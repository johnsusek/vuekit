declare global {
    export class K {
    }
    export class NSObject {
    }
    export class SSLProtocol {
    }
    export class tls_protocol_version_t {
    }
    export class CALayer {
    }
    export class CAMediaTimingFunction {
    }
    export class CGAffineTransform {
    }
    export class CIContext {
    }
    export class CIFilter {
    }
    export class CIImage {
    }
    export class CKContainer {
    }
    export class CKShare {
    }
    export class IndexPath {
    }
    export class Metadata {
    }
    export class NSAttributeType {
    }
    export class NSEntityDescription {
    }
    export class NSFetchRequest {
    }
    export class NSManagedObjectContext {
    }
    export class NSManagedObjectModel {
    }
    export class QLPreviewItem {
    }
    export enum NSURLSessionDelayedRequestDisposition {
    }
    export type OpaquePointer = any;
    export type NSFastEnumerationIterator = any;
    export type NSIndexSetIterator = any;
    export type IndexingIterator = any;
    export type Slice = any;
    export type CGPoint = NSPoint;
    export type CGRect = NSRect;
    export type CGSize = NSSize;
    class NSATSTypesetter extends NSTypesetter {
        static sharedTypesetter: NSATSTypesetter;
    }
    interface NSAccessibility extends NSObject {
        accessibilityActivationPoint: CGPoint;
        setAccessibilityActivationPoint(_: CGPoint): any;
        accessibilityAllowedValues: number[];
        setAccessibilityAllowedValues(_: number[]): any;
        isAccessibilityAlternateUIVisible: boolean;
        setAccessibilityAlternateUIVisible(_: boolean): any;
        accessibilityApplicationFocusedUIElement: any;
        setAccessibilityApplicationFocusedUIElement(_: any): any;
        accessibilityCancelButton: any;
        setAccessibilityCancelButton(_: any): any;
        accessibilityChildren: any[];
        setAccessibilityChildren(_: any[]): any;
        accessibilityChildrenInNavigationOrder: NSAccessibilityElement[];
        setAccessibilityChildrenInNavigationOrder(_: NSAccessibilityElement[]): any;
        accessibilityClearButton: any;
        setAccessibilityClearButton(_: any): any;
        accessibilityCloseButton: any;
        setAccessibilityCloseButton(_: any): any;
        accessibilityColumnCount: number;
        setAccessibilityColumnCount(_: number): any;
        accessibilityColumnHeaderUIElements: any[];
        setAccessibilityColumnHeaderUIElements(_: any[]): any;
        accessibilityColumnIndexRange: NSRange;
        setAccessibilityColumnIndexRange(_: NSRange): any;
        accessibilityColumns: any[];
        setAccessibilityColumns(_: any[]): any;
        accessibilityColumnTitles: any[];
        setAccessibilityColumnTitles(_: any[]): any;
        accessibilityContents: any[];
        setAccessibilityContents(_: any[]): any;
        accessibilityCriticalValue: any;
        setAccessibilityCriticalValue(_: any): any;
        accessibilityCustomActions: NSAccessibilityCustomAction[];
        setAccessibilityCustomActions(_: NSAccessibilityCustomAction[]): any;
        accessibilityCustomRotors: NSAccessibilityCustomRotor[];
        setAccessibilityCustomRotors(_: NSAccessibilityCustomRotor[]): any;
        accessibilityDecrementButton: any;
        setAccessibilityDecrementButton(_: any): any;
        accessibilityDefaultButton: any;
        setAccessibilityDefaultButton(_: any): any;
        isAccessibilityDisclosed: boolean;
        setAccessibilityDisclosed(_: boolean): any;
        accessibilityDisclosedByRow: any;
        setAccessibilityDisclosedByRow(_: any): any;
        accessibilityDisclosedRows: any;
        setAccessibilityDisclosedRows(_: any): any;
        accessibilityDisclosureLevel: number;
        setAccessibilityDisclosureLevel(_: number): any;
        accessibilityDocument: string;
        setAccessibilityDocument(_: string): any;
        isAccessibilityEdited: boolean;
        setAccessibilityEdited(_: boolean): any;
        isAccessibilityElement: boolean;
        setAccessibilityElement(_: boolean): any;
        isAccessibilityEnabled: boolean;
        setAccessibilityEnabled(_: boolean): any;
        isAccessibilityExpanded: boolean;
        setAccessibilityExpanded(_: boolean): any;
        accessibilityExtrasMenuBar: any;
        setAccessibilityExtrasMenuBar(_: any): any;
        accessibilityFilename: string;
        setAccessibilityFilename(_: string): any;
        isAccessibilityFocused: boolean;
        setAccessibilityFocused(_: boolean): any;
        accessibilityFocusedWindow: any;
        setAccessibilityFocusedWindow(_: any): any;
        accessibilityFrame: CGRect;
        setAccessibilityFrame(_: CGRect): any;
        isAccessibilityFrontmost: boolean;
        setAccessibilityFrontmost(_: boolean): any;
        accessibilityFullScreenButton: any;
        setAccessibilityFullScreenButton(_: any): any;
        accessibilityGrowArea: any;
        setAccessibilityGrowArea(_: any): any;
        accessibilityHandles: any[];
        setAccessibilityHandles(_: any[]): any;
        accessibilityHeader: any;
        setAccessibilityHeader(_: any): any;
        accessibilityHelp: string;
        setAccessibilityHelp(_: string): any;
        isAccessibilityHidden: boolean;
        setAccessibilityHidden(_: boolean): any;
        accessibilityHorizontalScrollBar: any;
        setAccessibilityHorizontalScrollBar(_: any): any;
        accessibilityHorizontalUnitDescription: string;
        setAccessibilityHorizontalUnitDescription(_: string): any;
        accessibilityHorizontalUnits: NSAccessibility.Units;
        setAccessibilityHorizontalUnits(_: NSAccessibility.Units): any;
        accessibilityIdentifier: string;
        setAccessibilityIdentifier(_: string): any;
        accessibilityIncrementButton: any;
        setAccessibilityIncrementButton(_: any): any;
        accessibilityIndex: number;
        setAccessibilityIndex(_: number): any;
        accessibilityInsertionPointLineNumber: number;
        setAccessibilityInsertionPointLineNumber(_: number): any;
        accessibilityLabel: string;
        setAccessibilityLabel(_: string): any;
        accessibilityLabelUIElements: any[];
        setAccessibilityLabelUIElements(_: any[]): any;
        accessibilityLabelValue: number;
        setAccessibilityLabelValue(_: number): any;
        accessibilityLinkedUIElements: any[];
        setAccessibilityLinkedUIElements(_: any[]): any;
        isAccessibilityMain: boolean;
        setAccessibilityMain(_: boolean): any;
        accessibilityMainWindow: any;
        setAccessibilityMainWindow(_: any): any;
        accessibilityMarkerGroupUIElement: any;
        setAccessibilityMarkerGroupUIElement(_: any): any;
        accessibilityMarkerTypeDescription: string;
        setAccessibilityMarkerTypeDescription(_: string): any;
        accessibilityMarkerUIElements: any[];
        setAccessibilityMarkerUIElements(_: any[]): any;
        accessibilityMarkerValues: any;
        setAccessibilityMarkerValues(_: any): any;
        accessibilityMaxValue: any;
        setAccessibilityMaxValue(_: any): any;
        accessibilityMenuBar: any;
        setAccessibilityMenuBar(_: any): any;
        accessibilityMinimizeButton: any;
        setAccessibilityMinimizeButton(_: any): any;
        isAccessibilityMinimized: boolean;
        setAccessibilityMinimized(_: boolean): any;
        accessibilityMinValue: any;
        setAccessibilityMinValue(_: any): any;
        isAccessibilityModal: boolean;
        setAccessibilityModal(_: boolean): any;
        accessibilityNextContents: any[];
        setAccessibilityNextContents(_: any[]): any;
        accessibilityNumberOfCharacters: number;
        setAccessibilityNumberOfCharacters(_: number): any;
        isAccessibilityOrderedByRow: boolean;
        setAccessibilityOrderedByRow(_: boolean): any;
        accessibilityOrientation: NSAccessibility.Orientation;
        setAccessibilityOrientation(_: NSAccessibility.Orientation): any;
        accessibilityOverflowButton: any;
        setAccessibilityOverflowButton(_: any): any;
        accessibilityParent: any;
        setAccessibilityParent(_: any): any;
        accessibilityPlaceholderValue: string;
        setAccessibilityPlaceholderValue(_: string): any;
        accessibilityPreviousContents: any[];
        setAccessibilityPreviousContents(_: any[]): any;
        isAccessibilityProtectedContent: boolean;
        setAccessibilityProtectedContent(_: boolean): any;
        accessibilityProxy: any;
        setAccessibilityProxy(_: any): any;
        isAccessibilityRequired: boolean;
        setAccessibilityRequired(_: boolean): any;
        accessibilityRole: string;
        setAccessibilityRole(_: string): any;
        accessibilityRoleDescription: string;
        setAccessibilityRoleDescription(_: string): any;
        accessibilityRowCount: number;
        setAccessibilityRowCount(_: number): any;
        accessibilityRowHeaderUIElements: any[];
        setAccessibilityRowHeaderUIElements(_: any[]): any;
        accessibilityRowIndexRange: NSRange;
        setAccessibilityRowIndexRange(_: NSRange): any;
        accessibilityRows: any[];
        setAccessibilityRows(_: any[]): any;
        accessibilityRulerMarkerType: NSAccessibility.RulerMarkerType;
        setAccessibilityRulerMarkerType(_: NSAccessibility.RulerMarkerType): any;
        accessibilitySearchButton: any;
        setAccessibilitySearchButton(_: any): any;
        accessibilitySearchMenu: any;
        setAccessibilitySearchMenu(_: any): any;
        isAccessibilitySelected: boolean;
        setAccessibilitySelected(_: boolean): any;
        accessibilitySelectedCells: any[];
        setAccessibilitySelectedCells(_: any[]): any;
        accessibilitySelectedChildren: any[];
        setAccessibilitySelectedChildren(_: any[]): any;
        accessibilitySelectedColumns: any[];
        setAccessibilitySelectedColumns(_: any[]): any;
        accessibilitySelectedRows: any[];
        setAccessibilitySelectedRows(_: any[]): any;
        accessibilitySelectedText: string;
        setAccessibilitySelectedText(_: string): any;
        accessibilitySelectedTextRange: NSRange;
        setAccessibilitySelectedTextRange(_: NSRange): any;
        accessibilitySelectedTextRanges: NSValue[];
        setAccessibilitySelectedTextRanges(_: NSValue[]): any;
        accessibilityServesAsTitleForUIElements: any[];
        setAccessibilityServesAsTitleForUIElements(_: any[]): any;
        accessibilitySharedCharacterRange: NSRange;
        setAccessibilitySharedCharacterRange(_: NSRange): any;
        accessibilitySharedFocusElements: any[];
        setAccessibilitySharedFocusElements(_: any[]): any;
        accessibilitySharedTextUIElements: any[];
        setAccessibilitySharedTextUIElements(_: any[]): any;
        accessibilityShownMenu: any;
        setAccessibilityShownMenu(_: any): any;
        accessibilitySortDirection: NSAccessibility.SortDirection;
        setAccessibilitySortDirection(_: NSAccessibility.SortDirection): any;
        accessibilitySplitters: any[];
        setAccessibilitySplitters(_: any[]): any;
        accessibilitySubrole: string;
        setAccessibilitySubrole(_: string): any;
        accessibilityTabs: any[];
        setAccessibilityTabs(_: any[]): any;
        accessibilityTitle: string;
        setAccessibilityTitle(_: string): any;
        accessibilityTitleUIElement: any;
        setAccessibilityTitleUIElement(_: any): any;
        accessibilityToolbarButton: any;
        setAccessibilityToolbarButton(_: any): any;
        accessibilityTopLevelUIElement: any;
        setAccessibilityTopLevelUIElement(_: any): any;
        accessibilityUnitDescription: string;
        setAccessibilityUnitDescription(_: string): any;
        accessibilityUnits: NSAccessibility.Units;
        setAccessibilityUnits(_: NSAccessibility.Units): any;
        accessibilityURL: NSURL;
        setAccessibilityURL(_: NSURL): any;
        accessibilityValue: any;
        setAccessibilityValue(_: any): any;
        accessibilityValueDescription: string;
        setAccessibilityValueDescription(_: string): any;
        accessibilityVerticalScrollBar: any;
        setAccessibilityVerticalScrollBar(_: any): any;
        accessibilityVerticalUnitDescription: string;
        setAccessibilityVerticalUnitDescription(_: string): any;
        accessibilityVerticalUnits: NSAccessibility.Units;
        setAccessibilityVerticalUnits(_: NSAccessibility.Units): any;
        accessibilityVisibleCells: any[];
        setAccessibilityVisibleCells(_: any[]): any;
        accessibilityVisibleCharacterRange: NSRange;
        setAccessibilityVisibleCharacterRange(_: NSRange): any;
        accessibilityVisibleChildren: any[];
        setAccessibilityVisibleChildren(_: any[]): any;
        accessibilityVisibleColumns: any[];
        setAccessibilityVisibleColumns(_: any[]): any;
        accessibilityVisibleRows: any[];
        setAccessibilityVisibleRows(_: any[]): any;
        accessibilityWarningValue: any;
        setAccessibilityWarningValue(_: any): any;
        accessibilityWindow: any;
        setAccessibilityWindow(_: any): any;
        accessibilityWindows: any[];
        setAccessibilityWindows(_: any[]): any;
        accessibilityZoomButton: any;
        setAccessibilityZoomButton(_: any): any;
        accessibilityAttributedStringForRange(_: NSRange): NSAttributedString;
        accessibilityCellForColumnRow(_: number, row: number): any;
        accessibilityFrameForRange(_: NSRange): CGRect;
        accessibilityLayoutPointForScreenPoint(_: CGPoint): CGPoint;
        accessibilityLayoutSizeForScreenSize(_: CGSize): CGSize;
        accessibilityLineForIndex(_: number): number;
        accessibilityPerformCancel(): boolean;
        accessibilityPerformConfirm(): boolean;
        accessibilityPerformDecrement(): boolean;
        accessibilityPerformDelete(): boolean;
        accessibilityPerformIncrement(): boolean;
        accessibilityPerformPick(): boolean;
        accessibilityPerformPress(): boolean;
        accessibilityPerformRaise(): boolean;
        accessibilityPerformShowAlternateUI(): boolean;
        accessibilityPerformShowDefaultUI(): boolean;
        accessibilityPerformShowMenu(): boolean;
        accessibilityRangeForIndex(_: number): NSRange;
        accessibilityRangeForLine(_: number): NSRange;
        accessibilityRangeForPosition(_: CGPoint): NSRange;
        accessibilityRTFForRange(_: NSRange): NSData;
        accessibilityScreenPointForLayoutPoint(_: CGPoint): CGPoint;
        accessibilityScreenSizeForLayoutSize(_: CGSize): CGSize;
        accessibilityStringForRange(_: NSRange): string;
        accessibilityStyleRangeForIndex(_: number): NSRange;
        isAccessibilitySelectorAllowed(_: string): boolean;
    }
    interface NSAccessibilityButton extends NSAccessibilityElement {
        accessibilityLabel(): string;
        accessibilityPerformPress(): boolean;
    }
    interface NSAccessibilityCheckBox extends NSAccessibilityButton {
        accessibilityValue(): number;
    }
    interface NSAccessibilityContainsTransientUI extends NSAccessibilityElement {
        accessibilityPerformShowAlternateUI(): boolean;
        accessibilityPerformShowDefaultUI(): boolean;
        isAccessibilityAlternateUIVisible(): boolean;
    }
    class NSAccessibilityCustomAction extends NSObject {
        handler: () => boolean;
        setHandler(_: () => boolean): any;
        name: string;
        setName(_: string): any;
        selector: string;
        setSelector(_: string): any;
        target: NSObject;
        setTarget(_: NSObject): any;
        static createWithNameHandler(name: string, handler?: () => boolean): NSAccessibilityCustomAction;
        static createWithNameTargetSelector(name: string, target: NSObject, selector: string): NSAccessibilityCustomAction;
    }
    class NSAccessibilityCustomRotor extends NSObject {
        itemLoadingDelegate: NSAccessibilityElementLoading;
        setItemLoadingDelegate(_: NSAccessibilityElementLoading): any;
        itemSearchDelegate: NSAccessibilityCustomRotorItemSearchDelegate;
        setItemSearchDelegate(_: NSAccessibilityCustomRotorItemSearchDelegate): any;
        label: string;
        setLabel(_: string): any;
        type: NSAccessibilityCustomRotor.RotorType;
        setType(_: NSAccessibilityCustomRotor.RotorType): any;
        static createWithLabelItemSearchDelegate(label: string, itemSearchDelegate: NSAccessibilityCustomRotorItemSearchDelegate): NSAccessibilityCustomRotor;
        static createWithRotorTypeItemSearchDelegate(rotorType: NSAccessibilityCustomRotor.RotorType, itemSearchDelegate: NSAccessibilityCustomRotorItemSearchDelegate): NSAccessibilityCustomRotor;
    }
    class ItemResult extends NSObject {
        customLabel: string;
        setCustomLabel(_: string): any;
        itemLoadingToken: any;
        targetElement: NSAccessibilityElement;
        targetRange: NSRange;
        setTargetRange(_: NSRange): any;
        static createWithItemLoadingTokenCustomLabel(itemLoadingToken: any, customLabel: string): ItemResult;
        static createWithTargetElement(targetElement: NSAccessibilityElement): ItemResult;
    }
    interface NSAccessibilityCustomRotorItemSearchDelegate extends NSObject {
        rotorResultForSearchParameters(_: NSAccessibilityCustomRotor, resultFor: SearchParameters): ItemResult;
    }
    class SearchParameters extends NSObject {
        currentItem: ItemResult;
        setCurrentItem(_: ItemResult): any;
        filterString: string;
        setFilterString(_: string): any;
        searchDirection: NSAccessibilityCustomRotor.SearchDirection;
        setSearchDirection(_: NSAccessibilityCustomRotor.SearchDirection): any;
    }
    class NSAccessibilityElement extends NSObject {
        static accessibilityElementWithRoleFrameLabelParent(withRole: string, frame: CGRect, label?: string, parent?: any): any;
        accessibilityFrameInParentSpace: CGRect;
        setAccessibilityFrameInParentSpace(_: CGRect): any;
        accessibilityAddChildElement(_: NSAccessibilityElement): void;
    }
    interface NSAccessibilityElementLoading extends NSObject {
        accessibilityElementWithToken(withToken: any): NSAccessibilityElement;
        accessibilityRangeInTargetElementWithToken?(withToken: any): NSRange;
    }
    interface NSAccessibilityElement extends NSObject {
        accessibilityFrame(): CGRect;
        accessibilityIdentifier?(): string;
        accessibilityParent(): any;
        isAccessibilityFocused?(): boolean;
    }
    interface NSAccessibilityGroup extends NSAccessibilityElement {
    }
    interface NSAccessibilityImage extends NSAccessibilityElement {
        accessibilityLabel(): string;
    }
    interface NSAccessibilityLayoutArea extends NSAccessibilityGroup {
        accessibilityFocusedUIElement: any;
        accessibilityChildren(): any[];
        accessibilityLabel(): string;
        accessibilitySelectedChildren(): any[];
    }
    interface NSAccessibilityLayoutItem extends NSAccessibilityGroup {
        setAccessibilityFrame?(_: CGRect): void;
    }
    interface NSAccessibilityList extends NSAccessibilityTable {
    }
    interface NSAccessibilityNavigableStaticText extends NSAccessibilityStaticText {
        accessibilityFrameForRange(for_: NSRange): CGRect;
        accessibilityLineForIndex(for_: number): number;
        accessibilityRangeForLine(forLine: number): NSRange;
        accessibilityStringForRange(for_: NSRange): string;
    }
    interface NSAccessibilityOutline extends NSAccessibilityTable {
    }
    interface NSAccessibilityProgressIndicator extends NSAccessibilityGroup {
        accessibilityValue(): number;
    }
    interface NSAccessibilityRadioButton extends NSAccessibilityButton {
        accessibilityValue(): number;
    }
    interface NSAccessibilityRow extends NSAccessibilityGroup {
        accessibilityDisclosureLevel?(): number;
        accessibilityIndex(): number;
    }
    interface NSAccessibilitySlider extends NSAccessibilityElement {
        accessibilityLabel(): string;
        accessibilityPerformDecrement(): boolean;
        accessibilityPerformIncrement(): boolean;
        accessibilityValue(): any;
    }
    interface NSAccessibilityStaticText extends NSAccessibilityElement {
        accessibilityAttributedStringForRange?(for_: NSRange): NSAttributedString;
        accessibilityValue(): string;
        accessibilityVisibleCharacterRange?(): NSRange;
    }
    interface NSAccessibilityStepper extends NSAccessibilityElement {
        accessibilityLabel(): string;
        accessibilityPerformDecrement(): boolean;
        accessibilityPerformIncrement(): boolean;
        accessibilityValue?(): any;
    }
    interface NSAccessibilitySwitch extends NSAccessibilityButton {
        accessibilityPerformDecrement?(): boolean;
        accessibilityPerformIncrement?(): boolean;
        accessibilityValue(): string;
    }
    interface NSAccessibilityTable extends NSAccessibilityGroup {
        accessibilityColumnHeaderUIElements?(): any[];
        accessibilityColumns?(): any[];
        accessibilityLabel(): string;
        accessibilityRowHeaderUIElements?(): any[];
        accessibilityRows(): NSAccessibilityRow[];
        accessibilitySelectedCells?(): any[];
        accessibilitySelectedColumns?(): any[];
        accessibilitySelectedRows?(): NSAccessibilityRow[];
        accessibilityVisibleCells?(): any[];
        accessibilityVisibleColumns?(): any[];
        accessibilityVisibleRows?(): NSAccessibilityRow[];
        setAccessibilitySelectedRows?(_: NSAccessibilityRow[]): void;
    }
    class NSActionCell extends NSCell {
    }
    class NSAlert extends NSObject {
        accessoryView: NSView;
        setAccessoryView(_: NSView): any;
        alertStyle: NSAlert.Style;
        setAlertStyle(_: NSAlert.Style): any;
        buttons: NSButton[];
        delegate: NSAlertDelegate;
        setDelegate(_: NSAlertDelegate): any;
        helpAnchor: string;
        setHelpAnchor(_: string): any;
        icon: NSImage;
        setIcon(_: NSImage): any;
        informativeText: string;
        setInformativeText(_: string): any;
        messageText: string;
        setMessageText(_: string): any;
        showsHelp: boolean;
        setShowsHelp(_: boolean): any;
        showsSuppressionButton: boolean;
        setShowsSuppressionButton(_: boolean): any;
        suppressionButton: NSButton;
        window: NSWindow;
        addButtonWithTitle(withTitle: string): NSButton;
        beginSheetModalForCompletionHandler(for_: NSWindow, completionHandler?: (p1: number) => void): void;
        layout(): void;
        runModal(): number;
    }
    interface NSAlertDelegate extends NSObject {
        alertShowHelp?(_: NSAlert): boolean;
    }
    class NSAlignmentFeedbackFilter extends NSObject {
        static inputEventMask: NSEvent.EventTypeMask;
        alignmentFeedbackTokenForHorizontalMovementInViewPreviousXAlignedXDefaultX(in_?: NSView, previousX?: number, alignedX?: number, defaultX?: number): NSAlignmentFeedbackToken;
        alignmentFeedbackTokenForMovementInViewPreviousPointAlignedPointDefaultPoint(in_?: NSView, previousPoint?: CGPoint, alignedPoint?: CGPoint, defaultPoint?: CGPoint): NSAlignmentFeedbackToken;
        alignmentFeedbackTokenForVerticalMovementInViewPreviousYAlignedYDefaultY(in_?: NSView, previousY?: number, alignedY?: number, defaultY?: number): NSAlignmentFeedbackToken;
        performFeedbackWithPerformanceTime(_: NSAlignmentFeedbackToken[], performanceTime: NSHapticFeedbackManager.PerformanceTime): void;
        updateWithEvent(with_: NSEvent): void;
        updateWithPanRecognizer(withPanRecognizer: NSPanGestureRecognizer): void;
    }
    interface NSAlignmentFeedbackToken extends NSObject {
    }
    interface NSAnimatablePropertyContainer {
        animations: Map<string, any>;
        setAnimations(_: Map<string, any>): any;
        animationForKey(forKey: string): any;
        animator(): NSAnimatablePropertyContainer;
    }
    class NSAnimation extends NSObject {
        isAnimating: boolean;
        animationBlockingMode: NSAnimation.BlockingMode;
        setAnimationBlockingMode(_: NSAnimation.BlockingMode): any;
        animationCurve: NSAnimation.Curve;
        setAnimationCurve(_: NSAnimation.Curve): any;
        currentProgress: number;
        setCurrentProgress(_: number): any;
        currentValue: number;
        delegate: NSAnimationDelegate;
        setDelegate(_: NSAnimationDelegate): any;
        duration: number;
        setDuration(_: number): any;
        frameRate: number;
        setFrameRate(_: number): any;
        progressMarks: number[];
        setProgressMarks(_: number[]): any;
        runLoopModesForAnimating: string[];
        addProgressMark(_: number): void;
        clearStartAnimation(): void;
        clearStopAnimation(): void;
        static createWithDurationAnimationCurve(duration: number, animationCurve: NSAnimation.Curve): NSAnimation;
        removeProgressMark(_: number): void;
        startAnimation(): void;
        startWhenAnimationReachesProgress(when: NSAnimation, reachesProgress: number): void;
        stopAnimation(): void;
        stopWhenAnimationReachesProgress(when: NSAnimation, reachesProgress: number): void;
    }
    class NSAnimationContext extends NSObject {
        static beginGrouping(): void;
        static endGrouping(): void;
        static runAnimationGroup(_: (p1: NSAnimationContext) => void): void;
        static runAnimationGroupWithCompletionHandler(_: (p1: NSAnimationContext) => void, completionHandler?: () => void): void;
        allowsImplicitAnimation: boolean;
        setAllowsImplicitAnimation(_: boolean): any;
        completionHandler: () => void;
        setCompletionHandler(_: () => void): any;
        duration: number;
        setDuration(_: number): any;
        timingFunction: CAMediaTimingFunction;
        setTimingFunction(_: CAMediaTimingFunction): any;
        static currentContext: NSAnimationContext;
    }
    interface NSAnimationDelegate extends NSObject {
        animationDidReachProgressMark?(_: NSAnimation, didReachProgressMark: number): void;
        animationValueForProgress?(_: NSAnimation, valueForProgress: number): number;
        animationDidEnd?(_: NSAnimation): void;
        animationDidStop?(_: NSAnimation): void;
        animationShouldStart?(_: NSAnimation): boolean;
    }
    class NSAppearance extends NSObject {
        allowsVibrancy: boolean;
        name: string;
        static currentAppearance: NSAppearance;
        setCurrentAppearance(_: NSAppearance): any;
        bestMatchFromAppearancesWithNames(from: string[]): string;
        static createWithAppearanceNamedBundle(appearanceNamed: string, bundle?: Bundle): NSAppearance;
    }
    interface NSAppearanceCustomization extends NSObject {
        appearance: NSAppearance;
        setAppearance(_: NSAppearance): any;
        effectiveAppearance: NSAppearance;
    }
    class NSApplication extends NSResponder {
        static detachDrawingThreadToTargetWithObject(_: string, toTarget: any, with_?: any): void;
        isActive: boolean;
        applicationIconImage: NSImage;
        setApplicationIconImage(_: NSImage): any;
        isAutomaticCustomizeTouchBarMenuItemEnabled: boolean;
        setAutomaticCustomizeTouchBarMenuItemEnabled(_: boolean): any;
        currentEvent: NSEvent;
        currentSystemPresentationOptions: NSApplication.PresentationOptions;
        delegate: NSApplicationDelegate;
        setDelegate(_: NSApplicationDelegate): any;
        dockTile: NSDockTile;
        enabledRemoteNotificationTypes: NSApplication.RemoteNotificationType;
        isFullKeyboardAccessEnabled: boolean;
        helpMenu: NSMenu;
        setHelpMenu(_: NSMenu): any;
        isHidden: boolean;
        keyWindow: NSWindow;
        mainMenu: NSMenu;
        setMainMenu(_: NSMenu): any;
        mainWindow: NSWindow;
        modalWindow: NSWindow;
        occlusionState: NSApplication.OcclusionState;
        orderedDocuments: NSDocument[];
        orderedWindows: NSWindow[];
        presentationOptions: NSApplication.PresentationOptions;
        setPresentationOptions(_: NSApplication.PresentationOptions): any;
        isRegisteredForRemoteNotifications: boolean;
        isRunning: boolean;
        servicesMenu: NSMenu;
        setServicesMenu(_: NSMenu): any;
        servicesProvider: any;
        setServicesProvider(_: any): any;
        userInterfaceLayoutDirection: NSUserInterfaceLayoutDirection;
        windows: NSWindow[];
        windowsMenu: NSMenu;
        setWindowsMenu(_: NSMenu): any;
        static sharedApplication: NSApplication;
        abortModal(): void;
        activateContextHelpMode(_?: any): void;
        activateIgnoringOtherApps(ignoringOtherApps: boolean): void;
        activationPolicy(): NSApplication.ActivationPolicy;
        addWindowsItemTitleFilename(_: NSWindow, title: string, filename: boolean): void;
        arrangeInFront(_?: any): void;
        beginModalSessionForWindow(for_: NSWindow): any;
        cancelUserAttentionRequest(_: number): void;
        changeWindowsItemTitleFilename(_: NSWindow, title: string, filename: boolean): void;
        completeStateRestoration(): void;
        deactivate(): void;
        disableRelaunchOnLogin(): void;
        discardEventsMatchingMaskBeforeEvent(matching: NSEvent.EventTypeMask, before?: NSEvent): void;
        enableRelaunchOnLogin(): void;
        endModalSession(_: any): void;
        enumerateWindowsWithOptionsUsing(options: NSApplication.WindowListOptions, using: (p1: NSWindow, p2: boolean) => void): void;
        extendStateRestoration(): void;
        finishLaunching(): void;
        hide(_?: any): void;
        hideOtherApplications(_?: any): void;
        miniaturizeAll(_?: any): void;
        nextEventMatchingMaskUntilDateInModeDequeue(matching: NSEvent.EventTypeMask, until?: Date, inMode?: string, dequeue?: boolean): NSEvent;
        orderFrontCharacterPalette(_?: any): void;
        orderFrontColorPanel(_?: any): void;
        orderFrontStandardAboutPanel(_?: any): void;
        orderFrontStandardAboutPanelWithOptions(options: Map<string, any>): void;
        postEventAtStart(_: NSEvent, atStart: boolean): void;
        preventWindowOrdering(): void;
        registerForRemoteNotificationTypes(matching: NSApplication.RemoteNotificationType): void;
        registerForRemoteNotifications(): void;
        registerServicesMenuSendTypesReturnTypes(_: string[], returnTypes: string[]): void;
        registerUserInterfaceItemSearchHandler(_: NSUserInterfaceItemSearching): void;
        removeWindowsItem(_: NSWindow): void;
        replyToApplicationShouldTerminate(toApplicationShouldTerminate: boolean): void;
        replyToOpenOrPrint(toOpenOrPrint: NSApplication.DelegateReply): void;
        reportException(_: NSException): void;
        requestUserAttention(_: NSApplication.RequestUserAttentionType): number;
        restoreWindowWithWithIdentifierStateCompletionHandler(withIdentifier: string, state: NSCoder, completionHandler?: (p1: NSWindow, p2: NSError) => void): boolean;
        run(): void;
        runModalForWindow(for_: NSWindow): number;
        runModalSession(_: any): number;
        runPageLayout(_?: any): void;
        searchStringInUserInterfaceItemStringSearchRangeFoundRange(_: string, inUserInterfaceItemString: string, range: NSRange, found?: NSRange): boolean;
        sendActionToFrom(_: string, to?: any, from?: any): boolean;
        sendEvent(_: NSEvent): void;
        setActivationPolicy(_: NSApplication.ActivationPolicy): boolean;
        setWindowsNeedUpdate(_: boolean): void;
        showHelp(_?: any): void;
        stop(_?: any): void;
        stopModal(): void;
        stopModalWithCode(withCode: number): void;
        targetForAction(forAction: string): any;
        targetForActionToFrom(forAction: string, to?: any, from?: any): any;
        terminate(_?: any): void;
        toggleTouchBarCustomizationPalette(_?: any): void;
        unhide(_?: any): void;
        unhideAllApplications(_?: any): void;
        unhideWithoutActivation(): void;
        unregisterForRemoteNotifications(): void;
        unregisterUserInterfaceItemSearchHandler(_: NSUserInterfaceItemSearching): void;
        updateWindows(): void;
        updateWindowsItem(_: NSWindow): void;
        windowWithWindowNumber(withWindowNumber: number): NSWindow;
    }
    interface NSApplicationDelegate extends NSObject {
        applicationContinueRestorationHandler?(_: NSApplication, continue_: NSUserActivity, restorationHandler: (p1: NSUserActivityRestoring[]) => void): boolean;
        applicationOpenURLs?(_: NSApplication, open: NSURL[]): void;
        applicationUserDidAcceptCloudKitShareWithMetadata?(_: NSApplication, userDidAcceptCloudKitShareWith: Metadata): void;
        applicationDidUpdateUserActivity?(_: NSApplication, didUpdate: NSUserActivity): void;
        applicationDelegateHandlesKey?(_: NSApplication, delegateHandlesKey: string): boolean;
        applicationDidDecodeRestorableState?(_: NSApplication, didDecodeRestorableState: NSCoder): void;
        applicationDidFailToContinueUserActivityWithTypeError?(_: NSApplication, didFailToContinueUserActivityWithType: string, error: NSError): void;
        applicationDidFailToRegisterForRemoteNotificationsWithError?(_: NSApplication, didFailToRegisterForRemoteNotificationsWithError: NSError): void;
        applicationDidReceiveRemoteNotification?(_: NSApplication, didReceiveRemoteNotification: Map<string, any>): void;
        applicationDidRegisterForRemoteNotificationsWithDeviceToken?(_: NSApplication, didRegisterForRemoteNotificationsWithDeviceToken: NSData): void;
        applicationOpenFile?(_: NSApplication, openFile: string): boolean;
        applicationOpenFiles?(_: NSApplication, openFiles: string[]): void;
        applicationOpenFileWithoutUI?(_: any, openFileWithoutUI: string): boolean;
        applicationOpenTempFile?(_: NSApplication, openTempFile: string): boolean;
        applicationPrintFile?(_: NSApplication, printFile: string): boolean;
        applicationPrintFilesWithSettingsShowPrintPanels?(_: NSApplication, printFiles: string[], withSettings: Map<string, any>, showPrintPanels: boolean): NSApplication.PrintReply;
        applicationWillContinueUserActivityWithType?(_: NSApplication, willContinueUserActivityWithType: string): boolean;
        applicationWillEncodeRestorableState?(_: NSApplication, willEncodeRestorableState: NSCoder): void;
        applicationWillPresentError?(_: NSApplication, willPresentError: NSError): NSError;
        applicationDidBecomeActive?(_: NSNotification): void;
        applicationDidChangeOcclusionState?(_: NSNotification): void;
        applicationDidChangeScreenParameters?(_: NSNotification): void;
        applicationDidFinishLaunching?(_: NSNotification): void;
        applicationDidHide?(_: NSNotification): void;
        applicationDidResignActive?(_: NSNotification): void;
        applicationDidUnhide?(_: NSNotification): void;
        applicationDidUpdate?(_: NSNotification): void;
        applicationDockMenu?(_: NSApplication): NSMenu;
        applicationOpenUntitledFile?(_: NSApplication): boolean;
        applicationShouldHandleReopenHasVisibleWindows?(_: NSApplication, hasVisibleWindows: boolean): boolean;
        applicationShouldOpenUntitledFile?(_: NSApplication): boolean;
        applicationShouldTerminate?(_: NSApplication): NSApplication.TerminateReply;
        applicationShouldTerminateAfterLastWindowClosed?(_: NSApplication): boolean;
        applicationWillBecomeActive?(_: NSNotification): void;
        applicationWillFinishLaunching?(_: NSNotification): void;
        applicationWillHide?(_: NSNotification): void;
        applicationWillResignActive?(_: NSNotification): void;
        applicationWillTerminate?(_: NSNotification): void;
        applicationWillUnhide?(_: NSNotification): void;
        applicationWillUpdate?(_: NSNotification): void;
    }
    class NSArrayController extends NSObjectController {
        alwaysUsesMultipleValuesMarker: boolean;
        setAlwaysUsesMultipleValuesMarker(_: boolean): any;
        arrangedObjects: any;
        automaticRearrangementKeyPaths: string[];
        automaticallyRearrangesObjects: boolean;
        setAutomaticallyRearrangesObjects(_: boolean): any;
        avoidsEmptySelection: boolean;
        setAvoidsEmptySelection(_: boolean): any;
        canInsert: boolean;
        canSelectNext: boolean;
        canSelectPrevious: boolean;
        clearsFilterPredicateOnInsertion: boolean;
        setClearsFilterPredicateOnInsertion(_: boolean): any;
        filterPredicate: NSPredicate;
        setFilterPredicate(_: NSPredicate): any;
        preservesSelection: boolean;
        setPreservesSelection(_: boolean): any;
        selectionIndex: number;
        selectionIndexes: NSIndexSet;
        selectsInsertedObjects: boolean;
        setSelectsInsertedObjects(_: boolean): any;
        sortDescriptors: NSSortDescriptor[];
        setSortDescriptors(_: NSSortDescriptor[]): any;
        addObjects(contentsOf: any[]): void;
        addSelectedObjects(_: any[]): boolean;
        addSelectionIndexes(_: NSIndexSet): boolean;
        arrangeObjects(_: any[]): any[];
        didChangeArrangementCriteria(): void;
        insert(_?: any): void;
        insertObjectAtArrangedObjectIndex(_: any, atArrangedObjectIndex: number): void;
        insertObjectsAtArrangedObjectIndexes(contentsOf: any[], atArrangedObjectIndexes: NSIndexSet): void;
        rearrangeObjects(): void;
        removeObjectAtArrangedObjectIndex(atArrangedObjectIndex: number): void;
        removeObjects(contentsOf: any[]): void;
        removeObjectsAtArrangedObjectIndexes(atArrangedObjectIndexes: NSIndexSet): void;
        removeSelectedObjects(_: any[]): boolean;
        removeSelectionIndexes(_: NSIndexSet): boolean;
        selectNext(_?: any): void;
        selectPrevious(_?: any): void;
        setSelectedObjects(_: any[]): boolean;
        setSelectionIndex(_: number): boolean;
        setSelectionIndexes(_: NSIndexSet): boolean;
    }
    class NSBezierPath extends NSObject {
        static clipRect(_: CGRect): void;
        static drawPackedGlyphsAtPoint(_: string, at: CGPoint): void;
        static fillRect(_: CGRect): void;
        static strokeLineFromPointToPoint(from: CGPoint, to: CGPoint): void;
        static strokeRect(_: CGRect): void;
        bezierPathByFlatteningPath: NSBezierPath;
        bezierPathByReversingPath: NSBezierPath;
        bounds: CGRect;
        controlPointBounds: CGRect;
        currentPoint: CGPoint;
        elementCount: number;
        isEmpty: boolean;
        flatness: number;
        setFlatness(_: number): any;
        lineCapStyle: NSBezierPath.LineCapStyle;
        setLineCapStyle(_: NSBezierPath.LineCapStyle): any;
        lineJoinStyle: NSBezierPath.LineJoinStyle;
        setLineJoinStyle(_: NSBezierPath.LineJoinStyle): any;
        lineWidth: number;
        setLineWidth(_: number): any;
        miterLimit: number;
        setMiterLimit(_: number): any;
        windingRule: NSBezierPath.WindingRule;
        setWindingRule(_: NSBezierPath.WindingRule): any;
        static defaultFlatness: number;
        setDefaultFlatness(_: number): any;
        static defaultLineCapStyle: NSBezierPath.LineCapStyle;
        setDefaultLineCapStyle(_: NSBezierPath.LineCapStyle): any;
        static defaultLineJoinStyle: NSBezierPath.LineJoinStyle;
        setDefaultLineJoinStyle(_: NSBezierPath.LineJoinStyle): any;
        static defaultLineWidth: number;
        setDefaultLineWidth(_: number): any;
        static defaultMiterLimit: number;
        setDefaultMiterLimit(_: number): any;
        static defaultWindingRule: NSBezierPath.WindingRule;
        setDefaultWindingRule(_: NSBezierPath.WindingRule): any;
        addClip(): void;
        appendBezierPath(_: NSBezierPath): void;
        appendBezierPathWithArcFromPointToPointRadius(from: CGPoint, to: CGPoint, radius: number): void;
        appendBezierPathWithArcWithCenterRadiusStartAngleEndAngle(withCenter: CGPoint, radius: number, startAngle: number, endAngle: number): void;
        appendBezierPathWithArcWithCenterRadiusStartAngleEndAngleClockwise(withCenter: CGPoint, radius: number, startAngle: number, endAngle: number, clockwise: boolean): void;
        appendBezierPathWithCGGlyphInFont(withCGGlyph: number, in_: NSFont): void;
        appendBezierPathWithCGGlyphsCountInFont(withCGGlyphs: number, count: number, in_: NSFont): void;
        appendBezierPathWithOvalInRect(in_: CGRect): void;
        appendBezierPathWithPointsCount(_: NSPoint, count: number): void;
        appendBezierPathWithRect(_: CGRect): void;
        appendBezierPathWithRoundedRectXRadiusYRadius(_: CGRect, xRadius: number, yRadius: number): void;
        closePath(): void;
        containsPoint(_: CGPoint): boolean;
        curveToPointControlPoint1ControlPoint2(to: CGPoint, controlPoint1: CGPoint, controlPoint2: CGPoint): void;
        elementAtIndex(at: number): NSBezierPath.ElementType;
        elementAtIndexAssociatedPoints(at: number, associatedPoints?: NSPoint): NSBezierPath.ElementType;
        fill(): void;
        getLineDashCountPhase(_?: number, count?: number, phase?: number): void;
        lineToPoint(to: CGPoint): void;
        moveToPoint(to: CGPoint): void;
        relativeCurveToPointControlPoint1ControlPoint2(to: CGPoint, controlPoint1: CGPoint, controlPoint2: CGPoint): void;
        relativeLineToPoint(to: CGPoint): void;
        relativeMoveToPoint(to: CGPoint): void;
        removeAllPoints(): void;
        setAssociatedPointsAtIndex(_?: NSPoint, at?: number): void;
        setClip(): void;
        setLineDashCountPhase(_?: number, count?: number, phase?: number): void;
        stroke(): void;
        transformUsingAffineTransform(using: NSAffineTransform): void;
    }
    class NSBindingSelectionMarker extends NSObject {
        static defaultPlaceholderForMarkerOnClassWithBinding(for_?: NSBindingSelectionMarker, on?: typeof NSObject, withBinding?: string): any;
        static setDefaultPlaceholderForMarkerOnClassWithBinding(_?: any, for_?: NSBindingSelectionMarker, on?: typeof NSObject, withBinding?: string): void;
        static multipleValuesSelectionMarker: NSBindingSelectionMarker;
        static noSelectionMarker: NSBindingSelectionMarker;
        static notApplicableSelectionMarker: NSBindingSelectionMarker;
    }
    class NSBitmapImageRep extends NSImageRep {
        static TIFFRepresentationOfImageRepsInArray(in_: NSImageRep[]): NSData;
        static TIFFRepresentationOfImageRepsInArrayUsingCompressionFactor(in_: NSImageRep[], using: NSBitmapImageRep.TIFFCompression, factor: number): NSData;
        static getTIFFCompressionTypesCount(_?: NSBitmapImageRep.TIFFCompression, count?: number): void;
        static imageRepsWithData(with_: NSData): NSImageRep[];
        static localizedNameForTIFFCompressionType(forTIFFCompressionType: NSBitmapImageRep.TIFFCompression): string;
        static representationOfImageRepsInArrayUsingTypeProperties(in_: NSImageRep[], using: NSBitmapImageRep.FileType, properties: Map<string, any>): NSData;
        CGImage: any;
        TIFFRepresentation: NSData;
        bitmapData: string;
        bitmapFormat: NSBitmapImageRep.Format;
        bitsPerPixel: number;
        bytesPerPlane: number;
        bytesPerRow: number;
        colorSpace: NSColorSpace;
        numberOfPlanes: number;
        isPlanar: boolean;
        samplesPerPixel: number;
        TIFFRepresentationUsingCompressionFactor(using: NSBitmapImageRep.TIFFCompression, factor: number): NSData;
        bitmapImageRepByConvertingToColorSpaceRenderingIntent(to: NSColorSpace, renderingIntent: NSColorRenderingIntent): NSBitmapImageRep;
        bitmapImageRepByRetaggingWithColorSpace(with_: NSColorSpace): NSBitmapImageRep;
        canBeCompressedUsing(using: NSBitmapImageRep.TIFFCompression): boolean;
        colorAtXY(x: number, y: number): NSColor;
        colorizeByMappingGrayToColorBlackMappingWhiteMapping(byMappingGray: number, to?: NSColor, blackMapping?: NSColor, whiteMapping?: NSColor): void;
        getBitmapDataPlanes(_?: string): void;
        getCompressionFactor(_?: NSBitmapImageRep.TIFFCompression, factor?: number): void;
        getPixelAtXY(_: number, atX: number, y: number): void;
        incrementalLoadFromDataComplete(from: NSData, complete: boolean): number;
        static createWithForIncrementalLoad(): NSBitmapImageRep;
        static createWithBitmapDataPlanesPixelsWidePixelsHighBitsPerSampleSamplesPerPixelHasAlphaIsPlanarColorSpaceNameBitmapFormatBytesPerRowBitsPerPixel(bitmapDataPlanes?: string, pixelsWide?: number, pixelsHigh?: number, bitsPerSample?: number, samplesPerPixel?: number, hasAlpha?: boolean, isPlanar?: boolean, colorSpaceName?: string, bitmapFormat?: NSBitmapImageRep.Format, bytesPerRow?: number, bitsPerPixel?: number): NSBitmapImageRep;
        static createWithBitmapDataPlanesPixelsWidePixelsHighBitsPerSampleSamplesPerPixelHasAlphaIsPlanarColorSpaceNameBytesPerRowBitsPerPixel(bitmapDataPlanes?: string, pixelsWide?: number, pixelsHigh?: number, bitsPerSample?: number, samplesPerPixel?: number, hasAlpha?: boolean, isPlanar?: boolean, colorSpaceName?: string, bytesPerRow?: number, bitsPerPixel?: number): NSBitmapImageRep;
        static createWithCGImage(CGImage: any): NSBitmapImageRep;
        static createWithCIImage(CIImage: CIImage): NSBitmapImageRep;
        static createWithData(data: NSData): NSBitmapImageRep;
        representationUsingTypeProperties(using: NSBitmapImageRep.FileType, properties: Map<string, any>): NSData;
        setColorAtXY(_: NSColor, atX: number, y: number): void;
        setCompressionFactor(_: NSBitmapImageRep.TIFFCompression, factor: number): void;
        setPixelAtXY(_: number, atX: number, y: number): void;
        setPropertyWithValue(_: string, withValue?: any): void;
        valueForProperty(forProperty: string): any;
    }
    class NSBox extends NSView {
        borderColor: NSColor;
        setBorderColor(_: NSColor): any;
        borderRect: CGRect;
        borderWidth: number;
        setBorderWidth(_: number): any;
        boxType: NSBox.BoxType;
        setBoxType(_: NSBox.BoxType): any;
        contentView: NSView;
        setContentView(_: NSView): any;
        contentViewMargins: CGSize;
        setContentViewMargins(_: CGSize): any;
        cornerRadius: number;
        setCornerRadius(_: number): any;
        fillColor: NSColor;
        setFillColor(_: NSColor): any;
        title: string;
        setTitle(_: string): any;
        titleCell: any;
        titleFont: NSFont;
        setTitleFont(_: NSFont): any;
        titlePosition: NSBox.TitlePosition;
        setTitlePosition(_: NSBox.TitlePosition): any;
        titleRect: CGRect;
        isTransparent: boolean;
        setTransparent(_: boolean): any;
        setFrameFromContentFrame(_: CGRect): void;
        sizeToFit(): void;
    }
    class NSBrowser extends NSControl {
        static removeSavedColumnsWithAutosaveName(withAutosaveName: string): void;
        allowsBranchSelection: boolean;
        setAllowsBranchSelection(_: boolean): any;
        allowsEmptySelection: boolean;
        setAllowsEmptySelection(_: boolean): any;
        allowsMultipleSelection: boolean;
        setAllowsMultipleSelection(_: boolean): any;
        allowsTypeSelect: boolean;
        setAllowsTypeSelect(_: boolean): any;
        autohidesScroller: boolean;
        setAutohidesScroller(_: boolean): any;
        backgroundColor: NSColor;
        setBackgroundColor(_: NSColor): any;
        cellPrototype: any;
        setCellPrototype(_: any): any;
        clickedColumn: number;
        clickedRow: number;
        columnResizingType: NSBrowser.ColumnResizingType;
        setColumnResizingType(_: NSBrowser.ColumnResizingType): any;
        columnsAutosaveName: string;
        setColumnsAutosaveName(_: string): any;
        delegate: NSBrowserDelegate;
        setDelegate(_: NSBrowserDelegate): any;
        doubleAction: string;
        setDoubleAction(_: string): any;
        firstVisibleColumn: number;
        hasHorizontalScroller: boolean;
        setHasHorizontalScroller(_: boolean): any;
        lastColumn: number;
        setLastColumn(_: number): any;
        lastVisibleColumn: number;
        isLoaded: boolean;
        maxVisibleColumns: number;
        setMaxVisibleColumns(_: number): any;
        minColumnWidth: number;
        setMinColumnWidth(_: number): any;
        numberOfVisibleColumns: number;
        pathSeparator: string;
        setPathSeparator(_: string): any;
        prefersAllColumnUserResizing: boolean;
        setPrefersAllColumnUserResizing(_: boolean): any;
        reusesColumns: boolean;
        setReusesColumns(_: boolean): any;
        rowHeight: number;
        setRowHeight(_: number): any;
        selectedCells: NSCell[];
        selectedColumn: number;
        selectionIndexPath: NSIndexPath;
        setSelectionIndexPath(_: NSIndexPath): any;
        selectionIndexPaths: NSIndexPath[];
        setSelectionIndexPaths(_: NSIndexPath[]): any;
        sendsActionOnArrowKeys: boolean;
        setSendsActionOnArrowKeys(_: boolean): any;
        separatesColumns: boolean;
        setSeparatesColumns(_: boolean): any;
        takesTitleFromPreviousColumn: boolean;
        setTakesTitleFromPreviousColumn(_: boolean): any;
        titleHeight: number;
        isTitled: boolean;
        setTitled(_: boolean): any;
        static cellClass: typeof NSObject;
        addColumn(): void;
        canDragRowsWithIndexesInColumnWithEvent(with_: NSIndexSet, inColumn: number, with_2: NSEvent): boolean;
        columnContentWidthForColumnWidth(forColumnWidth: number): number;
        columnWidthForColumnContentWidth(forColumnContentWidth: number): number;
        defaultColumnWidth(): number;
        doClick(_?: any): void;
        doDoubleClick(_?: any): void;
        draggingImageForRowsWithIndexesInColumnWithEventOffset(with_: NSIndexSet, inColumn: number, with_2: NSEvent, offset?: NSPoint): NSImage;
        drawTitleOfColumnInRect(ofColumn: number, in_: CGRect): void;
        editItemAtIndexPathWithEventSelect(at: NSIndexPath, with_?: NSEvent, select?: boolean): void;
        frameOfColumn(ofColumn: number): CGRect;
        frameOfInsideOfColumn(ofInsideOfColumn: number): CGRect;
        frameOfRowInColumn(ofRow: number, inColumn: number): CGRect;
        getRowColumnForPoint(_?: number, column?: number, for_?: CGPoint): boolean;
        indexPathForColumn(forColumn: number): NSIndexPath;
        isLeafItem(_?: any): boolean;
        itemAtIndexPath(at: NSIndexPath): any;
        itemAtRowInColumn(atRow: number, inColumn: number): any;
        loadColumnZero(): void;
        loadedCellAtRowColumn(atRow: number, column: number): any;
        noteHeightOfRowsWithIndexesChangedInColumn(_: NSIndexSet, inColumn: number): void;
        parentForItemsInColumn(inColumn: number): any;
        path(): string;
        pathToColumn(toColumn: number): string;
        reloadColumn(_: number): void;
        reloadDataForRowIndexesInColumn(forRowIndexes: NSIndexSet, inColumn: number): void;
        scrollColumnToVisible(_: number): void;
        scrollColumnsLeftBy(by: number): void;
        scrollColumnsRightBy(by: number): void;
        scrollRowToVisibleInColumn(_: number, inColumn: number): void;
        selectRowInColumn(_: number, inColumn: number): void;
        selectRowIndexesInColumn(_: NSIndexSet, inColumn: number): void;
        selectedCellInColumn(inColumn: number): any;
        selectedRowInColumn(inColumn: number): number;
        selectedRowIndexesInColumn(inColumn: number): NSIndexSet;
        sendAction(): boolean;
        setCellClass(_: typeof NSObject): void;
        setDefaultColumnWidth(_: number): void;
        setDraggingSourceOperationMaskForLocal(_: NSDragOperation, forLocal: boolean): void;
        setPath(_: string): boolean;
        setTitleOfColumn(_: string, ofColumn: number): void;
        setWidthOfColumn(_: number, ofColumn: number): void;
        tile(): void;
        titleFrameOfColumn(ofColumn: number): CGRect;
        titleOfColumn(ofColumn: number): string;
        validateVisibleColumns(): void;
        widthOfColumn(ofColumn: number): number;
    }
    class NSBrowserCell extends NSCell {
        alternateImage: NSImage;
        setAlternateImage(_: NSImage): any;
        isLeaf: boolean;
        setLeaf(_: boolean): any;
        isLoaded: boolean;
        setLoaded(_: boolean): any;
        static branchImage: NSImage;
        static highlightedBranchImage: NSImage;
        highlightColorInView(in_: NSView): NSColor;
        reset(): void;
        set(): void;
    }
    interface NSBrowserDelegate extends NSObject {
        browserCreateRowsForColumnInMatrix?(_: NSBrowser, createRowsForColumn: number, in_: NSMatrix): void;
        browserNextTypeSelectMatchFromRowToRowInColumnForString?(_: NSBrowser, nextTypeSelectMatchFromRow: number, toRow: number, inColumn: number, for_?: string): number;
        browserShouldTypeSelectForEventWithCurrentSearchString?(_: NSBrowser, shouldTypeSelectFor: NSEvent, withCurrentSearch?: string): boolean;
        browserSelectCellWithStringInColumn?(_: NSBrowser, selectCellWith: string, inColumn: number): boolean;
        browserDraggingImageForRowsWithIndexesInColumnWithEventOffset?(_: NSBrowser, draggingImageForRowsWith: NSIndexSet, inColumn: number, with_: NSEvent, offset: NSPoint): NSImage;
        browserCanDragRowsWithIndexesInColumnWithEvent?(_: NSBrowser, canDragRowsWith: NSIndexSet, inColumn: number, with_: NSEvent): boolean;
        browserWriteRowsWithIndexesInColumnToPasteboard?(_: NSBrowser, writeRowsWith: NSIndexSet, inColumn: number, to: NSPasteboard): boolean;
        browserAcceptDropAtRowColumnDropOperation?(_: NSBrowser, acceptDrop: NSDraggingInfo, atRow: number, column: number, dropOperation: NSBrowser.DropOperation): boolean;
        browserChildOfItem?(_: NSBrowser, child: number, ofItem?: any): any;
        browserDidChangeLastColumnToColumn?(_: NSBrowser, didChangeLastColumn: number, toColumn: number): void;
        browserHeaderViewControllerForItem?(_: NSBrowser, headerViewControllerForItem?: any): NSViewController;
        browserHeightOfRowInColumn?(_: NSBrowser, heightOfRow: number, inColumn: number): number;
        browserIsColumnValid?(_: NSBrowser, isColumnValid: number): boolean;
        browserIsLeafItem?(_: NSBrowser, isLeafItem?: any): boolean;
        browserNumberOfChildrenOfItem?(_: NSBrowser, numberOfChildrenOfItem?: any): number;
        browserNumberOfRowsInColumn?(_: NSBrowser, numberOfRowsInColumn: number): number;
        browserObjectValueForItem?(_: NSBrowser, objectValueForItem?: any): any;
        browserPreviewViewControllerForLeafItem?(_: NSBrowser, previewViewControllerForLeafItem: any): NSViewController;
        browserSelectionIndexesForProposedSelectionInColumn?(_: NSBrowser, selectionIndexesForProposedSelection: NSIndexSet, inColumn: number): NSIndexSet;
        browserSelectRowInColumn?(_: NSBrowser, selectRow: number, inColumn: number): boolean;
        browserSetObjectValueForItem?(_: NSBrowser, setObjectValue?: any, forItem?: any): void;
        browserShouldEditItem?(_: NSBrowser, shouldEditItem?: any): boolean;
        browserShouldShowCellExpansionForRowColumn?(_: NSBrowser, shouldShowCellExpansionForRow: number, column: number): boolean;
        browserShouldSizeColumnForUserResizeToWidth?(_: NSBrowser, shouldSizeColumn: number, forUserResize: boolean, toWidth: number): number;
        browserSizeToFitWidthOfColumn?(_: NSBrowser, sizeToFitWidthOfColumn: number): number;
        browserTitleOfColumn?(_: NSBrowser, titleOfColumn: number): string;
        browserTypeSelectStringForRowInColumn?(_: NSBrowser, typeSelectStringForRow: number, inColumn: number): string;
        browserValidateDropProposedRowColumnDropOperation?(_: NSBrowser, validateDrop: NSDraggingInfo, proposedRow: number, column: number, dropOperation: NSBrowser.DropOperation): NSDragOperation;
        browserWillDisplayCellAtRowColumn?(_: NSBrowser, willDisplayCell: any, atRow: number, column: number): void;
        browserColumnConfigurationDidChange?(_: NSNotification): void;
        browserDidScroll?(_: NSBrowser): void;
        browserWillScroll?(_: NSBrowser): void;
        rootItemForBrowser?(for_: NSBrowser): any;
    }
    class NSButton extends NSControl {
        static checkboxWithTitleTargetAction(checkboxWithTitle: string, target?: any, action?: string): NSButton;
        static radioButtonWithTitleTargetAction(radioButtonWithTitle: string, target?: any, action?: string): NSButton;
        allowsMixedState: boolean;
        setAllowsMixedState(_: boolean): any;
        alternateImage: NSImage;
        setAlternateImage(_: NSImage): any;
        alternateTitle: string;
        setAlternateTitle(_: string): any;
        attributedAlternateTitle: NSAttributedString;
        setAttributedAlternateTitle(_: NSAttributedString): any;
        attributedTitle: NSAttributedString;
        setAttributedTitle(_: NSAttributedString): any;
        bezelColor: NSColor;
        setBezelColor(_: NSColor): any;
        bezelStyle: NSButton.BezelStyle;
        setBezelStyle(_: NSButton.BezelStyle): any;
        isBordered: boolean;
        setBordered(_: boolean): any;
        contentTintColor: NSColor;
        setContentTintColor(_: NSColor): any;
        image: NSImage;
        setImage(_: NSImage): any;
        imageHugsTitle: boolean;
        setImageHugsTitle(_: boolean): any;
        imagePosition: NSControl.ImagePosition;
        setImagePosition(_: NSControl.ImagePosition): any;
        imageScaling: NSImageScaling;
        setImageScaling(_: NSImageScaling): any;
        keyEquivalent: string;
        setKeyEquivalent(_: string): any;
        keyEquivalentModifierMask: NSEvent.ModifierFlags;
        setKeyEquivalentModifierMask(_: NSEvent.ModifierFlags): any;
        maxAcceleratorLevel: number;
        setMaxAcceleratorLevel(_: number): any;
        showsBorderOnlyWhileMouseInside: boolean;
        setShowsBorderOnlyWhileMouseInside(_: boolean): any;
        sound: NSSound;
        setSound(_: NSSound): any;
        isSpringLoaded: boolean;
        setSpringLoaded(_: boolean): any;
        state: number;
        setState(_: number): any;
        title: string;
        setTitle(_: string): any;
        isTransparent: boolean;
        setTransparent(_: boolean): any;
        getPeriodicDelayInterval(_: number, interval: number): void;
        highlight(_: boolean): void;
        setButtonType(_: NSButton.ButtonType): void;
        setNextState(): void;
        setPeriodicDelayInterval(_: number, interval: number): void;
    }
    class NSButtonCell extends NSActionCell {
        alternateImage: NSImage;
        setAlternateImage(_: NSImage): any;
        alternateTitle: string;
        setAlternateTitle(_: string): any;
        attributedAlternateTitle: NSAttributedString;
        setAttributedAlternateTitle(_: NSAttributedString): any;
        attributedTitle: NSAttributedString;
        setAttributedTitle(_: NSAttributedString): any;
        backgroundColor: NSColor;
        setBackgroundColor(_: NSColor): any;
        bezelStyle: NSButton.BezelStyle;
        setBezelStyle(_: NSButton.BezelStyle): any;
        highlightsBy: NSCell.StyleMask;
        setHighlightsBy(_: NSCell.StyleMask): any;
        imageDimsWhenDisabled: boolean;
        setImageDimsWhenDisabled(_: boolean): any;
        imagePosition: NSControl.ImagePosition;
        setImagePosition(_: NSControl.ImagePosition): any;
        imageScaling: NSImageScaling;
        setImageScaling(_: NSImageScaling): any;
        keyEquivalentModifierMask: NSEvent.ModifierFlags;
        setKeyEquivalentModifierMask(_: NSEvent.ModifierFlags): any;
        showsBorderOnlyWhileMouseInside: boolean;
        setShowsBorderOnlyWhileMouseInside(_: boolean): any;
        showsStateBy: NSCell.StyleMask;
        setShowsStateBy(_: NSCell.StyleMask): any;
        sound: NSSound;
        setSound(_: NSSound): any;
        isTransparent: boolean;
        setTransparent(_: boolean): any;
        drawBezelWithFrameInView(withFrame: CGRect, in_: NSView): void;
        drawImageWithFrameInView(_: NSImage, withFrame: CGRect, in_: NSView): void;
        drawTitleWithFrameInView(_: NSAttributedString, withFrame: CGRect, in_: NSView): CGRect;
        mouseEntered(with_: NSEvent): void;
        mouseExited(with_: NSEvent): void;
        setButtonType(_: NSButton.ButtonType): void;
        setPeriodicDelayInterval(_: number, interval: number): void;
    }
    class NSButtonTouchBarItem extends NSTouchBarItem {
        action: string;
        setAction(_: string): any;
        bezelColor: NSColor;
        setBezelColor(_: NSColor): any;
        isEnabled: boolean;
        setEnabled(_: boolean): any;
        image: NSImage;
        setImage(_: NSImage): any;
        target: any;
        setTarget(_: any): any;
        title: string;
        setTitle(_: string): any;
    }
    class NSCIImageRep extends NSImageRep {
        CIImage: CIImage;
        static createWithCIImage(CIImage: CIImage): NSCIImageRep;
    }
    class NSCandidateListTouchBarItem<CandidateType> extends NSTouchBarItem {
        allowsCollapsing: boolean;
        setAllowsCollapsing(_: boolean): any;
        allowsTextInputContextCandidates: boolean;
        setAllowsTextInputContextCandidates(_: boolean): any;
        attributedStringForCandidate: (p1: CandidateType, p2: number) => NSAttributedString;
        setAttributedStringForCandidate(_: (p1: CandidateType, p2: number) => NSAttributedString): any;
        isCandidateListVisible: boolean;
        candidates: CandidateType[];
        client: NSView;
        setClient(_: NSView): any;
        isCollapsed: boolean;
        setCollapsed(_: boolean): any;
        delegate: NSCandidateListTouchBarItemDelegate;
        setDelegate(_: NSCandidateListTouchBarItemDelegate): any;
        setCandidatesForSelectedRangeInString(_: CandidateType[], forSelectedRange: NSRange, in_?: string): void;
        updateWithInsertionPointVisibility(withInsertionPointVisibility: boolean): void;
    }
    interface NSCandidateListTouchBarItemDelegate extends NSObject {
        candidateListTouchBarItemBeginSelectingCandidateAtIndex?(_: NSCandidateListTouchBarItem<any>, beginSelectingCandidateAt: number): void;
        candidateListTouchBarItemChangeSelectionFromCandidateAtIndexToIndex?(_: NSCandidateListTouchBarItem<any>, changeSelectionFromCandidateAt: number, to: number): void;
        candidateListTouchBarItemEndSelectingCandidateAtIndex?(_: NSCandidateListTouchBarItem<any>, endSelectingCandidateAt: number): void;
        candidateListTouchBarItemChangedCandidateListVisibility?(_: NSCandidateListTouchBarItem<any>, changedCandidateListVisibility: boolean): void;
    }
    class NSCell extends NSObject {
        acceptsFirstResponder: boolean;
        action: string;
        setAction(_: string): any;
        alignment: NSTextAlignment;
        setAlignment(_: NSTextAlignment): any;
        allowsEditingTextAttributes: boolean;
        setAllowsEditingTextAttributes(_: boolean): any;
        allowsMixedState: boolean;
        setAllowsMixedState(_: boolean): any;
        allowsUndo: boolean;
        setAllowsUndo(_: boolean): any;
        attributedStringValue: NSAttributedString;
        setAttributedStringValue(_: NSAttributedString): any;
        backgroundStyle: NSView.BackgroundStyle;
        setBackgroundStyle(_: NSView.BackgroundStyle): any;
        baseWritingDirection: NSWritingDirection;
        setBaseWritingDirection(_: NSWritingDirection): any;
        isBezeled: boolean;
        setBezeled(_: boolean): any;
        isBordered: boolean;
        setBordered(_: boolean): any;
        cellSize: CGSize;
        isContinuous: boolean;
        setContinuous(_: boolean): any;
        controlSize: NSControl.ControlSize;
        setControlSize(_: NSControl.ControlSize): any;
        controlView: NSView;
        setControlView(_: NSView): any;
        doubleValue: number;
        setDoubleValue(_: number): any;
        isEditable: boolean;
        setEditable(_: boolean): any;
        isEnabled: boolean;
        setEnabled(_: boolean): any;
        floatValue: number;
        setFloatValue(_: number): any;
        focusRingType: NSFocusRingType;
        setFocusRingType(_: NSFocusRingType): any;
        font: NSFont;
        setFont(_: NSFont): any;
        formatter: Formatter;
        setFormatter(_: Formatter): any;
        hasValidObjectValue: boolean;
        isHighlighted: boolean;
        setHighlighted(_: boolean): any;
        image: NSImage;
        setImage(_: NSImage): any;
        importsGraphics: boolean;
        setImportsGraphics(_: boolean): any;
        intValue: number;
        setIntValue(_: number): any;
        integerValue: number;
        setIntegerValue(_: number): any;
        interiorBackgroundStyle: NSView.BackgroundStyle;
        keyEquivalent: string;
        lineBreakMode: NSLineBreakMode;
        setLineBreakMode(_: NSLineBreakMode): any;
        menu: NSMenu;
        setMenu(_: NSMenu): any;
        mouseDownFlags: number;
        nextState: number;
        objectValue: any;
        setObjectValue(_: any): any;
        isOpaque: boolean;
        refusesFirstResponder: boolean;
        setRefusesFirstResponder(_: boolean): any;
        representedObject: any;
        setRepresentedObject(_: any): any;
        isScrollable: boolean;
        setScrollable(_: boolean): any;
        isSelectable: boolean;
        setSelectable(_: boolean): any;
        sendsActionOnEndEditing: boolean;
        setSendsActionOnEndEditing(_: boolean): any;
        showsFirstResponder: boolean;
        setShowsFirstResponder(_: boolean): any;
        state: number;
        setState(_: number): any;
        stringValue: string;
        setStringValue(_: string): any;
        tag: number;
        setTag(_: number): any;
        target: any;
        setTarget(_: any): any;
        title: string;
        setTitle(_: string): any;
        truncatesLastVisibleLine: boolean;
        setTruncatesLastVisibleLine(_: boolean): any;
        type: NSCell.CellType;
        setType(_: NSCell.CellType): any;
        userInterfaceLayoutDirection: NSUserInterfaceLayoutDirection;
        setUserInterfaceLayoutDirection(_: NSUserInterfaceLayoutDirection): any;
        usesSingleLineMode: boolean;
        setUsesSingleLineMode(_: boolean): any;
        wantsNotificationForMarkedText: boolean;
        wraps: boolean;
        setWraps(_: boolean): any;
        static defaultFocusRingType: NSFocusRingType;
        static defaultMenu: NSMenu;
        static prefersTrackingUntilMouseUp: boolean;
        calcDrawInfo(_: CGRect): void;
        cellAttribute(_: NSCell.Attribute): number;
        cellSizeForBounds(forBounds: CGRect): CGSize;
        compare(_: any): ComparisonResult;
        continueTrackingAtInView(last: CGPoint, current: CGPoint, in_: NSView): boolean;
        draggingImageComponentsWithFrameInView(withFrame: CGRect, in_: NSView): NSDraggingImageComponent[];
        drawFocusRingMaskWithFrameInView(withFrame: CGRect, in_: NSView): void;
        drawInteriorWithFrameInView(withFrame: CGRect, in_: NSView): void;
        drawWithExpansionFrameInView(withExpansionFrame: CGRect, in_: NSView): void;
        drawWithFrameInView(withFrame: CGRect, in_: NSView): void;
        drawingRectForBounds(forBounds: CGRect): CGRect;
        editWithFrameInViewEditorDelegateEvent(withFrame: CGRect, in_: NSView, editor: NSText, delegate?: any, event?: NSEvent): void;
        endEditing(_: NSText): void;
        expansionFrameWithFrameInView(withFrame: CGRect, in_: NSView): CGRect;
        fieldEditorForView(for_: NSView): NSTextView;
        focusRingMaskBoundsForFrameInView(forFrame: CGRect, in_: NSView): CGRect;
        getPeriodicDelayInterval(_: number, interval: number): void;
        highlightWithFrameInView(_: boolean, withFrame: CGRect, in_: NSView): void;
        highlightColorWithFrameInView(withFrame: CGRect, in_: NSView): NSColor;
        hitTestForEventInRectOfView(for_: NSEvent, in_: CGRect, of: NSView): NSCell.HitResult;
        imageRectForBounds(forBounds: CGRect): CGRect;
        static createWithImageCell(imageCell?: NSImage): NSCell;
        static createWithTextCell(textCell: string): NSCell;
        menuForEventInRectOfView(for_: NSEvent, in_: CGRect, of: NSView): NSMenu;
        performClick(_?: any): void;
        resetCursorRectInView(_: CGRect, in_: NSView): void;
        selectWithFrameInViewEditorDelegateStartLength(withFrame: CGRect, in_: NSView, editor: NSText, delegate?: any, start?: number, length?: number): void;
        sendActionOn(on: NSEvent.EventTypeMask): number;
        setCellAttributeTo(_: NSCell.Attribute, to: number): void;
        setNextState(): void;
        setUpFieldEditorAttributes(_: NSText): NSText;
        startTrackingAtInView(at: CGPoint, in_: NSView): boolean;
        stopTrackingAtInViewMouseIsUp(last: CGPoint, current: CGPoint, in_: NSView, mouseIsUp: boolean): void;
        takeDoubleValueFrom(_?: any): void;
        takeFloatValueFrom(_?: any): void;
        takeIntValueFrom(_?: any): void;
        takeIntegerValueFrom(_?: any): void;
        takeObjectValueFrom(_?: any): void;
        takeStringValueFrom(_?: any): void;
        titleRectForBounds(forBounds: CGRect): CGRect;
        trackMouseInRectOfViewUntilMouseUp(with_: NSEvent, in_: CGRect, of: NSView, untilMouseUp: boolean): boolean;
    }
    interface NSChangeSpelling {
        changeSpelling(_?: any): void;
    }
    class NSClickGestureRecognizer extends NSGestureRecognizer {
        buttonMask: number;
        setButtonMask(_: number): any;
        numberOfClicksRequired: number;
        setNumberOfClicksRequired(_: number): any;
        numberOfTouchesRequired: number;
        setNumberOfTouchesRequired(_: number): any;
    }
    class NSClipView extends NSView {
        automaticallyAdjustsContentInsets: boolean;
        setAutomaticallyAdjustsContentInsets(_: boolean): any;
        backgroundColor: NSColor;
        setBackgroundColor(_: NSColor): any;
        contentInsets: NSEdgeInsets;
        setContentInsets(_: NSEdgeInsets): any;
        documentCursor: NSCursor;
        setDocumentCursor(_: NSCursor): any;
        documentRect: CGRect;
        documentView: NSView;
        setDocumentView(_: NSView): any;
        documentVisibleRect: CGRect;
        drawsBackground: boolean;
        setDrawsBackground(_: boolean): any;
        constrainBoundsRect(_: CGRect): CGRect;
        scrollToPoint(to: CGPoint): void;
        viewBoundsChanged(_: NSNotification): void;
        viewFrameChanged(_: NSNotification): void;
    }
    interface NSCloudSharingServiceDelegate extends NSSharingServiceDelegate {
        optionsForSharingServiceShareProvider?(for_: NSSharingService, share: NSItemProvider): NSSharingService.CloudKitOptions;
        sharingServiceDidSaveShare?(_: NSSharingService, didSave: CKShare): void;
        sharingServiceDidCompleteForItemsError?(_: NSSharingService, didCompleteForItems: any[], error?: NSError): void;
        sharingServiceDidStopSharing?(_: NSSharingService, didStopSharing: CKShare): void;
    }
    interface NSCloudSharingValidation extends NSObject {
        cloudShareForUserInterfaceItem(for_: NSValidatedUserInterfaceItem): CKShare;
    }
    class NSCollectionLayoutAnchor extends NSObject {
        static layoutAnchorWithEdges(edges: NSDirectionalRectEdge): NSCollectionLayoutAnchor;
        static layoutAnchorWithEdgesAbsoluteOffset(edges: NSDirectionalRectEdge, absoluteOffset: CGPoint): NSCollectionLayoutAnchor;
        static layoutAnchorWithEdgesFractionalOffset(edges: NSDirectionalRectEdge, fractionalOffset: CGPoint): NSCollectionLayoutAnchor;
        edges: NSDirectionalRectEdge;
        isAbsoluteOffset: boolean;
        isFractionalOffset: boolean;
        offset: CGPoint;
    }
    class NSCollectionLayoutBoundarySupplementaryItem extends NSCollectionLayoutSupplementaryItem {
        static boundarySupplementaryItemWithLayoutSizeElementKindAlignment(layoutSize: NSCollectionLayoutSize, elementKind: string, alignment: NSRectAlignment): NSCollectionLayoutBoundarySupplementaryItem;
        static boundarySupplementaryItemWithLayoutSizeElementKindAlignmentAbsoluteOffset(layoutSize: NSCollectionLayoutSize, elementKind: string, alignment: NSRectAlignment, absoluteOffset: CGPoint): NSCollectionLayoutBoundarySupplementaryItem;
        alignment: NSRectAlignment;
        extendsBoundary: boolean;
        setExtendsBoundary(_: boolean): any;
        offset: CGPoint;
        pinToVisibleBounds: boolean;
        setPinToVisibleBounds(_: boolean): any;
    }
    interface NSCollectionLayoutContainer extends NSObject {
        contentInsets: NSDirectionalEdgeInsets;
        contentSize: CGSize;
        effectiveContentInsets: NSDirectionalEdgeInsets;
        effectiveContentSize: CGSize;
    }
    class NSCollectionLayoutDecorationItem extends NSCollectionLayoutItem {
        static backgroundDecorationItemWithElementKind(elementKind: string): NSCollectionLayoutDecorationItem;
        elementKind: string;
        zIndex: number;
        setZIndex(_: number): any;
    }
    class NSCollectionLayoutDimension extends NSObject {
        static absoluteDimension(_: number): NSCollectionLayoutDimension;
        static estimatedDimension(_: number): NSCollectionLayoutDimension;
        static fractionalHeightDimension(_: number): NSCollectionLayoutDimension;
        static fractionalWidthDimension(_: number): NSCollectionLayoutDimension;
        dimension: number;
        isAbsolute: boolean;
        isEstimated: boolean;
        isFractionalHeight: boolean;
        isFractionalWidth: boolean;
    }
    class NSCollectionLayoutEdgeSpacing extends NSObject {
        static spacingForLeadingTopTrailingBottom(leading?: NSCollectionLayoutSpacing, top?: NSCollectionLayoutSpacing, trailing?: NSCollectionLayoutSpacing, bottom?: NSCollectionLayoutSpacing): NSCollectionLayoutEdgeSpacing;
        bottom: NSCollectionLayoutSpacing;
        leading: NSCollectionLayoutSpacing;
        top: NSCollectionLayoutSpacing;
        trailing: NSCollectionLayoutSpacing;
    }
    interface NSCollectionLayoutEnvironment extends NSObject {
        container: NSCollectionLayoutContainer;
    }
    class NSCollectionLayoutGroup extends NSCollectionLayoutItem {
        static customWithLayoutSizeItemProvider(layoutSize: NSCollectionLayoutSize, itemProvider: (p1: NSCollectionLayoutEnvironment) => NSCollectionLayoutGroupCustomItem[]): NSCollectionLayoutGroup;
        static horizontalGroupWithLayoutSizeSubitemCount(layoutSize: NSCollectionLayoutSize, subitem: NSCollectionLayoutItem, count: number): NSCollectionLayoutGroup;
        static horizontalGroupWithLayoutSizeSubitems(layoutSize: NSCollectionLayoutSize, subitems: NSCollectionLayoutItem[]): NSCollectionLayoutGroup;
        static verticalGroupWithLayoutSizeSubitemCount(layoutSize: NSCollectionLayoutSize, subitem: NSCollectionLayoutItem, count: number): NSCollectionLayoutGroup;
        static verticalGroupWithLayoutSizeSubitems(layoutSize: NSCollectionLayoutSize, subitems: NSCollectionLayoutItem[]): NSCollectionLayoutGroup;
        interItemSpacing: NSCollectionLayoutSpacing;
        setInterItemSpacing(_: NSCollectionLayoutSpacing): any;
        subitems: NSCollectionLayoutItem[];
        visualDescription(): string;
    }
    class NSCollectionLayoutGroupCustomItem extends NSObject {
        static customItemWithFrame(frame: CGRect): NSCollectionLayoutGroupCustomItem;
        static customItemWithFrameZIndex(frame: CGRect, zIndex: number): NSCollectionLayoutGroupCustomItem;
        frame: CGRect;
        zIndex: number;
    }
    class NSCollectionLayoutItem extends NSObject {
        static itemWithLayoutSize(layoutSize: NSCollectionLayoutSize): NSCollectionLayoutItem;
        static itemWithLayoutSizeSupplementaryItems(layoutSize: NSCollectionLayoutSize, supplementaryItems: NSCollectionLayoutSupplementaryItem[]): NSCollectionLayoutItem;
        contentInsets: NSDirectionalEdgeInsets;
        setContentInsets(_: NSDirectionalEdgeInsets): any;
        edgeSpacing: NSCollectionLayoutEdgeSpacing;
        setEdgeSpacing(_: NSCollectionLayoutEdgeSpacing): any;
        layoutSize: NSCollectionLayoutSize;
        supplementaryItems: NSCollectionLayoutSupplementaryItem[];
    }
    class NSCollectionLayoutSection extends NSObject {
        static sectionWithGroup(group: NSCollectionLayoutGroup): NSCollectionLayoutSection;
        boundarySupplementaryItems: NSCollectionLayoutBoundarySupplementaryItem[];
        setBoundarySupplementaryItems(_: NSCollectionLayoutBoundarySupplementaryItem[]): any;
        contentInsets: NSDirectionalEdgeInsets;
        setContentInsets(_: NSDirectionalEdgeInsets): any;
        decorationItems: NSCollectionLayoutDecorationItem[];
        setDecorationItems(_: NSCollectionLayoutDecorationItem[]): any;
        interGroupSpacing: number;
        setInterGroupSpacing(_: number): any;
        orthogonalScrollingBehavior: NSCollectionLayoutSectionOrthogonalScrollingBehavior;
        setOrthogonalScrollingBehavior(_: NSCollectionLayoutSectionOrthogonalScrollingBehavior): any;
        supplementariesFollowContentInsets: boolean;
        setSupplementariesFollowContentInsets(_: boolean): any;
        visibleItemsInvalidationHandler: (p1: NSCollectionLayoutVisibleItem[], p2: CGPoint, p3: NSCollectionLayoutEnvironment) => void;
        setVisibleItemsInvalidationHandler(_: (p1: NSCollectionLayoutVisibleItem[], p2: CGPoint, p3: NSCollectionLayoutEnvironment) => void): any;
    }
    class NSCollectionLayoutSize extends NSObject {
        static sizeWithWidthDimensionHeightDimension(widthDimension: NSCollectionLayoutDimension, heightDimension: NSCollectionLayoutDimension): NSCollectionLayoutSize;
        heightDimension: NSCollectionLayoutDimension;
        widthDimension: NSCollectionLayoutDimension;
    }
    class NSCollectionLayoutSpacing extends NSObject {
        static fixedSpacing(_: number): NSCollectionLayoutSpacing;
        static flexibleSpacing(_: number): NSCollectionLayoutSpacing;
        isFixedSpacing: boolean;
        isFlexibleSpacing: boolean;
        spacing: number;
    }
    class NSCollectionLayoutSupplementaryItem extends NSCollectionLayoutItem {
        static supplementaryItemWithLayoutSizeElementKindContainerAnchor(layoutSize: NSCollectionLayoutSize, elementKind: string, containerAnchor: NSCollectionLayoutAnchor): NSCollectionLayoutSupplementaryItem;
        static supplementaryItemWithLayoutSizeElementKindContainerAnchorItemAnchor(layoutSize: NSCollectionLayoutSize, elementKind: string, containerAnchor: NSCollectionLayoutAnchor, itemAnchor: NSCollectionLayoutAnchor): NSCollectionLayoutSupplementaryItem;
        containerAnchor: NSCollectionLayoutAnchor;
        elementKind: string;
        itemAnchor: NSCollectionLayoutAnchor;
        zIndex: number;
        setZIndex(_: number): any;
    }
    interface NSCollectionLayoutVisibleItem extends NSObject {
        alpha: number;
        setAlpha(_: number): any;
        bounds: CGRect;
        center: CGPoint;
        setCenter(_: CGPoint): any;
        frame: CGRect;
        isHidden: boolean;
        setHidden(_: boolean): any;
        indexPath: NSIndexPath;
        name: string;
        representedElementCategory: NSCollectionElementCategory;
        representedElementKind: string;
        zIndex: number;
        setZIndex(_: number): any;
    }
    class NSCollectionView extends NSView {
        allowsEmptySelection: boolean;
        setAllowsEmptySelection(_: boolean): any;
        allowsMultipleSelection: boolean;
        setAllowsMultipleSelection(_: boolean): any;
        backgroundColors: NSColor[];
        setBackgroundColors(_: NSColor[]): any;
        backgroundView: NSView;
        setBackgroundView(_: NSView): any;
        backgroundViewScrollsWithContent: boolean;
        setBackgroundViewScrollsWithContent(_: boolean): any;
        collectionViewLayout: NSCollectionViewLayout;
        setCollectionViewLayout(_: NSCollectionViewLayout): any;
        content: any[];
        setContent(_: any[]): any;
        dataSource: NSCollectionViewDataSource;
        setDataSource(_: NSCollectionViewDataSource): any;
        delegate: NSCollectionViewDelegate;
        setDelegate(_: NSCollectionViewDelegate): any;
        isFirstResponder: boolean;
        numberOfSections: number;
        prefetchDataSource: NSCollectionViewPrefetching;
        setPrefetchDataSource(_: NSCollectionViewPrefetching): any;
        isSelectable: boolean;
        setSelectable(_: boolean): any;
        selectionIndexPaths: NSSet<IndexPath>;
        setSelectionIndexPaths(_: NSSet<IndexPath>): any;
        selectionIndexes: NSIndexSet;
        setSelectionIndexes(_: NSIndexSet): any;
        deleteItemsWithAt(at: NSSet<IndexPath>): void;
        deleteSections(_: NSIndexSet): void;
        deselectAll(_?: any): void;
        deselectItemsWithAt(at: NSSet<IndexPath>): void;
        draggingImageForItemsWithAtWithOffset(at: NSSet<IndexPath>, with_: NSEvent, offset: NSPoint): NSImage;
        draggingImageForItemsAtIndexesWithEventOffset(at: NSIndexSet, with_: NSEvent, offset: NSPoint): NSImage;
        frameForItemAtIndex(at: number): CGRect;
        frameForItemAtIndexWithNumberOfItems(at: number, withNumberOfItems: number): CGRect;
        indexPathForItem(for_: NSCollectionViewItem): NSIndexPath;
        indexPathForItemAtPoint(at: CGPoint): NSIndexPath;
        indexPathsForVisibleItems(): NSSet<IndexPath>;
        indexPathsForVisibleSupplementaryElementsOfKind(ofKind: string): NSSet<IndexPath>;
        insertItemsWithAt(at: NSSet<IndexPath>): void;
        insertSections(_: NSIndexSet): void;
        itemAtIndex(at: number): NSCollectionViewItem;
        itemAtIndexPath(at: NSIndexPath): NSCollectionViewItem;
        layoutAttributesForItemAtIndexPath(at: NSIndexPath): NSCollectionViewLayoutAttributes;
        layoutAttributesForSupplementaryElementOfKindAtIndexPath(ofKind: string, at: NSIndexPath): NSCollectionViewLayoutAttributes;
        makeItemWithIdentifierForIndexPath(withIdentifier: string, for_: NSIndexPath): NSCollectionViewItem;
        makeSupplementaryViewOfKindWithIdentifierForIndexPath(ofKind: string, withIdentifier: string, for_: NSIndexPath): NSView;
        moveItemAtIndexPathToIndexPath(at: NSIndexPath, to: NSIndexPath): void;
        moveSectionToSection(_: number, toSection: number): void;
        numberOfItemsInSection(inSection: number): number;
        performBatchUpdatesWithCompletionHandler(_?: () => void, completionHandler?: (p1: boolean) => void): void;
        registerClassForItemWithIdentifier(_?: typeof NSObject, forItemWithIdentifier?: string): void;
        registerClassForSupplementaryViewOfKindWithIdentifier(_?: typeof NSObject, forSupplementaryViewOfKind?: string, withIdentifier?: string): void;
        registerNibForItemWithIdentifier(_?: NSNib, forItemWithIdentifier?: string): void;
        registerNibForSupplementaryViewOfKindWithIdentifier(_?: NSNib, forSupplementaryViewOfKind?: string, withIdentifier?: string): void;
        reloadData(): void;
        reloadItemsWithAt(at: NSSet<IndexPath>): void;
        reloadSections(_: NSIndexSet): void;
        scrollToItemsWithAtScrollPosition(at: NSSet<IndexPath>, scrollPosition: NSCollectionView.ScrollPosition): void;
        selectItemsWithAtScrollPosition(at: NSSet<IndexPath>, scrollPosition: NSCollectionView.ScrollPosition): void;
        setDraggingSourceOperationMaskForLocal(_: NSDragOperation, forLocal: boolean): void;
        supplementaryViewForElementKindAtIndexPath(forElementKind: string, at: NSIndexPath): NSView;
        toggleSectionCollapse(_: any): void;
        visibleItems(): NSCollectionViewItem[];
        visibleSupplementaryViewsOfKind(ofKind: string): NSView[];
    }
    class NSCollectionViewCompositionalLayout extends NSCollectionViewLayout {
        configuration: NSCollectionViewCompositionalLayoutConfiguration;
        setConfiguration(_: NSCollectionViewCompositionalLayoutConfiguration): any;
        static createWithSection(section: NSCollectionLayoutSection): NSCollectionViewCompositionalLayout;
        static createWithSectionConfiguration(section: NSCollectionLayoutSection, configuration: NSCollectionViewCompositionalLayoutConfiguration): NSCollectionViewCompositionalLayout;
        static createWithSectionProvider(sectionProvider: (p1: number, p2: NSCollectionLayoutEnvironment) => NSCollectionLayoutSection): NSCollectionViewCompositionalLayout;
        static createWithSectionProviderConfiguration(sectionProvider: (p1: number, p2: NSCollectionLayoutEnvironment) => NSCollectionLayoutSection, configuration: NSCollectionViewCompositionalLayoutConfiguration): NSCollectionViewCompositionalLayout;
    }
    class NSCollectionViewCompositionalLayoutConfiguration extends NSObject {
        boundarySupplementaryItems: NSCollectionLayoutBoundarySupplementaryItem[];
        setBoundarySupplementaryItems(_: NSCollectionLayoutBoundarySupplementaryItem[]): any;
        interSectionSpacing: number;
        setInterSectionSpacing(_: number): any;
        scrollDirection: NSCollectionView.ScrollDirection;
        setScrollDirection(_: NSCollectionView.ScrollDirection): any;
    }
    interface NSCollectionViewDataSource extends NSObject {
        collectionViewItemForRepresentedObjectAtIndexPath(_: NSCollectionView, itemForRepresentedObjectAt: NSIndexPath): NSCollectionViewItem;
        collectionViewViewForSupplementaryElementOfKindAtIndexPath?(_: NSCollectionView, viewForSupplementaryElementOfKind: string, at: NSIndexPath): NSView;
        collectionViewNumberOfItemsInSection(_: NSCollectionView, numberOfItemsInSection: number): number;
        numberOfSectionsInCollectionView?(in_: NSCollectionView): number;
    }
    interface NSCollectionViewDelegate extends NSObject {
        collectionViewCanDragItemsAtWith?(_: NSCollectionView, canDragItemsAt: NSSet<IndexPath>, with_: NSEvent): boolean;
        collectionViewCanDragItemsAtIndexesWithEvent?(_: NSCollectionView, canDragItemsAt: NSIndexSet, with_: NSEvent): boolean;
        collectionViewWriteItemsAtTo?(_: NSCollectionView, writeItemsAt: NSSet<IndexPath>, to: NSPasteboard): boolean;
        collectionViewWriteItemsAtIndexesToPasteboard?(_: NSCollectionView, writeItemsAt: NSIndexSet, to: NSPasteboard): boolean;
        collectionViewDraggingImageForItemsAtWithOffset?(_: NSCollectionView, draggingImageForItemsAt: NSSet<IndexPath>, with_: NSEvent, offset: NSPoint): NSImage;
        collectionViewDraggingImageForItemsAtIndexesWithEventOffset?(_: NSCollectionView, draggingImageForItemsAt: NSIndexSet, with_: NSEvent, offset: NSPoint): NSImage;
        collectionViewPasteboardWriterForItemAtIndexPath?(_: NSCollectionView, pasteboardWriterForItemAt: NSIndexPath): NSPasteboardWriting;
        collectionViewPasteboardWriterForItemAtIndex?(_: NSCollectionView, pasteboardWriterForItemAt: number): NSPasteboardWriting;
        collectionViewDraggingSessionWillBeginAtForItemsAt?(_: NSCollectionView, draggingSession: NSDraggingSession, willBeginAt: CGPoint, forItemsAt: NSSet<IndexPath>): void;
        collectionViewDraggingSessionWillBeginAtPointForItemsAtIndexes?(_: NSCollectionView, draggingSession: NSDraggingSession, willBeginAt: CGPoint, forItemsAt: NSIndexSet): void;
        collectionViewDraggingSessionEndedAtPointDragOperation?(_: NSCollectionView, draggingSession: NSDraggingSession, endedAt: CGPoint, dragOperation: NSDragOperation): void;
        collectionViewShouldChangeItemsAtTo?(_: NSCollectionView, shouldChangeItemsAt: NSSet<IndexPath>, to: NSCollectionViewItem.HighlightState): NSSet<IndexPath>;
        collectionViewDidChangeItemsAtTo?(_: NSCollectionView, didChangeItemsAt: NSSet<IndexPath>, to: NSCollectionViewItem.HighlightState): void;
        collectionViewShouldSelectItemsAt?(_: NSCollectionView, shouldSelectItemsAt: NSSet<IndexPath>): NSSet<IndexPath>;
        collectionViewShouldDeselectItemsAt?(_: NSCollectionView, shouldDeselectItemsAt: NSSet<IndexPath>): NSSet<IndexPath>;
        collectionViewDidSelectItemsAt?(_: NSCollectionView, didSelectItemsAt: NSSet<IndexPath>): void;
        collectionViewDidDeselectItemsAt?(_: NSCollectionView, didDeselectItemsAt: NSSet<IndexPath>): void;
        collectionViewWillDisplayItemForRepresentedObjectAtIndexPath?(_: NSCollectionView, willDisplay: NSCollectionViewItem, forRepresentedObjectAt: NSIndexPath): void;
        collectionViewWillDisplaySupplementaryViewForElementKindAtIndexPath?(_: NSCollectionView, willDisplaySupplementaryView: NSView, forElementKind: string, at: NSIndexPath): void;
        collectionViewDidEndDisplayingItemForRepresentedObjectAtIndexPath?(_: NSCollectionView, didEndDisplaying: NSCollectionViewItem, forRepresentedObjectAt: NSIndexPath): void;
        collectionViewDidEndDisplayingSupplementaryViewForElementOfKindAtIndexPath?(_: NSCollectionView, didEndDisplayingSupplementaryView: NSView, forElementOfKind: string, at: NSIndexPath): void;
        collectionViewAcceptDropIndexDropOperation?(_: NSCollectionView, acceptDrop: NSDraggingInfo, index: number, dropOperation: NSCollectionView.DropOperation): boolean;
        collectionViewAcceptDropIndexPathDropOperation?(_: NSCollectionView, acceptDrop: NSDraggingInfo, indexPath: NSIndexPath, dropOperation: NSCollectionView.DropOperation): boolean;
        collectionViewTransitionLayoutForOldLayoutNewLayout?(_: NSCollectionView, transitionLayoutForOldLayout: NSCollectionViewLayout, newLayout: NSCollectionViewLayout): NSCollectionViewTransitionLayout;
        collectionViewUpdateDraggingItemsForDrag?(_: NSCollectionView, updateDraggingItemsForDrag: NSDraggingInfo): void;
        collectionViewValidateDropProposedIndexDropOperation?(_: NSCollectionView, validateDrop: NSDraggingInfo, proposedIndex: number, dropOperation: NSCollectionView.DropOperation): NSDragOperation;
        collectionViewValidateDropProposedIndexPathDropOperation?(_: NSCollectionView, validateDrop: NSDraggingInfo, proposedIndexPath: IndexPath, dropOperation: NSCollectionView.DropOperation): NSDragOperation;
    }
    interface NSCollectionViewDelegateFlowLayout extends NSCollectionViewDelegate {
        collectionViewLayoutSizeForItemAtIndexPath?(_: NSCollectionView, layout: NSCollectionViewLayout, sizeForItemAt: NSIndexPath): CGSize;
        collectionViewLayoutInsetForSectionAtIndex?(_: NSCollectionView, layout: NSCollectionViewLayout, insetForSectionAt: number): NSEdgeInsets;
        collectionViewLayoutMinimumLineSpacingForSectionAtIndex?(_: NSCollectionView, layout: NSCollectionViewLayout, minimumLineSpacingForSectionAt: number): number;
        collectionViewLayoutMinimumInteritemSpacingForSectionAtIndex?(_: NSCollectionView, layout: NSCollectionViewLayout, minimumInteritemSpacingForSectionAt: number): number;
        collectionViewLayoutReferenceSizeForFooterInSection?(_: NSCollectionView, layout: NSCollectionViewLayout, referenceSizeForFooterInSection: number): CGSize;
        collectionViewLayoutReferenceSizeForHeaderInSection?(_: NSCollectionView, layout: NSCollectionViewLayout, referenceSizeForHeaderInSection: number): CGSize;
    }
    class NSCollectionViewDiffableDataSourceReference<SectionIdentifierType, ItemIdentifierType> extends NSObject {
        supplementaryViewProvider: (p1: NSCollectionView, p2: string, p3: NSIndexPath) => NSView;
        setSupplementaryViewProvider(_: (p1: NSCollectionView, p2: string, p3: NSIndexPath) => NSView): any;
        applySnapshotWithAnimatingDifferences(_: NSDiffableDataSourceSnapshotReference<SectionIdentifierType, ItemIdentifierType>, animatingDifferences: boolean): void;
        indexPathForItemIdentifier(_: ItemIdentifierType): NSIndexPath;
        itemIdentifierForIndexPath(_: NSIndexPath): ItemIdentifierType;
        snapshot(): NSDiffableDataSourceSnapshotReference<SectionIdentifierType, ItemIdentifierType>;
    }
    interface NSCollectionViewElement extends NSObject, NSUserInterfaceItemIdentification {
        applyLayoutAttributes?(_: NSCollectionViewLayoutAttributes): void;
        didTransitionFromLayoutToLayout?(from: NSCollectionViewLayout, to: NSCollectionViewLayout): void;
        preferredLayoutAttributesFittingAttributes?(_: NSCollectionViewLayoutAttributes): NSCollectionViewLayoutAttributes;
        prepareForReuse?(): void;
        willTransitionFromLayoutToLayout?(from: NSCollectionViewLayout, to: NSCollectionViewLayout): void;
    }
    class NSCollectionViewFlowLayout extends NSCollectionViewLayout {
        estimatedItemSize: CGSize;
        setEstimatedItemSize(_: CGSize): any;
        footerReferenceSize: CGSize;
        setFooterReferenceSize(_: CGSize): any;
        headerReferenceSize: CGSize;
        setHeaderReferenceSize(_: CGSize): any;
        itemSize: CGSize;
        setItemSize(_: CGSize): any;
        minimumInteritemSpacing: number;
        setMinimumInteritemSpacing(_: number): any;
        minimumLineSpacing: number;
        setMinimumLineSpacing(_: number): any;
        scrollDirection: NSCollectionView.ScrollDirection;
        setScrollDirection(_: NSCollectionView.ScrollDirection): any;
        sectionFootersPinToVisibleBounds: boolean;
        setSectionFootersPinToVisibleBounds(_: boolean): any;
        sectionHeadersPinToVisibleBounds: boolean;
        setSectionHeadersPinToVisibleBounds(_: boolean): any;
        sectionInset: NSEdgeInsets;
        setSectionInset(_: NSEdgeInsets): any;
        collapseSectionAtIndex(at: number): void;
        expandSectionAtIndex(at: number): void;
        sectionAtIndexIsCollapsed(atIndexIsCollapsed: number): boolean;
    }
    class NSCollectionViewFlowLayoutInvalidationContext extends NSCollectionViewLayoutInvalidationContext {
        invalidateFlowLayoutAttributes: boolean;
        setInvalidateFlowLayoutAttributes(_: boolean): any;
        invalidateFlowLayoutDelegateMetrics: boolean;
        setInvalidateFlowLayoutDelegateMetrics(_: boolean): any;
    }
    class NSCollectionViewGridLayout extends NSCollectionViewLayout {
        backgroundColors: NSColor[];
        setBackgroundColors(_: NSColor[]): any;
        margins: NSEdgeInsets;
        setMargins(_: NSEdgeInsets): any;
        maximumItemSize: CGSize;
        setMaximumItemSize(_: CGSize): any;
        maximumNumberOfColumns: number;
        setMaximumNumberOfColumns(_: number): any;
        maximumNumberOfRows: number;
        setMaximumNumberOfRows(_: number): any;
        minimumInteritemSpacing: number;
        setMinimumInteritemSpacing(_: number): any;
        minimumItemSize: CGSize;
        setMinimumItemSize(_: CGSize): any;
        minimumLineSpacing: number;
        setMinimumLineSpacing(_: number): any;
    }
    class NSCollectionViewItem extends NSViewController {
        collectionView: NSCollectionView;
        draggingImageComponents: NSDraggingImageComponent[];
        highlightState: NSCollectionViewItem.HighlightState;
        setHighlightState(_: NSCollectionViewItem.HighlightState): any;
        imageView: NSImageView;
        setImageView(_: NSImageView): any;
        isSelected: boolean;
        setSelected(_: boolean): any;
        textField: NSTextField;
        setTextField(_: NSTextField): any;
    }
    class NSCollectionViewLayout extends NSObject {
        collectionView: NSCollectionView;
        collectionViewContentSize: CGSize;
        static invalidationContextClass: typeof NSObject;
        static layoutAttributesClass: typeof NSObject;
        finalLayoutAttributesForDisappearingDecorationElementOfKindAtIndexPath(ofKind: string, at: NSIndexPath): NSCollectionViewLayoutAttributes;
        finalLayoutAttributesForDisappearingItemAtIndexPath(at: NSIndexPath): NSCollectionViewLayoutAttributes;
        finalLayoutAttributesForDisappearingSupplementaryElementOfKindAtIndexPath(ofKind: string, at: NSIndexPath): NSCollectionViewLayoutAttributes;
        finalizeAnimatedBoundsChange(): void;
        finalizeCollectionViewUpdates(): void;
        finalizeLayoutTransition(): void;
        indexPathsToDeleteForDecorationViewOfKind(ofKind: string): NSSet<IndexPath>;
        indexPathsToDeleteForSupplementaryViewOfKind(ofKind: string): NSSet<IndexPath>;
        indexPathsToInsertForDecorationViewOfKind(ofKind: string): NSSet<IndexPath>;
        indexPathsToInsertForSupplementaryViewOfKind(ofKind: string): NSSet<IndexPath>;
        initialLayoutAttributesForAppearingDecorationElementOfKindAtIndexPath(ofKind: string, at: NSIndexPath): NSCollectionViewLayoutAttributes;
        initialLayoutAttributesForAppearingItemAtIndexPath(at: NSIndexPath): NSCollectionViewLayoutAttributes;
        initialLayoutAttributesForAppearingSupplementaryElementOfKindAtIndexPath(ofKind: string, at: NSIndexPath): NSCollectionViewLayoutAttributes;
        invalidateLayout(): void;
        invalidateLayoutWithContext(with_: NSCollectionViewLayoutInvalidationContext): void;
        invalidationContextForBoundsChange(forBoundsChange: CGRect): NSCollectionViewLayoutInvalidationContext;
        invalidationContextForPreferredLayoutAttributesWithOriginalAttributes(forPreferredLayoutAttributes: NSCollectionViewLayoutAttributes, withOriginalAttributes: NSCollectionViewLayoutAttributes): NSCollectionViewLayoutInvalidationContext;
        layoutAttributesForDecorationViewOfKindAtIndexPath(ofKind: string, at: NSIndexPath): NSCollectionViewLayoutAttributes;
        layoutAttributesForDropTargetAtPoint(at: CGPoint): NSCollectionViewLayoutAttributes;
        layoutAttributesForElementsInRect(in_: CGRect): NSCollectionViewLayoutAttributes[];
        layoutAttributesForInterItemGapBeforeIndexPath(before: NSIndexPath): NSCollectionViewLayoutAttributes;
        layoutAttributesForItemAtIndexPath(at: NSIndexPath): NSCollectionViewLayoutAttributes;
        layoutAttributesForSupplementaryViewOfKindAtIndexPath(ofKind: string, at: NSIndexPath): NSCollectionViewLayoutAttributes;
        prepareForAnimatedBoundsChange(forAnimatedBoundsChange: CGRect): void;
        prepareForCollectionViewUpdates(forCollectionViewUpdates: NSCollectionViewUpdateItem[]): void;
        prepareForTransitionFromLayout(from: NSCollectionViewLayout): void;
        prepareForTransitionToLayout(to: NSCollectionViewLayout): void;
        prepareLayout(): void;
        registerClassForDecorationViewOfKind(_?: typeof NSObject, forDecorationViewOfKind?: string): void;
        registerNibForDecorationViewOfKind(_?: NSNib, forDecorationViewOfKind?: string): void;
        shouldInvalidateLayoutForBoundsChange(forBoundsChange: CGRect): boolean;
        shouldInvalidateLayoutForPreferredLayoutAttributesWithOriginalAttributes(forPreferredLayoutAttributes: NSCollectionViewLayoutAttributes, withOriginalAttributes: NSCollectionViewLayoutAttributes): boolean;
        targetContentOffsetForProposedContentOffset(forProposedContentOffset: CGPoint): CGPoint;
        targetContentOffsetForProposedContentOffsetWithScrollingVelocity(forProposedContentOffset: CGPoint, withScrollingVelocity: CGPoint): CGPoint;
    }
    class NSCollectionViewLayoutAttributes extends NSObject {
        static layoutAttributesForDecorationViewOfKindWithIndexPath(forDecorationViewOfKind: string, with_: NSIndexPath): NSCollectionViewLayoutAttributes;
        static layoutAttributesForInterItemGapBeforeIndexPath(forInterItemGapBefore: NSIndexPath): NSCollectionViewLayoutAttributes;
        static layoutAttributesForItemWithIndexPath(forItemWith: NSIndexPath): NSCollectionViewLayoutAttributes;
        static layoutAttributesForSupplementaryViewOfKindWithIndexPath(forSupplementaryViewOfKind: string, with_: NSIndexPath): NSCollectionViewLayoutAttributes;
        alpha: number;
        setAlpha(_: number): any;
        frame: CGRect;
        setFrame(_: CGRect): any;
        isHidden: boolean;
        setHidden(_: boolean): any;
        indexPath: NSIndexPath;
        setIndexPath(_: NSIndexPath): any;
        representedElementCategory: NSCollectionElementCategory;
        representedElementKind: string;
        size: CGSize;
        setSize(_: CGSize): any;
        zIndex: number;
        setZIndex(_: number): any;
    }
    class NSCollectionViewLayoutInvalidationContext extends NSObject {
        contentOffsetAdjustment: CGPoint;
        setContentOffsetAdjustment(_: CGPoint): any;
        contentSizeAdjustment: CGSize;
        setContentSizeAdjustment(_: CGSize): any;
        invalidateDataSourceCounts: boolean;
        invalidateEverything: boolean;
        invalidatedDecorationIndexPaths: Map<string, NSSet<IndexPath>>;
        invalidatedItemIndexPaths: NSSet<IndexPath>;
        invalidatedSupplementaryIndexPaths: Map<string, NSSet<IndexPath>>;
        invalidateDecorationElementsWithOfKindAt(ofKind: string, at: NSSet<IndexPath>): void;
        invalidateItemsWithAt(at: NSSet<IndexPath>): void;
        invalidateSupplementaryElementsWithOfKindAt(ofKind: string, at: NSSet<IndexPath>): void;
    }
    interface NSCollectionViewPrefetching extends NSObject {
        collectionViewPrefetchItemsAtIndexPaths(_: NSCollectionView, prefetchItemsAt: NSIndexPath[]): void;
        collectionViewCancelPrefetchingForItemsAtIndexPaths?(_: NSCollectionView, cancelPrefetchingForItemsAt: NSIndexPath[]): void;
    }
    interface NSCollectionViewSectionHeaderView extends NSCollectionViewElement {
        sectionCollapseButton?: NSButton;
        setSectionCollapseButton(_: NSButton): any;
    }
    class NSCollectionViewTransitionLayout extends NSCollectionViewLayout {
        currentLayout: NSCollectionViewLayout;
        nextLayout: NSCollectionViewLayout;
        transitionProgress: number;
        setTransitionProgress(_: number): any;
        static createWithCurrentLayoutNextLayout(currentLayout: NSCollectionViewLayout, nextLayout: NSCollectionViewLayout): NSCollectionViewTransitionLayout;
        updateValueForAnimatedKey(_: number, forAnimatedKey: string): void;
        valueForAnimatedKey(forAnimatedKey: string): number;
    }
    class NSCollectionViewUpdateItem extends NSObject {
        indexPathAfterUpdate: NSIndexPath;
        indexPathBeforeUpdate: NSIndexPath;
        updateAction: NSCollectionView.UpdateAction;
    }
    class NSColor extends NSObject {
        CGColor: any;
        alphaComponent: number;
        blackComponent: number;
        blueComponent: number;
        brightnessComponent: number;
        catalogNameComponent: string;
        colorNameComponent: string;
        colorSpace: NSColorSpace;
        cyanComponent: number;
        greenComponent: number;
        hueComponent: number;
        localizedCatalogNameComponent: string;
        localizedColorNameComponent: string;
        magentaComponent: number;
        numberOfComponents: number;
        patternImage: NSImage;
        redComponent: number;
        saturationComponent: number;
        type: NSColor.ColorType;
        whiteComponent: number;
        yellowComponent: number;
        static alternateSelectedControlTextColor: NSColor;
        static alternatingContentBackgroundColors: NSColor[];
        static blackColor: NSColor;
        static blueColor: NSColor;
        static brownColor: NSColor;
        static clearColor: NSColor;
        static controlAccentColor: NSColor;
        static controlBackgroundColor: NSColor;
        static controlColor: NSColor;
        static controlTextColor: NSColor;
        static currentControlTint: NSControlTint;
        static cyanColor: NSColor;
        static darkGrayColor: NSColor;
        static disabledControlTextColor: NSColor;
        static findHighlightColor: NSColor;
        static grayColor: NSColor;
        static greenColor: NSColor;
        static gridColor: NSColor;
        static headerTextColor: NSColor;
        static highlightColor: NSColor;
        static ignoresAlpha: boolean;
        setIgnoresAlpha(_: boolean): any;
        static keyboardFocusIndicatorColor: NSColor;
        static labelColor: NSColor;
        static lightGrayColor: NSColor;
        static linkColor: NSColor;
        static magentaColor: NSColor;
        static orangeColor: NSColor;
        static placeholderTextColor: NSColor;
        static purpleColor: NSColor;
        static quaternaryLabelColor: NSColor;
        static redColor: NSColor;
        static scrubberTexturedBackgroundColor: NSColor;
        static secondaryLabelColor: NSColor;
        static selectedContentBackgroundColor: NSColor;
        static selectedControlColor: NSColor;
        static selectedControlTextColor: NSColor;
        static selectedMenuItemTextColor: NSColor;
        static selectedTextBackgroundColor: NSColor;
        static selectedTextColor: NSColor;
        static separatorColor: NSColor;
        static shadowColor: NSColor;
        static systemBlueColor: NSColor;
        static systemBrownColor: NSColor;
        static systemGrayColor: NSColor;
        static systemGreenColor: NSColor;
        static systemIndigoColor: NSColor;
        static systemOrangeColor: NSColor;
        static systemPinkColor: NSColor;
        static systemPurpleColor: NSColor;
        static systemRedColor: NSColor;
        static systemTealColor: NSColor;
        static systemYellowColor: NSColor;
        static tertiaryLabelColor: NSColor;
        static textBackgroundColor: NSColor;
        static textColor: NSColor;
        static underPageBackgroundColor: NSColor;
        static unemphasizedSelectedContentBackgroundColor: NSColor;
        static unemphasizedSelectedTextBackgroundColor: NSColor;
        static unemphasizedSelectedTextColor: NSColor;
        static whiteColor: NSColor;
        static windowBackgroundColor: NSColor;
        static windowFrameTextColor: NSColor;
        static yellowColor: NSColor;
        blendedColorWithFractionOfColor(withFraction: number, of: NSColor): NSColor;
        colorUsingColorSpace(_: NSColorSpace): NSColor;
        colorUsingType(_: NSColor.ColorType): NSColor;
        colorWithAlphaComponent(_: number): NSColor;
        colorWithSystemEffect(_: NSColor.SystemEffect): NSColor;
        drawSwatchInRect(in_: CGRect): void;
        getComponents(_: number): void;
        getCyanMagentaYellowBlackAlpha(_?: number, magenta?: number, yellow?: number, black?: number, alpha?: number): void;
        getHueSaturationBrightnessAlpha(_?: number, saturation?: number, brightness?: number, alpha?: number): void;
        getRedGreenBlueAlpha(_?: number, green?: number, blue?: number, alpha?: number): void;
        getWhiteAlpha(_?: number, alpha?: number): void;
        highlightWithLevel(withLevel: number): NSColor;
        set(): void;
        setFill(): void;
        setStroke(): void;
        shadowWithLevel(withLevel: number): NSColor;
        writeToPasteboard(to: NSPasteboard): void;
    }
    interface NSColorChanging extends NSObject {
        changeColor(_?: NSColorPanel): void;
    }
    class NSColorList extends NSObject {
        allKeys: string[];
        isEditable: boolean;
        name: string;
        static availableColorLists: NSColorList[];
        colorWithKey(withKey: string): NSColor;
        static createWithName(name: string): NSColorList;
        static createWithNameFromFile(name: string, fromFile?: string): NSColorList;
        insertColorKeyAtIndex(_: NSColor, key: string, at: number): void;
        removeColorWithKey(withKey: string): void;
        removeFile(): void;
        setColorForKey(_: NSColor, forKey: string): void;
        writeToURLError(error?: NSURL): boolean;
    }
    class NSColorPanel extends NSPanel {
        static dragColorWithEventFromView(_: NSColor, with_: NSEvent, from: NSView): boolean;
        static setPickerMask(_: NSColorPanel.Options): void;
        static setPickerMode(_: NSColorPanel.Mode): void;
        accessoryView: NSView;
        setAccessoryView(_: NSView): any;
        alpha: number;
        color: NSColor;
        setColor(_: NSColor): any;
        isContinuous: boolean;
        setContinuous(_: boolean): any;
        mode: NSColorPanel.Mode;
        setMode(_: NSColorPanel.Mode): any;
        showsAlpha: boolean;
        setShowsAlpha(_: boolean): any;
        static sharedColorPanel: NSColorPanel;
        static sharedColorPanelExists: boolean;
        attachColorList(_: NSColorList): void;
        detachColorList(_: NSColorList): void;
        setAction(_?: string): void;
        setTarget(_?: any): void;
    }
    class NSColorPicker extends NSObject {
        buttonToolTip: string;
        colorPanel: NSColorPanel;
        minContentSize: CGSize;
        provideNewButtonImage: NSImage;
    }
    class NSColorPickerTouchBarItem extends NSTouchBarItem {
        static colorPickerWithIdentifier(withIdentifier: string): NSColorPickerTouchBarItem;
        static colorPickerWithIdentifierButtonImage(withIdentifier: string, buttonImage: NSImage): NSColorPickerTouchBarItem;
        static strokeColorPickerWithIdentifier(withIdentifier: string): NSColorPickerTouchBarItem;
        static textColorPickerWithIdentifier(withIdentifier: string): NSColorPickerTouchBarItem;
        action: string;
        setAction(_: string): any;
        allowedColorSpaces: NSColorSpace[];
        setAllowedColorSpaces(_: NSColorSpace[]): any;
        color: NSColor;
        setColor(_: NSColor): any;
        colorList: NSColorList;
        setColorList(_: NSColorList): any;
        isEnabled: boolean;
        setEnabled(_: boolean): any;
        showsAlpha: boolean;
        setShowsAlpha(_: boolean): any;
        target: any;
        setTarget(_: any): any;
    }
    interface NSColorPickingCustom extends NSColorPickingDefault {
        currentMode(): NSColorPanel.Mode;
        provideNewView(_: boolean): NSView;
        setColor(_: NSColor): void;
        supportsMode(_: NSColorPanel.Mode): boolean;
    }
    interface NSColorPickingDefault {
        provideNewButtonImage: NSImage;
        buttonToolTip: string;
        minContentSize: CGSize;
        alphaControlAddedOrRemoved(_?: any): void;
        attachColorList(_: NSColorList): void;
        detachColorList(_: NSColorList): void;
        insertNewButtonImageIn(_: NSImage, in_: NSButtonCell): void;
        setMode(_: NSColorPanel.Mode): void;
        viewSizeChanged(_?: any): void;
    }
    class NSColorSampler extends NSObject {
        showWithSelectionHandler(selectionHandler?: (p1: NSColor) => void): void;
    }
    class NSColorSpace extends NSObject {
        static availableColorSpacesWithModel(with_: NSColorSpace.Model): NSColorSpace[];
        CGColorSpace: any;
        ICCProfileData: NSData;
        colorSpaceModel: NSColorSpace.Model;
        colorSyncProfile: any;
        localizedName: string;
        numberOfColorComponents: number;
        static adobeRGB1998ColorSpace: NSColorSpace;
        static deviceCMYKColorSpace: NSColorSpace;
        static deviceGrayColorSpace: NSColorSpace;
        static deviceRGBColorSpace: NSColorSpace;
        static displayP3ColorSpace: NSColorSpace;
        static extendedGenericGamma22GrayColorSpace: NSColorSpace;
        static extendedSRGBColorSpace: NSColorSpace;
        static genericCMYKColorSpace: NSColorSpace;
        static genericGamma22GrayColorSpace: NSColorSpace;
        static genericGrayColorSpace: NSColorSpace;
        static genericRGBColorSpace: NSColorSpace;
        static sRGBColorSpace: NSColorSpace;
        static createWithCGColorSpace(CGColorSpace: any): NSColorSpace;
        static createWithColorSyncProfile(colorSyncProfile: any): NSColorSpace;
        static createWithICCProfileData(ICCProfileData: NSData): NSColorSpace;
    }
    class NSColorWell extends NSControl {
        isActive: boolean;
        isBordered: boolean;
        setBordered(_: boolean): any;
        color: NSColor;
        setColor(_: NSColor): any;
        activate(_: boolean): void;
        deactivate(): void;
        drawWellInside(inside: CGRect): void;
        takeColorFrom(_?: any): void;
    }
    class NSComboBox extends NSTextField {
        isButtonBordered: boolean;
        setButtonBordered(_: boolean): any;
        completes: boolean;
        setCompletes(_: boolean): any;
        dataSource: NSComboBoxDataSource;
        setDataSource(_: NSComboBoxDataSource): any;
        hasVerticalScroller: boolean;
        setHasVerticalScroller(_: boolean): any;
        indexOfSelectedItem: number;
        intercellSpacing: CGSize;
        setIntercellSpacing(_: CGSize): any;
        itemHeight: number;
        setItemHeight(_: number): any;
        numberOfItems: number;
        numberOfVisibleItems: number;
        setNumberOfVisibleItems(_: number): any;
        objectValueOfSelectedItem: any;
        objectValues: any[];
        usesDataSource: boolean;
        setUsesDataSource(_: boolean): any;
        addItemWithObjectValue(withObjectValue: any): void;
        addItemsWithObjectValues(withObjectValues: any[]): void;
        deselectItemAtIndex(at: number): void;
        indexOfItemWithObjectValue(withObjectValue: any): number;
        insertItemWithObjectValueAtIndex(withObjectValue: any, at: number): void;
        itemObjectValueAtIndex(at: number): any;
        noteNumberOfItemsChanged(): void;
        reloadData(): void;
        removeAllItems(): void;
        removeItemAtIndex(at: number): void;
        removeItemWithObjectValue(withObjectValue: any): void;
        scrollItemAtIndexToTop(_: number): void;
        scrollItemAtIndexToVisible(_: number): void;
        selectItemAtIndex(at: number): void;
        selectItemWithObjectValue(withObjectValue?: any): void;
    }
    class NSComboBoxCell extends NSTextFieldCell {
        isButtonBordered: boolean;
        setButtonBordered(_: boolean): any;
        completes: boolean;
        setCompletes(_: boolean): any;
        dataSource: NSComboBoxCellDataSource;
        setDataSource(_: NSComboBoxCellDataSource): any;
        hasVerticalScroller: boolean;
        setHasVerticalScroller(_: boolean): any;
        indexOfSelectedItem: number;
        intercellSpacing: CGSize;
        setIntercellSpacing(_: CGSize): any;
        itemHeight: number;
        setItemHeight(_: number): any;
        numberOfItems: number;
        numberOfVisibleItems: number;
        setNumberOfVisibleItems(_: number): any;
        objectValueOfSelectedItem: any;
        objectValues: any[];
        usesDataSource: boolean;
        setUsesDataSource(_: boolean): any;
        addItemWithObjectValue(withObjectValue: any): void;
        addItemsWithObjectValues(withObjectValues: any[]): void;
        completedString(_: string): string;
        deselectItemAtIndex(at: number): void;
        indexOfItemWithObjectValue(withObjectValue: any): number;
        insertItemWithObjectValueAtIndex(withObjectValue: any, at: number): void;
        itemObjectValueAtIndex(at: number): any;
        noteNumberOfItemsChanged(): void;
        reloadData(): void;
        removeAllItems(): void;
        removeItemAtIndex(at: number): void;
        removeItemWithObjectValue(withObjectValue: any): void;
        scrollItemAtIndexToTop(_: number): void;
        scrollItemAtIndexToVisible(_: number): void;
        selectItemAtIndex(at: number): void;
        selectItemWithObjectValue(withObjectValue?: any): void;
    }
    interface NSComboBoxCellDataSource extends NSObject {
        comboBoxCellObjectValueForItemAtIndex?(_: NSComboBoxCell, objectValueForItemAt: number): any;
        comboBoxCellCompletedString?(_: NSComboBoxCell, completedString: string): string;
        comboBoxCellIndexOfItemWithStringValue?(_: NSComboBoxCell, indexOfItemWithStringValue: string): number;
        numberOfItemsInComboBoxCell?(in_: NSComboBoxCell): number;
    }
    interface NSComboBoxDataSource extends NSObject {
        comboBoxObjectValueForItemAtIndex?(_: NSComboBox, objectValueForItemAt: number): any;
        comboBoxCompletedString?(_: NSComboBox, completedString: string): string;
        comboBoxIndexOfItemWithStringValue?(_: NSComboBox, indexOfItemWithStringValue: string): number;
        numberOfItemsInComboBox?(in_: NSComboBox): number;
    }
    interface NSComboBoxDelegate extends NSTextFieldDelegate {
        comboBoxSelectionDidChange?(_: NSNotification): void;
        comboBoxSelectionIsChanging?(_: NSNotification): void;
        comboBoxWillDismiss?(_: NSNotification): void;
        comboBoxWillPopUp?(_: NSNotification): void;
    }
    class NSControl extends NSView {
        action: string;
        setAction(_: string): any;
        alignment: NSTextAlignment;
        setAlignment(_: NSTextAlignment): any;
        allowsExpansionToolTips: boolean;
        setAllowsExpansionToolTips(_: boolean): any;
        attributedStringValue: NSAttributedString;
        setAttributedStringValue(_: NSAttributedString): any;
        baseWritingDirection: NSWritingDirection;
        setBaseWritingDirection(_: NSWritingDirection): any;
        cell: NSCell;
        setCell(_: NSCell): any;
        isContinuous: boolean;
        setContinuous(_: boolean): any;
        controlSize: NSControl.ControlSize;
        setControlSize(_: NSControl.ControlSize): any;
        doubleValue: number;
        setDoubleValue(_: number): any;
        isEnabled: boolean;
        setEnabled(_: boolean): any;
        floatValue: number;
        setFloatValue(_: number): any;
        font: NSFont;
        setFont(_: NSFont): any;
        formatter: Formatter;
        setFormatter(_: Formatter): any;
        isHighlighted: boolean;
        setHighlighted(_: boolean): any;
        ignoresMultiClick: boolean;
        setIgnoresMultiClick(_: boolean): any;
        intValue: number;
        setIntValue(_: number): any;
        integerValue: number;
        setIntegerValue(_: number): any;
        lineBreakMode: NSLineBreakMode;
        setLineBreakMode(_: NSLineBreakMode): any;
        objectValue: any;
        setObjectValue(_: any): any;
        refusesFirstResponder: boolean;
        setRefusesFirstResponder(_: boolean): any;
        stringValue: string;
        setStringValue(_: string): any;
        target: any;
        setTarget(_: any): any;
        usesSingleLineMode: boolean;
        setUsesSingleLineMode(_: boolean): any;
        static cellClass: typeof NSObject;
        setCellClass(_: typeof NSObject): any;
        abortEditing(): boolean;
        currentEditor(): NSText;
        drawCell(_: NSCell): void;
        drawCellInside(_: NSCell): void;
        drawWithExpansionFrameInView(withExpansionFrame: CGRect, in_: NSView): void;
        editWithFrameEditorDelegateEvent(withFrame: CGRect, editor: NSText, delegate?: any, event?: NSEvent): void;
        endEditing(_: NSText): void;
        expansionFrameWithFrame(withFrame: CGRect): CGRect;
        invalidateIntrinsicContentSizeForCell(for_: NSCell): void;
        performClick(_?: any): void;
        selectCell(_: NSCell): void;
        selectWithFrameEditorDelegateStartLength(withFrame: CGRect, editor: NSText, delegate?: any, start?: number, length?: number): void;
        selectedCell(): NSCell;
        selectedTag(): number;
        sendActionTo(_?: string, to?: any): boolean;
        sendActionOn(on: NSEvent.EventTypeMask): number;
        sizeThatFits(_: CGSize): CGSize;
        sizeToFit(): void;
        takeDoubleValueFrom(_?: any): void;
        takeFloatValueFrom(_?: any): void;
        takeIntValueFrom(_?: any): void;
        takeIntegerValueFrom(_?: any): void;
        takeObjectValueFrom(_?: any): void;
        takeStringValueFrom(_?: any): void;
        updateCell(_: NSCell): void;
        updateCellInside(_: NSCell): void;
        validateEditing(): void;
    }
    interface NSControlTextEditingDelegate extends NSObject {
        controlTextViewDoCommandBySelector?(_: NSControl, textView: NSTextView, doCommandBy: string): boolean;
        controlDidFailToFormatStringErrorDescription?(_: NSControl, didFailToFormatString: string, errorDescription?: string): boolean;
        controlDidFailToValidatePartialStringErrorDescription?(_: NSControl, didFailToValidatePartialString: string, errorDescription?: string): void;
        controlIsValidObject?(_: NSControl, isValidObject?: any): boolean;
        controlTextShouldBeginEditing?(_: NSControl, textShouldBeginEditing: NSText): boolean;
        controlTextShouldEndEditing?(_: NSControl, textShouldEndEditing: NSText): boolean;
        controlTextViewCompletionsForPartialWordRangeIndexOfSelectedItem?(_: NSControl, textView: NSTextView, completions: string[], forPartialWordRange: NSRange, indexOfSelectedItem: number): string[];
        controlTextDidBeginEditing?(_: NSNotification): void;
        controlTextDidChange?(_: NSNotification): void;
        controlTextDidEndEditing?(_: NSNotification): void;
    }
    class NSController extends NSObject {
        isEditing: boolean;
    }
    class NSCursor extends NSObject {
        static hide(): void;
        static pop(): void;
        static setHiddenUntilMouseMoves(_: boolean): void;
        static unhide(): void;
        hotSpot: CGPoint;
        image: NSImage;
        static IBeamCursor: NSCursor;
        static IBeamCursorForVerticalLayout: NSCursor;
        static arrowCursor: NSCursor;
        static closedHandCursor: NSCursor;
        static contextualMenuCursor: NSCursor;
        static crosshairCursor: NSCursor;
        static currentCursor: NSCursor;
        static currentSystemCursor: NSCursor;
        static disappearingItemCursor: NSCursor;
        static dragCopyCursor: NSCursor;
        static dragLinkCursor: NSCursor;
        static openHandCursor: NSCursor;
        static operationNotAllowedCursor: NSCursor;
        static pointingHandCursor: NSCursor;
        static resizeDownCursor: NSCursor;
        static resizeLeftCursor: NSCursor;
        static resizeLeftRightCursor: NSCursor;
        static resizeRightCursor: NSCursor;
        static resizeUpCursor: NSCursor;
        static resizeUpDownCursor: NSCursor;
        static createWithImageHotSpot(image: NSImage, hotSpot: CGPoint): NSCursor;
        pop(): void;
        push(): void;
        set(): void;
    }
    class NSCustomImageRep extends NSImageRep {
        delegate: any;
        drawSelector: string;
        drawingHandler: (p1: CGRect) => boolean;
        static createWithDrawSelectorDelegate(drawSelector: string, delegate: any): NSCustomImageRep;
        static createWithSizeFlippedDrawingHandler(size: CGSize, flipped: boolean, drawingHandler: (p1: CGRect) => boolean): NSCustomImageRep;
    }
    class NSCustomTouchBarItem extends NSTouchBarItem {
    }
    class NSDataAsset extends NSObject {
        data: NSData;
        name: string;
        typeIdentifier: string;
        static createWithName(name: string): NSDataAsset;
        static createWithNameBundle(name: string, bundle: Bundle): NSDataAsset;
    }
    class NSDatePicker extends NSControl {
        backgroundColor: NSColor;
        setBackgroundColor(_: NSColor): any;
        isBezeled: boolean;
        setBezeled(_: boolean): any;
        isBordered: boolean;
        setBordered(_: boolean): any;
        calendar: NSCalendar;
        setCalendar(_: NSCalendar): any;
        datePickerElements: NSDatePicker.ElementFlags;
        setDatePickerElements(_: NSDatePicker.ElementFlags): any;
        datePickerMode: NSDatePicker.Mode;
        setDatePickerMode(_: NSDatePicker.Mode): any;
        datePickerStyle: NSDatePicker.Style;
        setDatePickerStyle(_: NSDatePicker.Style): any;
        dateValue: Date;
        setDateValue(_: Date): any;
        delegate: NSDatePickerCellDelegate;
        setDelegate(_: NSDatePickerCellDelegate): any;
        drawsBackground: boolean;
        setDrawsBackground(_: boolean): any;
        locale: NSLocale;
        setLocale(_: NSLocale): any;
        maxDate: Date;
        setMaxDate(_: Date): any;
        minDate: Date;
        setMinDate(_: Date): any;
        presentsCalendarOverlay: boolean;
        setPresentsCalendarOverlay(_: boolean): any;
        textColor: NSColor;
        setTextColor(_: NSColor): any;
        timeInterval: number;
        setTimeInterval(_: number): any;
        timeZone: NSTimeZone;
        setTimeZone(_: NSTimeZone): any;
    }
    class NSDatePickerCell extends NSActionCell {
        backgroundColor: NSColor;
        setBackgroundColor(_: NSColor): any;
        calendar: NSCalendar;
        setCalendar(_: NSCalendar): any;
        datePickerElements: NSDatePicker.ElementFlags;
        setDatePickerElements(_: NSDatePicker.ElementFlags): any;
        datePickerMode: NSDatePicker.Mode;
        setDatePickerMode(_: NSDatePicker.Mode): any;
        datePickerStyle: NSDatePicker.Style;
        setDatePickerStyle(_: NSDatePicker.Style): any;
        dateValue: Date;
        setDateValue(_: Date): any;
        delegate: NSDatePickerCellDelegate;
        setDelegate(_: NSDatePickerCellDelegate): any;
        drawsBackground: boolean;
        setDrawsBackground(_: boolean): any;
        locale: NSLocale;
        setLocale(_: NSLocale): any;
        maxDate: Date;
        setMaxDate(_: Date): any;
        minDate: Date;
        setMinDate(_: Date): any;
        textColor: NSColor;
        setTextColor(_: NSColor): any;
        timeInterval: number;
        setTimeInterval(_: number): any;
        timeZone: NSTimeZone;
        setTimeZone(_: NSTimeZone): any;
    }
    interface NSDatePickerCellDelegate extends NSObject {
        datePickerCellValidateProposedDateValueTimeInterval?(_: NSDatePickerCell, validateProposedDateValue: Date, timeInterval?: number): void;
    }
    class NSDictionaryController extends NSArrayController {
        excludedKeys: string[];
        setExcludedKeys(_: string[]): any;
        includedKeys: string[];
        setIncludedKeys(_: string[]): any;
        initialKey: string;
        setInitialKey(_: string): any;
        initialValue: any;
        setInitialValue(_: any): any;
        localizedKeyDictionary: Map<string, string>;
        setLocalizedKeyDictionary(_: Map<string, string>): any;
        localizedKeyTable: string;
        setLocalizedKeyTable(_: string): any;
    }
    class NSDictionaryControllerKeyValuePair extends NSObject {
        isExplicitlyIncluded: boolean;
        key: string;
        setKey(_: string): any;
        localizedKey: string;
        setLocalizedKey(_: string): any;
        value: any;
        setValue(_: any): any;
    }
    class NSDiffableDataSourceSnapshotReference<SectionIdentifierType, ItemIdentifierType> extends NSObject {
        itemIdentifiers: ItemIdentifierType[];
        numberOfItems: number;
        numberOfSections: number;
        sectionIdentifiers: SectionIdentifierType[];
        appendItemsWithIdentifiers(_: ItemIdentifierType[]): void;
        appendItemsWithIdentifiersIntoSectionWithIdentifier(_: ItemIdentifierType[], intoSectionWithIdentifier: SectionIdentifierType): void;
        appendSectionsWithIdentifiers(_: any[]): void;
        deleteAllItems(): void;
        deleteItemsWithIdentifiers(_: ItemIdentifierType[]): void;
        deleteSectionsWithIdentifiers(_: SectionIdentifierType[]): void;
        indexOfItemIdentifier(_: ItemIdentifierType): number;
        indexOfSectionIdentifier(_: SectionIdentifierType): number;
        insertItemsWithIdentifiersAfterItemWithIdentifier(_: ItemIdentifierType[], afterItemWithIdentifier: ItemIdentifierType): void;
        insertItemsWithIdentifiersBeforeItemWithIdentifier(_: ItemIdentifierType[], beforeItemWithIdentifier: ItemIdentifierType): void;
        insertSectionsWithIdentifiersAfterSectionWithIdentifier(_: SectionIdentifierType[], afterSectionWithIdentifier: SectionIdentifierType): void;
        insertSectionsWithIdentifiersBeforeSectionWithIdentifier(_: SectionIdentifierType[], beforeSectionWithIdentifier: SectionIdentifierType): void;
        itemIdentifiersInSectionWithIdentifier(_: SectionIdentifierType): ItemIdentifierType[];
        moveItemWithIdentifierAfterItemWithIdentifier(_: ItemIdentifierType, afterItemWithIdentifier: ItemIdentifierType): void;
        moveItemWithIdentifierBeforeItemWithIdentifier(_: ItemIdentifierType, beforeItemWithIdentifier: ItemIdentifierType): void;
        moveSectionWithIdentifierAfterSectionWithIdentifier(_: SectionIdentifierType, afterSectionWithIdentifier: SectionIdentifierType): void;
        moveSectionWithIdentifierBeforeSectionWithIdentifier(_: SectionIdentifierType, beforeSectionWithIdentifier: SectionIdentifierType): void;
        numberOfItemsInSection(_: SectionIdentifierType): number;
        reloadItemsWithIdentifiers(_: ItemIdentifierType[]): void;
        reloadSectionsWithIdentifiers(_: SectionIdentifierType[]): void;
        sectionIdentifierForSectionContainingItemIdentifier(_: ItemIdentifierType): SectionIdentifierType;
    }
    interface NSDirectionalEdgeInsets {
        top: number;
        leading: number;
        bottom: number;
        trailing: number;
    }
    class NSDockTile extends NSObject {
        badgeLabel: string;
        setBadgeLabel(_: string): any;
        contentView: NSView;
        setContentView(_: NSView): any;
        owner: any;
        showsApplicationBadge: boolean;
        setShowsApplicationBadge(_: boolean): any;
        size: CGSize;
        display(): void;
    }
    interface NSDockTilePlugIn extends NSObject {
        dockMenu?(): NSMenu;
        setDockTile(_?: NSDockTile): void;
    }
    class NSDocument extends NSObject {
        static canConcurrentlyReadDocumentsOfType(ofType: string): boolean;
        static isNativeType(_: string): boolean;
        PDFPrintOperation: NSPrintOperation;
        allowsDocumentSharing: boolean;
        autosavedContentsFileURL: NSURL;
        setAutosavedContentsFileURL(_: NSURL): any;
        autosavingFileType: string;
        autosavingIsImplicitlyCancellable: boolean;
        backupFileURL: NSURL;
        isBrowsingVersions: boolean;
        displayName: string;
        setDisplayName(_: string): any;
        isDocumentEdited: boolean;
        isDraft: boolean;
        setDraft(_: boolean): any;
        isEntireFileLoaded: boolean;
        fileModificationDate: Date;
        setFileModificationDate(_: Date): any;
        fileNameExtensionWasHiddenInLastRunSavePanel: boolean;
        fileType: string;
        setFileType(_: string): any;
        fileTypeFromLastRunSavePanel: string;
        fileURL: NSURL;
        setFileURL(_: NSURL): any;
        hasUnautosavedChanges: boolean;
        hasUndoManager: boolean;
        setHasUndoManager(_: boolean): any;
        isInViewingMode: boolean;
        keepBackupFile: boolean;
        lastComponentOfFileName: string;
        setLastComponentOfFileName(_: string): any;
        isLocked: boolean;
        printInfo: NSPrintInfo;
        setPrintInfo(_: NSPrintInfo): any;
        shouldRunSavePanelWithAccessoryView: boolean;
        undoManager: UndoManager;
        setUndoManager(_: UndoManager): any;
        userActivity: NSUserActivity;
        setUserActivity(_: NSUserActivity): any;
        windowControllers: NSWindowController[];
        windowForSheet: NSWindow;
        windowNibName: string;
        static autosavesDrafts: boolean;
        static autosavesInPlace: boolean;
        static preservesVersions: boolean;
        static readableTypes: string[];
        static restorableStateKeyPaths: string[];
        static usesUbiquitousStorage: boolean;
        static writableTypes: string[];
        addWindowController(_: NSWindowController): void;
        autosaveDocumentWithDelegateDidAutosaveSelectorContextInfo(withDelegate?: any, didAutosave?: string, contextInfo?: any): void;
        autosaveWithWithImplicitCancellabilityCompletionHandler(withImplicitCancellability: boolean, completionHandler?: (p1: NSError) => void): void;
        browseDocumentVersions(_?: any): void;
        canAsynchronouslyWriteToURLOfTypeForSaveOperation(to: NSURL, ofType: string, for_: NSDocument.SaveOperationType): boolean;
        canCloseDocumentWithDelegateShouldCloseSelectorContextInfo(withDelegate: any, shouldClose?: string, contextInfo?: any): void;
        changeCountTokenForSaveOperation(for_: NSDocument.SaveOperationType): any;
        checkAutosavingSafetyAndReturnError(): boolean;
        close(): void;
        continueActivity(_: () => void): void;
        continueAsynchronousWorkOnMainThread(_: () => void): void;
        dataOfTypeError(error: string): NSData;
        defaultDraftName(): string;
        duplicateAndReturnError(): NSDocument;
        duplicateDocument(_?: any): void;
        duplicateDocumentWithDelegateDidDuplicateSelectorContextInfo(withDelegate?: any, didDuplicate?: string, contextInfo?: any): void;
        encodeRestorableStateWithCoder(with_: NSCoder): void;
        encodeRestorableStateWithCoderBackgroundQueue(with_: NSCoder, backgroundQueue: OperationQueue): void;
        fileAttributesToWriteToURLOfTypeForSaveOperationOriginalContentsURLError(ofType: NSURL, forSaveOperation: string, originalContentsURL: NSDocument.SaveOperationType, error?: NSURL): Map<string, any>;
        fileNameExtensionForTypeSaveOperation(forType: string, saveOperation: NSDocument.SaveOperationType): string;
        fileWrapperOfTypeError(error: string): FileWrapper;
        handleCloseScriptCommand(_: NSCloseCommand): any;
        handlePrintScriptCommand(_: NSScriptCommand): any;
        handleSaveScriptCommand(_: NSScriptCommand): any;
        static createWithForURLWithContentsOfURLOfType(forURL?: NSURL, withContentsOfURL?: NSURL, ofType?: string): NSDocument;
        static createWithContentsOfURLOfType(contentsOfURL: NSURL, ofType: string): NSDocument;
        static createWithType(type: string): NSDocument;
        invalidateRestorableState(): void;
        lockDocument(_?: any): void;
        lockWithCompletionHandler(completionHandler?: (p1: boolean) => void): void;
        lockWithCompletionHandler(completionHandler?: (p1: NSError) => void): void;
        makeWindowControllers(): void;
        moveDocument(_?: any): void;
        moveDocumentToUbiquityContainer(_?: any): void;
        moveWithCompletionHandler(completionHandler?: (p1: boolean) => void): void;
        moveWithToCompletionHandler(to: NSURL, completionHandler?: (p1: NSError) => void): void;
        performActivityWithWithSynchronousWaitingUsing(withSynchronousWaiting: boolean, using: (p1: () => void) => void): void;
        performAsynchronousFileAccess(_: (p1: () => void) => void): void;
        performSynchronousFileAccess(_: () => void): void;
        preparePageLayout(_: NSPageLayout): boolean;
        prepareSavePanel(_: NSSavePanel): boolean;
        prepareSharingServicePicker(_: NSSharingServicePicker): void;
        presentError(_: NSError): boolean;
        presentErrorModalForWindowDelegateDidPresentSelectorContextInfo(_: NSError, modalFor: NSWindow, delegate?: any, didPresent?: string, contextInfo?: any): void;
        printDocument(_?: any): void;
        printDocumentWithSettingsShowPrintPanelDelegateDidPrintSelectorContextInfo(withSettings: Map<string, any>, showPrintPanel: boolean, delegate?: any, didPrint?: string, contextInfo?: any): void;
        printOperationWithSettingsError(error: Map<string, any>): NSPrintOperation;
        readFromDataOfTypeError(ofType: NSData, error: string): boolean;
        readFromFileWrapperOfTypeError(ofType: FileWrapper, error: string): boolean;
        readFromURLOfTypeError(ofType: NSURL, error: string): boolean;
        removeWindowController(_: NSWindowController): void;
        renameDocument(_?: any): void;
        restoreWindowWithWithIdentifierStateCompletionHandler(withIdentifier: string, state: NSCoder, completionHandler?: (p1: NSWindow, p2: NSError) => void): void;
        restoreStateWithCoder(with_: NSCoder): void;
        revertDocumentToSaved(_?: any): void;
        revertToContentsOfURLOfTypeError(ofType: NSURL, error: string): boolean;
        runModalPageLayoutWithPrintInfoDelegateDidRunSelectorContextInfo(with_: NSPrintInfo, delegate?: any, didRun?: string, contextInfo?: any): void;
        runModalPrintOperationDelegateDidRunSelectorContextInfo(_: NSPrintOperation, delegate?: any, didRun?: string, contextInfo?: any): void;
        runModalSavePanelForSaveOperationDelegateDidSaveSelectorContextInfo(for_: NSDocument.SaveOperationType, delegate?: any, didSave?: string, contextInfo?: any): void;
        runPageLayout(_?: any): void;
        saveDocument(_?: any): void;
        saveDocumentAs(_?: any): void;
        saveDocumentTo(_?: any): void;
        saveDocumentToPDF(_?: any): void;
        saveDocumentWithDelegateDidSaveSelectorContextInfo(withDelegate?: any, didSave?: string, contextInfo?: any): void;
        saveWithToOfTypeForCompletionHandler(to: NSURL, ofType: string, for_: NSDocument.SaveOperationType, completionHandler?: (p1: NSError) => void): void;
        saveToURLOfTypeForSaveOperationDelegateDidSaveSelectorContextInfo(to: NSURL, ofType: string, for_: NSDocument.SaveOperationType, delegate?: any, didSave?: string, contextInfo?: any): void;
        scheduleAutosaving(): void;
        setDisplayName(_?: string): void;
        setWindow(_?: NSWindow): void;
        shareWithWithCompletionHandler(with_: NSSharingService, completionHandler?: (p1: boolean) => void): void;
        shouldChangePrintInfo(_: NSPrintInfo): boolean;
        shouldCloseWindowControllerDelegateShouldCloseSelectorContextInfo(_: NSWindowController, delegate?: any, shouldClose?: string, contextInfo?: any): void;
        showWindows(): void;
        stopBrowsingVersionsWithCompletionHandler(completionHandler?: () => void): void;
        unblockUserInteraction(): void;
        unlockDocument(_?: any): void;
        unlockWithCompletionHandler(completionHandler?: (p1: boolean) => void): void;
        unlockWithCompletionHandler(completionHandler?: (p1: NSError) => void): void;
        updateChangeCount(_: NSDocument.ChangeType): void;
        updateChangeCountWithTokenForSaveOperation(withToken: any, for_: NSDocument.SaveOperationType): void;
        updateUserActivityState(_: NSUserActivity): void;
        willNotPresentError(_: NSError): void;
        willPresentError(_: NSError): NSError;
        windowControllerDidLoadNib(_: NSWindowController): void;
        windowControllerWillLoadNib(_: NSWindowController): void;
        writableTypesForSaveOperation(for_: NSDocument.SaveOperationType): string[];
        writeSafelyToURLOfTypeForSaveOperationError(ofType: NSURL, forSaveOperation: string, error: NSDocument.SaveOperationType): boolean;
        writeToURLOfTypeError(ofType: NSURL, error: string): boolean;
        writeToURLOfTypeForSaveOperationOriginalContentsURLError(ofType: NSURL, forSaveOperation: string, originalContentsURL: NSDocument.SaveOperationType, error?: NSURL): boolean;
    }
    class NSDocumentController extends NSObject {
        allowsAutomaticShareMenu: boolean;
        autosavingDelay: number;
        setAutosavingDelay(_: number): any;
        currentDirectory: string;
        currentDocument: NSDocument;
        defaultType: string;
        documentClassNames: string[];
        documents: NSDocument[];
        hasEditedDocuments: boolean;
        maximumRecentDocumentCount: number;
        recentDocumentURLs: NSURL[];
        static sharedDocumentController: NSDocumentController;
        URLsFromRunningOpenPanel(): NSURL[];
        addDocument(_: NSDocument): void;
        beginOpenPanelForTypesCompletionHandler(_: NSOpenPanel, forTypes?: string[], completionHandler?: (p1: number) => void): void;
        beginOpenPanelWithCompletionHandler(completionHandler?: (p1: NSURL[]) => void): void;
        clearRecentDocuments(_?: any): void;
        closeAllDocumentsWithDelegateDidCloseAllSelectorContextInfo(withDelegate?: any, didCloseAllSelector?: string, contextInfo?: any): void;
        displayNameForType(forType: string): string;
        documentClassForType(forType: string): typeof NSObject;
        documentForURL(for_: NSURL): NSDocument;
        documentForWindow(for_: NSWindow): NSDocument;
        duplicateDocumentWithContentsOfURLCopyingDisplayNameError(copying: NSURL, displayName: boolean, error?: string): NSDocument;
        makeDocumentForURLWithContentsOfURLOfTypeError(withContentsOfURL?: NSURL, ofType?: NSURL, error?: string): NSDocument;
        makeDocumentWithContentsOfURLOfTypeError(ofType: NSURL, error: string): NSDocument;
        makeUntitledDocumentOfTypeError(error: string): NSDocument;
        newDocument(_?: any): void;
        noteNewRecentDocument(_: NSDocument): void;
        noteNewRecentDocumentURL(_: NSURL): void;
        openDocument(_?: any): void;
        openDocumentWithWithContentsOfDisplayCompletionHandler(withContentsOf: NSURL, display: boolean, completionHandler?: (p1: NSDocument, p2: boolean, p3: NSError) => void): void;
        openUntitledDocumentAndDisplayError(error: boolean): NSDocument;
        presentError(_: NSError): boolean;
        presentErrorModalForWindowDelegateDidPresentSelectorContextInfo(_: NSError, modalFor: NSWindow, delegate?: any, didPresent?: string, contextInfo?: any): void;
        removeDocument(_: NSDocument): void;
        reopenDocumentForWithContentsOfDisplayCompletionHandler(for_?: NSURL, withContentsOf?: NSURL, display?: boolean, completionHandler?: (p1: NSDocument, p2: boolean, p3: NSError) => void): void;
        reviewUnsavedDocumentsWithAlertTitleCancellableDelegateDidReviewAllSelectorContextInfo(withAlertTitle?: string, cancellable?: boolean, delegate?: any, didReviewAllSelector?: string, contextInfo?: any): void;
        runModalOpenPanelForTypes(_: NSOpenPanel, forTypes?: string[]): number;
        saveAllDocuments(_?: any): void;
        standardShareMenuItem(): NSMenuItem;
        typeForContentsOfURLError(error: NSURL): string;
        willPresentError(_: NSError): NSError;
    }
    interface NSDraggingDestination extends NSObject {
        concludeDragOperation?(_?: NSDraggingInfo): void;
        draggingEnded?(_: NSDraggingInfo): void;
        draggingEntered?(_: NSDraggingInfo): NSDragOperation;
        draggingExited?(_?: NSDraggingInfo): void;
        draggingUpdated?(_: NSDraggingInfo): NSDragOperation;
        performDragOperation?(_: NSDraggingInfo): boolean;
        prepareForDragOperation?(_: NSDraggingInfo): boolean;
        updateDraggingItemsForDrag?(_?: NSDraggingInfo): void;
        wantsPeriodicDraggingUpdates?(): boolean;
    }
    class NSDraggingImageComponent extends NSObject {
        static draggingImageComponentWithKey(key: string): NSDraggingImageComponent;
        contents: any;
        setContents(_: any): any;
        frame: CGRect;
        setFrame(_: CGRect): any;
        key: string;
        setKey(_: string): any;
        static createWithKey(key: string): NSDraggingImageComponent;
    }
    interface NSDraggingInfo extends NSObject {
        animatesToDestination: boolean;
        setAnimatesToDestination(_: boolean): any;
        draggedImage: NSImage;
        draggedImageLocation: CGPoint;
        draggingDestinationWindow: NSWindow;
        draggingFormation: NSDraggingFormation;
        setDraggingFormation(_: NSDraggingFormation): any;
        draggingLocation: CGPoint;
        draggingPasteboard: NSPasteboard;
        draggingSequenceNumber: number;
        draggingSource: any;
        draggingSourceOperationMask: NSDragOperation;
        numberOfValidItemsForDrop: number;
        setNumberOfValidItemsForDrop(_: number): any;
        springLoadingHighlight: NSSpringLoadingHighlight;
        enumerateDraggingItemsWithOptionsForClassesSearchOptionsUsing(options: NSDraggingItemEnumerationOptions, for_?: NSView, classes?: typeof NSObject[], searchOptions?: Map<string, any>, using?: (p1: NSDraggingItem, p2: number, p3: boolean) => void): void;
        resetSpringLoading(): void;
        slideDraggedImageTo(to: CGPoint): void;
    }
    class NSDraggingItem extends NSObject {
        draggingFrame: CGRect;
        setDraggingFrame(_: CGRect): any;
        imageComponents: NSDraggingImageComponent[];
        imageComponentsProvider: () => NSDraggingImageComponent[];
        setImageComponentsProvider(_: () => NSDraggingImageComponent[]): any;
        item: any;
        static createWithPasteboardWriter(pasteboardWriter: NSPasteboardWriting): NSDraggingItem;
        setDraggingFrameContents(_: CGRect, contents?: any): void;
    }
    class NSDraggingSession extends NSObject {
        animatesToStartingPositionsOnCancelOrFail: boolean;
        setAnimatesToStartingPositionsOnCancelOrFail(_: boolean): any;
        draggingFormation: NSDraggingFormation;
        setDraggingFormation(_: NSDraggingFormation): any;
        draggingLeaderIndex: number;
        setDraggingLeaderIndex(_: number): any;
        draggingLocation: CGPoint;
        draggingPasteboard: NSPasteboard;
        draggingSequenceNumber: number;
        enumerateDraggingItemsWithOptionsForClassesSearchOptionsUsing(options: NSDraggingItemEnumerationOptions, for_?: NSView, classes?: typeof NSObject[], searchOptions?: Map<string, any>, using?: (p1: NSDraggingItem, p2: number, p3: boolean) => void): void;
    }
    interface NSDraggingSource extends NSObject {
        draggingSessionSourceOperationMaskForDraggingContext(_: NSDraggingSession, sourceOperationMaskFor: NSDraggingContext): NSDragOperation;
        draggingSessionWillBeginAtPoint?(_: NSDraggingSession, willBeginAt: CGPoint): void;
        draggingSessionMovedToPoint?(_: NSDraggingSession, movedTo: CGPoint): void;
        draggingSessionEndedAtPointOperation?(_: NSDraggingSession, endedAt: CGPoint, operation: NSDragOperation): void;
        ignoreModifierKeysForDraggingSession?(for_: NSDraggingSession): boolean;
    }
    interface NSDrawerDelegate extends NSObject {
    }
    class NSEPSImageRep extends NSImageRep {
        EPSRepresentation: NSData;
        boundingBox: CGRect;
        static createWithData(data: NSData): NSEPSImageRep;
    }
    interface NSEditor extends NSObject {
        commitEditing(): boolean;
        commitEditingWithDelegateDidCommitSelectorContextInfo(withDelegate?: any, didCommit?: string, contextInfo?: any): void;
        commitEditingAndReturnError(): boolean;
        discardEditing(): void;
    }
    interface NSEditorRegistration extends NSObject {
        objectDidBeginEditing?(_: NSEditor): void;
        objectDidEndEditing?(_: NSEditor): void;
    }
    class NSEvent extends NSObject {
        static addGlobalMonitorForEventsWithMatchingHandler(matching: NSEvent.EventTypeMask, handler: (p1: NSEvent) => void): any;
        static addLocalMonitorForEventsWithMatchingHandler(matching: NSEvent.EventTypeMask, handler?: (p1: NSEvent) => NSEvent): any;
        static enterExitEventWithTypeLocationModifierFlagsTimestampWindowNumberContextEventNumberTrackingNumberUserData(with_: NSEvent.EventType, location: CGPoint, modifierFlags: NSEvent.ModifierFlags, timestamp: number, windowNumber: number, context?: NSGraphicsContext, eventNumber?: number, trackingNumber?: number, userData?: any): NSEvent;
        static keyEventWithTypeLocationModifierFlagsTimestampWindowNumberContextCharactersCharactersIgnoringModifiersIsARepeatKeyCode(with_: NSEvent.EventType, location: CGPoint, modifierFlags: NSEvent.ModifierFlags, timestamp: number, windowNumber: number, context?: NSGraphicsContext, characters?: string, charactersIgnoringModifiers?: string, isARepeat?: boolean, keyCode?: number): NSEvent;
        static mouseEventWithTypeLocationModifierFlagsTimestampWindowNumberContextEventNumberClickCountPressure(with_: NSEvent.EventType, location: CGPoint, modifierFlags: NSEvent.ModifierFlags, timestamp: number, windowNumber: number, context?: NSGraphicsContext, eventNumber?: number, clickCount?: number, pressure?: number): NSEvent;
        static otherEventWithTypeLocationModifierFlagsTimestampWindowNumberContextSubtypeData1Data2(with_: NSEvent.EventType, location: CGPoint, modifierFlags: NSEvent.ModifierFlags, timestamp: number, windowNumber: number, context?: NSGraphicsContext, subtype?: number, data1?: number, data2?: number): NSEvent;
        static removeMonitor(_: any): void;
        static startPeriodicEventsAfterDelayWithPeriod(afterDelay: number, withPeriod: number): void;
        static stopPeriodicEvents(): void;
        isARepeat: boolean;
        CGEvent: any;
        absoluteX: number;
        absoluteY: number;
        absoluteZ: number;
        associatedEventsMask: NSEvent.EventTypeMask;
        buttonMask: NSEvent.ButtonMask;
        buttonNumber: number;
        capabilityMask: number;
        characters: string;
        charactersIgnoringModifiers: string;
        clickCount: number;
        data1: number;
        data2: number;
        deltaX: number;
        deltaY: number;
        deltaZ: number;
        deviceID: number;
        isDirectionInvertedFromDevice: boolean;
        isEnteringProximity: boolean;
        eventNumber: number;
        eventRef: any;
        hasPreciseScrollingDeltas: boolean;
        keyCode: number;
        locationInWindow: CGPoint;
        magnification: number;
        momentumPhase: NSEvent.Phase;
        phase: NSEvent.Phase;
        pointingDeviceID: number;
        pointingDeviceSerialNumber: number;
        pointingDeviceType: NSEvent.PointingDeviceType;
        pressure: number;
        pressureBehavior: NSEvent.PressureBehavior;
        rotation: number;
        scrollingDeltaX: number;
        scrollingDeltaY: number;
        stage: number;
        stageTransition: number;
        subtype: NSEvent.EventSubtype;
        systemTabletID: number;
        tabletID: number;
        tangentialPressure: number;
        tilt: CGPoint;
        timestamp: number;
        trackingArea: NSTrackingArea;
        trackingNumber: number;
        type: NSEvent.EventType;
        uniqueID: number;
        userData: any;
        vendorDefined: any;
        vendorID: number;
        vendorPointingDeviceType: number;
        window: NSWindow;
        windowNumber: number;
        static doubleClickInterval: number;
        static keyRepeatDelay: number;
        static keyRepeatInterval: number;
        static modifierFlags: NSEvent.ModifierFlags;
        static isMouseCoalescingEnabled: boolean;
        setMouseCoalescingEnabled(_: boolean): any;
        static mouseLocation: CGPoint;
        static pressedMouseButtons: number;
        static isSwipeTrackingFromScrollEventsEnabled: boolean;
        allTouches(): NSSet<NSTouch>;
        charactersByApplyingModifiers(byApplyingModifiers: NSEvent.ModifierFlags): string;
        coalescedTouchesForTouch(for_: NSTouch): NSTouch[];
        touchesForView(for_: NSView): NSSet<NSTouch>;
        touchesMatchingPhaseInView(matching: NSTouch.Phase, in_?: NSView): NSSet<NSTouch>;
        trackSwipeEventWithOptionsDampenAmountThresholdMinMaxUsingHandler(options: NSEvent.SwipeTrackingOptions, dampenAmountThresholdMin: number, max: number, usingHandler: (p1: number, p2: NSEvent.Phase, p3: boolean, p4: boolean) => void): void;
    }
    class NSFilePromiseProvider extends NSObject {
        delegate: NSFilePromiseProviderDelegate;
        setDelegate(_: NSFilePromiseProviderDelegate): any;
        fileType: string;
        setFileType(_: string): any;
        userInfo: any;
        setUserInfo(_: any): any;
        static createWithFileTypeDelegate(fileType: string, delegate: NSFilePromiseProviderDelegate): NSFilePromiseProvider;
    }
    interface NSFilePromiseProviderDelegate extends NSObject {
        filePromiseProviderWritePromiseToCompletionHandler(_: NSFilePromiseProvider, writePromiseTo: NSURL, completionHandler?: (p1: NSError) => void): void;
        filePromiseProviderFileNameForType(_: NSFilePromiseProvider, fileNameForType: string): string;
        operationQueueForFilePromiseProvider?(for_: NSFilePromiseProvider): OperationQueue;
    }
    class NSFilePromiseReceiver extends NSObject {
        fileNames: string[];
        fileTypes: string[];
        static readableDraggedTypes: string[];
        receivePromisedFilesWithAtDestinationOptionsOperationQueueReader(atDestination: NSURL, options: Map<any, any>, operationQueue: OperationQueue, reader?: (p1: NSURL, p2: NSError) => void): void;
    }
    class NSFont extends NSObject {
        static boldSystemFontOfSize(ofSize: number): NSFont;
        static controlContentFontOfSize(ofSize: number): NSFont;
        static labelFontOfSize(ofSize: number): NSFont;
        static menuBarFontOfSize(ofSize: number): NSFont;
        static menuFontOfSize(ofSize: number): NSFont;
        static messageFontOfSize(ofSize: number): NSFont;
        static monospacedDigitSystemFontOfSizeWeight(ofSize: number, weight: number): NSFont;
        static monospacedSystemFontOfSizeWeight(ofSize: number, weight: number): NSFont;
        static paletteFontOfSize(ofSize: number): NSFont;
        static setUserFixedPitchFont(_?: NSFont): void;
        static setUserFont(_?: NSFont): void;
        static systemFontOfSize(ofSize: number): NSFont;
        static systemFontOfSizeWeight(ofSize: number, weight: number): NSFont;
        static systemFontSizeForControlSize(for_: NSControl.ControlSize): number;
        static titleBarFontOfSize(ofSize: number): NSFont;
        static toolTipsFontOfSize(ofSize: number): NSFont;
        static userFixedPitchFontOfSize(ofSize: number): NSFont;
        static userFontOfSize(ofSize: number): NSFont;
        ascender: number;
        boundingRectForFont: CGRect;
        capHeight: number;
        coveredCharacterSet: NSCharacterSet;
        descender: number;
        displayName: string;
        familyName: string;
        isFixedPitch: boolean;
        fontDescriptor: NSFontDescriptor;
        fontName: string;
        italicAngle: number;
        leading: number;
        matrix: number;
        maximumAdvancement: CGSize;
        mostCompatibleStringEncoding: number;
        numberOfGlyphs: number;
        pointSize: number;
        printerFont: NSFont;
        renderingMode: NSFontRenderingMode;
        screenFont: NSFont;
        textTransform: NSAffineTransform;
        underlinePosition: number;
        underlineThickness: number;
        isVertical: boolean;
        verticalFont: NSFont;
        xHeight: number;
        static labelFontSize: number;
        static smallSystemFontSize: number;
        static systemFontSize: number;
        advancementForCGGlyph(forCGGlyph: number): CGSize;
        advancementForGlyph(forGlyph: number): CGSize;
        boundingRectForCGGlyph(forCGGlyph: number): CGRect;
        boundingRectForGlyph(forGlyph: number): CGRect;
        getAdvancementsForCGGlyphsCount(_: NSSize, forCGGlyphs: number, count: number): void;
        getAdvancementsForGlyphsCount(_: NSSize, forGlyphs: number, count: number): void;
        getAdvancementsForPackedGlyphsLength(_: NSSize, forPackedGlyphs: any, length: number): void;
        getBoundingRectsForCGGlyphsCount(_: NSRect, forCGGlyphs: number, count: number): void;
        getBoundingRectsForGlyphsCount(_: NSRect, forGlyphs: number, count: number): void;
        glyphWithName(withName: string): number;
        screenFontWithRenderingMode(with_: NSFontRenderingMode): NSFont;
        set(): void;
        setInContext(in_: NSGraphicsContext): void;
    }
    class NSFontAssetRequest extends NSObject {
        downloadedFontDescriptors: NSFontDescriptor[];
        downloadWithWithCompletionHandler(withCompletionHandler?: (p1: NSError) => boolean): void;
        static createWithFontDescriptorsOptions(fontDescriptors: NSFontDescriptor[], options: NSFontAssetRequest.Options): NSFontAssetRequest;
    }
    interface NSFontChanging extends NSObject {
        changeFont?(_?: NSFontManager): void;
        validModesForFontPanel?(_: NSFontPanel): NSFontPanel.ModeMask;
    }
    class NSFontCollection extends NSObject {
        static hideFontCollectionWithNameVisibilityError(visibility: string, error: NSFontCollection.Visibility): boolean;
        static renameFontCollectionWithNameVisibilityToNameError(fromName: string, visibility: NSFontCollection.Visibility, toName: string): boolean;
        static showFontCollectionWithNameVisibilityError(withName: NSFontCollection, visibility: string, error: NSFontCollection.Visibility): boolean;
        exclusionDescriptors: NSFontDescriptor[];
        matchingDescriptors: NSFontDescriptor[];
        queryDescriptors: NSFontDescriptor[];
        static allFontCollectionNames: string[];
        static fontCollectionWithAllAvailableDescriptors: NSFontCollection;
        matchingDescriptorsForFamily(forFamily: string): NSFontDescriptor[];
        matchingDescriptorsForFamilyOptions(forFamily: string, options?: Map<string, number>): NSFontDescriptor[];
        matchingDescriptorsWithOptions(options?: Map<string, number>): NSFontDescriptor[];
    }
    class NSFontDescriptor extends NSObject {
        fontAttributes: Map<string, any>;
        matrix: NSAffineTransform;
        pointSize: number;
        postscriptName: string;
        requiresFontAssetRequest: boolean;
        symbolicTraits: NSFontDescriptor.SymbolicTraits;
        fontDescriptorByAddingAttributes(_: Map<string, any>): NSFontDescriptor;
        fontDescriptorWithDesign(_: string): NSFontDescriptor;
        fontDescriptorWithFace(_: string): NSFontDescriptor;
        fontDescriptorWithFamily(_: string): NSFontDescriptor;
        fontDescriptorWithMatrix(_: NSAffineTransform): NSFontDescriptor;
        fontDescriptorWithSize(_: number): NSFontDescriptor;
        fontDescriptorWithSymbolicTraits(_: NSFontDescriptor.SymbolicTraits): NSFontDescriptor;
        static createWithFontAttributes(fontAttributes?: Map<string, any>): NSFontDescriptor;
        matchingFontDescriptorWithWithMandatoryKeys(withMandatoryKeys?: NSSet<string>): NSFontDescriptor;
        matchingFontDescriptorsWithWithMandatoryKeys(withMandatoryKeys?: NSSet<string>): NSFontDescriptor[];
        objectForKey(forKey: string): any;
    }
    class NSFontManager extends NSObject {
        static setFontManagerFactory(_?: typeof NSObject): void;
        static setFontPanelFactory(_?: typeof NSObject): void;
        action: string;
        setAction(_: string): any;
        availableFontFamilies: string[];
        availableFonts: string[];
        currentFontAction: NSFontAction;
        isEnabled: boolean;
        setEnabled(_: boolean): any;
        isMultiple: boolean;
        selectedFont: NSFont;
        target: any;
        setTarget(_: any): any;
        static sharedFontManager: NSFontManager;
        addFontTrait(_?: any): void;
        availableFontNamesWithTraits(with_: NSFontTraitMask): string[];
        availableMembersOfFontFamily(ofFontFamily: string): any[][];
        convertAttributes(_: Map<string, any>): Map<string, any>;
        convertFont(_: NSFont): NSFont;
        convertFontToFace(_: NSFont, toFace: string): NSFont;
        convertFontToFamily(_: NSFont, toFamily: string): NSFont;
        convertFontToHaveTrait(_: NSFont, toHaveTrait: NSFontTraitMask): NSFont;
        convertFontToNotHaveTrait(_: NSFont, toNotHaveTrait: NSFontTraitMask): NSFont;
        convertFontToSize(_: NSFont, toSize: number): NSFont;
        convertFontTraits(_: NSFontTraitMask): NSFontTraitMask;
        convertWeightOfFont(_: boolean, of: NSFont): NSFont;
        fontMenu(_: boolean): NSMenu;
        fontNamedHasTraits(_: string, hasTraits: NSFontTraitMask): boolean;
        fontPanel(_: boolean): NSFontPanel;
        fontWithFamilyTraitsWeightSize(withFamily: string, traits: NSFontTraitMask, weight: number, size: number): NSFont;
        localizedNameForFamilyFace(forFamily: string, face?: string): string;
        modifyFont(_?: any): void;
        modifyFontViaPanel(_?: any): void;
        orderFrontFontPanel(_?: any): void;
        orderFrontStylesPanel(_?: any): void;
        removeFontTrait(_?: any): void;
        sendAction(): boolean;
        setFontMenu(_: NSMenu): void;
        setSelectedAttributesIsMultiple(_: Map<string, any>, isMultiple: boolean): void;
        setSelectedFontIsMultiple(_: NSFont, isMultiple: boolean): void;
        traitsOfFont(of: NSFont): NSFontTraitMask;
        weightOfFont(of: NSFont): number;
    }
    class NSFontPanel extends NSPanel {
        accessoryView: NSView;
        setAccessoryView(_: NSView): any;
        isEnabled: boolean;
        setEnabled(_: boolean): any;
        static sharedFontPanel: NSFontPanel;
        static sharedFontPanelExists: boolean;
        panelConvertFont(_: NSFont): NSFont;
        reloadDefaultFontFamilies(): void;
        setPanelFontIsMultiple(_: NSFont, isMultiple: boolean): void;
    }
    class NSFormCell extends NSActionCell {
        attributedTitle: NSAttributedString;
        setAttributedTitle(_: NSAttributedString): any;
        placeholderAttributedString: NSAttributedString;
        setPlaceholderAttributedString(_: NSAttributedString): any;
        placeholderString: string;
        setPlaceholderString(_: string): any;
        preferredTextFieldWidth: number;
        setPreferredTextFieldWidth(_: number): any;
        titleAlignment: NSTextAlignment;
        setTitleAlignment(_: NSTextAlignment): any;
        titleBaseWritingDirection: NSWritingDirection;
        setTitleBaseWritingDirection(_: NSWritingDirection): any;
        titleFont: NSFont;
        setTitleFont(_: NSFont): any;
        titleWidth: number;
        setTitleWidth(_: number): any;
    }
    class NSGestureRecognizer extends NSObject {
        action: string;
        setAction(_: string): any;
        allowedTouchTypes: NSTouch.TouchTypeMask;
        setAllowedTouchTypes(_: NSTouch.TouchTypeMask): any;
        delaysKeyEvents: boolean;
        setDelaysKeyEvents(_: boolean): any;
        delaysMagnificationEvents: boolean;
        setDelaysMagnificationEvents(_: boolean): any;
        delaysOtherMouseButtonEvents: boolean;
        setDelaysOtherMouseButtonEvents(_: boolean): any;
        delaysPrimaryMouseButtonEvents: boolean;
        setDelaysPrimaryMouseButtonEvents(_: boolean): any;
        delaysRotationEvents: boolean;
        setDelaysRotationEvents(_: boolean): any;
        delaysSecondaryMouseButtonEvents: boolean;
        setDelaysSecondaryMouseButtonEvents(_: boolean): any;
        delegate: NSGestureRecognizerDelegate;
        setDelegate(_: NSGestureRecognizerDelegate): any;
        isEnabled: boolean;
        setEnabled(_: boolean): any;
        pressureConfiguration: NSPressureConfiguration;
        setPressureConfiguration(_: NSPressureConfiguration): any;
        state: NSGestureRecognizer.State;
        setState(_: NSGestureRecognizer.State): any;
        target: any;
        setTarget(_: any): any;
        view: NSView;
        canBePreventedByGestureRecognizer(by: NSGestureRecognizer): boolean;
        canPreventGestureRecognizer(_: NSGestureRecognizer): boolean;
        flagsChanged(with_: NSEvent): void;
        static createWithTargetAction(target?: any, action?: string): NSGestureRecognizer;
        keyDown(with_: NSEvent): void;
        keyUp(with_: NSEvent): void;
        locationInView(in_?: NSView): CGPoint;
        magnifyWithEvent(with_: NSEvent): void;
        mouseDown(with_: NSEvent): void;
        mouseDragged(with_: NSEvent): void;
        mouseUp(with_: NSEvent): void;
        otherMouseDown(with_: NSEvent): void;
        otherMouseDragged(with_: NSEvent): void;
        otherMouseUp(with_: NSEvent): void;
        pressureChangeWithEvent(with_: NSEvent): void;
        reset(): void;
        rightMouseDown(with_: NSEvent): void;
        rightMouseDragged(with_: NSEvent): void;
        rightMouseUp(with_: NSEvent): void;
        rotateWithEvent(with_: NSEvent): void;
        shouldBeRequiredToFailByGestureRecognizer(by: NSGestureRecognizer): boolean;
        shouldRequireFailureOfGestureRecognizer(of: NSGestureRecognizer): boolean;
        tabletPoint(with_: NSEvent): void;
        touchesBeganWithEvent(with_: NSEvent): void;
        touchesCancelledWithEvent(with_: NSEvent): void;
        touchesEndedWithEvent(with_: NSEvent): void;
        touchesMovedWithEvent(with_: NSEvent): void;
    }
    interface NSGestureRecognizerDelegate extends NSObject {
        gestureRecognizerShouldAttemptToRecognizeWithEvent?(_: NSGestureRecognizer, shouldAttemptToRecognizeWith: NSEvent): boolean;
        gestureRecognizerShouldRecognizeSimultaneouslyWithGestureRecognizer?(_: NSGestureRecognizer, shouldRecognizeSimultaneouslyWith: NSGestureRecognizer): boolean;
        gestureRecognizerShouldRequireFailureOfGestureRecognizer?(_: NSGestureRecognizer, shouldRequireFailureOf: NSGestureRecognizer): boolean;
        gestureRecognizerShouldBeRequiredToFailByGestureRecognizer?(_: NSGestureRecognizer, shouldBeRequiredToFailBy: NSGestureRecognizer): boolean;
        gestureRecognizerShouldReceiveTouch?(_: NSGestureRecognizer, shouldReceive: NSTouch): boolean;
        gestureRecognizerShouldBegin?(_: NSGestureRecognizer): boolean;
    }
    class NSGlyphGenerator extends NSObject {
        static sharedGlyphGenerator: NSGlyphGenerator;
        generateGlyphsForGlyphStorageDesiredNumberOfCharactersGlyphIndexCharacterIndex(for_: NSGlyphStorage, desiredNumberOfCharacters: number, glyphIndex?: number, characterIndex?: number): void;
    }
    class NSGlyphInfo extends NSObject {
        baseString: string;
        characterCollection: NSCharacterCollection;
        characterIdentifier: number;
        glyphID: number;
        glyphName: string;
    }
    interface NSGlyphStorage {
        attributedString(): NSAttributedString;
        insertGlyphsLengthForStartingGlyphAtIndexCharacterIndex(_: number, length: number, forStartingGlyphAt: number, characterIndex: number): void;
        layoutOptions(): number;
        setIntAttributeValueForGlyphAtIndex(_: number, value: number, forGlyphAt: number): void;
    }
    class NSGradient extends NSObject {
        colorSpace: NSColorSpace;
        numberOfColorStops: number;
        drawFromCenterRadiusToCenterRadiusOptions(fromCenter: CGPoint, radius: number, toCenter: CGPoint, radius2: number, options: NSGradient.DrawingOptions): void;
        drawFromPointToPointOptions(from: CGPoint, to: CGPoint, options: NSGradient.DrawingOptions): void;
        drawInBezierPathAngle(in_: NSBezierPath, angle: number): void;
        drawInBezierPathRelativeCenterPosition(in_: NSBezierPath, relativeCenterPosition: CGPoint): void;
        drawInRectAngle(in_: CGRect, angle: number): void;
        drawInRectRelativeCenterPosition(in_: CGRect, relativeCenterPosition: CGPoint): void;
        getColorLocationAtIndex(_?: NSColor, location?: number, at?: number): void;
        static createWithColors(colors: NSColor[]): NSGradient;
        static createWithColorsAtLocationsColorSpace(colors: NSColor[], atLocations?: number, colorSpace?: NSColorSpace): NSGradient;
        static createWithColorsAndLocations(colorsAndLocations: NSColor): NSGradient;
        static createWithStartingColorEndingColor(startingColor: NSColor, endingColor: NSColor): NSGradient;
        interpolatedColorAtLocation(atLocation: number): NSColor;
    }
    class NSGraphicsContext extends NSObject {
        static currentContextDrawingToScreen(): boolean;
        static restoreGraphicsState(): void;
        static saveGraphicsState(): void;
        CGContext: any;
        CIContext: CIContext;
        attributes: Map<string, any>;
        colorRenderingIntent: NSColorRenderingIntent;
        setColorRenderingIntent(_: NSColorRenderingIntent): any;
        compositingOperation: NSCompositingOperation;
        setCompositingOperation(_: NSCompositingOperation): any;
        isDrawingToScreen: boolean;
        isFlipped: boolean;
        imageInterpolation: NSImageInterpolation;
        setImageInterpolation(_: NSImageInterpolation): any;
        patternPhase: CGPoint;
        setPatternPhase(_: CGPoint): any;
        shouldAntialias: boolean;
        setShouldAntialias(_: boolean): any;
        static currentContext: NSGraphicsContext;
        setCurrentContext(_: NSGraphicsContext): any;
        flushGraphics(): void;
        restoreGraphicsState(): void;
        saveGraphicsState(): void;
    }
    class NSGridCell extends NSObject {
        column: NSGridColumn;
        contentView: NSView;
        setContentView(_: NSView): any;
        customPlacementConstraints: NSLayoutConstraint[];
        setCustomPlacementConstraints(_: NSLayoutConstraint[]): any;
        row: NSGridRow;
        rowAlignment: NSGridRow.Alignment;
        setRowAlignment(_: NSGridRow.Alignment): any;
        xPlacement: NSGridCell.Placement;
        setXPlacement(_: NSGridCell.Placement): any;
        yPlacement: NSGridCell.Placement;
        setYPlacement(_: NSGridCell.Placement): any;
        static emptyContentView: NSView;
    }
    class NSGridColumn extends NSObject {
        gridView: NSGridView;
        isHidden: boolean;
        setHidden(_: boolean): any;
        leadingPadding: number;
        setLeadingPadding(_: number): any;
        numberOfCells: number;
        trailingPadding: number;
        setTrailingPadding(_: number): any;
        width: number;
        setWidth(_: number): any;
        xPlacement: NSGridCell.Placement;
        setXPlacement(_: NSGridCell.Placement): any;
        cellAtIndex(at: number): NSGridCell;
        mergeCellsInRange(in_: NSRange): void;
    }
    class NSGridRow extends NSObject {
        bottomPadding: number;
        setBottomPadding(_: number): any;
        gridView: NSGridView;
        height: number;
        setHeight(_: number): any;
        isHidden: boolean;
        setHidden(_: boolean): any;
        numberOfCells: number;
        rowAlignment: NSGridRow.Alignment;
        setRowAlignment(_: NSGridRow.Alignment): any;
        topPadding: number;
        setTopPadding(_: number): any;
        yPlacement: NSGridCell.Placement;
        setYPlacement(_: NSGridCell.Placement): any;
        cellAtIndex(at: number): NSGridCell;
        mergeCellsInRange(in_: NSRange): void;
    }
    class NSGridView extends NSView {
        columnSpacing: number;
        setColumnSpacing(_: number): any;
        numberOfColumns: number;
        numberOfRows: number;
        rowAlignment: NSGridRow.Alignment;
        setRowAlignment(_: NSGridRow.Alignment): any;
        rowSpacing: number;
        setRowSpacing(_: number): any;
        xPlacement: NSGridCell.Placement;
        setXPlacement(_: NSGridCell.Placement): any;
        yPlacement: NSGridCell.Placement;
        setYPlacement(_: NSGridCell.Placement): any;
        addColumnWithViews(with_: NSView[]): NSGridColumn;
        addRowWithViews(with_: NSView[]): NSGridRow;
        cellAtColumnIndexRowIndex(atColumnIndex: number, rowIndex: number): NSGridCell;
        cellForView(for_: NSView): NSGridCell;
        columnAtIndex(at: number): NSGridColumn;
        indexOfColumn(of: NSGridColumn): number;
        indexOfRow(of: NSGridRow): number;
        insertColumnAtIndexWithViews(at: number, with_: NSView[]): NSGridColumn;
        insertRowAtIndexWithViews(at: number, with_: NSView[]): NSGridRow;
        mergeCellsInHorizontalRangeVerticalRange(inHorizontalRange: NSRange, verticalRange: NSRange): void;
        moveColumnAtIndexToIndex(at: number, to: number): void;
        moveRowAtIndexToIndex(at: number, to: number): void;
        removeColumnAtIndex(at: number): void;
        removeRowAtIndex(at: number): void;
        rowAtIndex(at: number): NSGridRow;
    }
    class NSGroupTouchBarItem extends NSTouchBarItem {
        static alertStyleGroupItemWithIdentifier(alertStyleWithIdentifier: string): NSGroupTouchBarItem;
        static groupItemWithIdentifierItems(identifier: string, items: NSTouchBarItem[]): NSGroupTouchBarItem;
        static groupItemWithIdentifierItemsAllowedCompressionOptions(identifier: string, items: NSTouchBarItem[], allowedCompressionOptions: NSUserInterfaceCompressionOptions): NSGroupTouchBarItem;
        effectiveCompressionOptions: NSUserInterfaceCompressionOptions;
        groupTouchBar: NSTouchBar;
        setGroupTouchBar(_: NSTouchBar): any;
        groupUserInterfaceLayoutDirection: NSUserInterfaceLayoutDirection;
        setGroupUserInterfaceLayoutDirection(_: NSUserInterfaceLayoutDirection): any;
        preferredItemWidth: number;
        setPreferredItemWidth(_: number): any;
        prefersEqualWidths: boolean;
        setPrefersEqualWidths(_: boolean): any;
        prioritizedCompressionOptions: NSUserInterfaceCompressionOptions[];
        setPrioritizedCompressionOptions(_: NSUserInterfaceCompressionOptions[]): any;
    }
    class NSHapticFeedbackManager extends NSObject {
        static defaultPerformer: NSHapticFeedbackPerformer;
    }
    interface NSHapticFeedbackPerformer extends NSObject {
        performFeedbackPatternPerformanceTime(_: NSHapticFeedbackManager.FeedbackPattern, performanceTime: NSHapticFeedbackManager.PerformanceTime): void;
    }
    class NSHelpManager extends NSObject {
        static isContextHelpModeActive: boolean;
        setContextHelpModeActive(_: boolean): any;
        static sharedHelpManager: NSHelpManager;
        contextHelpForObject(for_: any): NSAttributedString;
        findStringInBook(_: string, inBook?: string): void;
        openHelpAnchorInBook(_: string, inBook?: string): void;
        registerBooksInBundle(in_: Bundle): boolean;
        removeContextHelpForObject(for_: any): void;
        setContextHelpForObject(_: NSAttributedString, for_: any): void;
        showContextHelpForObjectLocationHint(for_: any, locationHint: CGPoint): boolean;
    }
    interface NSIgnoreMisspelledWords {
        ignoreSpelling(_?: any): void;
    }
    class NSImage extends NSObject {
        static canInitWithPasteboard(with_: NSPasteboard): boolean;
        TIFFRepresentation: NSData;
        accessibilityDescription: string;
        setAccessibilityDescription(_: string): any;
        alignmentRect: CGRect;
        setAlignmentRect(_: CGRect): any;
        backgroundColor: NSColor;
        setBackgroundColor(_: NSColor): any;
        cacheMode: NSImage.CacheMode;
        setCacheMode(_: NSImage.CacheMode): any;
        capInsets: NSEdgeInsets;
        setCapInsets(_: NSEdgeInsets): any;
        delegate: NSImageDelegate;
        setDelegate(_: NSImageDelegate): any;
        matchesOnMultipleResolution: boolean;
        setMatchesOnMultipleResolution(_: boolean): any;
        matchesOnlyOnBestFittingAxis: boolean;
        setMatchesOnlyOnBestFittingAxis(_: boolean): any;
        prefersColorMatch: boolean;
        setPrefersColorMatch(_: boolean): any;
        representations: NSImageRep[];
        resizingMode: NSImage.ResizingMode;
        setResizingMode(_: NSImage.ResizingMode): any;
        size: CGSize;
        setSize(_: CGSize): any;
        isTemplate: boolean;
        setTemplate(_: boolean): any;
        usesEPSOnResolutionMismatch: boolean;
        setUsesEPSOnResolutionMismatch(_: boolean): any;
        isValid: boolean;
        static imageTypes: string[];
        static imageUnfilteredTypes: string[];
        CGImageForProposedRectContextHints(forProposedRect?: NSRect, context?: NSGraphicsContext, hints?: Map<string, any>): any;
        TIFFRepresentationUsingCompressionFactor(using: NSBitmapImageRep.TIFFCompression, factor: number): NSData;
        addRepresentation(_: NSImageRep): void;
        addRepresentations(_: NSImageRep[]): void;
        bestRepresentationForRectContextHints(for_: CGRect, context?: NSGraphicsContext, hints?: Map<string, any>): NSImageRep;
        cancelIncrementalLoad(): void;
        drawAtPointFromRectOperationFraction(at: CGPoint, from: CGRect, operation: NSCompositingOperation, fraction: number): void;
        drawInRect(in_: CGRect): void;
        drawInRectFromRectOperationFraction(in_: CGRect, from: CGRect, operation: NSCompositingOperation, fraction: number): void;
        drawInRectFromRectOperationFractionRespectFlippedHints(in_: CGRect, from: CGRect, operation: NSCompositingOperation, fraction: number, respectFlipped: boolean, hints?: Map<string, any>): void;
        drawRepresentationInRect(_: NSImageRep, in_: CGRect): boolean;
        hitTestRectWithImageDestinationRectContextHintsFlipped(_: CGRect, withDestinationRect: CGRect, context?: NSGraphicsContext, hints?: Map<string, any>, flipped?: boolean): boolean;
        static createWithByReferencingFile(byReferencingFile: string): NSImage;
        static createWithByReferencingURL(byReferencingURL: NSURL): NSImage;
        static createWithCGImageSize(CGImage: any, size: CGSize): NSImage;
        static createWithContentsOfFile(contentsOfFile: string): NSImage;
        static createWithContentsOfURL(contentsOfURL: NSURL): NSImage;
        static createWithData(data: NSData): NSImage;
        static createWithDataIgnoringOrientation(dataIgnoringOrientation: NSData): NSImage;
        static createWithIconRef(iconRef: any): NSImage;
        static createWithPasteboard(pasteboard: NSPasteboard): NSImage;
        static createWithSize(size: CGSize): NSImage;
        layerContentsForContentsScale(forContentsScale: number): any;
        lockFocus(): void;
        lockFocusFlipped(_: boolean): void;
        name(): string;
        recache(): void;
        recommendedLayerContentsScale(_: number): number;
        removeRepresentation(_: NSImageRep): void;
        setName(_?: string): boolean;
        unlockFocus(): void;
    }
    class NSImageCell extends NSCell {
        imageAlignment: NSImageAlignment;
        setImageAlignment(_: NSImageAlignment): any;
        imageFrameStyle: NSImageView.FrameStyle;
        setImageFrameStyle(_: NSImageView.FrameStyle): any;
        imageScaling: NSImageScaling;
        setImageScaling(_: NSImageScaling): any;
    }
    interface NSImageDelegate extends NSObject {
        imageDidLoadRepresentationWithStatus?(_: NSImage, didLoadRepresentation: NSImageRep, with_: NSImage.LoadStatus): void;
        imageDidLoadPartOfRepresentationWithValidRows?(_: NSImage, didLoadPartOfRepresentation: NSImageRep, withValidRows: number): void;
        imageDidLoadRepresentationHeader?(_: NSImage, didLoadRepresentationHeader: NSImageRep): void;
        imageWillLoadRepresentation?(_: NSImage, willLoadRepresentation: NSImageRep): void;
        imageDidNotDrawInRect?(_: NSImage, in_: CGRect): NSImage;
    }
    class NSImageRep extends NSObject {
        static canInitWithData(with_: NSData): boolean;
        static canInitWithPasteboard(with_: NSPasteboard): boolean;
        static imageRepClassForData(for_: NSData): typeof NSObject;
        static imageRepClassForType(forType: string): typeof NSObject;
        static imageRepsWithContentsOfFile(withContentsOfFile: string): NSImageRep[];
        static imageRepsWithContentsOfURL(withContentsOf: NSURL): NSImageRep[];
        static imageRepsWithPasteboard(with_: NSPasteboard): NSImageRep[];
        static registerImageRepClass(_: typeof NSObject): void;
        static unregisterImageRepClass(_: typeof NSObject): void;
        hasAlpha: boolean;
        setAlpha(_: boolean): any;
        bitsPerSample: number;
        setBitsPerSample(_: number): any;
        colorSpaceName: string;
        setColorSpaceName(_: string): any;
        layoutDirection: NSImage.LayoutDirection;
        setLayoutDirection(_: NSImage.LayoutDirection): any;
        isOpaque: boolean;
        setOpaque(_: boolean): any;
        pixelsHigh: number;
        setPixelsHigh(_: number): any;
        pixelsWide: number;
        setPixelsWide(_: number): any;
        size: CGSize;
        setSize(_: CGSize): any;
        static imageTypes: string[];
        static imageUnfilteredTypes: string[];
        static registeredImageRepClasses: typeof NSObject[];
        CGImageForProposedRectContextHints(forProposedRect?: NSRect, context?: NSGraphicsContext, hints?: Map<string, any>): any;
        draw(): boolean;
        drawAtPoint(at: CGPoint): boolean;
        drawInRect(in_: CGRect): boolean;
        drawInRectFromRectOperationFractionRespectFlippedHints(in_: CGRect, from: CGRect, operation: NSCompositingOperation, fraction: number, respectFlipped: boolean, hints?: Map<string, any>): boolean;
    }
    class NSImageView extends NSControl {
        allowsCutCopyPaste: boolean;
        setAllowsCutCopyPaste(_: boolean): any;
        animates: boolean;
        setAnimates(_: boolean): any;
        contentTintColor: NSColor;
        setContentTintColor(_: NSColor): any;
        isEditable: boolean;
        setEditable(_: boolean): any;
        image: NSImage;
        setImage(_: NSImage): any;
        imageAlignment: NSImageAlignment;
        setImageAlignment(_: NSImageAlignment): any;
        imageFrameStyle: NSImageView.FrameStyle;
        setImageFrameStyle(_: NSImageView.FrameStyle): any;
        imageScaling: NSImageScaling;
        setImageScaling(_: NSImageScaling): any;
    }
    interface NSInputServerMouseTracker {
    }
    interface NSInputServiceProvider {
    }
    class NSLayoutAnchor<AnchorType> extends NSObject {
        constraintsAffectingLayout: NSLayoutConstraint[];
        hasAmbiguousLayout: boolean;
        item: any;
        name: string;
        constraintWithEqualTo(equalTo: NSLayoutAnchor<AnchorType>): NSLayoutConstraint;
        constraintWithEqualToConstant(equalTo: NSLayoutAnchor<AnchorType>, constant: number): NSLayoutConstraint;
        constraintWithGreaterThanOrEqualTo(greaterThanOrEqualTo: NSLayoutAnchor<AnchorType>): NSLayoutConstraint;
        constraintWithGreaterThanOrEqualToConstant(greaterThanOrEqualTo: NSLayoutAnchor<AnchorType>, constant: number): NSLayoutConstraint;
        constraintWithLessThanOrEqualTo(lessThanOrEqualTo: NSLayoutAnchor<AnchorType>): NSLayoutConstraint;
        constraintWithLessThanOrEqualToConstant(lessThanOrEqualTo: NSLayoutAnchor<AnchorType>, constant: number): NSLayoutConstraint;
    }
    class NSLayoutConstraint extends NSObject {
        static activateConstraints(_: NSLayoutConstraint[]): void;
        static constraintsWithVisualFormatOptionsMetricsViews(withVisualFormat: string, options: NSLayoutConstraint.FormatOptions, metrics?: Map<string, any>, views?: Map<string, any>): NSLayoutConstraint[];
        static deactivateConstraints(_: NSLayoutConstraint[]): void;
        isActive: boolean;
        setActive(_: boolean): any;
        constant: number;
        setConstant(_: number): any;
        firstAnchor: NSLayoutAnchor<any>;
        firstAttribute: NSLayoutConstraint.Attribute;
        firstItem: any;
        identifier: string;
        setIdentifier(_: string): any;
        multiplier: number;
        priority: number;
        setPriority(_: number): any;
        relation: NSLayoutConstraint.Relation;
        secondAnchor: NSLayoutAnchor<any>;
        secondAttribute: NSLayoutConstraint.Attribute;
        secondItem: any;
        shouldBeArchived: boolean;
        setShouldBeArchived(_: boolean): any;
    }
    class NSLayoutDimension extends NSLayoutAnchor<NSLayoutDimension> {
        constraintEqualToAnchorMultiplier(equalTo: NSLayoutDimension, multiplier: number): NSLayoutConstraint;
        constraintEqualToAnchorMultiplierConstant(equalTo: NSLayoutDimension, multiplier: number, constant: number): NSLayoutConstraint;
        constraintEqualToConstant(equalToConstant: number): NSLayoutConstraint;
        constraintGreaterThanOrEqualToAnchorMultiplier(greaterThanOrEqualTo: NSLayoutDimension, multiplier: number): NSLayoutConstraint;
        constraintGreaterThanOrEqualToAnchorMultiplierConstant(greaterThanOrEqualTo: NSLayoutDimension, multiplier: number, constant: number): NSLayoutConstraint;
        constraintGreaterThanOrEqualToConstant(greaterThanOrEqualToConstant: number): NSLayoutConstraint;
        constraintLessThanOrEqualToAnchorMultiplier(lessThanOrEqualTo: NSLayoutDimension, multiplier: number): NSLayoutConstraint;
        constraintLessThanOrEqualToAnchorMultiplierConstant(lessThanOrEqualTo: NSLayoutDimension, multiplier: number, constant: number): NSLayoutConstraint;
        constraintLessThanOrEqualToConstant(lessThanOrEqualToConstant: number): NSLayoutConstraint;
    }
    class NSLayoutGuide extends NSObject {
        bottomAnchor: NSLayoutYAxisAnchor;
        centerXAnchor: NSLayoutXAxisAnchor;
        centerYAnchor: NSLayoutYAxisAnchor;
        frame: CGRect;
        hasAmbiguousLayout: boolean;
        heightAnchor: NSLayoutDimension;
        leadingAnchor: NSLayoutXAxisAnchor;
        leftAnchor: NSLayoutXAxisAnchor;
        owningView: NSView;
        setOwningView(_: NSView): any;
        rightAnchor: NSLayoutXAxisAnchor;
        topAnchor: NSLayoutYAxisAnchor;
        trailingAnchor: NSLayoutXAxisAnchor;
        widthAnchor: NSLayoutDimension;
        constraintsAffectingLayoutForOrientation(for_: NSLayoutConstraint.Orientation): NSLayoutConstraint[];
    }
    class NSLayoutManager extends NSObject {
        allowsNonContiguousLayout: boolean;
        setAllowsNonContiguousLayout(_: boolean): any;
        backgroundLayoutEnabled: boolean;
        setBackgroundLayoutEnabled(_: boolean): any;
        defaultAttachmentScaling: NSImageScaling;
        setDefaultAttachmentScaling(_: NSImageScaling): any;
        delegate: NSLayoutManagerDelegate;
        setDelegate(_: NSLayoutManagerDelegate): any;
        extraLineFragmentRect: CGRect;
        extraLineFragmentTextContainer: NSTextContainer;
        extraLineFragmentUsedRect: CGRect;
        firstTextView: NSTextView;
        glyphGenerator: NSGlyphGenerator;
        setGlyphGenerator(_: NSGlyphGenerator): any;
        hasNonContiguousLayout: boolean;
        limitsLayoutForSuspiciousContents: boolean;
        setLimitsLayoutForSuspiciousContents(_: boolean): any;
        numberOfGlyphs: number;
        showsControlCharacters: boolean;
        setShowsControlCharacters(_: boolean): any;
        showsInvisibleCharacters: boolean;
        setShowsInvisibleCharacters(_: boolean): any;
        textContainers: NSTextContainer[];
        textStorage: NSTextStorage;
        setTextStorage(_: NSTextStorage): any;
        textViewForBeginningOfSelection: NSTextView;
        typesetter: NSTypesetter;
        setTypesetter(_: NSTypesetter): any;
        typesetterBehavior: NSLayoutManager.TypesetterBehavior;
        setTypesetterBehavior(_: NSLayoutManager.TypesetterBehavior): any;
        usesDefaultHyphenation: boolean;
        setUsesDefaultHyphenation(_: boolean): any;
        usesFontLeading: boolean;
        setUsesFontLeading(_: boolean): any;
        CGGlyphAtIndex(at: number): number;
        CGGlyphAtIndexIsValidIndex(at: number, isValidIndex?: boolean): number;
        addTemporaryAttributeValueForCharacterRange(_: string, value: any, forCharacterRange: NSRange): void;
        addTemporaryAttributesForCharacterRange(_: Map<string, any>, forCharacterRange: NSRange): void;
        addTextContainer(_: NSTextContainer): void;
        attachmentSizeForGlyphAtIndex(forGlyphAt: number): CGSize;
        boundingRectForGlyphRangeInTextContainer(forGlyphRange: NSRange, in_: NSTextContainer): CGRect;
        boundsRectForTextBlockAtIndexEffectiveRange(for_: NSTextBlock, at: number, effectiveRange?: NSRange): CGRect;
        boundsRectForTextBlockGlyphRange(for_: NSTextBlock, glyphRange: NSRange): CGRect;
        characterIndexForGlyphAtIndex(at: number): number;
        characterIndexForPointInTextContainerFractionOfDistanceBetweenInsertionPoints(for_: CGPoint, in_: NSTextContainer, fractionOfDistanceBetweenInsertionPoints?: number): number;
        characterRangeForGlyphRangeActualGlyphRange(forGlyphRange: NSRange, actualGlyphRange?: NSRange): NSRange;
        defaultBaselineOffsetForFont(for_: NSFont): number;
        defaultLineHeightForFont(for_: NSFont): number;
        drawBackgroundForGlyphRangeAtPoint(forGlyphRange: NSRange, at: CGPoint): void;
        drawGlyphsForGlyphRangeAtPoint(forGlyphRange: NSRange, at: CGPoint): void;
        drawStrikethroughForGlyphRangeStrikethroughTypeBaselineOffsetLineFragmentRectLineFragmentGlyphRangeContainerOrigin(forGlyphRange: NSRange, strikethroughType: NSUnderlineStyle, baselineOffset: number, lineFragmentRect: CGRect, lineFragmentGlyphRange: NSRange, containerOrigin: CGPoint): void;
        drawUnderlineForGlyphRangeUnderlineTypeBaselineOffsetLineFragmentRectLineFragmentGlyphRangeContainerOrigin(forGlyphRange: NSRange, underlineType: NSUnderlineStyle, baselineOffset: number, lineFragmentRect: CGRect, lineFragmentGlyphRange: NSRange, containerOrigin: CGPoint): void;
        drawsOutsideLineFragmentForGlyphAtIndex(forGlyphAt: number): boolean;
        ensureGlyphsForCharacterRange(forCharacterRange: NSRange): void;
        ensureGlyphsForGlyphRange(forGlyphRange: NSRange): void;
        ensureLayoutForBoundingRectInTextContainer(forBoundingRect: CGRect, in_: NSTextContainer): void;
        ensureLayoutForCharacterRange(forCharacterRange: NSRange): void;
        ensureLayoutForGlyphRange(forGlyphRange: NSRange): void;
        ensureLayoutForTextContainer(for_: NSTextContainer): void;
        enumerateEnclosingRectsWithForGlyphRangeWithinSelectedGlyphRangeInUsing(forGlyphRange: NSRange, withinSelectedGlyphRange: NSRange, in_: NSTextContainer, using: (p1: CGRect, p2: boolean) => void): void;
        enumerateLineFragmentsWithForGlyphRangeUsing(forGlyphRange: NSRange, using: (p1: CGRect, p2: CGRect, p3: NSTextContainer, p4: NSRange, p5: boolean) => void): void;
        fillBackgroundRectArrayCountForCharacterRangeColor(_: NSRect, count: number, forCharacterRange: NSRange, color: NSColor): void;
        firstUnlaidCharacterIndex(): number;
        firstUnlaidGlyphIndex(): number;
        fractionOfDistanceThroughGlyphForPointInTextContainer(for_: CGPoint, in_: NSTextContainer): number;
        getFirstUnlaidCharacterIndexGlyphIndex(_?: number, glyphIndex?: number): void;
        getGlyphsInRangeGlyphsPropertiesCharacterIndexesBidiLevels(in_: NSRange, glyphs?: number, properties?: NSLayoutManager.GlyphProperty, characterIndexes?: number, bidiLevels?: string): number;
        getLineFragmentInsertionPointsForCharacterAtIndexAlternatePositionsInDisplayOrderPositionsCharacterIndexes(forCharacterAt: number, alternatePositions: boolean, inDisplayOrder: boolean, positions?: number, characterIndexes?: number): number;
        glyphAtIndex(at: number): number;
        glyphAtIndexIsValidIndex(at: number, isValidIndex?: boolean): number;
        glyphIndexForCharacterAtIndex(at: number): number;
        glyphIndexForPointInTextContainer(for_: CGPoint, in_: NSTextContainer): number;
        glyphIndexForPointInTextContainerFractionOfDistanceThroughGlyph(for_: CGPoint, in_: NSTextContainer, fractionOfDistanceThroughGlyph?: number): number;
        glyphRangeForBoundingRectInTextContainer(forBoundingRect: CGRect, in_: NSTextContainer): NSRange;
        glyphRangeForBoundingRectWithoutAdditionalLayoutInTextContainer(forBoundingRectWithoutAdditionalLayout: CGRect, in_: NSTextContainer): NSRange;
        glyphRangeForCharacterRangeActualCharacterRange(forCharacterRange: NSRange, actualCharacterRange?: NSRange): NSRange;
        glyphRangeForTextContainer(for_: NSTextContainer): NSRange;
        insertTextContainerAtIndex(_: NSTextContainer, at: number): void;
        invalidateDisplayForCharacterRange(forCharacterRange: NSRange): void;
        invalidateDisplayForGlyphRange(forGlyphRange: NSRange): void;
        invalidateGlyphsForCharacterRangeChangeInLengthActualCharacterRange(forCharacterRange: NSRange, changeInLength: number, actualCharacterRange?: NSRange): void;
        invalidateLayoutForCharacterRangeActualCharacterRange(forCharacterRange: NSRange, actualCharacterRange?: NSRange): void;
        isValidGlyphIndex(_: number): boolean;
        layoutManagerOwnsFirstResponderInWindow(in_: NSWindow): boolean;
        layoutRectForTextBlockAtIndexEffectiveRange(for_: NSTextBlock, at: number, effectiveRange?: NSRange): CGRect;
        layoutRectForTextBlockGlyphRange(for_: NSTextBlock, glyphRange: NSRange): CGRect;
        lineFragmentRectForGlyphAtIndexEffectiveRange(forGlyphAt: number, effectiveRange?: NSRange): CGRect;
        lineFragmentRectForGlyphAtIndexEffectiveRangeWithoutAdditionalLayout(forGlyphAt: number, effectiveRange?: NSRange, withoutAdditionalLayout?: boolean): CGRect;
        lineFragmentUsedRectForGlyphAtIndexEffectiveRange(forGlyphAt: number, effectiveRange?: NSRange): CGRect;
        lineFragmentUsedRectForGlyphAtIndexEffectiveRangeWithoutAdditionalLayout(forGlyphAt: number, effectiveRange?: NSRange, withoutAdditionalLayout?: boolean): CGRect;
        locationForGlyphAtIndex(forGlyphAt: number): CGPoint;
        notShownAttributeForGlyphAtIndex(forGlyphAt: number): boolean;
        processEditingForTextStorageEditedRangeChangeInLengthInvalidatedRange(for_: NSTextStorage, edited: NSTextStorageEditActions, range: NSRange, changeInLength: number, invalidatedRange: NSRange): void;
        propertyForGlyphAtIndex(at: number): NSLayoutManager.GlyphProperty;
        rangeOfNominallySpacedGlyphsContainingIndex(ofNominallySpacedGlyphsContaining: number): NSRange;
        rectArrayForCharacterRangeWithinSelectedCharacterRangeInTextContainerRectCount(forCharacterRange: NSRange, withinSelectedCharacterRange: NSRange, in_: NSTextContainer, rectCount: number): NSRect;
        rectArrayForGlyphRangeWithinSelectedGlyphRangeInTextContainerRectCount(forGlyphRange: NSRange, withinSelectedGlyphRange: NSRange, in_: NSTextContainer, rectCount: number): NSRect;
        removeTemporaryAttributeForCharacterRange(_: string, forCharacterRange: NSRange): void;
        removeTextContainerAtIndex(at: number): void;
        replaceTextStorage(_: NSTextStorage): void;
        rulerAccessoryViewForTextViewParagraphStyleRulerEnabled(for_: NSTextView, paragraphStyle: NSParagraphStyle, ruler: NSRulerView, enabled: boolean): NSView;
        rulerMarkersForTextViewParagraphStyleRuler(for_: NSTextView, paragraphStyle: NSParagraphStyle, ruler: NSRulerView): NSRulerMarker[];
        setAttachmentSizeForGlyphRange(_: CGSize, forGlyphRange: NSRange): void;
        setBoundsRectForTextBlockGlyphRange(_: CGRect, for_: NSTextBlock, glyphRange: NSRange): void;
        setDrawsOutsideLineFragmentForGlyphAtIndex(_: boolean, forGlyphAt: number): void;
        setExtraLineFragmentRectUsedRectTextContainer(_: CGRect, usedRect: CGRect, textContainer: NSTextContainer): void;
        setGlyphsPropertiesCharacterIndexesFontForGlyphRange(_: number, properties: NSLayoutManager.GlyphProperty, characterIndexes: number, font: NSFont, forGlyphRange: NSRange): void;
        setLayoutRectForTextBlockGlyphRange(_: CGRect, for_: NSTextBlock, glyphRange: NSRange): void;
        setLineFragmentRectForGlyphRangeUsedRect(_: CGRect, forGlyphRange: NSRange, usedRect: CGRect): void;
        setLocationForStartOfGlyphRange(_: CGPoint, forStartOfGlyphRange: NSRange): void;
        setNotShownAttributeForGlyphAtIndex(_: boolean, forGlyphAt: number): void;
        setTemporaryAttributesForCharacterRange(_: Map<string, any>, forCharacterRange: NSRange): void;
        setTextContainerForGlyphRange(_: NSTextContainer, forGlyphRange: NSRange): void;
        showAttachmentCellInRectCharacterIndex(_: NSCell, in_: CGRect, characterIndex: number): void;
        showCGGlyphsPositionsCountFontTextMatrixAttributesInContext(_: number, positions: NSPoint, count: number, font: NSFont, textMatrix: CGAffineTransform, attributes: Map<string, any>, in_: any): void;
        strikethroughGlyphRangeStrikethroughTypeLineFragmentRectLineFragmentGlyphRangeContainerOrigin(_: NSRange, strikethroughType: NSUnderlineStyle, lineFragmentRect: CGRect, lineFragmentGlyphRange: NSRange, containerOrigin: CGPoint): void;
        temporaryAttributeAtCharacterIndexEffectiveRange(_: string, atCharacterIndex: number, effectiveRange?: NSRange): any;
        temporaryAttributeAtCharacterIndexLongestEffectiveRangeInRange(_: string, atCharacterIndex: number, longestEffectiveRange?: NSRange, in_?: NSRange): any;
        temporaryAttributesAtCharacterIndexEffectiveRange(atCharacterIndex: number, effectiveRange?: NSRange): Map<string, any>;
        temporaryAttributesAtCharacterIndexLongestEffectiveRangeInRange(atCharacterIndex: number, longestEffectiveRange?: NSRange, in_?: NSRange): Map<string, any>;
        textContainerChangedGeometry(_: NSTextContainer): void;
        textContainerChangedTextView(_: NSTextContainer): void;
        textContainerForGlyphAtIndexEffectiveRange(forGlyphAt: number, effectiveRange?: NSRange): NSTextContainer;
        textContainerForGlyphAtIndexEffectiveRangeWithoutAdditionalLayout(forGlyphAt: number, effectiveRange?: NSRange, withoutAdditionalLayout?: boolean): NSTextContainer;
        truncatedGlyphRangeInLineFragmentForGlyphAtIndex(inLineFragmentForGlyphAt: number): NSRange;
        underlineGlyphRangeUnderlineTypeLineFragmentRectLineFragmentGlyphRangeContainerOrigin(_: NSRange, underlineType: NSUnderlineStyle, lineFragmentRect: CGRect, lineFragmentGlyphRange: NSRange, containerOrigin: CGPoint): void;
        usedRectForTextContainer(for_: NSTextContainer): CGRect;
    }
    interface NSLayoutManagerDelegate extends NSObject {
        layoutManagerLineSpacingAfterGlyphAtIndexWithProposedLineFragmentRect?(_: NSLayoutManager, lineSpacingAfterGlyphAt: number, withProposedLineFragmentRect: CGRect): number;
        layoutManagerParagraphSpacingBeforeGlyphAtIndexWithProposedLineFragmentRect?(_: NSLayoutManager, paragraphSpacingBeforeGlyphAt: number, withProposedLineFragmentRect: CGRect): number;
        layoutManagerParagraphSpacingAfterGlyphAtIndexWithProposedLineFragmentRect?(_: NSLayoutManager, paragraphSpacingAfterGlyphAt: number, withProposedLineFragmentRect: CGRect): number;
        layoutManagerShouldUseActionForControlCharacterAtIndex?(_: NSLayoutManager, shouldUse: NSLayoutManager.ControlCharacterAction, forControlCharacterAt: number): NSLayoutManager.ControlCharacterAction;
        layoutManagerShouldBreakLineByWordBeforeCharacterAtIndex?(_: NSLayoutManager, shouldBreakLineByWordBeforeCharacterAt: number): boolean;
        layoutManagerShouldBreakLineByHyphenatingBeforeCharacterAtIndex?(_: NSLayoutManager, shouldBreakLineByHyphenatingBeforeCharacterAt: number): boolean;
        layoutManagerBoundingBoxForControlGlyphAtIndexForTextContainerProposedLineFragmentGlyphPositionCharacterIndex?(_: NSLayoutManager, boundingBoxForControlGlyphAt: number, for_: NSTextContainer, proposedLineFragment: CGRect, glyphPosition: CGPoint, characterIndex: number): CGRect;
        layoutManagerShouldSetLineFragmentRectLineFragmentUsedRectBaselineOffsetInTextContainerForGlyphRange?(_: NSLayoutManager, shouldSetLineFragmentRect: NSRect, lineFragmentUsedRect: NSRect, baselineOffset: number, in_: NSTextContainer, forGlyphRange: NSRange): boolean;
        layoutManagerDidCompleteLayoutForTextContainerAtEnd?(_: NSLayoutManager, didCompleteLayoutFor?: NSTextContainer, atEnd?: boolean): void;
        layoutManagerTextContainerDidChangeGeometryFromSize?(_: NSLayoutManager, textContainer: NSTextContainer, didChangeGeometryFrom: CGSize): void;
        layoutManagerShouldGenerateGlyphsPropertiesCharacterIndexesFontForGlyphRange?(_: NSLayoutManager, shouldGenerateGlyphs: number, properties: NSLayoutManager.GlyphProperty, characterIndexes: number, font: NSFont, forGlyphRange: NSRange): number;
        layoutManagerShouldUseTemporaryAttributesForDrawingToScreenAtCharacterIndexEffectiveRange?(_: NSLayoutManager, shouldUseTemporaryAttributes: Map<string, any>, forDrawingToScreen: boolean, atCharacterIndex: number, effectiveRange?: NSRange): Map<string, any>;
        layoutManagerDidInvalidateLayout?(_: NSLayoutManager): void;
    }
    class NSLayoutXAxisAnchor extends NSLayoutAnchor<NSLayoutXAxisAnchor> {
        anchorWithOffsetToAnchor(to: NSLayoutXAxisAnchor): NSLayoutDimension;
    }
    class NSLayoutYAxisAnchor extends NSLayoutAnchor<NSLayoutYAxisAnchor> {
        anchorWithOffsetToAnchor(to: NSLayoutYAxisAnchor): NSLayoutDimension;
    }
    class NSLevelIndicator extends NSControl {
        criticalFillColor: NSColor;
        setCriticalFillColor(_: NSColor): any;
        criticalValue: number;
        setCriticalValue(_: number): any;
        drawsTieredCapacityLevels: boolean;
        setDrawsTieredCapacityLevels(_: boolean): any;
        isEditable: boolean;
        setEditable(_: boolean): any;
        fillColor: NSColor;
        setFillColor(_: NSColor): any;
        levelIndicatorStyle: NSLevelIndicator.Style;
        setLevelIndicatorStyle(_: NSLevelIndicator.Style): any;
        maxValue: number;
        setMaxValue(_: number): any;
        minValue: number;
        setMinValue(_: number): any;
        numberOfMajorTickMarks: number;
        setNumberOfMajorTickMarks(_: number): any;
        numberOfTickMarks: number;
        setNumberOfTickMarks(_: number): any;
        placeholderVisibility: NSLevelIndicator.PlaceholderVisibility;
        setPlaceholderVisibility(_: NSLevelIndicator.PlaceholderVisibility): any;
        ratingImage: NSImage;
        setRatingImage(_: NSImage): any;
        ratingPlaceholderImage: NSImage;
        setRatingPlaceholderImage(_: NSImage): any;
        tickMarkPosition: NSSlider.TickMarkPosition;
        setTickMarkPosition(_: NSSlider.TickMarkPosition): any;
        warningFillColor: NSColor;
        setWarningFillColor(_: NSColor): any;
        warningValue: number;
        setWarningValue(_: number): any;
        rectOfTickMarkAtIndex(at: number): CGRect;
        tickMarkValueAtIndex(at: number): number;
    }
    class NSLevelIndicatorCell extends NSActionCell {
        criticalValue: number;
        setCriticalValue(_: number): any;
        levelIndicatorStyle: NSLevelIndicator.Style;
        setLevelIndicatorStyle(_: NSLevelIndicator.Style): any;
        maxValue: number;
        setMaxValue(_: number): any;
        minValue: number;
        setMinValue(_: number): any;
        numberOfMajorTickMarks: number;
        setNumberOfMajorTickMarks(_: number): any;
        numberOfTickMarks: number;
        setNumberOfTickMarks(_: number): any;
        tickMarkPosition: NSSlider.TickMarkPosition;
        setTickMarkPosition(_: NSSlider.TickMarkPosition): any;
        warningValue: number;
        setWarningValue(_: number): any;
        static createWithLevelIndicatorStyle(levelIndicatorStyle: NSLevelIndicator.Style): NSLevelIndicatorCell;
        rectOfTickMarkAtIndex(at: number): CGRect;
        tickMarkValueAtIndex(at: number): number;
    }
    class NSMagnificationGestureRecognizer extends NSGestureRecognizer {
        magnification: number;
        setMagnification(_: number): any;
    }
    class NSMatrix extends NSControl {
        allowsEmptySelection: boolean;
        setAllowsEmptySelection(_: boolean): any;
        autorecalculatesCellSize: boolean;
        setAutorecalculatesCellSize(_: boolean): any;
        isAutoscroll: boolean;
        setAutoscroll(_: boolean): any;
        autosizesCells: boolean;
        setAutosizesCells(_: boolean): any;
        backgroundColor: NSColor;
        setBackgroundColor(_: NSColor): any;
        cellBackgroundColor: NSColor;
        setCellBackgroundColor(_: NSColor): any;
        cellClass: typeof NSObject;
        setCellClass(_: typeof NSObject): any;
        cellSize: CGSize;
        setCellSize(_: CGSize): any;
        cells: NSCell[];
        delegate: NSMatrixDelegate;
        setDelegate(_: NSMatrixDelegate): any;
        doubleAction: string;
        setDoubleAction(_: string): any;
        drawsBackground: boolean;
        setDrawsBackground(_: boolean): any;
        drawsCellBackground: boolean;
        setDrawsCellBackground(_: boolean): any;
        intercellSpacing: CGSize;
        setIntercellSpacing(_: CGSize): any;
        keyCell: NSCell;
        setKeyCell(_: NSCell): any;
        mode: NSMatrix.Mode;
        setMode(_: NSMatrix.Mode): any;
        mouseDownFlags: number;
        numberOfColumns: number;
        numberOfRows: number;
        prototype: NSCell;
        setPrototype(_: NSCell): any;
        selectedCells: NSCell[];
        selectedColumn: number;
        selectedRow: number;
        isSelectionByRect: boolean;
        setSelectionByRect(_: boolean): any;
        tabKeyTraversesCells: boolean;
        setTabKeyTraversesCells(_: boolean): any;
        addColumn(): void;
        addColumnWithCells(with_: NSCell[]): void;
        addRow(): void;
        addRowWithCells(with_: NSCell[]): void;
        cellAtRowColumn(atRow: number, column: number): NSCell;
        cellFrameAtRowColumn(atRow: number, column: number): CGRect;
        cellWithTag(withTag: number): NSCell;
        deselectAllCells(): void;
        deselectSelectedCell(): void;
        drawCellAtRowColumn(atRow: number, column: number): void;
        getNumberOfRowsColumns(_?: number, columns?: number): void;
        getRowColumnForPoint(_: number, column: number, for_: CGPoint): boolean;
        getRowColumnOfCell(_: number, column: number, of: NSCell): boolean;
        highlightCellAtRowColumn(_: boolean, atRow: number, column: number): void;
        static createWithFrameModeCellClassNumberOfRowsNumberOfColumns(frame: CGRect, mode: NSMatrix.Mode, cellClass?: typeof NSObject, numberOfRows?: number, numberOfColumns?: number): NSMatrix;
        static createWithFrameModePrototypeNumberOfRowsNumberOfColumns(frame: CGRect, mode: NSMatrix.Mode, prototype: NSCell, numberOfRows: number, numberOfColumns: number): NSMatrix;
        insertColumn(_: number): void;
        insertColumnWithCells(_: number, with_?: NSCell[]): void;
        insertRow(_: number): void;
        insertRowWithCells(_: number, with_?: NSCell[]): void;
        makeCellAtRowColumn(atRow: number, column: number): NSCell;
        putCellAtRowColumn(_: NSCell, atRow: number, column: number): void;
        removeColumn(_: number): void;
        removeRow(_: number): void;
        renewRowsColumns(_: number, columns: number): void;
        scrollCellToVisibleAtRowColumn(atRow: number, column: number): void;
        selectCellAtRowColumn(atRow: number, column: number): void;
        selectCellWithTag(withTag: number): boolean;
        selectText(_?: any): void;
        selectTextAtRowColumn(atRow: number, column: number): NSCell;
        sendAction(): boolean;
        sendActionToForAllCells(_: string, to: any, forAllCells: boolean): void;
        sendDoubleAction(): void;
        setScrollable(_: boolean): void;
        setSelectionFromToAnchorHighlight(_: number, to: number, anchor: number, highlight: boolean): void;
        setStateAtRowColumn(_: number, atRow: number, column: number): void;
        setToolTipForCell(_?: string, for_?: NSCell): void;
        setValidateSize(_: boolean): void;
        sizeToCells(): void;
        sortWithUsingContext(using?: (p1: any, p2: any, p3: any) => number, context?: any): void;
        sortUsingSelector(using: string): void;
        textDidBeginEditing(_: NSNotification): void;
        textDidChange(_: NSNotification): void;
        textDidEndEditing(_: NSNotification): void;
        textShouldBeginEditing(_: NSText): boolean;
        textShouldEndEditing(_: NSText): boolean;
        toolTipForCell(for_: NSCell): string;
    }
    interface NSMatrixDelegate extends NSControlTextEditingDelegate {
    }
    class NSMediaLibraryBrowserController extends NSObject {
        frame: CGRect;
        setFrame(_: CGRect): any;
        mediaLibraries: NSMediaLibraryBrowserController.Library;
        setMediaLibraries(_: NSMediaLibraryBrowserController.Library): any;
        isVisible: boolean;
        setVisible(_: boolean): any;
        static sharedMediaLibraryBrowserController: NSMediaLibraryBrowserController;
        togglePanel(_?: any): void;
    }
    class NSMenu extends NSObject {
        static menuBarVisible(): boolean;
        static popUpContextMenuWithEventForView(_: NSMenu, with_: NSEvent, for_: NSView): void;
        static popUpContextMenuWithEventForViewWithFont(_: NSMenu, with_: NSEvent, for_: NSView, with_2?: NSFont): void;
        static setMenuBarVisible(_: boolean): void;
        allowsContextMenuPlugIns: boolean;
        setAllowsContextMenuPlugIns(_: boolean): any;
        autoenablesItems: boolean;
        setAutoenablesItems(_: boolean): any;
        delegate: NSMenuDelegate;
        setDelegate(_: NSMenuDelegate): any;
        font: NSFont;
        setFont(_: NSFont): any;
        highlightedItem: NSMenuItem;
        itemArray: NSMenuItem[];
        setItemArray(_: NSMenuItem[]): any;
        menuBarHeight: number;
        minimumWidth: number;
        setMinimumWidth(_: number): any;
        numberOfItems: number;
        propertiesToUpdate: NSMenu.Properties;
        showsStateColumn: boolean;
        setShowsStateColumn(_: boolean): any;
        size: CGSize;
        supermenu: NSMenu;
        setSupermenu(_: NSMenu): any;
        title: string;
        setTitle(_: string): any;
        userInterfaceLayoutDirection: NSUserInterfaceLayoutDirection;
        setUserInterfaceLayoutDirection(_: NSUserInterfaceLayoutDirection): any;
        addItem(_: NSMenuItem): void;
        addItemWithTitleActionKeyEquivalent(withTitle: string, action?: string, keyEquivalent?: string): NSMenuItem;
        cancelTracking(): void;
        cancelTrackingWithoutAnimation(): void;
        indexOfItem(of: NSMenuItem): number;
        indexOfItemWithRepresentedObject(withRepresentedObject?: any): number;
        indexOfItemWithSubmenu(withSubmenu?: NSMenu): number;
        indexOfItemWithTag(withTag: number): number;
        indexOfItemWithTargetAndAction(withTarget?: any, andAction?: string): number;
        indexOfItemWithTitle(withTitle: string): number;
        static createWithTitle(title: string): NSMenu;
        insertItemAtIndex(_: NSMenuItem, at: number): void;
        insertItemWithTitleActionKeyEquivalentAtIndex(withTitle: string, action?: string, keyEquivalent?: string, at?: number): NSMenuItem;
        itemAtIndex(at: number): NSMenuItem;
        itemChanged(_: NSMenuItem): void;
        itemWithTag(withTag: number): NSMenuItem;
        itemWithTitle(withTitle: string): NSMenuItem;
        performActionForItemAtIndex(at: number): void;
        performKeyEquivalent(with_: NSEvent): boolean;
        popUpMenuPositioningItemAtLocationInView(positioning?: NSMenuItem, at?: CGPoint, in_?: NSView): boolean;
        removeAllItems(): void;
        removeItem(_: NSMenuItem): void;
        removeItemAtIndex(at: number): void;
        setSubmenuForItem(_?: NSMenu, for_?: NSMenuItem): void;
        submenuAction(_?: any): void;
        update(): void;
    }
    interface NSMenuDelegate extends NSObject {
        confinementRectForMenuOnScreen?(for_: NSMenu, on?: NSScreen): CGRect;
        menuUpdateItemAtIndexShouldCancel?(_: NSMenu, update: NSMenuItem, at: number, shouldCancel: boolean): boolean;
        menuWillHighlightItem?(_: NSMenu, willHighlight?: NSMenuItem): void;
        menuDidClose?(_: NSMenu): void;
        menuHasKeyEquivalentForEventTargetAction?(_: NSMenu, for_: NSEvent, target?: any, action?: string): boolean;
        menuNeedsUpdate?(_: NSMenu): void;
        menuWillOpen?(_: NSMenu): void;
        numberOfItemsInMenu?(in_: NSMenu): number;
    }
    class NSMenuItem extends NSObject {
        static separatorItem(): NSMenuItem;
        action: string;
        setAction(_: string): any;
        allowsKeyEquivalentWhenHidden: boolean;
        setAllowsKeyEquivalentWhenHidden(_: boolean): any;
        isAlternate: boolean;
        setAlternate(_: boolean): any;
        attributedTitle: NSAttributedString;
        setAttributedTitle(_: NSAttributedString): any;
        isEnabled: boolean;
        setEnabled(_: boolean): any;
        hasSubmenu: boolean;
        isHidden: boolean;
        setHidden(_: boolean): any;
        isHiddenOrHasHiddenAncestor: boolean;
        isHighlighted: boolean;
        image: NSImage;
        setImage(_: NSImage): any;
        indentationLevel: number;
        setIndentationLevel(_: number): any;
        keyEquivalent: string;
        setKeyEquivalent(_: string): any;
        keyEquivalentModifierMask: NSEvent.ModifierFlags;
        setKeyEquivalentModifierMask(_: NSEvent.ModifierFlags): any;
        menu: NSMenu;
        setMenu(_: NSMenu): any;
        mixedStateImage: NSImage;
        setMixedStateImage(_: NSImage): any;
        offStateImage: NSImage;
        setOffStateImage(_: NSImage): any;
        onStateImage: NSImage;
        setOnStateImage(_: NSImage): any;
        parentItem: NSMenuItem;
        representedObject: any;
        setRepresentedObject(_: any): any;
        isSeparatorItem: boolean;
        state: number;
        setState(_: number): any;
        submenu: NSMenu;
        setSubmenu(_: NSMenu): any;
        tag: number;
        setTag(_: number): any;
        target: any;
        setTarget(_: any): any;
        title: string;
        setTitle(_: string): any;
        toolTip: string;
        setToolTip(_: string): any;
        userKeyEquivalent: string;
        view: NSView;
        setView(_: NSView): any;
        static usesUserKeyEquivalents: boolean;
        setUsesUserKeyEquivalents(_: boolean): any;
        static createWithTitleActionKeyEquivalent(title: string, action?: string, keyEquivalent?: string): NSMenuItem;
    }
    class NSMenuItemCell extends NSButtonCell {
        imageWidth: number;
        keyEquivalentWidth: number;
        menuItem: NSMenuItem;
        setMenuItem(_: NSMenuItem): any;
        needsDisplay: boolean;
        setNeedsDisplay(_: boolean): any;
        needsSizing: boolean;
        setNeedsSizing(_: boolean): any;
        stateImageWidth: number;
        titleWidth: number;
        calcSize(): void;
        drawBorderAndBackgroundWithFrameInView(withFrame: CGRect, in_: NSView): void;
        drawKeyEquivalentWithFrameInView(withFrame: CGRect, in_: NSView): void;
        drawSeparatorItemWithFrameInView(withFrame: CGRect, in_: NSView): void;
        drawStateImageWithFrameInView(withFrame: CGRect, in_: NSView): void;
        keyEquivalentRectForBounds(forBounds: CGRect): CGRect;
        stateImageRectForBounds(forBounds: CGRect): CGRect;
    }
    interface NSMenuItemValidation extends NSObject {
        validateMenuItem(_: NSMenuItem): boolean;
    }
    class NSMenuToolbarItem extends NSToolbarItem {
        menu: NSMenu;
        setMenu(_: NSMenu): any;
        showsIndicator: boolean;
        setShowsIndicator(_: boolean): any;
    }
    class NSMutableFontCollection extends NSFontCollection {
        static fontCollectionWithAllAvailableDescriptors: NSMutableFontCollection;
        addQueryForDescriptors(for_: NSFontDescriptor[]): void;
        removeQueryForDescriptors(for_: NSFontDescriptor[]): void;
    }
    class NSMutableParagraphStyle extends NSParagraphStyle {
        addTabStop(_: NSTextTab): void;
        removeTabStop(_: NSTextTab): void;
        setParagraphStyle(_: NSParagraphStyle): void;
    }
    class NSNib extends NSObject {
        static createWithNibDataBundle(nibData: NSData, bundle?: Bundle): NSNib;
        static createWithNibNamedBundle(nibNamed: string, bundle?: Bundle): NSNib;
        instantiateWithOwnerTopLevelObjects(withOwner?: any, topLevelObjects?: any[]): boolean;
    }
    class NSObjectController extends NSController {
        automaticallyPreparesContent: boolean;
        setAutomaticallyPreparesContent(_: boolean): any;
        canAdd: boolean;
        canRemove: boolean;
        content: any;
        setContent(_: any): any;
        isEditable: boolean;
        setEditable(_: boolean): any;
        entityName: string;
        setEntityName(_: string): any;
        fetchPredicate: NSPredicate;
        setFetchPredicate(_: NSPredicate): any;
        managedObjectContext: NSManagedObjectContext;
        setManagedObjectContext(_: NSManagedObjectContext): any;
        objectClass: typeof NSObject;
        setObjectClass(_: typeof NSObject): any;
        selectedObjects: any[];
        selection: any;
        usesLazyFetching: boolean;
        setUsesLazyFetching(_: boolean): any;
        add(_?: any): void;
        addObject(_: any): void;
        defaultFetchRequest(): NSFetchRequest;
        fetch(_?: any): void;
        fetchWithRequestMergeError(merge?: NSFetchRequest, error?: boolean): boolean;
        static createWithContent(content?: any): NSObjectController;
        newObject(): any;
        prepareContent(): void;
        remove(_?: any): void;
        removeObject(_: any): void;
        validateUserInterfaceItem(_: NSValidatedUserInterfaceItem): boolean;
    }
    class NSOpenPanel extends NSSavePanel {
        URLs: NSURL[];
        isAccessoryViewDisclosed: boolean;
        setAccessoryViewDisclosed(_: boolean): any;
        allowsMultipleSelection: boolean;
        setAllowsMultipleSelection(_: boolean): any;
        canChooseDirectories: boolean;
        setCanChooseDirectories(_: boolean): any;
        canChooseFiles: boolean;
        setCanChooseFiles(_: boolean): any;
        canDownloadUbiquitousContents: boolean;
        setCanDownloadUbiquitousContents(_: boolean): any;
        canResolveUbiquitousConflicts: boolean;
        setCanResolveUbiquitousConflicts(_: boolean): any;
        resolvesAliases: boolean;
        setResolvesAliases(_: boolean): any;
    }
    interface NSOpenSavePanelDelegate extends NSObject {
        panelShouldEnableURL?(_: any, shouldEnable: NSURL): boolean;
        panelDidChangeToDirectoryURL?(_: any, didChangeToDirectoryURL?: NSURL): void;
        panelUserEnteredFilenameConfirmed?(_: any, userEnteredFilename: string, confirmed: boolean): string;
        panelValidateURLError?(validateURL: any, error: NSURL): boolean;
        panelWillExpand?(_: any, willExpand: boolean): void;
        panelSelectionDidChange?(_?: any): void;
    }
    class NSOutlineView extends NSTableView {
        autoresizesOutlineColumn: boolean;
        setAutoresizesOutlineColumn(_: boolean): any;
        autosaveExpandedItems: boolean;
        setAutosaveExpandedItems(_: boolean): any;
        indentationMarkerFollowsCell: boolean;
        setIndentationMarkerFollowsCell(_: boolean): any;
        indentationPerLevel: number;
        setIndentationPerLevel(_: number): any;
        outlineTableColumn: NSTableColumn;
        setOutlineTableColumn(_: NSTableColumn): any;
        stronglyReferencesItems: boolean;
        setStronglyReferencesItems(_: boolean): any;
        childOfItem(_: number, ofItem?: any): any;
        childIndexForItem(forItem: any): number;
        collapseItem(_?: any): void;
        collapseItemCollapseChildren(_?: any, collapseChildren?: boolean): void;
        expandItem(_?: any): void;
        expandItemExpandChildren(_?: any, expandChildren?: boolean): void;
        frameOfOutlineCellAtRow(atRow: number): CGRect;
        insertItemsAtIndexesInParentWithAnimation(at: NSIndexSet, inParent?: any, withAnimation?: NSTableView.AnimationOptions): void;
        isExpandable(_?: any): boolean;
        isItemExpanded(_?: any): boolean;
        itemAtRow(atRow: number): any;
        levelForItem(forItem?: any): number;
        levelForRow(forRow: number): number;
        moveItemAtIndexInParentToIndexInParent(at: number, inParent?: any, to?: number, inParent2?: any): void;
        numberOfChildrenOfItem(ofItem?: any): number;
        parentForItem(forItem?: any): any;
        reloadItem(_?: any): void;
        reloadItemReloadChildren(_?: any, reloadChildren?: boolean): void;
        removeItemsAtIndexesInParentWithAnimation(at: NSIndexSet, inParent?: any, withAnimation?: NSTableView.AnimationOptions): void;
        rowForItem(forItem?: any): number;
        setDropItemDropChildIndex(_?: any, dropChildIndex?: number): void;
        shouldCollapseAutoExpandedItemsForDeposited(forDeposited: boolean): boolean;
    }
    interface NSOutlineViewDataSource extends NSObject {
        outlineViewObjectValueForTableColumnByItem?(_: NSOutlineView, objectValueFor?: NSTableColumn, byItem?: any): any;
        outlineViewSetObjectValueForTableColumnByItem?(_: NSOutlineView, setObjectValue?: any, for_?: NSTableColumn, byItem?: any): void;
        outlineViewDraggingSessionWillBeginAtPointForItems?(_: NSOutlineView, draggingSession: NSDraggingSession, willBeginAt: CGPoint, forItems: any[]): void;
        outlineViewDraggingSessionEndedAtPointOperation?(_: NSOutlineView, draggingSession: NSDraggingSession, endedAt: CGPoint, operation: NSDragOperation): void;
        outlineViewWriteItemsToPasteboard?(_: NSOutlineView, writeItems: any[], to: NSPasteboard): boolean;
        outlineViewAcceptDropItemChildIndex?(_: NSOutlineView, acceptDrop: NSDraggingInfo, item?: any, childIndex?: number): boolean;
        outlineViewChildOfItem?(_: NSOutlineView, child: number, ofItem?: any): any;
        outlineViewIsItemExpandable?(_: NSOutlineView, isItemExpandable: any): boolean;
        outlineViewItemForPersistentObject?(_: NSOutlineView, itemForPersistentObject: any): any;
        outlineViewNumberOfChildrenOfItem?(_: NSOutlineView, numberOfChildrenOfItem?: any): number;
        outlineViewPasteboardWriterForItem?(_: NSOutlineView, pasteboardWriterForItem: any): NSPasteboardWriting;
        outlineViewPersistentObjectForItem?(_: NSOutlineView, persistentObjectForItem?: any): any;
        outlineViewSortDescriptorsDidChange?(_: NSOutlineView, sortDescriptorsDidChange: NSSortDescriptor[]): void;
        outlineViewUpdateDraggingItemsForDrag?(_: NSOutlineView, updateDraggingItemsForDrag: NSDraggingInfo): void;
        outlineViewValidateDropProposedItemProposedChildIndex?(_: NSOutlineView, validateDrop: NSDraggingInfo, proposedItem?: any, proposedChildIndex?: number): NSDragOperation;
    }
    interface NSOutlineViewDelegate extends NSControlTextEditingDelegate {
        outlineViewViewForTableColumnItem?(_: NSOutlineView, viewFor?: NSTableColumn, item?: any): NSView;
        outlineViewWillDisplayOutlineCellForTableColumnItem?(_: NSOutlineView, willDisplayOutlineCell: any, for_?: NSTableColumn, item?: any): void;
        outlineViewDidAddRowViewForRow?(_: NSOutlineView, didAdd: NSTableRowView, forRow: number): void;
        outlineViewDidRemoveRowViewForRow?(_: NSOutlineView, didRemove: NSTableRowView, forRow: number): void;
        outlineViewWillDisplayCellForTableColumnItem?(_: NSOutlineView, willDisplayCell: any, for_?: NSTableColumn, item?: any): void;
        outlineViewShouldEditTableColumnItem?(_: NSOutlineView, shouldEdit?: NSTableColumn, item?: any): boolean;
        outlineViewDataCellForTableColumnItem?(_: NSOutlineView, dataCellFor?: NSTableColumn, item?: any): NSCell;
        outlineViewShouldTrackCellForTableColumnItem?(_: NSOutlineView, shouldTrackCell: NSCell, for_?: NSTableColumn, item?: any): boolean;
        outlineViewShouldShowCellExpansionForTableColumnItem?(_: NSOutlineView, shouldShowCellExpansionFor?: NSTableColumn, item?: any): boolean;
        outlineViewShouldSelectTableColumn?(_: NSOutlineView, shouldSelect?: NSTableColumn): boolean;
        outlineViewMouseDownInHeaderOfTableColumn?(_: NSOutlineView, mouseDownInHeaderOf: NSTableColumn): void;
        outlineViewDidClickTableColumn?(_: NSOutlineView, didClick: NSTableColumn): void;
        outlineViewDidDragTableColumn?(_: NSOutlineView, didDrag: NSTableColumn): void;
        outlineViewToolTipForCellRectTableColumnItemMouseLocation?(_: NSOutlineView, toolTipFor: NSCell, rect: NSRect, tableColumn?: NSTableColumn, item?: any, mouseLocation?: CGPoint): string;
        outlineViewShouldTypeSelectForEventWithCurrentSearchString?(_: NSOutlineView, shouldTypeSelectFor: NSEvent, withCurrentSearch?: string): boolean;
        outlineViewTypeSelectStringForTableColumnItem?(_: NSOutlineView, typeSelectStringFor?: NSTableColumn, item?: any): string;
        outlineViewNextTypeSelectMatchFromItemToItemForString?(_: NSOutlineView, nextTypeSelectMatchFromItem: any, toItem: any, for_: string): any;
        outlineViewHeightOfRowByItem?(_: NSOutlineView, heightOfRowByItem: any): number;
        outlineViewIsGroupItem?(_: NSOutlineView, isGroupItem: any): boolean;
        outlineViewRowViewForItem?(_: NSOutlineView, rowViewForItem: any): NSTableRowView;
        outlineViewSelectionIndexesForProposedSelection?(_: NSOutlineView, selectionIndexesForProposedSelection: NSIndexSet): NSIndexSet;
        outlineViewShouldCollapseItem?(_: NSOutlineView, shouldCollapseItem: any): boolean;
        outlineViewShouldExpandItem?(_: NSOutlineView, shouldExpandItem: any): boolean;
        outlineViewShouldReorderColumnToColumn?(_: NSOutlineView, shouldReorderColumn: number, toColumn: number): boolean;
        outlineViewShouldSelectItem?(_: NSOutlineView, shouldSelectItem: any): boolean;
        outlineViewShouldShowOutlineCellForItem?(_: NSOutlineView, shouldShowOutlineCellForItem: any): boolean;
        outlineViewSizeToFitWidthOfColumn?(_: NSOutlineView, sizeToFitWidthOfColumn: number): number;
        outlineViewColumnDidMove?(_: NSNotification): void;
        outlineViewColumnDidResize?(_: NSNotification): void;
        outlineViewItemDidCollapse?(_: NSNotification): void;
        outlineViewItemDidExpand?(_: NSNotification): void;
        outlineViewItemWillCollapse?(_: NSNotification): void;
        outlineViewItemWillExpand?(_: NSNotification): void;
        outlineViewSelectionDidChange?(_: NSNotification): void;
        outlineViewSelectionIsChanging?(_: NSNotification): void;
        selectionShouldChangeInOutlineView?(in_: NSOutlineView): boolean;
    }
    class NSPDFImageRep extends NSImageRep {
        PDFRepresentation: NSData;
        bounds: CGRect;
        currentPage: number;
        setCurrentPage(_: number): any;
        pageCount: number;
        static createWithData(data: NSData): NSPDFImageRep;
    }
    class NSPDFInfo extends NSObject {
        URL: NSURL;
        setURL(_: NSURL): any;
        attributes: NSMutableDictionary<string, any>;
        isFileExtensionHidden: boolean;
        setFileExtensionHidden(_: boolean): any;
        orientation: NSPrintInfo.PaperOrientation;
        setOrientation(_: NSPrintInfo.PaperOrientation): any;
        paperSize: CGSize;
        setPaperSize(_: CGSize): any;
        tagNames: string[];
        setTagNames(_: string[]): any;
    }
    class NSPDFPanel extends NSObject {
        accessoryController: NSViewController;
        setAccessoryController(_: NSViewController): any;
        defaultFileName: string;
        setDefaultFileName(_: string): any;
        options: NSPDFPanel.Options;
        setOptions(_: NSPDFPanel.Options): any;
        beginSheetWithWithModalForCompletionHandler(with_: NSPDFInfo, modalFor?: NSWindow, completionHandler?: (p1: number) => void): void;
    }
    class NSPICTImageRep extends NSImageRep {
        PICTRepresentation: NSData;
        boundingBox: CGRect;
        static createWithData(data: NSData): NSPICTImageRep;
    }
    class NSPageController extends NSViewController {
        arrangedObjects: any[];
        setArrangedObjects(_: any[]): any;
        delegate: NSPageControllerDelegate;
        setDelegate(_: NSPageControllerDelegate): any;
        selectedIndex: number;
        setSelectedIndex(_: number): any;
        selectedViewController: NSViewController;
        transitionStyle: NSPageController.TransitionStyle;
        setTransitionStyle(_: NSPageController.TransitionStyle): any;
        completeTransition(): void;
        navigateBack(_?: any): void;
        navigateForward(_?: any): void;
        navigateForwardToObject(to: any): void;
        takeSelectedIndexFrom(_?: any): void;
    }
    interface NSPageControllerDelegate extends NSObject {
        pageControllerIdentifierForObject?(_: NSPageController, identifierFor: any): string;
        pageControllerFrameForObject?(_: NSPageController, frameFor?: any): CGRect;
        pageControllerPrepareViewControllerWithObject?(_: NSPageController, prepare: NSViewController, with_?: any): void;
        pageControllerDidTransitionToObject?(_: NSPageController, didTransitionTo: any): void;
        pageControllerViewControllerForIdentifier?(_: NSPageController, viewControllerForIdentifier: string): NSViewController;
        pageControllerDidEndLiveTransition?(_: NSPageController): void;
        pageControllerWillStartLiveTransition?(_: NSPageController): void;
    }
    class NSPageLayout extends NSObject {
        accessoryControllers: NSViewController[];
        printInfo: NSPrintInfo;
        addAccessoryController(_: NSViewController): void;
        beginSheetWithPrintInfoModalForWindowDelegateDidEndSelectorContextInfo(with_: NSPrintInfo, modalFor: NSWindow, delegate?: any, didEnd?: string, contextInfo?: any): void;
        removeAccessoryController(_: NSViewController): void;
        runModal(): number;
        runModalWithPrintInfo(with_: NSPrintInfo): number;
    }
    class NSPanGestureRecognizer extends NSGestureRecognizer {
        buttonMask: number;
        setButtonMask(_: number): any;
        numberOfTouchesRequired: number;
        setNumberOfTouchesRequired(_: number): any;
        setTranslationInView(_: CGPoint, in_?: NSView): void;
        translationInView(in_?: NSView): CGPoint;
        velocityInView(in_?: NSView): CGPoint;
    }
    class NSPanel extends NSWindow {
        becomesKeyOnlyIfNeeded: boolean;
        setBecomesKeyOnlyIfNeeded(_: boolean): any;
    }
    class NSParagraphStyle extends NSObject {
        static defaultWritingDirectionForLanguage(forLanguage?: string): NSWritingDirection;
        alignment: NSTextAlignment;
        allowsDefaultTighteningForTruncation: boolean;
        baseWritingDirection: NSWritingDirection;
        defaultTabInterval: number;
        firstLineHeadIndent: number;
        headIndent: number;
        headerLevel: number;
        hyphenationFactor: number;
        lineBreakMode: NSLineBreakMode;
        lineHeightMultiple: number;
        lineSpacing: number;
        maximumLineHeight: number;
        minimumLineHeight: number;
        paragraphSpacing: number;
        paragraphSpacingBefore: number;
        tabStops: NSTextTab[];
        tailIndent: number;
        textBlocks: NSTextBlock[];
        textLists: NSTextList[];
        tighteningFactorForTruncation: number;
        static defaultParagraphStyle: NSParagraphStyle;
    }
    class NSPasteboard extends NSObject {
        static pasteboardWithUniqueName(): NSPasteboard;
        static typesFilterableTo(filterableTo: string): string[];
        changeCount: number;
        name: string;
        pasteboardItems: NSPasteboardItem[];
        types: string[];
        static generalPasteboard: NSPasteboard;
        addTypesOwner(_: string[], owner?: any): number;
        availableTypeFromArray(from: string[]): string;
        canReadItemWithDataConformingToTypes(withDataConformingToTypes: string[]): boolean;
        canReadObjectForClassesOptions(forClasses: typeof NSObject[], options?: Map<string, any>): boolean;
        clearContents(): number;
        dataForType(forType: string): NSData;
        declareTypesOwner(_: string[], owner?: any): number;
        indexOfPasteboardItem(of: NSPasteboardItem): number;
        prepareForNewContentsWithOptions(with_: NSPasteboard.ContentsOptions): number;
        propertyListForType(forType: string): any;
        readFileContentsTypeToFile(_?: string, toFile?: string): string;
        readFileWrapper(): FileWrapper;
        readObjectsForClassesOptions(forClasses: typeof NSObject[], options?: Map<string, any>): any[];
        releaseGlobally(): void;
        setDataForType(_?: NSData, forType?: string): boolean;
        setPropertyListForType(_: any, forType: string): boolean;
        setStringForType(_: string, forType: string): boolean;
        stringForType(forType: string): string;
        writeFileContents(_: string): boolean;
        writeFileWrapper(_: FileWrapper): boolean;
        writeObjects(_: NSPasteboardWriting[]): boolean;
    }
    class NSPasteboardItem extends NSObject {
        types: string[];
        availableTypeFromArray(from: string[]): string;
        dataForType(forType: string): NSData;
        propertyListForType(forType: string): any;
        setDataForType(_: NSData, forType: string): boolean;
        setDataProviderForTypes(_: NSPasteboardItemDataProvider, forTypes: string[]): boolean;
        setPropertyListForType(_: any, forType: string): boolean;
        setStringForType(_: string, forType: string): boolean;
        stringForType(forType: string): string;
    }
    interface NSPasteboardItemDataProvider extends NSObject {
        pasteboardItemProvideDataForType(_?: NSPasteboard, item?: NSPasteboardItem, provideDataForType?: string): void;
        pasteboardFinishedWithDataProvider?(_: NSPasteboard): void;
    }
    interface NSPasteboardReading extends NSObject {
    }
    interface NSPasteboardTypeOwner extends NSObject {
        pasteboardProvideDataForType(_: NSPasteboard, provideDataForType: string): void;
        pasteboardChangedOwner?(_: NSPasteboard): void;
    }
    interface NSPasteboardWriting extends NSObject {
        pasteboardPropertyListForType(forType: string): any;
        writableTypesForPasteboard(for_: NSPasteboard): string[];
        writingOptionsForTypePasteboard?(forType: string, pasteboard: NSPasteboard): NSPasteboard.WritingOptions;
    }
    class NSPathCell extends NSActionCell {
        URL: NSURL;
        setURL(_: NSURL): any;
        allowedTypes: string[];
        setAllowedTypes(_: string[]): any;
        backgroundColor: NSColor;
        setBackgroundColor(_: NSColor): any;
        clickedPathComponentCell: NSPathComponentCell;
        delegate: NSPathCellDelegate;
        setDelegate(_: NSPathCellDelegate): any;
        doubleAction: string;
        setDoubleAction(_: string): any;
        pathComponentCells: NSPathComponentCell[];
        setPathComponentCells(_: NSPathComponentCell[]): any;
        pathStyle: NSPathControl.Style;
        setPathStyle(_: NSPathControl.Style): any;
        placeholderAttributedString: NSAttributedString;
        setPlaceholderAttributedString(_: NSAttributedString): any;
        placeholderString: string;
        setPlaceholderString(_: string): any;
        static pathComponentCellClass: typeof NSObject;
        mouseEnteredWithFrameInView(with_: NSEvent, frame: CGRect, in_: NSView): void;
        mouseExitedWithFrameInView(with_: NSEvent, frame: CGRect, in_: NSView): void;
        pathComponentCellAtPointWithFrameInView(at: CGPoint, withFrame: CGRect, in_: NSView): NSPathComponentCell;
        rectOfPathComponentCellWithFrameInView(of: NSPathComponentCell, withFrame: CGRect, in_: NSView): CGRect;
        setObjectValue(_?: any): void;
    }
    interface NSPathCellDelegate extends NSObject {
        pathCellWillDisplayOpenPanel?(_: NSPathCell, willDisplay: NSOpenPanel): void;
        pathCellWillPopUpMenu?(_: NSPathCell, willPopUp: NSMenu): void;
    }
    class NSPathComponentCell extends NSTextFieldCell {
        URL: NSURL;
        setURL(_: NSURL): any;
    }
    class NSPathControl extends NSControl {
        URL: NSURL;
        setURL(_: NSURL): any;
        allowedTypes: string[];
        setAllowedTypes(_: string[]): any;
        backgroundColor: NSColor;
        setBackgroundColor(_: NSColor): any;
        clickedPathItem: NSPathControlItem;
        delegate: NSPathControlDelegate;
        setDelegate(_: NSPathControlDelegate): any;
        doubleAction: string;
        setDoubleAction(_: string): any;
        isEditable: boolean;
        setEditable(_: boolean): any;
        pathItems: NSPathControlItem[];
        setPathItems(_: NSPathControlItem[]): any;
        pathStyle: NSPathControl.Style;
        setPathStyle(_: NSPathControl.Style): any;
        placeholderAttributedString: NSAttributedString;
        setPlaceholderAttributedString(_: NSAttributedString): any;
        placeholderString: string;
        setPlaceholderString(_: string): any;
        setDraggingSourceOperationMaskForLocal(_: NSDragOperation, forLocal: boolean): void;
    }
    interface NSPathControlDelegate extends NSObject {
        pathControlShouldDragItemWithPasteboard?(_: NSPathControl, shouldDrag: NSPathControlItem, with_: NSPasteboard): boolean;
        pathControlShouldDragPathComponentCellWithPasteboard?(_: NSPathControl, shouldDrag: NSPathComponentCell, with_: NSPasteboard): boolean;
        pathControlWillDisplayOpenPanel?(_: NSPathControl, willDisplay: NSOpenPanel): void;
        pathControlWillPopUpMenu?(_: NSPathControl, willPopUp: NSMenu): void;
        pathControlAcceptDrop?(_: NSPathControl, acceptDrop: NSDraggingInfo): boolean;
        pathControlValidateDrop?(_: NSPathControl, validateDrop: NSDraggingInfo): NSDragOperation;
    }
    class NSPathControlItem extends NSObject {
        URL: NSURL;
        attributedTitle: NSAttributedString;
        setAttributedTitle(_: NSAttributedString): any;
        image: NSImage;
        setImage(_: NSImage): any;
        title: string;
        setTitle(_: string): any;
    }
    class NSPersistentDocument extends NSDocument {
        managedObjectContext: NSManagedObjectContext;
        setManagedObjectContext(_: NSManagedObjectContext): any;
        managedObjectModel: NSManagedObjectModel;
        configurePersistentStoreCoordinatorForURLOfTypeModelConfigurationStoreOptionsError(ofType: NSURL, modelConfiguration: string, storeOptions?: string, error?: Map<string, any>): boolean;
        persistentStoreTypeForFileType(forFileType: string): string;
    }
    class NSPickerTouchBarItem extends NSTouchBarItem {
        action: string;
        setAction(_: string): any;
        collapsedRepresentationImage: NSImage;
        setCollapsedRepresentationImage(_: NSImage): any;
        collapsedRepresentationLabel: string;
        setCollapsedRepresentationLabel(_: string): any;
        controlRepresentation: NSPickerTouchBarItem.ControlRepresentation;
        setControlRepresentation(_: NSPickerTouchBarItem.ControlRepresentation): any;
        isEnabled: boolean;
        setEnabled(_: boolean): any;
        numberOfOptions: number;
        setNumberOfOptions(_: number): any;
        selectedIndex: number;
        setSelectedIndex(_: number): any;
        selectionColor: NSColor;
        setSelectionColor(_: NSColor): any;
        selectionMode: NSPickerTouchBarItem.SelectionMode;
        setSelectionMode(_: NSPickerTouchBarItem.SelectionMode): any;
        target: any;
        setTarget(_: any): any;
        imageAtIndex(at: number): NSImage;
        isEnabledAtIndex(at: number): boolean;
        labelAtIndex(at: number): string;
        setEnabledAtIndex(_: boolean, at: number): void;
        setImageAtIndex(_?: NSImage, at?: number): void;
        setLabelAtIndex(_: string, at: number): void;
    }
    class NSPopUpButton extends NSButton {
        autoenablesItems: boolean;
        setAutoenablesItems(_: boolean): any;
        indexOfSelectedItem: number;
        itemArray: NSMenuItem[];
        itemTitles: string[];
        lastItem: NSMenuItem;
        numberOfItems: number;
        preferredEdge: NSRectEdge;
        setPreferredEdge(_: NSRectEdge): any;
        pullsDown: boolean;
        setPullsDown(_: boolean): any;
        selectedItem: NSMenuItem;
        titleOfSelectedItem: string;
        addItemWithTitle(withTitle: string): void;
        addItemsWithTitles(withTitles: string[]): void;
        indexOfItem(of: NSMenuItem): number;
        indexOfItemWithRepresentedObject(withRepresentedObject?: any): number;
        indexOfItemWithTag(withTag: number): number;
        indexOfItemWithTargetAndAction(withTarget?: any, andAction?: string): number;
        indexOfItemWithTitle(withTitle: string): number;
        static createWithFramePullsDown(frame: CGRect, pullsDown: boolean): NSPopUpButton;
        insertItemWithTitleAtIndex(withTitle: string, at: number): void;
        itemAtIndex(at: number): NSMenuItem;
        itemTitleAtIndex(at: number): string;
        itemWithTitle(withTitle: string): NSMenuItem;
        removeAllItems(): void;
        removeItemAtIndex(at: number): void;
        removeItemWithTitle(withTitle: string): void;
        selectItem(_?: NSMenuItem): void;
        selectItemAtIndex(at: number): void;
        selectItemWithTag(withTag: number): boolean;
        selectItemWithTitle(withTitle: string): void;
        setTitle(_: string): void;
        synchronizeTitleAndSelectedItem(): void;
    }
    class NSPopUpButtonCell extends NSMenuItemCell {
        altersStateOfSelectedItem: boolean;
        setAltersStateOfSelectedItem(_: boolean): any;
        arrowPosition: NSPopUpButton.ArrowPosition;
        setArrowPosition(_: NSPopUpButton.ArrowPosition): any;
        autoenablesItems: boolean;
        setAutoenablesItems(_: boolean): any;
        indexOfSelectedItem: number;
        itemArray: NSMenuItem[];
        itemTitles: string[];
        lastItem: NSMenuItem;
        numberOfItems: number;
        preferredEdge: NSRectEdge;
        setPreferredEdge(_: NSRectEdge): any;
        pullsDown: boolean;
        setPullsDown(_: boolean): any;
        selectedItem: NSMenuItem;
        titleOfSelectedItem: string;
        usesItemFromMenu: boolean;
        setUsesItemFromMenu(_: boolean): any;
        addItemWithTitle(withTitle: string): void;
        addItemsWithTitles(withTitles: string[]): void;
        attachPopUpWithFrameInView(withFrame: CGRect, in_: NSView): void;
        dismissPopUp(): void;
        indexOfItem(of: NSMenuItem): number;
        indexOfItemWithRepresentedObject(withRepresentedObject?: any): number;
        indexOfItemWithTag(withTag: number): number;
        indexOfItemWithTargetAndAction(withTarget?: any, andAction?: string): number;
        indexOfItemWithTitle(withTitle: string): number;
        static createWithTextCellPullsDown(textCell: string, pullsDown: boolean): NSPopUpButtonCell;
        insertItemWithTitleAtIndex(withTitle: string, at: number): void;
        itemAtIndex(at: number): NSMenuItem;
        itemTitleAtIndex(at: number): string;
        itemWithTitle(withTitle: string): NSMenuItem;
        performClickWithFrameInView(withFrame: CGRect, in_: NSView): void;
        removeAllItems(): void;
        removeItemAtIndex(at: number): void;
        removeItemWithTitle(withTitle: string): void;
        selectItem(_?: NSMenuItem): void;
        selectItemAtIndex(at: number): void;
        selectItemWithTag(withTag: number): boolean;
        selectItemWithTitle(withTitle: string): void;
        setTitle(_?: string): void;
        synchronizeTitleAndSelectedItem(): void;
    }
    class NSPopover extends NSResponder {
        animates: boolean;
        setAnimates(_: boolean): any;
        behavior: NSPopover.Behavior;
        setBehavior(_: NSPopover.Behavior): any;
        contentSize: CGSize;
        setContentSize(_: CGSize): any;
        contentViewController: NSViewController;
        setContentViewController(_: NSViewController): any;
        delegate: NSPopoverDelegate;
        setDelegate(_: NSPopoverDelegate): any;
        isDetached: boolean;
        positioningRect: CGRect;
        setPositioningRect(_: CGRect): any;
        isShown: boolean;
        close(): void;
        performClose(_?: any): void;
        showRelativeToRectOfViewPreferredEdge(relativeTo: CGRect, of: NSView, preferredEdge: NSRectEdge): void;
    }
    interface NSPopoverDelegate extends NSObject {
        detachableWindowForPopover?(for_: NSPopover): NSWindow;
        popoverDidClose?(_: NSNotification): void;
        popoverDidDetach?(_: NSPopover): void;
        popoverDidShow?(_: NSNotification): void;
        popoverShouldClose?(_: NSPopover): boolean;
        popoverShouldDetach?(_: NSPopover): boolean;
        popoverWillClose?(_: NSNotification): void;
        popoverWillShow?(_: NSNotification): void;
    }
    class NSPopoverTouchBarItem extends NSTouchBarItem {
        collapsedRepresentation: NSView;
        setCollapsedRepresentation(_: NSView): any;
        collapsedRepresentationImage: NSImage;
        setCollapsedRepresentationImage(_: NSImage): any;
        collapsedRepresentationLabel: string;
        setCollapsedRepresentationLabel(_: string): any;
        popoverTouchBar: NSTouchBar;
        setPopoverTouchBar(_: NSTouchBar): any;
        pressAndHoldTouchBar: NSTouchBar;
        setPressAndHoldTouchBar(_: NSTouchBar): any;
        showsCloseButton: boolean;
        setShowsCloseButton(_: boolean): any;
        dismissPopover(_?: any): void;
        makeStandardActivatePopoverGestureRecognizer(): NSGestureRecognizer;
        showPopover(_?: any): void;
    }
    class NSPredicateEditor extends NSRuleEditor {
        rowTemplates: NSPredicateEditorRowTemplate[];
        setRowTemplates(_: NSPredicateEditorRowTemplate[]): any;
    }
    class NSPredicateEditorRowTemplate extends NSObject {
        static templatesWithAttributeKeyPathsInEntityDescription(withAttributeKeyPaths: string[], in_: NSEntityDescription): NSPredicateEditorRowTemplate[];
        compoundTypes: number[];
        leftExpressions: NSExpression[];
        modifier: NSComparisonPredicate.Modifier;
        operators: number[];
        options: number;
        rightExpressionAttributeType: NSAttributeType;
        rightExpressions: NSExpression[];
        templateViews: NSView[];
        displayableSubpredicatesOfPredicate(of: NSPredicate): NSPredicate[];
        static createWithCompoundTypes(compoundTypes: number[]): NSPredicateEditorRowTemplate;
        static createWithLeftExpressionsRightExpressionAttributeTypeModifierOperatorsOptions(leftExpressions: NSExpression[], rightExpressionAttributeType: NSAttributeType, modifier: NSComparisonPredicate.Modifier, operators: number[], options: number): NSPredicateEditorRowTemplate;
        static createWithLeftExpressionsRightExpressionsModifierOperatorsOptions(leftExpressions: NSExpression[], rightExpressions: NSExpression[], modifier: NSComparisonPredicate.Modifier, operators: number[], options: number): NSPredicateEditorRowTemplate;
        matchForPredicate(for_: NSPredicate): number;
        predicateWithSubpredicates(withSubpredicates?: NSPredicate[]): NSPredicate;
        setPredicate(_: NSPredicate): void;
    }
    class NSPressGestureRecognizer extends NSGestureRecognizer {
        allowableMovement: number;
        setAllowableMovement(_: number): any;
        buttonMask: number;
        setButtonMask(_: number): any;
        minimumPressDuration: number;
        setMinimumPressDuration(_: number): any;
        numberOfTouchesRequired: number;
        setNumberOfTouchesRequired(_: number): any;
    }
    class NSPressureConfiguration extends NSObject {
        pressureBehavior: NSEvent.PressureBehavior;
        static createWithPressureBehavior(pressureBehavior: NSEvent.PressureBehavior): NSPressureConfiguration;
        set(): void;
    }
    class NSPrintInfo extends NSObject {
        bottomMargin: number;
        setBottomMargin(_: number): any;
        horizontalPagination: NSPrintInfo.PaginationMode;
        setHorizontalPagination(_: NSPrintInfo.PaginationMode): any;
        isHorizontallyCentered: boolean;
        setHorizontallyCentered(_: boolean): any;
        imageablePageBounds: CGRect;
        jobDisposition: string;
        setJobDisposition(_: string): any;
        leftMargin: number;
        setLeftMargin(_: number): any;
        localizedPaperName: string;
        orientation: NSPrintInfo.PaperOrientation;
        setOrientation(_: NSPrintInfo.PaperOrientation): any;
        paperName: string;
        setPaperName(_: string): any;
        paperSize: CGSize;
        setPaperSize(_: CGSize): any;
        printSettings: NSMutableDictionary<string, any>;
        printer: NSPrinter;
        setPrinter(_: NSPrinter): any;
        rightMargin: number;
        setRightMargin(_: number): any;
        scalingFactor: number;
        setScalingFactor(_: number): any;
        isSelectionOnly: boolean;
        setSelectionOnly(_: boolean): any;
        topMargin: number;
        setTopMargin(_: number): any;
        verticalPagination: NSPrintInfo.PaginationMode;
        setVerticalPagination(_: NSPrintInfo.PaginationMode): any;
        isVerticallyCentered: boolean;
        setVerticallyCentered(_: boolean): any;
        static defaultPrinter: NSPrinter;
        static sharedPrintInfo: NSPrintInfo;
        setSharedPrintInfo(_: NSPrintInfo): any;
        PMPageFormat(): any;
        PMPrintSession(): any;
        PMPrintSettings(): any;
        dictionary(): NSMutableDictionary<string, any>;
        static createWithDictionary(dictionary: Map<string, any>): NSPrintInfo;
        setUpPrintOperationDefaultValues(): void;
        takeSettingsFromPDFInfo(from: NSPDFInfo): void;
        updateFromPMPageFormat(): void;
        updateFromPMPrintSettings(): void;
    }
    class NSPrintOperation extends NSObject {
        static EPSOperationWithViewInsideRectToData(with_: NSView, inside: CGRect, to?: NSMutableData): NSPrintOperation;
        static EPSOperationWithViewInsideRectToDataPrintInfo(with_: NSView, inside: CGRect, to: NSMutableData, printInfo: NSPrintInfo): NSPrintOperation;
        static EPSOperationWithViewInsideRectToPathPrintInfo(with_: NSView, inside: CGRect, toPath: string, printInfo: NSPrintInfo): NSPrintOperation;
        static PDFOperationWithViewInsideRectToData(with_: NSView, inside: CGRect, to: NSMutableData): NSPrintOperation;
        static PDFOperationWithViewInsideRectToDataPrintInfo(with_: NSView, inside: CGRect, to: NSMutableData, printInfo: NSPrintInfo): NSPrintOperation;
        static PDFOperationWithViewInsideRectToPathPrintInfo(with_: NSView, inside: CGRect, toPath: string, printInfo: NSPrintInfo): NSPrintOperation;
        PDFPanel: NSPDFPanel;
        setPDFPanel(_: NSPDFPanel): any;
        canSpawnSeparateThread: boolean;
        setCanSpawnSeparateThread(_: boolean): any;
        context: NSGraphicsContext;
        isCopyingOperation: boolean;
        currentPage: number;
        jobTitle: string;
        setJobTitle(_: string): any;
        pageOrder: NSPrintOperation.PageOrder;
        setPageOrder(_: NSPrintOperation.PageOrder): any;
        pageRange: NSRange;
        preferredRenderingQuality: NSPrintOperation.RenderingQuality;
        printInfo: NSPrintInfo;
        setPrintInfo(_: NSPrintInfo): any;
        printPanel: NSPrintPanel;
        setPrintPanel(_: NSPrintPanel): any;
        showsPrintPanel: boolean;
        setShowsPrintPanel(_: boolean): any;
        showsProgressPanel: boolean;
        setShowsProgressPanel(_: boolean): any;
        view: NSView;
        static currentOperation: NSPrintOperation;
        setCurrentOperation(_: NSPrintOperation): any;
        cleanUpOperation(): void;
        createContext(): NSGraphicsContext;
        deliverResult(): boolean;
        destroyContext(): void;
        runOperation(): boolean;
        runOperationModalForWindowDelegateDidRunSelectorContextInfo(for_: NSWindow, delegate?: any, didRun?: string, contextInfo?: any): void;
    }
    class NSPrintPanel extends NSObject {
        accessoryControllers: NSViewController[];
        helpAnchor: string;
        setHelpAnchor(_: string): any;
        jobStyleHint: string;
        setJobStyleHint(_: string): any;
        options: NSPrintPanel.Options;
        setOptions(_: NSPrintPanel.Options): any;
        printInfo: NSPrintInfo;
        addAccessoryController(_: NSViewController): void;
        beginSheetWithPrintInfoModalForWindowDelegateDidEndSelectorContextInfo(with_: NSPrintInfo, modalFor: NSWindow, delegate?: any, didEnd?: string, contextInfo?: any): void;
        defaultButtonTitle(): string;
        removeAccessoryController(_: NSViewController): void;
        runModal(): number;
        runModalWithPrintInfo(with_: NSPrintInfo): number;
        setDefaultButtonTitle(_?: string): void;
    }
    interface NSPrintPanelAccessorizing {
        keyPathsForValuesAffectingPreview?(): NSSet<string>;
        localizedSummaryItems(): Map<string, string>[];
    }
    class NSPrinter extends NSObject {
        deviceDescription: Map<string, any>;
        languageLevel: number;
        name: string;
        type: string;
        static printerNames: string[];
        static printerTypes: string[];
        pageSizeForPaper(forPaper: string): CGSize;
    }
    class NSProgressIndicator extends NSView {
        isBezeled: boolean;
        setBezeled(_: boolean): any;
        controlSize: NSControl.ControlSize;
        setControlSize(_: NSControl.ControlSize): any;
        controlTint: NSControlTint;
        setControlTint(_: NSControlTint): any;
        isDisplayedWhenStopped: boolean;
        setDisplayedWhenStopped(_: boolean): any;
        doubleValue: number;
        setDoubleValue(_: number): any;
        isIndeterminate: boolean;
        setIndeterminate(_: boolean): any;
        maxValue: number;
        setMaxValue(_: number): any;
        minValue: number;
        setMinValue(_: number): any;
        style: NSProgressIndicator.Style;
        setStyle(_: NSProgressIndicator.Style): any;
        usesThreadedAnimation: boolean;
        setUsesThreadedAnimation(_: boolean): any;
        incrementBy(by: number): void;
        sizeToFit(): void;
        startAnimation(_?: any): void;
        stopAnimation(_?: any): void;
    }
    class NSResponder extends NSObject {
        acceptsFirstResponder: boolean;
        menu: NSMenu;
        setMenu(_: NSMenu): any;
        nextResponder: NSResponder;
        setNextResponder(_: NSResponder): any;
        touchBar: NSTouchBar;
        setTouchBar(_: NSTouchBar): any;
        undoManager: UndoManager;
        userActivity: NSUserActivity;
        setUserActivity(_: NSUserActivity): any;
        static restorableStateKeyPaths: string[];
        becomeFirstResponder(): boolean;
        beginGestureWithEvent(with_: NSEvent): void;
        changeModeWithEvent(with_: NSEvent): void;
        cursorUpdate(with_: NSEvent): void;
        encodeRestorableStateWithCoder(with_: NSCoder): void;
        encodeRestorableStateWithCoderBackgroundQueue(with_: NSCoder, backgroundQueue: OperationQueue): void;
        endGestureWithEvent(with_: NSEvent): void;
        flagsChanged(with_: NSEvent): void;
        flushBufferedKeyEvents(): void;
        helpRequested(_: NSEvent): void;
        interpretKeyEvents(_: NSEvent[]): void;
        invalidateRestorableState(): void;
        keyDown(with_: NSEvent): void;
        keyUp(with_: NSEvent): void;
        magnifyWithEvent(with_: NSEvent): void;
        makeTouchBar(): NSTouchBar;
        mouseDown(with_: NSEvent): void;
        mouseDragged(with_: NSEvent): void;
        mouseEntered(with_: NSEvent): void;
        mouseExited(with_: NSEvent): void;
        mouseMoved(with_: NSEvent): void;
        mouseUp(with_: NSEvent): void;
        newWindowForTab(_?: any): void;
        noResponderFor(for_: string): void;
        otherMouseDown(with_: NSEvent): void;
        otherMouseDragged(with_: NSEvent): void;
        otherMouseUp(with_: NSEvent): void;
        performKeyEquivalent(with_: NSEvent): boolean;
        performTextFinderAction(_?: any): void;
        presentError(_: NSError): boolean;
        presentErrorModalForWindowDelegateDidPresentSelectorContextInfo(_: NSError, modalFor: NSWindow, delegate?: any, didPresent?: string, contextInfo?: any): void;
        pressureChangeWithEvent(with_: NSEvent): void;
        quickLookWithEvent(with_: NSEvent): void;
        resignFirstResponder(): boolean;
        restoreStateWithCoder(with_: NSCoder): void;
        rightMouseDown(with_: NSEvent): void;
        rightMouseDragged(with_: NSEvent): void;
        rightMouseUp(with_: NSEvent): void;
        rotateWithEvent(with_: NSEvent): void;
        scrollWheel(with_: NSEvent): void;
        shouldBeTreatedAsInkEvent(_: NSEvent): boolean;
        showContextHelp(_?: any): void;
        smartMagnifyWithEvent(with_: NSEvent): void;
        supplementalTargetForActionSender(forAction: string, sender?: any): any;
        swipeWithEvent(with_: NSEvent): void;
        tabletPoint(with_: NSEvent): void;
        tabletProximity(with_: NSEvent): void;
        touchesBeganWithEvent(with_: NSEvent): void;
        touchesCancelledWithEvent(with_: NSEvent): void;
        touchesEndedWithEvent(with_: NSEvent): void;
        touchesMovedWithEvent(with_: NSEvent): void;
        tryToPerformWith(_: string, with_?: any): boolean;
        updateUserActivityState(_: NSUserActivity): void;
        validRequestorForSendTypeReturnType(forSendType?: string, returnType?: string): any;
        validateProposedFirstResponderForEvent(_: NSResponder, for_?: NSEvent): boolean;
        wantsForwardedScrollEventsForAxis(for_: NSEvent.GestureAxis): boolean;
        wantsScrollEventsForSwipeTrackingOnAxis(on: NSEvent.GestureAxis): boolean;
        willPresentError(_: NSError): NSError;
    }
    class NSRotationGestureRecognizer extends NSGestureRecognizer {
        rotation: number;
        setRotation(_: number): any;
        rotationInDegrees: number;
        setRotationInDegrees(_: number): any;
    }
    class NSRuleEditor extends NSControl {
        canRemoveAllRows: boolean;
        setCanRemoveAllRows(_: boolean): any;
        criteriaKeyPath: string;
        setCriteriaKeyPath(_: string): any;
        delegate: NSRuleEditorDelegate;
        setDelegate(_: NSRuleEditorDelegate): any;
        displayValuesKeyPath: string;
        setDisplayValuesKeyPath(_: string): any;
        isEditable: boolean;
        setEditable(_: boolean): any;
        formattingDictionary: Map<string, string>;
        setFormattingDictionary(_: Map<string, string>): any;
        formattingStringsFilename: string;
        setFormattingStringsFilename(_: string): any;
        nestingMode: NSRuleEditor.NestingMode;
        setNestingMode(_: NSRuleEditor.NestingMode): any;
        numberOfRows: number;
        predicate: NSPredicate;
        rowClass: typeof NSObject;
        setRowClass(_: typeof NSObject): any;
        rowHeight: number;
        setRowHeight(_: number): any;
        rowTypeKeyPath: string;
        setRowTypeKeyPath(_: string): any;
        selectedRowIndexes: NSIndexSet;
        subrowsKeyPath: string;
        setSubrowsKeyPath(_: string): any;
        addRow(_?: any): void;
        criteriaForRow(forRow: number): any[];
        displayValuesForRow(forRow: number): any[];
        insertRowAtIndexWithTypeAsSubrowOfRowAnimate(at: number, with_: NSRuleEditor.RowType, asSubrowOfRow: number, animate: boolean): void;
        parentRowForRow(forRow: number): number;
        predicateForRow(forRow: number): NSPredicate;
        reloadCriteria(): void;
        reloadPredicate(): void;
        removeRowAtIndex(at: number): void;
        removeRowsAtIndexesIncludeSubrows(at: NSIndexSet, includeSubrows: boolean): void;
        rowForDisplayValue(forDisplayValue: any): number;
        rowTypeForRow(forRow: number): NSRuleEditor.RowType;
        selectRowIndexesByExtendingSelection(_: NSIndexSet, byExtendingSelection: boolean): void;
        setCriteriaAndDisplayValuesForRowAtIndex(_: any[], andDisplayValues: any[], forRowAt: number): void;
        subrowIndexesForRow(forRow: number): NSIndexSet;
    }
    interface NSRuleEditorDelegate extends NSObject {
        ruleEditorNumberOfChildrenForCriterionWithRowType(_: NSRuleEditor, numberOfChildrenForCriterion?: any, with_?: NSRuleEditor.RowType): number;
        ruleEditorChildForCriterionWithRowType(_: NSRuleEditor, child: number, forCriterion?: any, with_?: NSRuleEditor.RowType): any;
        ruleEditorDisplayValueForCriterionInRow(_: NSRuleEditor, displayValueForCriterion: any, inRow: number): any;
        ruleEditorPredicatePartsForCriterionWithDisplayValueInRow?(_: NSRuleEditor, predicatePartsForCriterion: any, withDisplayValue: any, inRow: number): Map<string, any>;
        ruleEditorRowsDidChange?(_: NSNotification): void;
    }
    class NSRulerMarker extends NSObject {
        isDragging: boolean;
        image: NSImage;
        setImage(_: NSImage): any;
        imageOrigin: CGPoint;
        setImageOrigin(_: CGPoint): any;
        imageRectInRuler: CGRect;
        markerLocation: number;
        setMarkerLocation(_: number): any;
        isMovable: boolean;
        setMovable(_: boolean): any;
        isRemovable: boolean;
        setRemovable(_: boolean): any;
        representedObject: any;
        setRepresentedObject(_: any): any;
        ruler: NSRulerView;
        thicknessRequiredInRuler: number;
        drawRect(_: CGRect): void;
        static createWithRulerViewMarkerLocationImageImageOrigin(rulerView: NSRulerView, markerLocation: number, image: NSImage, imageOrigin: CGPoint): NSRulerMarker;
        trackMouseAdding(with_: NSEvent, adding: boolean): boolean;
    }
    class NSRulerView extends NSView {
        static registerUnitWithNameAbbreviationUnitToPointsConversionFactorStepUpCycleStepDownCycle(withName: string, abbreviation: string, unitToPointsConversionFactor: number, stepUpCycle: number[], stepDownCycle: number[]): void;
        accessoryView: NSView;
        setAccessoryView(_: NSView): any;
        baselineLocation: number;
        clientView: NSView;
        setClientView(_: NSView): any;
        markers: NSRulerMarker[];
        setMarkers(_: NSRulerMarker[]): any;
        measurementUnits: string;
        setMeasurementUnits(_: string): any;
        orientation: NSRulerView.Orientation;
        setOrientation(_: NSRulerView.Orientation): any;
        originOffset: number;
        setOriginOffset(_: number): any;
        requiredThickness: number;
        reservedThicknessForAccessoryView: number;
        setReservedThicknessForAccessoryView(_: number): any;
        reservedThicknessForMarkers: number;
        setReservedThicknessForMarkers(_: number): any;
        ruleThickness: number;
        setRuleThickness(_: number): any;
        scrollView: NSScrollView;
        setScrollView(_: NSScrollView): any;
        addMarker(_: NSRulerMarker): void;
        drawHashMarksAndLabelsInRect(in_: CGRect): void;
        drawMarkersInRect(in_: CGRect): void;
        static createWithScrollViewOrientation(scrollView?: NSScrollView, orientation?: NSRulerView.Orientation): NSRulerView;
        invalidateHashMarks(): void;
        moveRulerlineFromLocationToLocation(fromLocation: number, toLocation: number): void;
        removeMarker(_: NSRulerMarker): void;
        trackMarkerWithMouseEvent(_: NSRulerMarker, withMouseEvent: NSEvent): boolean;
    }
    class NSRunningApplication extends NSObject {
        static runningApplicationsWithBundleIdentifier(withBundleIdentifier: string): NSRunningApplication[];
        static terminateAutomaticallyTerminableApplications(): void;
        activationPolicy: NSApplication.ActivationPolicy;
        isActive: boolean;
        bundleIdentifier: string;
        bundleURL: NSURL;
        executableArchitecture: number;
        executableURL: NSURL;
        isFinishedLaunching: boolean;
        isHidden: boolean;
        icon: NSImage;
        launchDate: Date;
        localizedName: string;
        ownsMenuBar: boolean;
        processIdentifier: number;
        isTerminated: boolean;
        static currentApplication: NSRunningApplication;
        activateWithOptions(options: NSApplication.ActivationOptions): boolean;
        forceTerminate(): boolean;
        hide(): boolean;
        terminate(): boolean;
        unhide(): boolean;
    }
    class NSSavePanel extends NSPanel {
        URL: NSURL;
        accessoryView: NSView;
        setAccessoryView(_: NSView): any;
        allowedFileTypes: string[];
        setAllowedFileTypes(_: string[]): any;
        allowsOtherFileTypes: boolean;
        setAllowsOtherFileTypes(_: boolean): any;
        canCreateDirectories: boolean;
        setCanCreateDirectories(_: boolean): any;
        canSelectHiddenExtension: boolean;
        setCanSelectHiddenExtension(_: boolean): any;
        directoryURL: NSURL;
        setDirectoryURL(_: NSURL): any;
        isExpanded: boolean;
        isExtensionHidden: boolean;
        setExtensionHidden(_: boolean): any;
        message: string;
        setMessage(_: string): any;
        nameFieldLabel: string;
        setNameFieldLabel(_: string): any;
        nameFieldStringValue: string;
        setNameFieldStringValue(_: string): any;
        prompt: string;
        setPrompt(_: string): any;
        showsHiddenFiles: boolean;
        setShowsHiddenFiles(_: boolean): any;
        showsTagField: boolean;
        setShowsTagField(_: boolean): any;
        tagNames: string[];
        setTagNames(_: string[]): any;
        treatsFilePackagesAsDirectories: boolean;
        setTreatsFilePackagesAsDirectories(_: boolean): any;
        beginSheetModalForCompletionHandler(for_: NSWindow, completionHandler: (p1: number) => void): void;
        beginWithCompletionHandler(completionHandler: (p1: number) => void): void;
        cancel(_?: any): void;
        ok(_?: any): void;
        runModal(): number;
        validateVisibleColumns(): void;
    }
    class NSScreen extends NSObject {
        backingScaleFactor: number;
        colorSpace: NSColorSpace;
        depth: NSWindow.Depth;
        deviceDescription: Map<string, any>;
        frame: CGRect;
        localizedName: string;
        maximumExtendedDynamicRangeColorComponentValue: number;
        maximumPotentialExtendedDynamicRangeColorComponentValue: number;
        maximumReferenceExtendedDynamicRangeColorComponentValue: number;
        supportedWindowDepths: NSWindow.Depth;
        visibleFrame: CGRect;
        static deepestScreen: NSScreen;
        static mainScreen: NSScreen;
        static screens: NSScreen[];
        static screensHaveSeparateSpaces: boolean;
        backingAlignedRectOptions(_: CGRect, options: AlignmentOptions): CGRect;
        canRepresentDisplayGamut(_: NSDisplayGamut): boolean;
        convertRectFromBacking(_: CGRect): CGRect;
        convertRectToBacking(_: CGRect): CGRect;
    }
    class NSScrollView extends NSView {
        static contentSizeForFrameSizeHorizontalScrollerClassVerticalScrollerClassBorderTypeControlSizeScrollerStyle(forFrameSize: CGSize, horizontalScrollerClass?: typeof NSObject, verticalScrollerClass?: typeof NSObject, borderType?: NSBorderType, controlSize?: NSControl.ControlSize, scrollerStyle?: NSScroller.Style): CGSize;
        static frameSizeForContentSizeHorizontalScrollerClassVerticalScrollerClassBorderTypeControlSizeScrollerStyle(forContentSize: CGSize, horizontalScrollerClass?: typeof NSObject, verticalScrollerClass?: typeof NSObject, borderType?: NSBorderType, controlSize?: NSControl.ControlSize, scrollerStyle?: NSScroller.Style): CGSize;
        allowsMagnification: boolean;
        setAllowsMagnification(_: boolean): any;
        autohidesScrollers: boolean;
        setAutohidesScrollers(_: boolean): any;
        automaticallyAdjustsContentInsets: boolean;
        setAutomaticallyAdjustsContentInsets(_: boolean): any;
        backgroundColor: NSColor;
        setBackgroundColor(_: NSColor): any;
        borderType: NSBorderType;
        setBorderType(_: NSBorderType): any;
        contentInsets: NSEdgeInsets;
        setContentInsets(_: NSEdgeInsets): any;
        contentSize: CGSize;
        contentView: NSClipView;
        setContentView(_: NSClipView): any;
        documentCursor: NSCursor;
        setDocumentCursor(_: NSCursor): any;
        documentView: NSView;
        setDocumentView(_: NSView): any;
        documentVisibleRect: CGRect;
        drawsBackground: boolean;
        setDrawsBackground(_: boolean): any;
        findBarPosition: NSScrollView.FindBarPosition;
        setFindBarPosition(_: NSScrollView.FindBarPosition): any;
        hasHorizontalRuler: boolean;
        setHasHorizontalRuler(_: boolean): any;
        hasHorizontalScroller: boolean;
        setHasHorizontalScroller(_: boolean): any;
        hasVerticalRuler: boolean;
        setHasVerticalRuler(_: boolean): any;
        hasVerticalScroller: boolean;
        setHasVerticalScroller(_: boolean): any;
        horizontalLineScroll: number;
        setHorizontalLineScroll(_: number): any;
        horizontalPageScroll: number;
        setHorizontalPageScroll(_: number): any;
        horizontalRulerView: NSRulerView;
        setHorizontalRulerView(_: NSRulerView): any;
        horizontalScrollElasticity: NSScrollView.Elasticity;
        setHorizontalScrollElasticity(_: NSScrollView.Elasticity): any;
        horizontalScroller: NSScroller;
        setHorizontalScroller(_: NSScroller): any;
        lineScroll: number;
        setLineScroll(_: number): any;
        magnification: number;
        setMagnification(_: number): any;
        maxMagnification: number;
        setMaxMagnification(_: number): any;
        minMagnification: number;
        setMinMagnification(_: number): any;
        pageScroll: number;
        setPageScroll(_: number): any;
        rulersVisible: boolean;
        setRulersVisible(_: boolean): any;
        scrollerInsets: NSEdgeInsets;
        setScrollerInsets(_: NSEdgeInsets): any;
        scrollerKnobStyle: NSScroller.KnobStyle;
        setScrollerKnobStyle(_: NSScroller.KnobStyle): any;
        scrollerStyle: NSScroller.Style;
        setScrollerStyle(_: NSScroller.Style): any;
        scrollsDynamically: boolean;
        setScrollsDynamically(_: boolean): any;
        usesPredominantAxisScrolling: boolean;
        setUsesPredominantAxisScrolling(_: boolean): any;
        verticalLineScroll: number;
        setVerticalLineScroll(_: number): any;
        verticalPageScroll: number;
        setVerticalPageScroll(_: number): any;
        verticalRulerView: NSRulerView;
        setVerticalRulerView(_: NSRulerView): any;
        verticalScrollElasticity: NSScrollView.Elasticity;
        setVerticalScrollElasticity(_: NSScrollView.Elasticity): any;
        verticalScroller: NSScroller;
        setVerticalScroller(_: NSScroller): any;
        static rulerViewClass: typeof NSObject;
        setRulerViewClass(_: typeof NSObject): any;
        addFloatingSubviewForAxis(_: NSView, for_: NSEvent.GestureAxis): void;
        flashScrollers(): void;
        magnifyToFitRect(toFit: CGRect): void;
        setMagnificationCenteredAtPoint(_: number, centeredAt: CGPoint): void;
        tile(): void;
    }
    class NSScroller extends NSControl {
        static scrollerWidthForControlSizeScrollerStyle(for_: NSControl.ControlSize, scrollerStyle: NSScroller.Style): number;
        hitPart: NSScroller.Part;
        knobProportion: number;
        setKnobProportion(_: number): any;
        knobStyle: NSScroller.KnobStyle;
        setKnobStyle(_: NSScroller.KnobStyle): any;
        scrollerStyle: NSScroller.Style;
        setScrollerStyle(_: NSScroller.Style): any;
        usableParts: NSScroller.UsableParts;
        static isCompatibleWithOverlayScrollers: boolean;
        static preferredScrollerStyle: NSScroller.Style;
        checkSpaceForParts(): void;
        drawKnob(): void;
        drawKnobSlotInRectHighlight(in_: CGRect, highlight: boolean): void;
        rectForPart(for_: NSScroller.Part): CGRect;
        setKnobProportion(_: number): void;
        testPart(_: CGPoint): NSScroller.Part;
        trackKnob(with_: NSEvent): void;
    }
    class NSScrubber extends NSView {
        backgroundColor: NSColor;
        setBackgroundColor(_: NSColor): any;
        backgroundView: NSView;
        setBackgroundView(_: NSView): any;
        isContinuous: boolean;
        setContinuous(_: boolean): any;
        dataSource: NSScrubberDataSource;
        setDataSource(_: NSScrubberDataSource): any;
        delegate: NSScrubberDelegate;
        setDelegate(_: NSScrubberDelegate): any;
        floatsSelectionViews: boolean;
        setFloatsSelectionViews(_: boolean): any;
        highlightedIndex: number;
        itemAlignment: NSScrubber.Alignment;
        setItemAlignment(_: NSScrubber.Alignment): any;
        mode: NSScrubber.Mode;
        setMode(_: NSScrubber.Mode): any;
        numberOfItems: number;
        scrubberLayout: NSScrubberLayout;
        setScrubberLayout(_: NSScrubberLayout): any;
        selectedIndex: number;
        setSelectedIndex(_: number): any;
        selectionBackgroundStyle: NSScrubberSelectionStyle;
        setSelectionBackgroundStyle(_: NSScrubberSelectionStyle): any;
        selectionOverlayStyle: NSScrubberSelectionStyle;
        setSelectionOverlayStyle(_: NSScrubberSelectionStyle): any;
        showsAdditionalContentIndicators: boolean;
        setShowsAdditionalContentIndicators(_: boolean): any;
        showsArrowButtons: boolean;
        setShowsArrowButtons(_: boolean): any;
        insertItemsAtIndexes(at: NSIndexSet): void;
        itemViewForItemAtIndex(at: number): NSScrubberItemView;
        makeItemWithIdentifierOwner(withIdentifier: string, owner?: any): NSScrubberItemView;
        moveItemAtIndexToIndex(at: number, to: number): void;
        performSequentialBatchUpdates(_: () => void): void;
        registerClassForItemIdentifier(_?: typeof NSObject, forItemIdentifier?: string): void;
        registerNibForItemIdentifier(_?: NSNib, forItemIdentifier?: string): void;
        reloadData(): void;
        reloadItemsAtIndexes(at: NSIndexSet): void;
        removeItemsAtIndexes(at: NSIndexSet): void;
        scrollItemAtIndexToAlignment(at: number, to: NSScrubber.Alignment): void;
    }
    class NSScrubberArrangedView extends NSView {
        isHighlighted: boolean;
        setHighlighted(_: boolean): any;
        isSelected: boolean;
        setSelected(_: boolean): any;
        applyLayoutAttributes(_: NSScrubberLayoutAttributes): void;
    }
    interface NSScrubberDataSource extends NSObject {
        numberOfItemsForScrubber(for_: NSScrubber): number;
        scrubberViewForItemAtIndex(_: NSScrubber, viewForItemAt: number): NSScrubberItemView;
    }
    interface NSScrubberDelegate extends NSObject {
        didBeginInteractingWithScrubber?(with_: NSScrubber): void;
        didCancelInteractingWithScrubber?(with_: NSScrubber): void;
        didFinishInteractingWithScrubber?(with_: NSScrubber): void;
        scrubberDidSelectItemAtIndex?(_: NSScrubber, didSelectItemAt: number): void;
        scrubberDidHighlightItemAtIndex?(_: NSScrubber, didHighlightItemAt: number): void;
        scrubberDidChangeVisibleRange?(_: NSScrubber, didChangeVisibleRange: NSRange): void;
    }
    class NSScrubberFlowLayout extends NSScrubberLayout {
        itemSize: CGSize;
        setItemSize(_: CGSize): any;
        itemSpacing: number;
        setItemSpacing(_: number): any;
        invalidateLayoutForItemsAtIndexes(at: NSIndexSet): void;
    }
    interface NSScrubberFlowLayoutDelegate extends NSScrubberDelegate {
        scrubberLayoutSizeForItemAtIndex?(_: NSScrubber, layout: NSScrubberFlowLayout, sizeForItemAt: number): CGSize;
    }
    class NSScrubberImageItemView extends NSScrubberItemView {
        image: NSImage;
        setImage(_: NSImage): any;
        imageAlignment: NSImageAlignment;
        setImageAlignment(_: NSImageAlignment): any;
        imageView: NSImageView;
    }
    class NSScrubberItemView extends NSScrubberArrangedView {
    }
    class NSScrubberLayout extends NSObject {
        automaticallyMirrorsInRightToLeftLayout: boolean;
        scrubber: NSScrubber;
        scrubberContentSize: CGSize;
        shouldInvalidateLayoutForHighlightChange: boolean;
        shouldInvalidateLayoutForSelectionChange: boolean;
        visibleRect: CGRect;
        static layoutAttributesClass: typeof NSObject;
        invalidateLayout(): void;
        layoutAttributesForItemAtIndex(at: number): NSScrubberLayoutAttributes;
        layoutAttributesForItemsInRect(in_: CGRect): NSSet<NSScrubberLayoutAttributes>;
        prepareLayout(): void;
        shouldInvalidateLayoutForChangeFromVisibleRectToVisibleRect(fromVisibleRect: CGRect, toVisibleRect: CGRect): boolean;
    }
    class NSScrubberLayoutAttributes extends NSObject {
        static layoutAttributesForItemAtIndex(forItemAt: number): NSScrubberLayoutAttributes;
        alpha: number;
        setAlpha(_: number): any;
        frame: CGRect;
        setFrame(_: CGRect): any;
        itemIndex: number;
        setItemIndex(_: number): any;
    }
    class NSScrubberProportionalLayout extends NSScrubberLayout {
        numberOfVisibleItems: number;
        setNumberOfVisibleItems(_: number): any;
        static createWithNumberOfVisibleItems(numberOfVisibleItems: number): NSScrubberProportionalLayout;
    }
    class NSScrubberSelectionStyle extends NSObject {
        static outlineOverlayStyle: NSScrubberSelectionStyle;
        static roundedBackgroundStyle: NSScrubberSelectionStyle;
        makeSelectionView(): NSScrubberSelectionView;
    }
    class NSScrubberSelectionView extends NSScrubberArrangedView {
    }
    class NSScrubberTextItemView extends NSScrubberItemView {
        textField: NSTextField;
        title: string;
        setTitle(_: string): any;
    }
    class NSSearchField extends NSTextField {
        centersPlaceholder: boolean;
        setCentersPlaceholder(_: boolean): any;
        maximumRecents: number;
        setMaximumRecents(_: number): any;
        recentSearches: string[];
        setRecentSearches(_: string[]): any;
        recentsAutosaveName: string;
        setRecentsAutosaveName(_: string): any;
        searchMenuTemplate: NSMenu;
        setSearchMenuTemplate(_: NSMenu): any;
        sendsSearchStringImmediately: boolean;
        setSendsSearchStringImmediately(_: boolean): any;
        sendsWholeSearchString: boolean;
        setSendsWholeSearchString(_: boolean): any;
        rectForCancelButtonWhenCentered(whenCentered: boolean): CGRect;
        rectForSearchButtonWhenCentered(whenCentered: boolean): CGRect;
        rectForSearchTextWhenCentered(whenCentered: boolean): CGRect;
    }
    class NSSearchFieldCell extends NSTextFieldCell {
        cancelButtonCell: NSButtonCell;
        setCancelButtonCell(_: NSButtonCell): any;
        maximumRecents: number;
        setMaximumRecents(_: number): any;
        recentSearches: string[];
        setRecentSearches(_: string[]): any;
        recentsAutosaveName: string;
        setRecentsAutosaveName(_: string): any;
        searchButtonCell: NSButtonCell;
        setSearchButtonCell(_: NSButtonCell): any;
        searchMenuTemplate: NSMenu;
        setSearchMenuTemplate(_: NSMenu): any;
        sendsSearchStringImmediately: boolean;
        setSendsSearchStringImmediately(_: boolean): any;
        sendsWholeSearchString: boolean;
        setSendsWholeSearchString(_: boolean): any;
        cancelButtonRectForBounds(forBounds: CGRect): CGRect;
        resetCancelButtonCell(): void;
        resetSearchButtonCell(): void;
        searchButtonRectForBounds(forBounds: CGRect): CGRect;
        searchTextRectForBounds(forBounds: CGRect): CGRect;
    }
    interface NSSearchFieldDelegate extends NSTextFieldDelegate {
        searchFieldDidEndSearching?(_: NSSearchField): void;
        searchFieldDidStartSearching?(_: NSSearchField): void;
    }
    class NSSecureTextField extends NSTextField {
    }
    class NSSecureTextFieldCell extends NSTextFieldCell {
        echosBullets: boolean;
        setEchosBullets(_: boolean): any;
    }
    class NSSegmentedCell extends NSActionCell {
        segmentCount: number;
        setSegmentCount(_: number): any;
        segmentStyle: NSSegmentedControl.Style;
        setSegmentStyle(_: NSSegmentedControl.Style): any;
        selectedSegment: number;
        setSelectedSegment(_: number): any;
        trackingMode: NSSegmentedControl.SwitchTracking;
        setTrackingMode(_: NSSegmentedControl.SwitchTracking): any;
        drawSegmentInFrameWithView(_: number, inFrame: CGRect, with_: NSView): void;
        imageForSegment(forSegment: number): NSImage;
        imageScalingForSegment(forSegment: number): NSImageScaling;
        interiorBackgroundStyleForSegment(forSegment: number): NSView.BackgroundStyle;
        isEnabledForSegment(forSegment: number): boolean;
        isSelectedForSegment(forSegment: number): boolean;
        labelForSegment(forSegment: number): string;
        makeNextSegmentKey(): void;
        makePreviousSegmentKey(): void;
        menuForSegment(forSegment: number): NSMenu;
        selectSegmentWithTag(withTag: number): boolean;
        setEnabledForSegment(_: boolean, forSegment: number): void;
        setImageForSegment(_?: NSImage, forSegment?: number): void;
        setImageScalingForSegment(_: NSImageScaling, forSegment: number): void;
        setLabelForSegment(_: string, forSegment: number): void;
        setMenuForSegment(_?: NSMenu, forSegment?: number): void;
        setSelectedForSegment(_: boolean, forSegment: number): void;
        setTagForSegment(_: number, forSegment: number): void;
        setToolTipForSegment(_?: string, forSegment?: number): void;
        setWidthForSegment(_: number, forSegment: number): void;
        tagForSegment(forSegment: number): number;
        toolTipForSegment(forSegment: number): string;
        widthForSegment(forSegment: number): number;
    }
    class NSSegmentedControl extends NSControl {
        doubleValueForSelectedSegment: number;
        indexOfSelectedItem: number;
        segmentCount: number;
        setSegmentCount(_: number): any;
        segmentDistribution: NSSegmentedControl.Distribution;
        setSegmentDistribution(_: NSSegmentedControl.Distribution): any;
        segmentStyle: NSSegmentedControl.Style;
        setSegmentStyle(_: NSSegmentedControl.Style): any;
        selectedSegment: number;
        setSelectedSegment(_: number): any;
        selectedSegmentBezelColor: NSColor;
        setSelectedSegmentBezelColor(_: NSColor): any;
        isSpringLoaded: boolean;
        setSpringLoaded(_: boolean): any;
        trackingMode: NSSegmentedControl.SwitchTracking;
        setTrackingMode(_: NSSegmentedControl.SwitchTracking): any;
        alignmentForSegment(forSegment: number): NSTextAlignment;
        imageForSegment(forSegment: number): NSImage;
        imageScalingForSegment(forSegment: number): NSImageScaling;
        isEnabledForSegment(forSegment: number): boolean;
        isSelectedForSegment(forSegment: number): boolean;
        labelForSegment(forSegment: number): string;
        menuForSegment(forSegment: number): NSMenu;
        selectSegmentWithTag(withTag: number): boolean;
        setAlignmentForSegment(_: NSTextAlignment, forSegment: number): void;
        setEnabledForSegment(_: boolean, forSegment: number): void;
        setImageForSegment(_?: NSImage, forSegment?: number): void;
        setImageScalingForSegment(_: NSImageScaling, forSegment: number): void;
        setLabelForSegment(_: string, forSegment: number): void;
        setMenuForSegment(_?: NSMenu, forSegment?: number): void;
        setSelectedForSegment(_: boolean, forSegment: number): void;
        setShowsMenuIndicatorForSegment(_: boolean, forSegment: number): void;
        setTagForSegment(_: number, forSegment: number): void;
        setToolTipForSegment(_?: string, forSegment?: number): void;
        setWidthForSegment(_: number, forSegment: number): void;
        showsMenuIndicatorForSegment(forSegment: number): boolean;
        tagForSegment(forSegment: number): number;
        toolTipForSegment(forSegment: number): string;
        widthForSegment(forSegment: number): number;
    }
    interface NSSeguePerforming extends NSObject {
        performSegueWithIdentifierSender?(withIdentifier: string, sender?: any): void;
        prepareForSegueSender?(for_: NSStoryboardSegue, sender?: any): void;
        shouldPerformSegueWithIdentifierSender?(withIdentifier: string, sender?: any): boolean;
    }
    interface NSServicesMenuRequestor extends NSObject {
        readSelectionFromPasteboard?(from: NSPasteboard): boolean;
        writeSelectionToPasteboardTypes?(to: NSPasteboard, types: string[]): boolean;
    }
    class NSShadow extends NSObject {
        shadowBlurRadius: number;
        setShadowBlurRadius(_: number): any;
        shadowColor: NSColor;
        setShadowColor(_: NSColor): any;
        shadowOffset: CGSize;
        setShadowOffset(_: CGSize): any;
        set(): void;
    }
    class NSSharingService extends NSObject {
        static sharingServicesForItems(forItems: any[]): NSSharingService[];
        accountName: string;
        alternateImage: NSImage;
        attachmentFileURLs: NSURL[];
        delegate: NSSharingServiceDelegate;
        setDelegate(_: NSSharingServiceDelegate): any;
        image: NSImage;
        menuItemTitle: string;
        setMenuItemTitle(_: string): any;
        messageBody: string;
        permanentLink: NSURL;
        recipients: string[];
        setRecipients(_: string[]): any;
        subject: string;
        setSubject(_: string): any;
        title: string;
        canPerformWithItems(withItems?: any[]): boolean;
        static createWithTitleImageAlternateImageHandler(title: string, image: NSImage, alternateImage?: NSImage, handler?: () => void): NSSharingService;
        performWithItems(withItems: any[]): void;
    }
    interface NSSharingServiceDelegate extends NSObject {
        anchoringViewForSharingServiceShowRelativeToRectPreferredEdge?(for_: NSSharingService, showRelativeTo: NSRect, preferredEdge: NSRectEdge): NSView;
        sharingServiceDidFailToShareItemsError?(_: NSSharingService, didFailToShareItems: any[], error: NSError): void;
        sharingServiceDidShareItems?(_: NSSharingService, didShareItems: any[]): void;
        sharingServiceSourceFrameOnScreenForShareItem?(_: NSSharingService, sourceFrameOnScreenForShareItem: any): CGRect;
        sharingServiceSourceWindowForShareItemsSharingContentScope?(_: NSSharingService, sourceWindowForShareItems: any[], sharingContentScope: NSSharingService.SharingContentScope): NSWindow;
        sharingServiceTransitionImageForShareItemContentRect?(_: NSSharingService, transitionImageForShareItem: any, contentRect: NSRect): NSImage;
        sharingServiceWillShareItems?(_: NSSharingService, willShareItems: any[]): void;
    }
    class NSSharingServicePicker extends NSObject {
        delegate: NSSharingServicePickerDelegate;
        setDelegate(_: NSSharingServicePickerDelegate): any;
        static createWithItems(items: any[]): NSSharingServicePicker;
        showRelativeToRectOfViewPreferredEdge(relativeTo: CGRect, of: NSView, preferredEdge: NSRectEdge): void;
    }
    interface NSSharingServicePickerDelegate extends NSObject {
        sharingServicePickerDelegateForSharingService?(_: NSSharingServicePicker, delegateFor: NSSharingService): NSSharingServiceDelegate;
        sharingServicePickerDidChooseSharingService?(_: NSSharingServicePicker, didChoose?: NSSharingService): void;
        sharingServicePickerSharingServicesForItemsProposedSharingServices?(_: NSSharingServicePicker, sharingServicesForItems: any[], proposedSharingServices: NSSharingService[]): NSSharingService[];
    }
    class NSSharingServicePickerToolbarItem extends NSToolbarItem {
        delegate: NSSharingServicePickerToolbarItemDelegate;
        setDelegate(_: NSSharingServicePickerToolbarItemDelegate): any;
    }
    interface NSSharingServicePickerToolbarItemDelegate extends NSSharingServicePickerDelegate {
        itemsForSharingServicePickerToolbarItem(for_: NSSharingServicePickerToolbarItem): any[];
    }
    class NSSharingServicePickerTouchBarItem extends NSTouchBarItem {
        buttonImage: NSImage;
        setButtonImage(_: NSImage): any;
        buttonTitle: string;
        setButtonTitle(_: string): any;
        delegate: NSSharingServicePickerTouchBarItemDelegate;
        setDelegate(_: NSSharingServicePickerTouchBarItemDelegate): any;
        isEnabled: boolean;
        setEnabled(_: boolean): any;
    }
    interface NSSharingServicePickerTouchBarItemDelegate extends NSSharingServicePickerDelegate {
        itemsForSharingServicePickerTouchBarItem(for_: NSSharingServicePickerTouchBarItem): any[];
    }
    class NSSlider extends NSControl {
        allowsTickMarkValuesOnly: boolean;
        setAllowsTickMarkValuesOnly(_: boolean): any;
        altIncrementValue: number;
        setAltIncrementValue(_: number): any;
        knobThickness: number;
        maxValue: number;
        setMaxValue(_: number): any;
        minValue: number;
        setMinValue(_: number): any;
        numberOfTickMarks: number;
        setNumberOfTickMarks(_: number): any;
        sliderType: NSSlider.SliderType;
        setSliderType(_: NSSlider.SliderType): any;
        tickMarkPosition: NSSlider.TickMarkPosition;
        setTickMarkPosition(_: NSSlider.TickMarkPosition): any;
        trackFillColor: NSColor;
        setTrackFillColor(_: NSColor): any;
        isVertical: boolean;
        closestTickMarkValueToValue(toValue: number): number;
        indexOfTickMarkAtPoint(at: CGPoint): number;
        rectOfTickMarkAtIndex(at: number): CGRect;
        tickMarkValueAtIndex(at: number): number;
    }
    class NSSliderAccessory extends NSObject {
        behavior: NSSliderAccessoryBehavior;
        setBehavior(_: NSSliderAccessoryBehavior): any;
        isEnabled: boolean;
        setEnabled(_: boolean): any;
    }
    class NSSliderAccessoryBehavior extends NSObject {
        static initWithHandler(handler: (p1: NSSliderAccessory) => void): NSSliderAccessoryBehavior;
        static behaviorWithTargetAction(target?: any, action?: string): NSSliderAccessoryBehavior;
        static automaticBehavior: NSSliderAccessoryBehavior;
        static valueResetBehavior: NSSliderAccessoryBehavior;
        static valueStepBehavior: NSSliderAccessoryBehavior;
        handleAction(_: NSSliderAccessory): void;
    }
    class NSSliderCell extends NSActionCell {
        allowsTickMarkValuesOnly: boolean;
        setAllowsTickMarkValuesOnly(_: boolean): any;
        altIncrementValue: number;
        setAltIncrementValue(_: number): any;
        knobThickness: number;
        maxValue: number;
        setMaxValue(_: number): any;
        minValue: number;
        setMinValue(_: number): any;
        numberOfTickMarks: number;
        setNumberOfTickMarks(_: number): any;
        sliderType: NSSlider.SliderType;
        setSliderType(_: NSSlider.SliderType): any;
        tickMarkPosition: NSSlider.TickMarkPosition;
        setTickMarkPosition(_: NSSlider.TickMarkPosition): any;
        trackRect: CGRect;
        isVertical: boolean;
        barRectFlipped(flipped: boolean): CGRect;
        closestTickMarkValueToValue(toValue: number): number;
        drawBarInsideFlipped(inside: CGRect, flipped: boolean): void;
        drawKnob(): void;
        drawKnob(_: CGRect): void;
        drawTickMarks(): void;
        indexOfTickMarkAtPoint(at: CGPoint): number;
        knobRectFlipped(flipped: boolean): CGRect;
        rectOfTickMarkAtIndex(at: number): CGRect;
        tickMarkValueAtIndex(at: number): number;
    }
    class NSSliderTouchBarItem extends NSTouchBarItem {
        action: string;
        setAction(_: string): any;
        doubleValue: number;
        setDoubleValue(_: number): any;
        label: string;
        setLabel(_: string): any;
        maximumSliderWidth: number;
        setMaximumSliderWidth(_: number): any;
        maximumValueAccessory: NSSliderAccessory;
        setMaximumValueAccessory(_: NSSliderAccessory): any;
        minimumSliderWidth: number;
        setMinimumSliderWidth(_: number): any;
        minimumValueAccessory: NSSliderAccessory;
        setMinimumValueAccessory(_: NSSliderAccessory): any;
        slider: NSSlider;
        setSlider(_: NSSlider): any;
        target: any;
        setTarget(_: any): any;
        valueAccessoryWidth: number;
        setValueAccessoryWidth(_: number): any;
    }
    class NSSound extends NSObject {
        static canInitWithPasteboard(with_: NSPasteboard): boolean;
        currentTime: number;
        setCurrentTime(_: number): any;
        delegate: NSSoundDelegate;
        setDelegate(_: NSSoundDelegate): any;
        duration: number;
        loops: boolean;
        setLoops(_: boolean): any;
        name: string;
        playbackDeviceIdentifier: string;
        setPlaybackDeviceIdentifier(_: string): any;
        isPlaying: boolean;
        volume: number;
        setVolume(_: number): any;
        static soundUnfilteredTypes: string[];
        static createWithContentsOfFileByReference(contentsOfFile: string, byReference: boolean): NSSound;
        static createWithContentsOfURLByReference(contentsOfURL: NSURL, byReference: boolean): NSSound;
        static createWithData(data: NSData): NSSound;
        static createWithPasteboard(pasteboard: NSPasteboard): NSSound;
        pause(): boolean;
        play(): boolean;
        resume(): boolean;
        setName(_?: string): boolean;
        stop(): boolean;
        writeToPasteboard(to: NSPasteboard): void;
    }
    interface NSSoundDelegate extends NSObject {
        soundDidFinishPlaying?(_: NSSound, didFinishPlaying: boolean): void;
    }
    class NSSpeechRecognizer extends NSObject {
        blocksOtherRecognizers: boolean;
        setBlocksOtherRecognizers(_: boolean): any;
        commands: string[];
        setCommands(_: string[]): any;
        delegate: NSSpeechRecognizerDelegate;
        setDelegate(_: NSSpeechRecognizerDelegate): any;
        displayedCommandsTitle: string;
        setDisplayedCommandsTitle(_: string): any;
        listensInForegroundOnly: boolean;
        setListensInForegroundOnly(_: boolean): any;
        startListening(): void;
        stopListening(): void;
    }
    interface NSSpeechRecognizerDelegate extends NSObject {
        speechRecognizerDidRecognizeCommand?(_: NSSpeechRecognizer, didRecognizeCommand: string): void;
    }
    class NSSpeechSynthesizer extends NSObject {
        static attributesForVoice(forVoice: string): Map<string, any>;
        delegate: NSSpeechSynthesizerDelegate;
        setDelegate(_: NSSpeechSynthesizerDelegate): any;
        rate: number;
        setRate(_: number): any;
        isSpeaking: boolean;
        usesFeedbackWindow: boolean;
        setUsesFeedbackWindow(_: boolean): any;
        volume: number;
        setVolume(_: number): any;
        static isAnyApplicationSpeaking: boolean;
        static availableVoices: string[];
        static defaultVoice: string;
        addSpeechDictionary(_: Map<string, any>): void;
        continueSpeaking(): void;
        static createWithVoice(voice?: string): NSSpeechSynthesizer;
        objectForPropertyError(error: string): any;
        pauseSpeakingAtBoundary(at: NSSpeechSynthesizer.Boundary): void;
        phonemesFromText(from: string): string;
        setObjectForPropertyError(forProperty?: any, error?: string): boolean;
        setVoice(_?: string): boolean;
        startSpeakingString(_: string): boolean;
        startSpeakingStringToURL(_: string, to: NSURL): boolean;
        stopSpeaking(): void;
        stopSpeakingAtBoundary(at: NSSpeechSynthesizer.Boundary): void;
        voice(): string;
    }
    interface NSSpeechSynthesizerDelegate extends NSObject {
        speechSynthesizerWillSpeakWordOfString?(_: NSSpeechSynthesizer, willSpeakWord: NSRange, of: string): void;
        speechSynthesizerDidEncounterErrorAtIndexOfStringMessage?(_: NSSpeechSynthesizer, didEncounterErrorAt: number, of: string, message: string): void;
        speechSynthesizerDidEncounterSyncMessage?(_: NSSpeechSynthesizer, didEncounterSyncMessage: string): void;
        speechSynthesizerDidFinishSpeaking?(_: NSSpeechSynthesizer, didFinishSpeaking: boolean): void;
        speechSynthesizerWillSpeakPhoneme?(_: NSSpeechSynthesizer, willSpeakPhoneme: number): void;
    }
    class NSSpellChecker extends NSObject {
        static uniqueSpellDocumentTag(): number;
        accessoryView: NSView;
        setAccessoryView(_: NSView): any;
        automaticallyIdentifiesLanguages: boolean;
        setAutomaticallyIdentifiesLanguages(_: boolean): any;
        availableLanguages: string[];
        spellingPanel: NSPanel;
        substitutionsPanel: NSPanel;
        substitutionsPanelAccessoryViewController: NSViewController;
        setSubstitutionsPanelAccessoryViewController(_: NSViewController): any;
        userPreferredLanguages: string[];
        userReplacementsDictionary: Map<string, string>;
        static isAutomaticCapitalizationEnabled: boolean;
        static isAutomaticDashSubstitutionEnabled: boolean;
        static isAutomaticPeriodSubstitutionEnabled: boolean;
        static isAutomaticQuoteSubstitutionEnabled: boolean;
        static isAutomaticSpellingCorrectionEnabled: boolean;
        static isAutomaticTextCompletionEnabled: boolean;
        static isAutomaticTextReplacementEnabled: boolean;
        static sharedSpellChecker: NSSpellChecker;
        static sharedSpellCheckerExists: boolean;
        checkGrammarOfStringStartingAtLanguageWrapInSpellDocumentWithTagDetails(of: string, startingAt: number, language?: string, wrap?: boolean, inSpellDocumentWithTag?: number, details?: Map<string, any>[]): NSRange;
        checkSpellingOfStringStartingAt(of: string, startingAt: number): NSRange;
        checkSpellingOfStringStartingAtLanguageWrapInSpellDocumentWithTagWordCount(of: string, startingAt: number, language?: string, wrap?: boolean, inSpellDocumentWithTag?: number, wordCount?: number): NSRange;
        checkStringRangeTypesOptionsInSpellDocumentWithTagOrthographyWordCount(_: string, range: NSRange, types: number, options?: Map<string, any>, inSpellDocumentWithTag?: number, orthography?: NSOrthography, wordCount?: number): NSTextCheckingResult[];
        closeSpellDocumentWithTag(withTag: number): void;
        completionsForPartialWordRangeInStringLanguageInSpellDocumentWithTag(forPartialWordRange: NSRange, in_: string, language?: string, inSpellDocumentWithTag?: number): string[];
        correctionForWordRangeInStringLanguageInSpellDocumentWithTag(forWordRange: NSRange, in_: string, language: string, inSpellDocumentWithTag: number): string;
        countWordsInStringLanguage(in_: string, language?: string): number;
        deletesAutospaceBetweenStringAndStringLanguage(_: string, andString: string, language?: string): boolean;
        dismissCorrectionIndicatorForView(for_: NSView): void;
        guessesForWordRangeInStringLanguageInSpellDocumentWithTag(forWordRange: NSRange, in_: string, language?: string, inSpellDocumentWithTag?: number): string[];
        hasLearnedWord(_: string): boolean;
        ignoreWordInSpellDocumentWithTag(_: string, inSpellDocumentWithTag: number): void;
        ignoredWordsInSpellDocumentWithTag(inSpellDocumentWithTag: number): string[];
        language(): string;
        languageForWordRangeInStringOrthography(forWordRange: NSRange, in_: string, orthography?: NSOrthography): string;
        learnWord(_: string): void;
        menuForResultStringOptionsAtLocationInView(for_: NSTextCheckingResult, string: string, options?: Map<string, any>, atLocation?: CGPoint, in_?: NSView): NSMenu;
        preventsAutocorrectionBeforeStringLanguage(before: string, language?: string): boolean;
        recordResponseToCorrectionForWordLanguageInSpellDocumentWithTag(_: NSSpellChecker.CorrectionResponse, toCorrection: string, forWord: string, language?: string, inSpellDocumentWithTag?: number): void;
        requestCandidatesWithForSelectedRangeInTypesOptionsInSpellDocumentWithTagCompletionHandler(forSelectedRange: NSRange, in_: string, types: number, options?: Map<string, any>, inSpellDocumentWithTag?: number, completionHandler?: (p1: number, p2: NSTextCheckingResult[]) => void): number;
        requestCheckingOfRangeTypesOptionsInSpellDocumentWithTagCompletionHandler(of: string, range: NSRange, types: number, options?: Map<string, any>, inSpellDocumentWithTag?: number, completionHandler?: (p1: number, p2: NSTextCheckingResult[], p3: NSOrthography, p4: number) => void): number;
        setIgnoredWordsInSpellDocumentWithTag(_: string[], inSpellDocumentWithTag: number): void;
        setLanguage(_: string): boolean;
        setWordFieldStringValue(_: string): void;
        showCorrectionIndicatorOfPrimaryStringAlternativeStringsForStringInViewCompletionHandler(of: NSSpellChecker.CorrectionIndicatorType, primaryString: string, alternativeStrings: string[], forStringIn: CGRect, view: NSView, completionHandler?: (p1: string) => void): void;
        unlearnWord(_: string): void;
        updatePanels(): void;
        updateSpellingPanelWithGrammarStringDetail(withGrammarString: string, detail: Map<string, any>): void;
        updateSpellingPanelWithMisspelledWord(withMisspelledWord: string): void;
        userQuotesArrayForLanguage(forLanguage: string): string[];
    }
    class NSSplitView extends NSView {
        arrangedSubviews: NSView[];
        arrangesAllSubviews: boolean;
        setArrangesAllSubviews(_: boolean): any;
        autosaveName: string;
        setAutosaveName(_: string): any;
        delegate: NSSplitViewDelegate;
        setDelegate(_: NSSplitViewDelegate): any;
        dividerColor: NSColor;
        dividerStyle: NSSplitView.DividerStyle;
        setDividerStyle(_: NSSplitView.DividerStyle): any;
        dividerThickness: number;
        isVertical: boolean;
        setVertical(_: boolean): any;
        addArrangedSubview(_: NSView): void;
        adjustSubviews(): void;
        drawDividerInRect(in_: CGRect): void;
        holdingPriorityForSubviewAtIndex(at: number): number;
        insertArrangedSubviewAtIndex(_: NSView, at: number): void;
        isSubviewCollapsed(_: NSView): boolean;
        maxPossiblePositionOfDividerAtIndex(at: number): number;
        minPossiblePositionOfDividerAtIndex(at: number): number;
        removeArrangedSubview(_: NSView): void;
        setHoldingPriorityForSubviewAtIndex(_: number, forSubviewAt: number): void;
        setPositionOfDividerAtIndex(_: number, ofDividerAt: number): void;
    }
    class NSSplitViewController extends NSViewController {
        minimumThicknessForInlineSidebars: number;
        setMinimumThicknessForInlineSidebars(_: number): any;
        splitView: NSSplitView;
        setSplitView(_: NSSplitView): any;
        splitViewItems: NSSplitViewItem[];
        setSplitViewItems(_: NSSplitViewItem[]): any;
        addSplitViewItem(_: NSSplitViewItem): void;
        insertSplitViewItemAtIndex(_: NSSplitViewItem, at: number): void;
        removeSplitViewItem(_: NSSplitViewItem): void;
        splitViewItemForViewController(for_: NSViewController): NSSplitViewItem;
        toggleSidebar(_?: any): void;
    }
    interface NSSplitViewDelegate extends NSObject {
        splitViewShouldHideDividerAtIndex?(_: NSSplitView, shouldHideDividerAt: number): boolean;
        splitViewEffectiveRectForDrawnRectOfDividerAtIndex?(_: NSSplitView, effectiveRect: CGRect, forDrawnRect: CGRect, ofDividerAt: number): CGRect;
        splitViewAdditionalEffectiveRectOfDividerAtIndex?(_: NSSplitView, additionalEffectiveRectOfDividerAt: number): CGRect;
        splitViewCanCollapseSubview?(_: NSSplitView, canCollapseSubview: NSView): boolean;
        splitViewConstrainMaxCoordinateOfSubviewAt?(_: NSSplitView, constrainMaxCoordinate: number, ofSubviewAt: number): number;
        splitViewConstrainMinCoordinateOfSubviewAt?(_: NSSplitView, constrainMinCoordinate: number, ofSubviewAt: number): number;
        splitViewConstrainSplitPositionOfSubviewAt?(_: NSSplitView, constrainSplitPosition: number, ofSubviewAt: number): number;
        splitViewResizeSubviewsWithOldSize?(_: NSSplitView, resizeSubviewsWithOldSize: CGSize): void;
        splitViewShouldAdjustSizeOfSubview?(_: NSSplitView, shouldAdjustSizeOfSubview: NSView): boolean;
        splitViewDidResizeSubviews?(_: NSNotification): void;
        splitViewWillResizeSubviews?(_: NSNotification): void;
    }
    class NSSplitViewItem extends NSObject {
        static contentListWithViewController(contentListWithViewController: NSViewController): NSSplitViewItem;
        static sidebarWithViewController(sidebarWithViewController: NSViewController): NSSplitViewItem;
        automaticMaximumThickness: number;
        setAutomaticMaximumThickness(_: number): any;
        behavior: NSSplitViewItem.Behavior;
        canCollapse: boolean;
        setCanCollapse(_: boolean): any;
        collapseBehavior: NSSplitViewItem.CollapseBehavior;
        setCollapseBehavior(_: NSSplitViewItem.CollapseBehavior): any;
        isCollapsed: boolean;
        setCollapsed(_: boolean): any;
        holdingPriority: number;
        setHoldingPriority(_: number): any;
        maximumThickness: number;
        setMaximumThickness(_: number): any;
        minimumThickness: number;
        setMinimumThickness(_: number): any;
        preferredThicknessFraction: number;
        setPreferredThicknessFraction(_: number): any;
        isSpringLoaded: boolean;
        setSpringLoaded(_: boolean): any;
        viewController: NSViewController;
        setViewController(_: NSViewController): any;
    }
    interface NSSpringLoadingDestination extends NSObject {
        draggingEnded?(_: NSDraggingInfo): void;
        springLoadingActivatedDraggingInfo(_: boolean, draggingInfo: NSDraggingInfo): void;
        springLoadingEntered?(_: NSDraggingInfo): NSSpringLoadingOptions;
        springLoadingExited?(_: NSDraggingInfo): void;
        springLoadingHighlightChanged(_: NSDraggingInfo): void;
        springLoadingUpdated?(_: NSDraggingInfo): NSSpringLoadingOptions;
    }
    class NSStackView extends NSView {
        alignment: NSLayoutConstraint.Attribute;
        setAlignment(_: NSLayoutConstraint.Attribute): any;
        arrangedSubviews: NSView[];
        delegate: NSStackViewDelegate;
        setDelegate(_: NSStackViewDelegate): any;
        detachedViews: NSView[];
        detachesHiddenViews: boolean;
        setDetachesHiddenViews(_: boolean): any;
        distribution: NSStackView.Distribution;
        setDistribution(_: NSStackView.Distribution): any;
        edgeInsets: NSEdgeInsets;
        setEdgeInsets(_: NSEdgeInsets): any;
        orientation: NSUserInterfaceLayoutOrientation;
        setOrientation(_: NSUserInterfaceLayoutOrientation): any;
        spacing: number;
        setSpacing(_: number): any;
        views: NSView[];
        addArrangedSubview(_: NSView): void;
        addViewInGravity(_: NSView, in_: NSStackView.Gravity): void;
        clippingResistancePriorityForOrientation(for_: NSLayoutConstraint.Orientation): number;
        customSpacingAfterView(after: NSView): number;
        huggingPriorityForOrientation(for_: NSLayoutConstraint.Orientation): number;
        insertArrangedSubviewAtIndex(_: NSView, at: number): void;
        insertViewAtIndexInGravity(_: NSView, at: number, in_: NSStackView.Gravity): void;
        removeArrangedSubview(_: NSView): void;
        removeView(_: NSView): void;
        setClippingResistancePriorityForOrientation(_: number, for_: NSLayoutConstraint.Orientation): void;
        setCustomSpacingAfterView(_: number, after: NSView): void;
        setHuggingPriorityForOrientation(_: number, for_: NSLayoutConstraint.Orientation): void;
        setViewsInGravity(_: NSView[], in_: NSStackView.Gravity): void;
        setVisibilityPriorityForView(_: number, for_: NSView): void;
        viewsInGravity(in_: NSStackView.Gravity): NSView[];
        visibilityPriorityForView(for_: NSView): number;
    }
    interface NSStackViewDelegate extends NSObject {
        stackViewWillDetachViews?(_: NSStackView, willDetach: NSView[]): void;
        stackViewDidReattachViews?(_: NSStackView, didReattach: NSView[]): void;
    }
    interface NSStandardKeyBindingResponding extends NSObject {
        cancelOperation?(_?: any): void;
        capitalizeWord?(_?: any): void;
        centerSelectionInVisibleArea?(_?: any): void;
        changeCaseOfLetter?(_?: any): void;
        complete?(_?: any): void;
        deleteBackward?(_?: any): void;
        deleteBackwardByDecomposingPreviousCharacter?(_?: any): void;
        deleteForward?(_?: any): void;
        deleteToBeginningOfLine?(_?: any): void;
        deleteToBeginningOfParagraph?(_?: any): void;
        deleteToEndOfLine?(_?: any): void;
        deleteToEndOfParagraph?(_?: any): void;
        deleteToMark?(_?: any): void;
        deleteWordBackward?(_?: any): void;
        deleteWordForward?(_?: any): void;
        doCommandBySelector?(by: string): void;
        indent?(_?: any): void;
        insertBacktab?(_?: any): void;
        insertContainerBreak?(_?: any): void;
        insertDoubleQuoteIgnoringSubstitution?(_?: any): void;
        insertLineBreak?(_?: any): void;
        insertNewline?(_?: any): void;
        insertNewlineIgnoringFieldEditor?(_?: any): void;
        insertParagraphSeparator?(_?: any): void;
        insertSingleQuoteIgnoringSubstitution?(_?: any): void;
        insertTab?(_?: any): void;
        insertTabIgnoringFieldEditor?(_?: any): void;
        insertText?(_: any): void;
        lowercaseWord?(_?: any): void;
        makeBaseWritingDirectionLeftToRight?(_?: any): void;
        makeBaseWritingDirectionNatural?(_?: any): void;
        makeBaseWritingDirectionRightToLeft?(_?: any): void;
        makeTextWritingDirectionLeftToRight?(_?: any): void;
        makeTextWritingDirectionNatural?(_?: any): void;
        makeTextWritingDirectionRightToLeft?(_?: any): void;
        moveBackward?(_?: any): void;
        moveBackwardAndModifySelection?(_?: any): void;
        moveDown?(_?: any): void;
        moveDownAndModifySelection?(_?: any): void;
        moveForward?(_?: any): void;
        moveForwardAndModifySelection?(_?: any): void;
        moveLeft?(_?: any): void;
        moveLeftAndModifySelection?(_?: any): void;
        moveParagraphBackwardAndModifySelection?(_?: any): void;
        moveParagraphForwardAndModifySelection?(_?: any): void;
        moveRight?(_?: any): void;
        moveRightAndModifySelection?(_?: any): void;
        moveToBeginningOfDocument?(_?: any): void;
        moveToBeginningOfDocumentAndModifySelection?(_?: any): void;
        moveToBeginningOfLine?(_?: any): void;
        moveToBeginningOfLineAndModifySelection?(_?: any): void;
        moveToBeginningOfParagraph?(_?: any): void;
        moveToBeginningOfParagraphAndModifySelection?(_?: any): void;
        moveToEndOfDocument?(_?: any): void;
        moveToEndOfDocumentAndModifySelection?(_?: any): void;
        moveToEndOfLine?(_?: any): void;
        moveToEndOfLineAndModifySelection?(_?: any): void;
        moveToEndOfParagraph?(_?: any): void;
        moveToEndOfParagraphAndModifySelection?(_?: any): void;
        moveToLeftEndOfLine?(_?: any): void;
        moveToLeftEndOfLineAndModifySelection?(_?: any): void;
        moveToRightEndOfLine?(_?: any): void;
        moveToRightEndOfLineAndModifySelection?(_?: any): void;
        moveUp?(_?: any): void;
        moveUpAndModifySelection?(_?: any): void;
        moveWordBackward?(_?: any): void;
        moveWordBackwardAndModifySelection?(_?: any): void;
        moveWordForward?(_?: any): void;
        moveWordForwardAndModifySelection?(_?: any): void;
        moveWordLeft?(_?: any): void;
        moveWordLeftAndModifySelection?(_?: any): void;
        moveWordRight?(_?: any): void;
        moveWordRightAndModifySelection?(_?: any): void;
        pageDown?(_?: any): void;
        pageDownAndModifySelection?(_?: any): void;
        pageUp?(_?: any): void;
        pageUpAndModifySelection?(_?: any): void;
        quickLookPreviewItems?(_?: any): void;
        scrollLineDown?(_?: any): void;
        scrollLineUp?(_?: any): void;
        scrollPageDown?(_?: any): void;
        scrollPageUp?(_?: any): void;
        scrollToBeginningOfDocument?(_?: any): void;
        scrollToEndOfDocument?(_?: any): void;
        selectAll?(_?: any): void;
        selectLine?(_?: any): void;
        selectParagraph?(_?: any): void;
        selectToMark?(_?: any): void;
        selectWord?(_?: any): void;
        setMark?(_?: any): void;
        swapWithMark?(_?: any): void;
        transpose?(_?: any): void;
        transposeWords?(_?: any): void;
        uppercaseWord?(_?: any): void;
        yank?(_?: any): void;
    }
    class NSStatusBar extends NSObject {
        thickness: number;
        isVertical: boolean;
        static systemStatusBar: NSStatusBar;
        removeStatusItem(_: NSStatusItem): void;
        statusItemWithLength(withLength: number): NSStatusItem;
    }
    class NSStatusBarButton extends NSButton {
        appearsDisabled: boolean;
        setAppearsDisabled(_: boolean): any;
    }
    class NSStatusItem extends NSObject {
        autosaveName: string;
        setAutosaveName(_: string): any;
        behavior: NSStatusItem.Behavior;
        setBehavior(_: NSStatusItem.Behavior): any;
        button: NSStatusBarButton;
        length: number;
        setLength(_: number): any;
        menu: NSMenu;
        setMenu(_: NSMenu): any;
        statusBar: NSStatusBar;
        isVisible: boolean;
        setVisible(_: boolean): any;
    }
    class NSStepper extends NSControl {
        autorepeat: boolean;
        setAutorepeat(_: boolean): any;
        increment: number;
        setIncrement(_: number): any;
        maxValue: number;
        setMaxValue(_: number): any;
        minValue: number;
        setMinValue(_: number): any;
        valueWraps: boolean;
        setValueWraps(_: boolean): any;
    }
    class NSStepperCell extends NSActionCell {
        autorepeat: boolean;
        setAutorepeat(_: boolean): any;
        increment: number;
        setIncrement(_: number): any;
        maxValue: number;
        setMaxValue(_: number): any;
        minValue: number;
        setMinValue(_: number): any;
        valueWraps: boolean;
        setValueWraps(_: boolean): any;
    }
    class NSStepperTouchBarItem extends NSTouchBarItem {
        action: string;
        setAction(_: string): any;
        increment: number;
        setIncrement(_: number): any;
        maxValue: number;
        setMaxValue(_: number): any;
        minValue: number;
        setMinValue(_: number): any;
        target: any;
        setTarget(_: any): any;
        value: number;
        setValue(_: number): any;
    }
    class NSStoryboard extends NSObject {
        static mainStoryboard: NSStoryboard;
        instantiateControllerWithIdentifier(withIdentifier: string): any;
        instantiateControllerWithIdentifierWithCreator(_: string, creator?: (p1: NSCoder) => any): any;
        instantiateInitialController(): any;
        instantiateInitialControllerWithCreator(_?: (p1: NSCoder) => any): any;
    }
    class NSStoryboardSegue extends NSObject {
        destinationController: any;
        identifier: string;
        sourceController: any;
        static createWithIdentifierSourceDestination(identifier: string, source: any, destination: any): NSStoryboardSegue;
        perform(): void;
    }
    class NSStringDrawingContext extends NSObject {
        actualScaleFactor: number;
        minimumScaleFactor: number;
        setMinimumScaleFactor(_: number): any;
        totalBounds: CGRect;
    }
    class NSSwitch extends NSControl {
        state: number;
        setState(_: number): any;
    }
    class NSTabView extends NSView {
        allowsTruncatedLabels: boolean;
        setAllowsTruncatedLabels(_: boolean): any;
        contentRect: CGRect;
        controlSize: NSControl.ControlSize;
        setControlSize(_: NSControl.ControlSize): any;
        delegate: NSTabViewDelegate;
        setDelegate(_: NSTabViewDelegate): any;
        drawsBackground: boolean;
        setDrawsBackground(_: boolean): any;
        font: NSFont;
        setFont(_: NSFont): any;
        minimumSize: CGSize;
        numberOfTabViewItems: number;
        selectedTabViewItem: NSTabViewItem;
        tabPosition: NSTabView.TabPosition;
        setTabPosition(_: NSTabView.TabPosition): any;
        tabViewBorderType: NSTabView.TabViewBorderType;
        setTabViewBorderType(_: NSTabView.TabViewBorderType): any;
        tabViewItems: NSTabViewItem[];
        setTabViewItems(_: NSTabViewItem[]): any;
        tabViewType: NSTabView.TabType;
        setTabViewType(_: NSTabView.TabType): any;
        addTabViewItem(_: NSTabViewItem): void;
        indexOfTabViewItem(_: NSTabViewItem): number;
        indexOfTabViewItemWithIdentifier(withIdentifier: any): number;
        insertTabViewItemAtIndex(_: NSTabViewItem, at: number): void;
        removeTabViewItem(_: NSTabViewItem): void;
        selectFirstTabViewItem(_?: any): void;
        selectLastTabViewItem(_?: any): void;
        selectNextTabViewItem(_?: any): void;
        selectPreviousTabViewItem(_?: any): void;
        selectTabViewItem(_?: NSTabViewItem): void;
        selectTabViewItemAtIndex(at: number): void;
        selectTabViewItemWithIdentifier(withIdentifier: any): void;
        tabViewItemAtIndex(at: number): NSTabViewItem;
        tabViewItemAtPoint(at: CGPoint): NSTabViewItem;
        takeSelectedTabViewItemFromSender(_?: any): void;
    }
    class NSTabViewController extends NSViewController {
        canPropagateSelectedChildViewControllerTitle: boolean;
        setCanPropagateSelectedChildViewControllerTitle(_: boolean): any;
        selectedTabViewItemIndex: number;
        setSelectedTabViewItemIndex(_: number): any;
        tabStyle: NSTabViewController.TabStyle;
        setTabStyle(_: NSTabViewController.TabStyle): any;
        tabView: NSTabView;
        setTabView(_: NSTabView): any;
        tabViewItems: NSTabViewItem[];
        setTabViewItems(_: NSTabViewItem[]): any;
        transitionOptions: NSViewController.TransitionOptions;
        setTransitionOptions(_: NSViewController.TransitionOptions): any;
        addTabViewItem(_: NSTabViewItem): void;
        insertTabViewItemAtIndex(_: NSTabViewItem, at: number): void;
        removeTabViewItem(_: NSTabViewItem): void;
        tabViewItemForViewController(for_: NSViewController): NSTabViewItem;
    }
    interface NSTabViewDelegate extends NSObject {
        tabViewShouldSelectTabViewItem?(_: NSTabView, shouldSelect?: NSTabViewItem): boolean;
        tabViewWillSelectTabViewItem?(_: NSTabView, willSelect?: NSTabViewItem): void;
        tabViewDidSelectTabViewItem?(_: NSTabView, didSelect?: NSTabViewItem): void;
        tabViewDidChangeNumberOfTabViewItems?(_: NSTabView): void;
    }
    class NSTabViewItem extends NSObject {
        color: NSColor;
        setColor(_: NSColor): any;
        identifier: any;
        setIdentifier(_: any): any;
        image: NSImage;
        setImage(_: NSImage): any;
        initialFirstResponder: NSView;
        setInitialFirstResponder(_: NSView): any;
        label: string;
        setLabel(_: string): any;
        tabState: NSTabViewItem.State;
        tabView: NSTabView;
        toolTip: string;
        setToolTip(_: string): any;
        view: NSView;
        setView(_: NSView): any;
        viewController: NSViewController;
        setViewController(_: NSViewController): any;
        drawLabelInRect(_: boolean, in_: CGRect): void;
        static createWithIdentifier(identifier?: any): NSTabViewItem;
        sizeOfLabel(_: boolean): CGSize;
    }
    class NSTableCellView extends NSView {
        backgroundStyle: NSView.BackgroundStyle;
        setBackgroundStyle(_: NSView.BackgroundStyle): any;
        draggingImageComponents: NSDraggingImageComponent[];
        imageView: NSImageView;
        setImageView(_: NSImageView): any;
        objectValue: any;
        setObjectValue(_: any): any;
        rowSizeStyle: NSTableView.RowSizeStyle;
        setRowSizeStyle(_: NSTableView.RowSizeStyle): any;
        textField: NSTextField;
        setTextField(_: NSTextField): any;
    }
    class NSTableColumn extends NSObject {
        dataCell: any;
        setDataCell(_: any): any;
        isEditable: boolean;
        setEditable(_: boolean): any;
        headerCell: NSTableHeaderCell;
        setHeaderCell(_: NSTableHeaderCell): any;
        headerToolTip: string;
        setHeaderToolTip(_: string): any;
        isHidden: boolean;
        setHidden(_: boolean): any;
        maxWidth: number;
        setMaxWidth(_: number): any;
        minWidth: number;
        setMinWidth(_: number): any;
        resizingMask: NSTableColumn.ResizingOptions;
        setResizingMask(_: NSTableColumn.ResizingOptions): any;
        sortDescriptorPrototype: NSSortDescriptor;
        setSortDescriptorPrototype(_: NSSortDescriptor): any;
        tableView: NSTableView;
        setTableView(_: NSTableView): any;
        title: string;
        setTitle(_: string): any;
        width: number;
        setWidth(_: number): any;
        dataCellForRow(forRow: number): any;
        static createWithIdentifier(identifier: string): NSTableColumn;
        sizeToFit(): void;
    }
    class NSTableHeaderCell extends NSTextFieldCell {
        drawSortIndicatorWithFrameInViewAscendingPriority(withFrame: CGRect, in_: NSView, ascending: boolean, priority: number): void;
        sortIndicatorRectForBounds(forBounds: CGRect): CGRect;
    }
    class NSTableHeaderView extends NSView {
        draggedColumn: number;
        draggedDistance: number;
        resizedColumn: number;
        tableView: NSTableView;
        setTableView(_: NSTableView): any;
        columnAtPoint(at: CGPoint): number;
        headerRectOfColumn(ofColumn: number): CGRect;
    }
    class NSTableRowView extends NSView {
        backgroundColor: NSColor;
        setBackgroundColor(_: NSColor): any;
        draggingDestinationFeedbackStyle: NSTableView.DraggingDestinationFeedbackStyle;
        setDraggingDestinationFeedbackStyle(_: NSTableView.DraggingDestinationFeedbackStyle): any;
        isEmphasized: boolean;
        setEmphasized(_: boolean): any;
        isFloating: boolean;
        setFloating(_: boolean): any;
        isGroupRowStyle: boolean;
        setGroupRowStyle(_: boolean): any;
        indentationForDropOperation: number;
        setIndentationForDropOperation(_: number): any;
        interiorBackgroundStyle: NSView.BackgroundStyle;
        isNextRowSelected: boolean;
        setNextRowSelected(_: boolean): any;
        numberOfColumns: number;
        isPreviousRowSelected: boolean;
        setPreviousRowSelected(_: boolean): any;
        isSelected: boolean;
        setSelected(_: boolean): any;
        selectionHighlightStyle: NSTableView.SelectionHighlightStyle;
        setSelectionHighlightStyle(_: NSTableView.SelectionHighlightStyle): any;
        isTargetForDropOperation: boolean;
        setTargetForDropOperation(_: boolean): any;
        drawBackgroundInRect(in_: CGRect): void;
        drawDraggingDestinationFeedbackInRect(in_: CGRect): void;
        drawSelectionInRect(in_: CGRect): void;
        drawSeparatorInRect(in_: CGRect): void;
        viewAtColumn(atColumn: number): any;
    }
    class NSTableView extends NSControl {
        allowsColumnReordering: boolean;
        setAllowsColumnReordering(_: boolean): any;
        allowsColumnResizing: boolean;
        setAllowsColumnResizing(_: boolean): any;
        allowsColumnSelection: boolean;
        setAllowsColumnSelection(_: boolean): any;
        allowsEmptySelection: boolean;
        setAllowsEmptySelection(_: boolean): any;
        allowsMultipleSelection: boolean;
        setAllowsMultipleSelection(_: boolean): any;
        allowsTypeSelect: boolean;
        setAllowsTypeSelect(_: boolean): any;
        autosaveName: string;
        setAutosaveName(_: string): any;
        autosaveTableColumns: boolean;
        setAutosaveTableColumns(_: boolean): any;
        backgroundColor: NSColor;
        setBackgroundColor(_: NSColor): any;
        clickedColumn: number;
        clickedRow: number;
        columnAutoresizingStyle: NSTableView.ColumnAutoresizingStyle;
        setColumnAutoresizingStyle(_: NSTableView.ColumnAutoresizingStyle): any;
        cornerView: NSView;
        setCornerView(_: NSView): any;
        dataSource: NSTableViewDataSource;
        setDataSource(_: NSTableViewDataSource): any;
        delegate: NSTableViewDelegate;
        setDelegate(_: NSTableViewDelegate): any;
        doubleAction: string;
        setDoubleAction(_: string): any;
        draggingDestinationFeedbackStyle: NSTableView.DraggingDestinationFeedbackStyle;
        setDraggingDestinationFeedbackStyle(_: NSTableView.DraggingDestinationFeedbackStyle): any;
        editedColumn: number;
        editedRow: number;
        effectiveRowSizeStyle: NSTableView.RowSizeStyle;
        floatsGroupRows: boolean;
        setFloatsGroupRows(_: boolean): any;
        gridColor: NSColor;
        setGridColor(_: NSColor): any;
        gridStyleMask: NSTableView.GridLineStyle;
        setGridStyleMask(_: NSTableView.GridLineStyle): any;
        headerView: NSTableHeaderView;
        setHeaderView(_: NSTableHeaderView): any;
        hiddenRowIndexes: NSIndexSet;
        highlightedTableColumn: NSTableColumn;
        setHighlightedTableColumn(_: NSTableColumn): any;
        intercellSpacing: CGSize;
        setIntercellSpacing(_: CGSize): any;
        numberOfColumns: number;
        numberOfRows: number;
        numberOfSelectedColumns: number;
        numberOfSelectedRows: number;
        registeredNibsByIdentifier: Map<string, NSNib>;
        rowActionsVisible: boolean;
        setRowActionsVisible(_: boolean): any;
        rowHeight: number;
        setRowHeight(_: number): any;
        rowSizeStyle: NSTableView.RowSizeStyle;
        setRowSizeStyle(_: NSTableView.RowSizeStyle): any;
        selectedColumn: number;
        selectedColumnIndexes: NSIndexSet;
        selectedRow: number;
        selectedRowIndexes: NSIndexSet;
        selectionHighlightStyle: NSTableView.SelectionHighlightStyle;
        setSelectionHighlightStyle(_: NSTableView.SelectionHighlightStyle): any;
        sortDescriptors: NSSortDescriptor[];
        setSortDescriptors(_: NSSortDescriptor[]): any;
        tableColumns: NSTableColumn[];
        usesAlternatingRowBackgroundColors: boolean;
        setUsesAlternatingRowBackgroundColors(_: boolean): any;
        usesAutomaticRowHeights: boolean;
        setUsesAutomaticRowHeights(_: boolean): any;
        usesStaticContents: boolean;
        setUsesStaticContents(_: boolean): any;
        verticalMotionCanBeginDrag: boolean;
        setVerticalMotionCanBeginDrag(_: boolean): any;
        addTableColumn(_: NSTableColumn): void;
        beginUpdates(): void;
        canDragRowsWithIndexesAtPoint(with_: NSIndexSet, at: CGPoint): boolean;
        columnAtPoint(at: CGPoint): number;
        columnForView(for_: NSView): number;
        columnIndexesInRect(in_: CGRect): NSIndexSet;
        columnWithIdentifier(withIdentifier: string): number;
        deselectAll(_?: any): void;
        deselectColumn(_: number): void;
        deselectRow(_: number): void;
        didAddRowViewForRow(_: NSTableRowView, forRow: number): void;
        didRemoveRowViewForRow(_: NSTableRowView, forRow: number): void;
        dragImageForRowsWithIndexesTableColumnsEventOffset(with_: NSIndexSet, tableColumns: NSTableColumn[], event: NSEvent, offset: NSPoint): NSImage;
        drawBackgroundInClipRect(inClipRect: CGRect): void;
        drawGridInClipRect(inClipRect: CGRect): void;
        drawRowClipRect(_: number, clipRect: CGRect): void;
        editColumnRowWithEventSelect(_: number, row: number, with_?: NSEvent, select?: boolean): void;
        endUpdates(): void;
        enumerateAvailableRowViews(_: (p1: NSTableRowView, p2: number) => void): void;
        frameOfCellAtColumnRow(atColumn: number, row: number): CGRect;
        hideRowsAtIndexesWithAnimation(at: NSIndexSet, withAnimation: NSTableView.AnimationOptions): void;
        highlightSelectionInClipRect(inClipRect: CGRect): void;
        indicatorImageInTableColumn(in_: NSTableColumn): NSImage;
        insertRowsAtIndexesWithAnimation(at: NSIndexSet, withAnimation: NSTableView.AnimationOptions): void;
        isColumnSelected(_: number): boolean;
        isRowSelected(_: number): boolean;
        makeViewWithIdentifierOwner(withIdentifier: string, owner?: any): NSView;
        moveColumnToColumn(_: number, toColumn: number): void;
        moveRowAtIndexToIndex(at: number, to: number): void;
        noteHeightOfRowsWithIndexesChanged(withIndexesChanged: NSIndexSet): void;
        noteNumberOfRowsChanged(): void;
        rectOfColumn(ofColumn: number): CGRect;
        rectOfRow(ofRow: number): CGRect;
        registerNibForIdentifier(_?: NSNib, forIdentifier?: string): void;
        reloadData(): void;
        reloadDataForRowIndexesColumnIndexes(forRowIndexes: NSIndexSet, columnIndexes: NSIndexSet): void;
        removeRowsAtIndexesWithAnimation(at: NSIndexSet, withAnimation: NSTableView.AnimationOptions): void;
        removeTableColumn(_: NSTableColumn): void;
        rowAtPoint(at: CGPoint): number;
        rowForView(for_: NSView): number;
        rowViewAtRowMakeIfNecessary(atRow: number, makeIfNecessary: boolean): NSTableRowView;
        rowsInRect(in_: CGRect): NSRange;
        scrollColumnToVisible(_: number): void;
        scrollRowToVisible(_: number): void;
        selectColumnIndexesByExtendingSelection(_: NSIndexSet, byExtendingSelection: boolean): void;
        selectRowIndexesByExtendingSelection(_: NSIndexSet, byExtendingSelection: boolean): void;
        setDraggingSourceOperationMaskForLocal(_: NSDragOperation, forLocal: boolean): void;
        setDropRowDropOperation(_: number, dropOperation: NSTableView.DropOperation): void;
        setIndicatorImageInTableColumn(_?: NSImage, in_?: NSTableColumn): void;
        sizeLastColumnToFit(): void;
        tableColumnWithIdentifier(withIdentifier: string): NSTableColumn;
        tile(): void;
        unhideRowsAtIndexesWithAnimation(at: NSIndexSet, withAnimation: NSTableView.AnimationOptions): void;
        viewAtColumnRowMakeIfNecessary(atColumn: number, row: number, makeIfNecessary: boolean): NSView;
    }
    interface NSTableViewDataSource extends NSObject {
        numberOfRowsInTableView?(in_: NSTableView): number;
        tableViewObjectValueForTableColumnRow?(_: NSTableView, objectValueFor?: NSTableColumn, row?: number): any;
        tableViewSetObjectValueForTableColumnRow?(_: NSTableView, setObjectValue?: any, for_?: NSTableColumn, row?: number): void;
        tableViewDraggingSessionWillBeginAtPointForRowIndexes?(_: NSTableView, draggingSession: NSDraggingSession, willBeginAt: CGPoint, forRowIndexes: NSIndexSet): void;
        tableViewDraggingSessionEndedAtPointOperation?(_: NSTableView, draggingSession: NSDraggingSession, endedAt: CGPoint, operation: NSDragOperation): void;
        tableViewWriteRowsWithIndexesToPasteboard?(_: NSTableView, writeRowsWith: NSIndexSet, to: NSPasteboard): boolean;
        tableViewAcceptDropRowDropOperation?(_: NSTableView, acceptDrop: NSDraggingInfo, row: number, dropOperation: NSTableView.DropOperation): boolean;
        tableViewPasteboardWriterForRow?(_: NSTableView, pasteboardWriterForRow: number): NSPasteboardWriting;
        tableViewSortDescriptorsDidChange?(_: NSTableView, sortDescriptorsDidChange: NSSortDescriptor[]): void;
        tableViewUpdateDraggingItemsForDrag?(_: NSTableView, updateDraggingItemsForDrag: NSDraggingInfo): void;
        tableViewValidateDropProposedRowProposedDropOperation?(_: NSTableView, validateDrop: NSDraggingInfo, proposedRow: number, proposedDropOperation: NSTableView.DropOperation): NSDragOperation;
    }
    interface NSTableViewDelegate extends NSControlTextEditingDelegate {
        selectionShouldChangeInTableView?(in_: NSTableView): boolean;
        tableViewViewForTableColumnRow?(_: NSTableView, viewFor?: NSTableColumn, row?: number): NSView;
        tableViewDidAddRowViewForRow?(_: NSTableView, didAdd: NSTableRowView, forRow: number): void;
        tableViewDidRemoveRowViewForRow?(_: NSTableView, didRemove: NSTableRowView, forRow: number): void;
        tableViewWillDisplayCellForTableColumnRow?(_: NSTableView, willDisplayCell: any, for_?: NSTableColumn, row?: number): void;
        tableViewShouldEditTableColumnRow?(_: NSTableView, shouldEdit?: NSTableColumn, row?: number): boolean;
        tableViewToolTipForCellRectTableColumnRowMouseLocation?(_: NSTableView, toolTipFor: NSCell, rect: NSRect, tableColumn?: NSTableColumn, row?: number, mouseLocation?: CGPoint): string;
        tableViewShouldShowCellExpansionForTableColumnRow?(_: NSTableView, shouldShowCellExpansionFor?: NSTableColumn, row?: number): boolean;
        tableViewShouldTrackCellForTableColumnRow?(_: NSTableView, shouldTrackCell: NSCell, for_?: NSTableColumn, row?: number): boolean;
        tableViewDataCellForTableColumnRow?(_: NSTableView, dataCellFor?: NSTableColumn, row?: number): NSCell;
        tableViewShouldSelectTableColumn?(_: NSTableView, shouldSelect?: NSTableColumn): boolean;
        tableViewMouseDownInHeaderOfTableColumn?(_: NSTableView, mouseDownInHeaderOf: NSTableColumn): void;
        tableViewDidClickTableColumn?(_: NSTableView, didClick: NSTableColumn): void;
        tableViewDidDragTableColumn?(_: NSTableView, didDrag: NSTableColumn): void;
        tableViewTypeSelectStringForTableColumnRow?(_: NSTableView, typeSelectStringFor?: NSTableColumn, row?: number): string;
        tableViewNextTypeSelectMatchFromRowToRowForString?(_: NSTableView, nextTypeSelectMatchFromRow: number, toRow: number, for_: string): number;
        tableViewShouldTypeSelectForEventWithCurrentSearchString?(_: NSTableView, shouldTypeSelectFor: NSEvent, withCurrentSearch?: string): boolean;
        tableViewHeightOfRow?(_: NSTableView, heightOfRow: number): number;
        tableViewIsGroupRow?(_: NSTableView, isGroupRow: number): boolean;
        tableViewRowActionsForRowEdge?(_: NSTableView, rowActionsForRow: number, edge: NSTableView.RowActionEdge): NSTableViewRowAction[];
        tableViewRowViewForRow?(_: NSTableView, rowViewForRow: number): NSTableRowView;
        tableViewSelectionIndexesForProposedSelection?(_: NSTableView, selectionIndexesForProposedSelection: NSIndexSet): NSIndexSet;
        tableViewShouldReorderColumnToColumn?(_: NSTableView, shouldReorderColumn: number, toColumn: number): boolean;
        tableViewShouldSelectRow?(_: NSTableView, shouldSelectRow: number): boolean;
        tableViewSizeToFitWidthOfColumn?(_: NSTableView, sizeToFitWidthOfColumn: number): number;
        tableViewColumnDidMove?(_: NSNotification): void;
        tableViewColumnDidResize?(_: NSNotification): void;
        tableViewSelectionDidChange?(_: NSNotification): void;
        tableViewSelectionIsChanging?(_: NSNotification): void;
    }
    class NSTableViewRowAction extends NSObject {
        backgroundColor: NSColor;
        setBackgroundColor(_: NSColor): any;
        image: NSImage;
        setImage(_: NSImage): any;
        style: NSTableViewRowAction.Style;
        title: string;
        setTitle(_: string): any;
    }
    class NSText extends NSView {
        alignment: NSTextAlignment;
        setAlignment(_: NSTextAlignment): any;
        backgroundColor: NSColor;
        setBackgroundColor(_: NSColor): any;
        baseWritingDirection: NSWritingDirection;
        setBaseWritingDirection(_: NSWritingDirection): any;
        delegate: NSTextDelegate;
        setDelegate(_: NSTextDelegate): any;
        drawsBackground: boolean;
        setDrawsBackground(_: boolean): any;
        isEditable: boolean;
        setEditable(_: boolean): any;
        isFieldEditor: boolean;
        setFieldEditor(_: boolean): any;
        font: NSFont;
        setFont(_: NSFont): any;
        isHorizontallyResizable: boolean;
        setHorizontallyResizable(_: boolean): any;
        importsGraphics: boolean;
        setImportsGraphics(_: boolean): any;
        maxSize: CGSize;
        setMaxSize(_: CGSize): any;
        minSize: CGSize;
        setMinSize(_: CGSize): any;
        isRichText: boolean;
        setRichText(_: boolean): any;
        isRulerVisible: boolean;
        isSelectable: boolean;
        setSelectable(_: boolean): any;
        selectedRange: NSRange;
        setSelectedRange(_: NSRange): any;
        string: string;
        setString(_: string): any;
        textColor: NSColor;
        setTextColor(_: NSColor): any;
        usesFontPanel: boolean;
        setUsesFontPanel(_: boolean): any;
        isVerticallyResizable: boolean;
        setVerticallyResizable(_: boolean): any;
        RTFDFromRange(from: NSRange): NSData;
        RTFFromRange(from: NSRange): NSData;
        alignCenter(_?: any): void;
        alignLeft(_?: any): void;
        alignRight(_?: any): void;
        checkSpelling(_?: any): void;
        copyFont(_?: any): void;
        copyRuler(_?: any): void;
        cut(_?: any): void;
        delete(_?: any): void;
        paste(_?: any): void;
        pasteFont(_?: any): void;
        pasteRuler(_?: any): void;
        readRTFDFromFile(fromFile: string): boolean;
        replaceCharactersInRangeWithRTF(in_: NSRange, withRTF: NSData): void;
        replaceCharactersInRangeWithRTFD(in_: NSRange, withRTFD: NSData): void;
        replaceCharactersInRangeWithString(in_: NSRange, with_: string): void;
        scrollRangeToVisible(_: NSRange): void;
        setFontRange(_: NSFont, range: NSRange): void;
        setTextColorRange(_?: NSColor, range?: NSRange): void;
        showGuessPanel(_?: any): void;
        sizeToFit(): void;
        subscript(_?: any): void;
        superscript(_?: any): void;
        toggleRuler(_?: any): void;
        underline(_?: any): void;
        unscript(_?: any): void;
        writeRTFDToFileAtomically(toFile: string, atomically: boolean): boolean;
    }
    class NSTextAlternatives extends NSObject {
        alternativeStrings: string[];
        primaryString: string;
        static createWithPrimaryStringAlternativeStrings(primaryString: string, alternativeStrings: string[]): NSTextAlternatives;
        noteSelectedAlternativeString(_: string): void;
    }
    class NSTextAttachment extends NSObject {
        attachmentCell: NSTextAttachmentCell;
        setAttachmentCell(_: NSTextAttachmentCell): any;
        bounds: CGRect;
        setBounds(_: CGRect): any;
        contents: NSData;
        setContents(_: NSData): any;
        fileType: string;
        setFileType(_: string): any;
        fileWrapper: FileWrapper;
        setFileWrapper(_: FileWrapper): any;
        image: NSImage;
        setImage(_: NSImage): any;
        static createWithDataOfType(data?: NSData, ofType?: string): NSTextAttachment;
        static createWithFileWrapper(fileWrapper?: FileWrapper): NSTextAttachment;
    }
    class NSTextAttachmentCell extends NSCell {
    }
    interface NSTextAttachmentCell extends NSObject {
        attachment: NSTextAttachment;
        setAttachment(_: NSTextAttachment): any;
        cellBaselineOffset(): CGPoint;
        cellFrameForTextContainerProposedLineFragmentGlyphPositionCharacterIndex(_: NSTextContainer, proposedLineFragment: CGRect, glyphPosition: CGPoint, characterIndex: number): CGRect;
        cellSize_(): CGSize;
        drawWithFrameInView(_: CGRect, inView?: NSView): void;
        drawWithFrameInViewCharacterIndex(_: CGRect, inView?: NSView, characterIndex?: number): void;
        drawWithFrameInViewCharacterIndexLayoutManager(_: CGRect, inView?: NSView, characterIndex?: number, layoutManager?: NSLayoutManager): void;
        highlightWithFrameInView(_: boolean, withFrame: CGRect, inView?: NSView): void;
        trackMouseInRectOfViewAtCharacterIndexUntilMouseUp(_: NSEvent, inRect: CGRect, ofView?: NSView, atCharacterIndex?: number, untilMouseUp?: boolean): boolean;
        trackMouseInRectOfViewUntilMouseUp(_: NSEvent, inRect: CGRect, ofView?: NSView, untilMouseUp?: boolean): boolean;
        wantsToTrackMouse(): boolean;
        wantsToTrackMouseForEventInRectOfViewAtCharacterIndex(_: NSEvent, inRect: CGRect, ofView?: NSView, atCharacterIndex?: number): boolean;
    }
    interface NSTextAttachmentContainer extends NSObject {
        attachmentBoundsForTextContainerProposedLineFragmentGlyphPositionCharacterIndex(for_?: NSTextContainer, proposedLineFragment?: CGRect, glyphPosition?: CGPoint, characterIndex?: number): CGRect;
        imageForBoundsTextContainerCharacterIndex(forBounds: CGRect, textContainer?: NSTextContainer, characterIndex?: number): NSImage;
    }
    class NSTextBlock extends NSObject {
        backgroundColor: NSColor;
        setBackgroundColor(_: NSColor): any;
        contentWidth: number;
        contentWidthValueType: NSTextBlock.ValueType;
        verticalAlignment: NSTextBlock.VerticalAlignment;
        setVerticalAlignment(_: NSTextBlock.VerticalAlignment): any;
        borderColorForEdge(for_: NSRectEdge): NSColor;
        boundsRectForContentRectInRectTextContainerCharacterRange(forContentRect: CGRect, in_: CGRect, textContainer: NSTextContainer, characterRange: NSRange): CGRect;
        drawBackgroundWithFrameInViewCharacterRangeLayoutManager(withFrame: CGRect, in_: NSView, characterRange: NSRange, layoutManager: NSLayoutManager): void;
        rectForLayoutAtPointInRectTextContainerCharacterRange(at: CGPoint, in_: CGRect, textContainer: NSTextContainer, characterRange: NSRange): CGRect;
        setBorderColor(_?: NSColor): void;
        setBorderColorForEdge(_?: NSColor, for_?: NSRectEdge): void;
        setContentWidthType(_: number, type: NSTextBlock.ValueType): void;
        setValueTypeForDimension(_: number, type: NSTextBlock.ValueType, for_: NSTextBlock.Dimension): void;
        setWidthTypeForLayer(_: number, type: NSTextBlock.ValueType, for_: NSTextBlock.Layer): void;
        setWidthTypeForLayerEdge(_: number, type: NSTextBlock.ValueType, for_: NSTextBlock.Layer, edge: NSRectEdge): void;
        valueForDimension(for_: NSTextBlock.Dimension): number;
        valueTypeForDimension(for_: NSTextBlock.Dimension): NSTextBlock.ValueType;
        widthForLayerEdge(for_: NSTextBlock.Layer, edge: NSRectEdge): number;
        widthValueTypeForLayerEdge(for_: NSTextBlock.Layer, edge: NSRectEdge): NSTextBlock.ValueType;
    }
    interface NSTextCheckingClient extends NSTextInputClient, NSTextInputTraits {
        addAnnotationsRange(_: Map<string, string>, range: NSRange): void;
        annotatedSubstringForProposedRangeActualRange(forProposedRange: NSRange, actualRange?: NSRange): NSAttributedString;
        candidateListTouchBarItem(): NSCandidateListTouchBarItem<any>;
        removeAnnotationRange(_: string, range: NSRange): void;
        replaceCharactersInRangeWithAnnotatedString(in_: NSRange, withAnnotatedString: NSAttributedString): void;
        selectAndShowRange(_: NSRange): void;
        setAnnotationsRange(_: Map<string, string>, range: NSRange): void;
        viewForRangeFirstRectActualRange(for_: NSRange, firstRect?: NSRect, actualRange?: NSRange): NSView;
    }
    class NSTextCheckingController extends NSObject {
        client: NSTextCheckingClient;
        spellCheckerDocumentTag: number;
        setSpellCheckerDocumentTag(_: number): any;
        changeSpelling(_?: any): void;
        checkSpelling(_?: any): void;
        checkTextInDocument(_?: any): void;
        checkTextInRangeTypesOptions(in_: NSRange, types: number, options: Map<string, any>): void;
        checkTextInSelection(_?: any): void;
        considerTextCheckingForRange(for_: NSRange): void;
        didChangeSelectedRange(): void;
        didChangeTextInRange(in_: NSRange): void;
        ignoreSpelling(_?: any): void;
        static createWithClient(client: NSTextCheckingClient): NSTextCheckingController;
        insertedTextInRange(in_: NSRange): void;
        invalidate(): void;
        menuAtIndexClickedOnSelectionEffectiveRange(at: number, clickedOnSelection: boolean, effectiveRange: NSRange): NSMenu;
        orderFrontSubstitutionsPanel(_?: any): void;
        showGuessPanel(_?: any): void;
        updateCandidates(): void;
        validAnnotations(): string[];
    }
    class NSTextContainer extends NSObject {
        containerSize: CGSize;
        setContainerSize(_: CGSize): any;
        exclusionPaths: NSBezierPath[];
        setExclusionPaths(_: NSBezierPath[]): any;
        heightTracksTextView: boolean;
        setHeightTracksTextView(_: boolean): any;
        layoutManager: NSLayoutManager;
        setLayoutManager(_: NSLayoutManager): any;
        lineBreakMode: NSLineBreakMode;
        setLineBreakMode(_: NSLineBreakMode): any;
        lineFragmentPadding: number;
        setLineFragmentPadding(_: number): any;
        maximumNumberOfLines: number;
        setMaximumNumberOfLines(_: number): any;
        isSimpleRectangularTextContainer: boolean;
        size: CGSize;
        setSize(_: CGSize): any;
        textView: NSTextView;
        setTextView(_: NSTextView): any;
        widthTracksTextView: boolean;
        setWidthTracksTextView(_: boolean): any;
        static createWithContainerSize(containerSize: CGSize): NSTextContainer;
        static createWithSize(size: CGSize): NSTextContainer;
        lineFragmentRectForProposedRectAtIndexWritingDirectionRemainingRect(forProposedRect: CGRect, at: number, writingDirection: NSWritingDirection, remaining?: NSRect): CGRect;
        lineFragmentRectForProposedRectSweepDirectionMovementDirectionRemainingRect(forProposedRect: CGRect, sweepDirection: NSLineSweepDirection, movementDirection: NSLineMovementDirection, remaining?: NSRect): CGRect;
        replaceLayoutManager(_: NSLayoutManager): void;
    }
    interface NSTextDelegate extends NSObject {
        textDidBeginEditing?(_: NSNotification): void;
        textDidChange?(_: NSNotification): void;
        textDidEndEditing?(_: NSNotification): void;
        textShouldBeginEditing?(_: NSText): boolean;
        textShouldEndEditing?(_: NSText): boolean;
    }
    class NSTextField extends NSControl {
        static labelWithAttributedString(labelWithAttributedString: NSAttributedString): NSTextField;
        static labelWithString(labelWithString: string): NSTextField;
        static wrappingLabelWithString(wrappingLabelWithString: string): NSTextField;
        allowsCharacterPickerTouchBarItem: boolean;
        setAllowsCharacterPickerTouchBarItem(_: boolean): any;
        allowsDefaultTighteningForTruncation: boolean;
        setAllowsDefaultTighteningForTruncation(_: boolean): any;
        allowsEditingTextAttributes: boolean;
        setAllowsEditingTextAttributes(_: boolean): any;
        isAutomaticTextCompletionEnabled: boolean;
        setAutomaticTextCompletionEnabled(_: boolean): any;
        backgroundColor: NSColor;
        setBackgroundColor(_: NSColor): any;
        bezelStyle: NSTextField.BezelStyle;
        setBezelStyle(_: NSTextField.BezelStyle): any;
        isBezeled: boolean;
        setBezeled(_: boolean): any;
        isBordered: boolean;
        setBordered(_: boolean): any;
        delegate: NSTextFieldDelegate;
        setDelegate(_: NSTextFieldDelegate): any;
        drawsBackground: boolean;
        setDrawsBackground(_: boolean): any;
        isEditable: boolean;
        setEditable(_: boolean): any;
        importsGraphics: boolean;
        setImportsGraphics(_: boolean): any;
        maximumNumberOfLines: number;
        setMaximumNumberOfLines(_: number): any;
        placeholderAttributedString: NSAttributedString;
        setPlaceholderAttributedString(_: NSAttributedString): any;
        placeholderString: string;
        setPlaceholderString(_: string): any;
        preferredMaxLayoutWidth: number;
        setPreferredMaxLayoutWidth(_: number): any;
        isSelectable: boolean;
        setSelectable(_: boolean): any;
        textColor: NSColor;
        setTextColor(_: NSColor): any;
        selectText(_?: any): void;
        textDidBeginEditing(_: NSNotification): void;
        textDidChange(_: NSNotification): void;
        textDidEndEditing(_: NSNotification): void;
        textShouldBeginEditing(_: NSText): boolean;
        textShouldEndEditing(_: NSText): boolean;
    }
    class NSTextFieldCell extends NSActionCell {
        allowedInputSourceLocales: string[];
        setAllowedInputSourceLocales(_: string[]): any;
        backgroundColor: NSColor;
        setBackgroundColor(_: NSColor): any;
        bezelStyle: NSTextField.BezelStyle;
        setBezelStyle(_: NSTextField.BezelStyle): any;
        drawsBackground: boolean;
        setDrawsBackground(_: boolean): any;
        placeholderAttributedString: NSAttributedString;
        setPlaceholderAttributedString(_: NSAttributedString): any;
        placeholderString: string;
        setPlaceholderString(_: string): any;
        textColor: NSColor;
        setTextColor(_: NSColor): any;
        setWantsNotificationForMarkedText(_: boolean): void;
    }
    interface NSTextFieldDelegate extends NSControlTextEditingDelegate {
        textFieldTextViewShouldSelectCandidateAtIndex?(_: NSTextField, textView: NSTextView, shouldSelectCandidateAt: number): boolean;
        textFieldTextViewCandidatesForSelectedRange?(_: NSTextField, textView: NSTextView, candidates: NSTextCheckingResult[], forSelectedRange: NSRange): NSTextCheckingResult[];
        textFieldTextViewCandidatesForSelectedRange?(_: NSTextField, textView: NSTextView, candidatesForSelectedRange: NSRange): any[];
    }
    class NSTextFinder extends NSObject {
        static drawIncrementalMatchHighlightInRect(in_: CGRect): void;
        client: NSTextFinderClient;
        setClient(_: NSTextFinderClient): any;
        findBarContainer: NSTextFinderBarContainer;
        setFindBarContainer(_: NSTextFinderBarContainer): any;
        findIndicatorNeedsUpdate: boolean;
        setFindIndicatorNeedsUpdate(_: boolean): any;
        incrementalMatchRanges: NSValue[];
        isIncrementalSearchingEnabled: boolean;
        setIncrementalSearchingEnabled(_: boolean): any;
        incrementalSearchingShouldDimContentView: boolean;
        setIncrementalSearchingShouldDimContentView(_: boolean): any;
        cancelFindIndicator(): void;
        noteClientStringWillChange(): void;
        performAction(_: NSTextFinder.Action): void;
        validateAction(_: NSTextFinder.Action): boolean;
    }
    interface NSTextFinderBarContainer extends NSObject {
        findBarView: NSView;
        setFindBarView(_: NSView): any;
        isFindBarVisible: boolean;
        setFindBarVisible(_: boolean): any;
        contentView: NSView;
        findBarViewDidChangeHeight(): void;
    }
    interface NSTextFinderClient extends NSObject {
        allowsMultipleSelection?: boolean;
        isEditable?: boolean;
        firstSelectedRange?: NSRange;
        isSelectable?: boolean;
        selectedRanges?: NSValue[];
        setSelectedRanges(_: NSValue[]): any;
        string?: string;
        visibleCharacterRanges?: NSValue[];
        contentViewAtIndexEffectiveCharacterRange?(at: number, effectiveCharacterRange: NSRange): NSView;
        didReplaceCharacters?(): void;
        drawCharactersInRangeForContentView?(in_: NSRange, forContentView: NSView): void;
        rectsForCharacterRange?(forCharacterRange: NSRange): NSValue[];
        replaceCharactersInRangeWithString?(in_: NSRange, with_: string): void;
        scrollRangeToVisible?(_: NSRange): void;
        shouldReplaceCharactersInRangesWithStrings?(inRanges: NSValue[], with_: string[]): boolean;
        stringAtIndexEffectiveRangeEndsWithSearchBoundary?(at: number, effectiveRange: NSRange, endsWithSearchBoundary: boolean): string;
        stringLength?(): number;
    }
    interface NSTextInput {
    }
    interface NSTextInputClient {
        attributedString?(): NSAttributedString;
        attributedSubstringForProposedRangeActualRange(forProposedRange: NSRange, actualRange?: NSRange): NSAttributedString;
        baselineDeltaForCharacterAtIndex?(at: number): number;
        characterIndexForPoint(for_: CGPoint): number;
        doCommandBySelector(by: string): void;
        drawsVerticallyForCharacterAtIndex?(at: number): boolean;
        firstRectForCharacterRangeActualRange(forCharacterRange: NSRange, actualRange?: NSRange): CGRect;
        fractionOfDistanceThroughGlyphForPoint?(for_: CGPoint): number;
        hasMarkedText(): boolean;
        insertTextReplacementRange(_: any, replacementRange: NSRange): void;
        markedRange(): NSRange;
        selectedRange(): NSRange;
        setMarkedTextSelectedRangeReplacementRange(_: any, selectedRange: NSRange, replacementRange: NSRange): void;
        unmarkText(): void;
        validAttributesForMarkedText(): string[];
        windowLevel?(): number;
    }
    class NSTextInputContext extends NSObject {
        static localizedNameForInputSource(forInputSource: string): string;
        acceptsGlyphInfo: boolean;
        setAcceptsGlyphInfo(_: boolean): any;
        allowedInputSourceLocales: string[];
        setAllowedInputSourceLocales(_: string[]): any;
        client: NSTextInputClient;
        keyboardInputSources: string[];
        selectedKeyboardInputSource: string;
        setSelectedKeyboardInputSource(_: string): any;
        static currentInputContext: NSTextInputContext;
        activate(): void;
        deactivate(): void;
        discardMarkedText(): void;
        handleEvent(_: NSEvent): boolean;
        static createWithClient(client: NSTextInputClient): NSTextInputContext;
        invalidateCharacterCoordinates(): void;
    }
    interface NSTextInputTraits {
        autocorrectionType?: NSTextInputTraitType;
        setAutocorrectionType(_: NSTextInputTraitType): any;
        dataDetectionType?: NSTextInputTraitType;
        setDataDetectionType(_: NSTextInputTraitType): any;
        grammarCheckingType?: NSTextInputTraitType;
        setGrammarCheckingType(_: NSTextInputTraitType): any;
        linkDetectionType?: NSTextInputTraitType;
        setLinkDetectionType(_: NSTextInputTraitType): any;
        smartDashesType?: NSTextInputTraitType;
        setSmartDashesType(_: NSTextInputTraitType): any;
        smartInsertDeleteType?: NSTextInputTraitType;
        setSmartInsertDeleteType(_: NSTextInputTraitType): any;
        smartQuotesType?: NSTextInputTraitType;
        setSmartQuotesType(_: NSTextInputTraitType): any;
        spellCheckingType?: NSTextInputTraitType;
        setSpellCheckingType(_: NSTextInputTraitType): any;
        textCompletionType?: NSTextInputTraitType;
        setTextCompletionType(_: NSTextInputTraitType): any;
        textReplacementType?: NSTextInputTraitType;
        setTextReplacementType(_: NSTextInputTraitType): any;
    }
    interface NSTextLayoutOrientationProvider {
        layoutOrientation: NSLayoutManager.TextLayoutOrientation;
    }
    class NSTextList extends NSObject {
        listOptions: NSTextList.Options;
        markerFormat: string;
        startingItemNumber: number;
        setStartingItemNumber(_: number): any;
        static createWithMarkerFormatOptions(markerFormat: string, options: number): NSTextList;
        markerForItemNumber(forItemNumber: number): string;
    }
    class NSTextStorage extends NSMutableAttributedString {
        attributeRuns: NSTextStorage[];
        setAttributeRuns(_: NSTextStorage[]): any;
        changeInLength: number;
        characters: NSTextStorage[];
        setCharacters(_: NSTextStorage[]): any;
        delegate: NSTextStorageDelegate;
        setDelegate(_: NSTextStorageDelegate): any;
        editedMask: NSTextStorageEditActions;
        editedRange: NSRange;
        fixesAttributesLazily: boolean;
        font: NSFont;
        setFont(_: NSFont): any;
        foregroundColor: NSColor;
        setForegroundColor(_: NSColor): any;
        layoutManagers: NSLayoutManager[];
        paragraphs: NSTextStorage[];
        setParagraphs(_: NSTextStorage[]): any;
        words: NSTextStorage[];
        setWords(_: NSTextStorage[]): any;
        addLayoutManager(_: NSLayoutManager): void;
        editedRangeChangeInLength(_: NSTextStorageEditActions, range: NSRange, changeInLength: number): void;
        ensureAttributesAreFixedInRange(in_: NSRange): void;
        invalidateAttributesInRange(in_: NSRange): void;
        processEditing(): void;
        removeLayoutManager(_: NSLayoutManager): void;
    }
    interface NSTextStorageDelegate extends NSObject {
        textStorageDidProcessEditingRangeChangeInLength?(_: NSTextStorage, didProcessEditing: NSTextStorageEditActions, range: NSRange, changeInLength: number): void;
        textStorageWillProcessEditingRangeChangeInLength?(_: NSTextStorage, willProcessEditing: NSTextStorageEditActions, range: NSRange, changeInLength: number): void;
    }
    class NSTextTab extends NSObject {
        static columnTerminatorsForLocale(for_?: NSLocale): NSCharacterSet;
        alignment: NSTextAlignment;
        location: number;
        options: Map<string, any>;
        tabStopType: NSParagraphStyle.TextTabType;
        static createWithTextAlignmentLocationOptions(textAlignment: NSTextAlignment, location: number, options: Map<string, any>): NSTextTab;
        static createWithTypeLocation(type: NSParagraphStyle.TextTabType, location: number): NSTextTab;
    }
    class NSTextTable extends NSTextBlock {
        collapsesBorders: boolean;
        setCollapsesBorders(_: boolean): any;
        hidesEmptyCells: boolean;
        setHidesEmptyCells(_: boolean): any;
        layoutAlgorithm: NSTextTable.LayoutAlgorithm;
        setLayoutAlgorithm(_: NSTextTable.LayoutAlgorithm): any;
        numberOfColumns: number;
        setNumberOfColumns(_: number): any;
        boundsRectForBlockContentRectInRectTextContainerCharacterRange(for_: NSTextTableBlock, contentRect: CGRect, in_: CGRect, textContainer: NSTextContainer, characterRange: NSRange): CGRect;
        drawBackgroundForBlockWithFrameInViewCharacterRangeLayoutManager(for_: NSTextTableBlock, withFrame: CGRect, in_: NSView, characterRange: NSRange, layoutManager: NSLayoutManager): void;
        rectForBlockLayoutAtPointInRectTextContainerCharacterRange(for_: NSTextTableBlock, layoutAt: CGPoint, in_: CGRect, textContainer: NSTextContainer, characterRange: NSRange): CGRect;
    }
    class NSTextTableBlock extends NSTextBlock {
        columnSpan: number;
        rowSpan: number;
        startingColumn: number;
        startingRow: number;
        table: NSTextTable;
        static createWithTableStartingRowRowSpanStartingColumnColumnSpan(table: NSTextTable, startingRow: number, rowSpan: number, startingColumn: number, columnSpan: number): NSTextTableBlock;
    }
    class NSTextView extends NSText {
        static fieldEditor(): NSTextView;
        static registerForServices(): void;
        static scrollableDocumentContentTextView(): NSScrollView;
        static scrollablePlainDocumentContentTextView(): NSScrollView;
        static scrollableTextView(): NSScrollView;
        acceptableDragTypes: string[];
        acceptsGlyphInfo: boolean;
        setAcceptsGlyphInfo(_: boolean): any;
        allowedInputSourceLocales: string[];
        setAllowedInputSourceLocales(_: string[]): any;
        allowsCharacterPickerTouchBarItem: boolean;
        setAllowsCharacterPickerTouchBarItem(_: boolean): any;
        allowsDocumentBackgroundColorChange: boolean;
        setAllowsDocumentBackgroundColorChange(_: boolean): any;
        allowsImageEditing: boolean;
        setAllowsImageEditing(_: boolean): any;
        allowsUndo: boolean;
        setAllowsUndo(_: boolean): any;
        isAutomaticDashSubstitutionEnabled: boolean;
        setAutomaticDashSubstitutionEnabled(_: boolean): any;
        isAutomaticDataDetectionEnabled: boolean;
        setAutomaticDataDetectionEnabled(_: boolean): any;
        isAutomaticLinkDetectionEnabled: boolean;
        setAutomaticLinkDetectionEnabled(_: boolean): any;
        isAutomaticQuoteSubstitutionEnabled: boolean;
        setAutomaticQuoteSubstitutionEnabled(_: boolean): any;
        isAutomaticSpellingCorrectionEnabled: boolean;
        setAutomaticSpellingCorrectionEnabled(_: boolean): any;
        isAutomaticTextCompletionEnabled: boolean;
        setAutomaticTextCompletionEnabled(_: boolean): any;
        isAutomaticTextReplacementEnabled: boolean;
        setAutomaticTextReplacementEnabled(_: boolean): any;
        isCoalescingUndo: boolean;
        isContinuousSpellCheckingEnabled: boolean;
        setContinuousSpellCheckingEnabled(_: boolean): any;
        defaultParagraphStyle: NSParagraphStyle;
        setDefaultParagraphStyle(_: NSParagraphStyle): any;
        displaysLinkToolTips: boolean;
        setDisplaysLinkToolTips(_: boolean): any;
        enabledTextCheckingTypes: number;
        setEnabledTextCheckingTypes(_: number): any;
        isGrammarCheckingEnabled: boolean;
        setGrammarCheckingEnabled(_: boolean): any;
        isIncrementalSearchingEnabled: boolean;
        setIncrementalSearchingEnabled(_: boolean): any;
        insertionPointColor: NSColor;
        setInsertionPointColor(_: NSColor): any;
        layoutManager: NSLayoutManager;
        linkTextAttributes: Map<string, any>;
        setLinkTextAttributes(_: Map<string, any>): any;
        markedTextAttributes: Map<string, any>;
        setMarkedTextAttributes(_: Map<string, any>): any;
        rangeForUserCharacterAttributeChange: NSRange;
        rangeForUserCompletion: NSRange;
        rangeForUserParagraphAttributeChange: NSRange;
        rangeForUserTextChange: NSRange;
        rangesForUserCharacterAttributeChange: NSValue[];
        rangesForUserParagraphAttributeChange: NSValue[];
        rangesForUserTextChange: NSValue[];
        readablePasteboardTypes: string[];
        selectedRanges: NSValue[];
        setSelectedRanges(_: NSValue[]): any;
        selectedTextAttributes: Map<string, any>;
        setSelectedTextAttributes(_: Map<string, any>): any;
        selectionAffinity: NSSelectionAffinity;
        selectionGranularity: NSSelectionGranularity;
        setSelectionGranularity(_: NSSelectionGranularity): any;
        shouldDrawInsertionPoint: boolean;
        smartInsertDeleteEnabled: boolean;
        setSmartInsertDeleteEnabled(_: boolean): any;
        spellCheckerDocumentTag: number;
        textContainer: NSTextContainer;
        setTextContainer(_: NSTextContainer): any;
        textContainerInset: CGSize;
        setTextContainerInset(_: CGSize): any;
        textContainerOrigin: CGPoint;
        textStorage: NSTextStorage;
        typingAttributes: Map<string, any>;
        setTypingAttributes(_: Map<string, any>): any;
        usesAdaptiveColorMappingForDarkAppearance: boolean;
        setUsesAdaptiveColorMappingForDarkAppearance(_: boolean): any;
        usesFindBar: boolean;
        setUsesFindBar(_: boolean): any;
        usesFindPanel: boolean;
        setUsesFindPanel(_: boolean): any;
        usesInspectorBar: boolean;
        setUsesInspectorBar(_: boolean): any;
        usesRolloverButtonForSelection: boolean;
        setUsesRolloverButtonForSelection(_: boolean): any;
        usesRuler: boolean;
        setUsesRuler(_: boolean): any;
        writablePasteboardTypes: string[];
        static stronglyReferencesTextStorage: boolean;
        alignJustified(_?: any): void;
        breakUndoCoalescing(): void;
        changeAttributes(_?: any): void;
        changeDocumentBackgroundColor(_?: any): void;
        changeLayoutOrientation(_?: any): void;
        characterIndexForInsertionAtPoint(at: CGPoint): number;
        checkTextInDocument(_?: any): void;
        checkTextInRangeTypesOptions(in_: NSRange, types: number, options: Map<string, any>): void;
        checkTextInSelection(_?: any): void;
        cleanUpAfterDragOperation(): void;
        clickedOnLinkAtIndex(onLink: any, at: number): void;
        completionsForPartialWordRangeIndexOfSelectedItem(forPartialWordRange: NSRange, indexOfSelectedItem: number): string[];
        didChangeText(): void;
        dragImageForSelectionWithEventOrigin(with_: NSEvent, origin?: NSPoint): NSImage;
        dragOperationForDraggingInfoType(for_: NSDraggingInfo, type: string): NSDragOperation;
        dragSelectionWithEventOffsetSlideBack(with_: NSEvent, offset: CGSize, slideBack: boolean): boolean;
        drawInsertionPointInRectColorTurnedOn(in_: CGRect, color: NSColor, turnedOn: boolean): void;
        drawViewBackgroundInRect(in_: CGRect): void;
        handleTextCheckingResultsForRangeTypesOptionsOrthographyWordCount(_: NSTextCheckingResult[], forRange: NSRange, types: number, options: Map<string, any>, orthography: NSOrthography, wordCount: number): void;
        static createWithFrameTextContainer(frame: CGRect, textContainer?: NSTextContainer): NSTextView;
        insertCompletionForPartialWordRangeMovementIsFinal(_: string, forPartialWordRange: NSRange, movement: number, isFinal: boolean): void;
        invalidateTextContainerOrigin(): void;
        loosenKerning(_?: any): void;
        lowerBaseline(_?: any): void;
        orderFrontLinkPanel(_?: any): void;
        orderFrontListPanel(_?: any): void;
        orderFrontSharingServicePicker(_?: any): void;
        orderFrontSpacingPanel(_?: any): void;
        orderFrontSubstitutionsPanel(_?: any): void;
        orderFrontTablePanel(_?: any): void;
        outline(_?: any): void;
        pasteAsPlainText(_?: any): void;
        pasteAsRichText(_?: any): void;
        performFindPanelAction(_?: any): void;
        performValidatedReplacementInRangeWithAttributedString(in_: NSRange, with_: NSAttributedString): boolean;
        preferredPasteboardTypeFromArrayRestrictedToTypesFromArray(from: string[], restrictedToTypesFrom?: string[]): string;
        quickLookPreviewableItemsInRanges(_: NSValue[]): QLPreviewItem[];
        raiseBaseline(_?: any): void;
        readSelectionFromPasteboard(from: NSPasteboard): boolean;
        readSelectionFromPasteboardType(from: NSPasteboard, type: string): boolean;
        replaceTextContainer(_: NSTextContainer): void;
        selectionRangeForProposedRangeGranularity(forProposedRange: NSRange, granularity: NSSelectionGranularity): NSRange;
        setAlignmentRange(_: NSTextAlignment, range: NSRange): void;
        setBaseWritingDirectionRange(_: NSWritingDirection, range: NSRange): void;
        setConstrainedFrameSize(_: CGSize): void;
        setLayoutOrientation(_: NSLayoutManager.TextLayoutOrientation): void;
        setNeedsDisplayInRectAvoidAdditionalLayout(_: CGRect, avoidAdditionalLayout: boolean): void;
        setSelectedRange(_: NSRange): void;
        setSelectedRangeAffinityStillSelecting(_: NSRange, affinity: NSSelectionAffinity, stillSelecting: boolean): void;
        setSelectedRangesAffinityStillSelecting(_: NSValue[], affinity: NSSelectionAffinity, stillSelecting: boolean): void;
        setSpellingStateRange(_: number, range: NSRange): void;
        shouldChangeTextInRangeReplacementString(in_: NSRange, replacementString?: string): boolean;
        shouldChangeTextInRangesReplacementStrings(inRanges: NSValue[], replacementStrings?: string[]): boolean;
        showFindIndicatorForRange(for_: NSRange): void;
        smartDeleteRangeForProposedRange(forProposedRange: NSRange): NSRange;
        smartInsertAfterStringForStringReplacingRange(afterStringFor: string, replacing: NSRange): string;
        smartInsertBeforeStringForStringReplacingRange(beforeStringFor: string, replacing: NSRange): string;
        smartInsertForStringReplacingRangeBeforeStringAfterString(for_: string, replacing: NSRange, before?: string, after?: string): void;
        startSpeaking(_?: any): void;
        stopSpeaking(_?: any): void;
        tightenKerning(_?: any): void;
        toggleAutomaticDashSubstitution(_?: any): void;
        toggleAutomaticDataDetection(_?: any): void;
        toggleAutomaticLinkDetection(_?: any): void;
        toggleAutomaticQuoteSubstitution(_?: any): void;
        toggleAutomaticSpellingCorrection(_?: any): void;
        toggleAutomaticTextCompletion(_?: any): void;
        toggleAutomaticTextReplacement(_?: any): void;
        toggleContinuousSpellChecking(_?: any): void;
        toggleGrammarChecking(_?: any): void;
        toggleQuickLookPreviewPanel(_?: any): void;
        toggleSmartInsertDelete(_?: any): void;
        turnOffKerning(_?: any): void;
        turnOffLigatures(_?: any): void;
        updateCandidates(): void;
        updateDragTypeRegistration(): void;
        updateFontPanel(): void;
        updateInsertionPointStateAndRestartTimer(_: boolean): void;
        updateQuickLookPreviewPanel(): void;
        updateRuler(): void;
        updateTextTouchBarItems(): void;
        updateTouchBarItemIdentifiers(): void;
        useAllLigatures(_?: any): void;
        useStandardKerning(_?: any): void;
        useStandardLigatures(_?: any): void;
        writeSelectionToPasteboardType(to: NSPasteboard, type: string): boolean;
        writeSelectionToPasteboardTypes(to: NSPasteboard, types: string[]): boolean;
    }
    interface NSTextViewDelegate extends NSTextDelegate {
        textViewClickedOnLinkAtIndex?(_: NSTextView, clickedOnLink: any, at: number): boolean;
        textViewClickedOnCellInRectAtIndex?(_: NSTextView, clickedOn: NSTextAttachmentCell, in_: CGRect, at: number): void;
        textViewDoubleClickedOnCellInRectAtIndex?(_: NSTextView, doubleClickedOn: NSTextAttachmentCell, in_: CGRect, at: number): void;
        textViewDraggedCellInRectEventAtIndex?(_: NSTextView, draggedCell: NSTextAttachmentCell, in_: CGRect, event: NSEvent, at: number): void;
        textViewWritablePasteboardTypesForCellAtIndex?(_: NSTextView, writablePasteboardTypesFor: NSTextAttachmentCell, at: number): string[];
        textViewWriteCellAtIndexToPasteboardType?(_: NSTextView, write: NSTextAttachmentCell, at: number, to: NSPasteboard, type: string): boolean;
        textViewWillDisplayToolTipForCharacterAtIndex?(_: NSTextView, willDisplayToolTip: string, forCharacterAt: number): string;
        textViewShouldChangeTextInRangeReplacementString?(_: NSTextView, shouldChangeTextIn: NSRange, replacementString?: string): boolean;
        textViewDoCommandBySelector?(_: NSTextView, doCommandBy: string): boolean;
        textViewMenuForEventAtIndex?(_: NSTextView, menu: NSMenu, for_: NSEvent, at: number): NSMenu;
        textViewWillCheckTextInRangeOptionsTypes?(_: NSTextView, willCheckTextIn: NSRange, options: Map<string, any>, types: number): Map<string, any>;
        textViewDidCheckTextInRangeTypesOptionsResultsOrthographyWordCount?(_: NSTextView, didCheckTextIn: NSRange, types: number, options: Map<string, any>, results: NSTextCheckingResult[], orthography: NSOrthography, wordCount: number): NSTextCheckingResult[];
        textViewURLForContentsOfTextAttachmentAtIndex?(_: NSTextView, urlForContentsOf: NSTextAttachment, at: number): NSURL;
        textViewWillShowSharingServicePickerForItems?(_: NSTextView, willShow: NSSharingServicePicker, forItems: any[]): NSSharingServicePicker;
        textViewShouldSelectCandidateAtIndex?(_: NSTextView, shouldSelectCandidateAt: number): boolean;
        textViewCandidatesForSelectedRange?(_: NSTextView, candidates: NSTextCheckingResult[], forSelectedRange: NSRange): NSTextCheckingResult[];
        textViewCandidatesForSelectedRange?(_: NSTextView, candidatesForSelectedRange: NSRange): any[];
        textViewCompletionsForPartialWordRangeIndexOfSelectedItem?(_: NSTextView, completions: string[], forPartialWordRange: NSRange, indexOfSelectedItem?: number): string[];
        textViewShouldChangeTextInRangesReplacementStrings?(_: NSTextView, shouldChangeTextInRanges: NSValue[], replacementStrings?: string[]): boolean;
        textViewShouldChangeTypingAttributesToAttributes?(_: NSTextView, shouldChangeTypingAttributes: Map<string, any>, toAttributes: Map<string, any>): Map<string, any>;
        textViewShouldSetSpellingStateRange?(_: NSTextView, shouldSetSpellingState: number, range: NSRange): number;
        textViewShouldUpdateTouchBarItemIdentifiers?(_: NSTextView, shouldUpdateTouchBarItemIdentifiers: string[]): string[];
        textViewWillChangeSelectionFromCharacterRangeToCharacterRange?(_: NSTextView, willChangeSelectionFromCharacterRange: NSRange, toCharacterRange: NSRange): NSRange;
        textViewWillChangeSelectionFromCharacterRangesToCharacterRanges?(_: NSTextView, willChangeSelectionFromCharacterRanges: NSValue[], toCharacterRanges: NSValue[]): NSValue[];
        textViewDidChangeSelection?(_: NSNotification): void;
        textViewDidChangeTypingAttributes?(_: NSNotification): void;
        undoManagerForTextView?(for_: NSTextView): UndoManager;
    }
    class NSTitlebarAccessoryViewController extends NSViewController {
        fullScreenMinHeight: number;
        setFullScreenMinHeight(_: number): any;
        isHidden: boolean;
        setHidden(_: boolean): any;
        layoutAttribute: NSLayoutConstraint.Attribute;
        setLayoutAttribute(_: NSLayoutConstraint.Attribute): any;
    }
    class NSTokenField extends NSTextField {
        completionDelay: number;
        setCompletionDelay(_: number): any;
        tokenStyle: NSTokenField.TokenStyle;
        setTokenStyle(_: NSTokenField.TokenStyle): any;
        tokenizingCharacterSet: NSCharacterSet;
        setTokenizingCharacterSet(_: NSCharacterSet): any;
        static defaultCompletionDelay: number;
        static defaultTokenizingCharacterSet: NSCharacterSet;
    }
    class NSTokenFieldCell extends NSTextFieldCell {
        completionDelay: number;
        setCompletionDelay(_: number): any;
        delegate: NSTokenFieldCellDelegate;
        setDelegate(_: NSTokenFieldCellDelegate): any;
        tokenStyle: NSTokenField.TokenStyle;
        setTokenStyle(_: NSTokenField.TokenStyle): any;
        tokenizingCharacterSet: NSCharacterSet;
        setTokenizingCharacterSet(_: NSCharacterSet): any;
        static defaultCompletionDelay: number;
        static defaultTokenizingCharacterSet: NSCharacterSet;
    }
    interface NSTokenFieldCellDelegate extends NSObject {
        tokenFieldCellShouldAddObjectsAtIndex?(_: NSTokenFieldCell, shouldAdd: any[], at: number): any[];
        tokenFieldCellRepresentedObjectForEditingString?(_: NSTokenFieldCell, representedObjectForEditing: string): any;
        tokenFieldCellWriteRepresentedObjectsToPasteboard?(_: NSTokenFieldCell, writeRepresentedObjects: any[], to: NSPasteboard): boolean;
        tokenFieldCellReadFromPasteboard?(_: NSTokenFieldCell, readFrom: NSPasteboard): any[];
        tokenFieldCellCompletionsForSubstringIndexOfTokenIndexOfSelectedItem?(_: NSTokenFieldCell, completionsForSubstring: string, indexOfToken: number, indexOfSelectedItem: number): any[];
        tokenFieldCellDisplayStringForRepresentedObject?(_: NSTokenFieldCell, displayStringForRepresentedObject: any): string;
        tokenFieldCellEditingStringForRepresentedObject?(_: NSTokenFieldCell, editingStringForRepresentedObject: any): string;
        tokenFieldCellHasMenuForRepresentedObject?(_: NSTokenFieldCell, hasMenuForRepresentedObject: any): boolean;
        tokenFieldCellMenuForRepresentedObject?(_: NSTokenFieldCell, menuForRepresentedObject: any): NSMenu;
        tokenFieldCellStyleForRepresentedObject?(_: NSTokenFieldCell, styleForRepresentedObject: any): NSTokenField.TokenStyle;
    }
    interface NSTokenFieldDelegate extends NSTextFieldDelegate {
        tokenFieldShouldAddObjectsAtIndex?(_: NSTokenField, shouldAdd: any[], at: number): any[];
        tokenFieldRepresentedObjectForEditingString?(_: NSTokenField, representedObjectForEditing: string): any;
        tokenFieldWriteRepresentedObjectsToPasteboard?(_: NSTokenField, writeRepresentedObjects: any[], to: NSPasteboard): boolean;
        tokenFieldReadFromPasteboard?(_: NSTokenField, readFrom: NSPasteboard): any[];
        tokenFieldCompletionsForSubstringIndexOfTokenIndexOfSelectedItem?(_: NSTokenField, completionsForSubstring: string, indexOfToken: number, indexOfSelectedItem?: number): any[];
        tokenFieldDisplayStringForRepresentedObject?(_: NSTokenField, displayStringForRepresentedObject: any): string;
        tokenFieldEditingStringForRepresentedObject?(_: NSTokenField, editingStringForRepresentedObject: any): string;
        tokenFieldHasMenuForRepresentedObject?(_: NSTokenField, hasMenuForRepresentedObject: any): boolean;
        tokenFieldMenuForRepresentedObject?(_: NSTokenField, menuForRepresentedObject: any): NSMenu;
        tokenFieldStyleForRepresentedObject?(_: NSTokenField, styleForRepresentedObject: any): NSTokenField.TokenStyle;
    }
    class NSToolbar extends NSObject {
        allowsExtensionItems: boolean;
        setAllowsExtensionItems(_: boolean): any;
        allowsUserCustomization: boolean;
        setAllowsUserCustomization(_: boolean): any;
        autosavesConfiguration: boolean;
        setAutosavesConfiguration(_: boolean): any;
        centeredItemIdentifier: string;
        setCenteredItemIdentifier(_: string): any;
        configurationDictionary: Map<string, any>;
        customizationPaletteIsRunning: boolean;
        delegate: NSToolbarDelegate;
        setDelegate(_: NSToolbarDelegate): any;
        displayMode: NSToolbar.DisplayMode;
        setDisplayMode(_: NSToolbar.DisplayMode): any;
        identifier: string;
        items: NSToolbarItem[];
        selectedItemIdentifier: string;
        setSelectedItemIdentifier(_: string): any;
        showsBaselineSeparator: boolean;
        setShowsBaselineSeparator(_: boolean): any;
        sizeMode: NSToolbar.SizeMode;
        setSizeMode(_: NSToolbar.SizeMode): any;
        isVisible: boolean;
        setVisible(_: boolean): any;
        visibleItems: NSToolbarItem[];
        static createWithIdentifier(identifier: string): NSToolbar;
        insertItemWithItemIdentifierAtIndex(withItemIdentifier: string, at: number): void;
        removeItemAtIndex(at: number): void;
        runCustomizationPalette(_?: any): void;
        setConfigurationFromDictionary(_: Map<string, any>): void;
        validateVisibleItems(): void;
    }
    interface NSToolbarDelegate extends NSObject {
        toolbarItemForItemIdentifierWillBeInsertedIntoToolbar?(_: NSToolbar, itemForItemIdentifier: string, willBeInsertedIntoToolbar: boolean): NSToolbarItem;
        toolbarAllowedItemIdentifiers?(_: NSToolbar): string[];
        toolbarDefaultItemIdentifiers?(_: NSToolbar): string[];
        toolbarDidRemoveItem?(_: NSNotification): void;
        toolbarSelectableItemIdentifiers?(_: NSToolbar): string[];
        toolbarWillAddItem?(_: NSNotification): void;
    }
    class NSToolbarItem extends NSObject {
        action: string;
        setAction(_: string): any;
        allowsDuplicatesInToolbar: boolean;
        autovalidates: boolean;
        setAutovalidates(_: boolean): any;
        isBordered: boolean;
        setBordered(_: boolean): any;
        isEnabled: boolean;
        setEnabled(_: boolean): any;
        image: NSImage;
        setImage(_: NSImage): any;
        itemIdentifier: string;
        label: string;
        setLabel(_: string): any;
        maxSize: CGSize;
        setMaxSize(_: CGSize): any;
        menuFormRepresentation: NSMenuItem;
        setMenuFormRepresentation(_: NSMenuItem): any;
        minSize: CGSize;
        setMinSize(_: CGSize): any;
        paletteLabel: string;
        setPaletteLabel(_: string): any;
        tag: number;
        setTag(_: number): any;
        target: any;
        setTarget(_: any): any;
        title: string;
        setTitle(_: string): any;
        toolTip: string;
        setToolTip(_: string): any;
        toolbar: NSToolbar;
        view: NSView;
        setView(_: NSView): any;
        visibilityPriority: number;
        setVisibilityPriority(_: number): any;
        static createWithItemIdentifier(itemIdentifier: string): NSToolbarItem;
        validate(): void;
    }
    class NSToolbarItemGroup extends NSToolbarItem {
        controlRepresentation: NSToolbarItemGroup.ControlRepresentation;
        setControlRepresentation(_: NSToolbarItemGroup.ControlRepresentation): any;
        selectedIndex: number;
        setSelectedIndex(_: number): any;
        selectionMode: NSToolbarItemGroup.SelectionMode;
        setSelectionMode(_: NSToolbarItemGroup.SelectionMode): any;
        subitems: NSToolbarItem[];
        setSubitems(_: NSToolbarItem[]): any;
        isSelectedAtIndex(at: number): boolean;
        setSelectedAtIndex(_: boolean, at: number): void;
    }
    interface NSToolbarItemValidation extends NSObject {
        validateToolbarItem(_: NSToolbarItem): boolean;
    }
    class NSTouch extends NSObject {
        device: any;
        deviceSize: CGSize;
        identity: any;
        normalizedPosition: CGPoint;
        phase: NSTouch.Phase;
        isResting: boolean;
        type: NSTouch.TouchType;
        locationInView(in_?: NSView): CGPoint;
        previousLocationInView(in_?: NSView): CGPoint;
    }
    class NSTouchBar extends NSObject {
        customizationAllowedItemIdentifiers: string[];
        setCustomizationAllowedItemIdentifiers(_: string[]): any;
        customizationIdentifier: string;
        setCustomizationIdentifier(_: string): any;
        customizationRequiredItemIdentifiers: string[];
        setCustomizationRequiredItemIdentifiers(_: string[]): any;
        defaultItemIdentifiers: string[];
        setDefaultItemIdentifiers(_: string[]): any;
        delegate: NSTouchBarDelegate;
        setDelegate(_: NSTouchBarDelegate): any;
        escapeKeyReplacementItemIdentifier: string;
        setEscapeKeyReplacementItemIdentifier(_: string): any;
        itemIdentifiers: string[];
        principalItemIdentifier: string;
        setPrincipalItemIdentifier(_: string): any;
        templateItems: NSSet<NSTouchBarItem>;
        setTemplateItems(_: NSSet<NSTouchBarItem>): any;
        isVisible: boolean;
        static isAutomaticCustomizeTouchBarMenuItemEnabled: boolean;
        setAutomaticCustomizeTouchBarMenuItemEnabled(_: boolean): any;
        itemForIdentifier(forIdentifier: string): NSTouchBarItem;
    }
    interface NSTouchBarDelegate extends NSObject {
        touchBarMakeItemForIdentifier?(_: NSTouchBar, makeItemForIdentifier: string): NSTouchBarItem;
    }
    class NSTouchBarItem extends NSObject {
        customizationLabel: string;
        identifier: string;
        view: NSView;
        viewController: NSViewController;
        visibilityPriority: number;
        setVisibilityPriority(_: number): any;
        isVisible: boolean;
        static createWithIdentifier(identifier: string): NSTouchBarItem;
    }
    interface NSTouchBarProvider extends NSObject {
        touchBar: NSTouchBar;
    }
    class NSTrackingArea extends NSObject {
        options: NSTrackingArea.Options;
        owner: any;
        rect: CGRect;
        userInfo: Map<any, any>;
        static createWithRectOptionsOwnerUserInfo(rect: CGRect, options: NSTrackingArea.Options, owner?: any, userInfo?: Map<any, any>): NSTrackingArea;
    }
    class NSTreeController extends NSObjectController {
        alwaysUsesMultipleValuesMarker: boolean;
        setAlwaysUsesMultipleValuesMarker(_: boolean): any;
        arrangedObjects: NSTreeNode;
        avoidsEmptySelection: boolean;
        setAvoidsEmptySelection(_: boolean): any;
        canAddChild: boolean;
        canInsert: boolean;
        canInsertChild: boolean;
        childrenKeyPath: string;
        setChildrenKeyPath(_: string): any;
        countKeyPath: string;
        setCountKeyPath(_: string): any;
        leafKeyPath: string;
        setLeafKeyPath(_: string): any;
        preservesSelection: boolean;
        setPreservesSelection(_: boolean): any;
        selectedNodes: NSTreeNode[];
        selectionIndexPath: NSIndexPath;
        selectionIndexPaths: NSIndexPath[];
        selectsInsertedObjects: boolean;
        setSelectsInsertedObjects(_: boolean): any;
        sortDescriptors: NSSortDescriptor[];
        setSortDescriptors(_: NSSortDescriptor[]): any;
        addChild(_?: any): void;
        addSelectionIndexPaths(_: NSIndexPath[]): boolean;
        childrenKeyPathForNode(for_: NSTreeNode): string;
        countKeyPathForNode(for_: NSTreeNode): string;
        insert(_?: any): void;
        insertChild(_?: any): void;
        insertObjectAtArrangedObjectIndexPath(_?: any, atArrangedObjectIndexPath?: NSIndexPath): void;
        insertObjectsAtArrangedObjectIndexPaths(_: any[], atArrangedObjectIndexPaths: NSIndexPath[]): void;
        leafKeyPathForNode(for_: NSTreeNode): string;
        moveNodeToIndexPath(_: NSTreeNode, to: NSIndexPath): void;
        moveNodesToIndexPath(_: NSTreeNode[], to: NSIndexPath): void;
        rearrangeObjects(): void;
        removeObjectAtArrangedObjectIndexPath(atArrangedObjectIndexPath: NSIndexPath): void;
        removeObjectsAtArrangedObjectIndexPaths(atArrangedObjectIndexPaths: NSIndexPath[]): void;
        removeSelectionIndexPaths(_: NSIndexPath[]): boolean;
        setSelectionIndexPath(_?: NSIndexPath): boolean;
        setSelectionIndexPaths(_: NSIndexPath[]): boolean;
    }
    class NSTreeNode extends NSObject {
        childNodes: NSTreeNode[];
        indexPath: NSIndexPath;
        isLeaf: boolean;
        mutableChildNodes: NSMutableArray<NSTreeNode>;
        parentNode: NSTreeNode;
        representedObject: any;
        descendantNodeAtIndexPath(at: NSIndexPath): NSTreeNode;
        static createWithRepresentedObject(representedObject?: any): NSTreeNode;
        sortWithSortDescriptorsRecursively(with_: NSSortDescriptor[], recursively: boolean): void;
    }
    class NSTypesetter extends NSObject {
        static printingAdjustmentInLayoutManagerForNominallySpacedGlyphRangePackedGlyphsCount(in_: NSLayoutManager, forNominallySpacedGlyphRange: NSRange, packedGlyphs: string, count: number): CGSize;
        static sharedSystemTypesetterForBehavior(for_: NSLayoutManager.TypesetterBehavior): any;
        attributedString: NSAttributedString;
        setAttributedString(_: NSAttributedString): any;
        attributesForExtraLineFragment: Map<string, any>;
        bidiProcessingEnabled: boolean;
        setBidiProcessingEnabled(_: boolean): any;
        currentParagraphStyle: NSParagraphStyle;
        currentTextContainer: NSTextContainer;
        hyphenationFactor: number;
        setHyphenationFactor(_: number): any;
        layoutManager: NSLayoutManager;
        lineFragmentPadding: number;
        setLineFragmentPadding(_: number): any;
        paragraphCharacterRange: NSRange;
        paragraphGlyphRange: NSRange;
        paragraphSeparatorCharacterRange: NSRange;
        paragraphSeparatorGlyphRange: NSRange;
        textContainers: NSTextContainer[];
        typesetterBehavior: NSLayoutManager.TypesetterBehavior;
        setTypesetterBehavior(_: NSLayoutManager.TypesetterBehavior): any;
        usesFontLeading: boolean;
        setUsesFontLeading(_: boolean): any;
        static defaultTypesetterBehavior: NSLayoutManager.TypesetterBehavior;
        static sharedSystemTypesetter: NSTypesetter;
        actionForControlCharacterAtIndex(at: number): NSTypesetterControlCharacterAction;
        baselineOffsetInLayoutManagerGlyphIndex(in_: NSLayoutManager, glyphIndex: number): number;
        beginLineWithGlyphAtIndex(withGlyphAt: number): void;
        beginParagraph(): void;
        boundingBoxForControlGlyphAtIndexForTextContainerProposedLineFragmentGlyphPositionCharacterIndex(forControlGlyphAt: number, for_: NSTextContainer, proposedLineFragment: CGRect, glyphPosition: CGPoint, characterIndex: number): CGRect;
        characterRangeForGlyphRangeActualGlyphRange(forGlyphRange: NSRange, actualGlyphRange?: NSRange): NSRange;
        endLineWithGlyphRange(withGlyphRange: NSRange): void;
        endParagraph(): void;
        getLineFragmentRectUsedRectForParagraphSeparatorGlyphRangeAtProposedOrigin(_: NSRect, usedRect: NSRect, forParagraphSeparatorGlyphRange: NSRange, atProposedOrigin: CGPoint): void;
        getLineFragmentRectUsedRectRemainingRectForStartingGlyphAtIndexProposedRectLineSpacingParagraphSpacingBeforeParagraphSpacingAfter(_: NSRect, usedRect: NSRect, remaining: NSRect, forStartingGlyphAt: number, proposedRect: CGRect, lineSpacing: number, paragraphSpacingBefore: number, paragraphSpacingAfter: number): void;
        glyphRangeForCharacterRangeActualCharacterRange(forCharacterRange: NSRange, actualCharacterRange?: NSRange): NSRange;
        hyphenCharacterForGlyphAtIndex(forGlyphAt: number): number;
        hyphenationFactorForGlyphAtIndex(forGlyphAt: number): number;
        layoutCharactersInRangeForLayoutManagerMaximumNumberOfLineFragments(in_: NSRange, for_: NSLayoutManager, maximumNumberOfLineFragments: number): NSRange;
        layoutGlyphsInLayoutManagerStartingAtGlyphIndexMaxNumberOfLineFragmentsNextGlyphIndex(in_: NSLayoutManager, startingAtGlyphIndex: number, maxNumberOfLineFragments: number, nextGlyphIndex: number): void;
        layoutParagraphAtPoint(at: NSPoint): number;
        lineSpacingAfterGlyphAtIndexWithProposedLineFragmentRect(afterGlyphAt: number, withProposedLineFragmentRect: CGRect): number;
        paragraphSpacingAfterGlyphAtIndexWithProposedLineFragmentRect(afterGlyphAt: number, withProposedLineFragmentRect: CGRect): number;
        paragraphSpacingBeforeGlyphAtIndexWithProposedLineFragmentRect(beforeGlyphAt: number, withProposedLineFragmentRect: CGRect): number;
        setAttachmentSizeForGlyphRange(_: CGSize, forGlyphRange: NSRange): void;
        setBidiLevelsForGlyphRange(_: string, forGlyphRange: NSRange): void;
        setDrawsOutsideLineFragmentForGlyphRange(_: boolean, forGlyphRange: NSRange): void;
        setHardInvalidationForGlyphRange(_: boolean, forGlyphRange: NSRange): void;
        setLineFragmentRectForGlyphRangeUsedRectBaselineOffset(_: CGRect, forGlyphRange: NSRange, usedRect: CGRect, baselineOffset: number): void;
        setLocationWithAdvancementsForStartOfGlyphRange(_: CGPoint, withAdvancements: number, forStartOfGlyphRange: NSRange): void;
        setNotShownAttributeForGlyphRange(_: boolean, forGlyphRange: NSRange): void;
        setParagraphGlyphRangeSeparatorGlyphRange(_: NSRange, separatorGlyphRange: NSRange): void;
        shouldBreakLineByHyphenatingBeforeCharacterAtIndex(byHyphenatingBeforeCharacterAt: number): boolean;
        shouldBreakLineByWordBeforeCharacterAtIndex(byWordBeforeCharacterAt: number): boolean;
        substituteFontForFont(for_: NSFont): NSFont;
        textTabForGlyphLocationWritingDirectionMaxLocation(forGlyphLocation: number, writingDirection: NSWritingDirection, maxLocation: number): NSTextTab;
        willSetLineFragmentRectForGlyphRangeUsedRectBaselineOffset(_: NSRect, forGlyphRange: NSRange, usedRect: NSRect, baselineOffset: number): void;
    }
    interface NSUserActivityRestoring extends NSObject {
        restoreUserActivityState(_: NSUserActivity): void;
    }
    class NSUserDefaultsController extends NSController {
        appliesImmediately: boolean;
        setAppliesImmediately(_: boolean): any;
        defaults: UserDefaults;
        hasUnappliedChanges: boolean;
        initialValues: Map<string, any>;
        setInitialValues(_: Map<string, any>): any;
        values: any;
        static sharedUserDefaultsController: NSUserDefaultsController;
        static createWithDefaultsInitialValues(defaults?: UserDefaults, initialValues?: Map<string, any>): NSUserDefaultsController;
        revert(_?: any): void;
        revertToInitialValues(_?: any): void;
        save(_?: any): void;
    }
    interface NSUserInterfaceCompression {
        activeCompressionOptions: NSUserInterfaceCompressionOptions;
        compressWithPrioritizedCompressionOptions(withPrioritizedCompressionOptions: NSUserInterfaceCompressionOptions[]): void;
        minimumSizeWithPrioritizedCompressionOptions(withPrioritizedCompressionOptions: NSUserInterfaceCompressionOptions[]): CGSize;
    }
    class NSUserInterfaceCompressionOptions extends NSObject {
        isEmpty: boolean;
        static breakEqualWidthsOption: NSUserInterfaceCompressionOptions;
        static hideImagesOption: NSUserInterfaceCompressionOptions;
        static hideTextOption: NSUserInterfaceCompressionOptions;
        static reduceMetricsOption: NSUserInterfaceCompressionOptions;
        static standardOptions: NSUserInterfaceCompressionOptions;
        containsOptions(_: NSUserInterfaceCompressionOptions): boolean;
        static createWithCompressionOptions(compressionOptions: NSSet<NSUserInterfaceCompressionOptions>): NSUserInterfaceCompressionOptions;
        static createWithIdentifier(identifier: string): NSUserInterfaceCompressionOptions;
        intersectsOptions(_: NSUserInterfaceCompressionOptions): boolean;
        optionsByAddingOptions(_: NSUserInterfaceCompressionOptions): NSUserInterfaceCompressionOptions;
        optionsByRemovingOptions(_: NSUserInterfaceCompressionOptions): NSUserInterfaceCompressionOptions;
    }
    interface NSUserInterfaceItemIdentification {
        identifier: string;
        setIdentifier(_: string): any;
    }
    interface NSUserInterfaceItemSearching extends NSObject {
        localizedTitlesForItem(forItem: any): string[];
        performActionForItem?(forItem: any): void;
        searchForItemsWithWithSearchResultLimitMatchedItemHandler(withSearch: string, resultLimit: number, matchedItemHandler: (p1: any[]) => void): void;
        showAllHelpTopicsForSearchString?(forSearch: string): void;
    }
    interface NSUserInterfaceValidations {
        validateUserInterfaceItem(_: NSValidatedUserInterfaceItem): boolean;
    }
    interface NSValidatedUserInterfaceItem {
        action: string;
        tag: number;
    }
    class NSView extends NSResponder {
        alignmentRectInsets: NSEdgeInsets;
        allowedTouchTypes: NSTouch.TouchTypeMask;
        setAllowedTouchTypes(_: NSTouch.TouchTypeMask): any;
        allowsVibrancy: boolean;
        alphaValue: number;
        setAlphaValue(_: number): any;
        autoresizesSubviews: boolean;
        setAutoresizesSubviews(_: boolean): any;
        autoresizingMask: NSView.AutoresizingMask;
        setAutoresizingMask(_: NSView.AutoresizingMask): any;
        backgroundFilters: CIFilter[];
        setBackgroundFilters(_: CIFilter[]): any;
        baselineOffsetFromBottom: number;
        bottomAnchor: NSLayoutYAxisAnchor;
        bounds: CGRect;
        setBounds(_: CGRect): any;
        boundsRotation: number;
        setBoundsRotation(_: number): any;
        canBecomeKeyView: boolean;
        canDrawConcurrently: boolean;
        setCanDrawConcurrently(_: boolean): any;
        canDrawSubviewsIntoLayer: boolean;
        setCanDrawSubviewsIntoLayer(_: boolean): any;
        candidateListTouchBarItem: NSCandidateListTouchBarItem<any>;
        centerXAnchor: NSLayoutXAxisAnchor;
        centerYAnchor: NSLayoutYAxisAnchor;
        compositingFilter: CIFilter;
        setCompositingFilter(_: CIFilter): any;
        constraints: NSLayoutConstraint[];
        contentFilters: CIFilter[];
        setContentFilters(_: CIFilter[]): any;
        isDrawingFindIndicator: boolean;
        enclosingMenuItem: NSMenuItem;
        enclosingScrollView: NSScrollView;
        firstBaselineAnchor: NSLayoutYAxisAnchor;
        firstBaselineOffsetFromTop: number;
        fittingSize: CGSize;
        isFlipped: boolean;
        focusRingMaskBounds: CGRect;
        focusRingType: NSFocusRingType;
        setFocusRingType(_: NSFocusRingType): any;
        frame: CGRect;
        setFrame(_: CGRect): any;
        frameCenterRotation: number;
        setFrameCenterRotation(_: number): any;
        frameRotation: number;
        setFrameRotation(_: number): any;
        gestureRecognizers: NSGestureRecognizer[];
        setGestureRecognizers(_: NSGestureRecognizer[]): any;
        hasAmbiguousLayout: boolean;
        heightAdjustLimit: number;
        heightAnchor: NSLayoutDimension;
        isHidden: boolean;
        setHidden(_: boolean): any;
        isHiddenOrHasHiddenAncestor: boolean;
        isHorizontalContentSizeConstraintActive: boolean;
        setHorizontalContentSizeConstraintActive(_: boolean): any;
        isInFullScreenMode: boolean;
        inLiveResize: boolean;
        inputContext: NSTextInputContext;
        intrinsicContentSize: CGSize;
        lastBaselineAnchor: NSLayoutYAxisAnchor;
        lastBaselineOffsetFromBottom: number;
        layer: CALayer;
        setLayer(_: CALayer): any;
        layerContentsPlacement: NSView.LayerContentsPlacement;
        setLayerContentsPlacement(_: NSView.LayerContentsPlacement): any;
        layerContentsRedrawPolicy: NSView.LayerContentsRedrawPolicy;
        setLayerContentsRedrawPolicy(_: NSView.LayerContentsRedrawPolicy): any;
        layerUsesCoreImageFilters: boolean;
        setLayerUsesCoreImageFilters(_: boolean): any;
        layoutGuides: NSLayoutGuide[];
        leadingAnchor: NSLayoutXAxisAnchor;
        leftAnchor: NSLayoutXAxisAnchor;
        mouseDownCanMoveWindow: boolean;
        needsDisplay: boolean;
        setNeedsDisplay(_: boolean): any;
        needsLayout: boolean;
        setNeedsLayout(_: boolean): any;
        needsPanelToBecomeKey: boolean;
        needsUpdateConstraints: boolean;
        setNeedsUpdateConstraints(_: boolean): any;
        nextKeyView: NSView;
        setNextKeyView(_: NSView): any;
        nextValidKeyView: NSView;
        isOpaque: boolean;
        opaqueAncestor: NSView;
        pageFooter: NSAttributedString;
        pageHeader: NSAttributedString;
        postsBoundsChangedNotifications: boolean;
        setPostsBoundsChangedNotifications(_: boolean): any;
        postsFrameChangedNotifications: boolean;
        setPostsFrameChangedNotifications(_: boolean): any;
        preparedContentRect: CGRect;
        setPreparedContentRect(_: CGRect): any;
        preservesContentDuringLiveResize: boolean;
        pressureConfiguration: NSPressureConfiguration;
        setPressureConfiguration(_: NSPressureConfiguration): any;
        previousKeyView: NSView;
        previousValidKeyView: NSView;
        printJobTitle: string;
        rectPreservedDuringLiveResize: CGRect;
        registeredDraggedTypes: string[];
        rightAnchor: NSLayoutXAxisAnchor;
        isRotatedFromBase: boolean;
        isRotatedOrScaledFromBase: boolean;
        shadow: NSShadow;
        setShadow(_: NSShadow): any;
        subviews: NSView[];
        setSubviews(_: NSView[]): any;
        superview: NSView;
        tag: number;
        toolTip: string;
        setToolTip(_: string): any;
        topAnchor: NSLayoutYAxisAnchor;
        trackingAreas: NSTrackingArea[];
        trailingAnchor: NSLayoutXAxisAnchor;
        translatesAutoresizingMaskIntoConstraints: boolean;
        setTranslatesAutoresizingMaskIntoConstraints(_: boolean): any;
        userInterfaceLayoutDirection: NSUserInterfaceLayoutDirection;
        setUserInterfaceLayoutDirection(_: NSUserInterfaceLayoutDirection): any;
        isVerticalContentSizeConstraintActive: boolean;
        setVerticalContentSizeConstraintActive(_: boolean): any;
        visibleRect: CGRect;
        wantsDefaultClipping: boolean;
        wantsLayer: boolean;
        setWantsLayer(_: boolean): any;
        wantsRestingTouches: boolean;
        setWantsRestingTouches(_: boolean): any;
        wantsUpdateLayer: boolean;
        widthAdjustLimit: number;
        widthAnchor: NSLayoutDimension;
        window: NSWindow;
        static isCompatibleWithResponsiveScrolling: boolean;
        static defaultFocusRingType: NSFocusRingType;
        static defaultMenu: NSMenu;
        static focusView: NSView;
        static requiresConstraintBasedLayout: boolean;
        acceptsFirstMouse(for_?: NSEvent): boolean;
        addConstraint(_: NSLayoutConstraint): void;
        addConstraints(_: NSLayoutConstraint[]): void;
        addCursorRectCursor(_: CGRect, cursor: NSCursor): void;
        addGestureRecognizer(_: NSGestureRecognizer): void;
        addLayoutGuide(_: NSLayoutGuide): void;
        addSubview(_: NSView): void;
        addSubviewPositionedRelativeTo(_: NSView, positioned: NSWindow.OrderingMode, relativeTo?: NSView): void;
        addToolTipRectOwnerUserData(_: CGRect, owner: any, userData?: any): number;
        addTrackingArea(_: NSTrackingArea): void;
        addTrackingRectOwnerUserDataAssumeInside(_: CGRect, owner: any, userData?: any, assumeInside?: boolean): number;
        adjustPageHeightNewTopBottomLimit(_: number, top: number, bottom: number, limit: number): void;
        adjustPageWidthNewLeftRightLimit(_: number, left: number, right: number, limit: number): void;
        adjustScroll(_: CGRect): CGRect;
        alignmentRectForFrame(forFrame: CGRect): CGRect;
        ancestorSharedWithView(with_: NSView): NSView;
        autoscroll(with_: NSEvent): boolean;
        backingAlignedRectOptions(_: CGRect, options: AlignmentOptions): CGRect;
        beginDocument(): void;
        beginDraggingSessionWithItemsEventSource(with_: NSDraggingItem[], event: NSEvent, source: NSDraggingSource): NSDraggingSession;
        beginPageInRectAtPlacement(in_: CGRect, atPlacement: CGPoint): void;
        bitmapImageRepForCachingDisplayInRect(in_: CGRect): NSBitmapImageRep;
        cacheDisplayInRectToBitmapImageRep(in_: CGRect, to: NSBitmapImageRep): void;
        centerScanRect(_: CGRect): CGRect;
        constraintsAffectingLayoutForOrientation(for_: NSLayoutConstraint.Orientation): NSLayoutConstraint[];
        contentCompressionResistancePriorityForOrientation(for_: NSLayoutConstraint.Orientation): number;
        contentHuggingPriorityForOrientation(for_: NSLayoutConstraint.Orientation): number;
        convertPointFromView(_: CGPoint, from?: NSView): CGPoint;
        convertPointToView(_: CGPoint, to?: NSView): CGPoint;
        convertPointFromBacking(_: CGPoint): CGPoint;
        convertPointFromLayer(_: CGPoint): CGPoint;
        convertPointToBacking(_: CGPoint): CGPoint;
        convertPointToLayer(_: CGPoint): CGPoint;
        convertRectFromView(_: CGRect, from?: NSView): CGRect;
        convertRectToView(_: CGRect, to?: NSView): CGRect;
        convertRectFromBacking(_: CGRect): CGRect;
        convertRectFromLayer(_: CGRect): CGRect;
        convertRectToBacking(_: CGRect): CGRect;
        convertRectToLayer(_: CGRect): CGRect;
        convertSizeFromView(_: CGSize, from?: NSView): CGSize;
        convertSizeToView(_: CGSize, to?: NSView): CGSize;
        convertSizeFromBacking(_: CGSize): CGSize;
        convertSizeFromLayer(_: CGSize): CGSize;
        convertSizeToBacking(_: CGSize): CGSize;
        convertSizeToLayer(_: CGSize): CGSize;
        dataWithEPSInsideRect(inside: CGRect): NSData;
        dataWithPDFInsideRect(inside: CGRect): NSData;
        didAddSubview(_: NSView): void;
        didCloseMenuWithEvent(_: NSMenu, with_?: NSEvent): void;
        discardCursorRects(): void;
        display(): void;
        displayIfNeeded(): void;
        displayIfNeededIgnoringOpacity(): void;
        displayIfNeededInRect(_: CGRect): void;
        displayIfNeededInRectIgnoringOpacity(_: CGRect): void;
        displayRect(_: CGRect): void;
        displayRectIgnoringOpacity(_: CGRect): void;
        displayRectIgnoringOpacityInContext(_: CGRect, in_: NSGraphicsContext): void;
        drawFocusRingMask(): void;
        drawPageBorderWithSize(with_: CGSize): void;
        drawRect(_: CGRect): void;
        endDocument(): void;
        endPage(): void;
        enterFullScreenModeWithOptions(_: NSScreen, withOptions?: Map<string, any>): boolean;
        exerciseAmbiguityInLayout(): void;
        exitFullScreenModeWithOptions(options?: Map<string, any>): void;
        frameForAlignmentRect(forAlignmentRect: CGRect): CGRect;
        getRectsBeingDrawnCount(_?: NSRect, count?: number): void;
        getRectsExposedDuringLiveResizeCount(_: NSRect, count: number): void;
        hitTest(_: CGPoint): NSView;
        static createWithFrame(frame: CGRect): NSView;
        invalidateIntrinsicContentSize(): void;
        isDescendantOf(of: NSView): boolean;
        knowsPageRange(_: NSRange): boolean;
        layout(): void;
        layoutSubtreeIfNeeded(): void;
        locationOfPrintRect(_: CGRect): CGPoint;
        makeBackingLayer(): CALayer;
        menuForEvent(for_: NSEvent): NSMenu;
        mouseInRect(_: CGPoint, in_: CGRect): boolean;
        needsToDrawRect(_: CGRect): boolean;
        noteFocusRingMaskChanged(): void;
        prepareContentInRect(in_: CGRect): void;
        prepareForReuse(): void;
        print(_?: any): void;
        rectForPage(_: number): CGRect;
        rectForSmartMagnificationAtPointInRect(at: CGPoint, in_: CGRect): CGRect;
        reflectScrolledClipView(_: NSClipView): void;
        registerForDraggedTypes(_: string[]): void;
        removeAllToolTips(): void;
        removeConstraint(_: NSLayoutConstraint): void;
        removeConstraints(_: NSLayoutConstraint[]): void;
        removeCursorRectCursor(_: CGRect, cursor: NSCursor): void;
        removeFromSuperview(): void;
        removeFromSuperviewWithoutNeedingDisplay(): void;
        removeGestureRecognizer(_: NSGestureRecognizer): void;
        removeLayoutGuide(_: NSLayoutGuide): void;
        removeToolTip(_: number): void;
        removeTrackingArea(_: NSTrackingArea): void;
        removeTrackingRect(_: number): void;
        replaceSubviewWith(_: NSView, with_: NSView): void;
        resetCursorRects(): void;
        resizeSubviewsWithOldSize(withOldSize: CGSize): void;
        resizeWithOldSuperviewSize(withOldSuperviewSize: CGSize): void;
        rotateByAngle(byDegrees: number): void;
        rulerViewDidAddMarker(_: NSRulerView, didAdd: NSRulerMarker): void;
        rulerViewDidMoveMarker(_: NSRulerView, didMove: NSRulerMarker): void;
        rulerViewDidRemoveMarker(_: NSRulerView, didRemove: NSRulerMarker): void;
        rulerViewHandleMouseDown(_: NSRulerView, handleMouseDownWith: NSEvent): void;
        rulerViewLocationForPoint(_: NSRulerView, locationFor: CGPoint): number;
        rulerViewPointForLocation(_: NSRulerView, pointForLocation: number): CGPoint;
        rulerViewShouldAddMarker(_: NSRulerView, shouldAdd: NSRulerMarker): boolean;
        rulerViewShouldMoveMarker(_: NSRulerView, shouldMove: NSRulerMarker): boolean;
        rulerViewShouldRemoveMarker(_: NSRulerView, shouldRemove: NSRulerMarker): boolean;
        rulerViewWillAddMarkerAtLocation(_: NSRulerView, willAdd: NSRulerMarker, atLocation: number): number;
        rulerViewWillMoveMarkerToLocation(_: NSRulerView, willMove: NSRulerMarker, toLocation: number): number;
        rulerViewWillSetClientView(_: NSRulerView, willSetClientView: NSView): void;
        scaleUnitSquareToSize(to: CGSize): void;
        scrollClipViewToPoint(_: NSClipView, to: CGPoint): void;
        scrollPoint(_: CGPoint): void;
        scrollRectToVisible(_: CGRect): boolean;
        setBoundsOrigin(_: CGPoint): void;
        setBoundsSize(_: CGSize): void;
        setContentCompressionResistancePriorityForOrientation(_: number, for_: NSLayoutConstraint.Orientation): void;
        setContentHuggingPriorityForOrientation(_: number, for_: NSLayoutConstraint.Orientation): void;
        setFrameOrigin(_: CGPoint): void;
        setFrameSize(_: CGSize): void;
        setKeyboardFocusRingNeedsDisplayInRect(_: CGRect): void;
        setNeedsDisplayInRect(_: CGRect): void;
        shouldDelayWindowOrderingForEvent(for_: NSEvent): boolean;
        showDefinitionForAttributedStringAtPoint(for_?: NSAttributedString, at?: CGPoint): void;
        showDefinitionForRangeOptionsBaselineOriginProvider(for_?: NSAttributedString, range?: NSRange, options?: Map<string, any>, baselineOriginProvider?: (p1: NSRange) => CGPoint): void;
        sortSubviewsContext(_?: (p1: NSView, p2: NSView, p3: any) => ComparisonResult, context?: any): void;
        translateOriginToPoint(to: CGPoint): void;
        translateRectsNeedingDisplayInRectBy(in_: CGRect, by: CGSize): void;
        unregisterDraggedTypes(): void;
        updateConstraints(): void;
        updateConstraintsForSubtreeIfNeeded(): void;
        updateLayer(): void;
        updateTrackingAreas(): void;
        viewDidChangeBackingProperties(): void;
        viewDidChangeEffectiveAppearance(): void;
        viewDidEndLiveResize(): void;
        viewDidHide(): void;
        viewDidMoveToSuperview(): void;
        viewDidMoveToWindow(): void;
        viewDidUnhide(): void;
        viewWillDraw(): void;
        viewWillMoveToSuperview(toSuperview?: NSView): void;
        viewWillMoveToWindow(toWindow?: NSWindow): void;
        viewWillStartLiveResize(): void;
        viewWithTag(_: number): NSView;
        willOpenMenuWithEvent(_: NSMenu, with_: NSEvent): void;
        willRemoveSubview(_: NSView): void;
        writeEPSInsideRectToPasteboard(inside: CGRect, to: NSPasteboard): void;
        writePDFInsideRectToPasteboard(inside: CGRect, to: NSPasteboard): void;
    }
    class NSViewAnimation extends NSAnimation {
        viewAnimations: Map<string, any>[];
        setViewAnimations(_: Map<string, any>[]): any;
        static createWithViewAnimations(viewAnimations: Map<string, any>[]): NSViewAnimation;
    }
    class NSViewController extends NSResponder {
        childViewControllers: NSViewController[];
        setChildViewControllers(_: NSViewController[]): any;
        extensionContext: NSExtensionContext;
        nibBundle: Bundle;
        nibName: string;
        parentViewController: NSViewController;
        preferredContentSize: CGSize;
        setPreferredContentSize(_: CGSize): any;
        preferredMaximumSize: CGSize;
        preferredMinimumSize: CGSize;
        preferredScreenOrigin: CGPoint;
        setPreferredScreenOrigin(_: CGPoint): any;
        presentedViewControllers: NSViewController[];
        presentingViewController: NSViewController;
        representedObject: any;
        setRepresentedObject(_: any): any;
        sourceItemView: NSView;
        setSourceItemView(_: NSView): any;
        storyboard: NSStoryboard;
        title: string;
        setTitle(_: string): any;
        view: NSView;
        setView(_: NSView): any;
        isViewLoaded: boolean;
        addChildViewController(_: NSViewController): void;
        dismissController(_?: any): void;
        dismissViewController(_: NSViewController): void;
        static createWithNibNameBundle(nibName?: string, bundle?: Bundle): NSViewController;
        insertChildViewControllerAtIndex(_: NSViewController, at: number): void;
        loadView(): void;
        preferredContentSizeDidChangeForViewController(for_: NSViewController): void;
        presentViewControllerAnimator(_: NSViewController, animator: NSViewControllerPresentationAnimator): void;
        presentViewControllerAsPopoverRelativeToRectOfViewPreferredEdgeBehavior(_: NSViewController, asPopoverRelativeTo: CGRect, of: NSView, preferredEdge: NSRectEdge, behavior: NSPopover.Behavior): void;
        presentViewControllerAsModalWindow(_: NSViewController): void;
        presentViewControllerAsSheet(_: NSViewController): void;
        removeChildViewControllerAtIndex(at: number): void;
        removeFromParentViewController(): void;
        transitionWithFromToOptionsCompletionHandler(from: NSViewController, to: NSViewController, options: NSViewController.TransitionOptions, completionHandler?: () => void): void;
        updateViewConstraints(): void;
        viewDidAppear(): void;
        viewDidDisappear(): void;
        viewDidLayout(): void;
        viewDidLoad(): void;
        viewWillAppear(): void;
        viewWillDisappear(): void;
        viewWillLayout(): void;
        viewWillTransitionToSize(to: CGSize): void;
    }
    interface NSViewControllerPresentationAnimator extends NSObject {
        animateDismissalOfViewControllerFromViewController(of: NSViewController, from: NSViewController): void;
        animatePresentationOfViewControllerFromViewController(of: NSViewController, from: NSViewController): void;
    }
    interface NSViewLayerContentScaleDelegate extends NSObject {
        layerShouldInheritContentsScaleFromWindow?(_: CALayer, shouldInheritContentsScale: number, from: NSWindow): boolean;
    }
    interface NSViewToolTipOwner extends NSObject {
        viewStringForToolTipPointUserData(_: NSView, stringForToolTip: number, point: CGPoint, userData?: any): string;
    }
    class NSVisualEffectView extends NSView {
        blendingMode: NSVisualEffectView.BlendingMode;
        setBlendingMode(_: NSVisualEffectView.BlendingMode): any;
        isEmphasized: boolean;
        setEmphasized(_: boolean): any;
        interiorBackgroundStyle: NSView.BackgroundStyle;
        maskImage: NSImage;
        setMaskImage(_: NSImage): any;
        material: NSVisualEffectView.Material;
        setMaterial(_: NSVisualEffectView.Material): any;
        state: NSVisualEffectView.State;
        setState(_: NSVisualEffectView.State): any;
    }
    class NSWindow extends NSResponder {
        static contentRectForFrameRectStyleMask(forFrameRect: CGRect, styleMask: NSWindow.StyleMask): CGRect;
        static frameRectForContentRectStyleMask(forContentRect: CGRect, styleMask: NSWindow.StyleMask): CGRect;
        static minFrameWidthWithTitleStyleMask(withTitle: string, styleMask: NSWindow.StyleMask): number;
        static removeFrameUsingName(usingName: string): void;
        static standardWindowButtonForStyleMask(_: NSWindow.ButtonType, for_: NSWindow.StyleMask): NSButton;
        static windowNumberAtPointBelowWindowWithWindowNumber(at: CGPoint, belowWindowWithWindowNumber: number): number;
        static windowNumbersWithOptions(options: NSWindow.NumberListOptions): number[];
        acceptsMouseMovedEvents: boolean;
        setAcceptsMouseMovedEvents(_: boolean): any;
        allowsConcurrentViewDrawing: boolean;
        setAllowsConcurrentViewDrawing(_: boolean): any;
        allowsToolTipsWhenApplicationIsInactive: boolean;
        setAllowsToolTipsWhenApplicationIsInactive(_: boolean): any;
        alphaValue: number;
        setAlphaValue(_: number): any;
        animationBehavior: NSWindow.AnimationBehavior;
        setAnimationBehavior(_: NSWindow.AnimationBehavior): any;
        appearanceSource: NSObject;
        setAppearanceSource(_: NSObject): any;
        areCursorRectsEnabled: boolean;
        aspectRatio: CGSize;
        setAspectRatio(_: CGSize): any;
        attachedSheet: NSWindow;
        autorecalculatesKeyViewLoop: boolean;
        setAutorecalculatesKeyViewLoop(_: boolean): any;
        backgroundColor: NSColor;
        setBackgroundColor(_: NSColor): any;
        backingScaleFactor: number;
        backingType: NSWindow.BackingStoreType;
        setBackingType(_: NSWindow.BackingStoreType): any;
        canBecomeKeyWindow: boolean;
        canBecomeMainWindow: boolean;
        canBecomeVisibleWithoutLogin: boolean;
        setCanBecomeVisibleWithoutLogin(_: boolean): any;
        canHide: boolean;
        setCanHide(_: boolean): any;
        childWindows: NSWindow[];
        collectionBehavior: NSWindow.CollectionBehavior;
        setCollectionBehavior(_: NSWindow.CollectionBehavior): any;
        colorSpace: NSColorSpace;
        setColorSpace(_: NSColorSpace): any;
        contentAspectRatio: CGSize;
        setContentAspectRatio(_: CGSize): any;
        contentLayoutGuide: any;
        contentLayoutRect: CGRect;
        contentMaxSize: CGSize;
        setContentMaxSize(_: CGSize): any;
        contentMinSize: CGSize;
        setContentMinSize(_: CGSize): any;
        contentResizeIncrements: CGSize;
        setContentResizeIncrements(_: CGSize): any;
        contentView: NSView;
        setContentView(_: NSView): any;
        contentViewController: NSViewController;
        setContentViewController(_: NSViewController): any;
        currentEvent: NSEvent;
        deepestScreen: NSScreen;
        defaultButtonCell: NSButtonCell;
        setDefaultButtonCell(_: NSButtonCell): any;
        delegate: NSWindowDelegate;
        setDelegate(_: NSWindowDelegate): any;
        depthLimit: NSWindow.Depth;
        setDepthLimit(_: NSWindow.Depth): any;
        deviceDescription: Map<string, any>;
        displaysWhenScreenProfileChanges: boolean;
        setDisplaysWhenScreenProfileChanges(_: boolean): any;
        dockTile: NSDockTile;
        isDocumentEdited: boolean;
        setDocumentEdited(_: boolean): any;
        isExcludedFromWindowsMenu: boolean;
        setExcludedFromWindowsMenu(_: boolean): any;
        firstResponder: NSResponder;
        isFloatingPanel: boolean;
        frame: CGRect;
        frameAutosaveName: string;
        hasCloseBox: boolean;
        hasDynamicDepthLimit: boolean;
        hasShadow: boolean;
        setHasShadow(_: boolean): any;
        hasTitleBar: boolean;
        hidesOnDeactivate: boolean;
        setHidesOnDeactivate(_: boolean): any;
        ignoresMouseEvents: boolean;
        setIgnoresMouseEvents(_: boolean): any;
        inLiveResize: boolean;
        initialFirstResponder: NSView;
        setInitialFirstResponder(_: NSView): any;
        keyViewSelectionDirection: NSWindow.SelectionDirection;
        isKeyWindow: boolean;
        level: number;
        setLevel(_: number): any;
        isMainWindow: boolean;
        maxFullScreenContentSize: CGSize;
        setMaxFullScreenContentSize(_: CGSize): any;
        maxSize: CGSize;
        setMaxSize(_: CGSize): any;
        minFullScreenContentSize: CGSize;
        setMinFullScreenContentSize(_: CGSize): any;
        minSize: CGSize;
        setMinSize(_: CGSize): any;
        isMiniaturizable: boolean;
        isMiniaturized: boolean;
        miniwindowImage: NSImage;
        setMiniwindowImage(_: NSImage): any;
        miniwindowTitle: string;
        setMiniwindowTitle(_: string): any;
        isModalPanel: boolean;
        mouseLocationOutsideOfEventStream: CGPoint;
        isMovable: boolean;
        setMovable(_: boolean): any;
        isMovableByWindowBackground: boolean;
        setMovableByWindowBackground(_: boolean): any;
        occlusionState: NSWindow.OcclusionState;
        isOnActiveSpace: boolean;
        isOpaque: boolean;
        setOpaque(_: boolean): any;
        orderedIndex: number;
        setOrderedIndex(_: number): any;
        parentWindow: NSWindow;
        setParentWindow(_: NSWindow): any;
        preservesContentDuringLiveResize: boolean;
        setPreservesContentDuringLiveResize(_: boolean): any;
        preventsApplicationTerminationWhenModal: boolean;
        setPreventsApplicationTerminationWhenModal(_: boolean): any;
        isReleasedWhenClosed: boolean;
        setReleasedWhenClosed(_: boolean): any;
        representedFilename: string;
        setRepresentedFilename(_: string): any;
        representedURL: NSURL;
        setRepresentedURL(_: NSURL): any;
        isResizable: boolean;
        resizeFlags: NSEvent.ModifierFlags;
        resizeIncrements: CGSize;
        setResizeIncrements(_: CGSize): any;
        isRestorable: boolean;
        setRestorable(_: boolean): any;
        restorationClass: typeof NSObject;
        setRestorationClass(_: typeof NSObject): any;
        screen: NSScreen;
        sharingType: NSWindow.SharingType;
        setSharingType(_: NSWindow.SharingType): any;
        isSheet: boolean;
        sheetParent: NSWindow;
        sheets: NSWindow[];
        showsResizeIndicator: boolean;
        setShowsResizeIndicator(_: boolean): any;
        showsToolbarButton: boolean;
        setShowsToolbarButton(_: boolean): any;
        stringWithSavedFrame: string;
        styleMask: NSWindow.StyleMask;
        setStyleMask(_: NSWindow.StyleMask): any;
        tab: NSWindowTab;
        tabGroup: NSWindowTabGroup;
        tabbedWindows: NSWindow[];
        tabbingIdentifier: string;
        setTabbingIdentifier(_: string): any;
        tabbingMode: NSWindow.TabbingMode;
        setTabbingMode(_: NSWindow.TabbingMode): any;
        title: string;
        setTitle(_: string): any;
        titleVisibility: NSWindow.TitleVisibility;
        setTitleVisibility(_: NSWindow.TitleVisibility): any;
        titlebarAccessoryViewControllers: NSTitlebarAccessoryViewController[];
        setTitlebarAccessoryViewControllers(_: NSTitlebarAccessoryViewController[]): any;
        titlebarAppearsTransparent: boolean;
        setTitlebarAppearsTransparent(_: boolean): any;
        toolbar: NSToolbar;
        setToolbar(_: NSToolbar): any;
        viewsNeedDisplay: boolean;
        setViewsNeedDisplay(_: boolean): any;
        isVisible: boolean;
        windowController: NSWindowController;
        setWindowController(_: NSWindowController): any;
        windowNumber: number;
        windowRef: any;
        windowTitlebarLayoutDirection: NSUserInterfaceLayoutDirection;
        worksWhenModal: boolean;
        isZoomable: boolean;
        isZoomed: boolean;
        static allowsAutomaticWindowTabbing: boolean;
        setAllowsAutomaticWindowTabbing(_: boolean): any;
        static defaultDepthLimit: NSWindow.Depth;
        static userTabbingPreference: NSWindow.UserTabbingPreference;
        addChildWindowOrdered(_: NSWindow, ordered: NSWindow.OrderingMode): void;
        addTabbedWindowOrdered(_: NSWindow, ordered: NSWindow.OrderingMode): void;
        addTitlebarAccessoryViewController(_: NSTitlebarAccessoryViewController): void;
        anchorAttributeForOrientation(for_: NSLayoutConstraint.Orientation): NSLayoutConstraint.Attribute;
        animationResizeTime(_: CGRect): number;
        autorecalculatesContentBorderThicknessForEdge(for_: NSRectEdge): boolean;
        backingAlignedRectOptions(_: CGRect, options: AlignmentOptions): CGRect;
        becomeKeyWindow(): void;
        becomeMainWindow(): void;
        beginCriticalSheetWithCompletionHandler(_: NSWindow, completionHandler?: (p1: number) => void): void;
        beginSheetWithCompletionHandler(_: NSWindow, completionHandler?: (p1: number) => void): void;
        canRepresentDisplayGamut(_: NSDisplayGamut): boolean;
        cascadeTopLeftFromPoint(from: CGPoint): CGPoint;
        center(): void;
        close(): void;
        constrainFrameRectToScreen(_: CGRect, to?: NSScreen): CGRect;
        contentBorderThicknessForEdge(for_: NSRectEdge): number;
        contentRectForFrameRect(forFrameRect: CGRect): CGRect;
        convertPointFromBacking(_: CGPoint): CGPoint;
        convertPointFromScreen(fromScreen: CGPoint): CGPoint;
        convertPointToBacking(_: CGPoint): CGPoint;
        convertPointToScreen(toScreen: CGPoint): CGPoint;
        convertRectFromBacking(_: CGRect): CGRect;
        convertRectFromScreen(_: CGRect): CGRect;
        convertRectToBacking(_: CGRect): CGRect;
        convertRectToScreen(_: CGRect): CGRect;
        dataWithEPSInsideRect(inside: CGRect): NSData;
        dataWithPDFInsideRect(inside: CGRect): NSData;
        deminiaturize(_?: any): void;
        disableCursorRects(): void;
        disableKeyEquivalentForDefaultButtonCell(): void;
        disableScreenUpdatesUntilFlush(): void;
        disableSnapshotRestoration(): void;
        discardCursorRects(): void;
        discardEventsMatchingMaskBeforeEvent(matching: NSEvent.EventTypeMask, before?: NSEvent): void;
        display(): void;
        displayIfNeeded(): void;
        dragImageAtOffsetEventPasteboardSourceSlideBack(_: NSImage, at: CGPoint, offset: CGSize, event: NSEvent, pasteboard: NSPasteboard, source: any, slideBack: boolean): void;
        enableCursorRects(): void;
        enableKeyEquivalentForDefaultButtonCell(): void;
        enableSnapshotRestoration(): void;
        endEditingFor(for_?: any): void;
        endSheet(_: NSWindow): void;
        endSheetReturnCode(_: NSWindow, returnCode: number): void;
        fieldEditorForObject(_: boolean, for_?: any): NSText;
        frameRectForContentRect(forContentRect: CGRect): CGRect;
        handleCloseScriptCommand(_: NSCloseCommand): any;
        handlePrintScriptCommand(_: NSScriptCommand): any;
        handleSaveScriptCommand(_: NSScriptCommand): any;
        static createWithContentRectStyleMaskBackingDefer(contentRect: CGRect, styleMask: NSWindow.StyleMask, backing: NSWindow.BackingStoreType, defer: boolean): NSWindow;
        static createWithContentRectStyleMaskBackingDeferScreen(contentRect: CGRect, styleMask: NSWindow.StyleMask, backing: NSWindow.BackingStoreType, defer: boolean, screen?: NSScreen): NSWindow;
        static createWithWindowRef(windowRef: any): NSWindow;
        insertTitlebarAccessoryViewControllerAtIndex(_: NSTitlebarAccessoryViewController, at: number): void;
        invalidateCursorRectsForView(for_: NSView): void;
        invalidateShadow(): void;
        layoutIfNeeded(): void;
        makeFirstResponder(_?: NSResponder): boolean;
        makeKeyAndOrderFront(_?: any): void;
        makeKeyWindow(): void;
        makeMainWindow(): void;
        mergeAllWindows(_?: any): void;
        miniaturize(_?: any): void;
        moveTabToNewWindow(_?: any): void;
        nextEventMatchingMask(matching: NSEvent.EventTypeMask): NSEvent;
        nextEventMatchingMaskUntilDateInModeDequeue(matching: NSEvent.EventTypeMask, until?: Date, inMode?: string, dequeue?: boolean): NSEvent;
        orderBack(_?: any): void;
        orderFront(_?: any): void;
        orderFrontRegardless(): void;
        orderOut(_?: any): void;
        orderWindowRelativeTo(_: NSWindow.OrderingMode, relativeTo: number): void;
        performClose(_?: any): void;
        performMiniaturize(_?: any): void;
        performWindowDragWithEvent(with_: NSEvent): void;
        performZoom(_?: any): void;
        postEventAtStart(_: NSEvent, atStart: boolean): void;
        print(_?: any): void;
        recalculateKeyViewLoop(): void;
        registerForDraggedTypes(_: string[]): void;
        removeChildWindow(_: NSWindow): void;
        removeTitlebarAccessoryViewControllerAtIndex(at: number): void;
        resetCursorRects(): void;
        resignKeyWindow(): void;
        resignMainWindow(): void;
        runToolbarCustomizationPalette(_?: any): void;
        saveFrameUsingName(usingName: string): void;
        selectKeyViewFollowingView(following: NSView): void;
        selectKeyViewPrecedingView(preceding: NSView): void;
        selectNextKeyView(_?: any): void;
        selectNextTab(_?: any): void;
        selectPreviousKeyView(_?: any): void;
        selectPreviousTab(_?: any): void;
        sendEvent(_: NSEvent): void;
        setAnchorAttributeForOrientation(_: NSLayoutConstraint.Attribute, for_: NSLayoutConstraint.Orientation): void;
        setAutorecalculatesContentBorderThicknessForEdge(_: boolean, for_: NSRectEdge): void;
        setContentBorderThicknessForEdge(_: number, for_: NSRectEdge): void;
        setContentSize(_: CGSize): void;
        setDynamicDepthLimit(_: boolean): void;
        setFrameDisplay(_: CGRect, display: boolean): void;
        setFrameDisplayAnimate(_: CGRect, display: boolean, animate: boolean): void;
        setFrameAutosaveName(_: string): boolean;
        setFrameFromString(from: string): void;
        setFrameOrigin(_: CGPoint): void;
        setFrameTopLeftPoint(_: CGPoint): void;
        setFrameUsingName(_: string): boolean;
        setFrameUsingNameForce(_: string, force: boolean): boolean;
        setIsMiniaturized(_: boolean): void;
        setIsVisible(_: boolean): void;
        setIsZoomed(_: boolean): void;
        setTitleWithRepresentedFilename(_: string): void;
        standardWindowButton(_: NSWindow.ButtonType): NSButton;
        toggleFullScreen(_?: any): void;
        toggleTabBar(_?: any): void;
        toggleTabOverview(_?: any): void;
        toggleToolbarShown(_?: any): void;
        trackEventsWithMatchingTimeoutModeHandler(matching: NSEvent.EventTypeMask, timeout: number, mode: string, handler?: (p1: NSEvent, p2: boolean) => void): void;
        unregisterDraggedTypes(): void;
        update(): void;
        updateConstraintsIfNeeded(): void;
        visualizeConstraints(_?: NSLayoutConstraint[]): void;
        zoom(_?: any): void;
    }
    class NSWindowController extends NSResponder {
        contentViewController: NSViewController;
        setContentViewController(_: NSViewController): any;
        document: any;
        setDocument(_: any): any;
        owner: any;
        shouldCascadeWindows: boolean;
        setShouldCascadeWindows(_: boolean): any;
        shouldCloseDocument: boolean;
        setShouldCloseDocument(_: boolean): any;
        storyboard: NSStoryboard;
        window: NSWindow;
        setWindow(_: NSWindow): any;
        windowFrameAutosaveName: string;
        setWindowFrameAutosaveName(_: string): any;
        isWindowLoaded: boolean;
        windowNibName: string;
        windowNibPath: string;
        close(): void;
        dismissController(_?: any): void;
        static createWithWindow(window?: NSWindow): NSWindowController;
        static createWithWindowNibName(windowNibName: string): NSWindowController;
        static createWithWindowNibNameOwner(windowNibName: string, owner: any): NSWindowController;
        static createWithWindowNibPathOwner(windowNibPath: string, owner: any): NSWindowController;
        loadWindow(): void;
        setDocumentEdited(_: boolean): void;
        showWindow(_?: any): void;
        synchronizeWindowTitleWithDocumentName(): void;
        windowDidLoad(): void;
        windowTitleForDocumentDisplayName(forDocumentDisplayName: string): string;
        windowWillLoad(): void;
    }
    interface NSWindowDelegate extends NSObject {
        customWindowsToEnterFullScreenForWindow?(for_: NSWindow): NSWindow[];
        customWindowsToEnterFullScreenForWindowOnScreen?(for_: NSWindow, on: NSScreen): NSWindow[];
        customWindowsToExitFullScreenForWindow?(for_: NSWindow): NSWindow[];
        windowWillPositionSheetUsingRect?(_: NSWindow, willPositionSheet: NSWindow, using: CGRect): CGRect;
        windowShouldDragDocumentWithEventFromWithPasteboard?(_: NSWindow, shouldDragDocumentWith: NSEvent, from: CGPoint, with_: NSPasteboard): boolean;
        windowStartCustomAnimationToEnterFullScreenOnScreenWithDuration?(_: NSWindow, startCustomAnimationToEnterFullScreenOn: NSScreen, withDuration: number): void;
        windowDidDecodeRestorableState?(_: NSWindow, didDecodeRestorableState: NSCoder): void;
        windowShouldPopUpDocumentPathMenu?(_: NSWindow, shouldPopUpDocumentPathMenu: NSMenu): boolean;
        windowStartCustomAnimationToEnterFullScreenWithDuration?(_: NSWindow, startCustomAnimationToEnterFullScreenWithDuration: number): void;
        windowStartCustomAnimationToExitFullScreenWithDuration?(_: NSWindow, startCustomAnimationToExitFullScreenWithDuration: number): void;
        windowWillEncodeRestorableState?(_: NSWindow, willEncodeRestorableState: NSCoder): void;
        windowWillResizeForVersionBrowserWithMaxPreferredSizeMaxAllowedSize?(_: NSWindow, willResizeForVersionBrowserWithMaxPreferredSize: CGSize, maxAllowedSize: CGSize): CGSize;
        windowWillUseFullScreenContentSize?(_: NSWindow, willUseFullScreenContentSize: CGSize): CGSize;
        windowWillUseFullScreenPresentationOptions?(_: NSWindow, willUseFullScreenPresentationOptions: NSApplication.PresentationOptions): NSApplication.PresentationOptions;
        windowDidBecomeKey?(_: NSNotification): void;
        windowDidBecomeMain?(_: NSNotification): void;
        windowDidChangeBackingProperties?(_: NSNotification): void;
        windowDidChangeOcclusionState?(_: NSNotification): void;
        windowDidChangeScreen?(_: NSNotification): void;
        windowDidChangeScreenProfile?(_: NSNotification): void;
        windowDidDeminiaturize?(_: NSNotification): void;
        windowDidEndLiveResize?(_: NSNotification): void;
        windowDidEndSheet?(_: NSNotification): void;
        windowDidEnterFullScreen?(_: NSNotification): void;
        windowDidEnterVersionBrowser?(_: NSNotification): void;
        windowDidExitFullScreen?(_: NSNotification): void;
        windowDidExitVersionBrowser?(_: NSNotification): void;
        windowDidExpose?(_: NSNotification): void;
        windowDidFailToEnterFullScreen?(_: NSWindow): void;
        windowDidFailToExitFullScreen?(_: NSWindow): void;
        windowDidMiniaturize?(_: NSNotification): void;
        windowDidMove?(_: NSNotification): void;
        windowDidResignKey?(_: NSNotification): void;
        windowDidResignMain?(_: NSNotification): void;
        windowDidResize?(_: NSNotification): void;
        windowDidUpdate?(_: NSNotification): void;
        windowShouldClose?(_: NSWindow): boolean;
        windowShouldZoomToFrame?(_: NSWindow, toFrame: CGRect): boolean;
        windowWillBeginSheet?(_: NSNotification): void;
        windowWillClose?(_: NSNotification): void;
        windowWillEnterFullScreen?(_: NSNotification): void;
        windowWillEnterVersionBrowser?(_: NSNotification): void;
        windowWillExitFullScreen?(_: NSNotification): void;
        windowWillExitVersionBrowser?(_: NSNotification): void;
        windowWillMiniaturize?(_: NSNotification): void;
        windowWillMove?(_: NSNotification): void;
        windowWillResizeToSize?(_: NSWindow, to: CGSize): CGSize;
        windowWillReturnFieldEditorToObject?(_: NSWindow, to?: any): any;
        windowWillReturnUndoManager?(_: NSWindow): UndoManager;
        windowWillStartLiveResize?(_: NSNotification): void;
        windowWillUseStandardFrameDefaultFrame?(_: NSWindow, defaultFrame: CGRect): CGRect;
    }
    interface NSWindowRestoration extends NSObject {
    }
    class NSWindowTab extends NSObject {
        accessoryView: NSView;
        setAccessoryView(_: NSView): any;
        attributedTitle: NSAttributedString;
        setAttributedTitle(_: NSAttributedString): any;
        title: string;
        setTitle(_: string): any;
        toolTip: string;
        setToolTip(_: string): any;
    }
    class NSWindowTabGroup extends NSObject {
        identifier: string;
        isOverviewVisible: boolean;
        setOverviewVisible(_: boolean): any;
        selectedWindow: NSWindow;
        setSelectedWindow(_: NSWindow): any;
        isTabBarVisible: boolean;
        windows: NSWindow[];
        addWindow(_: NSWindow): void;
        insertWindowAtIndex(_: NSWindow, at: number): void;
        removeWindow(_: NSWindow): void;
    }
    class NSWorkspace extends NSObject {
        accessibilityDisplayShouldDifferentiateWithoutColor: boolean;
        accessibilityDisplayShouldIncreaseContrast: boolean;
        accessibilityDisplayShouldInvertColors: boolean;
        accessibilityDisplayShouldReduceMotion: boolean;
        accessibilityDisplayShouldReduceTransparency: boolean;
        fileLabelColors: NSColor[];
        fileLabels: string[];
        frontmostApplication: NSRunningApplication;
        menuBarOwningApplication: NSRunningApplication;
        notificationCenter: NotificationCenter;
        runningApplications: NSRunningApplication[];
        isSwitchControlEnabled: boolean;
        isVoiceOverEnabled: boolean;
        static sharedWorkspace: NSWorkspace;
        URLForApplicationToOpenURL(toOpen: NSURL): NSURL;
        URLForApplicationWithBundleIdentifier(withBundleIdentifier: string): NSURL;
        activateFileViewerSelectingURLs(_: NSURL[]): void;
        desktopImageOptionsForScreen(for_: NSScreen): Map<string, any>;
        desktopImageURLForScreen(for_: NSScreen): NSURL;
        duplicateCompletionHandler(_: NSURL[], completionHandler?: (p1: Map<NSURL, NSURL>, p2: NSError) => void): void;
        extendPowerOffBy(by: number): number;
        filenameExtensionIsValidForType(_: string, isValidForType: string): boolean;
        getFileSystemInfoForPathIsRemovableIsWritableIsUnmountableDescriptionType(forPath: string, isRemovable?: boolean, isWritable?: boolean, isUnmountable?: boolean, description?: string, type?: string): boolean;
        getInfoForFileApplicationType(_: string, application?: string, type?: string): boolean;
        hideOtherApplications(): void;
        iconForFile(forFile: string): NSImage;
        iconForFileType(forFileType: string): NSImage;
        iconForFiles(forFiles: string[]): NSImage;
        isFilePackageAtPath(atPath: string): boolean;
        launchApplicationAtURLOptionsConfigurationError(options: NSURL, configuration: NSWorkspace.LaunchOptions, error: Map<string, any>): NSRunningApplication;
        localizedDescriptionForType(forType: string): string;
        noteFileSystemChanged(_: string): void;
        openApplicationWithAtConfigurationCompletionHandler(at: NSURL, configuration: OpenConfiguration, completionHandler?: (p1: NSRunningApplication, p2: NSError) => void): void;
        openURL(_: NSURL): boolean;
        openConfigurationCompletionHandler(_: NSURL, configuration: OpenConfiguration, completionHandler?: (p1: NSRunningApplication, p2: NSError) => void): void;
        openURLOptionsConfigurationError(options: NSURL, configuration: NSWorkspace.LaunchOptions, error: Map<string, any>): NSRunningApplication;
        openWithApplicationAtConfigurationCompletionHandler(_: NSURL[], withApplicationAt: NSURL, configuration: OpenConfiguration, completionHandler?: (p1: NSRunningApplication, p2: NSError) => void): void;
        openURLsWithApplicationAtURLOptionsConfigurationError(withApplicationAtURL: NSURL[], options: NSURL, configuration: NSWorkspace.LaunchOptions, error: Map<string, any>): NSRunningApplication;
        preferredFilenameExtensionForType(forType: string): string;
        recycleCompletionHandler(_: NSURL[], completionHandler?: (p1: Map<NSURL, NSURL>, p2: NSError) => void): void;
        requestAuthorizationWithToCompletionHandler(to: NSWorkspace.AuthorizationType, completionHandler?: (p1: Authorization, p2: NSError) => void): void;
        selectFileInFileViewerRootedAtPath(_?: string, inFileViewerRootedAtPath?: string): boolean;
        setDesktopImageURLForScreenOptionsError(forScreen: NSURL, options: NSScreen, error: Map<string, any>): boolean;
        setIconForFileOptions(_?: NSImage, forFile?: string, options?: NSWorkspace.IconCreationOptions): boolean;
        showSearchResultsForQueryString(forQueryString: string): boolean;
        typeConformsToType(_: string, conformsToType: string): boolean;
        typeOfFileError(error: string): string;
        unmountAndEjectDeviceAtPath(atPath: string): boolean;
        unmountAndEjectDeviceAtURLError(error: NSURL): boolean;
    }
    class Authorization extends NSObject {
    }
    class OpenConfiguration extends NSObject {
        static configuration(): OpenConfiguration;
        activates: boolean;
        setActivates(_: boolean): any;
        addsToRecentItems: boolean;
        setAddsToRecentItems(_: boolean): any;
        allowsRunningApplicationSubstitution: boolean;
        setAllowsRunningApplicationSubstitution(_: boolean): any;
        appleEvent: NSAppleEventDescriptor;
        setAppleEvent(_: NSAppleEventDescriptor): any;
        architecture: number;
        setArchitecture(_: number): any;
        arguments: string[];
        setArguments(_: string[]): any;
        createsNewApplicationInstance: boolean;
        setCreatesNewApplicationInstance(_: boolean): any;
        environment: Map<string, string>;
        setEnvironment(_: Map<string, string>): any;
        isForPrinting: boolean;
        setForPrinting(_: boolean): any;
        hides: boolean;
        setHides(_: boolean): any;
        hidesOthers: boolean;
        setHidesOthers(_: boolean): any;
        promptsUserIfNeeded: boolean;
        setPromptsUserIfNeeded(_: boolean): any;
        requiresUniversalLinks: boolean;
        setRequiresUniversalLinks(_: boolean): any;
    }
    interface _OVFlags {
        unused3: number;
        dataSourceObjectValueByItem: number;
        allowAutomaticAnimations: number;
        dontRedisplayOnFrameChange: number;
        unused2: number;
        delegateShouldAutoExpandItem: number;
        delegateAutoCollapseItem: number;
        delegateAutoExpandItem: number;
        delegateShouldShowOutlineCellForItem: number;
        dataSourceDraggedImageMovedTo: number;
        dataSourceDraggingEndedAt: number;
        reloadingData: number;
        validDataSourceMethods: number;
        numberOfRowsDataExpandEntered: number;
        delayRowEntryFreeDisabled: number;
        delegateHeightOfRowByItem: number;
        animateExpandAndCollapse: number;
        stronglyReferencesItems: number;
        selectionAdjustmentDisabled: number;
        subclassRowForItem: number;
        delegateWillDisplayOutlineCell: number;
        enableExpandNotifications: number;
        autoSaveExpandItems: number;
        autoresizesOutlineColumn: number;
        delegateShouldExpandItem: number;
        delegateShouldCollapseItem: number;
        delegateSelectionShouldChangeInOutlineView: number;
        delegateShouldSelectTableColumn: number;
        delegateShouldSelectItem: number;
        delegateShouldEditTableColumn: number;
        delegateWillDisplayCell: number;
    }
    interface CFAllocatorContext {
        version: number;
        info: any;
        retain: (p1: any) => any;
        release: (p1: any) => void;
        copyDescription: (p1: any) => string;
        allocate: (p1: number, p2: number, p3: any) => any;
        reallocate: (p1: any, p2: number, p3: number, p4: any) => any;
        deallocate: (p1: any, p2: any) => void;
        preferredSize: (p1: number, p2: number, p3: any) => number;
    }
    interface CFArrayCallBacks {
        version: number;
        retain: (p1: any, p2: any) => any;
        release: (p1: any, p2: any) => void;
        copyDescription: (p1: any) => string;
        equal: (p1: any, p2: any) => boolean;
    }
    interface CFBagCallBacks {
        version: number;
        retain: (p1: any, p2: any) => any;
        release: (p1: any, p2: any) => void;
        copyDescription: (p1: any) => string;
        equal: (p1: any, p2: any) => boolean;
        hash: (p1: any) => number;
    }
    interface CFBinaryHeapCallBacks {
        version: number;
        retain: (p1: any, p2: any) => any;
        release: (p1: any, p2: any) => void;
        copyDescription: (p1: any) => string;
        compare: (p1: any, p2: any, p3: any) => CFComparisonResult;
    }
    interface CFBinaryHeapCompareContext {
        version: number;
        info: any;
        retain: (p1: any) => any;
        release: (p1: any) => void;
        copyDescription: (p1: any) => string;
    }
    interface CFDictionaryKeyCallBacks {
        version: number;
        retain: (p1: any, p2: any) => any;
        release: (p1: any, p2: any) => void;
        copyDescription: (p1: any) => string;
        equal: (p1: any, p2: any) => boolean;
        hash: (p1: any) => number;
    }
    interface CFDictionaryValueCallBacks {
        version: number;
        retain: (p1: any, p2: any) => any;
        release: (p1: any, p2: any) => void;
        copyDescription: (p1: any) => string;
        equal: (p1: any, p2: any) => boolean;
    }
    interface CFFileDescriptorContext {
        version: number;
        info: any;
        retain: (p1: any) => any;
        release: (p1: any) => void;
        copyDescription: (p1: any) => string;
    }
    interface CFGregorianDate {
        year: number;
        month: number;
        day: number;
        hour: number;
        minute: number;
        second: number;
    }
    interface CFGregorianUnits {
        years: number;
        months: number;
        days: number;
        hours: number;
        minutes: number;
        seconds: number;
    }
    interface CFMachPortContext {
        version: number;
        info: any;
        retain: (p1: any) => any;
        release: (p1: any) => void;
        copyDescription: (p1: any) => string;
    }
    interface CFMessagePortContext {
        version: number;
        info: any;
        retain: (p1: any) => any;
        release: (p1: any) => void;
        copyDescription: (p1: any) => string;
    }
    interface CFRange {
        location: number;
        length: number;
    }
    interface CFRunLoopObserverContext {
        version: number;
        info: any;
        retain: (p1: any) => any;
        release: (p1: any) => void;
        copyDescription: (p1: any) => string;
    }
    interface CFRunLoopSourceContext {
        version: number;
        info: any;
        retain: (p1: any) => any;
        release: (p1: any) => void;
        copyDescription: (p1: any) => string;
        equal: (p1: any, p2: any) => boolean;
        hash: (p1: any) => number;
        schedule: (p1: any, p2: any, p3: any) => void;
        cancel: (p1: any, p2: any, p3: any) => void;
        perform: (p1: any) => void;
    }
    interface CFRunLoopSourceContext1 {
        version: number;
        info: any;
        retain: (p1: any) => any;
        release: (p1: any) => void;
        copyDescription: (p1: any) => string;
        equal: (p1: any, p2: any) => boolean;
        hash: (p1: any) => number;
        getPort: (p1: any) => number;
        perform: (p1: any, p2: number, p3: any, p4: any) => any;
    }
    interface CFRunLoopTimerContext {
        version: number;
        info: any;
        retain: (p1: any) => any;
        release: (p1: any) => void;
        copyDescription: (p1: any) => string;
    }
    interface CFSetCallBacks {
        version: number;
        retain: (p1: any, p2: any) => any;
        release: (p1: any, p2: any) => void;
        copyDescription: (p1: any) => string;
        equal: (p1: any, p2: any) => boolean;
        hash: (p1: any) => number;
    }
    interface CFSocketContext {
        version: number;
        info: any;
        retain: (p1: any) => any;
        release: (p1: any) => void;
        copyDescription: (p1: any) => string;
    }
    interface CFSocketSignature {
        protocolFamily: number;
        socketType: number;
        protocol: number;
        address: NSData;
    }
    interface CFStreamClientContext {
        version: number;
        info: any;
        retain: (p1: any) => any;
        release: (p1: any) => void;
        copyDescription: (p1: any) => string;
    }
    interface CFStreamError {
        domain: number;
        error: number;
    }
    interface CFStringInlineBuffer {
        buffer: number;
        theString: string;
        directUniCharBuffer: number;
        directCStringBuffer: string;
        rangeToBuffer: CFRange;
        bufferedRangeStart: number;
        bufferedRangeEnd: number;
    }
    interface CFSwappedFloat32 {
        v: number;
    }
    interface CFSwappedFloat64 {
        v: number;
    }
    interface CFTreeContext {
        version: number;
        info: any;
        retain: (p1: any) => any;
        release: (p1: any) => void;
        copyDescription: (p1: any) => string;
    }
    interface CFUUIDBytes {
        byte0: number;
        byte1: number;
        byte2: number;
        byte3: number;
        byte4: number;
        byte5: number;
        byte6: number;
        byte7: number;
        byte8: number;
        byte9: number;
        byte10: number;
        byte11: number;
        byte12: number;
        byte13: number;
        byte14: number;
        byte15: number;
    }
    interface CFXMLAttributeDeclarationInfo {
        attributeName: string;
        typeString: string;
        defaultString: string;
    }
    interface CFXMLAttributeListDeclarationInfo {
        numberOfAttributes: number;
        attributes: CFXMLAttributeDeclarationInfo;
    }
    interface CFXMLDocumentInfo {
        sourceURL: NSURL;
        encoding: number;
    }
    interface CFXMLDocumentTypeInfo {
        externalID: CFXMLExternalID;
    }
    interface CFXMLElementInfo {
        attributes: Map<any, any>;
        attributeOrder: any[];
        isEmpty: boolean;
    }
    interface CFXMLElementTypeDeclarationInfo {
        contentDescription: string;
    }
    interface CFXMLEntityInfo {
        entityType: CFXMLEntityTypeCode;
        replacementText: string;
        entityID: CFXMLExternalID;
        notationName: string;
    }
    interface CFXMLEntityReferenceInfo {
        entityType: CFXMLEntityTypeCode;
    }
    interface CFXMLExternalID {
        systemID: NSURL;
        publicID: string;
    }
    interface CFXMLNotationInfo {
        externalID: CFXMLExternalID;
    }
    interface CFXMLParserCallBacks {
        version: number;
        createXMLStructure: (p1: any, p2: any, p3: any) => any;
        addChild: (p1: any, p2: any, p3: any, p4: any) => void;
        endXMLStructure: (p1: any, p2: any, p3: any) => void;
        resolveExternalEntity: (p1: any, p2: CFXMLExternalID, p3: any) => NSData;
        handleError: (p1: any, p2: CFXMLParserStatusCode, p3: any) => boolean;
    }
    interface CFXMLParserContext {
        version: number;
        info: any;
        retain: (p1: any) => any;
        release: (p1: any) => void;
        copyDescription: (p1: any) => string;
    }
    interface CFXMLProcessingInstructionInfo {
        dataString: string;
    }
    interface IUnknownVTbl {
        QueryInterface: (p1: any, p2: CFUUIDBytes, p3: any) => number;
        AddRef: (p1: any) => number;
        Release: (p1: any) => number;
    }
    class NSAffineTransform extends NSObject {
        transformStruct: NSAffineTransformStruct;
        setTransformStruct(_: NSAffineTransformStruct): any;
        appendTransform(_: NSAffineTransform): void;
        concat(): void;
        static createWithTransform(transform: NSAffineTransform): NSAffineTransform;
        invert(): void;
        prependTransform(_: NSAffineTransform): void;
        rotateByDegrees(byDegrees: number): void;
        rotateByRadians(byRadians: number): void;
        scaleBy(by: number): void;
        scaleXByYBy(by: number, yBy: number): void;
        set(): void;
        transformBezierPath(_: NSBezierPath): NSBezierPath;
        transformPoint(_: CGPoint): CGPoint;
        transformSize(_: CGSize): CGSize;
        translateXByYBy(by: number, yBy: number): void;
    }
    interface NSAffineTransformStruct {
        m11: number;
        m12: number;
        m21: number;
        m22: number;
        tX: number;
        tY: number;
    }
    class NSAppleEventDescriptor extends NSObject {
        static appleEventWithEventClassEventIDTargetDescriptorReturnIDTransactionID(withEventClass: number, eventID: number, targetDescriptor?: NSAppleEventDescriptor, returnID?: number, transactionID?: number): NSAppleEventDescriptor;
        static currentProcessDescriptor(): NSAppleEventDescriptor;
        static listDescriptor(): NSAppleEventDescriptor;
        static nullDescriptor(): NSAppleEventDescriptor;
        static recordDescriptor(): NSAppleEventDescriptor;
        aeDesc: AE.AEDataModel;
        booleanValue: boolean;
        data: NSData;
        dateValue: Date;
        descriptorType: number;
        doubleValue: number;
        enumCodeValue: number;
        eventClass: number;
        eventID: number;
        fileURLValue: NSURL;
        int32Value: number;
        isRecordDescriptor: boolean;
        numberOfItems: number;
        returnID: number;
        stringValue: string;
        transactionID: number;
        typeCodeValue: number;
        attributeDescriptorForKeyword(forKeyword: number): NSAppleEventDescriptor;
        coerceToDescriptorType(toDescriptorType: number): NSAppleEventDescriptor;
        descriptorAtIndex(_: number): NSAppleEventDescriptor;
        descriptorForKeyword(_: number): NSAppleEventDescriptor;
        static createWithListDescriptor(): NSAppleEventDescriptor;
        static createWithRecordDescriptor(): NSAppleEventDescriptor;
        static createWithAEDescNoCopy(AEDescNoCopy: AE.AEDataModel): NSAppleEventDescriptor;
        static createWithDescriptorTypeBytesLength(descriptorType: number, bytes?: any, length?: number): NSAppleEventDescriptor;
        static createWithDescriptorTypeData(descriptorType: number, data?: NSData): NSAppleEventDescriptor;
        static createWithEventClassEventIDTargetDescriptorReturnIDTransactionID(eventClass: number, eventID: number, targetDescriptor?: NSAppleEventDescriptor, returnID?: number, transactionID?: number): NSAppleEventDescriptor;
        insertDescriptorAtIndex(_: NSAppleEventDescriptor, at: number): void;
        keywordForDescriptorAtIndex(at: number): number;
        paramDescriptorForKeyword(forKeyword: number): NSAppleEventDescriptor;
        removeDescriptorAtIndex(at: number): void;
        removeDescriptorWithKeyword(withKeyword: number): void;
        removeParamDescriptorWithKeyword(withKeyword: number): void;
        sendEventWithOptionsTimeoutError(timeout: NSAppleEventDescriptor.SendOptions, error: number): NSAppleEventDescriptor;
        setAttributeDescriptorForKeyword(_: NSAppleEventDescriptor, forKeyword: number): void;
        setDescriptorForKeyword(_: NSAppleEventDescriptor, forKeyword: number): void;
        setParamDescriptorForKeyword(_: NSAppleEventDescriptor, forKeyword: number): void;
    }
    class NSAppleEventManager extends NSObject {
        static sharedAppleEventManager(): NSAppleEventManager;
        currentAppleEvent: NSAppleEventDescriptor;
        currentReplyAppleEvent: NSAppleEventDescriptor;
        appleEventForSuspensionID(forSuspensionID: any): NSAppleEventDescriptor;
        dispatchRawAppleEventWithRawReplyHandlerRefCon(_: AE.AEDataModel, withRawReply: AE.AEDataModel, handlerRefCon: any): number;
        removeEventHandlerForEventClassAndEventID(forEventClass: number, andEventID: number): void;
        replyAppleEventForSuspensionID(forSuspensionID: any): NSAppleEventDescriptor;
        resumeWithSuspensionID(withSuspensionID: any): void;
        setCurrentAppleEventAndReplyEventWithSuspensionID(_: any): void;
        setEventHandlerAndSelectorForEventClassAndEventID(_: any, andSelector: string, forEventClass: number, andEventID: number): void;
        suspendCurrentAppleEvent(): any;
    }
    class NSAppleScript extends NSObject {
        isCompiled: boolean;
        richTextSource: NSAttributedString;
        source: string;
        compileAndReturnError(_?: Map<string, any>): boolean;
        executeAndReturnError(_?: Map<string, any>): NSAppleEventDescriptor;
        executeAppleEventError(_: NSAppleEventDescriptor, error?: Map<string, any>): NSAppleEventDescriptor;
        static createWithContentsOfURLError(contentsOfURL: NSURL, error?: Map<string, any>): NSAppleScript;
        static createWithSource(source: string): NSAppleScript;
    }
    class NSArray<ObjectType> extends NSObject {
        static arrayWithObjects<ObjectType>(_: ObjectType): NSArray<ObjectType>;
        count: number;
        firstObject: ObjectType;
        lastObject: ObjectType;
        sortedArrayHint: NSData;
        addObserverToObjectsAtIndexesForKeyPathOptionsContext(_: NSObject, toObjectsAt: NSIndexSet, forKeyPath: string, options: NSKeyValueObservingOptions, context?: any): void;
        arrayByAddingObject(_: ObjectType): ObjectType[];
        arrayByAddingObjectsFromArray(from: ObjectType[]): ObjectType[];
        componentsJoinedByString(by: string): string;
        containsObject(_: ObjectType): boolean;
        descriptionWithLocale(withLocale?: any): string;
        descriptionWithLocaleIndent(withLocale?: any, indent?: number): string;
        enumerateObjectsWithAtOptionsUsing(at: NSIndexSet, options: NSEnumerationOptions, using: (p1: ObjectType, p2: number, p3: boolean) => void): void;
        enumerateObjects(_: (p1: ObjectType, p2: number, p3: boolean) => void): void;
        enumerateObjectsWithOptionsUsing(options: NSEnumerationOptions, using: (p1: ObjectType, p2: number, p3: boolean) => void): void;
        filteredArrayUsingPredicate(using: NSPredicate): ObjectType[];
        firstObjectCommonWithArray(with_: ObjectType[]): ObjectType;
        indexOfObject(of: ObjectType): number;
        indexOfObjectInRange(of: ObjectType, in_: NSRange): number;
        indexOfInSortedRangeOptionsUsingComparator(of: ObjectType, inSortedRange: NSRange, options: NSBinarySearchingOptions, usingComparator: (p1: any, p2: any) => ComparisonResult): number;
        indexOfObjectWithAtOptionsPassingTest(at: NSIndexSet, options: NSEnumerationOptions, passingTest: (p1: ObjectType, p2: number, p3: boolean) => boolean): number;
        indexOfObjectIdenticalTo(to: ObjectType): number;
        indexOfObjectIdenticalToInRange(to: ObjectType, in_: NSRange): number;
        indexOfObjectWithPassingTest(passingTest: (p1: ObjectType, p2: number, p3: boolean) => boolean): number;
        indexOfObjectWithOptionsPassingTest(options: NSEnumerationOptions, passingTest: (p1: ObjectType, p2: number, p3: boolean) => boolean): number;
        indexesOfObjectsWithAtOptionsPassingTest(at: NSIndexSet, options: NSEnumerationOptions, passingTest: (p1: ObjectType, p2: number, p3: boolean) => boolean): NSIndexSet;
        indexesOfObjectsWithPassingTest(passingTest: (p1: ObjectType, p2: number, p3: boolean) => boolean): NSIndexSet;
        indexesOfObjectsWithOptionsPassingTest(options: NSEnumerationOptions, passingTest: (p1: ObjectType, p2: number, p3: boolean) => boolean): NSIndexSet;
        isEqualToArray(to: ObjectType[]): boolean;
        objectAtIndex(at: number): ObjectType;
        objectEnumerator(): NSEnumerator<ObjectType>;
        objectsAtIndexes(at: NSIndexSet): ObjectType[];
        pathsMatchingExtensions(_: string[]): string[];
        removeObserverFromObjectsAtIndexesForKeyPath(_: NSObject, fromObjectsAt: NSIndexSet, forKeyPath: string): void;
        removeObserverFromObjectsAtIndexesForKeyPathContext(_: NSObject, fromObjectsAt: NSIndexSet, forKeyPath: string, context?: any): void;
        reverseObjectEnumerator(): NSEnumerator<ObjectType>;
        sortedArrayWithComparator(comparator: (p1: any, p2: any) => ComparisonResult): ObjectType[];
        sortedArrayUsingDescriptors(using: NSSortDescriptor[]): ObjectType[];
        sortedArrayContext(_?: (p1: ObjectType, p2: ObjectType, p3: any) => number, context?: any): ObjectType[];
        sortedArrayContextHint(_?: (p1: ObjectType, p2: ObjectType, p3: any) => number, context?: any, hint?: NSData): ObjectType[];
        sortedArrayUsingSelector(using: string): ObjectType[];
        sortedArrayWithOptionsUsingComparator(options: NSSortOptions, usingComparator: (p1: any, p2: any) => ComparisonResult): ObjectType[];
        subarrayWithRange(with_: NSRange): ObjectType[];
        writeToFileAtomically(toFile: string, atomically: boolean): boolean;
        writeToURLAtomically(to: NSURL, atomically: boolean): boolean;
        writeToURLError(error: NSURL): boolean;
    }
    class NSAssertionHandler extends NSObject {
        static currentHandler: NSAssertionHandler;
    }
    class NSAttributedString extends NSObject {
        containsAttachments: boolean;
        length: number;
        string: string;
        static textTypes: string[];
        static textUnfilteredTypes: string[];
        RTFDFileWrapperFromRangeDocumentAttributes(from: NSRange, documentAttributes: Map<string, any>): FileWrapper;
        RTFDFromRangeDocumentAttributes(from: NSRange, documentAttributes: Map<string, any>): NSData;
        RTFFromRangeDocumentAttributes(from: NSRange, documentAttributes: Map<string, any>): NSData;
        attributeAtIndexEffectiveRange(_: string, at: number, effectiveRange?: NSRange): any;
        attributeAtIndexLongestEffectiveRangeInRange(_: string, at: number, longestEffectiveRange?: NSRange, in_?: NSRange): any;
        attributedSubstringFromRange(from: NSRange): NSAttributedString;
        attributesAtIndexEffectiveRange(at: number, effectiveRange?: NSRange): Map<string, any>;
        attributesAtIndexLongestEffectiveRangeInRange(at: number, longestEffectiveRange?: NSRange, in_?: NSRange): Map<string, any>;
        boundingRectWithSizeOptions(with_: CGSize, options: NSString.DrawingOptions): CGRect;
        boundingRectWithSizeOptionsContext(with_: CGSize, options: NSString.DrawingOptions, context?: NSStringDrawingContext): CGRect;
        containsAttachmentsInRange(in_: NSRange): boolean;
        dataFromRangeDocumentAttributesError(documentAttributes: NSRange, error: Map<string, any>): NSData;
        docFormatFromRangeDocumentAttributes(from: NSRange, documentAttributes: Map<string, any>): NSData;
        doubleClickAtIndex(at: number): NSRange;
        drawAtPoint(at: CGPoint): void;
        drawInRect(in_: CGRect): void;
        drawWithRectOptions(with_: CGRect, options: NSString.DrawingOptions): void;
        drawWithRectOptionsContext(with_: CGRect, options: NSString.DrawingOptions, context?: NSStringDrawingContext): void;
        enumerateAttributeInOptionsUsing(_: string, in_: NSRange, options: NSAttributedString.EnumerationOptions, using?: (p1: any, p2: NSRange, p3: boolean) => void): void;
        enumerateAttributesWithInOptionsUsing(in_: NSRange, options: NSAttributedString.EnumerationOptions, using: (p1: Map<string, any>, p2: NSRange, p3: boolean) => void): void;
        fileWrapperFromRangeDocumentAttributesError(documentAttributes: NSRange, error: Map<string, any>): FileWrapper;
        fontAttributesInRange(in_: NSRange): Map<string, any>;
        static createWithAttributedString(attributedString: NSAttributedString): NSAttributedString;
        static createWithDataOptionsDocumentAttributes(data: NSData, options: Map<string, any>, documentAttributes?: Map<string, any>): NSAttributedString;
        static createWithDocFormatDocumentAttributes(docFormat: NSData, documentAttributes?: Map<string, any>): NSAttributedString;
        static createWithHtmlBaseURLDocumentAttributes(HTML: NSData, baseURL: NSURL, documentAttributes?: Map<string, any>): NSAttributedString;
        static createWithHtmlDocumentAttributes(HTML: NSData, documentAttributes?: Map<string, any>): NSAttributedString;
        static createWithHtmlOptionsDocumentAttributes(HTML: NSData, options: Map<string, any>, documentAttributes?: Map<string, any>): NSAttributedString;
        static createWithRtfDocumentAttributes(RTF: NSData, documentAttributes?: Map<string, any>): NSAttributedString;
        static createWithRtfdDocumentAttributes(RTFD: NSData, documentAttributes?: Map<string, any>): NSAttributedString;
        static createWithRTFDFileWrapperDocumentAttributes(RTFDFileWrapper: FileWrapper, documentAttributes?: Map<string, any>): NSAttributedString;
        static createWithString(string: string): NSAttributedString;
        static createWithStringAttributes(string: string, attributes?: Map<string, any>): NSAttributedString;
        static createWithUrlOptionsDocumentAttributes(URL: NSURL, options: Map<string, any>, documentAttributes?: Map<string, any>): NSAttributedString;
        isEqualToAttributedString(to: NSAttributedString): boolean;
        itemNumberInTextListAtIndex(in_: NSTextList, at: number): number;
        lineBreakBeforeIndexWithinRange(before: number, within: NSRange): number;
        lineBreakByHyphenatingBeforeIndexWithinRange(before: number, within: NSRange): number;
        nextWordFromIndexForward(from: number, forward: boolean): number;
        rangeOfTextBlockAtIndex(of: NSTextBlock, at: number): NSRange;
        rangeOfTextListAtIndex(of: NSTextList, at: number): NSRange;
        rangeOfTextTableAtIndex(of: NSTextTable, at: number): NSRange;
        rulerAttributesInRange(in_: NSRange): Map<string, any>;
        size(): CGSize;
    }
    class NSAutoreleasePool extends NSObject {
        static addObject(_: any): void;
        static showPools(): void;
        addObject(_: any): void;
        drain(): void;
    }
    class NSBackgroundActivityScheduler extends NSObject {
        identifier: string;
        interval: number;
        setInterval(_: number): any;
        qualityOfService: QualityOfService;
        setQualityOfService(_: QualityOfService): any;
        repeats: boolean;
        setRepeats(_: boolean): any;
        shouldDefer: boolean;
        tolerance: number;
        setTolerance(_: number): any;
        static createWithIdentifier(identifier: string): NSBackgroundActivityScheduler;
        invalidate(): void;
        schedule(_: (p1: (p1: NSBackgroundActivityScheduler.Result) => void) => void): void;
    }
    class BlockOperation extends Operation {
        static blockOperationWithBlock(_: () => void): BlockOperation;
        executionBlocks: () => void[];
        addExecutionBlock(_: () => void): void;
    }
    class Bundle extends NSObject {
        static URLForResourceWithExtensionSubdirectoryInBundleWithURL(forResource?: string, withExtension?: string, subdirectory?: string, in_?: NSURL): NSURL;
        static URLsForResourcesWithExtensionSubdirectoryInBundleWithURL(forResourcesWithExtension?: string, subdirectory?: string, in_?: NSURL): NSURL[];
        static pathForResourceOfTypeInDirectory(forResource?: string, ofType?: string, inDirectory?: string): string;
        static pathsForResourcesOfTypeInDirectory(forResourcesOfType?: string, inDirectory?: string): string[];
        static preferredLocalizationsFromArray(_: string[]): string[];
        static preferredLocalizationsFromArrayForPreferences(_: string[], forPreferences?: string[]): string[];
        appStoreReceiptURL: NSURL;
        builtInPlugInsPath: string;
        builtInPlugInsURL: NSURL;
        bundleIdentifier: string;
        bundlePath: string;
        bundleURL: NSURL;
        developmentLocalization: string;
        executableArchitectures: number[];
        executablePath: string;
        executableURL: NSURL;
        infoDictionary: Map<string, any>;
        isLoaded: boolean;
        localizations: string[];
        localizedInfoDictionary: Map<string, any>;
        preferredLocalizations: string[];
        principalClass: typeof NSObject;
        privateFrameworksPath: string;
        privateFrameworksURL: NSURL;
        resourcePath: string;
        resourceURL: NSURL;
        sharedFrameworksPath: string;
        sharedFrameworksURL: NSURL;
        sharedSupportPath: string;
        sharedSupportURL: NSURL;
        static allBundles: Bundle[];
        static allFrameworks: Bundle[];
        static mainBundle: Bundle;
        URLForAuxiliaryExecutable(forAuxiliaryExecutable: string): NSURL;
        URLForImageResource(_: string): NSURL;
        URLForResourceWithExtension(forResource?: string, withExtension?: string): NSURL;
        URLForResourceWithExtensionSubdirectory(forResource?: string, withExtension?: string, subdirectory?: string): NSURL;
        URLForResourceWithExtensionSubdirectoryLocalization(_?: string, withExtension?: string, subdirectory?: string, localization?: string): NSURL;
        URLsForResourcesWithExtensionSubdirectory(forResourcesWithExtension?: string, subdirectory?: string): NSURL[];
        URLsForResourcesWithExtensionSubdirectoryLocalization(forResourcesWithExtension?: string, subdirectory?: string, localization?: string): NSURL[];
        classNamed(_: string): typeof NSObject;
        contextHelpForKey(_: string): NSAttributedString;
        imageForResource(_: string): NSImage;
        static createWithPath(path: string): Bundle;
        static createWithUrl(URL: NSURL): Bundle;
        loadAndReturnError(): boolean;
        loadNibNamedOwnerTopLevelObjects(_: string, owner?: any, topLevelObjects?: any[]): boolean;
        localizedStringForKeyValueTable(_: string, value?: string, table?: string): string;
        objectForInfoDictionaryKey(forInfoDictionaryKey: string): any;
        pathForAuxiliaryExecutable(forAuxiliaryExecutable: string): string;
        pathForImageResource(_: string): string;
        pathForResourceOfType(forResource?: string, ofType?: string): string;
        pathForResourceOfTypeInDirectory(forResource?: string, ofType?: string, inDirectory?: string): string;
        pathForResourceOfTypeInDirectoryForLocalization(forResource?: string, ofType?: string, inDirectory?: string, forLocalization?: string): string;
        pathForSoundResource(_: string): string;
        pathsForResourcesOfTypeInDirectory(forResourcesOfType?: string, inDirectory?: string): string[];
        pathsForResourcesOfTypeInDirectoryForLocalization(forResourcesOfType?: string, inDirectory?: string, forLocalization?: string): string[];
        preflightAndReturnError(): boolean;
        unload(): boolean;
    }
    class ByteCountFormatter extends Formatter {
        static stringFromByteCountCountStyle(_: number, countStyle: ByteCountFormatter.CountStyle): string;
        static stringFromMeasurementWithCountStyle(_: NSMeasurement<NSUnitInformationStorage>, countStyle: ByteCountFormatter.CountStyle): string;
        isAdaptive: boolean;
        setAdaptive(_: boolean): any;
        allowedUnits: ByteCountFormatter.Units;
        setAllowedUnits(_: ByteCountFormatter.Units): any;
        allowsNonnumericFormatting: boolean;
        setAllowsNonnumericFormatting(_: boolean): any;
        countStyle: ByteCountFormatter.CountStyle;
        setCountStyle(_: ByteCountFormatter.CountStyle): any;
        formattingContext: Formatter.Context;
        setFormattingContext(_: Formatter.Context): any;
        includesActualByteCount: boolean;
        setIncludesActualByteCount(_: boolean): any;
        includesCount: boolean;
        setIncludesCount(_: boolean): any;
        includesUnit: boolean;
        setIncludesUnit(_: boolean): any;
        zeroPadsFractionDigits: boolean;
        setZeroPadsFractionDigits(_: boolean): any;
        stringFromByteCount(fromByteCount: number): string;
        stringFromMeasurement(_: NSMeasurement<NSUnitInformationStorage>): string;
    }
    class NSCache<KeyType, ObjectType> extends NSObject {
        countLimit: number;
        setCountLimit(_: number): any;
        delegate: NSCacheDelegate;
        setDelegate(_: NSCacheDelegate): any;
        evictsObjectsWithDiscardedContent: boolean;
        setEvictsObjectsWithDiscardedContent(_: boolean): any;
        name: string;
        setName(_: string): any;
        totalCostLimit: number;
        setTotalCostLimit(_: number): any;
        objectForKey(forKey: KeyType): ObjectType;
        removeAllObjects(): void;
        removeObjectForKey(forKey: KeyType): void;
        setObjectForKey(_: ObjectType, forKey: KeyType): void;
        setObjectForKeyCost(_: ObjectType, forKey: KeyType, cost: number): void;
    }
    interface NSCacheDelegate extends NSObject {
        cacheWillEvictObject?(_: NSCache<any, any>, willEvictObject: any): void;
    }
    class CachedURLResponse extends NSObject {
        data: NSData;
        response: URLResponse;
        storagePolicy: URLCache.StoragePolicy;
        userInfo: Map<any, any>;
        static createWithResponseData(response: URLResponse, data: NSData): CachedURLResponse;
        static createWithResponseDataUserInfoStoragePolicy(response: URLResponse, data: NSData, userInfo?: Map<any, any>, storagePolicy?: URLCache.StoragePolicy): CachedURLResponse;
    }
    class NSCalendar extends NSObject {
        AMSymbol: string;
        PMSymbol: string;
        calendarIdentifier: string;
        eraSymbols: string[];
        firstWeekday: number;
        setFirstWeekday(_: number): any;
        locale: NSLocale;
        setLocale(_: NSLocale): any;
        longEraSymbols: string[];
        minimumDaysInFirstWeek: number;
        setMinimumDaysInFirstWeek(_: number): any;
        monthSymbols: string[];
        quarterSymbols: string[];
        shortMonthSymbols: string[];
        shortQuarterSymbols: string[];
        shortStandaloneMonthSymbols: string[];
        shortStandaloneQuarterSymbols: string[];
        shortStandaloneWeekdaySymbols: string[];
        shortWeekdaySymbols: string[];
        standaloneMonthSymbols: string[];
        standaloneQuarterSymbols: string[];
        standaloneWeekdaySymbols: string[];
        timeZone: NSTimeZone;
        setTimeZone(_: NSTimeZone): any;
        veryShortMonthSymbols: string[];
        veryShortStandaloneMonthSymbols: string[];
        veryShortStandaloneWeekdaySymbols: string[];
        veryShortWeekdaySymbols: string[];
        weekdaySymbols: string[];
        static autoupdatingCurrentCalendar: NSCalendar;
        static currentCalendar: NSCalendar;
        compareDateToDateToUnitGranularity(_: Date, to: Date, toUnitGranularity: NSCalendar.Unit): ComparisonResult;
        componentFromDate(_: NSCalendar.Unit, from: Date): number;
        componentsFromDate(_: NSCalendar.Unit, from: Date): NSDateComponents;
        componentsFromDateToDateOptions(_: NSCalendar.Unit, from: Date, to: Date, options: NSCalendar.Options): NSDateComponents;
        componentsFromDateComponentsToDateComponentsOptions(_: NSCalendar.Unit, from: NSDateComponents, to: NSDateComponents, options: NSCalendar.Options): NSDateComponents;
        componentsInTimeZoneFromDate(in_: NSTimeZone, from: Date): NSDateComponents;
        dateMatchesComponents(_: Date, matchesComponents: NSDateComponents): boolean;
        dateByAddingComponentsToDateOptions(byAdding: NSDateComponents, to: Date, options: NSCalendar.Options): Date;
        dateByAddingUnitValueToDateOptions(byAdding: NSCalendar.Unit, value: number, to: Date, options: NSCalendar.Options): Date;
        dateBySettingHourMinuteSecondOfDateOptions(bySettingHour: number, minute: number, second: number, of: Date, options: NSCalendar.Options): Date;
        dateBySettingUnitValueOfDateOptions(bySettingUnit: NSCalendar.Unit, value: number, of: Date, options: NSCalendar.Options): Date;
        dateFromComponents(from: NSDateComponents): Date;
        dateWithEraYearMonthDayHourMinuteSecondNanosecond(era: number, year: number, month: number, day: number, hour: number, minute: number, second: number, nanosecond: number): Date;
        dateWithEraYearForWeekOfYearWeekOfYearWeekdayHourMinuteSecondNanosecond(era: number, yearForWeekOfYear: number, weekOfYear: number, weekday: number, hour: number, minute: number, second: number, nanosecond: number): Date;
        enumerateDatesWithStartingAfterMatchingOptionsUsing(startingAfter: Date, matching: NSDateComponents, options: NSCalendar.Options, using?: (p1: Date, p2: boolean, p3: boolean) => void): void;
        getEraYearMonthDayFromDate(_?: number, year?: number, month?: number, day?: number, from?: Date): void;
        getEraYearForWeekOfYearWeekOfYearWeekdayFromDate(_?: number, yearForWeekOfYear?: number, weekOfYear?: number, weekday?: number, from?: Date): void;
        getHourMinuteSecondNanosecondFromDate(_?: number, minute?: number, second?: number, nanosecond?: number, from?: Date): void;
        static createWithCalendarIdentifier(calendarIdentifier: string): NSCalendar;
        isDateEqualToDateToUnitGranularity(_: Date, equalTo: Date, toUnitGranularity: NSCalendar.Unit): boolean;
        isDateInSameDayAsDate(_: Date, inSameDayAs: Date): boolean;
        isDateInToday(_: Date): boolean;
        isDateInTomorrow(_: Date): boolean;
        isDateInWeekend(_: Date): boolean;
        isDateInYesterday(_: Date): boolean;
        maximumRangeOfUnit(of: NSCalendar.Unit): NSRange;
        minimumRangeOfUnit(of: NSCalendar.Unit): NSRange;
        nextDateAfterDateMatchingComponentsOptions(after: Date, matching: NSDateComponents, options: NSCalendar.Options): Date;
        nextDateAfterDateMatchingHourMinuteSecondOptions(after: Date, matchingHour: number, minute: number, second: number, options: NSCalendar.Options): Date;
        nextDateAfterDateMatchingUnitValueOptions(after: Date, matching: NSCalendar.Unit, value: number, options: NSCalendar.Options): Date;
        nextWeekendStartDateIntervalOptionsAfterDate(_?: Date, interval?: number, options?: NSCalendar.Options, after?: Date): boolean;
        ordinalityOfUnitInUnitForDate(of: NSCalendar.Unit, in_: NSCalendar.Unit, for_: Date): number;
        rangeOfUnitInUnitForDate(of: NSCalendar.Unit, in_: NSCalendar.Unit, for_: Date): NSRange;
        rangeOfUnitStartDateIntervalForDate(of: NSCalendar.Unit, start?: Date, interval?: number, for_?: Date): boolean;
        rangeOfWeekendStartDateIntervalContainingDate(ofWeekendStart?: Date, interval?: number, containing?: Date): boolean;
        startOfDayForDate(for_: Date): Date;
    }
    class NSCharacterSet extends NSObject {
        bitmapRepresentation: NSData;
        invertedSet: NSCharacterSet;
        static URLFragmentAllowedCharacterSet: NSCharacterSet;
        static URLHostAllowedCharacterSet: NSCharacterSet;
        static URLPasswordAllowedCharacterSet: NSCharacterSet;
        static URLPathAllowedCharacterSet: NSCharacterSet;
        static URLQueryAllowedCharacterSet: NSCharacterSet;
        static URLUserAllowedCharacterSet: NSCharacterSet;
        static alphanumericCharacterSet: NSCharacterSet;
        static capitalizedLetterCharacterSet: NSCharacterSet;
        static controlCharacterSet: NSCharacterSet;
        static decimalDigitCharacterSet: NSCharacterSet;
        static decomposableCharacterSet: NSCharacterSet;
        static illegalCharacterSet: NSCharacterSet;
        static letterCharacterSet: NSCharacterSet;
        static lowercaseLetterCharacterSet: NSCharacterSet;
        static newlineCharacterSet: NSCharacterSet;
        static nonBaseCharacterSet: NSCharacterSet;
        static punctuationCharacterSet: NSCharacterSet;
        static symbolCharacterSet: NSCharacterSet;
        static uppercaseLetterCharacterSet: NSCharacterSet;
        static whitespaceAndNewlineCharacterSet: NSCharacterSet;
        static whitespaceCharacterSet: NSCharacterSet;
        characterIsMember(_: string): boolean;
        hasMemberInPlane(_: number): boolean;
        isSupersetOfSet(of: NSCharacterSet): boolean;
        longCharacterIsMember(_: number): boolean;
    }
    class NSClassDescription extends NSObject {
        static invalidateClassDescriptionCache(): void;
        static registerClassDescriptionForClass(_: NSClassDescription, for_: typeof NSObject): void;
    }
    class NSCloneCommand extends NSScriptCommand {
        keySpecifier: NSScriptObjectSpecifier;
        setReceiversSpecifier(_?: NSScriptObjectSpecifier): void;
    }
    class NSCloseCommand extends NSScriptCommand {
        saveOptions: NSSaveOptions;
    }
    class NSCoder extends NSObject {
        allowedClasses: NSSet<typeof NSObject>;
        allowsKeyedCoding: boolean;
        decodingFailurePolicy: NSCoder.DecodingFailurePolicy;
        error: NSError;
        requiresSecureCoding: boolean;
        systemVersion: number;
        containsValueForKey(forKey: string): boolean;
        decodeArrayOfObjCTypeCountAt(ofObjCType: string, count: number, at: any): void;
        decodeBoolForKey(forKey: string): boolean;
        decodeBytesForKeyReturnedLength(forKey: string, returnedLength?: number): string;
        decodeBytesWithReturnedLength(withReturnedLength: number): any;
        decodeDataObject(): NSData;
        decodeDoubleForKey(forKey: string): number;
        decodeFloatForKey(forKey: string): number;
        decodeInt32ForKey(forKey: string): number;
        decodeInt64ForKey(forKey: string): number;
        decodeIntForKey(forKey: string): number;
        decodeIntegerForKey(forKey: string): number;
        decodeObject(): any;
        decodeObjectForKey(forKey: string): any;
        decodePoint(): CGPoint;
        decodePointForKey(forKey: string): CGPoint;
        decodePropertyList(): any;
        decodePropertyListForKey(forKey: string): any;
        decodeRect(): CGRect;
        decodeRectForKey(forKey: string): CGRect;
        decodeSize(): CGSize;
        decodeSizeForKey(forKey: string): CGSize;
        decodeValueOfObjCTypeAt(ofObjCType: string, at: any): void;
        decodeValueOfObjCTypeAtSize(ofObjCType: string, at: any, size: number): void;
        encodeArrayOfObjCTypeCountAt(ofObjCType: string, count: number, at: any): void;
        encodeBoolForKey(_: boolean, forKey: string): void;
        encodeBycopyObject(_?: any): void;
        encodeByrefObject(_?: any): void;
        encodeBytesLength(_?: any, length?: number): void;
        encodeBytesLengthForKey(_?: string, length?: number, forKey?: string): void;
        encodeConditionalObject(_?: any): void;
        encodeConditionalObjectForKey(_?: any, forKey?: string): void;
        encodeDataObject(_: NSData): void;
        encodeDoubleForKey(_: number, forKey: string): void;
        encodeFloatForKey(_: number, forKey: string): void;
        encodeInt32ForKey(_: number, forKey: string): void;
        encodeInt64ForKey(_: number, forKey: string): void;
        encodeIntForKey(_: number, forKey: string): void;
        encodeIntegerForKey(_: number, forKey: string): void;
        encodeObject(_?: any): void;
        encodeObjectForKey(_?: any, forKey?: string): void;
        encodePoint(_: CGPoint): void;
        encodePointForKey(_: CGPoint, forKey: string): void;
        encodePropertyList(_: any): void;
        encodeRect(_: CGRect): void;
        encodeRectForKey(_: CGRect, forKey: string): void;
        encodeRootObject(_: any): void;
        encodeSize(_: CGSize): void;
        encodeSizeForKey(_: CGSize, forKey: string): void;
        encodeValueOfObjCTypeAt(ofObjCType: string, at: any): void;
        failWithError(_: NSError): void;
        versionForClassName(forClassName: string): number;
    }
    interface NSCoding {
        encodeWithCoder(with_: NSCoder): void;
    }
    class NSComparisonPredicate extends NSPredicate {
        comparisonPredicateModifier: NSComparisonPredicate.Modifier;
        customSelector: string;
        leftExpression: NSExpression;
        options: NSComparisonPredicate.Options;
        predicateOperatorType: NSComparisonPredicate.Operator;
        rightExpression: NSExpression;
        static createWithLeftExpressionRightExpressionCustomSelector(leftExpression: NSExpression, rightExpression: NSExpression, customSelector: string): NSComparisonPredicate;
        static createWithLeftExpressionRightExpressionModifierTypeOptions(leftExpression: NSExpression, rightExpression: NSExpression, modifier: NSComparisonPredicate.Modifier, type: NSComparisonPredicate.Operator, options: NSComparisonPredicate.Options): NSComparisonPredicate;
    }
    class NSCompoundPredicate extends NSPredicate {
        compoundPredicateType: NSCompoundPredicate.LogicalType;
        subpredicates: any[];
        static createWithTypeSubpredicates(type: NSCompoundPredicate.LogicalType, subpredicates: NSPredicate[]): NSCompoundPredicate;
    }
    class NSCondition extends NSObject {
        name: string;
        setName(_: string): any;
        broadcast(): void;
        signal(): void;
        wait(): void;
        waitUntilDate(until: Date): boolean;
    }
    class NSConditionLock extends NSObject {
        condition: number;
        name: string;
        setName(_: string): any;
        static createWithCondition(condition: number): NSConditionLock;
        lockBeforeDate(before: Date): boolean;
        lockWhenCondition(whenCondition: number): void;
        lockWhenConditionBeforeDate(whenCondition: number, before: Date): boolean;
        tryLock(): boolean;
        tryLockWhenCondition(whenCondition: number): boolean;
        unlockWithCondition(withCondition: number): void;
    }
    interface NSCopying {
    }
    class NSCountCommand extends NSScriptCommand {
    }
    class NSCountedSet<ObjectType> extends NSMutableSet<ObjectType> {
        countForObject(for_: ObjectType): number;
    }
    class NSCreateCommand extends NSScriptCommand {
        createClassDescription: NSScriptClassDescription;
        resolvedKeyDictionary: Map<string, any>;
    }
    class NSData extends NSObject {
        static dataWithContentsOfFileOptionsError(options: string, error: NSData.ReadingOptions): NSData;
        static dataWithContentsOfURLOptionsError(options: NSURL, error: NSData.ReadingOptions): NSData;
        bytes: any;
        length: number;
        base64EncodedDataWithOptions(options: NSData.Base64EncodingOptions): NSData;
        base64EncodedStringWithOptions(options: NSData.Base64EncodingOptions): string;
        compressedDataUsingAlgorithmError(using: NSData.CompressionAlgorithm): NSData;
        decompressedDataUsingAlgorithmError(using: NSData.CompressionAlgorithm): NSData;
        enumerateBytes(_: (p1: any, p2: NSRange, p3: boolean) => void): void;
        getBytesLength(_: any, length: number): void;
        getBytesRange(_: any, range: NSRange): void;
        static createWithBase64EncodedDataOptions(base64EncodedData: NSData, options: NSData.Base64DecodingOptions): NSData;
        static createWithBase64EncodedStringOptions(base64EncodedString: string, options: NSData.Base64DecodingOptions): NSData;
        static createWithBytesLength(bytes?: any, length?: number): NSData;
        static createWithBytesNoCopyLength(bytesNoCopy: any, length: number): NSData;
        static createWithBytesNoCopyLengthDeallocator(bytesNoCopy: any, length: number, deallocator?: (p1: any, p2: number) => void): NSData;
        static createWithBytesNoCopyLengthFreeWhenDone(bytesNoCopy: any, length: number, freeWhenDone: boolean): NSData;
        static createWithContentsOfFile(contentsOfFile: string): NSData;
        static createWithContentsOfFileOptions(contentsOfFile: string, options: NSData.ReadingOptions): NSData;
        static createWithContentsOfURL(contentsOfURL: NSURL): NSData;
        static createWithContentsOfURLOptions(contentsOfURL: NSURL, options: NSData.ReadingOptions): NSData;
        static createWithData(data: NSData): NSData;
        isEqualToData(to: NSData): boolean;
        rangeOfDataOptionsRange(of: NSData, options: NSData.SearchOptions, in_: NSRange): NSRange;
        subdataWithRange(with_: NSRange): NSData;
        writeToFileAtomically(toFile: string, atomically: boolean): boolean;
        writeToFileOptionsError(options: string, error: NSData.WritingOptions): boolean;
        writeToURLAtomically(to: NSURL, atomically: boolean): boolean;
        writeToURLOptionsError(options: NSURL, error: NSData.WritingOptions): boolean;
    }
    class NSDataDetector extends NSRegularExpression {
        static dataDetectorWithTypesError(error: number): NSDataDetector;
        checkingTypes: number;
        static createWithTypes(types: number): NSDataDetector;
    }
    class NSDate extends NSObject {
        timeIntervalSince1970: number;
        timeIntervalSinceNow: number;
        static distantFuture: Date;
        static distantPast: Date;
        static now: Date;
        static timeIntervalSinceReferenceDate: number;
        compare(_: Date): ComparisonResult;
        dateByAddingTimeInterval(_: number): NSDate;
        descriptionWithLocale(with_?: any): string;
        earlierDate(_: Date): Date;
        static createWithTimeIntervalSinceDate(timeInterval: number, sinceDate: Date): NSDate;
        static createWithTimeIntervalSince1970(timeIntervalSince1970: number): NSDate;
        static createWithTimeIntervalSinceNow(timeIntervalSinceNow: number): NSDate;
        static createWithTimeIntervalSinceReferenceDate(timeIntervalSinceReferenceDate: number): NSDate;
        isEqualToDate(to: Date): boolean;
        laterDate(_: Date): Date;
        timeIntervalSinceDate(_: Date): number;
    }
    class NSDateComponents extends NSObject {
        calendar: NSCalendar;
        setCalendar(_: NSCalendar): any;
        date: Date;
        day: number;
        setDay(_: number): any;
        era: number;
        setEra(_: number): any;
        hour: number;
        setHour(_: number): any;
        isLeapMonth: boolean;
        setLeapMonth(_: boolean): any;
        minute: number;
        setMinute(_: number): any;
        month: number;
        setMonth(_: number): any;
        nanosecond: number;
        setNanosecond(_: number): any;
        quarter: number;
        setQuarter(_: number): any;
        second: number;
        setSecond(_: number): any;
        timeZone: NSTimeZone;
        setTimeZone(_: NSTimeZone): any;
        isValidDate: boolean;
        weekOfMonth: number;
        setWeekOfMonth(_: number): any;
        weekOfYear: number;
        setWeekOfYear(_: number): any;
        weekday: number;
        setWeekday(_: number): any;
        weekdayOrdinal: number;
        setWeekdayOrdinal(_: number): any;
        year: number;
        setYear(_: number): any;
        yearForWeekOfYear: number;
        setYearForWeekOfYear(_: number): any;
        isValidDateInCalendar(in_: NSCalendar): boolean;
        setValueForComponent(_: number, forComponent: NSCalendar.Unit): void;
        valueForComponent(forComponent: NSCalendar.Unit): number;
    }
    class DateComponentsFormatter extends Formatter {
        static localizedStringFromDateComponentsUnitsStyle(_: NSDateComponents, unitsStyle: DateComponentsFormatter.UnitsStyle): string;
        allowedUnits: NSCalendar.Unit;
        setAllowedUnits(_: NSCalendar.Unit): any;
        allowsFractionalUnits: boolean;
        setAllowsFractionalUnits(_: boolean): any;
        calendar: NSCalendar;
        setCalendar(_: NSCalendar): any;
        collapsesLargestUnit: boolean;
        setCollapsesLargestUnit(_: boolean): any;
        formattingContext: Formatter.Context;
        setFormattingContext(_: Formatter.Context): any;
        includesApproximationPhrase: boolean;
        setIncludesApproximationPhrase(_: boolean): any;
        includesTimeRemainingPhrase: boolean;
        setIncludesTimeRemainingPhrase(_: boolean): any;
        maximumUnitCount: number;
        setMaximumUnitCount(_: number): any;
        referenceDate: Date;
        setReferenceDate(_: Date): any;
        unitsStyle: DateComponentsFormatter.UnitsStyle;
        setUnitsStyle(_: DateComponentsFormatter.UnitsStyle): any;
        zeroFormattingBehavior: DateComponentsFormatter.ZeroFormattingBehavior;
        setZeroFormattingBehavior(_: DateComponentsFormatter.ZeroFormattingBehavior): any;
        stringFromDateToDate(_: Date, toDate: Date): string;
        stringFromDateComponents(_: NSDateComponents): string;
        stringFromTimeInterval(from: number): string;
    }
    class DateFormatter extends Formatter {
        static dateFormatFromTemplateOptionsLocale(_: string, options: number, locale?: NSLocale): string;
        static localizedStringFromDateDateStyleTimeStyle(from: Date, dateStyle: DateFormatter.Style, timeStyle: DateFormatter.Style): string;
        AMSymbol: string;
        setAMSymbol(_: string): any;
        PMSymbol: string;
        setPMSymbol(_: string): any;
        calendar: NSCalendar;
        setCalendar(_: NSCalendar): any;
        dateFormat: string;
        setDateFormat(_: string): any;
        dateStyle: DateFormatter.Style;
        setDateStyle(_: DateFormatter.Style): any;
        defaultDate: Date;
        setDefaultDate(_: Date): any;
        doesRelativeDateFormatting: boolean;
        setDoesRelativeDateFormatting(_: boolean): any;
        eraSymbols: string[];
        setEraSymbols(_: string[]): any;
        formatterBehavior: DateFormatter.Behavior;
        setFormatterBehavior(_: DateFormatter.Behavior): any;
        formattingContext: Formatter.Context;
        setFormattingContext(_: Formatter.Context): any;
        generatesCalendarDates: boolean;
        setGeneratesCalendarDates(_: boolean): any;
        gregorianStartDate: Date;
        setGregorianStartDate(_: Date): any;
        isLenient: boolean;
        setLenient(_: boolean): any;
        locale: NSLocale;
        setLocale(_: NSLocale): any;
        longEraSymbols: string[];
        setLongEraSymbols(_: string[]): any;
        monthSymbols: string[];
        setMonthSymbols(_: string[]): any;
        quarterSymbols: string[];
        setQuarterSymbols(_: string[]): any;
        shortMonthSymbols: string[];
        setShortMonthSymbols(_: string[]): any;
        shortQuarterSymbols: string[];
        setShortQuarterSymbols(_: string[]): any;
        shortStandaloneMonthSymbols: string[];
        setShortStandaloneMonthSymbols(_: string[]): any;
        shortStandaloneQuarterSymbols: string[];
        setShortStandaloneQuarterSymbols(_: string[]): any;
        shortStandaloneWeekdaySymbols: string[];
        setShortStandaloneWeekdaySymbols(_: string[]): any;
        shortWeekdaySymbols: string[];
        setShortWeekdaySymbols(_: string[]): any;
        standaloneMonthSymbols: string[];
        setStandaloneMonthSymbols(_: string[]): any;
        standaloneQuarterSymbols: string[];
        setStandaloneQuarterSymbols(_: string[]): any;
        standaloneWeekdaySymbols: string[];
        setStandaloneWeekdaySymbols(_: string[]): any;
        timeStyle: DateFormatter.Style;
        setTimeStyle(_: DateFormatter.Style): any;
        timeZone: NSTimeZone;
        setTimeZone(_: NSTimeZone): any;
        twoDigitStartDate: Date;
        setTwoDigitStartDate(_: Date): any;
        veryShortMonthSymbols: string[];
        setVeryShortMonthSymbols(_: string[]): any;
        veryShortStandaloneMonthSymbols: string[];
        setVeryShortStandaloneMonthSymbols(_: string[]): any;
        veryShortStandaloneWeekdaySymbols: string[];
        setVeryShortStandaloneWeekdaySymbols(_: string[]): any;
        veryShortWeekdaySymbols: string[];
        setVeryShortWeekdaySymbols(_: string[]): any;
        weekdaySymbols: string[];
        setWeekdaySymbols(_: string[]): any;
        static defaultFormatterBehavior: DateFormatter.Behavior;
        setDefaultFormatterBehavior(_: DateFormatter.Behavior): any;
        dateFromString(_: string): Date;
        getObjectValueForStringRangeError(forString?: any, range?: string, error?: NSRange): boolean;
        setLocalizedDateFormatFromTemplate(_: string): void;
        stringFromDate(_: Date): string;
    }
    class NSDateInterval extends NSObject {
        duration: number;
        endDate: Date;
        startDate: Date;
        compare(_: NSDateInterval): ComparisonResult;
        containsDate(_: Date): boolean;
        static createWithStartDateDuration(startDate: Date, duration: number): NSDateInterval;
        static createWithStartDateEndDate(startDate: Date, endDate: Date): NSDateInterval;
        intersectionWithDateInterval(with_: NSDateInterval): NSDateInterval;
        intersectsDateInterval(_: NSDateInterval): boolean;
        isEqualToDateInterval(to: NSDateInterval): boolean;
    }
    class DateIntervalFormatter extends Formatter {
        calendar: NSCalendar;
        setCalendar(_: NSCalendar): any;
        dateStyle: DateIntervalFormatter.Style;
        setDateStyle(_: DateIntervalFormatter.Style): any;
        dateTemplate: string;
        setDateTemplate(_: string): any;
        locale: NSLocale;
        setLocale(_: NSLocale): any;
        timeStyle: DateIntervalFormatter.Style;
        setTimeStyle(_: DateIntervalFormatter.Style): any;
        timeZone: NSTimeZone;
        setTimeZone(_: NSTimeZone): any;
        stringFromDateToDate(_: Date, toDate: Date): string;
        stringFromDateInterval(_: NSDateInterval): string;
    }
    class NSDecimalNumber extends NSNumber {
        static defaultBehavior: NSDecimalNumberBehaviors;
        setDefaultBehavior(_: NSDecimalNumberBehaviors): any;
        static maximumDecimalNumber: NSDecimalNumber;
        static minimumDecimalNumber: NSDecimalNumber;
        static notANumber: NSDecimalNumber;
        static one: NSDecimalNumber;
        static zero: NSDecimalNumber;
        decimalNumberByAdding(_: NSDecimalNumber): NSDecimalNumber;
        decimalNumberByAddingWithBehavior(_: NSDecimalNumber, withBehavior?: NSDecimalNumberBehaviors): NSDecimalNumber;
        decimalNumberByDividingBy(by: NSDecimalNumber): NSDecimalNumber;
        decimalNumberByDividingByWithBehavior(by: NSDecimalNumber, withBehavior?: NSDecimalNumberBehaviors): NSDecimalNumber;
        decimalNumberByMultiplyingBy(by: NSDecimalNumber): NSDecimalNumber;
        decimalNumberByMultiplyingByWithBehavior(by: NSDecimalNumber, withBehavior?: NSDecimalNumberBehaviors): NSDecimalNumber;
        decimalNumberByMultiplyingByPowerOf10(byPowerOf10: number): NSDecimalNumber;
        decimalNumberByMultiplyingByPowerOf10WithBehavior(byPowerOf10: number, withBehavior?: NSDecimalNumberBehaviors): NSDecimalNumber;
        decimalNumberByRaisingToPower(toPower: number): NSDecimalNumber;
        decimalNumberByRaisingToPowerWithBehavior(toPower: number, withBehavior?: NSDecimalNumberBehaviors): NSDecimalNumber;
        decimalNumberByRoundingAccordingToBehavior(accordingToBehavior?: NSDecimalNumberBehaviors): NSDecimalNumber;
        decimalNumberBySubtracting(_: NSDecimalNumber): NSDecimalNumber;
        decimalNumberBySubtractingWithBehavior(_: NSDecimalNumber, withBehavior?: NSDecimalNumberBehaviors): NSDecimalNumber;
        static createWithDecimal(decimal: number): NSDecimalNumber;
        static createWithMantissaExponentIsNegative(mantissa: number, exponent: number, isNegative: boolean): NSDecimalNumber;
        static createWithString(string?: string): NSDecimalNumber;
        static createWithStringLocale(string?: string, locale?: any): NSDecimalNumber;
    }
    interface NSDecimalNumberBehaviors {
        exceptionDuringOperationErrorLeftOperandRightOperand(_: string, error: NSDecimalNumber.CalculationError, leftOperand: NSDecimalNumber, rightOperand?: NSDecimalNumber): NSDecimalNumber;
        roundingMode(): NSDecimalNumber.RoundingMode;
        scale(): number;
    }
    class NSDecimalNumberHandler extends NSObject {
        static decimalNumberHandlerWithRoundingModeScaleRaiseOnExactnessRaiseOnOverflowRaiseOnUnderflowRaiseOnDivideByZero(roundingMode: NSDecimalNumber.RoundingMode, scale: number, raiseOnExactness: boolean, raiseOnOverflow: boolean, raiseOnUnderflow: boolean, raiseOnDivideByZero: boolean): NSDecimalNumberHandler;
        static defaultDecimalNumberHandler: NSDecimalNumberHandler;
        static createWithRoundingModeScaleRaiseOnExactnessRaiseOnOverflowRaiseOnUnderflowRaiseOnDivideByZero(roundingMode: NSDecimalNumber.RoundingMode, scale: number, raiseOnExactness: boolean, raiseOnOverflow: boolean, raiseOnUnderflow: boolean, raiseOnDivideByZero: boolean): NSDecimalNumberHandler;
    }
    class NSDeleteCommand extends NSScriptCommand {
        keySpecifier: NSScriptObjectSpecifier;
        setReceiversSpecifier(_?: NSScriptObjectSpecifier): void;
    }
    class NSDictionary<KeyType, ObjectType> extends NSObject {
        static sharedKeySetWithForKeys<KeyType>(forKeys: KeyType[]): any;
        allKeys: KeyType[];
        allValues: ObjectType[];
        count: number;
        descriptionInStringsFileFormat: string;
        allKeysForObject(for_: ObjectType): KeyType[];
        countByEnumeratingWithStateObjectsCount(with_: NSFastEnumerationState, objects?: K, count?: number): number;
        descriptionWithLocale(withLocale?: any): string;
        descriptionWithLocaleIndent(withLocale?: any, indent?: number): string;
        enumerateKeysAndObjects(_: (p1: KeyType, p2: ObjectType, p3: boolean) => void): void;
        enumerateKeysAndObjectsWithOptionsUsing(options: NSEnumerationOptions, using: (p1: KeyType, p2: ObjectType, p3: boolean) => void): void;
        fileCreationDate(): Date;
        fileExtensionHidden(): boolean;
        fileGroupOwnerAccountID(): number;
        fileGroupOwnerAccountName(): string;
        fileHFSCreatorCode(): number;
        fileHFSTypeCode(): number;
        fileIsAppendOnly(): boolean;
        fileIsImmutable(): boolean;
        fileModificationDate(): Date;
        fileOwnerAccountID(): number;
        fileOwnerAccountName(): string;
        filePosixPermissions(): number;
        fileSize(): number;
        fileSystemFileNumber(): number;
        fileSystemNumber(): number;
        fileType(): string;
        isEqualToDictionary(to: Map<KeyType, ObjectType>): boolean;
        keyEnumerator(): NSEnumerator<KeyType>;
        keysOfEntriesWithPassingTest(passingTest: (p1: KeyType, p2: ObjectType, p3: boolean) => boolean): NSSet<KeyType>;
        keysOfEntriesWithOptionsPassingTest(options: NSEnumerationOptions, passingTest: (p1: KeyType, p2: ObjectType, p3: boolean) => boolean): NSSet<KeyType>;
        keysSortedByValueWithComparator(comparator: (p1: any, p2: any) => ComparisonResult): KeyType[];
        keysSortedByValueUsingSelector(using: string): KeyType[];
        keysSortedByValueWithOptionsUsingComparator(options: NSSortOptions, usingComparator: (p1: any, p2: any) => ComparisonResult): KeyType[];
        objectEnumerator(): NSEnumerator<ObjectType>;
        objectForKey(forKey: KeyType): ObjectType;
        objectsForKeysNotFoundMarker(forKeys: KeyType[], notFoundMarker: ObjectType): ObjectType[];
        writeToFileAtomically(toFile: string, atomically: boolean): boolean;
        writeToURLAtomically(to: NSURL, atomically: boolean): boolean;
        writeToURLError(error: NSURL): boolean;
    }
    class Dimension extends Unit {
        static baseUnit(): Dimension;
        converter: UnitConverter;
        static createWithSymbolConverter(symbol: string, converter: UnitConverter): Dimension;
    }
    class DirectoryEnumerator<ObjectType> extends NSEnumerator<ObjectType> {
        directoryAttributes: Map<string, any>;
        fileAttributes: Map<string, any>;
        isEnumeratingDirectoryPostOrder: boolean;
        level: number;
        skipDescendants(): void;
        skipDescendents(): void;
    }
    interface NSDiscardableContent {
        beginContentAccess(): boolean;
        discardContentIfPossible(): void;
        endContentAccess(): void;
        isContentDiscarded(): boolean;
    }
    class NSDistributedLock extends NSObject {
        lockDate: Date;
        breakLock(): void;
        static createWithPath(path: string): NSDistributedLock;
        tryLock(): boolean;
        unlock(): void;
    }
    class DistributedNotificationCenter extends NotificationCenter {
        suspended: boolean;
        setSuspended(_: boolean): any;
        addObserverSelectorNameObjectSuspensionBehavior(_: any, selector: string, name?: string, object_?: string, suspensionBehavior?: DistributedNotificationCenter.SuspensionBehavior): void;
        postNotificationNameObjectUserInfoDeliverImmediately(_: string, object_?: string, userInfo?: Map<any, any>, deliverImmediately?: boolean): void;
        postNotificationNameObjectUserInfoOptions(_: string, object_?: string, userInfo?: Map<any, any>, options?: DistributedNotificationCenter.Options): void;
    }
    interface NSEdgeInsets {
        top: number;
        left: number;
        bottom: number;
        right: number;
    }
    class EnergyFormatter extends Formatter {
        isForFoodEnergyUse: boolean;
        setForFoodEnergyUse(_: boolean): any;
        numberFormatter: NumberFormatter;
        setNumberFormatter(_: NumberFormatter): any;
        unitStyle: Formatter.UnitStyle;
        setUnitStyle(_: Formatter.UnitStyle): any;
        stringFromJoules(_: number): string;
        stringFromValueUnit(_: number, unit: EnergyFormatter.Unit): string;
        unitStringFromJoulesUsedUnit(_: number, usedUnit?: EnergyFormatter.Unit): string;
        unitStringFromValueUnit(_: number, unit: EnergyFormatter.Unit): string;
    }
    class NSEnumerator<ObjectType> extends NSObject {
        allObjects: ObjectType[];
        nextObject(): ObjectType;
    }
    class NSError extends NSObject {
        static setUserInfoValueProviderWithForDomainProvider(forDomain: string, provider?: (p1: NSError, p2: string) => any): void;
        static userInfoValueProviderForDomain(forDomain: string): (p1: NSError, p2: string) => any;
        code: number;
        domain: string;
        helpAnchor: string;
        localizedDescription: string;
        localizedFailureReason: string;
        localizedRecoveryOptions: string[];
        localizedRecoverySuggestion: string;
        recoveryAttempter: any;
        userInfo: Map<string, any>;
        static createWithDomainCodeUserInfo(domain: string, code: number, userInfo?: Map<string, any>): NSError;
    }
    class NSException extends NSObject {
        callStackReturnAddresses: number[];
        callStackSymbols: string[];
        name: string;
        reason: string;
        userInfo: Map<any, any>;
        static createWithNameReasonUserInfo(name: string, reason?: string, userInfo?: Map<any, any>): NSException;
        raise(): void;
    }
    class NSExistsCommand extends NSScriptCommand {
    }
    class NSExpression extends NSObject {
        static expressionForAnyKey(): NSExpression;
        static expressionForEvaluatedObject(): NSExpression;
        arguments: NSExpression[];
        collection: any;
        constantValue: any;
        expressionBlock: (p1: any, p2: NSExpression[], p3: NSMutableDictionary<any, any>) => any;
        expressionType: NSExpression.ExpressionType;
        falseExpression: NSExpression;
        function: string;
        keyPath: string;
        leftExpression: NSExpression;
        operand: NSExpression;
        predicate: NSPredicate;
        rightExpression: NSExpression;
        trueExpression: NSExpression;
        variable: string;
        allowEvaluation(): void;
        expressionValueWithObjectContext(with_?: any, context?: NSMutableDictionary<any, any>): any;
        static createWithExpressionType(expressionType: NSExpression.ExpressionType): NSExpression;
    }
    class NSExtensionContext extends NSObject {
        inputItems: any[];
        cancelRequestWithError(withError: NSError): void;
        completeRequestWithReturningItemsCompletionHandler(returningItems?: any[], completionHandler?: (p1: boolean) => void): void;
        openCompletionHandler(_: NSURL, completionHandler?: (p1: boolean) => void): void;
    }
    class NSExtensionItem extends NSObject {
        attachments: NSItemProvider[];
        setAttachments(_: NSItemProvider[]): any;
        attributedContentText: NSAttributedString;
        setAttributedContentText(_: NSAttributedString): any;
        attributedTitle: NSAttributedString;
        setAttributedTitle(_: NSAttributedString): any;
        userInfo: Map<any, any>;
        setUserInfo(_: Map<any, any>): any;
    }
    interface NSExtensionRequestHandling extends NSObject {
        beginRequestWithExtensionContext(with_: NSExtensionContext): void;
    }
    interface NSFastEnumeration {
        countByEnumeratingWithStateObjectsCount(with_: NSFastEnumerationState, objects?: any, count?: number): number;
    }
    interface NSFastEnumerationState {
        state: number;
        itemsPtr: any;
        mutationsPtr: number;
        extra: number;
    }
    class NSFileAccessIntent extends NSObject {
        static readingIntentWithURLOptions(with_: NSURL, options: NSFileCoordinator.ReadingOptions): NSFileAccessIntent;
        static writingIntentWithURLOptions(with_: NSURL, options: NSFileCoordinator.WritingOptions): NSFileAccessIntent;
        URL: NSURL;
    }
    class NSFileCoordinator extends NSObject {
        static addFilePresenter(_: NSFilePresenter): void;
        static removeFilePresenter(_: NSFilePresenter): void;
        purposeIdentifier: string;
        setPurposeIdentifier(_: string): any;
        static filePresenters: NSFilePresenter[];
        cancel(): void;
        coordinateWithWithQueueByAccessor(with_: NSFileAccessIntent[], queue: OperationQueue, byAccessor?: (p1: NSError) => void): void;
        coordinateWithReadingItemAtOptionsErrorByAccessor(readingItemAt: NSURL, options: NSFileCoordinator.ReadingOptions, error?: Error, byAccessor?: (p1: NSURL) => void): void;
        coordinateWithReadingItemAtOptionsWritingItemAtOptionsErrorByAccessor(readingItemAt: NSURL, options: NSFileCoordinator.ReadingOptions, writingItemAt: NSURL, options2: NSFileCoordinator.WritingOptions, error?: Error, byAccessor?: (p1: NSURL, p2: NSURL) => void): void;
        coordinateWithWritingItemAtOptionsErrorByAccessor(writingItemAt: NSURL, options: NSFileCoordinator.WritingOptions, error?: Error, byAccessor?: (p1: NSURL) => void): void;
        coordinateWithWritingItemAtOptionsWritingItemAtOptionsErrorByAccessor(writingItemAt: NSURL, options: NSFileCoordinator.WritingOptions, writingItemAt2: NSURL, options2: NSFileCoordinator.WritingOptions, error?: Error, byAccessor?: (p1: NSURL, p2: NSURL) => void): void;
        static createWithFilePresenter(filePresenter?: NSFilePresenter): NSFileCoordinator;
        itemWithAtDidChangeUbiquityAttributes(at: NSURL, didChangeUbiquityAttributes: NSSet<string>): void;
        itemAtURLDidMoveToURL(at: NSURL, didMoveTo: NSURL): void;
        itemAtURLWillMoveToURL(at: NSURL, willMoveTo: NSURL): void;
        prepareWithForReadingItemsAtOptionsWritingItemsAtOptionsErrorByAccessor(forReadingItemsAt: NSURL[], options: NSFileCoordinator.ReadingOptions, writingItemsAt: NSURL[], options2: NSFileCoordinator.WritingOptions, error?: Error, byAccessor?: (p1: () => void) => void): void;
    }
    class FileHandle extends NSObject {
        static fileHandleForReadingFromURLError(error: NSURL): FileHandle;
        static fileHandleForUpdatingURLError(error: NSURL): FileHandle;
        static fileHandleForWritingToURLError(error: NSURL): FileHandle;
        availableData: NSData;
        fileDescriptor: number;
        offsetInFile: number;
        readabilityHandler: (p1: FileHandle) => void;
        setReadabilityHandler(_: (p1: FileHandle) => void): any;
        writeabilityHandler: (p1: FileHandle) => void;
        setWriteabilityHandler(_: (p1: FileHandle) => void): any;
        static fileHandleWithNullDevice: FileHandle;
        static fileHandleWithStandardError: FileHandle;
        static fileHandleWithStandardInput: FileHandle;
        static fileHandleWithStandardOutput: FileHandle;
        acceptConnectionInBackgroundAndNotify(): void;
        acceptConnectionInBackgroundAndNotifyForModes(_?: string[]): void;
        closeAndReturnError(): boolean;
        closeFile(): void;
        getOffsetError(error: number): boolean;
        static createWithFileDescriptor(fileDescriptor: number): FileHandle;
        static createWithFileDescriptorCloseOnDealloc(fileDescriptor: number, closeOnDealloc: boolean): FileHandle;
        readDataOfLength(_: number): NSData;
        readDataToEndOfFile(): NSData;
        readDataToEndOfFileAndReturnError(): NSData;
        readDataUpToLengthError(error: number): NSData;
        readInBackgroundAndNotify(): void;
        readInBackgroundAndNotifyForModes(_?: string[]): void;
        readToEndOfFileInBackgroundAndNotify(): void;
        readToEndOfFileInBackgroundAndNotifyForModes(_?: string[]): void;
        seekToEndOfFile(): number;
        seekToEndReturningOffsetError(error?: number): boolean;
        seekToFileOffset(_: number): void;
        seekToOffsetError(error: number): boolean;
        synchronizeAndReturnError(): boolean;
        synchronizeFile(): void;
        truncateAtOffsetError(error: number): boolean;
        truncateFileAtOffset(_: number): void;
        waitForDataInBackgroundAndNotify(): void;
        waitForDataInBackgroundAndNotifyForModes(_?: string[]): void;
        writeData(_: NSData): void;
        writeDataError(error: NSData): boolean;
    }
    class FileManager extends NSObject {
        currentDirectoryPath: string;
        delegate: FileManagerDelegate;
        setDelegate(_: FileManagerDelegate): any;
        homeDirectoryForCurrentUser: NSURL;
        temporaryDirectory: NSURL;
        ubiquityIdentityToken: any;
        static defaultManager: FileManager;
        URLForDirectoryInDomainAppropriateForURLCreateError(for_: FileManager.SearchPathDirectory, in_: FileManager.SearchPathDomainMask, appropriateFor?: NSURL, create?: boolean): NSURL;
        URLForPublishingUbiquitousItemAtURLExpirationDateError(forPublishingUbiquitousItemAt: NSURL, expiration?: Date): NSURL;
        URLForUbiquityContainerIdentifier(forUbiquityContainerIdentifier?: string): NSURL;
        URLsForDirectoryInDomains(for_: FileManager.SearchPathDirectory, in_: FileManager.SearchPathDomainMask): NSURL[];
        attributesOfFileSystemForPathError(error: string): Map<string, any>;
        attributesOfItemAtPathError(error: string): Map<string, any>;
        changeCurrentDirectoryPath(_: string): boolean;
        componentsToDisplayForPath(_: string): string[];
        containerURLForSecurityApplicationGroupIdentifier(forSecurityApplicationGroupIdentifier: string): NSURL;
        contentsAtPath(_: string): NSData;
        contentsEqualAtPathAndPath(_: string, andPath: string): boolean;
        contentsOfDirectoryAtPathError(error: string): string[];
        contentsOfDirectoryAtURLIncludingPropertiesForKeysOptionsError(includingPropertiesForKeys: NSURL, options?: string[], error?: FileManager.DirectoryEnumerationOptions): NSURL[];
        copyItemAtPathToPathError(toPath: string, error: string): boolean;
        copyItemAtURLToURLError(toURL: NSURL, error: NSURL): boolean;
        createDirectoryAtPathWithIntermediateDirectoriesAttributesError(withIntermediateDirectories: string, attributes: boolean, error?: Map<string, any>): boolean;
        createDirectoryAtURLWithIntermediateDirectoriesAttributesError(withIntermediateDirectories: NSURL, attributes: boolean, error?: Map<string, any>): boolean;
        createFileAtPathContentsAttributes(_: string, contents?: NSData, attributes?: Map<string, any>): boolean;
        createSymbolicLinkAtPathWithDestinationPathError(withDestinationPath: string, error: string): boolean;
        createSymbolicLinkAtURLWithDestinationURLError(withDestinationURL: NSURL, error: NSURL): boolean;
        destinationOfSymbolicLinkAtPathError(error: string): string;
        displayNameAtPath(_: string): string;
        enumeratorAtPath(_: string): DirectoryEnumerator<string>;
        enumeratorAtURLWithIncludingPropertiesForKeysOptionsErrorHandler(_: NSURL, includingPropertiesForKeys?: string[], options?: FileManager.DirectoryEnumerationOptions, errorHandler?: (p1: NSURL, p2: NSError) => boolean): DirectoryEnumerator<NSURL>;
        evictUbiquitousItemAtURLError(error: NSURL): boolean;
        fileExistsAtPath(_: string): boolean;
        fileExistsAtPathIsDirectory(_: string, isDirectory?: boolean): boolean;
        fileSystemRepresentationWithPath(_: string): string;
        getFileProviderServicesForItemAtURLWithCompletionHandler(_: NSURL, completionHandler?: (p1: Map<string, NSFileProviderService>, p2: NSError) => void): void;
        getRelationshipOfDirectoryInDomainToItemAtURLError(ofDirectory: FileManager.URLRelationship, inDomain: FileManager.SearchPathDirectory, toItemAtURL: FileManager.SearchPathDomainMask, error: NSURL): boolean;
        getRelationshipOfDirectoryAtURLToItemAtURLError(ofDirectoryAtURL: FileManager.URLRelationship, toItemAtURL: NSURL, error: NSURL): boolean;
        homeDirectoryForUser(_: string): NSURL;
        isDeletableFileAtPath(_: string): boolean;
        isExecutableFileAtPath(_: string): boolean;
        isReadableFileAtPath(_: string): boolean;
        isUbiquitousItemAtURL(_: NSURL): boolean;
        isWritableFileAtPath(_: string): boolean;
        linkItemAtPathToPathError(toPath: string, error: string): boolean;
        linkItemAtURLToURLError(toURL: NSURL, error: NSURL): boolean;
        mountedVolumeURLsIncludingResourceValuesForKeysOptions(includingResourceValuesForKeys?: string[], options?: FileManager.VolumeEnumerationOptions): NSURL[];
        moveItemAtPathToPathError(toPath: string, error: string): boolean;
        moveItemAtURLToURLError(toURL: NSURL, error: NSURL): boolean;
        removeItemAtPathError(error: string): boolean;
        removeItemAtURLError(error: NSURL): boolean;
        replaceItemAtURLWithItemAtURLBackupItemNameOptionsResultingItemURLError(withItemAtURL: NSURL, backupItemName: NSURL, options?: string, resultingItemURL?: FileManager.ItemReplacementOptions, error?: NSURL): boolean;
        setAttributesOfItemAtPathError(ofItemAtPath: Map<string, any>, error: string): boolean;
        setUbiquitousItemAtURLDestinationURLError(itemAtURL: boolean, destinationURL: NSURL, error: NSURL): boolean;
        startDownloadingUbiquitousItemAtURLError(error: NSURL): boolean;
        stringWithFileSystemRepresentationLength(_: string, length: number): string;
        subpathsAtPath(_: string): string[];
        subpathsOfDirectoryAtPathError(error: string): string[];
        trashItemAtURLResultingItemURLError(resultingItemURL: NSURL, error?: NSURL): boolean;
        unmountVolumeAtURLWithOptionsCompletionHandler(_: NSURL, options: FileManager.UnmountOptions, completionHandler?: (p1: NSError) => void): void;
    }
    interface FileManagerDelegate extends NSObject {
        fileManagerShouldCopyItemAtPathToPath?(_: FileManager, shouldCopyItemAtPath: string, toPath: string): boolean;
        fileManagerShouldCopyItemAtURLToURL?(_: FileManager, shouldCopyItemAtURL: NSURL, toURL: NSURL): boolean;
        fileManagerShouldLinkItemAtPathToPath?(_: FileManager, shouldLinkItemAtPath: string, toPath: string): boolean;
        fileManagerShouldLinkItemAtURLToURL?(_: FileManager, shouldLinkItemAtURL: NSURL, toURL: NSURL): boolean;
        fileManagerShouldMoveItemAtPathToPath?(_: FileManager, shouldMoveItemAtPath: string, toPath: string): boolean;
        fileManagerShouldMoveItemAtURLToURL?(_: FileManager, shouldMoveItemAtURL: NSURL, toURL: NSURL): boolean;
        fileManagerShouldProceedAfterErrorCopyingItemAtPathToPath?(_: FileManager, shouldProceedAfterError: NSError, copyingItemAtPath: string, toPath: string): boolean;
        fileManagerShouldProceedAfterErrorCopyingItemAtURLToURL?(_: FileManager, shouldProceedAfterError: NSError, copyingItemAtURL: NSURL, toURL: NSURL): boolean;
        fileManagerShouldProceedAfterErrorLinkingItemAtPathToPath?(_: FileManager, shouldProceedAfterError: NSError, linkingItemAtPath: string, toPath: string): boolean;
        fileManagerShouldProceedAfterErrorLinkingItemAtURLToURL?(_: FileManager, shouldProceedAfterError: NSError, linkingItemAtURL: NSURL, toURL: NSURL): boolean;
        fileManagerShouldProceedAfterErrorMovingItemAtPathToPath?(_: FileManager, shouldProceedAfterError: NSError, movingItemAtPath: string, toPath: string): boolean;
        fileManagerShouldProceedAfterErrorMovingItemAtURLToURL?(_: FileManager, shouldProceedAfterError: NSError, movingItemAtURL: NSURL, toURL: NSURL): boolean;
        fileManagerShouldProceedAfterErrorRemovingItemAtPath?(_: FileManager, shouldProceedAfterError: NSError, removingItemAtPath: string): boolean;
        fileManagerShouldProceedAfterErrorRemovingItemAtURL?(_: FileManager, shouldProceedAfterError: NSError, removingItemAtURL: NSURL): boolean;
        fileManagerShouldRemoveItemAtPath?(_: FileManager, shouldRemoveItemAtPath: string): boolean;
        fileManagerShouldRemoveItemAtURL?(_: FileManager, shouldRemoveItemAtURL: NSURL): boolean;
    }
    interface NSFilePresenter extends NSObject {
        observedPresentedItemUbiquityAttributes?: NSSet<string>;
        presentedItemOperationQueue: OperationQueue;
        presentedItemURL: NSURL;
        primaryPresentedItemURL?: NSURL;
        accommodatePresentedItemDeletionWithCompletionHandler?(completionHandler?: (p1: NSError) => void): void;
        accommodatePresentedSubitemDeletionWithAtCompletionHandler?(at: NSURL, completionHandler?: (p1: NSError) => void): void;
        presentedItemDidChange?(): void;
        presentedItemDidChangeUbiquityAttributes?(_: NSSet<string>): void;
        presentedItemDidGainVersion?(_: NSFileVersion): void;
        presentedItemDidLoseVersion?(_: NSFileVersion): void;
        presentedItemDidMoveToURL?(to: NSURL): void;
        presentedItemDidResolveConflictVersion?(_: NSFileVersion): void;
        presentedSubitemAtURLDidMoveToURL?(at: NSURL, didMoveTo: NSURL): void;
        presentedSubitemAtURLDidGainVersion?(at: NSURL, didGain: NSFileVersion): void;
        presentedSubitemAtURLDidLoseVersion?(at: NSURL, didLose: NSFileVersion): void;
        presentedSubitemAtURLDidResolveConflictVersion?(at: NSURL, didResolve: NSFileVersion): void;
        presentedSubitemDidAppearAtURL?(at: NSURL): void;
        presentedSubitemDidChangeAtURL?(at: NSURL): void;
        relinquishPresentedItemWithToReader?(toReader?: (p1: () => void) => void): void;
        relinquishPresentedItemWithToWriter?(toWriter?: (p1: () => void) => void): void;
        savePresentedItemChangesWithCompletionHandler?(completionHandler?: (p1: NSError) => void): void;
    }
    class NSFileProviderService extends NSObject {
        name: string;
        getFileProviderConnectionWithCompletionHandler(completionHandler?: (p1: NSXPCConnection, p2: NSError) => void): void;
    }
    class NSFileSecurity extends NSObject {
    }
    class NSFileVersion extends NSObject {
        static addVersionOfItemAtURLWithContentsOfURLOptionsError(withContentsOfURL: NSURL, options: NSURL, error: NSFileVersion.AddingOptions): NSFileVersion;
        static currentVersionOfItemAtURL(at: NSURL): NSFileVersion;
        static getNonlocalVersionsOfItemWithAtCompletionHandler(at: NSURL, completionHandler?: (p1: NSFileVersion[], p2: NSError) => void): void;
        static otherVersionsOfItemAtURL(at: NSURL): NSFileVersion[];
        static removeOtherVersionsOfItemAtURLError(error: NSURL): boolean;
        static temporaryDirectoryURLForNewVersionOfItemAtURL(at: NSURL): NSURL;
        static unresolvedConflictVersionsOfItemAtURL(at: NSURL): NSFileVersion[];
        URL: NSURL;
        isConflict: boolean;
        isDiscardable: boolean;
        setDiscardable(_: boolean): any;
        hasLocalContents: boolean;
        hasThumbnail: boolean;
        localizedName: string;
        localizedNameOfSavingComputer: string;
        modificationDate: Date;
        originatorNameComponents: NSPersonNameComponents;
        persistentIdentifier: NSCoding;
        isResolved: boolean;
        setResolved(_: boolean): any;
        removeAndReturnError(): boolean;
        replaceItemAtURLOptionsError(options: NSURL, error: NSFileVersion.ReplacingOptions): NSURL;
    }
    class FileWrapper extends NSObject {
        isDirectory: boolean;
        fileAttributes: Map<string, any>;
        setFileAttributes(_: Map<string, any>): any;
        fileWrappers: Map<string, FileWrapper>;
        filename: string;
        setFilename(_: string): any;
        icon: NSImage;
        setIcon(_: NSImage): any;
        preferredFilename: string;
        setPreferredFilename(_: string): any;
        isRegularFile: boolean;
        regularFileContents: NSData;
        serializedRepresentation: NSData;
        isSymbolicLink: boolean;
        symbolicLinkDestinationURL: NSURL;
        addFileWrapper(_: FileWrapper): string;
        addRegularFileWithContentsPreferredFilename(_: NSData, preferredFilename: string): string;
        static createWithDirectoryWithFileWrappers(directoryWithFileWrappers: Map<string, FileWrapper>): FileWrapper;
        static createWithRegularFileWithContents(regularFileWithContents: NSData): FileWrapper;
        static createWithSymbolicLinkWithDestinationURL(symbolicLinkWithDestinationURL: NSURL): FileWrapper;
        static createWithSerializedRepresentation(serializedRepresentation: NSData): FileWrapper;
        static createWithUrlOptions(URL: NSURL, options: FileWrapper.ReadingOptions): FileWrapper;
        keyForFileWrapper(_: FileWrapper): string;
        matchesContentsOfURL(_: NSURL): boolean;
        readFromURLOptionsError(options: NSURL, error: FileWrapper.ReadingOptions): boolean;
        removeFileWrapper(_: FileWrapper): void;
        writeToURLOptionsOriginalContentsURLError(options: NSURL, originalContentsURL: FileWrapper.WritingOptions, error?: NSURL): boolean;
    }
    class Formatter extends NSObject {
        attributedStringForObjectValueWithDefaultAttributes(_: any, withDefaultAttributes?: Map<string, any>): NSAttributedString;
        editingStringForObjectValue(_: any): string;
        getObjectValueForStringErrorDescription(_?: any, forString?: string, errorDescription?: string): boolean;
        isPartialStringValidNewEditingStringErrorDescription(_: string, newEditingString?: string, errorDescription?: string): boolean;
        isPartialStringValidProposedSelectedRangeOriginalStringOriginalSelectedRangeErrorDescription(_: string, proposedSelectedRange?: NSRange, originalString?: string, originalSelectedRange?: NSRange, errorDescription?: string): boolean;
        stringForObjectValue(_?: any): string;
    }
    class NSGetCommand extends NSScriptCommand {
    }
    class HTTPCookie extends NSObject {
        static cookiesWithResponseHeaderFieldsForURL(_: Map<string, string>, forURL: NSURL): HTTPCookie[];
        static requestHeaderFieldsWithCookies(_: HTTPCookie[]): Map<string, string>;
        isHTTPOnly: boolean;
        comment: string;
        commentURL: NSURL;
        domain: string;
        expiresDate: Date;
        name: string;
        path: string;
        portList: number[];
        properties: Map<string, any>;
        sameSitePolicy: string;
        isSecure: boolean;
        isSessionOnly: boolean;
        value: string;
        static createWithProperties(properties: Map<string, any>): HTTPCookie;
    }
    class HTTPCookieStorage extends NSObject {
        static sharedCookieStorageForGroupContainerIdentifier(_: string): HTTPCookieStorage;
        cookieAcceptPolicy: HTTPCookie.AcceptPolicy;
        setCookieAcceptPolicy(_: HTTPCookie.AcceptPolicy): any;
        cookies: HTTPCookie[];
        static sharedHTTPCookieStorage: HTTPCookieStorage;
        cookiesForURL(_: NSURL): HTTPCookie[];
        deleteCookie(_: HTTPCookie): void;
        getCookiesForTaskWithCompletionHandler(_: URLSessionTask, completionHandler?: (p1: HTTPCookie[]) => void): void;
        removeCookiesSinceDate(_: Date): void;
        setCookie(_: HTTPCookie): void;
        setCookiesForURLMainDocumentURL(_: HTTPCookie[], forURL?: NSURL, mainDocumentURL?: NSURL): void;
        sortedCookiesUsingDescriptors(_: NSSortDescriptor[]): HTTPCookie[];
        storeCookiesForTask(_: HTTPCookie[], forTask: URLSessionTask): void;
    }
    class HTTPURLResponse extends URLResponse {
        static localizedStringForStatusCode(_: number): string;
        allHeaderFields: Map<any, any>;
        statusCode: number;
        static createWithUrlStatusCodeHTTPVersionHeaderFields(URL: NSURL, statusCode: number, HTTPVersion?: string, headerFields?: Map<string, string>): HTTPURLResponse;
        valueForHTTPHeaderField(_: string): string;
    }
    class NSHashTable<ObjectType> extends NSObject {
        static weakObjectsHashTable<ObjectType>(): NSHashTable<ObjectType>;
        allObjects: ObjectType[];
        anyObject: ObjectType;
        count: number;
        pointerFunctions: NSPointerFunctions;
        setRepresentation: NSSet<ObjectType>;
        addObject(_?: ObjectType): void;
        containsObject(_?: ObjectType): boolean;
        intersect(_: NSHashTable<ObjectType>): void;
        intersects(_: NSHashTable<ObjectType>): boolean;
        isEqualWithTo(to: NSHashTable<ObjectType>): boolean;
        isSubsetOf(of: NSHashTable<ObjectType>): boolean;
        member(_?: ObjectType): ObjectType;
        minus(_: NSHashTable<ObjectType>): void;
        objectEnumerator(): NSEnumerator<ObjectType>;
        removeAllObjects(): void;
        removeObject(_?: ObjectType): void;
        union(_: NSHashTable<ObjectType>): void;
    }
    interface NSHashTableCallBacks {
        hash: (p1: NSHashTable<any>, p2: any) => number;
        isEqual: (p1: NSHashTable<any>, p2: any, p3: any) => boolean;
        retain: (p1: NSHashTable<any>, p2: any) => void;
        release: (p1: NSHashTable<any>, p2: any) => void;
        describe: (p1: NSHashTable<any>, p2: any) => string;
    }
    class Host extends NSObject {
        static currentHost(): Host;
        address: string;
        addresses: string[];
        localizedName: string;
        name: string;
        names: string[];
        isEqualToHost(_: Host): boolean;
    }
    class ISO8601DateFormatter extends Formatter {
        static stringFromDateTimeZoneFormatOptions(_: Date, timeZone: NSTimeZone, formatOptions: ISO8601DateFormatter.Options): string;
        formatOptions: ISO8601DateFormatter.Options;
        setFormatOptions(_: ISO8601DateFormatter.Options): any;
        timeZone: NSTimeZone;
        setTimeZone(_: NSTimeZone): any;
        dateFromString(_: string): Date;
        stringFromDate(_: Date): string;
    }
    class NSIndexPath extends NSObject {
        item: number;
        length: number;
        section: number;
        compare(_: NSIndexPath): ComparisonResult;
        getIndexes(_: number): void;
        getIndexesRange(_: number, range: NSRange): void;
        indexAtPosition(atPosition: number): number;
        indexPathByAddingIndex(_: number): NSIndexPath;
        indexPathByRemovingLastIndex(): NSIndexPath;
        static createWithIndex(index: number): NSIndexPath;
        static createWithIndexesLength(indexes?: number, length?: number): NSIndexPath;
    }
    class NSIndexSet extends NSObject {
        count: number;
        firstIndex: number;
        lastIndex: number;
        containsIndex(_: number): boolean;
        containsIndexes(_: NSIndexSet): boolean;
        containsIndexesInRange(in_: NSRange): boolean;
        countOfIndexesInRange(in_: NSRange): number;
        enumerateWithInOptionsUsing(in_: NSRange, options: NSEnumerationOptions, using: (p1: number, p2: boolean) => void): void;
        enumerate(_: (p1: number, p2: boolean) => void): void;
        enumerateWithOptionsUsing(options: NSEnumerationOptions, using: (p1: number, p2: boolean) => void): void;
        enumerateRangesWithInOptionsUsing(in_: NSRange, options: NSEnumerationOptions, using: (p1: NSRange, p2: boolean) => void): void;
        enumerateRanges(_: (p1: NSRange, p2: boolean) => void): void;
        enumerateRangesWithOptionsUsing(options: NSEnumerationOptions, using: (p1: NSRange, p2: boolean) => void): void;
        getIndexesMaxCountInIndexRange(_: number, maxCount: number, inIndexRange?: NSRange): number;
        indexGreaterThanIndex(_: number): number;
        indexGreaterThanOrEqualToIndex(to: number): number;
        indexWithInOptionsPassingTest(in_: NSRange, options: NSEnumerationOptions, passingTest: (p1: number, p2: boolean) => boolean): number;
        indexLessThanIndex(_: number): number;
        indexLessThanOrEqualToIndex(to: number): number;
        indexWithPassingTest(passingTest: (p1: number, p2: boolean) => boolean): number;
        indexWithOptionsPassingTest(options: NSEnumerationOptions, passingTest: (p1: number, p2: boolean) => boolean): number;
        indexesWithInOptionsPassingTest(in_: NSRange, options: NSEnumerationOptions, passingTest: (p1: number, p2: boolean) => boolean): NSIndexSet;
        indexesWithPassingTest(passingTest: (p1: number, p2: boolean) => boolean): NSIndexSet;
        indexesWithOptionsPassingTest(options: NSEnumerationOptions, passingTest: (p1: number, p2: boolean) => boolean): NSIndexSet;
        static createWithIndex(index: number): NSIndexSet;
        static createWithIndexSet(indexSet: NSIndexSet): NSIndexSet;
        static createWithIndexesInRange(indexesInRange: NSRange): NSIndexSet;
        intersectsIndexesInRange(in_: NSRange): boolean;
        isEqualToIndexSet(to: NSIndexSet): boolean;
    }
    class NSIndexSpecifier extends NSScriptObjectSpecifier {
        index: number;
        setIndex(_: number): any;
        static createWithContainerClassDescriptionContainerSpecifierKeyIndex(containerClassDescription: NSScriptClassDescription, containerSpecifier?: NSScriptObjectSpecifier, key?: string, index?: number): NSIndexSpecifier;
    }
    class InputStream extends Stream {
        static inputStreamWithData(_: NSData): InputStream;
        static inputStreamWithFileAtPath(_: string): InputStream;
        static inputStreamWithURL(_: NSURL): InputStream;
        hasBytesAvailable: boolean;
        getBufferLength(_?: string, length?: number): boolean;
        static createWithData(data: NSData): InputStream;
        static createWithFileAtPath(fileAtPath: string): InputStream;
        static createWithUrl(URL: NSURL): InputStream;
        readMaxLength(_: string, maxLength: number): number;
    }
    class NSItemProvider extends NSObject {
        containerFrame: CGRect;
        preferredPresentationSize: CGSize;
        previewImageHandler: (p1: (p1: NSSecureCoding, p2: NSError) => void, p2: typeof NSObject, p3: Map<any, any>) => void;
        setPreviewImageHandler(_: (p1: (p1: NSSecureCoding, p2: NSError) => void, p2: typeof NSObject, p3: Map<any, any>) => void): any;
        registeredTypeIdentifiers: string[];
        sourceFrame: CGRect;
        suggestedName: string;
        setSuggestedName(_: string): any;
        canLoadObjectOfClass(ofClass: typeof NSObject): boolean;
        hasItemConformingToTypeIdentifier(_: string): boolean;
        hasRepresentationConformingToTypeIdentifierFileOptions(toTypeIdentifier: string, fileOptions: NSItemProviderFileOptions): boolean;
        static createWithContentsOfURL(contentsOfURL: NSURL): NSItemProvider;
        static createWithItemTypeIdentifier(item?: NSSecureCoding, typeIdentifier?: string): NSItemProvider;
        static createWithObject(object_: NSItemProviderWriting): NSItemProvider;
        loadDataRepresentationWithForTypeIdentifierCompletionHandler(forTypeIdentifier: string, completionHandler?: (p1: NSData, p2: NSError) => void): Progress;
        loadFileRepresentationWithForTypeIdentifierCompletionHandler(forTypeIdentifier: string, completionHandler?: (p1: NSURL, p2: NSError) => void): Progress;
        loadInPlaceFileRepresentationWithForTypeIdentifierCompletionHandler(forTypeIdentifier: string, completionHandler?: (p1: NSURL, p2: boolean, p3: NSError) => void): Progress;
        loadItemWithForTypeIdentifierOptionsCompletionHandler(forTypeIdentifier: string, options?: Map<any, any>, completionHandler?: (p1: NSSecureCoding, p2: NSError) => void): void;
        loadObjectWithOfClassCompletionHandler(ofClass: typeof NSObject, completionHandler?: (p1: NSItemProviderReading, p2: NSError) => void): Progress;
        loadPreviewImageWithOptionsCompletionHandler(options: Map<any, any>, completionHandler: (p1: NSSecureCoding, p2: NSError) => void): void;
        registerCloudKitShareContainer(_: CKShare, container: CKContainer): void;
        registerCloudKitShareWithPreparationHandler(preparationHandler?: (p1: (p1: CKShare, p2: CKContainer, p3: NSError) => void) => void): void;
        registerDataRepresentationWithForTypeIdentifierVisibilityLoadHandler(forTypeIdentifier: string, visibility: NSItemProviderRepresentationVisibility, loadHandler?: (p1: (p1: NSData, p2: NSError) => void) => Progress): void;
        registerFileRepresentationWithForTypeIdentifierFileOptionsVisibilityLoadHandler(forTypeIdentifier: string, fileOptions: NSItemProviderFileOptions, visibility: NSItemProviderRepresentationVisibility, loadHandler?: (p1: (p1: NSURL, p2: boolean, p3: NSError) => void) => Progress): void;
        registerItemWithForTypeIdentifierLoadHandler(forTypeIdentifier: string, loadHandler: (p1: (p1: NSSecureCoding, p2: NSError) => void, p2: typeof NSObject, p3: Map<any, any>) => void): void;
        registerObjectVisibility(_: NSItemProviderWriting, visibility: NSItemProviderRepresentationVisibility): void;
        registerObjectWithOfClassVisibilityLoadHandler(ofClass: typeof NSObject, visibility: NSItemProviderRepresentationVisibility, loadHandler?: (p1: (p1: NSItemProviderWriting, p2: NSError) => void) => Progress): void;
        registeredTypeIdentifiersWithFileOptions(fileOptions: NSItemProviderFileOptions): string[];
    }
    interface NSItemProviderReading extends NSObject {
    }
    interface NSItemProviderWriting extends NSObject {
        writableTypeIdentifiersForItemProvider?: string[];
        itemProviderVisibilityForRepresentationWithTypeIdentifier?(withTypeIdentifier: string): NSItemProviderRepresentationVisibility;
        loadDataWithWithTypeIdentifierForItemProviderCompletionHandler(withTypeIdentifier: string, forItemProviderCompletionHandler?: (p1: NSData, p2: NSError) => void): Progress;
    }
    class JSONSerialization extends NSObject {
        static JSONObjectWithDataOptionsError(options: NSData, error: JSONSerialization.ReadingOptions): any;
        static JSONObjectWithStreamOptionsError(options: InputStream, error: JSONSerialization.ReadingOptions): any;
        static dataWithJSONObjectOptionsError(options: any, error: JSONSerialization.WritingOptions): NSData;
        static isValidJSONObject(_: any): boolean;
        static writeJSONObjectToStreamOptionsError(toStream: any, options: OutputStream, error: JSONSerialization.WritingOptions): number;
    }
    class NSKeyedArchiver extends NSCoder {
        static archivedDataWithRootObjectRequiringSecureCodingError(requiringSecureCoding: any, error: boolean): NSData;
        static classNameForClass(for_: typeof NSObject): string;
        static setClassNameForClass(_?: string, for_?: typeof NSObject): void;
        delegate: NSKeyedArchiverDelegate;
        setDelegate(_: NSKeyedArchiverDelegate): any;
        encodedData: NSData;
        outputFormat: PropertyListSerialization.PropertyListFormat;
        setOutputFormat(_: PropertyListSerialization.PropertyListFormat): any;
        classNameForClass(for_: typeof NSObject): string;
        finishEncoding(): void;
        static createWithRequiringSecureCoding(requiringSecureCoding: boolean): NSKeyedArchiver;
        setClassNameForClass(_?: string, for_?: typeof NSObject): void;
    }
    interface NSKeyedArchiverDelegate extends NSObject {
        archiverWillEncodeObject?(_: NSKeyedArchiver, willEncode: any): any;
        archiverDidEncodeObject?(_: NSKeyedArchiver, didEncode?: any): void;
        archiverWillReplaceObjectWithObject?(_: NSKeyedArchiver, willReplace?: any, with_?: any): void;
        archiverDidFinish?(_: NSKeyedArchiver): void;
        archiverWillFinish?(_: NSKeyedArchiver): void;
    }
    class NSKeyedUnarchiver extends NSCoder {
        static classForClassName(forClassName: string): typeof NSObject;
        static setClassForClassName(_?: typeof NSObject, forClassName?: string): void;
        static unarchivedObjectOfClassFromDataError(fromData: typeof NSObject, error: NSData): any;
        static unarchivedObjectOfClassesWithFromDataError(fromData: NSSet<typeof NSObject>, error: NSData): any;
        delegate: NSKeyedUnarchiverDelegate;
        setDelegate(_: NSKeyedUnarchiverDelegate): any;
        classForClassName(forClassName: string): typeof NSObject;
        finishDecoding(): void;
        static createWithForReadingFromData(forReadingFromData: NSData): NSKeyedUnarchiver;
        setClassForClassName(_?: typeof NSObject, forClassName?: string): void;
    }
    interface NSKeyedUnarchiverDelegate extends NSObject {
        unarchiverDidDecodeObject?(_: NSKeyedUnarchiver, didDecode?: any): any;
        unarchiverWillReplaceObjectWithObject?(_: NSKeyedUnarchiver, willReplace: any, with_: any): void;
        unarchiverCannotDecodeObjectOfClassNameOriginalClasses?(_: NSKeyedUnarchiver, cannotDecodeObjectOfClassName: string, originalClasses: string[]): typeof NSObject;
        unarchiverDidFinish?(_: NSKeyedUnarchiver): void;
        unarchiverWillFinish?(_: NSKeyedUnarchiver): void;
    }
    class LengthFormatter extends Formatter {
        isForPersonHeightUse: boolean;
        setForPersonHeightUse(_: boolean): any;
        numberFormatter: NumberFormatter;
        setNumberFormatter(_: NumberFormatter): any;
        unitStyle: Formatter.UnitStyle;
        setUnitStyle(_: Formatter.UnitStyle): any;
        stringFromMeters(_: number): string;
        stringFromValueUnit(_: number, unit: LengthFormatter.Unit): string;
        unitStringFromMetersUsedUnit(_: number, usedUnit?: LengthFormatter.Unit): string;
        unitStringFromValueUnit(_: number, unit: LengthFormatter.Unit): string;
    }
    class NSLinguisticTagger extends NSObject {
        static availableTagSchemesForLanguage(forLanguage: string): string[];
        static availableTagSchemesForUnitLanguage(for_: NSLinguisticTaggerUnit, language: string): string[];
        static dominantLanguageForString(for_: string): string;
        static enumerateTagsForRangeUnitSchemeOptionsOrthographyUsing(for_: string, range: NSRange, unit: NSLinguisticTaggerUnit, scheme: string, options: NSLinguisticTagger.Options, orthography?: NSOrthography, using?: (p1: string, p2: NSRange, p3: boolean) => void): void;
        static tagForStringAtIndexUnitSchemeOrthographyTokenRange(for_: string, at: number, unit: NSLinguisticTaggerUnit, scheme: string, orthography?: NSOrthography, tokenRange?: NSRange): string;
        static tagsForStringRangeUnitSchemeOptionsOrthographyTokenRanges(for_: string, range: NSRange, unit: NSLinguisticTaggerUnit, scheme: string, options: NSLinguisticTagger.Options, orthography?: NSOrthography, tokenRanges?: NSValue[]): string[];
        dominantLanguage: string;
        string: string;
        setString(_: string): any;
        tagSchemes: string[];
        enumerateTagsWithInSchemeOptionsUsing(in_: NSRange, scheme: string, options: NSLinguisticTagger.Options, using?: (p1: string, p2: NSRange, p3: NSRange, p4: boolean) => void): void;
        enumerateTagsWithInUnitSchemeOptionsUsing(in_: NSRange, unit: NSLinguisticTaggerUnit, scheme: string, options: NSLinguisticTagger.Options, using?: (p1: string, p2: NSRange, p3: boolean) => void): void;
        static createWithTagSchemesOptions(tagSchemes: string[], options: number): NSLinguisticTagger;
        orthographyAtIndexEffectiveRange(at: number, effectiveRange?: NSRange): NSOrthography;
        possibleTagsAtIndexSchemeTokenRangeSentenceRangeScores(at: number, scheme: string, tokenRange?: NSRange, sentenceRange?: NSRange, scores?: NSValue[]): string[];
        sentenceRangeForRange(for_: NSRange): NSRange;
        setOrthographyRange(_?: NSOrthography, range?: NSRange): void;
        stringEditedInRangeChangeInLength(in_: NSRange, changeInLength: number): void;
        tagAtIndexSchemeTokenRangeSentenceRange(at: number, scheme: string, tokenRange?: NSRange, sentenceRange?: NSRange): string;
        tagAtIndexUnitSchemeTokenRange(at: number, unit: NSLinguisticTaggerUnit, scheme: string, tokenRange?: NSRange): string;
        tagsInRangeSchemeOptionsTokenRanges(in_: NSRange, scheme: string, options: NSLinguisticTagger.Options, tokenRanges?: NSValue[]): string[];
        tagsInRangeUnitSchemeOptionsTokenRanges(in_: NSRange, unit: NSLinguisticTaggerUnit, scheme: string, options: NSLinguisticTagger.Options, tokenRanges?: NSValue[]): string[];
        tokenRangeAtIndexUnit(at: number, unit: NSLinguisticTaggerUnit): NSRange;
    }
    class ListFormatter extends Formatter {
        static localizedStringByJoiningStrings(_: string[]): string;
        itemFormatter: Formatter;
        setItemFormatter(_: Formatter): any;
        locale: NSLocale;
        setLocale(_: NSLocale): any;
        stringFromItems(from: any[]): string;
    }
    class NSLocale extends NSObject {
        static canonicalLanguageIdentifierFromString(from: string): string;
        static canonicalLocaleIdentifierFromString(from: string): string;
        static characterDirectionForLanguage(forLanguage: string): NSLocale.LanguageDirection;
        static componentsFromLocaleIdentifier(fromLocaleIdentifier: string): Map<string, string>;
        static lineDirectionForLanguage(forLanguage: string): NSLocale.LanguageDirection;
        static localeIdentifierFromComponents(fromComponents: Map<string, string>): string;
        static localeIdentifierFromWindowsLocaleCode(fromWindowsLocaleCode: number): string;
        static windowsLocaleCodeFromLocaleIdentifier(fromLocaleIdentifier: string): number;
        alternateQuotationBeginDelimiter: string;
        alternateQuotationEndDelimiter: string;
        calendarIdentifier: string;
        collationIdentifier: string;
        collatorIdentifier: string;
        countryCode: string;
        currencyCode: string;
        currencySymbol: string;
        decimalSeparator: string;
        exemplarCharacterSet: NSCharacterSet;
        groupingSeparator: string;
        languageCode: string;
        localeIdentifier: string;
        quotationBeginDelimiter: string;
        quotationEndDelimiter: string;
        scriptCode: string;
        usesMetricSystem: boolean;
        variantCode: string;
        static ISOCountryCodes: string[];
        static ISOCurrencyCodes: string[];
        static ISOLanguageCodes: string[];
        static autoupdatingCurrentLocale: NSLocale;
        static availableLocaleIdentifiers: string[];
        static commonISOCurrencyCodes: string[];
        static currentLocale: NSLocale;
        static preferredLanguages: string[];
        static systemLocale: NSLocale;
        displayNameForKeyValue(forKey: string, value: any): string;
        static createWithLocaleIdentifier(localeIdentifier: string): NSLocale;
        localizedStringForCalendarIdentifier(forCalendarIdentifier: string): string;
        localizedStringForCollationIdentifier(forCollationIdentifier: string): string;
        localizedStringForCollatorIdentifier(forCollatorIdentifier: string): string;
        localizedStringForCountryCode(forCountryCode: string): string;
        localizedStringForCurrencyCode(forCurrencyCode: string): string;
        localizedStringForLanguageCode(forLanguageCode: string): string;
        localizedStringForLocaleIdentifier(forLocaleIdentifier: string): string;
        localizedStringForScriptCode(forScriptCode: string): string;
        localizedStringForVariantCode(forVariantCode: string): string;
        objectForKey(forKey: string): any;
    }
    class NSLock extends NSObject {
        name: string;
        setName(_: string): any;
        lockBeforeDate(before: Date): boolean;
        tryLock(): boolean;
    }
    interface NSLocking {
        lock(): void;
        unlock(): void;
    }
    class NSLogicalTest extends NSScriptWhoseTest {
        static createWithAndTestWithTests(andTestWithTests: NSSpecifierTest[]): NSLogicalTest;
        static createWithNotTestWithTest(notTestWithTest: NSScriptWhoseTest): NSLogicalTest;
        static createWithOrTestWithTests(orTestWithTests: NSSpecifierTest[]): NSLogicalTest;
    }
    class NSMachPort extends Port {
        static portWithMachPort(withMachPort: number): Port;
        static portWithMachPortOptions(withMachPort: number, options: NSMachPort.Options): Port;
        machPort: number;
        static createWithMachPort(machPort: number): NSMachPort;
        static createWithMachPortOptions(machPort: number, options: NSMachPort.Options): NSMachPort;
    }
    interface NSMachPortDelegate extends PortDelegate {
        handleMachMessage?(_: any): void;
    }
    class NSMapTable<KeyType, ObjectType> extends NSObject {
        static strongToStrongObjectsMapTable<KeyType, ObjectType>(): NSMapTable<KeyType, ObjectType>;
        static strongToWeakObjectsMapTable<KeyType, ObjectType>(): NSMapTable<KeyType, ObjectType>;
        static weakToStrongObjectsMapTable<KeyType, ObjectType>(): NSMapTable<KeyType, ObjectType>;
        static weakToWeakObjectsMapTable<KeyType, ObjectType>(): NSMapTable<KeyType, ObjectType>;
        count: number;
        keyPointerFunctions: NSPointerFunctions;
        valuePointerFunctions: NSPointerFunctions;
        dictionaryRepresentation(): Map<KeyType, ObjectType>;
        keyEnumerator(): NSEnumerator<KeyType>;
        objectEnumerator(): NSEnumerator<ObjectType>;
        objectForKey(forKey?: KeyType): ObjectType;
        removeAllObjects(): void;
        removeObjectForKey(forKey?: KeyType): void;
        setObjectForKey(_?: ObjectType, forKey?: KeyType): void;
    }
    interface NSMapTableKeyCallBacks {
        hash: (p1: NSMapTable<any, any>, p2: any) => number;
        isEqual: (p1: NSMapTable<any, any>, p2: any, p3: any) => boolean;
        retain: (p1: NSMapTable<any, any>, p2: any) => void;
        release: (p1: NSMapTable<any, any>, p2: any) => void;
        describe: (p1: NSMapTable<any, any>, p2: any) => string;
        notAKeyMarker: any;
    }
    interface NSMapTableValueCallBacks {
        retain: (p1: NSMapTable<any, any>, p2: any) => void;
        release: (p1: NSMapTable<any, any>, p2: any) => void;
        describe: (p1: NSMapTable<any, any>, p2: any) => string;
    }
    class MassFormatter extends Formatter {
        isForPersonMassUse: boolean;
        setForPersonMassUse(_: boolean): any;
        numberFormatter: NumberFormatter;
        setNumberFormatter(_: NumberFormatter): any;
        unitStyle: Formatter.UnitStyle;
        setUnitStyle(_: Formatter.UnitStyle): any;
        stringFromKilograms(_: number): string;
        stringFromValueUnit(_: number, unit: MassFormatter.Unit): string;
        unitStringFromKilogramsUsedUnit(_: number, usedUnit?: MassFormatter.Unit): string;
        unitStringFromValueUnit(_: number, unit: MassFormatter.Unit): string;
    }
    class NSMeasurement<UnitType> extends NSObject {
        doubleValue: number;
        unit: UnitType;
        canBeConvertedToUnit(to: Unit): boolean;
        adding(_: NSMeasurement<UnitType>): NSMeasurement<UnitType>;
        measurementByConvertingToUnit(to: Unit): NSMeasurement<any>;
        subtracting(_: NSMeasurement<UnitType>): NSMeasurement<UnitType>;
    }
    class MeasurementFormatter extends Formatter {
        locale: NSLocale;
        setLocale(_: NSLocale): any;
        numberFormatter: NumberFormatter;
        setNumberFormatter(_: NumberFormatter): any;
        unitOptions: MeasurementFormatter.UnitOptions;
        setUnitOptions(_: MeasurementFormatter.UnitOptions): any;
        unitStyle: Formatter.UnitStyle;
        setUnitStyle(_: Formatter.UnitStyle): any;
        stringFromMeasurement(_: NSMeasurement<any>): string;
        stringFromUnit(_: Unit): string;
    }
    class MessagePort extends Port {
    }
    class NSMetadataItem extends NSObject {
        attributes: string[];
        static createWithUrl(URL: NSURL): NSMetadataItem;
        valueForAttribute(forAttribute: string): any;
        valuesForAttributes(forAttributes: string[]): Map<string, any>;
    }
    class NSMetadataQuery extends NSObject {
        delegate: NSMetadataQueryDelegate;
        setDelegate(_: NSMetadataQueryDelegate): any;
        isGathering: boolean;
        groupedResults: NSMetadataQueryResultGroup[];
        groupingAttributes: string[];
        setGroupingAttributes(_: string[]): any;
        notificationBatchingInterval: number;
        setNotificationBatchingInterval(_: number): any;
        operationQueue: OperationQueue;
        setOperationQueue(_: OperationQueue): any;
        predicate: NSPredicate;
        setPredicate(_: NSPredicate): any;
        resultCount: number;
        results: any[];
        searchItems: any[];
        setSearchItems(_: any[]): any;
        searchScopes: any[];
        setSearchScopes(_: any[]): any;
        sortDescriptors: NSSortDescriptor[];
        setSortDescriptors(_: NSSortDescriptor[]): any;
        isStarted: boolean;
        isStopped: boolean;
        valueListAttributes: string[];
        setValueListAttributes(_: string[]): any;
        valueLists: Map<string, NSMetadataQueryAttributeValueTuple[]>;
        disableUpdates(): void;
        enableUpdates(): void;
        enumerateResults(_: (p1: any, p2: number, p3: boolean) => void): void;
        enumerateResultsWithOptionsUsing(options: NSEnumerationOptions, using: (p1: any, p2: number, p3: boolean) => void): void;
        indexOfResult(ofResult: any): number;
        resultAtIndex(at: number): any;
        startQuery(): boolean;
        stopQuery(): void;
        valueOfAttributeForResultAtIndex(ofAttribute: string, forResultAt: number): any;
    }
    class NSMetadataQueryAttributeValueTuple extends NSObject {
        attribute: string;
        count: number;
        value: any;
    }
    interface NSMetadataQueryDelegate extends NSObject {
        metadataQueryReplacementObjectForResultObject?(_: NSMetadataQuery, replacementObjectForResultObject: NSMetadataItem): any;
        metadataQueryReplacementValueForAttributeValue?(_: NSMetadataQuery, replacementValueForAttribute: string, value: any): any;
    }
    class NSMetadataQueryResultGroup extends NSObject {
        attribute: string;
        resultCount: number;
        results: any[];
        subgroups: NSMetadataQueryResultGroup[];
        value: any;
        resultAtIndex(at: number): any;
    }
    class NSMiddleSpecifier extends NSScriptObjectSpecifier {
    }
    class NSMoveCommand extends NSScriptCommand {
        keySpecifier: NSScriptObjectSpecifier;
        setReceiversSpecifier(_?: NSScriptObjectSpecifier): void;
    }
    class NSMutableArray<ObjectType> extends NSArray<ObjectType> {
        static arrayWithCapacity<ObjectType>(capacity: number): NSMutableArray<ObjectType>;
        addObject(_: ObjectType): void;
        addObjectsFromArray(from: ObjectType[]): void;
        exchangeObjectAtIndexWithObjectAtIndex(at: number, withObjectAt: number): void;
        filterUsingPredicate(using: NSPredicate): void;
        insertObjectAtIndex(_: ObjectType, at: number): void;
        insertObjectsAtIndexes(_: ObjectType[], at: NSIndexSet): void;
        removeAllObjects(): void;
        removeLastObject(): void;
        removeObject(_: ObjectType): void;
        removeObjectInRange(_: ObjectType, in_: NSRange): void;
        removeObjectAtIndex(at: number): void;
        removeObjectIdenticalTo(identicalTo: ObjectType): void;
        removeObjectIdenticalToInRange(identicalTo: ObjectType, in_: NSRange): void;
        removeObjectsAtIndexes(at: NSIndexSet): void;
        removeObjectsInArray(in_: ObjectType[]): void;
        removeObjectsInRange(in_: NSRange): void;
        replaceObjectAtIndexWithObject(at: number, with_: ObjectType): void;
        replaceObjectsAtIndexesWithObjects(at: NSIndexSet, with_: ObjectType[]): void;
        replaceObjectsInRangeWithObjectsFromArray(in_: NSRange, withObjectsFrom: ObjectType[]): void;
        replaceObjectsInRangeWithObjectsFromArrayRange(in_: NSRange, withObjectsFrom: ObjectType[], range: NSRange): void;
        setArray(_: ObjectType[]): void;
        setObjectAtIndexedSubscript(_: ObjectType, atIndexedSubscript: number): void;
        sortWithComparator(comparator: (p1: any, p2: any) => ComparisonResult): void;
        sortUsingDescriptors(using: NSSortDescriptor[]): void;
        sortContext(_?: (p1: ObjectType, p2: ObjectType, p3: any) => number, context?: any): void;
        sortUsingSelector(using: string): void;
        sortWithOptionsUsingComparator(options: NSSortOptions, usingComparator: (p1: any, p2: any) => ComparisonResult): void;
    }
    class NSMutableAttributedString extends NSAttributedString {
        mutableString: NSMutableString;
        addAttributeValueRange(_: string, value: any, range: NSRange): void;
        addAttributesRange(_: Map<string, any>, range: NSRange): void;
        appendAttributedString(_: NSAttributedString): void;
        applyFontTraitsRange(_: NSFontTraitMask, range: NSRange): void;
        beginEditing(): void;
        deleteCharactersInRange(in_: NSRange): void;
        endEditing(): void;
        fixAttachmentAttributeInRange(in_: NSRange): void;
        fixAttributesInRange(in_: NSRange): void;
        fixFontAttributeInRange(in_: NSRange): void;
        fixParagraphStyleAttributeInRange(in_: NSRange): void;
        insertAttributedStringAtIndex(_: NSAttributedString, at: number): void;
        readFromDataOptionsDocumentAttributesError(from: NSData, options: Map<string, any>, documentAttributes?: Map<string, any>): boolean;
        readFromURLOptionsDocumentAttributesError(from: NSURL, options: Map<string, any>, documentAttributes?: Map<string, any>): boolean;
        removeAttributeRange(_: string, range: NSRange): void;
        replaceCharactersInRangeWithAttributedString(in_: NSRange, with_: NSAttributedString): void;
        replaceCharactersInRangeWithString(in_: NSRange, with_: string): void;
        setAlignmentRange(_: NSTextAlignment, range: NSRange): void;
        setAttributedString(_: NSAttributedString): void;
        setAttributesRange(_?: Map<string, any>, range?: NSRange): void;
        setBaseWritingDirectionRange(_: NSWritingDirection, range: NSRange): void;
        subscriptRange(_: NSRange): void;
        superscriptRange(_: NSRange): void;
        unscriptRange(_: NSRange): void;
        updateAttachmentsFromPath(fromPath: string): void;
    }
    class NSMutableCharacterSet extends NSCharacterSet {
        addCharactersInRange(in_: NSRange): void;
        addCharactersInString(in_: string): void;
        formIntersectionWithCharacterSet(with_: NSCharacterSet): void;
        formUnionWithCharacterSet(with_: NSCharacterSet): void;
        invert(): void;
        removeCharactersInRange(in_: NSRange): void;
        removeCharactersInString(in_: string): void;
    }
    interface NSMutableCopying {
    }
    class NSMutableData extends NSData {
        static dataWithCapacity(capacity: number): NSMutableData;
        static dataWithLength(length: number): NSMutableData;
        mutableBytes: any;
        appendBytesLength(_: any, length: number): void;
        appendData(_: NSData): void;
        compressUsingAlgorithmError(error: NSData.CompressionAlgorithm): boolean;
        decompressUsingAlgorithmError(error: NSData.CompressionAlgorithm): boolean;
        increaseLengthBy(by: number): void;
        static createWithCapacity(capacity: number): NSMutableData;
        static createWithLength(length: number): NSMutableData;
        replaceBytesInRangeWithBytes(in_: NSRange, withBytes: any): void;
        replaceBytesInRangeWithBytesLength(in_: NSRange, withBytes?: any, length?: number): void;
        resetBytesInRange(in_: NSRange): void;
        setData(_: NSData): void;
    }
    class NSMutableDictionary<KeyType, ObjectType> extends NSDictionary<KeyType, ObjectType> {
        static dictionaryWithCapacity<KeyType, ObjectType>(capacity: number): NSMutableDictionary<KeyType, ObjectType>;
        static dictionaryWithSharedKeySet<KeyType, ObjectType>(sharedKeySet: any): NSMutableDictionary<KeyType, ObjectType>;
        addEntriesFromDictionary(from: Map<KeyType, ObjectType>): void;
        removeAllObjects(): void;
        removeObjectForKey(forKey: KeyType): void;
        removeObjectsForKeys(forKeys: KeyType[]): void;
        setDictionary(_: Map<KeyType, ObjectType>): void;
        setObjectForKey(_: ObjectType, forKey: KeyType): void;
        setObjectForKeyedSubscript(_?: ObjectType, forKeyedSubscript?: KeyType): void;
    }
    class NSMutableIndexSet extends NSIndexSet {
        addIndex(_: number): void;
        addIndexes(_: NSIndexSet): void;
        addIndexesInRange(in_: NSRange): void;
        removeAllIndexes(): void;
        removeIndex(_: number): void;
        removeIndexes(_: NSIndexSet): void;
        removeIndexesInRange(in_: NSRange): void;
        shiftIndexesStartingAtIndexBy(at: number, by: number): void;
    }
    class NSMutableOrderedSet<ObjectType> extends NSOrderedSet<ObjectType> {
        static orderedSetWithCapacity<ObjectType>(capacity: number): NSMutableOrderedSet<ObjectType>;
        addObject(_: ObjectType): void;
        addObjectsCount(_?: ObjectType, count?: number): void;
        addObjectsFromArray(from: ObjectType[]): void;
        exchangeObjectAtIndexWithObjectAtIndex(at: number, withObjectAt: number): void;
        filterUsingPredicate(using: NSPredicate): void;
        insertObjectAtIndex(_: ObjectType, at: number): void;
        insertObjectsAtIndexes(_: ObjectType[], at: NSIndexSet): void;
        intersect(_: NSOrderedSet<ObjectType>): void;
        intersectSet(_: NSSet<ObjectType>): void;
        minus(_: NSOrderedSet<ObjectType>): void;
        minusSet(_: NSSet<ObjectType>): void;
        moveObjectsAtIndexesToIndex(at: NSIndexSet, to: number): void;
        removeAllObjects(): void;
        removeObject(_: ObjectType): void;
        removeObjectAtIndex(at: number): void;
        removeObjectsAtIndexes(at: NSIndexSet): void;
        removeObjectsInArray(in_: ObjectType[]): void;
        removeObjectsInRange(in_: NSRange): void;
        replaceObjectAtIndexWithObject(at: number, with_: ObjectType): void;
        replaceObjectsAtIndexesWithObjects(at: NSIndexSet, with_: ObjectType[]): void;
        replaceObjectsInRangeWithObjectsCount(in_: NSRange, with_?: ObjectType, count?: number): void;
        setObjectAtIndex(_: ObjectType, at: number): void;
        setObjectAtIndexedSubscript(_: ObjectType, atIndexedSubscript: number): void;
        sortRangeWithOptionsUsingComparator(_: NSRange, options: NSSortOptions, usingComparator: (p1: any, p2: any) => ComparisonResult): void;
        sortWithComparator(comparator: (p1: any, p2: any) => ComparisonResult): void;
        sortUsingDescriptors(using: NSSortDescriptor[]): void;
        sortWithOptionsUsingComparator(options: NSSortOptions, usingComparator: (p1: any, p2: any) => ComparisonResult): void;
        union(_: NSOrderedSet<ObjectType>): void;
        unionSet(_: NSSet<ObjectType>): void;
    }
    class NSMutableSet<ObjectType> extends NSSet<ObjectType> {
        static setWithCapacity<ObjectType>(capacity: number): NSMutableSet<ObjectType>;
        addObject(_: ObjectType): void;
        addObjectsFromArray(from: ObjectType[]): void;
        filterUsingPredicate(using: NSPredicate): void;
        intersect(_: NSSet<ObjectType>): void;
        minus(_: NSSet<ObjectType>): void;
        removeAllObjects(): void;
        removeObject(_: ObjectType): void;
        setSet(_: NSSet<ObjectType>): void;
        union(_: NSSet<ObjectType>): void;
    }
    class NSMutableString extends NSString {
        static stringWithCapacity(capacity: number): NSMutableString;
        appendString(_: string): void;
        applyTransformReverseRangeUpdatedRange(_: string, reverse: boolean, range: NSRange, updatedRange?: NSRange): boolean;
        deleteCharactersInRange(in_: NSRange): void;
        static createWithCapacity(capacity: number): NSMutableString;
        insertStringAtIndex(_: string, at: number): void;
        replaceCharactersInRangeWithString(in_: NSRange, with_: string): void;
        replaceOccurrencesOfStringWithStringOptionsRange(of: string, with_: string, options: NSString.CompareOptions, range: NSRange): number;
        setString(_: string): void;
    }
    class NSMutableURLRequest extends NSURLRequest {
        addValueForHTTPHeaderField(_: string, forHTTPHeaderField: string): void;
        setValueForHTTPHeaderField(_?: string, forHTTPHeaderField?: string): void;
    }
    class NSNameSpecifier extends NSScriptObjectSpecifier {
        name: string;
        setName(_: string): any;
        static createWithContainerClassDescriptionContainerSpecifierKeyName(containerClassDescription: NSScriptClassDescription, containerSpecifier?: NSScriptObjectSpecifier, key?: string, name?: string): NSNameSpecifier;
    }
    class NetService extends NSObject {
        static dataFromTXTRecordDictionary(_: Map<string, Data>): NSData;
        static dictionaryFromTXTRecordData(_: NSData): Map<string, Data>;
        addresses: NSData[];
        delegate: NetServiceDelegate;
        setDelegate(_: NetServiceDelegate): any;
        domain: string;
        hostName: string;
        includesPeerToPeer: boolean;
        setIncludesPeerToPeer(_: boolean): any;
        name: string;
        port: number;
        type: string;
        TXTRecordData(): NSData;
        getInputStreamOutputStream(_?: InputStream, outputStream?: OutputStream): boolean;
        static createWithDomainTypeName(domain: string, type: string, name: string): NetService;
        static createWithDomainTypeNamePort(domain: string, type: string, name: string, port: number): NetService;
        publish(): void;
        publishWithOptions(_: NetService.Options): void;
        removeFromRunLoopForMode(_: RunLoop, forMode: string): void;
        resolveWithTimeout(_: number): void;
        scheduleInRunLoopForMode(_: RunLoop, forMode: string): void;
        setTXTRecordData(_?: NSData): boolean;
        startMonitoring(): void;
        stop(): void;
        stopMonitoring(): void;
    }
    class NetServiceBrowser extends NSObject {
        delegate: NetServiceBrowserDelegate;
        setDelegate(_: NetServiceBrowserDelegate): any;
        includesPeerToPeer: boolean;
        setIncludesPeerToPeer(_: boolean): any;
        removeFromRunLoopForMode(_: RunLoop, forMode: string): void;
        scheduleInRunLoopForMode(_: RunLoop, forMode: string): void;
        searchForBrowsableDomains(): void;
        searchForRegistrationDomains(): void;
        searchForServicesOfTypeInDomain(_: string, inDomain: string): void;
        stop(): void;
    }
    interface NetServiceBrowserDelegate extends NSObject {
        netServiceBrowserDidFindDomainMoreComing?(_: NetServiceBrowser, didFindDomain: string, moreComing: boolean): void;
        netServiceBrowserDidFindServiceMoreComing?(_: NetServiceBrowser, didFindService: NetService, moreComing: boolean): void;
        netServiceBrowserDidNotSearch?(_: NetServiceBrowser, didNotSearch: Map<string, number>): void;
        netServiceBrowserDidRemoveDomainMoreComing?(_: NetServiceBrowser, didRemoveDomain: string, moreComing: boolean): void;
        netServiceBrowserDidRemoveServiceMoreComing?(_: NetServiceBrowser, didRemoveService: NetService, moreComing: boolean): void;
        netServiceBrowserDidStopSearch?(_: NetServiceBrowser): void;
        netServiceBrowserWillSearch?(_: NetServiceBrowser): void;
    }
    interface NetServiceDelegate extends NSObject {
        netServiceDidAcceptConnectionWithInputStreamOutputStream?(_: NetService, didAcceptConnectionWithInputStream: InputStream, outputStream: OutputStream): void;
        netServiceDidNotPublish?(_: NetService, didNotPublish: Map<string, number>): void;
        netServiceDidNotResolve?(_: NetService, didNotResolve: Map<string, number>): void;
        netServiceDidUpdateTXTRecordData?(_: NetService, didUpdateTXTRecordData: NSData): void;
        netServiceDidPublish?(_: NetService): void;
        netServiceDidResolveAddress?(_: NetService): void;
        netServiceDidStop?(_: NetService): void;
        netServiceWillPublish?(_: NetService): void;
        netServiceWillResolve?(_: NetService): void;
    }
    class NSNotification extends NSObject {
        name: string;
        object: any;
        userInfo: Map<any, any>;
        static createWithNameObjectUserInfo(name: string, object_?: any, userInfo?: Map<any, any>): NSNotification;
    }
    class NotificationCenter extends NSObject {
        static defaultCenter: NotificationCenter;
        addObserverSelectorNameObject(_: any, selector: string, name?: string, object_?: any): void;
        addObserverForNameWithObjectQueueUsingBlock(_?: string, object_?: any, queue?: OperationQueue, usingBlock?: (p1: NSNotification) => void): NSObject;
        postNotification(_: NSNotification): void;
        postNotificationNameObject(name: string, object_?: any): void;
        postNotificationNameObjectUserInfo(name: string, object_?: any, userInfo?: Map<any, any>): void;
        removeObserver(_: any): void;
        removeObserverNameObject(_: any, name?: string, object_?: any): void;
    }
    class NotificationQueue extends NSObject {
        static defaultQueue: NotificationQueue;
        dequeueNotificationsMatchingCoalesceMask(_: NSNotification, coalesceMask: number): void;
        enqueueNotificationPostingStyle(_: NSNotification, postingStyle: NotificationQueue.PostingStyle): void;
        enqueueNotificationPostingStyleCoalesceMaskForModes(_: NSNotification, postingStyle: NotificationQueue.PostingStyle, coalesceMask: NotificationQueue.NotificationCoalescing, forModes?: string[]): void;
        static createWithNotificationCenter(notificationCenter: NotificationCenter): NotificationQueue;
    }
    class NSNull extends NSObject {
    }
    class NSNumber extends NSValue {
        static numberWithBool(bool: boolean): number;
        static numberWithChar(char: number): number;
        static numberWithDouble(double: number): number;
        static numberWithFloat(float: number): number;
        static numberWithInt(int: number): number;
        static numberWithInteger(integer: number): number;
        static numberWithLong(long: number): number;
        static numberWithLongLong(longLong: number): number;
        static numberWithShort(short: number): number;
        static numberWithUnsignedChar(unsignedChar: number): number;
        static numberWithUnsignedInt(unsignedInt: number): number;
        static numberWithUnsignedInteger(unsignedInteger: number): number;
        static numberWithUnsignedLong(unsignedLong: number): number;
        static numberWithUnsignedLongLong(unsignedLongLong: number): number;
        static numberWithUnsignedShort(unsignedShort: number): number;
        boolValue: boolean;
        charValue: number;
        decimalValue: number;
        doubleValue: number;
        floatValue: number;
        intValue: number;
        integerValue: number;
        longLongValue: number;
        longValue: number;
        shortValue: number;
        stringValue: string;
        unsignedCharValue: number;
        unsignedIntValue: number;
        unsignedIntegerValue: number;
        unsignedLongLongValue: number;
        unsignedLongValue: number;
        unsignedShortValue: number;
        compare(_: number): ComparisonResult;
        descriptionWithLocale(withLocale?: any): string;
        static createWithBool(bool: boolean): NSNumber;
        static createWithChar(char: number): NSNumber;
        static createWithDouble(double: number): NSNumber;
        static createWithFloat(float: number): NSNumber;
        static createWithInt(int: number): NSNumber;
        static createWithInteger(integer: number): NSNumber;
        static createWithLong(long: number): NSNumber;
        static createWithLongLong(longLong: number): NSNumber;
        static createWithShort(short: number): NSNumber;
        static createWithUnsignedChar(unsignedChar: number): NSNumber;
        static createWithUnsignedInt(unsignedInt: number): NSNumber;
        static createWithUnsignedInteger(unsignedInteger: number): NSNumber;
        static createWithUnsignedLong(unsignedLong: number): NSNumber;
        static createWithUnsignedLongLong(unsignedLongLong: number): NSNumber;
        static createWithUnsignedShort(unsignedShort: number): NSNumber;
        isEqualToNumber(to: number): boolean;
    }
    class NumberFormatter extends Formatter {
        static defaultFormatterBehavior(): NumberFormatter.Behavior;
        static localizedStringFromNumberNumberStyle(_: number, numberStyle: NumberFormatter.Style): string;
        static setDefaultFormatterBehavior(_: NumberFormatter.Behavior): void;
        allowsFloats: boolean;
        setAllowsFloats(_: boolean): any;
        alwaysShowsDecimalSeparator: boolean;
        setAlwaysShowsDecimalSeparator(_: boolean): any;
        attributedStringForNil: NSAttributedString;
        setAttributedStringForNil(_: NSAttributedString): any;
        attributedStringForNotANumber: NSAttributedString;
        setAttributedStringForNotANumber(_: NSAttributedString): any;
        attributedStringForZero: NSAttributedString;
        setAttributedStringForZero(_: NSAttributedString): any;
        currencyCode: string;
        setCurrencyCode(_: string): any;
        currencyDecimalSeparator: string;
        setCurrencyDecimalSeparator(_: string): any;
        currencyGroupingSeparator: string;
        setCurrencyGroupingSeparator(_: string): any;
        currencySymbol: string;
        setCurrencySymbol(_: string): any;
        decimalSeparator: string;
        setDecimalSeparator(_: string): any;
        exponentSymbol: string;
        setExponentSymbol(_: string): any;
        format: string;
        setFormat(_: string): any;
        formatWidth: number;
        setFormatWidth(_: number): any;
        formatterBehavior: NumberFormatter.Behavior;
        setFormatterBehavior(_: NumberFormatter.Behavior): any;
        formattingContext: Formatter.Context;
        setFormattingContext(_: Formatter.Context): any;
        generatesDecimalNumbers: boolean;
        setGeneratesDecimalNumbers(_: boolean): any;
        groupingSeparator: string;
        setGroupingSeparator(_: string): any;
        groupingSize: number;
        setGroupingSize(_: number): any;
        hasThousandSeparators: boolean;
        setHasThousandSeparators(_: boolean): any;
        internationalCurrencySymbol: string;
        setInternationalCurrencySymbol(_: string): any;
        isLenient: boolean;
        setLenient(_: boolean): any;
        locale: NSLocale;
        setLocale(_: NSLocale): any;
        localizesFormat: boolean;
        setLocalizesFormat(_: boolean): any;
        maximum: number;
        setMaximum(_: number): any;
        maximumFractionDigits: number;
        setMaximumFractionDigits(_: number): any;
        maximumIntegerDigits: number;
        setMaximumIntegerDigits(_: number): any;
        maximumSignificantDigits: number;
        setMaximumSignificantDigits(_: number): any;
        minimum: number;
        setMinimum(_: number): any;
        minimumFractionDigits: number;
        setMinimumFractionDigits(_: number): any;
        minimumIntegerDigits: number;
        setMinimumIntegerDigits(_: number): any;
        minimumSignificantDigits: number;
        setMinimumSignificantDigits(_: number): any;
        minusSign: string;
        setMinusSign(_: string): any;
        multiplier: number;
        setMultiplier(_: number): any;
        negativeFormat: string;
        setNegativeFormat(_: string): any;
        negativeInfinitySymbol: string;
        setNegativeInfinitySymbol(_: string): any;
        negativePrefix: string;
        setNegativePrefix(_: string): any;
        negativeSuffix: string;
        setNegativeSuffix(_: string): any;
        nilSymbol: string;
        setNilSymbol(_: string): any;
        notANumberSymbol: string;
        setNotANumberSymbol(_: string): any;
        numberStyle: NumberFormatter.Style;
        setNumberStyle(_: NumberFormatter.Style): any;
        paddingCharacter: string;
        setPaddingCharacter(_: string): any;
        paddingPosition: NumberFormatter.PadPosition;
        setPaddingPosition(_: NumberFormatter.PadPosition): any;
        isPartialStringValidationEnabled: boolean;
        setPartialStringValidationEnabled(_: boolean): any;
        perMillSymbol: string;
        setPerMillSymbol(_: string): any;
        percentSymbol: string;
        setPercentSymbol(_: string): any;
        plusSign: string;
        setPlusSign(_: string): any;
        positiveFormat: string;
        setPositiveFormat(_: string): any;
        positiveInfinitySymbol: string;
        setPositiveInfinitySymbol(_: string): any;
        positivePrefix: string;
        setPositivePrefix(_: string): any;
        positiveSuffix: string;
        setPositiveSuffix(_: string): any;
        roundingBehavior: NSDecimalNumberHandler;
        setRoundingBehavior(_: NSDecimalNumberHandler): any;
        roundingIncrement: number;
        setRoundingIncrement(_: number): any;
        roundingMode: NumberFormatter.RoundingMode;
        setRoundingMode(_: NumberFormatter.RoundingMode): any;
        secondaryGroupingSize: number;
        setSecondaryGroupingSize(_: number): any;
        textAttributesForNegativeInfinity: Map<string, any>;
        setTextAttributesForNegativeInfinity(_: Map<string, any>): any;
        textAttributesForNegativeValues: Map<string, any>;
        setTextAttributesForNegativeValues(_: Map<string, any>): any;
        textAttributesForNil: Map<string, any>;
        setTextAttributesForNil(_: Map<string, any>): any;
        textAttributesForNotANumber: Map<string, any>;
        setTextAttributesForNotANumber(_: Map<string, any>): any;
        textAttributesForPositiveInfinity: Map<string, any>;
        setTextAttributesForPositiveInfinity(_: Map<string, any>): any;
        textAttributesForPositiveValues: Map<string, any>;
        setTextAttributesForPositiveValues(_: Map<string, any>): any;
        textAttributesForZero: Map<string, any>;
        setTextAttributesForZero(_: Map<string, any>): any;
        thousandSeparator: string;
        setThousandSeparator(_: string): any;
        usesGroupingSeparator: boolean;
        setUsesGroupingSeparator(_: boolean): any;
        usesSignificantDigits: boolean;
        setUsesSignificantDigits(_: boolean): any;
        zeroSymbol: string;
        setZeroSymbol(_: string): any;
        getObjectValueForStringRangeError(forString?: any, range?: string, error?: NSRange): boolean;
        numberFromString(_: string): number;
        stringFromNumber(_: number): string;
    }
    interface OperatingSystemVersion {
        majorVersion: number;
        minorVersion: number;
        patchVersion: number;
    }
    class Operation extends NSObject {
        isAsynchronous: boolean;
        isCancelled: boolean;
        completionBlock: () => void;
        setCompletionBlock(_: () => void): any;
        isConcurrent: boolean;
        dependencies: Operation[];
        isExecuting: boolean;
        isFinished: boolean;
        name: string;
        setName(_: string): any;
        qualityOfService: QualityOfService;
        setQualityOfService(_: QualityOfService): any;
        queuePriority: Operation.QueuePriority;
        setQueuePriority(_: Operation.QueuePriority): any;
        isReady: boolean;
        addDependency(_: Operation): void;
        cancel(): void;
        main(): void;
        removeDependency(_: Operation): void;
        start(): void;
        waitUntilFinished(): void;
    }
    class OperationQueue extends NSObject {
        maxConcurrentOperationCount: number;
        setMaxConcurrentOperationCount(_: number): any;
        name: string;
        setName(_: string): any;
        operationCount: number;
        operations: Operation[];
        qualityOfService: QualityOfService;
        setQualityOfService(_: QualityOfService): any;
        isSuspended: boolean;
        setSuspended(_: boolean): any;
        underlyingQueue: NSObject;
        setUnderlyingQueue(_: NSObject): any;
        static currentQueue: OperationQueue;
        static mainQueue: OperationQueue;
        addBarrierBlock(_: () => void): void;
        addOperation(_: Operation): void;
        addOperationWithBlock(_: () => void): void;
        addOperationsWaitUntilFinished(_: Operation[], waitUntilFinished: boolean): void;
        cancelAllOperations(): void;
        waitUntilAllOperationsAreFinished(): void;
    }
    class NSOrderedCollectionChange<ObjectType> extends NSObject {
        associatedIndex: number;
        changeType: NSCollectionChangeType;
        index: number;
        object: ObjectType;
    }
    class NSOrderedCollectionDifference<ObjectType> extends NSObject {
        hasChanges: boolean;
        insertions: NSOrderedCollectionChange<ObjectType>[];
        removals: NSOrderedCollectionChange<ObjectType>[];
        transformingChanges(_: (p1: NSOrderedCollectionChange<ObjectType>) => NSOrderedCollectionChange<any>): NSOrderedCollectionDifference<any>;
        inverseDifference(): NSOrderedCollectionDifference<ObjectType>;
    }
    class NSOrderedSet<ObjectType> extends NSObject {
        static orderedSetWithObjects<ObjectType>(_: ObjectType): NSOrderedSet<ObjectType>;
        array: ObjectType[];
        count: number;
        firstObject: ObjectType;
        lastObject: ObjectType;
        reversedOrderedSet: NSOrderedSet<ObjectType>;
        set: NSSet<ObjectType>;
        containsObject(_: ObjectType): boolean;
        descriptionWithLocale(withLocale?: any): string;
        descriptionWithLocaleIndent(withLocale?: any, indent?: number): string;
        enumerateObjectsWithAtOptionsUsing(at: NSIndexSet, options: NSEnumerationOptions, using: (p1: ObjectType, p2: number, p3: boolean) => void): void;
        enumerateObjects(_: (p1: ObjectType, p2: number, p3: boolean) => void): void;
        enumerateObjectsWithOptionsUsing(options: NSEnumerationOptions, using: (p1: ObjectType, p2: number, p3: boolean) => void): void;
        filteredOrderedSetUsingPredicate(using: NSPredicate): NSOrderedSet<ObjectType>;
        indexOfObject(of: ObjectType): number;
        indexOfInSortedRangeOptionsUsingComparator(of: ObjectType, inSortedRange: NSRange, options: NSBinarySearchingOptions, usingComparator: (p1: any, p2: any) => ComparisonResult): number;
        indexWithOfObjectAtOptionsPassingTest(ofObjectAt: NSIndexSet, options: NSEnumerationOptions, passingTest: (p1: ObjectType, p2: number, p3: boolean) => boolean): number;
        indexWithOfObjectPassingTest(ofObjectPassingTest: (p1: ObjectType, p2: number, p3: boolean) => boolean): number;
        indexOfObjectPassingTest(_: NSEnumerationOptions, ofObjectPassingTest: (p1: ObjectType, p2: number, p3: boolean) => boolean): number;
        indexesWithOfObjectsAtOptionsPassingTest(ofObjectsAt: NSIndexSet, options: NSEnumerationOptions, passingTest: (p1: ObjectType, p2: number, p3: boolean) => boolean): NSIndexSet;
        indexesWithOfObjectsPassingTest(ofObjectsPassingTest: (p1: ObjectType, p2: number, p3: boolean) => boolean): NSIndexSet;
        indexesWithOptionsOfObjectsPassingTest(options: NSEnumerationOptions, ofObjectsPassingTest: (p1: ObjectType, p2: number, p3: boolean) => boolean): NSIndexSet;
        intersects(_: NSOrderedSet<ObjectType>): boolean;
        intersectsSet(_: NSSet<ObjectType>): boolean;
        isEqualWithTo(to: NSOrderedSet<ObjectType>): boolean;
        isSubsetOf(of: NSOrderedSet<ObjectType>): boolean;
        isSubsetOf(of: NSSet<ObjectType>): boolean;
        objectAtIndex(at: number): ObjectType;
        objectEnumerator(): NSEnumerator<ObjectType>;
        objectsAtIndexes(at: NSIndexSet): ObjectType[];
        reverseObjectEnumerator(): NSEnumerator<ObjectType>;
        sortedArrayWithComparator(comparator: (p1: any, p2: any) => ComparisonResult): ObjectType[];
        sortedArrayUsingDescriptors(using: NSSortDescriptor[]): ObjectType[];
        sortedArrayWithOptionsUsingComparator(options: NSSortOptions, usingComparator: (p1: any, p2: any) => ComparisonResult): ObjectType[];
    }
    class NSOrthography extends NSObject {
        static defaultOrthographyForLanguage(forLanguage: string): NSOrthography;
        allLanguages: string[];
        allScripts: string[];
        dominantLanguage: string;
        dominantScript: string;
        languageMap: Map<string, string[]>;
        dominantLanguageForScript(forScript: string): string;
        static createWithDominantScriptLanguageMap(dominantScript: string, languageMap: Map<string, string[]>): NSOrthography;
        languagesForScript(forScript: string): string[];
    }
    class OutputStream extends Stream {
        static outputStreamToBufferCapacity(_: string, capacity: number): OutputStream;
        static outputStreamToFileAtPathAppend(_: string, append: boolean): OutputStream;
        static outputStreamToMemory(): OutputStream;
        static outputStreamWithURLAppend(_: NSURL, append: boolean): OutputStream;
        hasSpaceAvailable: boolean;
        static createWithToBufferCapacity(toBuffer: string, capacity: number): OutputStream;
        static createWithToFileAtPathAppend(toFileAtPath: string, append: boolean): OutputStream;
        static createWithToMemory(): OutputStream;
        static createWithUrlAppend(URL: NSURL, append: boolean): OutputStream;
        writeMaxLength(_: string, maxLength: number): number;
    }
    class NSPersonNameComponents extends NSObject {
        familyName: string;
        setFamilyName(_: string): any;
        givenName: string;
        setGivenName(_: string): any;
        middleName: string;
        setMiddleName(_: string): any;
        namePrefix: string;
        setNamePrefix(_: string): any;
        nameSuffix: string;
        setNameSuffix(_: string): any;
        nickname: string;
        setNickname(_: string): any;
        phoneticRepresentation: NSPersonNameComponents;
        setPhoneticRepresentation(_: NSPersonNameComponents): any;
    }
    class PersonNameComponentsFormatter extends Formatter {
        static localizedStringFromPersonNameComponentsStyleOptions(_: NSPersonNameComponents, style: PersonNameComponentsFormatter.Style, options: PersonNameComponentsFormatter.Options): string;
        isPhonetic: boolean;
        setPhonetic(_: boolean): any;
        style: PersonNameComponentsFormatter.Style;
        setStyle(_: PersonNameComponentsFormatter.Style): any;
        annotatedStringFromPersonNameComponents(_: NSPersonNameComponents): NSAttributedString;
        personNameComponentsFromString(_: string): NSPersonNameComponents;
        stringFromPersonNameComponents(_: NSPersonNameComponents): string;
    }
    class Pipe extends NSObject {
        static pipe(): Pipe;
        fileHandleForReading: FileHandle;
        fileHandleForWriting: FileHandle;
    }
    class NSPointerArray extends NSObject {
        static strongObjectsPointerArray(): NSPointerArray;
        static weakObjectsPointerArray(): NSPointerArray;
        allObjects: any[];
        count: number;
        setCount(_: number): any;
        pointerFunctions: NSPointerFunctions;
        addPointer(_?: any): void;
        compact(): void;
        static createWithOptions(options: NSPointerFunctions.Options): NSPointerArray;
        static createWithPointerFunctions(pointerFunctions: NSPointerFunctions): NSPointerArray;
        insertPointerAtIndex(_?: any, at?: number): void;
        pointerAtIndex(at: number): any;
        removePointerAtIndex(at: number): void;
        replacePointerAtIndexWithPointer(at: number, withPointer?: any): void;
    }
    class NSPointerFunctions extends NSObject {
        acquireFunction: (p1: any, p2: (p1: any) => number, p3: boolean) => any;
        setAcquireFunction(_: (p1: any, p2: (p1: any) => number, p3: boolean) => any): any;
        descriptionFunction: (p1: any) => string;
        setDescriptionFunction(_: (p1: any) => string): any;
        hashFunction: (p1: any, p2: (p1: any) => number) => number;
        setHashFunction(_: (p1: any, p2: (p1: any) => number) => number): any;
        isEqualFunction: (p1: any, p2: any, p3: (p1: any) => number) => boolean;
        setIsEqualFunction(_: (p1: any, p2: any, p3: (p1: any) => number) => boolean): any;
        relinquishFunction: (p1: any, p2: (p1: any) => number) => void;
        setRelinquishFunction(_: (p1: any, p2: (p1: any) => number) => void): any;
        sizeFunction: (p1: any) => number;
        setSizeFunction(_: (p1: any) => number): any;
        static createWithOptions(options: NSPointerFunctions.Options): NSPointerFunctions;
    }
    class Port extends NSObject {
        reservedSpaceLength: number;
        isValid: boolean;
        delegate(): PortDelegate;
        invalidate(): void;
        removeFromRunLoopForMode(_: RunLoop, forMode: string): void;
        scheduleInRunLoopForMode(_: RunLoop, forMode: string): void;
        sendBeforeDateComponentsFromReserved(_: Date, components?: NSMutableArray<any>, from?: Port, reserved?: number): boolean;
        sendBeforeDateMsgidComponentsFromReserved(_: Date, msgid: number, components?: NSMutableArray<any>, from?: Port, reserved?: number): boolean;
        setDelegate(_?: PortDelegate): void;
    }
    interface PortDelegate extends NSObject {
        handlePortMessage?(_: PortMessage): void;
    }
    class PortMessage extends NSObject {
        components: any[];
        msgid: number;
        setMsgid(_: number): any;
        receivePort: Port;
        sendPort: Port;
        static createWithSendPortReceivePortComponents(sendPort?: Port, receivePort?: Port, components?: any[]): PortMessage;
        sendBeforeDate(_: Date): boolean;
    }
    class NSPositionalSpecifier extends NSObject {
        insertionContainer: any;
        insertionIndex: number;
        insertionKey: string;
        insertionReplaces: boolean;
        position: NSPositionalSpecifier.InsertionPosition;
        evaluate(): void;
        static createWithPositionObjectSpecifier(position: NSPositionalSpecifier.InsertionPosition, objectSpecifier: NSScriptObjectSpecifier): NSPositionalSpecifier;
        setInsertionClassDescription(_: NSScriptClassDescription): void;
    }
    class NSPredicate extends NSObject {
        predicateFormat: string;
        allowEvaluation(): void;
        evaluateWithObject(with_?: any): boolean;
        evaluateWithObjectSubstitutionVariables(with_?: any, substitutionVariables?: Map<string, any>): boolean;
        predicateWithSubstitutionVariables(_: Map<string, any>): NSPredicate;
    }
    class ProcessInfo extends NSObject {
        activeProcessorCount: number;
        arguments: string[];
        automaticTerminationSupportEnabled: boolean;
        setAutomaticTerminationSupportEnabled(_: boolean): any;
        environment: Map<string, string>;
        fullUserName: string;
        globallyUniqueString: string;
        hostName: string;
        isMacCatalystApp: boolean;
        operatingSystemVersion: OperatingSystemVersion;
        operatingSystemVersionString: string;
        physicalMemory: number;
        processIdentifier: number;
        processName: string;
        setProcessName(_: string): any;
        processorCount: number;
        systemUptime: number;
        thermalState: ProcessInfo.ThermalState;
        userName: string;
        static processInfo: ProcessInfo;
        beginActivityWithOptionsReason(_: ProcessInfo.ActivityOptions, reason: string): NSObject;
        disableAutomaticTermination(_: string): void;
        disableSuddenTermination(): void;
        enableAutomaticTermination(_: string): void;
        enableSuddenTermination(): void;
        endActivity(_: NSObject): void;
        isOperatingSystemAtLeastVersion(_: OperatingSystemVersion): boolean;
        performActivityWithOptionsWithReasonUsingBlock(_: ProcessInfo.ActivityOptions, reason: string, usingBlock: () => void): void;
    }
    class Progress extends NSObject {
        static addSubscriberForFileURLWithWithPublishingHandler(_: NSURL, withPublishingHandler: (p1: Progress) => () => void): any;
        static currentProgress(): Progress;
        static discreteProgressWithTotalUnitCount(totalUnitCount: number): Progress;
        static removeSubscriber(_: any): void;
        isCancellable: boolean;
        setCancellable(_: boolean): any;
        cancellationHandler: () => void;
        setCancellationHandler(_: () => void): any;
        isCancelled: boolean;
        completedUnitCount: number;
        setCompletedUnitCount(_: number): any;
        estimatedTimeRemaining: number;
        setEstimatedTimeRemaining(_: number): any;
        fileCompletedCount: number;
        setFileCompletedCount(_: number): any;
        fileOperationKind: string;
        setFileOperationKind(_: string): any;
        fileTotalCount: number;
        setFileTotalCount(_: number): any;
        fileURL: NSURL;
        setFileURL(_: NSURL): any;
        isFinished: boolean;
        fractionCompleted: number;
        isIndeterminate: boolean;
        kind: string;
        setKind(_: string): any;
        localizedAdditionalDescription: string;
        setLocalizedAdditionalDescription(_: string): any;
        localizedDescription: string;
        setLocalizedDescription(_: string): any;
        isOld: boolean;
        isPausable: boolean;
        setPausable(_: boolean): any;
        isPaused: boolean;
        pausingHandler: () => void;
        setPausingHandler(_: () => void): any;
        resumingHandler: () => void;
        setResumingHandler(_: () => void): any;
        throughput: number;
        setThroughput(_: number): any;
        totalUnitCount: number;
        setTotalUnitCount(_: number): any;
        userInfo: Map<string, any>;
        addChildWithPendingUnitCount(_: Progress, withPendingUnitCount: number): void;
        becomeCurrentWithPendingUnitCount(_: number): void;
        cancel(): void;
        static createWithParentUserInfo(parent?: Progress, userInfo?: Map<string, any>): Progress;
        pause(): void;
        performAsCurrentWithPendingUnitCountWithUsingBlock(_: number, usingBlock: () => void): void;
        publish(): void;
        resignCurrent(): void;
        resume(): void;
        setUserInfoObjectForKey(_?: any, forKey?: string): void;
        unpublish(): void;
    }
    interface ProgressReporting extends NSObject {
        progress: Progress;
    }
    class PropertyListSerialization extends NSObject {
        static dataWithPropertyListFormatOptionsError(fromPropertyList: any, format: PropertyListSerialization.PropertyListFormat, options: number): NSData;
        static propertyListIsValidForFormat(_: any, isValidForFormat: PropertyListSerialization.PropertyListFormat): boolean;
        static propertyListWithDataOptionsFormatError(from: NSData, options: PropertyListSerialization.MutabilityOptions, format?: PropertyListSerialization.PropertyListFormat): any;
        static propertyListWithStreamOptionsFormatError(options: InputStream, format: PropertyListSerialization.MutabilityOptions, error?: PropertyListSerialization.PropertyListFormat): any;
        static writePropertyListToStreamFormatOptionsError(toStream: any, format: OutputStream, options: PropertyListSerialization.PropertyListFormat, error: number): number;
    }
    class NSPropertySpecifier extends NSScriptObjectSpecifier {
    }
    class NSProtocolChecker extends NSProxy {
        protocol: any;
        target: NSObject;
        static createWithTargetProtocol(target: NSObject, protocol: any): NSProtocolChecker;
    }
    class NSProxy {
        static alloc(): NSProxy;
        static class(): typeof NSObject;
        static respondsToSelector(to: string): boolean;
        dealloc(): void;
        finalize(): void;
    }
    class NSPurgeableData extends NSMutableData {
    }
    class NSQuitCommand extends NSScriptCommand {
        saveOptions: NSSaveOptions;
    }
    class NSRandomSpecifier extends NSScriptObjectSpecifier {
    }
    interface NSRange {
        location: number;
        length: number;
    }
    class NSRangeSpecifier extends NSScriptObjectSpecifier {
        endSpecifier: NSScriptObjectSpecifier;
        setEndSpecifier(_: NSScriptObjectSpecifier): any;
        startSpecifier: NSScriptObjectSpecifier;
        setStartSpecifier(_: NSScriptObjectSpecifier): any;
        static createWithContainerClassDescriptionContainerSpecifierKeyStartSpecifierEndSpecifier(containerClassDescription: NSScriptClassDescription, containerSpecifier?: NSScriptObjectSpecifier, key?: string, startSpecifier?: NSScriptObjectSpecifier, endSpecifier?: NSScriptObjectSpecifier): NSRangeSpecifier;
    }
    class NSRecursiveLock extends NSObject {
        name: string;
        setName(_: string): any;
        lockBeforeDate(before: Date): boolean;
        tryLock(): boolean;
    }
    class NSRegularExpression extends NSObject {
        static escapedPatternForString(for_: string): string;
        static escapedTemplateForString(for_: string): string;
        static regularExpressionWithPatternOptionsError(options: string, error: NSRegularExpression.Options): NSRegularExpression;
        numberOfCaptureGroups: number;
        options: NSRegularExpression.Options;
        pattern: string;
        enumerateMatchesWithInOptionsRangeUsing(in_: string, options: NSRegularExpression.MatchingOptions, range: NSRange, using?: (p1: NSTextCheckingResult, p2: NSRegularExpression.MatchingFlags, p3: boolean) => void): void;
        firstMatchInStringOptionsRange(in_: string, options: NSRegularExpression.MatchingOptions, range: NSRange): NSTextCheckingResult;
        static createWithPatternOptions(pattern: string, options: NSRegularExpression.Options): NSRegularExpression;
        matchesInStringOptionsRange(in_: string, options: NSRegularExpression.MatchingOptions, range: NSRange): NSTextCheckingResult[];
        numberOfMatchesInStringOptionsRange(in_: string, options: NSRegularExpression.MatchingOptions, range: NSRange): number;
        rangeOfFirstMatchInStringOptionsRange(in_: string, options: NSRegularExpression.MatchingOptions, range: NSRange): NSRange;
        replaceMatchesInStringOptionsRangeWithTemplate(in_: NSMutableString, options: NSRegularExpression.MatchingOptions, range: NSRange, withTemplate: string): number;
        replacementStringForResultInStringOffsetTemplate(for_: NSTextCheckingResult, in_: string, offset: number, template: string): string;
        stringByReplacingMatchesInStringOptionsRangeWithTemplate(in_: string, options: NSRegularExpression.MatchingOptions, range: NSRange, withTemplate: string): string;
    }
    class RelativeDateTimeFormatter extends Formatter {
        calendar: NSCalendar;
        setCalendar(_: NSCalendar): any;
        dateTimeStyle: RelativeDateTimeFormatter.DateTimeStyle;
        setDateTimeStyle(_: RelativeDateTimeFormatter.DateTimeStyle): any;
        formattingContext: Formatter.Context;
        setFormattingContext(_: Formatter.Context): any;
        locale: NSLocale;
        setLocale(_: NSLocale): any;
        unitsStyle: RelativeDateTimeFormatter.UnitsStyle;
        setUnitsStyle(_: RelativeDateTimeFormatter.UnitsStyle): any;
        localizedStringForDateRelativeToDate(_: Date, relativeToDate: Date): string;
        localizedStringFromDateComponents(_: NSDateComponents): string;
        localizedStringFromTimeInterval(_: number): string;
    }
    class NSRelativeSpecifier extends NSScriptObjectSpecifier {
        baseSpecifier: NSScriptObjectSpecifier;
        setBaseSpecifier(_: NSScriptObjectSpecifier): any;
        relativePosition: NSRelativeSpecifier.RelativePosition;
        setRelativePosition(_: NSRelativeSpecifier.RelativePosition): any;
        static createWithContainerClassDescriptionContainerSpecifierKeyRelativePositionBaseSpecifier(containerClassDescription: NSScriptClassDescription, containerSpecifier?: NSScriptObjectSpecifier, key?: string, relativePosition?: NSRelativeSpecifier.RelativePosition, baseSpecifier?: NSScriptObjectSpecifier): NSRelativeSpecifier;
    }
    class RunLoop extends NSObject {
        currentMode: string;
        static currentRunLoop: RunLoop;
        static mainRunLoop: RunLoop;
        acceptInputForModeBeforeDate(_: string, beforeDate: Date): void;
        addPortForMode(_: Port, forMode: string): void;
        addTimerForMode(_: Timer, forMode: string): void;
        cancelPerformSelectorTargetArgument(_: string, target: any, argument?: any): void;
        cancelPerformSelectorsWithTarget(_: any): void;
        getCFRunLoop(): any;
        limitDateForMode(_: string): Date;
        performBlock(_: () => void): void;
        performInModesWithBlock(_: string[], block: () => void): void;
        performSelectorTargetArgumentOrderModes(_: string, target: any, argument?: any, order?: number, modes?: string[]): void;
        removePortForMode(_: Port, forMode: string): void;
        run(): void;
        runModeBeforeDate(mode: string, before: Date): boolean;
        runUntilDate(_: Date): void;
    }
    class Scanner extends NSObject {
        static localizedScannerWithString(_: string): any;
        isAtEnd: boolean;
        caseSensitive: boolean;
        setCaseSensitive(_: boolean): any;
        charactersToBeSkipped: NSCharacterSet;
        setCharactersToBeSkipped(_: NSCharacterSet): any;
        locale: any;
        setLocale(_: any): any;
        string: string;
        static createWithString(string: string): Scanner;
        scanHexDouble(_?: number): boolean;
        scanHexFloat(_?: number): boolean;
        scanHexLongLong(_?: number): boolean;
        scanInt(_?: number): boolean;
        scanInteger(_?: number): boolean;
        scanLongLong(_?: number): boolean;
        scanUnsignedLongLong(_?: number): boolean;
    }
    class NSScriptClassDescription extends NSClassDescription {
        appleEventCode: number;
        defaultSubcontainerAttributeKey: string;
        implementationClassName: string;
        suiteName: string;
        superclassDescription: NSScriptClassDescription;
        appleEventCodeForKey(forKey: string): number;
        classDescriptionForKey(_: string): NSScriptClassDescription;
        hasOrderedToManyRelationshipForKey(forKey: string): boolean;
        hasPropertyForKey(forKey: string): boolean;
        hasReadablePropertyForKey(forKey: string): boolean;
        hasWritablePropertyForKey(forKey: string): boolean;
        static createWithSuiteNameClassNameDictionary(suiteName: string, className: string, dictionary?: Map<any, any>): NSScriptClassDescription;
        isLocationRequiredToCreateForKey(forKey: string): boolean;
        keyWithAppleEventCode(withAppleEventCode: number): string;
        matchesAppleEventCode(_: number): boolean;
        selectorForCommand(forCommand: NSScriptCommandDescription): string;
        supportsCommand(_: NSScriptCommandDescription): boolean;
        typeForKey(forKey: string): string;
    }
    class NSScriptCoercionHandler extends NSObject {
        static sharedCoercionHandler(): NSScriptCoercionHandler;
        coerceValueToClass(_: any, to: typeof NSObject): any;
        registerCoercerSelectorToConvertFromClassToClass(_: any, selector: string, toConvertFrom: typeof NSObject, to: typeof NSObject): void;
    }
    class NSScriptCommand extends NSObject {
        static currentCommand(): NSScriptCommand;
        appleEvent: NSAppleEventDescriptor;
        arguments: Map<string, any>;
        setArguments(_: Map<string, any>): any;
        commandDescription: NSScriptCommandDescription;
        directParameter: any;
        setDirectParameter(_: any): any;
        evaluatedArguments: Map<string, any>;
        evaluatedReceivers: any;
        receiversSpecifier: NSScriptObjectSpecifier;
        setReceiversSpecifier(_: NSScriptObjectSpecifier): any;
        scriptErrorExpectedTypeDescriptor: NSAppleEventDescriptor;
        setScriptErrorExpectedTypeDescriptor(_: NSAppleEventDescriptor): any;
        scriptErrorNumber: number;
        setScriptErrorNumber(_: number): any;
        scriptErrorOffendingObjectDescriptor: NSAppleEventDescriptor;
        setScriptErrorOffendingObjectDescriptor(_: NSAppleEventDescriptor): any;
        scriptErrorString: string;
        setScriptErrorString(_: string): any;
        isWellFormed: boolean;
        executeCommand(): any;
        static createWithCommandDescription(commandDescription: NSScriptCommandDescription): NSScriptCommand;
        performDefaultImplementation(): any;
        resumeExecutionWithResult(withResult?: any): void;
        suspendExecution(): void;
    }
    class NSScriptCommandDescription extends NSObject {
        appleEventClassCode: number;
        appleEventCode: number;
        appleEventCodeForReturnType: number;
        argumentNames: string[];
        commandClassName: string;
        commandName: string;
        returnType: string;
        suiteName: string;
        appleEventCodeForArgumentWithName(withName: string): number;
        createCommandInstance(): NSScriptCommand;
        createCommandInstanceWithZone(with_?: any): NSScriptCommand;
        static createWithSuiteNameCommandNameDictionary(suiteName: string, commandName: string, dictionary?: Map<any, any>): NSScriptCommandDescription;
        isOptionalArgumentWithName(withName: string): boolean;
        typeForArgumentWithName(withName: string): string;
    }
    class NSScriptExecutionContext extends NSObject {
        static sharedScriptExecutionContext(): NSScriptExecutionContext;
        objectBeingTested: any;
        setObjectBeingTested(_: any): any;
        rangeContainerObject: any;
        setRangeContainerObject(_: any): any;
        topLevelObject: any;
        setTopLevelObject(_: any): any;
    }
    class NSScriptObjectSpecifier extends NSObject {
        static objectSpecifierWithDescriptor(descriptor: NSAppleEventDescriptor): NSScriptObjectSpecifier;
        childSpecifier: NSScriptObjectSpecifier;
        setChildSpecifier(_: NSScriptObjectSpecifier): any;
        containerClassDescription: NSScriptClassDescription;
        setContainerClassDescription(_: NSScriptClassDescription): any;
        containerIsObjectBeingTested: boolean;
        setContainerIsObjectBeingTested(_: boolean): any;
        containerIsRangeContainerObject: boolean;
        setContainerIsRangeContainerObject(_: boolean): any;
        containerSpecifier: NSScriptObjectSpecifier;
        setContainerSpecifier(_: NSScriptObjectSpecifier): any;
        descriptor: NSAppleEventDescriptor;
        evaluationErrorNumber: number;
        setEvaluationErrorNumber(_: number): any;
        evaluationErrorSpecifier: NSScriptObjectSpecifier;
        key: string;
        setKey(_: string): any;
        keyClassDescription: NSScriptClassDescription;
        objectsByEvaluatingSpecifier: any;
        indicesOfObjectsByEvaluatingWithContainerCount(withContainer: any, count: number): number;
        static createWithContainerClassDescriptionContainerSpecifierKey(containerClassDescription: NSScriptClassDescription, containerSpecifier?: NSScriptObjectSpecifier, key?: string): NSScriptObjectSpecifier;
        static createWithContainerSpecifierKey(containerSpecifier: NSScriptObjectSpecifier, key: string): NSScriptObjectSpecifier;
        objectsByEvaluatingWithContainers(withContainers: any): any;
    }
    class NSScriptSuiteRegistry extends NSObject {
        static setSharedScriptSuiteRegistry(_: NSScriptSuiteRegistry): void;
        static sharedScriptSuiteRegistry(): NSScriptSuiteRegistry;
        suiteNames: string[];
        aeteResource(_: string): NSData;
        appleEventCodeForSuite(forSuite: string): number;
        bundleForSuite(forSuite: string): Bundle;
        classDescriptionWithAppleEventCode(withAppleEventCode: number): NSScriptClassDescription;
        classDescriptionsInSuite(inSuite: string): Map<string, NSScriptClassDescription>;
        commandDescriptionWithAppleEventClassAndAppleEventCode(withAppleEventClass: number, andAppleEventCode: number): NSScriptCommandDescription;
        commandDescriptionsInSuite(inSuite: string): Map<string, NSScriptCommandDescription>;
        loadSuiteWithDictionaryFromBundle(with_: Map<any, any>, from: Bundle): void;
        loadSuitesFromBundle(from: Bundle): void;
        registerClassDescription(_: NSScriptClassDescription): void;
        registerCommandDescription(_: NSScriptCommandDescription): void;
        suiteForAppleEventCode(forAppleEventCode: number): string;
    }
    class NSScriptWhoseTest extends NSObject {
        isTrue(): boolean;
    }
    interface NSSecureCoding extends NSCoding {
    }
    class NSSecureUnarchiveFromDataTransformer extends ValueTransformer {
        static allowedTopLevelClasses: typeof NSObject[];
    }
    class NSSet<ObjectType> extends NSObject {
        static setWithObjects<ObjectType>(_: ObjectType): NSSet<ObjectType>;
        allObjects: ObjectType[];
        count: number;
        anyObject(): ObjectType;
        containsObject(_: ObjectType): boolean;
        descriptionWithLocale(withLocale?: any): string;
        enumerateIndexPathsWithOptionsUsing(options: NSEnumerationOptions, using: (p1: NSIndexPath, p2: boolean) => void): void;
        enumerateObjects(_: (p1: ObjectType, p2: boolean) => void): void;
        enumerateObjectsWithOptionsUsing(options: NSEnumerationOptions, using: (p1: ObjectType, p2: boolean) => void): void;
        filteredSetUsingPredicate(using: NSPredicate): NSSet<ObjectType>;
        intersects(_: NSSet<ObjectType>): boolean;
        isEqualWithTo(to: NSSet<ObjectType>): boolean;
        isSubsetOf(of: NSSet<ObjectType>): boolean;
        member(_: ObjectType): ObjectType;
        objectEnumerator(): NSEnumerator<ObjectType>;
        objectsWithPassingTest(passingTest: (p1: ObjectType, p2: boolean) => boolean): NSSet<ObjectType>;
        objectsWithOptionsPassingTest(options: NSEnumerationOptions, passingTest: (p1: ObjectType, p2: boolean) => boolean): NSSet<ObjectType>;
        setByAddingObject(_: ObjectType): NSSet<ObjectType>;
        setByAddingObjectsFromArray(from: ObjectType[]): NSSet<ObjectType>;
        addingObjectsWithFrom(from: NSSet<ObjectType>): NSSet<ObjectType>;
        sortedArrayUsingDescriptors(using: NSSortDescriptor[]): ObjectType[];
    }
    class NSSetCommand extends NSScriptCommand {
        keySpecifier: NSScriptObjectSpecifier;
        setReceiversSpecifier(_?: NSScriptObjectSpecifier): void;
    }
    class SocketPort extends Port {
        address: NSData;
        protocol: number;
        protocolFamily: number;
        socket: number;
        socketType: number;
        static createWithRemoteWithProtocolFamilySocketTypeProtocolAddress(remoteWithProtocolFamily: number, socketType: number, protocol: number, address: NSData): SocketPort;
        static createWithRemoteWithTCPPortHost(remoteWithTCPPort: number, host?: string): SocketPort;
        static createWithProtocolFamilySocketTypeProtocolAddress(protocolFamily: number, socketType: number, protocol: number, address: NSData): SocketPort;
        static createWithProtocolFamilySocketTypeProtocolSocket(protocolFamily: number, socketType: number, protocol: number, socket: number): SocketPort;
        static createWithTCPPort(TCPPort: number): SocketPort;
    }
    class NSSortDescriptor extends NSObject {
        ascending: boolean;
        comparator: (p1: any, p2: any) => ComparisonResult;
        key: string;
        reversedSortDescriptor: any;
        selector: string;
        allowEvaluation(): void;
        compareObjectToObject(_: any, to: any): ComparisonResult;
        static createWithKeyAscending(key?: string, ascending?: boolean): NSSortDescriptor;
        static createWithKeyAscendingComparator(key?: string, ascending?: boolean, comparator?: (p1: any, p2: any) => ComparisonResult): NSSortDescriptor;
        static createWithKeyAscendingSelector(key?: string, ascending?: boolean, selector?: string): NSSortDescriptor;
    }
    class NSSpecifierTest extends NSScriptWhoseTest {
        static createWithObjectSpecifierComparisonOperatorTestObject(objectSpecifier?: NSScriptObjectSpecifier, comparisonOperator?: NSSpecifierTest.TestComparisonOperation, testObject?: any): NSSpecifierTest;
    }
    class NSSpellServer extends NSObject {
        delegate: NSSpellServerDelegate;
        setDelegate(_: NSSpellServerDelegate): any;
        isWordInUserDictionariesCaseSensitive(inUserDictionaries: string, caseSensitive: boolean): boolean;
        registerLanguageByVendor(_?: string, byVendor?: string): boolean;
        run(): void;
    }
    interface NSSpellServerDelegate extends NSObject {
        spellServerFindMisspelledWordInStringLanguageWordCountCountOnly?(_: NSSpellServer, findMisspelledWordIn: string, language: string, wordCount: number, countOnly: boolean): NSRange;
        spellServerSuggestCompletionsForPartialWordRangeInStringLanguage?(_: NSSpellServer, suggestCompletionsForPartialWordRange: NSRange, in_: string, language: string): string[];
        spellServerCheckGrammarInStringLanguageDetails?(_: NSSpellServer, checkGrammarIn: string, language?: string, details?: Map<string, any>[]): NSRange;
        spellServerCheckStringOffsetTypesOptionsOrthographyWordCount?(_: NSSpellServer, check: string, offset: number, types: number, options?: Map<string, any>, orthography?: NSOrthography, wordCount?: number): NSTextCheckingResult[];
        spellServerDidForgetWordInLanguage?(_: NSSpellServer, didForgetWord: string, inLanguage: string): void;
        spellServerDidLearnWordInLanguage?(_: NSSpellServer, didLearnWord: string, inLanguage: string): void;
        spellServerRecordResponseToCorrectionForWordLanguage?(_: NSSpellServer, recordResponse: number, toCorrection: string, forWord: string, language: string): void;
        spellServerSuggestGuessesForWordInLanguage?(_: NSSpellServer, suggestGuessesForWord: string, inLanguage: string): string[];
    }
    class Stream extends NSObject {
        static getBoundStreamsWithBufferSizeInputStreamOutputStream(_: number, inputStream?: InputStream, outputStream?: OutputStream): void;
        static getStreamsToHostWithNamePortInputStreamOutputStream(_: string, port: number, inputStream?: InputStream, outputStream?: OutputStream): void;
        delegate: StreamDelegate;
        setDelegate(_: StreamDelegate): any;
        streamError: NSError;
        streamStatus: Stream.Status;
        close(): void;
        open(): void;
        propertyForKey(_: string): any;
        removeFromRunLoopForMode(_: RunLoop, forMode: string): void;
        scheduleInRunLoopForMode(_: RunLoop, forMode: string): void;
        setPropertyForKey(_?: any, forKey?: string): boolean;
    }
    interface StreamDelegate extends NSObject {
        streamHandleEvent?(_: Stream, handleEvent: Stream.Event): void;
    }
    class NSString extends NSObject {
        static localizedNameOfStringEncoding(of: number): string;
        static pathWithComponents(withComponents: string[]): string;
        static stringEncodingForDataEncodingOptionsConvertedStringUsedLossyConversion(for_: NSData, encodingOptions?: Map<string, any>, convertedString?: string, usedLossyConversion?: boolean): number;
        static stringWithContentsOfFileEncodingError(encoding: string, error: number): NSString;
        static stringWithContentsOfFileUsedEncodingError(usedEncoding: string, error?: number): NSString;
        static stringWithContentsOfURLEncodingError(encoding: NSURL, error: number): NSString;
        static stringWithContentsOfURLUsedEncodingError(usedEncoding: NSURL, error?: number): NSString;
        UTF8String: string;
        isAbsolutePath: boolean;
        boolValue: boolean;
        capitalizedString: string;
        decomposedStringWithCanonicalMapping: string;
        decomposedStringWithCompatibilityMapping: string;
        doubleValue: number;
        fastestEncoding: number;
        fileSystemRepresentation: string;
        floatValue: number;
        intValue: number;
        integerValue: number;
        lastPathComponent: string;
        length: number;
        localizedCapitalizedString: string;
        localizedLowercaseString: string;
        localizedUppercaseString: string;
        longLongValue: number;
        lowercaseString: string;
        pathComponents: string[];
        pathExtension: string;
        precomposedStringWithCanonicalMapping: string;
        precomposedStringWithCompatibilityMapping: string;
        smallestEncoding: number;
        stringByAbbreviatingWithTildeInPath: string;
        stringByDeletingLastPathComponent: string;
        stringByDeletingPathExtension: string;
        stringByExpandingTildeInPath: string;
        stringByRemovingPercentEncoding: string;
        stringByResolvingSymlinksInPath: string;
        stringByStandardizingPath: string;
        uppercaseString: string;
        static availableStringEncodings: number;
        static defaultCStringEncoding: number;
        boundingRectWithSizeOptionsAttributes(with_: CGSize, options: NSString.DrawingOptions, attributes?: Map<string, any>): CGRect;
        boundingRectWithSizeOptionsAttributesContext(with_: CGSize, options: NSString.DrawingOptions, attributes?: Map<string, any>, context?: NSStringDrawingContext): CGRect;
        cStringUsingEncoding(using: number): string;
        canBeConvertedToEncoding(to: number): boolean;
        capitalizedStringWithLocale(with_?: NSLocale): string;
        caseInsensitiveCompare(_: string): ComparisonResult;
        characterAtIndex(at: number): string;
        commonPrefixWithStringOptions(with_: string, options: NSString.CompareOptions): string;
        compare(_: string): ComparisonResult;
        compareOptions(_: string, options: NSString.CompareOptions): ComparisonResult;
        compareOptionsRange(_: string, options: NSString.CompareOptions, range: NSRange): ComparisonResult;
        compareOptionsRangeLocale(_: string, options: NSString.CompareOptions, range: NSRange, locale?: any): ComparisonResult;
        completePathIntoStringCaseSensitiveMatchesIntoArrayFilterTypes(into?: string, caseSensitive?: boolean, matchesInto?: string[], filterTypes?: string[]): number;
        componentsSeparatedByCharactersInSet(separatedBy: NSCharacterSet): string[];
        componentsSeparatedByString(separatedBy: string): string[];
        containsString(_: string): boolean;
        dataUsingEncoding(using: number): NSData;
        dataUsingEncodingAllowLossyConversion(using: number, allowLossyConversion: boolean): NSData;
        drawAtPointWithAttributes(at: CGPoint, withAttributes?: Map<string, any>): void;
        drawInRectWithAttributes(in_: CGRect, withAttributes?: Map<string, any>): void;
        drawWithRectOptionsAttributes(with_: CGRect, options: NSString.DrawingOptions, attributes?: Map<string, any>): void;
        drawWithRectOptionsAttributesContext(with_: CGRect, options: NSString.DrawingOptions, attributes?: Map<string, any>, context?: NSStringDrawingContext): void;
        enumerateLines(_: (p1: string, p2: boolean) => void): void;
        enumerateLinguisticTagsWithInSchemeOptionsOrthographyUsing(in_: NSRange, scheme: string, options: NSLinguisticTagger.Options, orthography?: NSOrthography, using?: (p1: string, p2: NSRange, p3: NSRange, p4: boolean) => void): void;
        enumerateSubstringsWithInOptionsUsing(in_: NSRange, options: NSString.EnumerationOptions, using?: (p1: string, p2: NSRange, p3: NSRange, p4: boolean) => void): void;
        getBytesMaxLengthUsedLengthEncodingOptionsRangeRemainingRange(_?: any, maxLength?: number, usedLength?: number, encoding?: number, options?: NSString.EncodingConversionOptions, range?: NSRange, remaining?: NSRange): boolean;
        getCStringMaxLengthEncoding(_: string, maxLength: number, encoding: number): boolean;
        getCharacters(_: string): void;
        getCharactersRange(_: string, range: NSRange): void;
        getFileSystemRepresentationMaxLength(_: string, maxLength: number): boolean;
        getLineStartEndContentsEndForRange(_?: number, end?: number, contentsEnd?: number, for_?: NSRange): void;
        getParagraphStartEndContentsEndForRange(_?: number, end?: number, contentsEnd?: number, for_?: NSRange): void;
        hasPrefix(_: string): boolean;
        hasSuffix(_: string): boolean;
        static createWithBytesLengthEncoding(bytes: any, length: number, encoding: number): NSString;
        static createWithBytesNoCopyLengthEncodingFreeWhenDone(bytesNoCopy: any, length: number, encoding: number, freeWhenDone: boolean): NSString;
        static createWithCStringEncoding(CString: string, encoding: number): NSString;
        static createWithCharactersLength(characters: string, length: number): NSString;
        static createWithCharactersNoCopyLengthFreeWhenDone(charactersNoCopy: string, length: number, freeWhenDone: boolean): NSString;
        static createWithContentsOfFileEncoding(contentsOfFile: string, encoding: number): NSString;
        static createWithContentsOfFileUsedEncoding(contentsOfFile: string, usedEncoding?: number): NSString;
        static createWithContentsOfURLEncoding(contentsOfURL: NSURL, encoding: number): NSString;
        static createWithContentsOfURLUsedEncoding(contentsOfURL: NSURL, usedEncoding?: number): NSString;
        static createWithDataEncoding(data: NSData, encoding: number): NSString;
        static createWithString(string: string): NSString;
        static createWithUTF8String(UTF8String: string): NSString;
        isEqualToString(to: string): boolean;
        lengthOfBytesUsingEncoding(using: number): number;
        lineRangeForRange(for_: NSRange): NSRange;
        linguisticTagsInRangeSchemeOptionsOrthographyTokenRanges(in_: NSRange, scheme: string, options: NSLinguisticTagger.Options, orthography?: NSOrthography, tokenRanges?: NSValue[]): string[];
        localizedCaseInsensitiveCompare(_: string): ComparisonResult;
        localizedCaseInsensitiveContainsString(_: string): boolean;
        localizedCompare(_: string): ComparisonResult;
        localizedStandardCompare(_: string): ComparisonResult;
        localizedStandardContainsString(_: string): boolean;
        localizedStandardRangeOfString(of: string): NSRange;
        lowercaseStringWithLocale(with_?: NSLocale): string;
        maximumLengthOfBytesUsingEncoding(using: number): number;
        paragraphRangeForRange(for_: NSRange): NSRange;
        propertyList(): any;
        propertyListFromStringsFileFormat(): Map<any, any>;
        rangeOfCharacterFromSet(from: NSCharacterSet): NSRange;
        rangeOfCharacterFromSetOptions(from: NSCharacterSet, options: NSString.CompareOptions): NSRange;
        rangeOfCharacterFromSetOptionsRange(from: NSCharacterSet, options: NSString.CompareOptions, range: NSRange): NSRange;
        rangeOfComposedCharacterSequenceAtIndex(at: number): NSRange;
        rangeOfComposedCharacterSequencesForRange(for_: NSRange): NSRange;
        rangeOfString(of: string): NSRange;
        rangeOfStringOptions(of: string, options: NSString.CompareOptions): NSRange;
        rangeOfStringOptionsRange(of: string, options: NSString.CompareOptions, range: NSRange): NSRange;
        rangeOfStringOptionsRangeLocale(of: string, options: NSString.CompareOptions, range: NSRange, locale?: NSLocale): NSRange;
        sizeWithAttributes(withAttributes?: Map<string, any>): CGSize;
        stringByAddingPercentEncodingWithAllowedCharacters(withAllowedCharacters: NSCharacterSet): string;
        stringByAppendingPathComponent(_: string): string;
        stringByAppendingPathExtension(_: string): string;
        stringByAppendingString(_: string): string;
        stringByApplyingTransformReverse(_: string, reverse: boolean): string;
        stringByFoldingWithOptionsLocale(options: NSString.CompareOptions, locale?: NSLocale): string;
        stringByPaddingToLengthWithStringStartingAtIndex(toLength: number, withPad: string, startingAt: number): string;
        stringByReplacingCharactersInRangeWithString(in_: NSRange, with_: string): string;
        stringByReplacingOccurrencesOfStringWithString(of: string, with_: string): string;
        stringByReplacingOccurrencesOfStringWithStringOptionsRange(of: string, with_: string, options: NSString.CompareOptions, range: NSRange): string;
        stringByTrimmingCharactersInSet(in_: NSCharacterSet): string;
        stringsByAppendingPaths(byAppendingPaths: string[]): string[];
        substringFromIndex(from: number): string;
        substringToIndex(to: number): string;
        substringWithRange(with_: NSRange): string;
        uppercaseStringWithLocale(with_?: NSLocale): string;
        variantFittingPresentationWidth(_: number): string;
        writeToFileAtomicallyEncodingError(atomically: string, encoding: boolean, error: number): boolean;
        writeToURLAtomicallyEncodingError(atomically: NSURL, encoding: boolean, error: number): boolean;
    }
    interface NSSwappedDouble {
        v: number;
    }
    interface NSSwappedFloat {
        v: number;
    }
    class Process extends NSObject {
        static runArgumentsTerminationHandler(_: NSURL, _2: string[], arguments_?: Error, terminationHandler?: (p1: Process) => void): Process;
        static launchedTaskWithLaunchPathArguments(launchPath: string, arguments_: string[]): Process;
        arguments: string[];
        setArguments(_: string[]): any;
        currentDirectoryPath: string;
        setCurrentDirectoryPath(_: string): any;
        currentDirectoryURL: NSURL;
        setCurrentDirectoryURL(_: NSURL): any;
        environment: Map<string, string>;
        setEnvironment(_: Map<string, string>): any;
        executableURL: NSURL;
        setExecutableURL(_: NSURL): any;
        launchPath: string;
        setLaunchPath(_: string): any;
        processIdentifier: number;
        qualityOfService: QualityOfService;
        setQualityOfService(_: QualityOfService): any;
        isRunning: boolean;
        standardError: any;
        setStandardError(_: any): any;
        standardInput: any;
        setStandardInput(_: any): any;
        standardOutput: any;
        setStandardOutput(_: any): any;
        terminationHandler: (p1: Process) => void;
        setTerminationHandler(_: (p1: Process) => void): any;
        terminationReason: Process.TerminationReason;
        terminationStatus: number;
        interrupt(): void;
        launch(): void;
        launchAndReturnError(): boolean;
        resume(): boolean;
        suspend(): boolean;
        terminate(): void;
        waitUntilExit(): void;
    }
    class NSTextCheckingResult extends NSObject {
        static addressCheckingResultWithRangeComponents(range: NSRange, components: Map<string, string>): NSTextCheckingResult;
        static correctionCheckingResultWithRangeReplacementString(range: NSRange, replacementString: string): NSTextCheckingResult;
        static correctionCheckingResultWithRangeReplacementStringAlternativeStrings(range: NSRange, replacementString: string, alternativeStrings: string[]): NSTextCheckingResult;
        static dashCheckingResultWithRangeReplacementString(range: NSRange, replacementString: string): NSTextCheckingResult;
        static dateCheckingResultWithRangeDate(range: NSRange, date: Date): NSTextCheckingResult;
        static dateCheckingResultWithRangeDateTimeZoneDuration(range: NSRange, date: Date, timeZone: NSTimeZone, duration: number): NSTextCheckingResult;
        static grammarCheckingResultWithRangeDetails(range: NSRange, details: Map<string, any>[]): NSTextCheckingResult;
        static linkCheckingResultWithRangeUrl(range: NSRange, url: NSURL): NSTextCheckingResult;
        static orthographyCheckingResultWithRangeOrthography(range: NSRange, orthography: NSOrthography): NSTextCheckingResult;
        static phoneNumberCheckingResultWithRangePhoneNumber(range: NSRange, phoneNumber: string): NSTextCheckingResult;
        static quoteCheckingResultWithRangeReplacementString(range: NSRange, replacementString: string): NSTextCheckingResult;
        static regularExpressionCheckingResultWithRangesCountRegularExpression(ranges: NSRange, count: number, regularExpression: NSRegularExpression): NSTextCheckingResult;
        static replacementCheckingResultWithRangeReplacementString(range: NSRange, replacementString: string): NSTextCheckingResult;
        static spellCheckingResultWithRange(range: NSRange): NSTextCheckingResult;
        static transitInformationCheckingResultWithRangeComponents(range: NSRange, components: Map<string, string>): NSTextCheckingResult;
        URL: NSURL;
        addressComponents: Map<string, string>;
        alternativeStrings: string[];
        components: Map<string, string>;
        date: Date;
        duration: number;
        grammarDetails: Map<string, any>[];
        numberOfRanges: number;
        orthography: NSOrthography;
        phoneNumber: string;
        range: NSRange;
        regularExpression: NSRegularExpression;
        replacementString: string;
        resultType: NSTextCheckingResult.CheckingType;
        timeZone: NSTimeZone;
        rangeAtIndex(at: number): NSRange;
        rangeWithName(withName: string): NSRange;
        resultByAdjustingRangesWithOffset(offset: number): NSTextCheckingResult;
    }
    class Thread extends NSObject {
        static detachNewThreadSelectorToTargetWithObject(_: string, toTarget: any, withObject?: any): void;
        static detachNewThreadWithBlock(_: () => void): void;
        static exit(): void;
        static isMultiThreaded(): boolean;
        static setThreadPriority(_: number): boolean;
        static sleepForTimeInterval(_: number): void;
        static sleepUntilDate(_: Date): void;
        static threadPriority(): number;
        isCancelled: boolean;
        isExecuting: boolean;
        isFinished: boolean;
        name: string;
        setName(_: string): any;
        qualityOfService: QualityOfService;
        setQualityOfService(_: QualityOfService): any;
        stackSize: number;
        setStackSize(_: number): any;
        threadDictionary: NSMutableDictionary<any, any>;
        threadPriority: number;
        setThreadPriority(_: number): any;
        static callStackReturnAddresses: number[];
        static callStackSymbols: string[];
        static currentThread: Thread;
        static isMainThread: boolean;
        static mainThread: Thread;
        cancel(): void;
        static createWithBlock(block: () => void): Thread;
        static createWithTargetSelectorObject(target: any, selector: string, object_?: any): Thread;
        main(): void;
        start(): void;
    }
    class NSTimeZone extends NSObject {
        static resetSystemTimeZone(): void;
        abbreviation: string;
        data: NSData;
        isDaylightSavingTime: boolean;
        daylightSavingTimeOffset: number;
        name: string;
        nextDaylightSavingTimeTransition: Date;
        secondsFromGMT: number;
        static abbreviationDictionary: Map<string, string>;
        setAbbreviationDictionary(_: Map<string, string>): any;
        static defaultTimeZone: NSTimeZone;
        setDefaultTimeZone(_: NSTimeZone): any;
        static knownTimeZoneNames: string[];
        static localTimeZone: NSTimeZone;
        static systemTimeZone: NSTimeZone;
        static timeZoneDataVersion: string;
        abbreviationForDate(for_: Date): string;
        daylightSavingTimeOffsetForDate(for_: Date): number;
        static createWithName(name: string): NSTimeZone;
        static createWithNameData(name: string, data?: NSData): NSTimeZone;
        isDaylightSavingTimeForDate(for_: Date): boolean;
        isEqualToTimeZone(to: NSTimeZone): boolean;
        localizedNameLocale(_: NSTimeZone.NameStyle, locale?: NSLocale): string;
        nextDaylightSavingTimeTransitionAfterDate(after: Date): Date;
        secondsFromGMTForDate(for_: Date): number;
    }
    class Timer extends NSObject {
        static scheduledTimerWithTimeIntervalWithRepeatsBlock(_: number, repeats: boolean, block: (p1: Timer) => void): Timer;
        static scheduledTimerWithTimeIntervalTargetSelectorUserInfoRepeats(timeInterval: number, target: any, selector: string, userInfo?: any, repeats?: boolean): Timer;
        fireDate: Date;
        setFireDate(_: Date): any;
        timeInterval: number;
        tolerance: number;
        setTolerance(_: number): any;
        userInfo: any;
        isValid: boolean;
        fire(): void;
        static createWithFireDateIntervalRepeatsBlock(fireDate: Date, interval: number, repeats: boolean, block: (p1: Timer) => void): Timer;
        static createWithFireDateIntervalTargetSelectorUserInfoRepeats(fireDate: Date, interval: number, target: any, selector: string, userInfo?: any, repeats?: boolean): Timer;
        invalidate(): void;
    }
    class NSURL extends NSObject {
        static URLByResolvingAliasFileAtURLOptionsError(resolvingAliasFileAt: NSURL, options: NSURL.BookmarkResolutionOptions): NSURL;
        static URLByResolvingBookmarkDataOptionsRelativeToURLBookmarkDataIsStaleError(options: NSData, relativeToURL: NSURL.BookmarkResolutionOptions, bookmarkDataIsStale?: NSURL, error?: boolean): NSURL;
        static absoluteURLWithDataRepresentationRelativeToURL(withDataRepresentation: NSData, relativeTo?: NSURL): NSURL;
        static bookmarkDataWithContentsOfURLError(error: NSURL): NSData;
        static fileURLWithFileSystemRepresentationIsDirectoryRelativeToURL(withFileSystemRepresentation: string, isDirectory: boolean, relativeTo?: NSURL): NSURL;
        static fileURLWithPath(withPath: string): NSURL;
        static fileURLWithPathIsDirectory(withPath: string, isDirectory: boolean): NSURL;
        static fileURLWithPathIsDirectoryRelativeToURL(withPath: string, isDirectory: boolean, relativeTo?: NSURL): NSURL;
        static fileURLWithPathRelativeToURL(withPath: string, relativeTo?: NSURL): NSURL;
        static fileURLWithPathComponents(withPathComponents: string[]): NSURL;
        static resourceValuesForKeysFromBookmarkData(forKeys: string[], fromBookmarkData: NSData): Map<string, any>;
        static writeBookmarkDataToURLOptionsError(toURL: NSData, options: NSURL, error: number): boolean;
        URLByDeletingLastPathComponent: NSURL;
        URLByDeletingPathExtension: NSURL;
        URLByResolvingSymlinksInPath: NSURL;
        URLByStandardizingPath: NSURL;
        absoluteString: string;
        absoluteURL: NSURL;
        baseURL: NSURL;
        dataRepresentation: NSData;
        filePathURL: NSURL;
        fileSystemRepresentation: string;
        isFileURL: boolean;
        fragment: string;
        hasDirectoryPath: boolean;
        host: string;
        lastPathComponent: string;
        password: string;
        path: string;
        pathComponents: string[];
        pathExtension: string;
        port: number;
        query: string;
        relativePath: string;
        relativeString: string;
        resourceSpecifier: string;
        scheme: string;
        standardizedURL: NSURL;
        user: string;
        URLByAppendingPathComponent(_: string): NSURL;
        URLByAppendingPathComponentIsDirectory(_: string, isDirectory: boolean): NSURL;
        URLByAppendingPathExtension(_: string): NSURL;
        bookmarkDataWithOptionsIncludingResourceValuesForKeysRelativeToURLError(includingResourceValuesForKeys: NSURL.BookmarkCreationOptions, relativeToURL?: string[], error?: NSURL): NSData;
        checkPromisedItemIsReachableAndReturnError(): boolean;
        checkResourceIsReachableAndReturnError(): boolean;
        fileReferenceURL(): NSURL;
        getFileSystemRepresentationMaxLength(_: string, maxLength: number): boolean;
        getPromisedItemResourceValueForKeyError(forKey?: any, error?: string): boolean;
        getResourceValueForKeyError(forKey?: any, error?: string): boolean;
        static createWithAbsoluteURLWithDataRepresentationRelativeToURL(absoluteURLWithDataRepresentation: NSData, relativeToURL?: NSURL): NSURL;
        static createWithByResolvingBookmarkDataOptionsRelativeToURLBookmarkDataIsStale(byResolvingBookmarkData: NSData, options: NSURL.BookmarkResolutionOptions, relativeToURL?: NSURL, bookmarkDataIsStale?: boolean): NSURL;
        static createWithFileURLWithFileSystemRepresentationIsDirectoryRelativeToURL(fileURLWithFileSystemRepresentation: string, isDirectory: boolean, relativeToURL?: NSURL): NSURL;
        static createWithFileURLWithPath(fileURLWithPath: string): NSURL;
        static createWithFileURLWithPathIsDirectory(fileURLWithPath: string, isDirectory: boolean): NSURL;
        static createWithFileURLWithPathIsDirectoryRelativeToURL(fileURLWithPath: string, isDirectory: boolean, relativeToURL?: NSURL): NSURL;
        static createWithFileURLWithPathRelativeToURL(fileURLWithPath: string, relativeToURL?: NSURL): NSURL;
        static createWithDataRepresentationRelativeToURL(dataRepresentation: NSData, relativeToURL?: NSURL): NSURL;
        static createWithString(string: string): NSURL;
        static createWithStringRelativeToURL(string: string, relativeToURL?: NSURL): NSURL;
        isFileReferenceURL(): boolean;
        promisedItemResourceValuesForKeysError(error: string[]): Map<string, any>;
        removeAllCachedResourceValues(): void;
        removeCachedResourceValueForKey(forKey: string): void;
        resourceValuesForKeysError(error: string[]): Map<string, any>;
        setResourceValueForKeyError(forKey?: any, error?: string): boolean;
        setResourceValuesError(error: Map<string, any>): boolean;
        setTemporaryResourceValueForKey(_?: any, forKey?: string): void;
        startAccessingSecurityScopedResource(): boolean;
        stopAccessingSecurityScopedResource(): void;
        writeToPasteboard(to: NSPasteboard): void;
    }
    class URLAuthenticationChallenge extends NSObject {
        error: NSError;
        failureResponse: URLResponse;
        previousFailureCount: number;
        proposedCredential: URLCredential;
        protectionSpace: URLProtectionSpace;
        sender: URLAuthenticationChallengeSender;
        static createWithAuthenticationChallengeSender(authenticationChallenge: URLAuthenticationChallenge, sender: URLAuthenticationChallengeSender): URLAuthenticationChallenge;
        static createWithProtectionSpaceProposedCredentialPreviousFailureCountFailureResponseErrorSender(protectionSpace: URLProtectionSpace, proposedCredential?: URLCredential, previousFailureCount?: number, failureResponse?: URLResponse, error?: NSError, sender?: URLAuthenticationChallengeSender): URLAuthenticationChallenge;
    }
    interface URLAuthenticationChallengeSender extends NSObject {
        cancelAuthenticationChallenge(_: URLAuthenticationChallenge): void;
        continueWithoutCredentialForAuthenticationChallenge(_: URLAuthenticationChallenge): void;
        performDefaultHandlingForAuthenticationChallenge?(_: URLAuthenticationChallenge): void;
        rejectProtectionSpaceAndContinueWithChallenge?(_: URLAuthenticationChallenge): void;
        useCredentialForAuthenticationChallenge(_: URLCredential, forAuthenticationChallenge: URLAuthenticationChallenge): void;
    }
    class URLCache extends NSObject {
        currentDiskUsage: number;
        currentMemoryUsage: number;
        diskCapacity: number;
        setDiskCapacity(_: number): any;
        memoryCapacity: number;
        setMemoryCapacity(_: number): any;
        static sharedURLCache: URLCache;
        setSharedURLCache(_: URLCache): any;
        cachedResponseForRequest(_: NSURLRequest): CachedURLResponse;
        getCachedResponseForDataTaskWithCompletionHandler(_: URLSessionDataTask, completionHandler?: (p1: CachedURLResponse) => void): void;
        static createWithMemoryCapacityDiskCapacityDirectoryURL(memoryCapacity: number, diskCapacity: number, directoryURL?: NSURL): URLCache;
        static createWithMemoryCapacityDiskCapacityDiskPath(memoryCapacity: number, diskCapacity: number, diskPath?: string): URLCache;
        removeAllCachedResponses(): void;
        removeCachedResponseForDataTask(_: URLSessionDataTask): void;
        removeCachedResponseForRequest(_: NSURLRequest): void;
        removeCachedResponsesSinceDate(_: Date): void;
        storeCachedResponseForDataTask(_: CachedURLResponse, forDataTask: URLSessionDataTask): void;
        storeCachedResponseForRequest(_: CachedURLResponse, forRequest: NSURLRequest): void;
    }
    class NSURLComponents extends NSObject {
        static componentsWithString(string: string): NSURLComponents;
        static componentsWithURLResolvingAgainstBaseURL(url: NSURL, resolvingAgainstBaseURL: boolean): NSURLComponents;
        URL: NSURL;
        fragment: string;
        setFragment(_: string): any;
        host: string;
        setHost(_: string): any;
        password: string;
        setPassword(_: string): any;
        path: string;
        setPath(_: string): any;
        percentEncodedFragment: string;
        setPercentEncodedFragment(_: string): any;
        percentEncodedHost: string;
        setPercentEncodedHost(_: string): any;
        percentEncodedPassword: string;
        setPercentEncodedPassword(_: string): any;
        percentEncodedPath: string;
        setPercentEncodedPath(_: string): any;
        percentEncodedQuery: string;
        setPercentEncodedQuery(_: string): any;
        percentEncodedQueryItems: NSURLQueryItem[];
        setPercentEncodedQueryItems(_: NSURLQueryItem[]): any;
        percentEncodedUser: string;
        setPercentEncodedUser(_: string): any;
        port: number;
        setPort(_: number): any;
        query: string;
        setQuery(_: string): any;
        queryItems: NSURLQueryItem[];
        setQueryItems(_: NSURLQueryItem[]): any;
        rangeOfFragment: NSRange;
        rangeOfHost: NSRange;
        rangeOfPassword: NSRange;
        rangeOfPath: NSRange;
        rangeOfPort: NSRange;
        rangeOfQuery: NSRange;
        rangeOfScheme: NSRange;
        rangeOfUser: NSRange;
        scheme: string;
        setScheme(_: string): any;
        string: string;
        user: string;
        setUser(_: string): any;
        URLRelativeToURL(relativeTo?: NSURL): NSURL;
        static createWithString(string: string): NSURLComponents;
        static createWithUrlResolvingAgainstBaseURL(URL: NSURL, resolvingAgainstBaseURL: boolean): NSURLComponents;
    }
    class NSURLConnection extends NSObject {
        static canHandleRequest(_: NSURLRequest): boolean;
        currentRequest: NSURLRequest;
        originalRequest: NSURLRequest;
        cancel(): void;
        scheduleInRunLoopForMode(in_: RunLoop, forMode: string): void;
        setDelegateQueue(_?: OperationQueue): void;
        start(): void;
        unscheduleFromRunLoopForMode(from: RunLoop, forMode: string): void;
    }
    interface NSURLConnectionDataDelegate extends NSURLConnectionDelegate {
        connectionWillSendRequestRedirectResponse?(_: NSURLConnection, willSend: NSURLRequest, redirectResponse?: URLResponse): NSURLRequest;
        connectionDidReceiveResponse?(_: NSURLConnection, didReceive: URLResponse): void;
        connectionDidReceiveData?(_: NSURLConnection, didReceive: NSData): void;
        connectionDidSendBodyDataTotalBytesWrittenTotalBytesExpectedToWrite?(_: NSURLConnection, didSendBodyData: number, totalBytesWritten: number, totalBytesExpectedToWrite: number): void;
        connectionNeedNewBodyStream?(_: NSURLConnection, needNewBodyStream: NSURLRequest): InputStream;
        connectionWillCacheResponse?(_: NSURLConnection, willCacheResponse: CachedURLResponse): CachedURLResponse;
        connectionDidFinishLoading?(_: NSURLConnection): void;
    }
    interface NSURLConnectionDelegate extends NSObject {
        connectionWillSendRequestForAuthenticationChallenge?(_: NSURLConnection, willSendRequestFor: URLAuthenticationChallenge): void;
        connectionDidFailWithError?(_: NSURLConnection, didFailWithError: NSError): void;
        connectionShouldUseCredentialStorage?(_: NSURLConnection): boolean;
    }
    interface NSURLConnectionDownloadDelegate extends NSURLConnectionDelegate {
        connectionDidWriteDataTotalBytesWrittenExpectedTotalBytes?(_: NSURLConnection, didWriteData: number, totalBytesWritten: number, expectedTotalBytes: number): void;
        connectionDidFinishDownloadingDestinationURL(_: NSURLConnection, destinationURL: NSURL): void;
        connectionDidResumeDownloadingTotalBytesWrittenExpectedTotalBytes?(_: NSURLConnection, totalBytesWritten: number, expectedTotalBytes: number): void;
    }
    class URLCredential extends NSObject {
        certificates: any[];
        hasPassword: boolean;
        identity: any;
        password: string;
        persistence: URLCredential.Persistence;
        user: string;
        static createWithIdentityCertificatesPersistence(identity: any, certificates?: any[], persistence?: URLCredential.Persistence): URLCredential;
        static createWithTrust(trust: any): URLCredential;
        static createWithUserPasswordPersistence(user: string, password: string, persistence: URLCredential.Persistence): URLCredential;
    }
    class URLCredentialStorage extends NSObject {
        allCredentials: Map<URLProtectionSpace, Map<string, URLCredential>>;
        static sharedCredentialStorage: URLCredentialStorage;
        credentialsForProtectionSpace(_: URLProtectionSpace): Map<string, URLCredential>;
        defaultCredentialForProtectionSpace(_: URLProtectionSpace): URLCredential;
        getCredentialsForTaskCompletionHandler(for_: URLProtectionSpace, task: URLSessionTask, completionHandler?: (p1: Map<string, URLCredential>) => void): void;
        getDefaultCredentialForProtectionSpaceWithTaskCompletionHandler(_: URLProtectionSpace, task: URLSessionTask, completionHandler?: (p1: URLCredential) => void): void;
        removeCredentialForProtectionSpace(_: URLCredential, forProtectionSpace: URLProtectionSpace): void;
        removeCredentialForProtectionSpaceOptions(_: URLCredential, forProtectionSpace: URLProtectionSpace, options?: Map<string, any>): void;
        removeCredentialForProtectionSpaceOptionsTask(_: URLCredential, forProtectionSpace: URLProtectionSpace, options?: Map<string, any>, task?: URLSessionTask): void;
        setCredentialForProtectionSpace(_: URLCredential, for_: URLProtectionSpace): void;
        setCredentialForProtectionSpaceTask(_: URLCredential, for_: URLProtectionSpace, task: URLSessionTask): void;
        setDefaultCredentialForProtectionSpace(_: URLCredential, forProtectionSpace: URLProtectionSpace): void;
        setDefaultCredentialForProtectionSpaceTask(_: URLCredential, forProtectionSpace: URLProtectionSpace, task: URLSessionTask): void;
    }
    class NSURLDownload extends NSObject {
        static canResumeDownloadDecodedWithEncodingMIMEType(withEncodingMIMEType: string): boolean;
        deletesFileUponFailure: boolean;
        setDeletesFileUponFailure(_: boolean): any;
        request: NSURLRequest;
        resumeData: NSData;
        cancel(): void;
        setDestinationAllowOverwrite(_: string, allowOverwrite: boolean): void;
    }
    interface NSURLDownloadDelegate extends NSObject {
        downloadWillSendRequestRedirectResponse?(_: NSURLDownload, willSend: NSURLRequest, redirectResponse?: URLResponse): NSURLRequest;
        downloadDidReceiveAuthenticationChallenge?(_: NSURLDownload, didReceive: URLAuthenticationChallenge): void;
        downloadDidCancelAuthenticationChallenge?(_: NSURLDownload, didCancel: URLAuthenticationChallenge): void;
        downloadDidReceiveResponse?(_: NSURLDownload, didReceive: URLResponse): void;
        downloadWillResumeWithResponseFromByte?(_: NSURLDownload, willResumeWith: URLResponse, fromByte: number): void;
        downloadCanAuthenticateAgainstProtectionSpace?(_: NSURLDownload, canAuthenticateAgainstProtectionSpace: URLProtectionSpace): boolean;
        downloadDecideDestinationWithSuggestedFilename?(_: NSURLDownload, decideDestinationWithSuggestedFilename: string): void;
        downloadDidCreateDestination?(_: NSURLDownload, didCreateDestination: string): void;
        downloadDidFailWithError?(_: NSURLDownload, didFailWithError: NSError): void;
        downloadDidReceiveDataOfLength?(_: NSURLDownload, didReceiveDataOfLength: number): void;
        downloadShouldDecodeSourceDataOfMIMEType?(_: NSURLDownload, shouldDecodeSourceDataOfMIMEType: string): boolean;
        downloadDidBegin?(_: NSURLDownload): void;
        downloadDidFinish?(_: NSURLDownload): void;
        downloadShouldUseCredentialStorage?(_: NSURLDownload): boolean;
    }
    class NSURLHandle extends NSObject {
    }
    class URLProtectionSpace extends NSObject {
        authenticationMethod: string;
        distinguishedNames: NSData[];
        host: string;
        isProxy: boolean;
        port: number;
        protocol: string;
        proxyType: string;
        realm: string;
        receivesCredentialSecurely: boolean;
        serverTrust: any;
        static createWithHostPortProtocolRealmAuthenticationMethod(host: string, port: number, protocol?: string, realm?: string, authenticationMethod?: string): URLProtectionSpace;
        static createWithProxyHostPortTypeRealmAuthenticationMethod(proxyHost: string, port: number, type?: string, realm?: string, authenticationMethod?: string): URLProtectionSpace;
    }
    class URLProtocol extends NSObject {
        static canInitWithRequest(_: NSURLRequest): boolean;
        static canInitWithTask(_: URLSessionTask): boolean;
        static canonicalRequestForRequest(_: NSURLRequest): NSURLRequest;
        static propertyForKeyInRequest(_: string, inRequest: NSURLRequest): any;
        static registerClass(_: typeof NSObject): boolean;
        static removePropertyForKeyInRequest(_: string, inRequest: NSMutableURLRequest): void;
        static requestIsCacheEquivalentToRequest(_: NSURLRequest, toRequest: NSURLRequest): boolean;
        static setPropertyForKeyInRequest(_: any, forKey: string, inRequest: NSMutableURLRequest): void;
        static unregisterClass(_: typeof NSObject): void;
        cachedResponse: CachedURLResponse;
        client: URLProtocolClient;
        request: NSURLRequest;
        task: URLSessionTask;
        static createWithRequestCachedResponseClient(request: NSURLRequest, cachedResponse?: CachedURLResponse, client?: URLProtocolClient): URLProtocol;
        static createWithTaskCachedResponseClient(task: URLSessionTask, cachedResponse?: CachedURLResponse, client?: URLProtocolClient): URLProtocol;
        startLoading(): void;
        stopLoading(): void;
    }
    interface URLProtocolClient extends NSObject {
        URLProtocolCachedResponseIsValid(_: URLProtocol, cachedResponseIsValid: CachedURLResponse): void;
        URLProtocolDidCancelAuthenticationChallenge(_: URLProtocol, didCancelAuthenticationChallenge: URLAuthenticationChallenge): void;
        URLProtocolDidFailWithError(_: URLProtocol, didFailWithError: NSError): void;
        URLProtocolDidLoadData(_: URLProtocol, didLoadData: NSData): void;
        URLProtocolDidReceiveAuthenticationChallenge(_: URLProtocol, didReceiveAuthenticationChallenge: URLAuthenticationChallenge): void;
        URLProtocolDidReceiveResponseCacheStoragePolicy(_: URLProtocol, didReceiveResponse: URLResponse, cacheStoragePolicy: URLCache.StoragePolicy): void;
        URLProtocolWasRedirectedToRequestRedirectResponse(_: URLProtocol, wasRedirectedToRequest: NSURLRequest, redirectResponse: URLResponse): void;
        URLProtocolDidFinishLoading(_: URLProtocol): void;
    }
    class NSURLQueryItem extends NSObject {
        static queryItemWithNameValue(name: string, value?: string): NSURLQueryItem;
        name: string;
        value: string;
        static createWithNameValue(name: string, value?: string): NSURLQueryItem;
    }
    class NSURLRequest extends NSObject {
        HTTPBody: NSData;
        HTTPBodyStream: InputStream;
        HTTPMethod: string;
        HTTPShouldHandleCookies: boolean;
        HTTPShouldUsePipelining: boolean;
        URL: NSURL;
        allHTTPHeaderFields: Map<string, string>;
        allowsCellularAccess: boolean;
        allowsConstrainedNetworkAccess: boolean;
        allowsExpensiveNetworkAccess: boolean;
        cachePolicy: NSURLRequest.CachePolicy;
        mainDocumentURL: NSURL;
        networkServiceType: NSURLRequest.NetworkServiceType;
        timeoutInterval: number;
        static createWithUrl(URL: NSURL): NSURLRequest;
        static createWithUrlCachePolicyTimeoutInterval(URL: NSURL, cachePolicy: NSURLRequest.CachePolicy, timeoutInterval: number): NSURLRequest;
        valueForHTTPHeaderField(forHTTPHeaderField: string): string;
    }
    class URLResponse extends NSObject {
        MIMEType: string;
        URL: NSURL;
        expectedContentLength: number;
        suggestedFilename: string;
        textEncodingName: string;
        static createWithUrlMIMETypeExpectedContentLengthTextEncodingName(URL: NSURL, MIMEType?: string, expectedContentLength?: number, textEncodingName?: string): URLResponse;
    }
    class URLSession extends NSObject {
        configuration: URLSessionConfiguration;
        delegate: URLSessionDelegate;
        delegateQueue: OperationQueue;
        sessionDescription: string;
        setSessionDescription(_: string): any;
        static sharedSession: URLSession;
        dataTaskWithRequest(_: NSURLRequest): URLSessionDataTask;
        dataTaskWithRequestWithCompletionHandler(_: NSURLRequest, completionHandler?: (p1: NSData, p2: URLResponse, p3: NSError) => void): URLSessionDataTask;
        dataTaskWithURL(_: NSURL): URLSessionDataTask;
        dataTaskWithURLWithCompletionHandler(_: NSURL, completionHandler?: (p1: NSData, p2: URLResponse, p3: NSError) => void): URLSessionDataTask;
        downloadTaskWithRequest(_: NSURLRequest): URLSessionDownloadTask;
        downloadTaskWithRequestWithCompletionHandler(_: NSURLRequest, completionHandler?: (p1: NSURL, p2: URLResponse, p3: NSError) => void): URLSessionDownloadTask;
        downloadTaskWithResumeData(_: NSData): URLSessionDownloadTask;
        downloadTaskWithResumeDataWithCompletionHandler(_: NSData, completionHandler?: (p1: NSURL, p2: URLResponse, p3: NSError) => void): URLSessionDownloadTask;
        downloadTaskWithURL(_: NSURL): URLSessionDownloadTask;
        downloadTaskWithURLWithCompletionHandler(_: NSURL, completionHandler?: (p1: NSURL, p2: URLResponse, p3: NSError) => void): URLSessionDownloadTask;
        finishTasksAndInvalidate(): void;
        flushWithCompletionHandler(_: () => void): void;
        getAllTasksWithCompletionHandler(_: (p1: URLSessionTask[]) => void): void;
        getTasksWithCompletionHandler(_: (p1: URLSessionDataTask[], p2: URLSessionUploadTask[], p3: URLSessionDownloadTask[]) => void): void;
        invalidateAndCancel(): void;
        resetWithCompletionHandler(_: () => void): void;
        streamTaskWithHostNamePort(_: string, port: number): URLSessionStreamTask;
        streamTaskWithNetService(_: NetService): URLSessionStreamTask;
        uploadTaskWithRequestFromData(_: NSURLRequest, fromData: NSData): URLSessionUploadTask;
        uploadTaskWithRequestWithFromDataCompletionHandler(_: NSURLRequest, fromData?: NSData, completionHandler?: (p1: NSData, p2: URLResponse, p3: NSError) => void): URLSessionUploadTask;
        uploadTaskWithRequestFromFile(_: NSURLRequest, fromFile: NSURL): URLSessionUploadTask;
        uploadTaskWithRequestWithFromFileCompletionHandler(_: NSURLRequest, fromFile: NSURL, completionHandler?: (p1: NSData, p2: URLResponse, p3: NSError) => void): URLSessionUploadTask;
        uploadTaskWithStreamedRequest(_: NSURLRequest): URLSessionUploadTask;
        webSocketTaskWithRequest(_: NSURLRequest): URLSessionWebSocketTask;
        webSocketTaskWithURL(_: NSURL): URLSessionWebSocketTask;
        webSocketTaskWithURLProtocols(_: NSURL, protocols: string[]): URLSessionWebSocketTask;
    }
    class URLSessionConfiguration extends NSObject {
        static backgroundSessionConfigurationWithIdentifier(withIdentifier: string): URLSessionConfiguration;
        HTTPAdditionalHeaders: Map<any, any>;
        setHTTPAdditionalHeaders(_: Map<any, any>): any;
        HTTPCookieAcceptPolicy: HTTPCookie.AcceptPolicy;
        setHTTPCookieAcceptPolicy(_: HTTPCookie.AcceptPolicy): any;
        HTTPCookieStorage: HTTPCookieStorage;
        setHTTPCookieStorage(_: HTTPCookieStorage): any;
        HTTPMaximumConnectionsPerHost: number;
        setHTTPMaximumConnectionsPerHost(_: number): any;
        HTTPShouldSetCookies: boolean;
        setHTTPShouldSetCookies(_: boolean): any;
        HTTPShouldUsePipelining: boolean;
        setHTTPShouldUsePipelining(_: boolean): any;
        TLSMaximumSupportedProtocol: SSLProtocol;
        setTLSMaximumSupportedProtocol(_: SSLProtocol): any;
        TLSMaximumSupportedProtocolVersion: tls_protocol_version_t;
        setTLSMaximumSupportedProtocolVersion(_: tls_protocol_version_t): any;
        TLSMinimumSupportedProtocol: SSLProtocol;
        setTLSMinimumSupportedProtocol(_: SSLProtocol): any;
        TLSMinimumSupportedProtocolVersion: tls_protocol_version_t;
        setTLSMinimumSupportedProtocolVersion(_: tls_protocol_version_t): any;
        URLCache: URLCache;
        setURLCache(_: URLCache): any;
        URLCredentialStorage: URLCredentialStorage;
        setURLCredentialStorage(_: URLCredentialStorage): any;
        allowsCellularAccess: boolean;
        setAllowsCellularAccess(_: boolean): any;
        allowsConstrainedNetworkAccess: boolean;
        setAllowsConstrainedNetworkAccess(_: boolean): any;
        allowsExpensiveNetworkAccess: boolean;
        setAllowsExpensiveNetworkAccess(_: boolean): any;
        connectionProxyDictionary: Map<any, any>;
        setConnectionProxyDictionary(_: Map<any, any>): any;
        isDiscretionary: boolean;
        setDiscretionary(_: boolean): any;
        identifier: string;
        networkServiceType: NSURLRequest.NetworkServiceType;
        setNetworkServiceType(_: NSURLRequest.NetworkServiceType): any;
        protocolClasses: typeof NSObject[];
        setProtocolClasses(_: typeof NSObject[]): any;
        requestCachePolicy: NSURLRequest.CachePolicy;
        setRequestCachePolicy(_: NSURLRequest.CachePolicy): any;
        sharedContainerIdentifier: string;
        setSharedContainerIdentifier(_: string): any;
        shouldUseExtendedBackgroundIdleMode: boolean;
        setShouldUseExtendedBackgroundIdleMode(_: boolean): any;
        timeoutIntervalForRequest: number;
        setTimeoutIntervalForRequest(_: number): any;
        timeoutIntervalForResource: number;
        setTimeoutIntervalForResource(_: number): any;
        waitsForConnectivity: boolean;
        setWaitsForConnectivity(_: boolean): any;
        static defaultSessionConfiguration: URLSessionConfiguration;
        static ephemeralSessionConfiguration: URLSessionConfiguration;
    }
    interface URLSessionDataDelegate extends URLSessionTaskDelegate {
        URLSessionDataTaskDidBecomeDownloadTask?(_: URLSession, dataTask: URLSessionDataTask, didBecomeDownloadTask: URLSessionDownloadTask): void;
        URLSessionDataTaskDidBecomeStreamTask?(_: URLSession, dataTask: URLSessionDataTask, didBecomeStreamTask: URLSessionStreamTask): void;
        URLSessionDataTaskDidReceiveData?(_: URLSession, dataTask: URLSessionDataTask, didReceiveData: NSData): void;
        URLSessionWithDataTaskDidReceiveResponseCompletionHandler?(_: URLSession, dataTask: URLSessionDataTask, didReceiveResponse: URLResponse, completionHandler: (p1: URLSession.ResponseDisposition) => void): void;
        URLSessionWithDataTaskWillCacheResponseCompletionHandler?(_: URLSession, dataTask: URLSessionDataTask, willCacheResponse: CachedURLResponse, completionHandler?: (p1: CachedURLResponse) => void): void;
    }
    class URLSessionDataTask extends URLSessionTask {
    }
    interface URLSessionDelegate extends NSObject {
        URLSessionDidBecomeInvalidWithError?(_: URLSession, didBecomeInvalidWithError?: NSError): void;
        URLSessionWithDidReceiveChallengeCompletionHandler?(_: URLSession, didReceiveChallenge: URLAuthenticationChallenge, completionHandler?: (p1: URLSession.AuthChallengeDisposition, p2: URLCredential) => void): void;
    }
    interface URLSessionDownloadDelegate extends URLSessionTaskDelegate {
        URLSessionDownloadTaskDidFinishDownloadingToURL(_: URLSession, downloadTask: URLSessionDownloadTask, didFinishDownloadingToURL: NSURL): void;
        URLSessionDownloadTaskDidResumeAtOffsetExpectedTotalBytes?(_: URLSession, downloadTask: URLSessionDownloadTask, didResumeAtOffset: number, expectedTotalBytes: number): void;
        URLSessionDownloadTaskDidWriteDataTotalBytesWrittenTotalBytesExpectedToWrite?(_: URLSession, downloadTask: URLSessionDownloadTask, didWriteData: number, totalBytesWritten: number, totalBytesExpectedToWrite: number): void;
    }
    class URLSessionDownloadTask extends URLSessionTask {
        cancelByProducingResumeData(_?: (p1: NSData) => void): void;
    }
    interface URLSessionStreamDelegate extends URLSessionTaskDelegate {
        URLSessionBetterRouteDiscoveredForStreamTask?(_: URLSession, betterRouteDiscoveredForStreamTask: URLSessionStreamTask): void;
        URLSessionReadClosedForStreamTask?(_: URLSession, readClosedForStreamTask: URLSessionStreamTask): void;
        URLSessionStreamTaskDidBecomeInputStreamOutputStream?(_: URLSession, streamTask: URLSessionStreamTask, didBecomeInputStream: InputStream, outputStream: OutputStream): void;
        URLSessionWriteClosedForStreamTask?(_: URLSession, writeClosedForStreamTask: URLSessionStreamTask): void;
    }
    class URLSessionStreamTask extends URLSessionTask {
        captureStreams(): void;
        closeRead(): void;
        closeWrite(): void;
        readDataOfMinLengthWithMaxLengthTimeoutCompletionHandler(_: number, maxLength: number, timeout: number, completionHandler?: (p1: NSData, p2: boolean, p3: NSError) => void): void;
        startSecureConnection(): void;
        writeDataWithTimeoutCompletionHandler(_: NSData, timeout: number, completionHandler?: (p1: NSError) => void): void;
    }
    class URLSessionTask extends NSObject {
        countOfBytesClientExpectsToReceive: number;
        setCountOfBytesClientExpectsToReceive(_: number): any;
        countOfBytesClientExpectsToSend: number;
        setCountOfBytesClientExpectsToSend(_: number): any;
        countOfBytesExpectedToReceive: number;
        countOfBytesExpectedToSend: number;
        countOfBytesReceived: number;
        countOfBytesSent: number;
        currentRequest: NSURLRequest;
        earliestBeginDate: Date;
        setEarliestBeginDate(_: Date): any;
        error: NSError;
        originalRequest: NSURLRequest;
        priority: number;
        setPriority(_: number): any;
        response: URLResponse;
        state: URLSessionTask.State;
        taskDescription: string;
        setTaskDescription(_: string): any;
        taskIdentifier: number;
        cancel(): void;
        resume(): void;
        suspend(): void;
    }
    interface URLSessionTaskDelegate extends URLSessionDelegate {
        URLSessionTaskDidCompleteWithError?(_: URLSession, task: URLSessionTask, didCompleteWithError?: NSError): void;
        URLSessionTaskDidFinishCollectingMetrics?(_: URLSession, task: URLSessionTask, didFinishCollectingMetrics: URLSessionTaskMetrics): void;
        URLSessionWithTaskDidReceiveChallengeCompletionHandler?(_: URLSession, task: URLSessionTask, didReceiveChallenge: URLAuthenticationChallenge, completionHandler?: (p1: URLSession.AuthChallengeDisposition, p2: URLCredential) => void): void;
        URLSessionTaskDidSendBodyDataTotalBytesSentTotalBytesExpectedToSend?(_: URLSession, task: URLSessionTask, didSendBodyData: number, totalBytesSent: number, totalBytesExpectedToSend: number): void;
        URLSessionWithTaskNeedNewBodyStream?(_: URLSession, task: URLSessionTask, needNewBodyStream?: (p1: InputStream) => void): void;
        URLSessionWithTaskWillBeginDelayedRequestCompletionHandler?(_: URLSession, task: URLSessionTask, willBeginDelayedRequest: NSURLRequest, completionHandler?: (p1: NSURLSessionDelayedRequestDisposition, p2: NSURLRequest) => void): void;
        URLSessionWithTaskWillPerformHTTPRedirectionNewRequestCompletionHandler?(_: URLSession, task: URLSessionTask, willPerformHTTPRedirection: HTTPURLResponse, newRequest: NSURLRequest, completionHandler?: (p1: NSURLRequest) => void): void;
        URLSessionTaskIsWaitingForConnectivity?(_: URLSession, taskIsWaitingForConnectivity: URLSessionTask): void;
    }
    class URLSessionTaskMetrics extends NSObject {
        redirectCount: number;
        taskInterval: NSDateInterval;
        transactionMetrics: URLSessionTaskTransactionMetrics[];
    }
    class URLSessionTaskTransactionMetrics extends NSObject {
        isCellular: boolean;
        connectEndDate: Date;
        connectStartDate: Date;
        isConstrained: boolean;
        countOfRequestBodyBytesBeforeEncoding: number;
        countOfRequestBodyBytesSent: number;
        countOfRequestHeaderBytesSent: number;
        countOfResponseBodyBytesAfterDecoding: number;
        countOfResponseBodyBytesReceived: number;
        countOfResponseHeaderBytesReceived: number;
        domainLookupEndDate: Date;
        domainLookupStartDate: Date;
        isExpensive: boolean;
        fetchStartDate: Date;
        localAddress: string;
        localPort: number;
        isMultipath: boolean;
        negotiatedTLSCipherSuite: number;
        negotiatedTLSProtocolVersion: number;
        networkProtocolName: string;
        isProxyConnection: boolean;
        remoteAddress: string;
        remotePort: number;
        request: NSURLRequest;
        requestEndDate: Date;
        requestStartDate: Date;
        resourceFetchType: URLSessionTaskMetrics.ResourceFetchType;
        response: URLResponse;
        responseEndDate: Date;
        responseStartDate: Date;
        isReusedConnection: boolean;
        secureConnectionEndDate: Date;
        secureConnectionStartDate: Date;
    }
    class URLSessionUploadTask extends URLSessionDataTask {
    }
    interface URLSessionWebSocketDelegate extends URLSessionTaskDelegate {
        URLSessionWebSocketTaskDidCloseWithCodeReason?(_: URLSession, webSocketTask: URLSessionWebSocketTask, didCloseWithCode: URLSessionWebSocketTask.CloseCode, reason?: NSData): void;
        URLSessionWebSocketTaskDidOpenWithProtocol?(_: URLSession, webSocketTask: URLSessionWebSocketTask, didOpenWithProtocol?: string): void;
    }
    class NSURLSessionWebSocketMessage extends NSObject {
        data: NSData;
        string: string;
        type: NSURLSessionWebSocketMessageType;
        static createWithData(data: NSData): NSURLSessionWebSocketMessage;
        static createWithString(string: string): NSURLSessionWebSocketMessage;
    }
    class URLSessionWebSocketTask extends URLSessionTask {
        closeCode: URLSessionWebSocketTask.CloseCode;
        closeReason: NSData;
        maximumMessageSize: number;
        setMaximumMessageSize(_: number): any;
        cancelWithCloseCodeReason(_: URLSessionWebSocketTask.CloseCode, reason?: NSData): void;
        receiveMessageWithCompletionHandler(_?: (p1: NSURLSessionWebSocketMessage, p2: NSError) => void): void;
        sendMessageWithCompletionHandler(_: NSURLSessionWebSocketMessage, completionHandler?: (p1: NSError) => void): void;
        sendPingWithPongReceiveHandler(_?: (p1: NSError) => void): void;
    }
    class NSUUID extends NSObject {
        UUIDString: string;
        getUUIDBytes(_: number): void;
        static createWithUUIDBytes(UUIDBytes?: number): NSUUID;
        static createWithUUIDString(UUIDString: string): NSUUID;
    }
    class NSUbiquitousKeyValueStore extends NSObject {
        dictionaryRepresentation: Map<string, any>;
        static defaultStore: NSUbiquitousKeyValueStore;
        arrayForKey(forKey: string): any[];
        boolForKey(forKey: string): boolean;
        dataForKey(forKey: string): NSData;
        dictionaryForKey(forKey: string): Map<string, any>;
        doubleForKey(forKey: string): number;
        longLongForKey(forKey: string): number;
        objectForKey(forKey: string): any;
        removeObjectForKey(forKey: string): void;
        setArrayForKey(_?: any[], forKey?: string): void;
        setBoolForKey(_: boolean, forKey: string): void;
        setDataForKey(_?: NSData, forKey?: string): void;
        setDictionaryForKey(_?: Map<string, any>, forKey?: string): void;
        setDoubleForKey(_: number, forKey: string): void;
        setLongLongForKey(_: number, forKey: string): void;
        setObjectForKey(_?: any, forKey?: string): void;
        setStringForKey(_?: string, forKey?: string): void;
        stringForKey(forKey: string): string;
        synchronize(): boolean;
    }
    class UndoManager extends NSObject {
        canRedo: boolean;
        canUndo: boolean;
        groupingLevel: number;
        groupsByEvent: boolean;
        setGroupsByEvent(_: boolean): any;
        levelsOfUndo: number;
        setLevelsOfUndo(_: number): any;
        redoActionIsDiscardable: boolean;
        redoActionName: string;
        redoMenuItemTitle: string;
        isRedoing: boolean;
        runLoopModes: string[];
        setRunLoopModes(_: string[]): any;
        undoActionIsDiscardable: boolean;
        undoActionName: string;
        undoMenuItemTitle: string;
        isUndoRegistrationEnabled: boolean;
        isUndoing: boolean;
        beginUndoGrouping(): void;
        disableUndoRegistration(): void;
        enableUndoRegistration(): void;
        endUndoGrouping(): void;
        prepareWithInvocationTarget(_: any): any;
        redo(): void;
        redoMenuTitleForUndoActionName(_: string): string;
        registerUndoWithTargetSelectorObject(_: any, selector: string, object_?: any): void;
        removeAllActions(): void;
        removeAllActionsWithTarget(_: any): void;
        setActionIsDiscardable(_: boolean): void;
        setActionName(_: string): void;
        undo(): void;
        undoMenuTitleForUndoActionName(_: string): string;
        undoNestedGroup(): void;
    }
    class NSUniqueIDSpecifier extends NSScriptObjectSpecifier {
        uniqueID: any;
        setUniqueID(_: any): any;
        static createWithContainerClassDescriptionContainerSpecifierKeyUniqueID(containerClassDescription: NSScriptClassDescription, containerSpecifier?: NSScriptObjectSpecifier, key?: string, uniqueID?: any): NSUniqueIDSpecifier;
    }
    class Unit extends NSObject {
        symbol: string;
        static createWithSymbol(symbol: string): Unit;
    }
    class UnitAcceleration extends Dimension {
        static gravity: UnitAcceleration;
        static metersPerSecondSquared: UnitAcceleration;
    }
    class UnitAngle extends Dimension {
        static arcMinutes: UnitAngle;
        static arcSeconds: UnitAngle;
        static degrees: UnitAngle;
        static gradians: UnitAngle;
        static radians: UnitAngle;
        static revolutions: UnitAngle;
    }
    class UnitArea extends Dimension {
        static acres: UnitArea;
        static ares: UnitArea;
        static hectares: UnitArea;
        static squareCentimeters: UnitArea;
        static squareFeet: UnitArea;
        static squareInches: UnitArea;
        static squareKilometers: UnitArea;
        static squareMegameters: UnitArea;
        static squareMeters: UnitArea;
        static squareMicrometers: UnitArea;
        static squareMiles: UnitArea;
        static squareMillimeters: UnitArea;
        static squareNanometers: UnitArea;
        static squareYards: UnitArea;
    }
    class UnitConcentrationMass extends Dimension {
        static millimolesPerLiterWithGramsPerMole(_: number): UnitConcentrationMass;
        static gramsPerLiter: UnitConcentrationMass;
        static milligramsPerDeciliter: UnitConcentrationMass;
    }
    class UnitConverter extends NSObject {
        baseUnitValueFromValue(_: number): number;
        valueFromBaseUnitValue(_: number): number;
    }
    class UnitConverterLinear extends UnitConverter {
        coefficient: number;
        constant: number;
        static createWithCoefficient(coefficient: number): UnitConverterLinear;
        static createWithCoefficientConstant(coefficient: number, constant: number): UnitConverterLinear;
    }
    class UnitDispersion extends Dimension {
        static partsPerMillion: UnitDispersion;
    }
    class UnitDuration extends Dimension {
        static hours: UnitDuration;
        static microseconds: UnitDuration;
        static milliseconds: UnitDuration;
        static minutes: UnitDuration;
        static nanoseconds: UnitDuration;
        static picoseconds: UnitDuration;
        static seconds: UnitDuration;
    }
    class UnitElectricCharge extends Dimension {
        static ampereHours: UnitElectricCharge;
        static coulombs: UnitElectricCharge;
        static kiloampereHours: UnitElectricCharge;
        static megaampereHours: UnitElectricCharge;
        static microampereHours: UnitElectricCharge;
        static milliampereHours: UnitElectricCharge;
    }
    class UnitElectricCurrent extends Dimension {
        static amperes: UnitElectricCurrent;
        static kiloamperes: UnitElectricCurrent;
        static megaamperes: UnitElectricCurrent;
        static microamperes: UnitElectricCurrent;
        static milliamperes: UnitElectricCurrent;
    }
    class UnitElectricPotentialDifference extends Dimension {
        static kilovolts: UnitElectricPotentialDifference;
        static megavolts: UnitElectricPotentialDifference;
        static microvolts: UnitElectricPotentialDifference;
        static millivolts: UnitElectricPotentialDifference;
        static volts: UnitElectricPotentialDifference;
    }
    class UnitElectricResistance extends Dimension {
        static kiloohms: UnitElectricResistance;
        static megaohms: UnitElectricResistance;
        static microohms: UnitElectricResistance;
        static milliohms: UnitElectricResistance;
        static ohms: UnitElectricResistance;
    }
    class UnitEnergy extends Dimension {
        static calories: UnitEnergy;
        static joules: UnitEnergy;
        static kilocalories: UnitEnergy;
        static kilojoules: UnitEnergy;
        static kilowattHours: UnitEnergy;
    }
    class UnitFrequency extends Dimension {
        static framesPerSecond: UnitFrequency;
        static gigahertz: UnitFrequency;
        static hertz: UnitFrequency;
        static kilohertz: UnitFrequency;
        static megahertz: UnitFrequency;
        static microhertz: UnitFrequency;
        static millihertz: UnitFrequency;
        static nanohertz: UnitFrequency;
        static terahertz: UnitFrequency;
    }
    class UnitFuelEfficiency extends Dimension {
        static litersPer100Kilometers: UnitFuelEfficiency;
        static milesPerGallon: UnitFuelEfficiency;
        static milesPerImperialGallon: UnitFuelEfficiency;
    }
    class UnitIlluminance extends Dimension {
        static lux: UnitIlluminance;
    }
    class NSUnitInformationStorage extends Dimension {
        static bits: NSUnitInformationStorage;
        static bytes: NSUnitInformationStorage;
        static exabits: NSUnitInformationStorage;
        static exabytes: NSUnitInformationStorage;
        static exbibits: NSUnitInformationStorage;
        static exbibytes: NSUnitInformationStorage;
        static gibibits: NSUnitInformationStorage;
        static gibibytes: NSUnitInformationStorage;
        static gigabits: NSUnitInformationStorage;
        static gigabytes: NSUnitInformationStorage;
        static kibibits: NSUnitInformationStorage;
        static kibibytes: NSUnitInformationStorage;
        static kilobits: NSUnitInformationStorage;
        static kilobytes: NSUnitInformationStorage;
        static mebibits: NSUnitInformationStorage;
        static mebibytes: NSUnitInformationStorage;
        static megabits: NSUnitInformationStorage;
        static megabytes: NSUnitInformationStorage;
        static nibbles: NSUnitInformationStorage;
        static pebibits: NSUnitInformationStorage;
        static pebibytes: NSUnitInformationStorage;
        static petabits: NSUnitInformationStorage;
        static petabytes: NSUnitInformationStorage;
        static tebibits: NSUnitInformationStorage;
        static tebibytes: NSUnitInformationStorage;
        static terabits: NSUnitInformationStorage;
        static terabytes: NSUnitInformationStorage;
        static yobibits: NSUnitInformationStorage;
        static yobibytes: NSUnitInformationStorage;
        static yottabits: NSUnitInformationStorage;
        static yottabytes: NSUnitInformationStorage;
        static zebibits: NSUnitInformationStorage;
        static zebibytes: NSUnitInformationStorage;
        static zettabits: NSUnitInformationStorage;
        static zettabytes: NSUnitInformationStorage;
    }
    class UnitLength extends Dimension {
        static astronomicalUnits: UnitLength;
        static centimeters: UnitLength;
        static decameters: UnitLength;
        static decimeters: UnitLength;
        static fathoms: UnitLength;
        static feet: UnitLength;
        static furlongs: UnitLength;
        static hectometers: UnitLength;
        static inches: UnitLength;
        static kilometers: UnitLength;
        static lightyears: UnitLength;
        static megameters: UnitLength;
        static meters: UnitLength;
        static micrometers: UnitLength;
        static miles: UnitLength;
        static millimeters: UnitLength;
        static nanometers: UnitLength;
        static nauticalMiles: UnitLength;
        static parsecs: UnitLength;
        static picometers: UnitLength;
        static scandinavianMiles: UnitLength;
        static yards: UnitLength;
    }
    class UnitMass extends Dimension {
        static carats: UnitMass;
        static centigrams: UnitMass;
        static decigrams: UnitMass;
        static grams: UnitMass;
        static kilograms: UnitMass;
        static metricTons: UnitMass;
        static micrograms: UnitMass;
        static milligrams: UnitMass;
        static nanograms: UnitMass;
        static ounces: UnitMass;
        static ouncesTroy: UnitMass;
        static picograms: UnitMass;
        static poundsMass: UnitMass;
        static shortTons: UnitMass;
        static slugs: UnitMass;
        static stones: UnitMass;
    }
    class UnitPower extends Dimension {
        static femtowatts: UnitPower;
        static gigawatts: UnitPower;
        static horsepower: UnitPower;
        static kilowatts: UnitPower;
        static megawatts: UnitPower;
        static microwatts: UnitPower;
        static milliwatts: UnitPower;
        static nanowatts: UnitPower;
        static picowatts: UnitPower;
        static terawatts: UnitPower;
        static watts: UnitPower;
    }
    class UnitPressure extends Dimension {
        static bars: UnitPressure;
        static gigapascals: UnitPressure;
        static hectopascals: UnitPressure;
        static inchesOfMercury: UnitPressure;
        static kilopascals: UnitPressure;
        static megapascals: UnitPressure;
        static millibars: UnitPressure;
        static millimetersOfMercury: UnitPressure;
        static newtonsPerMetersSquared: UnitPressure;
        static poundsForcePerSquareInch: UnitPressure;
    }
    class UnitSpeed extends Dimension {
        static kilometersPerHour: UnitSpeed;
        static knots: UnitSpeed;
        static metersPerSecond: UnitSpeed;
        static milesPerHour: UnitSpeed;
    }
    class UnitTemperature extends Dimension {
        static celsius: UnitTemperature;
        static fahrenheit: UnitTemperature;
        static kelvin: UnitTemperature;
    }
    class UnitVolume extends Dimension {
        static acreFeet: UnitVolume;
        static bushels: UnitVolume;
        static centiliters: UnitVolume;
        static cubicCentimeters: UnitVolume;
        static cubicDecimeters: UnitVolume;
        static cubicFeet: UnitVolume;
        static cubicInches: UnitVolume;
        static cubicKilometers: UnitVolume;
        static cubicMeters: UnitVolume;
        static cubicMiles: UnitVolume;
        static cubicMillimeters: UnitVolume;
        static cubicYards: UnitVolume;
        static cups: UnitVolume;
        static deciliters: UnitVolume;
        static fluidOunces: UnitVolume;
        static gallons: UnitVolume;
        static imperialFluidOunces: UnitVolume;
        static imperialGallons: UnitVolume;
        static imperialPints: UnitVolume;
        static imperialQuarts: UnitVolume;
        static imperialTablespoons: UnitVolume;
        static imperialTeaspoons: UnitVolume;
        static kiloliters: UnitVolume;
        static liters: UnitVolume;
        static megaliters: UnitVolume;
        static metricCups: UnitVolume;
        static milliliters: UnitVolume;
        static pints: UnitVolume;
        static quarts: UnitVolume;
        static tablespoons: UnitVolume;
        static teaspoons: UnitVolume;
    }
    class NSUserActivity extends NSObject {
        activityType: string;
        delegate: NSUserActivityDelegate;
        setDelegate(_: NSUserActivityDelegate): any;
        isEligibleForHandoff: boolean;
        setEligibleForHandoff(_: boolean): any;
        isEligibleForPublicIndexing: boolean;
        setEligibleForPublicIndexing(_: boolean): any;
        isEligibleForSearch: boolean;
        setEligibleForSearch(_: boolean): any;
        expirationDate: Date;
        setExpirationDate(_: Date): any;
        keywords: NSSet<string>;
        setKeywords(_: NSSet<string>): any;
        needsSave: boolean;
        setNeedsSave(_: boolean): any;
        referrerURL: NSURL;
        setReferrerURL(_: NSURL): any;
        requiredUserInfoKeys: NSSet<string>;
        setRequiredUserInfoKeys(_: NSSet<string>): any;
        supportsContinuationStreams: boolean;
        setSupportsContinuationStreams(_: boolean): any;
        targetContentIdentifier: string;
        setTargetContentIdentifier(_: string): any;
        title: string;
        setTitle(_: string): any;
        userInfo: Map<any, any>;
        setUserInfo(_: Map<any, any>): any;
        webpageURL: NSURL;
        setWebpageURL(_: NSURL): any;
        addUserInfoEntriesFromDictionary(from: Map<any, any>): void;
        becomeCurrent(): void;
        getContinuationStreamsWithCompletionHandler(completionHandler?: (p1: InputStream, p2: OutputStream, p3: NSError) => void): void;
        static createWithActivityType(activityType: string): NSUserActivity;
        invalidate(): void;
        resignCurrent(): void;
    }
    interface NSUserActivityDelegate extends NSObject {
        userActivityDidReceiveInputStreamOutputStream?(_: NSUserActivity, didReceive: InputStream, outputStream: OutputStream): void;
        userActivityWasContinued?(_: NSUserActivity): void;
        userActivityWillSave?(_: NSUserActivity): void;
    }
    class NSUserAppleScriptTask extends NSUserScriptTask {
        executeWithWithAppleEventCompletionHandler(withAppleEvent?: NSAppleEventDescriptor, completionHandler?: (p1: NSAppleEventDescriptor, p2: NSError) => void): void;
    }
    class NSUserAutomatorTask extends NSUserScriptTask {
        variables: Map<string, any>;
        setVariables(_: Map<string, any>): any;
        executeWithWithInputCompletionHandler(withInput?: NSSecureCoding, completionHandler?: (p1: any, p2: NSError) => void): void;
    }
    class UserDefaults extends NSObject {
        static resetStandardUserDefaults(): void;
        volatileDomainNames: string[];
        static standardUserDefaults: UserDefaults;
        URLForKey(_: string): NSURL;
        addSuiteNamed(named: string): void;
        arrayForKey(_: string): any[];
        boolForKey(_: string): boolean;
        dataForKey(_: string): NSData;
        dictionaryForKey(_: string): Map<string, any>;
        dictionaryRepresentation(): Map<string, any>;
        doubleForKey(_: string): number;
        floatForKey(_: string): number;
        static createWithSuiteName(suiteName?: string): UserDefaults;
        integerForKey(_: string): number;
        objectForKey(_: string): any;
        objectIsForcedForKey(_: string): boolean;
        objectIsForcedForKeyInDomain(_: string, inDomain: string): boolean;
        persistentDomainForName(_: string): Map<string, any>;
        registerDefaults(defaults: Map<string, any>): void;
        removeObjectForKey(_: string): void;
        removePersistentDomainForName(_: string): void;
        removeSuiteNamed(named: string): void;
        removeVolatileDomainForName(_: string): void;
        setBoolForKey(_: boolean, forKey: string): void;
        setDoubleForKey(_: number, forKey: string): void;
        setFloatForKey(_: number, forKey: string): void;
        setIntegerForKey(_: number, forKey: string): void;
        setObjectForKey(_?: any, forKey?: string): void;
        setPersistentDomainForName(_: Map<string, any>, forName: string): void;
        setURLForKey(_?: NSURL, forKey?: string): void;
        setVolatileDomainForName(_: Map<string, any>, forName: string): void;
        stringArrayForKey(_: string): string[];
        stringForKey(_: string): string;
        synchronize(): boolean;
        volatileDomainForName(_: string): Map<string, any>;
    }
    class NSUserNotification extends NSObject {
        actionButtonTitle: string;
        setActionButtonTitle(_: string): any;
        activationType: NSUserNotification.ActivationType;
        actualDeliveryDate: Date;
        additionalActions: NSUserNotificationAction[];
        setAdditionalActions(_: NSUserNotificationAction[]): any;
        additionalActivationAction: NSUserNotificationAction;
        contentImage: NSImage;
        setContentImage(_: NSImage): any;
        deliveryDate: Date;
        setDeliveryDate(_: Date): any;
        deliveryRepeatInterval: NSDateComponents;
        setDeliveryRepeatInterval(_: NSDateComponents): any;
        deliveryTimeZone: NSTimeZone;
        setDeliveryTimeZone(_: NSTimeZone): any;
        hasActionButton: boolean;
        setHasActionButton(_: boolean): any;
        hasReplyButton: boolean;
        setHasReplyButton(_: boolean): any;
        identifier: string;
        setIdentifier(_: string): any;
        informativeText: string;
        setInformativeText(_: string): any;
        otherButtonTitle: string;
        setOtherButtonTitle(_: string): any;
        isPresented: boolean;
        isRemote: boolean;
        response: NSAttributedString;
        responsePlaceholder: string;
        setResponsePlaceholder(_: string): any;
        soundName: string;
        setSoundName(_: string): any;
        subtitle: string;
        setSubtitle(_: string): any;
        title: string;
        setTitle(_: string): any;
        userInfo: Map<string, any>;
        setUserInfo(_: Map<string, any>): any;
    }
    class NSUserNotificationAction extends NSObject {
        static actionWithIdentifierTitle(identifier?: string, title?: string): NSUserNotificationAction;
        identifier: string;
        title: string;
    }
    class NSUserNotificationCenter extends NSObject {
        delegate: NSUserNotificationCenterDelegate;
        setDelegate(_: NSUserNotificationCenterDelegate): any;
        deliveredNotifications: NSUserNotification[];
        scheduledNotifications: NSUserNotification[];
        setScheduledNotifications(_: NSUserNotification[]): any;
        static defaultUserNotificationCenter: NSUserNotificationCenter;
        deliverNotification(_: NSUserNotification): void;
        removeAllDeliveredNotifications(): void;
        removeDeliveredNotification(_: NSUserNotification): void;
        removeScheduledNotification(_: NSUserNotification): void;
        scheduleNotification(_: NSUserNotification): void;
    }
    interface NSUserNotificationCenterDelegate extends NSObject {
        userNotificationCenterDidDeliverNotification?(_: NSUserNotificationCenter, didDeliver: NSUserNotification): void;
        userNotificationCenterDidActivateNotification?(_: NSUserNotificationCenter, didActivate: NSUserNotification): void;
        userNotificationCenterShouldPresentNotification?(_: NSUserNotificationCenter, shouldPresent: NSUserNotification): boolean;
    }
    class NSUserScriptTask extends NSObject {
        scriptURL: NSURL;
        executeWithCompletionHandler(completionHandler?: (p1: NSError) => void): void;
        static createWithUrl(URL: NSURL): NSUserScriptTask;
    }
    class NSUserUnixTask extends NSUserScriptTask {
        standardError: FileHandle;
        setStandardError(_: FileHandle): any;
        standardInput: FileHandle;
        setStandardInput(_: FileHandle): any;
        standardOutput: FileHandle;
        setStandardOutput(_: FileHandle): any;
        executeWithWithArgumentsCompletionHandler(withArguments?: string[], completionHandler?: (p1: NSError) => void): void;
    }
    class NSValue extends NSObject {
        edgeInsetsValue: NSEdgeInsets;
        nonretainedObjectValue: any;
        objCType: string;
        pointValue: CGPoint;
        pointerValue: any;
        rangeValue: NSRange;
        rectValue: CGRect;
        sizeValue: CGSize;
        getValue(_: any): void;
        getValueSize(_: any, size: number): void;
        static createWithBytesObjCType(bytes: any, objCType: string): NSValue;
        isEqualToValue(to: NSValue): boolean;
    }
    class ValueTransformer extends NSObject {
        static allowsReverseTransformation(): boolean;
        static setValueTransformerForName(_?: ValueTransformer, forName?: string): void;
        static transformedValueClass(): typeof NSObject;
        static valueTransformerNames(): string[];
        reverseTransformedValue(_?: any): any;
        transformedValue(_?: any): any;
    }
    class NSWhoseSpecifier extends NSScriptObjectSpecifier {
        endSubelementIdentifier: NSWhoseSpecifier.SubelementIdentifier;
        setEndSubelementIdentifier(_: NSWhoseSpecifier.SubelementIdentifier): any;
        endSubelementIndex: number;
        setEndSubelementIndex(_: number): any;
        startSubelementIdentifier: NSWhoseSpecifier.SubelementIdentifier;
        setStartSubelementIdentifier(_: NSWhoseSpecifier.SubelementIdentifier): any;
        startSubelementIndex: number;
        setStartSubelementIndex(_: number): any;
        test: NSScriptWhoseTest;
        setTest(_: NSScriptWhoseTest): any;
        static createWithContainerClassDescriptionContainerSpecifierKeyTest(containerClassDescription: NSScriptClassDescription, containerSpecifier?: NSScriptObjectSpecifier, key?: string, test?: NSScriptWhoseTest): NSWhoseSpecifier;
    }
    class XMLDTD extends XMLNode {
        static predefinedEntityDeclarationForName(_: string): XMLDTDNode;
        publicID: string;
        setPublicID(_: string): any;
        systemID: string;
        setSystemID(_: string): any;
        addChild(_: XMLNode): void;
        attributeDeclarationForNameElementName(_: string, elementName: string): XMLDTDNode;
        elementDeclarationForName(_: string): XMLDTDNode;
        entityDeclarationForName(_: string): XMLDTDNode;
        static createWithContentsOfURLOptions(contentsOfURL: NSURL, options: XMLNode.Options): XMLDTD;
        static createWithDataOptions(data: NSData, options: XMLNode.Options): XMLDTD;
        insertChildAtIndex(_: XMLNode, atIndex: number): void;
        insertChildrenAtIndex(_: XMLNode[], atIndex: number): void;
        notationDeclarationForName(_: string): XMLDTDNode;
        removeChildAtIndex(_: number): void;
        replaceChildAtIndexWithNode(_: number, withNode: XMLNode): void;
        setChildren(_?: XMLNode[]): void;
    }
    class XMLDTDNode extends XMLNode {
        DTDKind: XMLDTDNode.DTDKind;
        setDTDKind(_: XMLDTDNode.DTDKind): any;
        isExternal: boolean;
        notationName: string;
        setNotationName(_: string): any;
        publicID: string;
        setPublicID(_: string): any;
        systemID: string;
        setSystemID(_: string): any;
        static createWithXMLString(XMLString: string): XMLDTDNode;
    }
    class XMLDocument extends XMLNode {
        static replacementClassForClass(_: typeof NSObject): typeof NSObject;
        DTD: XMLDTD;
        setDTD(_: XMLDTD): any;
        MIMEType: string;
        setMIMEType(_: string): any;
        XMLData: NSData;
        characterEncoding: string;
        setCharacterEncoding(_: string): any;
        documentContentKind: XMLDocument.ContentKind;
        setDocumentContentKind(_: XMLDocument.ContentKind): any;
        isStandalone: boolean;
        setStandalone(_: boolean): any;
        XMLDataWithOptions(_: XMLNode.Options): NSData;
        addChild(_: XMLNode): void;
        static createWithContentsOfURLOptions(contentsOfURL: NSURL, options: XMLNode.Options): XMLDocument;
        static createWithDataOptions(data: NSData, options: XMLNode.Options): XMLDocument;
        static createWithRootElement(rootElement?: XMLElement): XMLDocument;
        static createWithXMLStringOptions(XMLString: string, options: XMLNode.Options): XMLDocument;
        insertChildAtIndex(_: XMLNode, atIndex: number): void;
        insertChildrenAtIndex(_: XMLNode[], atIndex: number): void;
        objectByApplyingXSLTArgumentsError(arguments_: NSData, error?: Map<string, string>): any;
        objectByApplyingXSLTAtURLArgumentsError(arguments_: NSURL, error?: Map<string, string>): any;
        objectByApplyingXSLTStringArgumentsError(arguments_: string, error?: Map<string, string>): any;
        removeChildAtIndex(_: number): void;
        replaceChildAtIndexWithNode(_: number, withNode: XMLNode): void;
        rootElement(): XMLElement;
        setChildren(_?: XMLNode[]): void;
        setRootElement(_: XMLElement): void;
        validateAndReturnError(): boolean;
    }
    class XMLElement extends XMLNode {
        attributes: XMLNode[];
        setAttributes(_: XMLNode[]): any;
        namespaces: XMLNode[];
        setNamespaces(_: XMLNode[]): any;
        addAttribute(_: XMLNode): void;
        addChild(_: XMLNode): void;
        addNamespace(_: XMLNode): void;
        attributeForLocalNameUri(_: string, URI?: string): XMLNode;
        attributeForName(_: string): XMLNode;
        elementsForLocalNameUri(_: string, URI?: string): XMLElement[];
        elementsForName(_: string): XMLElement[];
        static createWithName(name: string): XMLElement;
        static createWithNameUri(name: string, URI?: string): XMLElement;
        static createWithNameStringValue(name: string, stringValue?: string): XMLElement;
        static createWithXMLString(XMLString: string): XMLElement;
        insertChildAtIndex(_: XMLNode, atIndex: number): void;
        insertChildrenAtIndex(_: XMLNode[], atIndex: number): void;
        namespaceForPrefix(_: string): XMLNode;
        normalizeAdjacentTextNodesPreservingCDATA(_: boolean): void;
        removeAttributeForName(_: string): void;
        removeChildAtIndex(_: number): void;
        removeNamespaceForPrefix(_: string): void;
        replaceChildAtIndexWithNode(_: number, withNode: XMLNode): void;
        resolveNamespaceForName(_: string): XMLNode;
        resolvePrefixForNamespaceURI(_: string): string;
        setAttributesAsDictionary(_: Map<any, any>): void;
        setAttributesWithDictionary(_: Map<string, string>): void;
        setChildren(_?: XMLNode[]): void;
    }
    class XMLNode extends NSObject {
        static DTDNodeWithXMLString(_: string): any;
        static attributeWithNameUriStringValue(_: string, URI: string, stringValue: string): any;
        static attributeWithNameStringValue(_: string, stringValue: string): any;
        static commentWithStringValue(_: string): any;
        static document(): any;
        static documentWithRootElement(_: XMLElement): any;
        static elementWithName(_: string): any;
        static elementWithNameUri(_: string, URI: string): any;
        static elementWithNameChildrenAttributes(_: string, children?: XMLNode[], attributes?: XMLNode[]): any;
        static elementWithNameStringValue(_: string, stringValue: string): any;
        static localNameForName(_: string): string;
        static namespaceWithNameStringValue(_: string, stringValue: string): any;
        static predefinedNamespaceForPrefix(_: string): XMLNode;
        static prefixForName(_: string): string;
        static processingInstructionWithNameStringValue(_: string, stringValue: string): any;
        static textWithStringValue(_: string): any;
        URI: string;
        setURI(_: string): any;
        XMLString: string;
        XPath: string;
        childCount: number;
        children: XMLNode[];
        index: number;
        kind: XMLNode.Kind;
        level: number;
        localName: string;
        name: string;
        setName(_: string): any;
        nextNode: XMLNode;
        nextSibling: XMLNode;
        objectValue: any;
        setObjectValue(_: any): any;
        parent: XMLNode;
        prefix: string;
        previousNode: XMLNode;
        previousSibling: XMLNode;
        rootDocument: XMLDocument;
        stringValue: string;
        setStringValue(_: string): any;
        XMLStringWithOptions(_: XMLNode.Options): string;
        canonicalXMLStringPreservingComments(_: boolean): string;
        childAtIndex(_: number): XMLNode;
        detach(): void;
        static createWithKind(kind: XMLNode.Kind): XMLNode;
        static createWithKindOptions(kind: XMLNode.Kind, options: XMLNode.Options): XMLNode;
        nodesForXPathError(error: string): XMLNode[];
        objectsForXQueryConstantsError(constants: string, error?: Map<string, any>): any[];
        objectsForXQueryError(error: string): any[];
        setStringValueResolvingEntities(_: string, resolvingEntities: boolean): void;
    }
    class XMLParser extends NSObject {
        allowedExternalEntityURLs: NSSet<NSURL>;
        setAllowedExternalEntityURLs(_: NSSet<NSURL>): any;
        columnNumber: number;
        delegate: XMLParserDelegate;
        setDelegate(_: XMLParserDelegate): any;
        externalEntityResolvingPolicy: XMLParser.ExternalEntityResolvingPolicy;
        setExternalEntityResolvingPolicy(_: XMLParser.ExternalEntityResolvingPolicy): any;
        lineNumber: number;
        parserError: NSError;
        publicID: string;
        shouldProcessNamespaces: boolean;
        setShouldProcessNamespaces(_: boolean): any;
        shouldReportNamespacePrefixes: boolean;
        setShouldReportNamespacePrefixes(_: boolean): any;
        shouldResolveExternalEntities: boolean;
        setShouldResolveExternalEntities(_: boolean): any;
        systemID: string;
        abortParsing(): void;
        static createWithContentsOfURL(contentsOfURL: NSURL): XMLParser;
        static createWithData(data: NSData): XMLParser;
        static createWithStream(stream: InputStream): XMLParser;
        parse(): boolean;
    }
    interface XMLParserDelegate extends NSObject {
        parserDidEndElementNamespaceURIQualifiedName?(_: XMLParser, didEndElement: string, namespaceURI?: string, qualifiedName?: string): void;
        parserDidEndMappingPrefix?(_: XMLParser, didEndMappingPrefix: string): void;
        parserDidStartElementNamespaceURIQualifiedNameAttributes?(_: XMLParser, didStartElement: string, namespaceURI?: string, qualifiedName?: string, attributes?: Map<string, string>): void;
        parserDidStartMappingPrefixToURI?(_: XMLParser, didStartMappingPrefix: string, toURI: string): void;
        parserFoundAttributeDeclarationWithNameForElementTypeDefaultValue?(_: XMLParser, foundAttributeDeclarationWithName: string, forElement: string, type?: string, defaultValue?: string): void;
        parserFoundCDATA?(_: XMLParser, foundCDATA: NSData): void;
        parserFoundCharacters?(_: XMLParser, foundCharacters: string): void;
        parserFoundComment?(_: XMLParser, foundComment: string): void;
        parserFoundElementDeclarationWithNameModel?(_: XMLParser, foundElementDeclarationWithName: string, model: string): void;
        parserFoundExternalEntityDeclarationWithNamePublicIDSystemID?(_: XMLParser, foundExternalEntityDeclarationWithName: string, publicID?: string, systemID?: string): void;
        parserFoundIgnorableWhitespace?(_: XMLParser, foundIgnorableWhitespace: string): void;
        parserFoundInternalEntityDeclarationWithNameValue?(_: XMLParser, foundInternalEntityDeclarationWithName: string, value?: string): void;
        parserFoundNotationDeclarationWithNamePublicIDSystemID?(_: XMLParser, foundNotationDeclarationWithName: string, publicID?: string, systemID?: string): void;
        parserFoundProcessingInstructionWithTargetData?(_: XMLParser, foundProcessingInstructionWithTarget: string, data?: string): void;
        parserFoundUnparsedEntityDeclarationWithNamePublicIDSystemIDNotationName?(_: XMLParser, foundUnparsedEntityDeclarationWithName: string, publicID?: string, systemID?: string, notationName?: string): void;
        parserParseErrorOccurred?(_: XMLParser, parseErrorOccurred: NSError): void;
        parserResolveExternalEntityNameSystemID?(_: XMLParser, resolveExternalEntityName: string, systemID?: string): NSData;
        parserValidationErrorOccurred?(_: XMLParser, validationErrorOccurred: NSError): void;
        parserDidEndDocument?(_: XMLParser): void;
        parserDidStartDocument?(_: XMLParser): void;
    }
    class NSXPCCoder extends NSCoder {
        connection: NSXPCConnection;
        userInfo: NSObject;
        setUserInfo(_: NSObject): any;
        decodeXPCObjectOfTypeForKey(ofType: any, forKey: string): NSObject;
        encodeXPCObjectForKey(_: NSObject, forKey: string): void;
    }
    class NSXPCConnection extends NSObject {
        static currentConnection(): NSXPCConnection;
        auditSessionIdentifier: number;
        effectiveGroupIdentifier: number;
        effectiveUserIdentifier: number;
        endpoint: NSXPCListenerEndpoint;
        exportedInterface: NSXPCInterface;
        setExportedInterface(_: NSXPCInterface): any;
        exportedObject: any;
        setExportedObject(_: any): any;
        interruptionHandler: () => void;
        setInterruptionHandler(_: () => void): any;
        invalidationHandler: () => void;
        setInvalidationHandler(_: () => void): any;
        processIdentifier: number;
        remoteObjectInterface: NSXPCInterface;
        setRemoteObjectInterface(_: NSXPCInterface): any;
        remoteObjectProxy: any;
        serviceName: string;
        static createWithListenerEndpoint(listenerEndpoint: NSXPCListenerEndpoint): NSXPCConnection;
        static createWithMachServiceNameOptions(machServiceName: string, options: NSXPCConnection.Options): NSXPCConnection;
        static createWithServiceName(serviceName: string): NSXPCConnection;
        invalidate(): void;
        resume(): void;
        scheduleSendBarrierBlock(_: () => void): void;
        suspend(): void;
    }
    class NSXPCInterface extends NSObject {
        static interfaceWithProtocol(with_: any): NSXPCInterface;
        protocol: any;
        setProtocol(_: any): any;
        XPCTypeForSelectorArgumentIndexOfReply(for_: string, argumentIndex: number, ofReply: boolean): any;
        classesForSelectorArgumentIndexOfReply(for_: string, argumentIndex: number, ofReply: boolean): NSSet<typeof NSObject>;
        interfaceForSelectorArgumentIndexOfReply(_: string, argumentIndex: number, ofReply: boolean): NSXPCInterface;
        setClassesForArgumentIndexOfReply(_: NSSet<typeof NSObject>, for_: string, argumentIndex: number, ofReply: boolean): void;
        setInterfaceForSelectorArgumentIndexOfReply(_: NSXPCInterface, for_: string, argumentIndex: number, ofReply: boolean): void;
        setXPCTypeForSelectorArgumentIndexOfReply(_: any, for_: string, argumentIndex: number, ofReply: boolean): void;
    }
    class NSXPCListener extends NSObject {
        static anonymousListener(): NSXPCListener;
        static serviceListener(): NSXPCListener;
        delegate: NSXPCListenerDelegate;
        setDelegate(_: NSXPCListenerDelegate): any;
        endpoint: NSXPCListenerEndpoint;
        static createWithMachServiceName(machServiceName: string): NSXPCListener;
        invalidate(): void;
        resume(): void;
        suspend(): void;
    }
    interface NSXPCListenerDelegate extends NSObject {
        listenerShouldAcceptNewConnection?(_: NSXPCListener, shouldAcceptNewConnection: NSXPCConnection): boolean;
    }
    class NSXPCListenerEndpoint extends NSObject {
    }
    interface NSXPCProxyCreating {
        remoteObjectProxy: any;
        remoteObjectProxyWithErrorHandler(_: (p1: NSError) => void): any;
        synchronousRemoteObjectProxyWithErrorHandler?(_: (p1: NSError) => void): any;
    }
    interface __ssFlags {
        delegateLearnsWords: number;
        delegateForgetsWords: number;
        busy: number;
    }
    namespace AE {
        enum AEDataModel {
        }
    }
    namespace Bundle {
    }
    namespace ByteCountFormatter {
        enum CountStyle {
            File = 0,
            Memory = 1,
            Decimal = 2,
            Binary = 3
        }
        enum Units {
            UseDefault = 0,
            UseBytes = 1,
            UseKB = 2,
            UseMB = 4,
            UseGB = 8,
            UseTB = 16,
            UsePB = 32,
            UseEB = 64,
            UseZB = 128,
            UseYBOrHigher = 65280,
            UseAll = 65535
        }
    }
    namespace CFCalendarIdentifier {
    }
    namespace CFDateFormatterKey {
    }
    namespace CFLocaleKey {
    }
    namespace CFNotificationName {
    }
    namespace CFNumberFormatterKey {
    }
    namespace CFRunLoopMode {
    }
    namespace CFStreamPropertyKey {
    }
    namespace DateComponentsFormatter {
        enum UnitsStyle {
            Positional = 0,
            Abbreviated = 1,
            Short = 2,
            Full = 3,
            SpellOut = 4,
            Brief = 5
        }
        enum ZeroFormattingBehavior {
            None = 0,
            Default = 1,
            DropLeading = 2,
            DropMiddle = 4,
            DropTrailing = 8,
            DropAll = 14,
            Pad = 65536
        }
    }
    namespace DateFormatter {
        enum Behavior {
            BehaviorDefault = 0,
            Behavior10_0 = 1000,
            Behavior10_4 = 1040
        }
        enum Style {
            NoStyle = 0,
            ShortStyle = 1,
            MediumStyle = 2,
            LongStyle = 3,
            FullStyle = 4
        }
    }
    namespace DateIntervalFormatter {
        enum Style {
            NoStyle = 0,
            ShortStyle = 1,
            MediumStyle = 2,
            LongStyle = 3,
            FullStyle = 4
        }
    }
    namespace DistributedNotificationCenter {
        enum Options {
            DeliverImmediately = 1,
            PostToAllSessions = 2
        }
        enum SuspensionBehavior {
            Drop = 1,
            Coalesce = 2,
            Hold = 3,
            DeliverImmediately = 4
        }
    }
    namespace EnergyFormatter {
        enum Unit {
            Joule = 11,
            Kilojoule = 14,
            Calorie = 1793,
            Kilocalorie = 1794
        }
    }
    namespace FileAttributeKey {
    }
    namespace FileAttributeType {
    }
    namespace FileHandle {
    }
    namespace FileManager {
        enum DirectoryEnumerationOptions {
            SkipsSubdirectoryDescendants = 1,
            SkipsPackageDescendants = 2,
            SkipsHiddenFiles = 4,
            IncludesDirectoriesPostOrder = 8,
            ProducesRelativePathURLs = 16
        }
        enum ItemReplacementOptions {
            UsingNewMetadataOnly = 1,
            WithoutDeletingBackupItem = 2
        }
        enum UnmountOptions {
            AllPartitionsAndEjectDisk = 1,
            WithoutUI = 2
        }
        enum SearchPathDirectory {
            ApplicationDirectory = 1,
            DemoApplicationDirectory = 2,
            DeveloperApplicationDirectory = 3,
            AdminApplicationDirectory = 4,
            LibraryDirectory = 5,
            DeveloperDirectory = 6,
            UserDirectory = 7,
            DocumentationDirectory = 8,
            DocumentDirectory = 9,
            CoreServiceDirectory = 10,
            AutosavedInformationDirectory = 11,
            DesktopDirectory = 12,
            CachesDirectory = 13,
            ApplicationSupportDirectory = 14,
            DownloadsDirectory = 15,
            InputMethodsDirectory = 16,
            MoviesDirectory = 17,
            MusicDirectory = 18,
            PicturesDirectory = 19,
            PrinterDescriptionDirectory = 20,
            SharedPublicDirectory = 21,
            PreferencePanesDirectory = 22,
            ApplicationScriptsDirectory = 23,
            ItemReplacementDirectory = 99,
            AllApplicationsDirectory = 100,
            AllLibrariesDirectory = 101,
            TrashDirectory = 102
        }
        enum SearchPathDomainMask {
            UserDomainMask = 1,
            LocalDomainMask = 2,
            NetworkDomainMask = 4,
            SystemDomainMask = 8,
            AllDomainsMask = 65535
        }
        enum URLRelationship {
            Contains = 0,
            Same = 1,
            Other = 2
        }
        enum VolumeEnumerationOptions {
            SkipHiddenVolumes = 2,
            ProduceFileReferenceURLs = 4
        }
    }
    namespace FileProtectionType {
    }
    namespace FileWrapper {
        enum ReadingOptions {
            Immediate = 1,
            WithoutMapping = 2
        }
        enum WritingOptions {
            Atomic = 1,
            WithNameUpdating = 2
        }
    }
    namespace Formatter {
        enum Context {
            Unknown = 0,
            Dynamic = 1,
            Standalone = 2,
            ListItem = 3,
            BeginningOfSentence = 4,
            MiddleOfSentence = 5
        }
        enum UnitStyle {
            Short = 1,
            Medium = 2,
            Long = 3
        }
    }
    namespace HTTPCookie {
        enum AcceptPolicy {
            Always = 0,
            Never = 1,
            OnlyFromMainDocumentDomain = 2
        }
    }
    namespace HTTPCookiePropertyKey {
    }
    namespace HTTPCookieStringPolicy {
    }
    namespace ISO8601DateFormatter {
        enum Options {
            WithYear = 1,
            WithMonth = 2,
            WithWeekOfYear = 4,
            WithDay = 16,
            WithTime = 32,
            WithTimeZone = 64,
            WithSpaceBetweenDateAndTime = 128,
            WithDashSeparatorInDate = 256,
            WithColonSeparatorInTime = 512,
            WithColonSeparatorInTimeZone = 1024,
            WithFractionalSeconds = 2048,
            WithFullDate = 275,
            WithFullTime = 1632,
            WithInternetDateTime = 1907
        }
    }
    namespace JSONSerialization {
        enum ReadingOptions {
            MutableContainers = 1,
            MutableLeaves = 2,
            FragmentsAllowed = 4,
            AllowFragments = 4
        }
        enum WritingOptions {
            PrettyPrinted = 1,
            SortedKeys = 2,
            FragmentsAllowed = 4,
            WithoutEscapingSlashes = 8
        }
    }
    namespace LengthFormatter {
        enum Unit {
            Millimeter = 8,
            Centimeter = 9,
            Meter = 11,
            Kilometer = 14,
            Inch = 1281,
            Foot = 1282,
            Yard = 1283,
            Mile = 1284
        }
    }
    namespace MassFormatter {
        enum Unit {
            Gram = 11,
            Kilogram = 14,
            Ounce = 1537,
            Pound = 1538,
            Stone = 1539
        }
    }
    namespace MeasurementFormatter {
        enum UnitOptions {
            ProvidedUnit = 1,
            NaturalScale = 2,
            TemperatureWithoutUnit = 4
        }
    }
    namespace NSAccessibility {
        enum AnnotationPosition {
            FullRange = 0,
            Start = 1,
            End = 2
        }
        enum Orientation {
            Unknown = 0,
            Vertical = 1,
            Horizontal = 2
        }
        enum RulerMarkerType {
            Unknown = 0,
            TabStopLeft = 1,
            TabStopRight = 2,
            TabStopCenter = 3,
            TabStopDecimal = 4,
            IndentHead = 5,
            IndentTail = 6,
            IndentFirstLine = 7
        }
        enum SortDirection {
            Unknown = 0,
            Ascending = 1,
            Descending = 2
        }
        enum Units {
            Unknown = 0,
            Inches = 1,
            Centimeters = 2,
            Points = 3,
            Picas = 4
        }
    }
    namespace NSAccessibilityCustomRotor {
        enum SearchDirection {
            Previous = 0,
            Next = 1
        }
        enum RotorType {
            Custom = 0,
            Any = 1,
            Annotation = 2,
            BoldText = 3,
            Heading = 4,
            HeadingLevel1 = 5,
            HeadingLevel2 = 6,
            HeadingLevel3 = 7,
            HeadingLevel4 = 8,
            HeadingLevel5 = 9,
            HeadingLevel6 = 10,
            Image = 11,
            ItalicText = 12,
            Landmark = 13,
            Link = 14,
            List = 15,
            MisspelledWord = 16,
            Table = 17,
            TextField = 18,
            UnderlinedText = 19,
            VisitedLink = 20
        }
    }
    namespace NSAlert {
        enum Style {
            Warning = 0,
            Informational = 1,
            Critical = 2
        }
    }
    namespace NSAnimation {
        enum BlockingMode {
            Blocking = 0,
            Nonblocking = 1,
            NonblockingThreaded = 2
        }
        enum Curve {
            EaseInOut = 0,
            EaseIn = 1,
            EaseOut = 2,
            Linear = 3
        }
    }
    namespace NSAppKitVersion {
    }
    namespace NSAppearance {
    }
    namespace NSAppleEventDescriptor {
        enum SendOptions {
            NoReply = 1,
            QueueReply = 2,
            WaitForReply = 3,
            NeverInteract = 16,
            CanInteract = 32,
            AlwaysInteract = 48,
            CanSwitchLayer = 64,
            DontRecord = 4096,
            DontExecute = 8192,
            DontAnnotate = 65536,
            DefaultOptions = 35
        }
    }
    namespace NSAppleEventManager {
    }
    namespace NSAppleScript {
    }
    namespace NSApplication {
        enum ActivationOptions {
            ActivateAllWindows = 1,
            ActivateIgnoringOtherApps = 2
        }
        enum ActivationPolicy {
            Regular = 0,
            Accessory = 1,
            Prohibited = 2
        }
        enum DelegateReply {
            Success = 0,
            Cancel = 1,
            Failure = 2
        }
        enum OcclusionState {
            Visible = 2
        }
        enum PresentationOptions {
            Default = 0,
            AutoHideDock = 1,
            HideDock = 2,
            AutoHideMenuBar = 4,
            HideMenuBar = 8,
            DisableAppleMenu = 16,
            DisableProcessSwitching = 32,
            DisableForceQuit = 64,
            DisableSessionTermination = 128,
            DisableHideApplication = 256,
            DisableMenuBarTransparency = 512,
            FullScreen = 1024,
            AutoHideToolbar = 2048,
            DisableCursorLocationAssistance = 4096
        }
        enum PrintReply {
            PrintingCancelled = 0,
            PrintingSuccess = 1,
            PrintingFailure = 3,
            PrintingReplyLater = 2
        }
        enum TerminateReply {
            TerminateCancel = 0,
            TerminateNow = 1,
            TerminateLater = 2
        }
        enum RemoteNotificationType {
            None = 0,
            Badge = 1,
            Sound = 2,
            Alert = 4
        }
        enum RequestUserAttentionType {
            CriticalRequest = 0,
            InformationalRequest = 10
        }
        enum WindowListOptions {
            OrderedFrontToBack = 1
        }
    }
    namespace NSArray {
    }
    namespace NSAttributedString {
        enum SpellingState {
            SpellingFlag = 1,
            GrammarFlag = 2
        }
        enum EnumerationOptions {
            Reverse = 2,
            LongestEffectiveRangeNotRequired = 1048576
        }
    }
    namespace NSBackgroundActivityScheduler {
        enum Result {
            Finished = 1,
            Deferred = 2
        }
    }
    namespace NSBezierPath {
        enum ElementType {
            MoveTo = 0,
            LineTo = 1,
            CurveTo = 2,
            ClosePath = 3
        }
        enum LineCapStyle {
            Butt = 0,
            Round = 1,
            Square = 2
        }
        enum LineJoinStyle {
            Miter = 0,
            Round = 1,
            Bevel = 2
        }
        enum WindingRule {
            NonZero = 0,
            EvenOdd = 1
        }
    }
    namespace NSBindingInfoKey {
    }
    namespace NSBindingName {
    }
    namespace NSBindingOption {
    }
    namespace NSBitmapImageRep {
        enum Format {
            AlphaFirst = 1,
            AlphaNonpremultiplied = 2,
            FloatingPointSamples = 4,
            SixteenBitLittleEndian = 256,
            ThirtyTwoBitLittleEndian = 512,
            SixteenBitBigEndian = 1024,
            ThirtyTwoBitBigEndian = 2048
        }
        enum FileType {
            TIFF = 0,
            BMP = 1,
            GIF = 2,
            JPEG = 3,
            PNG = 4,
            JPEG2000 = 5
        }
        enum LoadStatus {
            UnknownType = -1,
            ReadingHeader = -2,
            WillNeedAllData = -3,
            InvalidData = -4,
            UnexpectedEOF = -5,
            Completed = -6
        }
        enum TIFFCompression {
            None = 1,
            CCITTFAX3 = 3,
            CCITTFAX4 = 4,
            LZW = 5,
            JPEG = 6,
            NEXT = 32766,
            PackBits = 32773,
            OldJPEG = 32865
        }
    }
    namespace NSBox {
        enum BoxType {
            Primary = 0,
            Separator = 2,
            Custom = 4
        }
        enum TitlePosition {
            NoTitle = 0,
            AboveTop = 1,
            AtTop = 2,
            BelowTop = 3,
            AboveBottom = 4,
            AtBottom = 5,
            BelowBottom = 6
        }
    }
    namespace NSBrowser {
        enum ColumnResizingType {
            NoColumnResizing = 0,
            AutoColumnResizing = 1,
            UserColumnResizing = 2
        }
        enum DropOperation {
            On = 0,
            Above = 1
        }
    }
    namespace NSButton {
        enum BezelStyle {
            Rounded = 1,
            RegularSquare = 2,
            Disclosure = 5,
            ShadowlessSquare = 6,
            Circular = 7,
            TexturedSquare = 8,
            HelpButton = 9,
            SmallSquare = 10,
            TexturedRounded = 11,
            RoundRect = 12,
            Recessed = 13,
            RoundedDisclosure = 14,
            Inline = 15
        }
        enum ButtonType {
            MomentaryLight = 0,
            PushOnPushOff = 1,
            Toggle = 2,
            Switch = 3,
            Radio = 4,
            MomentaryChange = 5,
            OnOff = 6,
            MomentaryPushIn = 7,
            Accelerator = 8,
            MultiLevelAccelerator = 9
        }
    }
    namespace NSCalendar {
        enum Options {
            WrapComponents = 1,
            MatchStrictly = 2,
            SearchBackwards = 4,
            MatchPreviousTimePreservingSmallerUnits = 256,
            MatchNextTimePreservingSmallerUnits = 512,
            MatchNextTime = 1024,
            MatchFirst = 4096,
            MatchLast = 8192
        }
        enum Unit {
            CalendarUnitEra = 2,
            CalendarUnitYear = 4,
            CalendarUnitMonth = 8,
            CalendarUnitDay = 16,
            CalendarUnitHour = 32,
            CalendarUnitMinute = 64,
            CalendarUnitSecond = 128,
            CalendarUnitWeekday = 512,
            CalendarUnitWeekdayOrdinal = 1024,
            CalendarUnitQuarter = 2048,
            CalendarUnitWeekOfMonth = 4096,
            CalendarUnitWeekOfYear = 8192,
            CalendarUnitYearForWeekOfYear = 16384,
            CalendarUnitNanosecond = 32768,
            CalendarUnitCalendar = 1048576,
            CalendarUnitTimeZone = 2097152,
            EraCalendarUnit = 2,
            YearCalendarUnit = 4,
            MonthCalendarUnit = 8,
            DayCalendarUnit = 16,
            HourCalendarUnit = 32,
            MinuteCalendarUnit = 64,
            SecondCalendarUnit = 128,
            WeekCalendarUnit = 256,
            WeekdayCalendarUnit = 512,
            WeekdayOrdinalCalendarUnit = 1024,
            QuarterCalendarUnit = 2048,
            WeekOfMonthCalendarUnit = 4096,
            WeekOfYearCalendarUnit = 8192,
            YearForWeekOfYearCalendarUnit = 16384,
            CalendarCalendarUnit = 1048576,
            TimeZoneCalendarUnit = 2097152
        }
    }
    namespace NSCell {
        enum Attribute {
            CellDisabled = 0,
            CellState = 1,
            PushInCell = 2,
            CellEditable = 3,
            ChangeGrayCell = 4,
            CellHighlighted = 5,
            CellLightsByContents = 6,
            CellLightsByGray = 7,
            ChangeBackgroundCell = 8,
            CellLightsByBackground = 9,
            CellIsBordered = 10,
            CellHasOverlappingImage = 11,
            CellHasImageHorizontal = 12,
            CellHasImageOnLeftOrBottom = 13,
            CellChangesContents = 14,
            CellIsInsetButton = 15,
            CellAllowsMixedState = 16
        }
        enum HitResult {
            None = 0,
            ContentArea = 1,
            EditableTextArea = 2,
            TrackableArea = 4
        }
        enum StyleMask {
            NoCellMask = 0,
            ContentsCellMask = 1,
            PushInCellMask = 2,
            ChangeGrayCellMask = 4,
            ChangeBackgroundCellMask = 8
        }
        enum CellType {
            NullCellType = 0,
            TextCellType = 1,
            ImageCellType = 2
        }
    }
    namespace NSCoder {
        enum DecodingFailurePolicy {
            RaiseException = 0,
            SetErrorAndReturn = 1
        }
    }
    namespace NSCollectionView {
        enum UpdateAction {
            Insert = 0,
            Delete = 1,
            Reload = 2,
            Move = 3,
            None = 4
        }
        enum DropOperation {
            On = 0,
            Before = 1
        }
        enum ScrollDirection {
            Vertical = 0,
            Horizontal = 1
        }
        enum ScrollPosition {
            None = 0,
            Top = 1,
            CenteredVertically = 2,
            Bottom = 4,
            NearestHorizontalEdge = 512,
            Left = 8,
            CenteredHorizontally = 16,
            Right = 32,
            LeadingEdge = 64,
            TrailingEdge = 128,
            NearestVerticalEdge = 256
        }
    }
    namespace NSCollectionViewItem {
        enum HighlightState {
            None = 0,
            ForSelection = 1,
            ForDeselection = 2,
            AsDropTarget = 3
        }
    }
    namespace NSCollectionViewTransitionLayout {
    }
    namespace NSColor {
        enum SystemEffect {
            None = 0,
            Pressed = 1,
            DeepPressed = 2,
            Disabled = 3,
            Rollover = 4
        }
        enum ColorType {
            ComponentBased = 0,
            Pattern = 1,
            Catalog = 2
        }
    }
    namespace NSColorList {
    }
    namespace NSColorPanel {
        enum Mode {
            None = -1,
            Gray = 0,
            RGB = 1,
            CMYK = 2,
            HSB = 3,
            CustomPalette = 4,
            ColorList = 5,
            Wheel = 6,
            Crayon = 7
        }
        enum Options {
            GrayModeMask = 1,
            RGBModeMask = 2,
            CMYKModeMask = 4,
            HSBModeMask = 8,
            CustomPaletteModeMask = 16,
            ColorListModeMask = 32,
            WheelModeMask = 64,
            CrayonModeMask = 128,
            AllModesMask = 65535
        }
    }
    namespace NSColorSpace {
        enum Model {
            Unknown = -1,
            Gray = 0,
            RGB = 1,
            CMYK = 2,
            LAB = 3,
            DeviceN = 4,
            Indexed = 5,
            Patterned = 6
        }
    }
    namespace NSColorSpaceName {
    }
    namespace NSComboBox {
    }
    namespace NSComparisonPredicate {
        enum Modifier {
            DirectPredicateModifier = 0,
            AllPredicateModifier = 1,
            AnyPredicateModifier = 2
        }
        enum Options {
            CaseInsensitivePredicateOption = 1,
            DiacriticInsensitivePredicateOption = 2,
            NormalizedPredicateOption = 4
        }
        enum Operator {
            LessThanPredicateOperatorType = 0,
            LessThanOrEqualToPredicateOperatorType = 1,
            GreaterThanPredicateOperatorType = 2,
            GreaterThanOrEqualToPredicateOperatorType = 3,
            EqualToPredicateOperatorType = 4,
            NotEqualToPredicateOperatorType = 5,
            MatchesPredicateOperatorType = 6,
            LikePredicateOperatorType = 7,
            BeginsWithPredicateOperatorType = 8,
            EndsWithPredicateOperatorType = 9,
            InPredicateOperatorType = 10,
            CustomSelectorPredicateOperatorType = 11,
            ContainsPredicateOperatorType = 99,
            BetweenPredicateOperatorType = 100
        }
    }
    namespace NSCompoundPredicate {
        enum LogicalType {
            NotPredicateType = 0,
            AndPredicateType = 1,
            OrPredicateType = 2
        }
    }
    namespace NSControl {
        enum ImagePosition {
            NoImage = 0,
            ImageOnly = 1,
            ImageLeft = 2,
            ImageRight = 3,
            ImageBelow = 4,
            ImageAbove = 5,
            ImageOverlaps = 6,
            ImageLeading = 7,
            ImageTrailing = 8
        }
        enum ControlSize {
            Regular = 0,
            Small = 1,
            Mini = 2
        }
    }
    namespace NSData {
        enum Base64DecodingOptions {
            IgnoreUnknownCharacters = 1
        }
        enum Base64EncodingOptions {
            Encoding64CharacterLineLength = 1,
            Encoding76CharacterLineLength = 2,
            EncodingEndLineWithCarriageReturn = 16,
            EncodingEndLineWithLineFeed = 32
        }
        enum CompressionAlgorithm {
            LZFSE = 0,
            LZ4 = 1,
            LZMA = 2,
            Zlib = 3
        }
        enum ReadingOptions {
            DataReadingMappedIfSafe = 1,
            DataReadingUncached = 2,
            DataReadingMappedAlways = 8,
            DataReadingMapped = 1,
            MappedRead = 1,
            UncachedRead = 2
        }
        enum SearchOptions {
            Backwards = 1,
            Anchored = 2
        }
        enum WritingOptions {
            DataWritingAtomic = 1,
            DataWritingWithoutOverwriting = 2,
            DataWritingFileProtectionNone = 268435456,
            DataWritingFileProtectionComplete = 536870912,
            DataWritingFileProtectionCompleteUnlessOpen = 805306368,
            DataWritingFileProtectionCompleteUntilFirstUserAuthentication = 1073741824,
            DataWritingFileProtectionMask = 4026531840,
            AtomicWrite = 1
        }
    }
    namespace NSDatePicker {
        enum ElementFlags {
            HourMinute = 12,
            HourMinuteSecond = 14,
            TimeZone = 16,
            YearMonth = 192,
            YearMonthDay = 224,
            Era = 256
        }
        enum Mode {
            Single = 0,
            Range = 1
        }
        enum Style {
            TextFieldAndStepper = 0,
            ClockAndCalendar = 1,
            TextField = 2
        }
    }
    namespace NSDecimalNumber {
        enum CalculationError {
            NoError = 0,
            LossOfPrecision = 1,
            Underflow = 2,
            Overflow = 3,
            DivideByZero = 4
        }
        enum RoundingMode {
            Plain = 0,
            Down = 1,
            Up = 2,
            Bankers = 3
        }
    }
    namespace NSDeviceDescriptionKey {
    }
    namespace NSDocument {
        enum ChangeType {
            ChangeDone = 0,
            ChangeUndone = 1,
            ChangeRedone = 5,
            ChangeCleared = 2,
            ChangeReadOtherContents = 3,
            ChangeAutosaved = 4,
            ChangeDiscardable = 256
        }
        enum SaveOperationType {
            SaveOperation = 0,
            SaveAsOperation = 1,
            SaveToOperation = 2,
            AutosaveInPlaceOperation = 4,
            AutosaveElsewhereOperation = 3,
            AutosaveAsOperation = 5,
            AutosaveOperation = 3
        }
    }
    namespace NSDraggingItem {
    }
    namespace NSDrawer {
        enum State {
            ClosedState = 0,
            OpeningState = 1,
            OpenState = 2,
            ClosingState = 3
        }
    }
    namespace NSEnumerator {
    }
    namespace NSError {
    }
    namespace NSEvent {
        enum ButtonMask {
            PenTip = 1,
            PenLowerSide = 2,
            PenUpperSide = 4
        }
        enum GestureAxis {
            None = 0,
            Horizontal = 1,
            Vertical = 2
        }
        enum EventTypeMask {
            LeftMouseDown = 2,
            LeftMouseUp = 4,
            RightMouseDown = 8,
            RightMouseUp = 16,
            MouseMoved = 32,
            LeftMouseDragged = 64,
            RightMouseDragged = 128,
            MouseEntered = 256,
            MouseExited = 512,
            KeyDown = 1024,
            KeyUp = 2048,
            FlagsChanged = 4096,
            AppKitDefined = 8192,
            SystemDefined = 16384,
            ApplicationDefined = 32768,
            Periodic = 65536,
            CursorUpdate = 131072,
            ScrollWheel = 4194304,
            TabletPoint = 8388608,
            TabletProximity = 16777216,
            OtherMouseDown = 33554432,
            OtherMouseUp = 67108864,
            OtherMouseDragged = 134217728,
            Gesture = 536870912,
            Magnify = 1073741824,
            Swipe = 2147483648,
            Rotate = 262144,
            BeginGesture = 524288,
            EndGesture = 1048576,
            SmartMagnify = 4294967296,
            Pressure = 17179869184,
            DirectTouch = 137438953472,
            ChangeMode = 274877906944,
            Any = -1
        }
        enum ModifierFlags {
            CapsLock = 65536,
            Shift = 131072,
            Control = 262144,
            Option = 524288,
            Command = 1048576,
            NumericPad = 2097152,
            Help = 4194304,
            Function = 8388608,
            DeviceIndependentFlagsMask = 4294901760
        }
        enum Phase {
            None = 0,
            Began = 1,
            Stationary = 2,
            Changed = 4,
            Ended = 8,
            Cancelled = 16,
            MayBegin = 32
        }
        enum EventSubtype {
            WindowExposed = 0,
            ApplicationActivated = 1,
            ApplicationDeactivated = 2,
            WindowMoved = 4,
            ScreenChanged = 8,
            PowerOff = 1,
            MouseEvent = 0,
            TabletPoint = 1,
            TabletProximity = 2,
            Touch = 3
        }
        enum SwipeTrackingOptions {
            LockDirection = 1,
            ClampGestureAmount = 2
        }
        enum EventType {
            LeftMouseDown = 1,
            LeftMouseUp = 2,
            RightMouseDown = 3,
            RightMouseUp = 4,
            MouseMoved = 5,
            LeftMouseDragged = 6,
            RightMouseDragged = 7,
            MouseEntered = 8,
            MouseExited = 9,
            KeyDown = 10,
            KeyUp = 11,
            FlagsChanged = 12,
            AppKitDefined = 13,
            SystemDefined = 14,
            ApplicationDefined = 15,
            Periodic = 16,
            CursorUpdate = 17,
            ScrollWheel = 22,
            TabletPoint = 23,
            TabletProximity = 24,
            OtherMouseDown = 25,
            OtherMouseUp = 26,
            OtherMouseDragged = 27,
            Gesture = 29,
            Magnify = 30,
            Swipe = 31,
            Rotate = 18,
            BeginGesture = 19,
            EndGesture = 20,
            SmartMagnify = 32,
            QuickLook = 33,
            Pressure = 34,
            DirectTouch = 37,
            ChangeMode = 38
        }
        enum PointingDeviceType {
            Unknown = 0,
            Pen = 1,
            Cursor = 2,
            Eraser = 3
        }
        enum PressureBehavior {
            Unknown = -1,
            PrimaryDefault = 0,
            PrimaryClick = 1,
            PrimaryGeneric = 2,
            PrimaryAccelerator = 3,
            PrimaryDeepClick = 5,
            PrimaryDeepDrag = 6
        }
    }
    namespace NSExceptionName {
    }
    namespace NSExpression {
        enum ExpressionType {
            ConstantValueExpressionType = 0,
            EvaluatedObjectExpressionType = 1,
            VariableExpressionType = 2,
            KeyPathExpressionType = 3,
            FunctionExpressionType = 4,
            UnionSetExpressionType = 5,
            IntersectSetExpressionType = 6,
            MinusSetExpressionType = 7,
            SubqueryExpressionType = 13,
            AggregateExpressionType = 14,
            AnyKeyExpressionType = 15,
            BlockExpressionType = 19,
            ConditionalExpressionType = 20
        }
    }
    namespace NSFileCoordinator {
        enum ReadingOptions {
            WithoutChanges = 1,
            ResolvesSymbolicLink = 2,
            ImmediatelyAvailableMetadataOnly = 4,
            ForUploading = 8
        }
        enum WritingOptions {
            ForDeleting = 1,
            ForMoving = 2,
            ForMerging = 4,
            ForReplacing = 8,
            ContentIndependentMetadataOnly = 16
        }
    }
    namespace NSFileVersion {
        enum AddingOptions {
            ByMoving = 1
        }
        enum ReplacingOptions {
            ByMoving = 1
        }
    }
    namespace NSFont {
    }
    namespace NSFontAssetRequest {
        enum Options {
            UsesStandardUI = 1
        }
    }
    namespace NSFontCollection {
        enum Visibility {
            Process = 1,
            User = 2,
            Computer = 4
        }
    }
    namespace NSFontDescriptor {
        enum SymbolicTraits {
            TraitItalic = 1,
            TraitBold = 2,
            TraitExpanded = 32,
            TraitCondensed = 64,
            TraitMonoSpace = 1024,
            TraitVertical = 2048,
            TraitUIOptimized = 4096,
            TraitTightLeading = 32768,
            TraitLooseLeading = 65536,
            ClassMask = 4026531840,
            ClassUnknown = 0,
            ClassOldStyleSerifs = 268435456,
            ClassTransitionalSerifs = 536870912,
            ClassModernSerifs = 805306368,
            ClassClarendonSerifs = 1073741824,
            ClassSlabSerifs = 1342177280,
            ClassFreeformSerifs = 1879048192,
            ClassSansSerif = 2147483648,
            ClassOrnamentals = 2415919104,
            ClassScripts = 2684354560,
            ClassSymbolic = 3221225472
        }
    }
    namespace NSFontPanel {
        enum ModeMask {
            ModeMaskFace = 1,
            ModeMaskSize = 2,
            ModeMaskCollection = 4,
            ModeMaskUnderlineEffect = 256,
            ModeMaskStrikethroughEffect = 512,
            ModeMaskTextColorEffect = 1024,
            ModeMaskDocumentColorEffect = 2048,
            ModeMaskShadowEffect = 4096,
            ModeMaskAllEffects = 1048320,
            ModesMaskStandardModes = 65535,
            ModesMaskAllModes = 4294967295
        }
    }
    namespace NSGestureRecognizer {
        enum State {
            Possible = 0,
            Began = 1,
            Changed = 2,
            Ended = 3,
            Cancelled = 4,
            Failed = 5,
            Recognized = 3
        }
    }
    namespace NSGradient {
        enum DrawingOptions {
            DrawsBeforeStartingLocation = 1,
            DrawsAfterEndingLocation = 2
        }
    }
    namespace NSGraphicsContext {
    }
    namespace NSGridCell {
        enum Placement {
            Inherited = 0,
            None = 1,
            Leading = 2,
            Top = 2,
            Trailing = 3,
            Bottom = 3,
            Center = 4,
            Fill = 5
        }
    }
    namespace NSGridRow {
        enum Alignment {
            Inherited = 0,
            None = 1,
            FirstBaseline = 2,
            LastBaseline = 3
        }
    }
    namespace NSGridView {
    }
    namespace NSHapticFeedbackManager {
        enum FeedbackPattern {
            Generic = 0,
            Alignment = 1,
            LevelChange = 2
        }
        enum PerformanceTime {
            Default = 0,
            Now = 1,
            DrawCompleted = 2
        }
    }
    namespace NSHelpManager {
    }
    namespace NSImage {
        enum CacheMode {
            Default = 0,
            Always = 1,
            BySize = 2,
            Never = 3
        }
        enum LayoutDirection {
            Unspecified = -1,
            LeftToRight = 2,
            RightToLeft = 3
        }
        enum LoadStatus {
            Completed = 0,
            Cancelled = 1,
            InvalidData = 2,
            UnexpectedEOF = 3,
            ReadError = 4
        }
        enum ResizingMode {
            Stretch = 0,
            Tile = 1
        }
    }
    namespace NSImageRep {
    }
    namespace NSImageView {
        enum FrameStyle {
            None = 0,
            Photo = 1,
            GrayBezel = 2,
            Groove = 3,
            Button = 4
        }
    }
    namespace NSIndexSet {
    }
    namespace NSItemProvider {
        enum ErrorCode {
            UnknownError = -1,
            ItemUnavailableError = -1000,
            UnexpectedValueClassError = -1100,
            UnavailableCoercionError = -1200
        }
    }
    namespace NSKeyValueChangeKey {
    }
    namespace NSKeyValueOperator {
    }
    namespace NSLayoutConstraint {
        enum Attribute {
            Left = 1,
            Right = 2,
            Top = 3,
            Bottom = 4,
            Leading = 5,
            Trailing = 6,
            Width = 7,
            Height = 8,
            CenterX = 9,
            CenterY = 10,
            LastBaseline = 11,
            Baseline = 11,
            FirstBaseline = 12,
            NotAnAttribute = 0
        }
        enum Orientation {
            Horizontal = 0,
            Vertical = 1
        }
        enum FormatOptions {
            AlignAllLeft = 2,
            AlignAllRight = 4,
            AlignAllTop = 8,
            AlignAllBottom = 16,
            AlignAllLeading = 32,
            AlignAllTrailing = 64,
            AlignAllCenterX = 512,
            AlignAllCenterY = 1024,
            AlignAllLastBaseline = 2048,
            AlignAllFirstBaseline = 4096,
            AlignAllBaseline = 2048,
            AlignmentMask = 65535,
            DirectionLeadingToTrailing = 0,
            DirectionLeftToRight = 65536,
            DirectionRightToLeft = 131072,
            DirectionMask = 196608
        }
        enum Relation {
            LessThanOrEqual = -1,
            Equal = 0,
            GreaterThanOrEqual = 1
        }
    }
    namespace NSLayoutManager {
        enum ControlCharacterAction {
            ZeroAdvancement = 1,
            Whitespace = 2,
            HorizontalTab = 4,
            LineBreak = 8,
            ParagraphBreak = 16,
            ContainerBreak = 32
        }
        enum GlyphProperty {
            Null = 1,
            ControlCharacter = 2,
            Elastic = 4,
            NonBaseCharacter = 8
        }
        enum TextLayoutOrientation {
            Horizontal = 0,
            Vertical = 1
        }
        enum TypesetterBehavior {
            LatestBehavior = -1,
            OriginalBehavior = 0,
            Behavior_10_2_WithCompatibility = 1,
            Behavior_10_2 = 2,
            Behavior_10_3 = 3,
            Behavior_10_4 = 4
        }
    }
    namespace NSLevelIndicator {
        enum PlaceholderVisibility {
            Automatic = 0,
            Always = 1,
            WhileEditing = 2
        }
        enum Style {
            Relevancy = 0,
            ContinuousCapacity = 1,
            DiscreteCapacity = 2,
            Rating = 3
        }
    }
    namespace NSLinguisticTag {
    }
    namespace NSLinguisticTagScheme {
    }
    namespace NSLinguisticTagger {
        enum Options {
            OmitWords = 1,
            OmitPunctuation = 2,
            OmitWhitespace = 4,
            OmitOther = 8,
            JoinNames = 16
        }
    }
    namespace NSLocale {
        enum LanguageDirection {
            Unknown = 0,
            LeftToRight = 1,
            RightToLeft = 2,
            TopToBottom = 3,
            BottomToTop = 4
        }
    }
    namespace NSMachPort {
        enum Options {
            DeallocateNone = 0,
            DeallocateSendRight = 1,
            DeallocateReceiveRight = 2
        }
    }
    namespace NSMatrix {
        enum Mode {
            RadioModeMatrix = 0,
            HighlightModeMatrix = 1,
            ListModeMatrix = 2,
            TrackModeMatrix = 3
        }
    }
    namespace NSMediaLibraryBrowserController {
        enum Library {
            Audio = 1,
            Image = 2,
            Movie = 4
        }
    }
    namespace NSMenu {
        enum Properties {
            PropertyItemTitle = 1,
            PropertyItemAttributedTitle = 2,
            PropertyItemKeyEquivalent = 4,
            PropertyItemImage = 8,
            PropertyItemEnabled = 16,
            PropertyItemAccessibilityDescription = 32
        }
    }
    namespace NSMenuItem {
    }
    namespace NSNib {
    }
    namespace NSNotification {
    }
    namespace NSNumber {
    }
    namespace NSOrderedSet {
    }
    namespace NSOutlineView {
    }
    namespace NSPDFPanel {
        enum Options {
            ShowsPaperSize = 4,
            ShowsOrientation = 8,
            RequestsParentDirectory = 16777216
        }
    }
    namespace NSPageController {
        enum TransitionStyle {
            StackHistory = 0,
            StackBook = 1,
            HorizontalStrip = 2
        }
    }
    namespace NSParagraphStyle {
        enum TextTabType {
            LeftTabStopType = 0,
            RightTabStopType = 1,
            CenterTabStopType = 2,
            DecimalTabStopType = 3
        }
        enum LineBreakStrategy {
            pushOut,
            hangulWordPriority,
            standard
        }
    }
    namespace NSPasteboard {
        enum ContentsOptions {
            CurrentHostOnly = 1
        }
        enum ReadingOptions {
            AsData = 0,
            AsString = 1,
            AsPropertyList = 2,
            AsKeyedArchive = 4
        }
        enum WritingOptions {
            Promised = 512
        }
    }
    namespace NSPathControl {
        enum Style {
            Standard = 0,
            PopUp = 2,
            NavigationBar = 1
        }
    }
    namespace NSPickerTouchBarItem {
        enum ControlRepresentation {
            Automatic = 0,
            Expanded = 1,
            Collapsed = 2
        }
        enum SelectionMode {
            SelectOne = 0,
            SelectAny = 1,
            Momentary = 2
        }
    }
    namespace NSPointerFunctions {
        enum Options {
            StrongMemory = 0,
            ZeroingWeakMemory = 1,
            OpaqueMemory = 2,
            MallocMemory = 3,
            MachVirtualMemory = 4,
            WeakMemory = 5,
            ObjectPersonality = 0,
            OpaquePersonality = 256,
            ObjectPointerPersonality = 512,
            CStringPersonality = 768,
            StructPersonality = 1024,
            IntegerPersonality = 1280,
            CopyIn = 65536
        }
    }
    namespace NSPopUpButton {
        enum ArrowPosition {
            NoArrow = 0,
            ArrowAtCenter = 1,
            ArrowAtBottom = 2
        }
    }
    namespace NSPopUpButtonCell {
    }
    namespace NSPopover {
        enum Behavior {
            ApplicationDefined = 0,
            Transient = 1,
            Semitransient = 2
        }
    }
    namespace NSPositionalSpecifier {
        enum InsertionPosition {
            PositionAfter = 0,
            PositionBefore = 1,
            PositionBeginning = 2,
            PositionEnd = 3,
            PositionReplace = 4
        }
    }
    namespace NSPrintInfo {
        enum PaperOrientation {
            Portrait = 0,
            Landscape = 1
        }
        enum PaginationMode {
            Automatic = 0,
            Fit = 1,
            Clip = 2
        }
    }
    namespace NSPrintOperation {
        enum RenderingQuality {
            Best = 0,
            Responsive = 1
        }
        enum PageOrder {
            DescendingPageOrder = -1,
            SpecialPageOrder = 0,
            AscendingPageOrder = 1,
            UnknownPageOrder = 2
        }
    }
    namespace NSPrintPanel {
        enum Options {
            ShowsCopies = 1,
            ShowsPageRange = 2,
            ShowsPaperSize = 4,
            ShowsOrientation = 8,
            ShowsScaling = 16,
            ShowsPrintSelection = 32,
            ShowsPageSetupAccessory = 256,
            ShowsPreview = 131072
        }
    }
    namespace NSPrinter {
        enum TableStatus {
            OK = 0,
            NotFound = 1,
            Error = 2
        }
    }
    namespace NSProgressIndicator {
        enum Style {
            Bar = 0,
            Spinning = 1
        }
    }
    namespace NSRegularExpression {
        enum MatchingFlags {
            Progress = 1,
            Completed = 2,
            HitEnd = 4,
            RequiredEnd = 8,
            InternalError = 16
        }
        enum MatchingOptions {
            ReportProgress = 1,
            ReportCompletion = 2,
            Anchored = 4,
            WithTransparentBounds = 8,
            WithoutAnchoringBounds = 16
        }
        enum Options {
            CaseInsensitive = 1,
            AllowCommentsAndWhitespace = 2,
            IgnoreMetacharacters = 4,
            DotMatchesLineSeparators = 8,
            AnchorsMatchLines = 16,
            UseUnixLineSeparators = 32,
            UseUnicodeWordBoundaries = 64
        }
    }
    namespace NSRelativeSpecifier {
        enum RelativePosition {
            After = 0,
            Before = 1
        }
    }
    namespace NSRuleEditor {
        enum NestingMode {
            Single = 0,
            List = 1,
            Compound = 2,
            Simple = 3
        }
        enum RowType {
            Simple = 0,
            Compound = 1
        }
    }
    namespace NSRulerView {
        enum Orientation {
            HorizontalRuler = 0,
            VerticalRuler = 1
        }
    }
    namespace NSScreen {
    }
    namespace NSScrollView {
        enum Elasticity {
            Automatic = 0,
            None = 1,
            Allowed = 2
        }
        enum FindBarPosition {
            AboveHorizontalRuler = 0,
            AboveContent = 1,
            BelowContent = 2
        }
    }
    namespace NSScroller {
        enum KnobStyle {
            Default = 0,
            Dark = 1,
            Light = 2
        }
        enum Part {
            NoPart = 0,
            DecrementPage = 1,
            Knob = 2,
            IncrementPage = 3,
            DecrementLine = 4,
            IncrementLine = 5,
            KnobSlot = 6
        }
        enum Style {
            Legacy = 0,
            Overlay = 1
        }
        enum UsableParts {
            NoScrollerParts = 0,
            OnlyScrollerArrows = 1,
            AllScrollerParts = 2
        }
    }
    namespace NSScrubber {
        enum Alignment {
            None = 0,
            Leading = 1,
            Trailing = 2,
            Center = 3
        }
        enum Mode {
            Fixed = 0,
            Free = 1
        }
    }
    namespace NSSearchField {
    }
    namespace NSSegmentedControl {
        enum Distribution {
            Fit = 0,
            Fill = 1,
            FillEqually = 2,
            FillProportionally = 3
        }
        enum Style {
            Automatic = 0,
            Rounded = 1,
            RoundRect = 3,
            TexturedSquare = 4,
            SmallSquare = 6,
            Separated = 8,
            TexturedRounded = 2,
            Capsule = 5
        }
        enum SwitchTracking {
            SelectOne = 0,
            SelectAny = 1,
            Momentary = 2,
            MomentaryAccelerator = 3
        }
    }
    namespace NSSet {
    }
    namespace NSSharingService {
        enum CloudKitOptions {
            Standard = 0,
            AllowPublic = 1,
            AllowPrivate = 2,
            AllowReadOnly = 16,
            AllowReadWrite = 32
        }
        enum SharingContentScope {
            Item = 0,
            Partial = 1,
            Full = 2
        }
    }
    namespace NSSlider {
        enum SliderType {
            Linear = 0,
            Circular = 1
        }
        enum TickMarkPosition {
            Below = 0,
            Above = 1,
            Leading = 1,
            Trailing = 0
        }
    }
    namespace NSSliderAccessory {
    }
    namespace NSSound {
    }
    namespace NSSpecifierTest {
        enum TestComparisonOperation {
            EqualToComparison = 0,
            LessThanOrEqualToComparison = 1,
            LessThanComparison = 2,
            GreaterThanOrEqualToComparison = 3,
            GreaterThanComparison = 4,
            BeginsWithComparison = 5,
            EndsWithComparison = 6,
            ContainsComparison = 7
        }
    }
    namespace NSSpeechSynthesizer {
        enum Boundary {
            ImmediateBoundary = 0,
            WordBoundary = 1,
            SentenceBoundary = 2
        }
    }
    namespace NSSpellChecker {
        enum CorrectionIndicatorType {
            Default = 0,
            Reversion = 1,
            Guesses = 2
        }
        enum CorrectionResponse {
            None = 0,
            Accepted = 1,
            Rejected = 2,
            Ignored = 3,
            Edited = 4,
            Reverted = 5
        }
    }
    namespace NSSplitView {
        enum DividerStyle {
            Thick = 1,
            Thin = 2,
            PaneSplitter = 3
        }
    }
    namespace NSSplitViewController {
    }
    namespace NSSplitViewItem {
        enum Behavior {
            Default = 0,
            Sidebar = 1,
            ContentList = 2
        }
        enum CollapseBehavior {
            Default = 0,
            PreferResizingSplitViewWithFixedSiblings = 1,
            PreferResizingSiblingsWithFixedSplitView = 2,
            UseConstraints = 3
        }
    }
    namespace NSStackView {
        enum Distribution {
            GravityAreas = -1,
            Fill = 0,
            FillEqually = 1,
            FillProportionally = 2,
            EqualSpacing = 3,
            EqualCentering = 4
        }
        enum Gravity {
            Top = 1,
            Leading = 1,
            Center = 2,
            Bottom = 3,
            Trailing = 3
        }
    }
    namespace NSStatusItem {
        enum Behavior {
            RemovalAllowed = 2,
            TerminationOnRemoval = 4
        }
    }
    namespace NSStoryboard {
    }
    namespace NSStoryboardSegue {
    }
    namespace NSString {
        enum DrawingOptions {
            UsesLineFragmentOrigin = 1,
            UsesFontLeading = 2,
            UsesDeviceMetrics = 8,
            TruncatesLastVisibleLine = 32,
            DisableScreenFontSubstitution = 4,
            OneShot = 16
        }
        enum CompareOptions {
            CaseInsensitiveSearch = 1,
            LiteralSearch = 2,
            BackwardsSearch = 4,
            AnchoredSearch = 8,
            NumericSearch = 64,
            DiacriticInsensitiveSearch = 128,
            WidthInsensitiveSearch = 256,
            ForcedOrderingSearch = 512,
            RegularExpressionSearch = 1024
        }
        enum EncodingConversionOptions {
            AllowLossy = 1,
            ExternalRepresentation = 2
        }
        enum EnumerationOptions {
            ByLines = 0,
            ByParagraphs = 1,
            ByComposedCharacterSequences = 2,
            ByWords = 3,
            BySentences = 4,
            Reverse = 256,
            SubstringNotRequired = 512,
            Localized = 1024
        }
    }
    namespace NSTabView {
        enum TabPosition {
            None = 0,
            Top = 1,
            Left = 2,
            Bottom = 3,
            Right = 4
        }
        enum TabViewBorderType {
            None = 0,
            Line = 1,
            Bezel = 2
        }
        enum TabType {
            TopTabsBezelBorder = 0,
            LeftTabsBezelBorder = 1,
            BottomTabsBezelBorder = 2,
            RightTabsBezelBorder = 3,
            NoTabsBezelBorder = 4,
            NoTabsLineBorder = 5,
            NoTabsNoBorder = 6
        }
    }
    namespace NSTabViewController {
        enum TabStyle {
            SegmentedControlOnTop = 0,
            SegmentedControlOnBottom = 1,
            Toolbar = 2,
            Unspecified = -1
        }
    }
    namespace NSTabViewItem {
        enum State {
            SelectedTab = 0,
            BackgroundTab = 1,
            PressedTab = 2
        }
    }
    namespace NSTableColumn {
        enum ResizingOptions {
            NoResizing = 0,
            AutoresizingMask = 1,
            UserResizingMask = 2
        }
    }
    namespace NSTableView {
        enum RowActionEdge {
            Leading = 0,
            Trailing = 1
        }
        enum AnimationOptions {
            EffectNone = 0,
            EffectFade = 1,
            EffectGap = 2,
            SlideUp = 16,
            SlideDown = 32,
            SlideLeft = 48,
            SlideRight = 64
        }
        enum ColumnAutoresizingStyle {
            NoColumnAutoresizing = 0,
            UniformColumnAutoresizingStyle = 1,
            SequentialColumnAutoresizingStyle = 2,
            ReverseSequentialColumnAutoresizingStyle = 3,
            LastColumnOnlyAutoresizingStyle = 4,
            FirstColumnOnlyAutoresizingStyle = 5
        }
        enum DraggingDestinationFeedbackStyle {
            None = -1,
            Regular = 0,
            SourceList = 1,
            Gap = 2
        }
        enum DropOperation {
            On = 0,
            Above = 1
        }
        enum GridLineStyle {
            GridNone = 0,
            SolidVerticalGridLineMask = 1,
            SolidHorizontalGridLineMask = 2,
            DashedHorizontalGridLineMask = 8
        }
        enum RowSizeStyle {
            Default = -1,
            Custom = 0,
            Small = 1,
            Medium = 2,
            Large = 3
        }
        enum SelectionHighlightStyle {
            None = -1,
            Regular = 0,
            SourceList = 1
        }
    }
    namespace NSTableViewRowAction {
        enum Style {
            Regular = 0,
            Destructive = 1
        }
    }
    namespace NSText {
    }
    namespace NSTextAlternatives {
    }
    namespace NSTextBlock {
        enum Dimension {
            Width = 0,
            MinimumWidth = 1,
            MaximumWidth = 2,
            Height = 4,
            MinimumHeight = 5,
            MaximumHeight = 6
        }
        enum Layer {
            Padding = -1,
            Border = 0,
            Margin = 1
        }
        enum ValueType {
            AbsoluteValueType = 0,
            PercentageValueType = 1
        }
        enum VerticalAlignment {
            TopAlignment = 0,
            MiddleAlignment = 1,
            BottomAlignment = 2,
            BaselineAlignment = 3
        }
    }
    namespace NSTextCheckingKey {
    }
    namespace NSTextCheckingResult {
        enum CheckingType {
            Orthography = 1,
            Spelling = 2,
            Grammar = 4,
            Date = 8,
            Address = 16,
            Link = 32,
            Quote = 64,
            Dash = 128,
            Replacement = 256,
            Correction = 512,
            RegularExpression = 1024,
            PhoneNumber = 2048,
            TransitInformation = 4096
        }
    }
    namespace NSTextField {
        enum BezelStyle {
            SquareBezel = 0,
            RoundedBezel = 1
        }
    }
    namespace NSTextFinder {
        enum Action {
            ShowFindInterface = 1,
            NextMatch = 2,
            PreviousMatch = 3,
            ReplaceAll = 4,
            Replace = 5,
            ReplaceAndFind = 6,
            SetSearchString = 7,
            ReplaceAllInSelection = 8,
            SelectAll = 9,
            SelectAllInSelection = 10,
            HideFindInterface = 11,
            ShowReplaceInterface = 12,
            HideReplaceInterface = 13
        }
        enum MatchingType {
            Contains = 0,
            StartsWith = 1,
            FullWord = 2,
            EndsWith = 3
        }
    }
    namespace NSTextInputContext {
    }
    namespace NSTextList {
        enum Options {
            PrependEnclosingMarker = 1
        }
    }
    namespace NSTextStorage {
    }
    namespace NSTextTab {
    }
    namespace NSTextTable {
        enum LayoutAlgorithm {
            AutomaticLayoutAlgorithm = 0,
            FixedLayoutAlgorithm = 1
        }
    }
    namespace NSTextView {
    }
    namespace NSTimeZone {
        enum NameStyle {
            Standard = 0,
            ShortStandard = 1,
            DaylightSaving = 2,
            ShortDaylightSaving = 3,
            Generic = 4,
            ShortGeneric = 5
        }
    }
    namespace NSTokenField {
        enum TokenStyle {
            Default = 0,
            None = 1,
            Rounded = 2,
            Squared = 3,
            PlainSquared = 4
        }
    }
    namespace NSToolbar {
        enum DisplayMode {
            Default = 0,
            IconAndLabel = 1,
            IconOnly = 2,
            LabelOnly = 3
        }
        enum SizeMode {
            Default = 0,
            Regular = 1,
            Small = 2
        }
    }
    namespace NSToolbarItem {
    }
    namespace NSToolbarItemGroup {
        enum ControlRepresentation {
            Automatic = 0,
            Expanded = 1,
            Collapsed = 2
        }
        enum SelectionMode {
            SelectOne = 0,
            SelectAny = 1,
            Momentary = 2
        }
    }
    namespace NSTouch {
        enum Phase {
            Began = 1,
            Moved = 2,
            Stationary = 4,
            Ended = 8,
            Cancelled = 16,
            Touching = 7,
            Any = -1
        }
        enum TouchType {
            Direct = 0,
            Indirect = 1
        }
        enum TouchTypeMask {
            Direct = 1,
            Indirect = 2
        }
    }
    namespace NSTouchBar {
    }
    namespace NSTouchBarItem {
    }
    namespace NSTrackingArea {
        enum Options {
            MouseEnteredAndExited = 1,
            MouseMoved = 2,
            CursorUpdate = 4,
            ActiveWhenFirstResponder = 16,
            ActiveInKeyWindow = 32,
            ActiveInActiveApp = 64,
            ActiveAlways = 128,
            AssumeInside = 256,
            InVisibleRect = 512,
            EnabledDuringMouseDrag = 1024
        }
    }
    namespace NSURL {
        enum BookmarkCreationOptions {
            PreferFileIDResolution = 256,
            MinimalBookmark = 512,
            SuitableForBookmarkFile = 1024,
            WithSecurityScope = 2048,
            SecurityScopeAllowOnlyReadAccess = 4096
        }
        enum BookmarkResolutionOptions {
            WithoutUI = 256,
            WithoutMounting = 512,
            WithSecurityScope = 1024
        }
    }
    namespace NSURLHandle {
        enum Status {
            NotLoaded = 0,
            LoadSucceeded = 1,
            LoadInProgress = 2,
            LoadFailed = 3
        }
    }
    namespace NSURLRequest {
        enum CachePolicy {
            UseProtocolCachePolicy = 0,
            ReloadIgnoringLocalCacheData = 1,
            ReloadIgnoringLocalAndRemoteCacheData = 4,
            ReloadIgnoringCacheData = 1,
            ReturnCacheDataElseLoad = 2,
            ReturnCacheDataDontLoad = 3,
            ReloadRevalidatingCacheData = 5
        }
        enum NetworkServiceType {
            NetworkServiceTypeDefault = 0,
            NetworkServiceTypeVoIP = 1,
            NetworkServiceTypeVideo = 2,
            NetworkServiceTypeBackground = 3,
            NetworkServiceTypeVoice = 4,
            NetworkServiceTypeResponsiveData = 6,
            NetworkServiceTypeAVStreaming = 8,
            NetworkServiceTypeResponsiveAV = 9,
            NetworkServiceTypeCallSignaling = 11
        }
    }
    namespace NSUbiquitousKeyValueStore {
    }
    namespace NSUserNotification {
        enum ActivationType {
            None = 0,
            ContentsClicked = 1,
            ActionButtonClicked = 2,
            Replied = 3,
            AdditionalActionClicked = 4
        }
    }
    namespace NSValueTransformerName {
    }
    namespace NSView {
        enum AutoresizingMask {
            ViewNotSizable = 0,
            ViewMinXMargin = 1,
            ViewWidthSizable = 2,
            ViewMaxXMargin = 4,
            ViewMinYMargin = 8,
            ViewHeightSizable = 16,
            ViewMaxYMargin = 32
        }
        enum BackgroundStyle {
            Normal = 0,
            Emphasized = 1,
            Raised = 2,
            Lowered = 3
        }
        enum LayerContentsPlacement {
            ScaleAxesIndependently = 0,
            ScaleProportionallyToFit = 1,
            ScaleProportionallyToFill = 2,
            Center = 3,
            Top = 4,
            TopRight = 5,
            Right = 6,
            BottomRight = 7,
            Bottom = 8,
            BottomLeft = 9,
            Left = 10,
            TopLeft = 11
        }
        enum LayerContentsRedrawPolicy {
            Never = 0,
            OnSetNeedsDisplay = 1,
            DuringViewResize = 2,
            BeforeViewResize = 3,
            Crossfade = 4
        }
    }
    namespace NSViewAnimation {
    }
    namespace NSViewController {
        enum TransitionOptions {
            None = 0,
            Crossfade = 1,
            SlideUp = 16,
            SlideDown = 32,
            SlideLeft = 64,
            SlideRight = 128,
            SlideForward = 320,
            SlideBackward = 384,
            AllowUserInteraction = 4096
        }
    }
    namespace NSVisualEffectView {
        enum BlendingMode {
            BehindWindow = 0,
            WithinWindow = 1
        }
        enum Material {
            Titlebar = 3,
            Selection = 4,
            Menu = 5,
            Popover = 6,
            Sidebar = 7,
            HeaderView = 10,
            Sheet = 11,
            WindowBackground = 12,
            HUDWindow = 13,
            FullScreenUI = 15,
            ToolTip = 17,
            ContentBackground = 18,
            UnderWindowBackground = 21,
            UnderPageBackground = 22,
            AppearanceBased = 0,
            Light = 1,
            Dark = 2,
            MediumLight = 8,
            UltraDark = 9
        }
        enum State {
            FollowsWindowActiveState = 0,
            Active = 1,
            Inactive = 2
        }
    }
    namespace NSWhoseSpecifier {
        enum SubelementIdentifier {
            IndexSubelement = 0,
            EverySubelement = 1,
            MiddleSubelement = 2,
            RandomSubelement = 3,
            NoSubelement = 4
        }
    }
    namespace NSWindow {
        enum BackingStoreType {
            Retained = 0,
            Nonretained = 1,
            Buffered = 2
        }
        enum SelectionDirection {
            DirectSelection = 0,
            SelectingNext = 1,
            SelectingPrevious = 2
        }
        enum AnimationBehavior {
            Default = 0,
            None = 2,
            DocumentWindow = 3,
            UtilityWindow = 4,
            AlertPanel = 5
        }
        enum ButtonType {
            CloseButton = 0,
            MiniaturizeButton = 1,
            ZoomButton = 2,
            ToolbarButton = 3,
            DocumentIconButton = 4,
            DocumentVersionsButton = 6
        }
        enum CollectionBehavior {
            Default = 0,
            CanJoinAllSpaces = 1,
            MoveToActiveSpace = 2,
            Managed = 4,
            Transient = 8,
            Stationary = 16,
            ParticipatesInCycle = 32,
            IgnoresCycle = 64,
            FullScreenPrimary = 128,
            FullScreenAuxiliary = 256,
            FullScreenNone = 512,
            FullScreenAllowsTiling = 2048,
            FullScreenDisallowsTiling = 4096
        }
        enum Depth {
            TwentyfourBitRGB = 520,
            SixtyfourBitRGB = 528,
            OnehundredtwentyeightBitRGB = 544
        }
        enum NumberListOptions {
            AllApplications = 1,
            AllSpaces = 16
        }
        enum OcclusionState {
            Visible = 2
        }
        enum OrderingMode {
            Above = 1,
            Below = -1,
            Out = 0
        }
        enum SharingType {
            None = 0,
            ReadOnly = 1,
            ReadWrite = 2
        }
        enum StyleMask {
            Borderless = 0,
            Titled = 1,
            Closable = 2,
            Miniaturizable = 4,
            Resizable = 8,
            TexturedBackground = 256,
            UnifiedTitleAndToolbar = 4096,
            FullScreen = 16384,
            FullSizeContentView = 32768,
            UtilityWindow = 16,
            DocModalWindow = 64,
            NonactivatingPanel = 128,
            HUDWindow = 8192
        }
        enum TabbingMode {
            Automatic = 0,
            Preferred = 1,
            Disallowed = 2
        }
        enum TitleVisibility {
            Visible = 0,
            Hidden = 1
        }
        enum UserTabbingPreference {
            Manual = 0,
            Always = 1,
            InFullScreen = 2
        }
    }
    namespace NSWorkspace {
        enum AuthorizationType {
            CreateSymbolicLink = 0,
            SetAttributes = 1,
            ReplaceFile = 2
        }
        enum IconCreationOptions {
            ExcludeQuickDrawElementsIconCreationOption = 2,
            Exclude10_4ElementsIconCreationOption = 4
        }
        enum LaunchOptions {
            AndPrint = 2,
            WithErrorPresentation = 64,
            InhibitingBackgroundOnly = 128,
            WithoutAddingToRecents = 256,
            WithoutActivation = 512,
            Async = 65536,
            NewInstance = 524288,
            AndHide = 1048576,
            AndHideOthers = 2097152,
            Default = 65536,
            AllowingClassicStartup = 131072,
            PreferringClassic = 262144
        }
    }
    namespace NSXPCConnection {
        enum Options {
            Privileged = 4096
        }
    }
    namespace NetService {
        enum Options {
            noAutoRename,
            listenForConnections,
            center,
            name,
            object
        }
    }
    namespace NotificationQueue {
        enum NotificationCoalescing {
            NoCoalescing = 0,
            CoalescingOnName = 1,
            CoalescingOnSender = 2
        }
        enum PostingStyle {
            WhenIdle = 1,
            ASAP = 2,
            Now = 3
        }
    }
    namespace NumberFormatter {
        enum Behavior {
            BehaviorDefault = 0,
            Behavior10_0 = 1000,
            Behavior10_4 = 1040
        }
        enum PadPosition {
            BeforePrefix = 0,
            AfterPrefix = 1,
            BeforeSuffix = 2,
            AfterSuffix = 3
        }
        enum RoundingMode {
            Ceiling = 0,
            Floor = 1,
            Down = 2,
            Up = 3,
            HalfEven = 4,
            HalfDown = 5,
            HalfUp = 6
        }
        enum Style {
            NoStyle = 0,
            DecimalStyle = 1,
            CurrencyStyle = 2,
            PercentStyle = 3,
            ScientificStyle = 4,
            SpellOutStyle = 5,
            OrdinalStyle = 6,
            CurrencyISOCodeStyle = 8,
            CurrencyPluralStyle = 9,
            CurrencyAccountingStyle = 10
        }
    }
    namespace Operation {
        enum QueuePriority {
            VeryLow = -8,
            Low = -4,
            Normal = 0,
            High = 4,
            VeryHigh = 8
        }
    }
    namespace OperationQueue {
    }
    namespace PersonNameComponentsFormatter {
        enum Options {
            Phonetic = 2
        }
        enum Style {
            Default = 0,
            Short = 1,
            Medium = 2,
            Long = 3,
            Abbreviated = 4
        }
    }
    namespace Port {
    }
    namespace Process {
        enum TerminationReason {
            Exit = 1,
            UncaughtSignal = 2
        }
    }
    namespace ProcessInfo {
        enum ActivityOptions {
            IdleDisplaySleepDisabled = 1099511627776,
            IdleSystemSleepDisabled = 1048576,
            SuddenTerminationDisabled = 16384,
            AutomaticTerminationDisabled = 32768,
            UserInitiated = 16777215,
            UserInitiatedAllowingIdleSystemSleep = 15728639,
            Background = 255,
            LatencyCritical = 1095216660480
        }
        enum ThermalState {
            Nominal = 0,
            Fair = 1,
            Serious = 2,
            Critical = 3
        }
    }
    namespace Progress {
    }
    namespace ProgressKind {
    }
    namespace ProgressUserInfoKey {
    }
    namespace PropertyListSerialization {
        enum PropertyListFormat {
            OpenStepFormat = 1,
            XMLFormat_v1_0 = 100,
            BinaryFormat_v1_0 = 200
        }
        enum MutabilityOptions {
            Immutable = 0,
            MutableContainers = 1,
            MutableContainersAndLeaves = 2
        }
    }
    namespace RelativeDateTimeFormatter {
        enum DateTimeStyle {
            Numeric = 0,
            Named = 1
        }
        enum UnitsStyle {
            Full = 0,
            SpellOut = 1,
            Short = 2,
            Abbreviated = 3
        }
    }
    namespace RunLoop {
    }
    namespace Stream {
        enum Event {
            None = 0,
            OpenCompleted = 1,
            HasBytesAvailable = 2,
            HasSpaceAvailable = 4,
            ErrorOccurred = 8,
            EndEncountered = 16
        }
        enum Status {
            NotOpen = 0,
            Opening = 1,
            Open = 2,
            Reading = 3,
            Writing = 4,
            AtEnd = 5,
            Closed = 6,
            Error = 7
        }
    }
    namespace StreamNetworkServiceTypeValue {
    }
    namespace StreamSOCKSProxyConfiguration {
    }
    namespace StreamSOCKSProxyVersion {
    }
    namespace StreamSocketSecurityLevel {
    }
    namespace StringEncodingDetectionOptionsKey {
    }
    namespace StringTransform {
    }
    namespace URLCache {
        enum StoragePolicy {
            Allowed = 0,
            AllowedInMemoryOnly = 1,
            NotAllowed = 2
        }
    }
    namespace URLCredential {
        enum Persistence {
            None = 0,
            ForSession = 1,
            Permanent = 2,
            Synchronizable = 3
        }
    }
    namespace URLFileProtection {
    }
    namespace URLFileResourceType {
    }
    namespace URLResourceKey {
    }
    namespace URLSession {
        enum AuthChallengeDisposition {
            UseCredential = 0,
            PerformDefaultHandling = 1,
            CancelAuthenticationChallenge = 2,
            RejectProtectionSpace = 3
        }
        enum ResponseDisposition {
            Cancel = 0,
            Allow = 1,
            BecomeDownload = 2,
            BecomeStream = 3
        }
    }
    namespace URLSessionTask {
        enum State {
            Running = 0,
            Suspended = 1,
            Canceling = 2,
            Completed = 3
        }
    }
    namespace URLSessionTaskMetrics {
        enum ResourceFetchType {
            Unknown = 0,
            NetworkLoad = 1,
            ServerPush = 2,
            LocalCache = 3
        }
    }
    namespace URLSessionWebSocketTask {
        enum CloseCode {
            Invalid = 0,
            NormalClosure = 1000,
            GoingAway = 1001,
            ProtocolError = 1002,
            UnsupportedData = 1003,
            NoStatusReceived = 1005,
            AbnormalClosure = 1006,
            InvalidFramePayloadData = 1007,
            PolicyViolation = 1008,
            MessageTooBig = 1009,
            MandatoryExtensionMissing = 1010,
            InternalServerError = 1011,
            TLSHandshakeFailure = 1015
        }
    }
    namespace URLThumbnailDictionaryItem {
    }
    namespace URLUbiquitousItemDownloadingStatus {
    }
    namespace URLUbiquitousSharedItemPermissions {
    }
    namespace URLUbiquitousSharedItemRole {
    }
    namespace UserDefaults {
    }
    namespace XMLDTDNode {
        enum DTDKind {
            EntityGeneralKind = 1,
            EntityParsedKind = 2,
            EntityUnparsedKind = 3,
            EntityParameterKind = 4,
            EntityPredefined = 5,
            AttributeCDATAKind = 6,
            AttributeIDKind = 7,
            AttributeIDRefKind = 8,
            AttributeIDRefsKind = 9,
            AttributeEntityKind = 10,
            AttributeEntitiesKind = 11,
            AttributeNMTokenKind = 12,
            AttributeNMTokensKind = 13,
            AttributeEnumerationKind = 14,
            AttributeNotationKind = 15,
            ElementDeclarationUndefinedKind = 16,
            ElementDeclarationEmptyKind = 17,
            ElementDeclarationAnyKind = 18,
            ElementDeclarationMixedKind = 19,
            ElementDeclarationElementKind = 20
        }
    }
    namespace XMLDocument {
        enum ContentKind {
            XMLKind = 0,
            XHTMLKind = 1,
            HTMLKind = 2,
            TextKind = 3
        }
    }
    namespace XMLNode {
        enum Kind {
            InvalidKind = 0,
            DocumentKind = 1,
            ElementKind = 2,
            AttributeKind = 3,
            NamespaceKind = 4,
            ProcessingInstructionKind = 5,
            CommentKind = 6,
            TextKind = 7,
            DTDKind = 8,
            EntityDeclarationKind = 9,
            AttributeDeclarationKind = 10,
            ElementDeclarationKind = 11,
            NotationDeclarationKind = 12
        }
        enum Options {
            NodeOptionsNone = 0,
            NodeIsCDATA = 1,
            NodeExpandEmptyElement = 2,
            NodeCompactEmptyElement = 4,
            NodeUseSingleQuotes = 8,
            NodeUseDoubleQuotes = 16,
            NodeNeverEscapeContents = 32,
            DocumentTidyHTML = 512,
            DocumentTidyXML = 1024,
            DocumentValidate = 8192,
            NodeLoadExternalEntitiesAlways = 16384,
            NodeLoadExternalEntitiesSameOriginOnly = 32768,
            NodeLoadExternalEntitiesNever = 524288,
            DocumentXInclude = 65536,
            NodePrettyPrint = 131072,
            DocumentIncludeContentTypeDeclaration = 262144,
            NodePreserveNamespaceOrder = 1048576,
            NodePreserveAttributeOrder = 2097152,
            NodePreserveEntities = 4194304,
            NodePreservePrefixes = 8388608,
            NodePreserveCDATA = 16777216,
            NodePreserveWhitespace = 33554432,
            NodePreserveDTD = 67108864,
            NodePreserveCharacterReferences = 134217728,
            NodePromoteSignificantWhitespace = 268435456,
            NodePreserveEmptyElements = 6,
            NodePreserveQuotes = 24,
            NodePreserveAll = 4293918750
        }
    }
    namespace XMLParser {
        enum ErrorCode {
            InternalError = 1,
            OutOfMemoryError = 2,
            DocumentStartError = 3,
            EmptyDocumentError = 4,
            PrematureDocumentEndError = 5,
            InvalidHexCharacterRefError = 6,
            InvalidDecimalCharacterRefError = 7,
            InvalidCharacterRefError = 8,
            InvalidCharacterError = 9,
            CharacterRefAtEOFError = 10,
            CharacterRefInPrologError = 11,
            CharacterRefInEpilogError = 12,
            CharacterRefInDTDError = 13,
            EntityRefAtEOFError = 14,
            EntityRefInPrologError = 15,
            EntityRefInEpilogError = 16,
            EntityRefInDTDError = 17,
            ParsedEntityRefAtEOFError = 18,
            ParsedEntityRefInPrologError = 19,
            ParsedEntityRefInEpilogError = 20,
            ParsedEntityRefInInternalSubsetError = 21,
            EntityReferenceWithoutNameError = 22,
            EntityReferenceMissingSemiError = 23,
            ParsedEntityRefNoNameError = 24,
            ParsedEntityRefMissingSemiError = 25,
            UndeclaredEntityError = 26,
            UnparsedEntityError = 28,
            EntityIsExternalError = 29,
            EntityIsParameterError = 30,
            UnknownEncodingError = 31,
            EncodingNotSupportedError = 32,
            StringNotStartedError = 33,
            StringNotClosedError = 34,
            NamespaceDeclarationError = 35,
            EntityNotStartedError = 36,
            EntityNotFinishedError = 37,
            LessThanSymbolInAttributeError = 38,
            AttributeNotStartedError = 39,
            AttributeNotFinishedError = 40,
            AttributeHasNoValueError = 41,
            AttributeRedefinedError = 42,
            LiteralNotStartedError = 43,
            LiteralNotFinishedError = 44,
            CommentNotFinishedError = 45,
            ProcessingInstructionNotStartedError = 46,
            ProcessingInstructionNotFinishedError = 47,
            NotationNotStartedError = 48,
            NotationNotFinishedError = 49,
            AttributeListNotStartedError = 50,
            AttributeListNotFinishedError = 51,
            MixedContentDeclNotStartedError = 52,
            MixedContentDeclNotFinishedError = 53,
            ElementContentDeclNotStartedError = 54,
            ElementContentDeclNotFinishedError = 55,
            XMLDeclNotStartedError = 56,
            XMLDeclNotFinishedError = 57,
            ConditionalSectionNotStartedError = 58,
            ConditionalSectionNotFinishedError = 59,
            ExternalSubsetNotFinishedError = 60,
            DOCTYPEDeclNotFinishedError = 61,
            MisplacedCDATAEndStringError = 62,
            CDATANotFinishedError = 63,
            MisplacedXMLDeclarationError = 64,
            SpaceRequiredError = 65,
            SeparatorRequiredError = 66,
            NMTOKENRequiredError = 67,
            NAMERequiredError = 68,
            PCDATARequiredError = 69,
            URIRequiredError = 70,
            PublicIdentifierRequiredError = 71,
            LTRequiredError = 72,
            GTRequiredError = 73,
            LTSlashRequiredError = 74,
            EqualExpectedError = 75,
            TagNameMismatchError = 76,
            UnfinishedTagError = 77,
            StandaloneValueError = 78,
            InvalidEncodingNameError = 79,
            CommentContainsDoubleHyphenError = 80,
            InvalidEncodingError = 81,
            ExternalStandaloneEntityError = 82,
            InvalidConditionalSectionError = 83,
            EntityValueRequiredError = 84,
            NotWellBalancedError = 85,
            ExtraContentError = 86,
            InvalidCharacterInEntityError = 87,
            ParsedEntityRefInInternalError = 88,
            EntityRefLoopError = 89,
            EntityBoundaryError = 90,
            InvalidURIError = 91,
            URIFragmentError = 92,
            NoDTDError = 94,
            DelegateAbortedParseError = 512
        }
        enum ExternalEntityResolvingPolicy {
            ResolveExternalEntitiesNever = 0,
            ResolveExternalEntitiesNoNetwork = 1,
            ResolveExternalEntitiesSameOriginOnly = 2,
            ResolveExternalEntitiesAlways = 3
        }
    }
    export enum AVAssetReferenceRestrictions {
        forbidRemoteReferenceToLocal,
        forbidLocalReferenceToRemote,
        forbidCrossSiteReference,
        forbidLocalReferenceToLocal,
        forbidAll,
        defaultPolicy
    }
    export enum AVAudioPlayerNodeBufferOptions {
        byteSwapped,
        scalarCount,
        loops,
        interrupts,
        interruptsAtLoop
    }
    export enum AVAudioSpatializationFormats {
        monoAndStereo,
        multichannel,
        monoStereoAndMultichannel
    }
    export enum AVMovieWritingOptions {
        errorDomain,
        unknown,
        outOfMemory,
        sessionNotRunning,
        deviceAlreadyUsedByAnotherSession,
        noDataCaptured,
        sessionConfigurationChanged,
        diskFull,
        deviceWasDisconnected,
        mediaChanged,
        maximumDurationReached,
        maximumFileSizeReached,
        mediaDiscontinuity,
        maximumNumberOfSamplesForFileFormatReached,
        deviceNotConnected,
        deviceInUseByAnotherApplication,
        deviceLockedForConfigurationByAnotherProcess,
        exportFailed,
        decodeFailed,
        invalidSourceMedia,
        fileAlreadyExists,
        compositionTrackSegmentsNotContiguous,
        invalidCompositionTrackSegmentDuration,
        invalidCompositionTrackSegmentSourceStartTime,
        invalidCompositionTrackSegmentSourceDuration,
        fileFormatNotRecognized,
        fileFailedToParse,
        maximumStillImageCaptureRequestsExceeded,
        contentIsProtected,
        noImageAtTime,
        decoderNotFound,
        encoderNotFound,
        contentIsNotAuthorized,
        applicationIsNotAuthorized,
        operationNotSupportedForAsset,
        decoderTemporarilyUnavailable,
        encoderTemporarilyUnavailable,
        invalidVideoComposition,
        referenceForbiddenByReferencePolicy,
        invalidOutputURLPathExtension,
        screenCaptureFailed,
        displayWasDisabled,
        torchLevelUnavailable,
        incompatibleAsset,
        failedToLoadMediaData,
        serverIncorrectlyConfigured,
        applicationIsNotAuthorizedToUseDevice,
        failedToParse,
        fileTypeDoesNotSupportSampleReferences,
        undecodableMediaData,
        airPlayControllerRequiresInternet,
        airPlayReceiverRequiresInternet,
        videoCompositorFailed,
        createContentKeyRequestFailed,
        unsupportedOutputSettings,
        operationNotAllowed,
        contentIsUnavailable,
        formatUnsupported,
        malformedDepth,
        contentNotUpdated,
        noLongerPlayable,
        noCompatibleAlternatesForExternalDisplay,
        noSourceTrack,
        externalPlaybackNotSupportedForAsset,
        operationNotSupportedForPreset,
        incorrectlyConfigured,
        segmentStartedWithNonSyncSample,
        rosettaNotInstalled,
        addMovieHeaderToDestination,
        truncateDestinationToMovieHeaderOnly
    }
    export enum AVMusicSequenceLoadOptions {
        smfChannelsToTracks,
        scalarCount
    }
    export enum AlignmentOptions {
        alignMinXInward,
        alignMinYInward,
        alignMaxXInward,
        alignMaxYInward,
        alignWidthInward,
        alignHeightInward,
        alignMinXOutward,
        alignMinYOutward,
        alignMaxXOutward,
        alignMaxYOutward,
        alignWidthOutward,
        alignHeightOutward,
        alignMinXNearest,
        alignMinYNearest,
        alignMaxXNearest,
        alignMaxYNearest,
        alignWidthNearest,
        alignHeightNearest,
        alignRectFlipped,
        alignAllEdgesInward,
        alignAllEdgesOutward,
        alignAllEdgesNearest
    }
    export enum AnyObject {
        byteSwapped,
        scalarCount,
        assureMemoryNow,
        alwaysCopyData,
        dontOptimizeDepth,
        permitEmptyReference
    }
    export enum CAAutoresizingMask {
        layerMinXMargin,
        layerWidthSizable,
        layerMaxXMargin,
        layerMinYMargin,
        layerHeightSizable,
        layerMaxYMargin
    }
    export enum CACornerMask {
        layerMinXMinYCorner,
        layerMaxXMinYCorner,
        layerMinXMaxYCorner,
        layerMaxXMaxYCorner
    }
    export enum CAEdgeAntialiasingMask {
        layerLeftEdge,
        layerRightEdge,
        layerBottomEdge,
        layerTopEdge
    }
    export enum CFCalendarUnit {
        magnitude,
        byteSwapped,
        scalarCount,
        era,
        year,
        month,
        day,
        hour,
        minute,
        second,
        week,
        weekday,
        weekdayOrdinal,
        quarter,
        weekOfMonth,
        weekOfYear,
        yearForWeekOfYear
    }
    export enum CFDataSearchFlags {
        backwards,
        anchored
    }
    export enum CFFileSecurityClearOptions {
        magnitude,
        byteSwapped,
        scalarCount,
        owner,
        group,
        mode,
        ownerUUID,
        groupUUID,
        accessControlList
    }
    export enum CFGregorianUnitFlags {
        unitsYears,
        unitsMonths,
        unitsDays,
        unitsHours,
        unitsMinutes,
        unitsSeconds,
        allUnits
    }
    export enum CFISO8601DateFormatOptions {
        byteSwapped,
        scalarCount,
        withYear,
        withMonth,
        withWeekOfYear,
        withDay,
        withTime,
        withTimeZone,
        withSpaceBetweenDateAndTime,
        withDashSeparatorInDate,
        withColonSeparatorInTime,
        withColonSeparatorInTimeZone,
        withFractionalSeconds,
        withFullDate,
        withFullTime,
        withInternetDateTime
    }
    export enum CFNumberFormatterOptionFlags {
        magnitude,
        byteSwapped,
        scalarCount,
        parseIntegersOnly
    }
    export enum CFPropertyListMutabilityOptions {
        byteSwapped,
        scalarCount,
        mutableContainers,
        mutableContainersAndLeaves
    }
    export enum CFRunLoopActivity {
        entry,
        beforeTimers,
        beforeSources,
        beforeWaiting,
        afterWaiting,
        exit,
        allActivities
    }
    export enum CFSocketCallBackType {
        readCallBack,
        acceptCallBack,
        dataCallBack,
        connectCallBack,
        writeCallBack
    }
    export enum CFStreamEventType {
        magnitude,
        byteSwapped,
        scalarCount,
        openCompleted,
        hasBytesAvailable,
        canAcceptBytes,
        errorOccurred,
        endEncountered
    }
    export enum CFStringCompareFlags {
        compareCaseInsensitive,
        compareBackwards,
        compareAnchored,
        compareNonliteral,
        compareLocalized,
        compareNumerically,
        compareDiacriticInsensitive,
        compareWidthInsensitive,
        compareForcedOrdering
    }
    export enum CFStringTokenizerTokenType {
        byteSwapped,
        scalarCount,
        normal,
        hasSubTokensMask,
        hasDerivedSubTokensMask,
        hasHasNumbersMask,
        hasNonLettersMask,
        isCJWordMask
    }
    export enum CFURLBookmarkCreationOptions {
        byteSwapped,
        scalarCount,
        minimalBookmarkMask,
        suitableForBookmarkFile,
        withSecurityScope,
        securityScopeAllowOnlyReadAccess
    }
    export enum CFURLBookmarkResolutionOptions {
        byteSwapped,
        scalarCount,
        cfurlBookmarkResolutionWithoutUIMask,
        cfurlBookmarkResolutionWithoutMountingMask,
        cfurlBookmarkResolutionWithSecurityScope,
        cfBookmarkResolutionWithoutUIMask,
        cfBookmarkResolutionWithoutMountingMask
    }
    export enum CFURLEnumeratorOptions {
        descendRecursively,
        skipInvisibles,
        generateFileReferenceURLs,
        skipPackageContents,
        includeDirectoriesPreOrder,
        includeDirectoriesPostOrder,
        generateRelativePathURLs
    }
    export enum CFXMLParserOptions {
        validateDocument,
        skipMetaData,
        replacePhysicalEntities,
        skipWhitespace,
        resolveExternalEntities,
        addImpliedAttributes,
        allOptions
    }
    export enum CFXMLParserStatusCode {
        statusParseNotBegun,
        statusParseInProgress,
        errorUnexpectedEOF,
        errorUnknownEncoding,
        errorEncodingConversionFailure,
        errorMalformedProcessingInstruction,
        errorMalformedDTD,
        errorMalformedName,
        errorMalformedCDSect,
        errorMalformedCloseTag,
        errorMalformedStartTag,
        errorMalformedDocument,
        errorElementlessDocument,
        errorMalformedComment,
        errorMalformedCharacterReference,
        errorMalformedParsedCharacterData,
        errorNoData
    }
    export enum CGBitmapInfo {
        alphaInfoMask,
        floatInfoMask,
        floatComponents,
        byteOrderMask,
        byteOrder16Little,
        byteOrder32Little,
        byteOrder16Big,
        byteOrder32Big
    }
    export enum CGCaptureOptions {
        byteSwapped,
        scalarCount,
        noFill
    }
    export enum CGConfigureOption {
        byteSwapped,
        scalarCount,
        forAppOnly,
        forSession,
        permanently
    }
    export enum CGDisplayChangeSummaryFlags {
        byteSwapped,
        scalarCount,
        beginConfigurationFlag,
        movedFlag,
        setMainFlag,
        setModeFlag,
        addFlag,
        removeFlag,
        enabledFlag,
        disabledFlag,
        mirrorFlag,
        unMirrorFlag,
        desktopShapeChangedFlag
    }
    export enum CGEventFilterMask {
        byteSwapped,
        scalarCount,
        permitLocalMouseEvents,
        permitLocalKeyboardEvents,
        permitSystemDefinedEvents
    }
    export enum CGEventFlags {
        maskAlphaShift,
        maskShift,
        maskControl,
        maskAlternate,
        maskCommand,
        maskHelp,
        maskSecondaryFn,
        maskNumericPad,
        maskNonCoalesced
    }
    export enum CGGradientDrawingOptions {
        byteSwapped,
        scalarCount,
        drawsBeforeStartLocation,
        drawsAfterEndLocation
    }
    export enum CGPDFAccessPermissions {
        byteSwapped,
        scalarCount,
        allowsLowQualityPrinting,
        allowsHighQualityPrinting,
        allowsDocumentChanges,
        allowsDocumentAssembly,
        allowsContentCopying,
        allowsContentAccessibility,
        allowsCommenting,
        allowsFormFieldEntry
    }
    export enum CGScreenUpdateOperation {
        byteSwapped,
        scalarCount,
        refresh,
        move,
        reducedDirtyRectangleCount
    }
    export enum CGWindowImageOption {
        byteSwapped,
        scalarCount,
        boundsIgnoreFraming,
        shouldBeOpaque,
        onlyShadows,
        bestResolution,
        nominalResolution
    }
    export enum CGWindowListOption {
        magnitude,
        byteSwapped,
        scalarCount,
        optionAll,
        optionOnScreenOnly,
        optionOnScreenAboveWindow,
        optionOnScreenBelowWindow,
        optionIncludingWindow,
        excludeDesktopElements
    }
    export enum CKContainer_Application_Permissions {
        userDiscoverability
    }
    export enum CMSampleBuffer {
        audioBufferListAssure16ByteAlignment
    }
    export enum CMTimeFlags {
        magnitude,
        byteSwapped,
        scalarCount,
        valid,
        hasBeenRounded,
        positiveInfinity,
        negativeInfinity,
        indefinite,
        impliedValueFlagsMask
    }
    export enum Character {
        request,
        session,
        ascii,
        nextstep,
        japaneseEUC,
        utf8,
        isoLatin1,
        symbol,
        nonLossyASCII,
        shiftJIS,
        isoLatin2,
        unicode,
        windowsCP1251,
        windowsCP1252,
        windowsCP1253,
        windowsCP1254,
        windowsCP1250,
        iso2022JP,
        macOSRoman,
        utf16,
        utf16BigEndian,
        utf16LittleEndian,
        utf32,
        utf32BigEndian,
        utf32LittleEndian
    }
    export enum Data {
        video,
        audio,
        muxed,
        text,
        closedCaption,
        subtitle,
        timeCode,
        metadata,
        linearPCM,
        ac3,
        iec60958AC3,
        appleIMA4,
        mpeg4AAC,
        mpeg4CELP,
        mpeg4HVXC,
        mpeg4TwinVQ,
        mace3,
        mace6,
        uLaw,
        aLaw,
        qDesign,
        qDesign2,
        qualcomm,
        mpegLayer1,
        mpegLayer2,
        mpegLayer3,
        midiStream,
        parameterValueStream,
        appleLossless,
        mpeg4AAC_HE,
        mpeg4AAC_LD,
        mpeg4AAC_ELD,
        mpeg4AAC_ELD_SBR,
        mpeg4AAC_ELD_V2,
        mpeg4AAC_HE_V2,
        mpeg4AAC_Spatial,
        mpegD_USAC,
        amr,
        amr_WB,
        audible,
        iLBC,
        dviIntelIMA,
        microsoftGSM,
        aes3,
        enhancedAC3,
        flac,
        opus,
        aacLCProtected,
        aacAudibleProtected,
        pixelFormat_32ARGB,
        pixelFormat_32BGRA,
        pixelFormat_24RGB,
        pixelFormat_16BE555,
        pixelFormat_16BE565,
        pixelFormat_16LE555,
        pixelFormat_16LE565,
        pixelFormat_16LE5551,
        pixelFormat_422YpCbCr8,
        pixelFormat_422YpCbCr8_yuvs,
        pixelFormat_444YpCbCr8,
        pixelFormat_4444YpCbCrA8,
        pixelFormat_422YpCbCr16,
        pixelFormat_422YpCbCr10,
        pixelFormat_444YpCbCr10,
        pixelFormat_8IndexedGray_WhiteIsZero,
        animation,
        cinepak,
        jpeg,
        jpeg_OpenDML,
        sorensonVideo,
        sorensonVideo3,
        h263,
        h264,
        hevc,
        hevcWithAlpha,
        mpeg4Video,
        mpeg2Video,
        mpeg1Video,
        dvcNTSC,
        dvcPAL,
        dvcProPAL,
        dvcPro50NTSC,
        dvcPro50PAL,
        dvcPROHD720p60,
        dvcPROHD720p50,
        dvcPROHD1080i60,
        dvcPROHD1080i50,
        dvcPROHD1080p30,
        dvcPROHD1080p25,
        proRes4444XQ,
        proRes4444,
        proRes422HQ,
        proRes422,
        proRes422LT,
        proRes422Proxy,
        proResRAW,
        proResRAWHQ,
        mpeg1System,
        mpeg2Transport,
        mpeg2Program,
        dv,
        cea608,
        cea708,
        atsc,
        qt,
        mobile3GPP,
        webVTT,
        timeCode32,
        timeCode64,
        counter32,
        counter64,
        icy,
        id3,
        boxed,
        emsg,
        streamBasicDescription,
        magicCookie,
        channelLayout,
        extensions,
        all,
        startIndex,
        endIndex
    }
    export enum Int {
        byteSwapped,
        scalarCount
    }
    export enum NSBinarySearchingOptions {
        firstEqual,
        lastEqual,
        insertionIndex
    }
    export enum NSDirectionalRectEdge {
        top,
        leading,
        bottom,
        trailing,
        all
    }
    export enum NSDragOperation {
        copy,
        link,
        generic,
        private,
        move,
        delete,
        every,
        all_Obsolete,
        all
    }
    export enum NSDraggingItemEnumerationOptions {
        concurrent,
        clearNonenumeratedImages
    }
    export enum NSEnumerationOptions {
        concurrent,
        reverse
    }
    export enum NSFontCollectionOptions {
        applicationOnlyMask
    }
    export enum NSFontTraitMask {
        byteSwapped,
        scalarCount,
        italicFontMask,
        boldFontMask,
        unboldFontMask,
        nonStandardCharacterSetFontMask,
        narrowFontMask,
        expandedFontMask,
        condensedFontMask,
        smallCapsFontMask,
        posterFontMask,
        compressedFontMask,
        fixedPitchFontMask,
        unitalicFontMask
    }
    export enum NSItemProviderFileOptions {
        openInPlace
    }
    export enum NSKeyValueObservingOptions {
        new,
        old,
        initial,
        prior
    }
    export enum NSOrderedCollectionDifferenceCalculationOptions {
        magnitude,
        timeInterval,
        hashValue,
        omitInsertedObjects,
        omitRemovedObjects,
        inferMoves
    }
    export enum NSSortOptions {
        magnitude,
        byteSwapped,
        scalarCount,
        concurrent,
        stable
    }
    export enum NSSpringLoadingOptions {
        disabled,
        enabled,
        continuousActivation,
        noHover
    }
    export enum NSTextStorageEditActions {
        editedAttributes,
        editedCharacters
    }
    export enum NSTypesetterControlCharacterAction {
        magnitude,
        byteSwapped,
        scalarCount,
        zeroAdvancementAction,
        whitespaceAction,
        horizontalTabAction,
        lineBreakAction,
        paragraphBreakAction,
        containerBreakAction
    }
    export enum NSUnderlineStyle {
        single,
        thick,
        double,
        patternDot,
        patternDash,
        patternDashDot,
        patternDashDotDot,
        byWord
    }
    export enum UInt {
        magnitude,
        byteSwapped,
        scalarCount,
        hashValue,
        bitWidth,
        leadingZeroBitCount,
        trailingZeroBitCount,
        nonzeroBitCount,
        count,
        startIndex,
        endIndex,
        indices,
        words
    }
    export enum UInt8 {
        regions,
        startIndex,
        endIndex,
        indices,
        hashValue,
        autoupdatingCurrent,
        current
    }
    export enum NSAccessibilityPriorityLevel {
        Low = 10,
        Medium = 50,
        High = 90
    }
    export enum NSAnimationEffect {
        DisappearingItemDefault = 0,
        Poof = 10
    }
    export enum NSBorderType {
        NoBorder = 0,
        LineBorder = 1,
        BezelBorder = 2,
        GrooveBorder = 3
    }
    export enum NSCharacterCollection {
        IdentityMappingCharacterCollection = 0,
        AdobeCNS1CharacterCollection = 1,
        AdobeGB1CharacterCollection = 2,
        AdobeJapan1CharacterCollection = 3,
        AdobeJapan2CharacterCollection = 4,
        AdobeKorea1CharacterCollection = 5
    }
    export enum NSCollectionElementCategory {
        Item = 0,
        SupplementaryView = 1,
        DecorationView = 2,
        InterItemGap = 3
    }
    export enum NSCollectionLayoutSectionOrthogonalScrollingBehavior {
        None = 0,
        Continuous = 1,
        ContinuousGroupLeadingBoundary = 2,
        Paging = 3,
        GroupPaging = 4,
        GroupPagingCentered = 5
    }
    export enum NSColorRenderingIntent {
        Default = 0,
        AbsoluteColorimetric = 1,
        RelativeColorimetric = 2,
        Perceptual = 3,
        Saturation = 4
    }
    export enum NSCompositingOperation {
        Clear = 0,
        Copy = 1,
        SourceOver = 2,
        SourceIn = 3,
        SourceOut = 4,
        SourceAtop = 5,
        DestinationOver = 6,
        DestinationIn = 7,
        DestinationOut = 8,
        DestinationAtop = 9,
        XOR = 10,
        PlusDarker = 11,
        Highlight = 12,
        PlusLighter = 13,
        Multiply = 14,
        Screen = 15,
        Overlay = 16,
        Darken = 17,
        Lighten = 18,
        ColorDodge = 19,
        ColorBurn = 20,
        SoftLight = 21,
        HardLight = 22,
        Difference = 23,
        Exclusion = 24,
        Hue = 25,
        Saturation = 26,
        Color = 27,
        Luminosity = 28
    }
    export enum NSControlTint {
        DefaultControlTint = 0,
        BlueControlTint = 1,
        GraphiteControlTint = 6,
        ClearControlTint = 7
    }
    export enum NSDirectionalRectEdge {
        None = 0,
        Top = 1,
        Leading = 2,
        Bottom = 4,
        Trailing = 8,
        All = 15
    }
    export enum NSDisplayGamut {
        SRGB = 1,
        P3 = 2
    }
    export enum NSDragOperation {
        None = 0,
        Copy = 1,
        Link = 2,
        Generic = 4,
        Private = 8,
        Move = 16,
        Delete = 32,
        Every = -1,
        All_Obsolete = 15,
        All = 15
    }
    export enum NSDraggingContext {
        OutsideApplication = 0,
        WithinApplication = 1
    }
    export enum NSDraggingFormation {
        Default = 0,
        None = 1,
        Pile = 2,
        List = 3,
        Stack = 4
    }
    export enum NSDraggingItemEnumerationOptions {
        Concurrent = 1,
        ClearNonenumeratedImages = 65536
    }
    export enum NSFindPanelAction {
        ShowFindPanel = 1,
        Next = 2,
        Previous = 3,
        ReplaceAll = 4,
        Replace = 5,
        ReplaceAndFind = 6,
        SetFindString = 7,
        ReplaceAllInSelection = 8,
        SelectAll = 9,
        SelectAllInSelection = 10
    }
    export enum NSFindPanelSubstringMatchType {
        Contains = 0,
        StartsWith = 1,
        FullWord = 2,
        EndsWith = 3
    }
    export enum NSFocusRingPlacement {
        Only = 0,
        Below = 1,
        Above = 2
    }
    export enum NSFocusRingType {
        Default = 0,
        None = 1,
        Exterior = 2
    }
    export enum NSFontAction {
        NoFontChangeAction = 0,
        ViaPanelFontAction = 1,
        AddTraitFontAction = 2,
        SizeUpFontAction = 3,
        SizeDownFontAction = 4,
        HeavierFontAction = 5,
        LighterFontAction = 6,
        RemoveTraitFontAction = 7
    }
    export enum NSFontCollectionOptions {
        ApplicationOnlyMask = 1
    }
    export enum NSFontRenderingMode {
        DefaultRenderingMode = 0,
        AntialiasedRenderingMode = 1,
        IntegerAdvancementsRenderingMode = 2,
        AntialiasedIntegerAdvancementsRenderingMode = 3
    }
    export enum NSFontTraitMask {
        ItalicFontMask = 1,
        BoldFontMask = 2,
        UnboldFontMask = 4,
        NonStandardCharacterSetFontMask = 8,
        NarrowFontMask = 16,
        ExpandedFontMask = 32,
        CondensedFontMask = 64,
        SmallCapsFontMask = 128,
        PosterFontMask = 256,
        CompressedFontMask = 512,
        FixedPitchFontMask = 1024,
        UnitalicFontMask = 16777216
    }
    export enum NSImageAlignment {
        Center = 0,
        Top = 1,
        TopLeft = 2,
        TopRight = 3,
        Left = 4,
        Bottom = 5,
        BottomLeft = 6,
        BottomRight = 7,
        Right = 8
    }
    export enum NSImageInterpolation {
        Default = 0,
        None = 1,
        Low = 2,
        Medium = 4,
        High = 3
    }
    export enum NSImageScaling {
        ImageScaleProportionallyDown = 0,
        ImageScaleAxesIndependently = 1,
        ImageScaleNone = 2,
        ImageScaleProportionallyUpOrDown = 3,
        ScaleProportionally = 0,
        ScaleToFit = 1,
        ScaleNone = 2
    }
    export enum NSLineBreakMode {
        ByWordWrapping = 0,
        ByCharWrapping = 1,
        ByClipping = 2,
        ByTruncatingHead = 3,
        ByTruncatingTail = 4,
        ByTruncatingMiddle = 5
    }
    export enum NSLineMovementDirection {
        DoesntMove = 0,
        MovesLeft = 1,
        MovesRight = 2,
        MovesDown = 3,
        MovesUp = 4
    }
    export enum NSLineSweepDirection {
        Left = 0,
        Right = 1,
        Down = 2,
        Up = 3
    }
    export enum NSRectAlignment {
        None = 0,
        Top = 1,
        TopLeading = 2,
        Leading = 3,
        BottomLeading = 4,
        Bottom = 5,
        BottomTrailing = 6,
        Trailing = 7,
        TopTrailing = 8
    }
    export enum NSSelectionAffinity {
        Upstream = 0,
        Downstream = 1
    }
    export enum NSSelectionGranularity {
        ByCharacter = 0,
        ByWord = 1,
        ByParagraph = 2
    }
    export enum NSSpringLoadingHighlight {
        None = 0,
        Standard = 1,
        Emphasized = 2
    }
    export enum NSSpringLoadingOptions {
        Disabled = 0,
        Enabled = 1,
        ContinuousActivation = 2,
        NoHover = 8
    }
    export enum NSTextAlignment {
        Left = 0,
        Right = 1,
        Center = 2,
        Justified = 3,
        Natural = 4
    }
    export enum NSTextInputTraitType {
        Default = 0,
        No = 1,
        Yes = 2
    }
    export enum NSTextMovement {
        Return = 16,
        Tab = 17,
        Backtab = 18,
        Left = 19,
        Right = 20,
        Up = 21,
        Down = 22,
        Cancel = 23,
        Other = 0
    }
    export enum NSTextScalingType {
        Standard = 0,
        iOS = 1
    }
    export enum NSTextStorageEditActions {
        EditedAttributes = 1,
        EditedCharacters = 2
    }
    export enum NSTypesetterControlCharacterAction {
        ZeroAdvancementAction = 1,
        WhitespaceAction = 2,
        HorizontalTabAction = 4,
        LineBreakAction = 8,
        ParagraphBreakAction = 16,
        ContainerBreakAction = 32
    }
    export enum NSUnderlineStyle {
        None = 0,
        Single = 1,
        Thick = 2,
        Double = 9,
        PatternSolid = 0,
        PatternDot = 256,
        PatternDash = 512,
        PatternDashDot = 768,
        PatternDashDotDot = 1024,
        ByWord = 32768
    }
    export enum NSUserInterfaceLayoutDirection {
        LeftToRight = 0,
        RightToLeft = 1
    }
    export enum NSUserInterfaceLayoutOrientation {
        Horizontal = 0,
        Vertical = 1
    }
    export enum NSWritingDirection {
        Natural = -1,
        LeftToRight = 0,
        RightToLeft = 1
    }
    export enum NSWritingDirectionFormatType {
        Embedding = 0,
        Override = 2
    }
    export enum CFCalendarUnit {
        kCFCalendarUnitEra = 2,
        kCFCalendarUnitYear = 4,
        kCFCalendarUnitMonth = 8,
        kCFCalendarUnitDay = 16,
        kCFCalendarUnitHour = 32,
        kCFCalendarUnitMinute = 64,
        kCFCalendarUnitSecond = 128,
        kCFCalendarUnitWeek = 256,
        kCFCalendarUnitWeekday = 512,
        kCFCalendarUnitWeekdayOrdinal = 1024,
        kCFCalendarUnitQuarter = 2048,
        kCFCalendarUnitWeekOfMonth = 4096,
        kCFCalendarUnitWeekOfYear = 8192,
        kCFCalendarUnitYearForWeekOfYear = 16384
    }
    export enum CFCharacterSetPredefinedSet {
        kCFCharacterSetControl = 1,
        kCFCharacterSetWhitespace = 2,
        kCFCharacterSetWhitespaceAndNewline = 3,
        kCFCharacterSetDecimalDigit = 4,
        kCFCharacterSetLetter = 5,
        kCFCharacterSetLowercaseLetter = 6,
        kCFCharacterSetUppercaseLetter = 7,
        kCFCharacterSetNonBase = 8,
        kCFCharacterSetDecomposable = 9,
        kCFCharacterSetAlphaNumeric = 10,
        kCFCharacterSetPunctuation = 11,
        kCFCharacterSetCapitalizedLetter = 13,
        kCFCharacterSetSymbol = 14,
        kCFCharacterSetNewline = 15,
        kCFCharacterSetIllegal = 12
    }
    export enum CFComparisonResult {
        kCFCompareLessThan = -1,
        kCFCompareEqualTo = 0,
        kCFCompareGreaterThan = 1
    }
    export enum CFDataSearchFlags {
        kCFDataSearchBackwards = 1,
        kCFDataSearchAnchored = 2
    }
    export enum CFDateFormatterStyle {
        kCFDateFormatterNoStyle = 0,
        kCFDateFormatterShortStyle = 1,
        kCFDateFormatterMediumStyle = 2,
        kCFDateFormatterLongStyle = 3,
        kCFDateFormatterFullStyle = 4
    }
    export enum CFFileSecurityClearOptions {
        kCFFileSecurityClearOwner = 1,
        kCFFileSecurityClearGroup = 2,
        kCFFileSecurityClearMode = 4,
        kCFFileSecurityClearOwnerUUID = 8,
        kCFFileSecurityClearGroupUUID = 16,
        kCFFileSecurityClearAccessControlList = 32
    }
    export enum CFGregorianUnitFlags {
        kCFGregorianUnitsYears = 1,
        kCFGregorianUnitsMonths = 2,
        kCFGregorianUnitsDays = 4,
        kCFGregorianUnitsHours = 8,
        kCFGregorianUnitsMinutes = 16,
        kCFGregorianUnitsSeconds = 32,
        kCFGregorianAllUnits = 16777215
    }
    export enum CFISO8601DateFormatOptions {
        kCFISO8601DateFormatWithYear = 1,
        kCFISO8601DateFormatWithMonth = 2,
        kCFISO8601DateFormatWithWeekOfYear = 4,
        kCFISO8601DateFormatWithDay = 16,
        kCFISO8601DateFormatWithTime = 32,
        kCFISO8601DateFormatWithTimeZone = 64,
        kCFISO8601DateFormatWithSpaceBetweenDateAndTime = 128,
        kCFISO8601DateFormatWithDashSeparatorInDate = 256,
        kCFISO8601DateFormatWithColonSeparatorInTime = 512,
        kCFISO8601DateFormatWithColonSeparatorInTimeZone = 1024,
        kCFISO8601DateFormatWithFractionalSeconds = 2048,
        kCFISO8601DateFormatWithFullDate = 275,
        kCFISO8601DateFormatWithFullTime = 1632,
        kCFISO8601DateFormatWithInternetDateTime = 1907
    }
    export enum CFLocaleLanguageDirection {
        kCFLocaleLanguageDirectionUnknown = 0,
        kCFLocaleLanguageDirectionLeftToRight = 1,
        kCFLocaleLanguageDirectionRightToLeft = 2,
        kCFLocaleLanguageDirectionTopToBottom = 3,
        kCFLocaleLanguageDirectionBottomToTop = 4
    }
    export enum CFNotificationSuspensionBehavior {
        Drop = 1,
        Coalesce = 2,
        Hold = 3,
        DeliverImmediately = 4
    }
    export enum CFNumberFormatterOptionFlags {
        kCFNumberFormatterParseIntegersOnly = 1
    }
    export enum CFNumberFormatterPadPosition {
        kCFNumberFormatterPadBeforePrefix = 0,
        kCFNumberFormatterPadAfterPrefix = 1,
        kCFNumberFormatterPadBeforeSuffix = 2,
        kCFNumberFormatterPadAfterSuffix = 3
    }
    export enum CFNumberFormatterRoundingMode {
        kCFNumberFormatterRoundCeiling = 0,
        kCFNumberFormatterRoundFloor = 1,
        kCFNumberFormatterRoundDown = 2,
        kCFNumberFormatterRoundUp = 3,
        kCFNumberFormatterRoundHalfEven = 4,
        kCFNumberFormatterRoundHalfDown = 5,
        kCFNumberFormatterRoundHalfUp = 6
    }
    export enum CFNumberFormatterStyle {
        kCFNumberFormatterNoStyle = 0,
        kCFNumberFormatterDecimalStyle = 1,
        kCFNumberFormatterCurrencyStyle = 2,
        kCFNumberFormatterPercentStyle = 3,
        kCFNumberFormatterScientificStyle = 4,
        kCFNumberFormatterSpellOutStyle = 5,
        kCFNumberFormatterOrdinalStyle = 6,
        kCFNumberFormatterCurrencyISOCodeStyle = 8,
        kCFNumberFormatterCurrencyPluralStyle = 9,
        kCFNumberFormatterCurrencyAccountingStyle = 10
    }
    export enum CFNumberType {
        kCFNumberSInt8Type = 1,
        kCFNumberSInt16Type = 2,
        kCFNumberSInt32Type = 3,
        kCFNumberSInt64Type = 4,
        kCFNumberFloat32Type = 5,
        kCFNumberFloat64Type = 6,
        kCFNumberCharType = 7,
        kCFNumberShortType = 8,
        kCFNumberIntType = 9,
        kCFNumberLongType = 10,
        kCFNumberLongLongType = 11,
        kCFNumberFloatType = 12,
        kCFNumberDoubleType = 13,
        kCFNumberCFIndexType = 14,
        kCFNumberNSIntegerType = 15,
        kCFNumberCGFloatType = 16,
        kCFNumberMaxType = 16
    }
    export enum CFPropertyListFormat {
        kCFPropertyListOpenStepFormat = 1,
        kCFPropertyListXMLFormat_v1_0 = 100,
        kCFPropertyListBinaryFormat_v1_0 = 200
    }
    export enum CFPropertyListMutabilityOptions {
        kCFPropertyListImmutable = 0,
        kCFPropertyListMutableContainers = 1,
        kCFPropertyListMutableContainersAndLeaves = 2
    }
    export enum CFRunLoopActivity {
        kCFRunLoopEntry = 1,
        kCFRunLoopBeforeTimers = 2,
        kCFRunLoopBeforeSources = 4,
        kCFRunLoopBeforeWaiting = 32,
        kCFRunLoopAfterWaiting = 64,
        kCFRunLoopExit = 128,
        kCFRunLoopAllActivities = 268435455
    }
    export enum CFRunLoopRunResult {
        kCFRunLoopRunFinished = 1,
        kCFRunLoopRunStopped = 2,
        kCFRunLoopRunTimedOut = 3,
        kCFRunLoopRunHandledSource = 4
    }
    export enum CFSocketCallBackType {
        kCFSocketNoCallBack = 0,
        kCFSocketReadCallBack = 1,
        kCFSocketAcceptCallBack = 2,
        kCFSocketDataCallBack = 3,
        kCFSocketConnectCallBack = 4,
        kCFSocketWriteCallBack = 8
    }
    export enum CFSocketError {
        kCFSocketSuccess = 0,
        kCFSocketError = -1,
        kCFSocketTimeout = -2
    }
    export enum CFStreamErrorDomain {
        kCFStreamErrorDomainCustom = -1,
        kCFStreamErrorDomainPOSIX = 1,
        kCFStreamErrorDomainMacOSStatus = 2
    }
    export enum CFStreamEventType {
        kCFStreamEventNone = 0,
        kCFStreamEventOpenCompleted = 1,
        kCFStreamEventHasBytesAvailable = 2,
        kCFStreamEventCanAcceptBytes = 4,
        kCFStreamEventErrorOccurred = 8,
        kCFStreamEventEndEncountered = 16
    }
    export enum CFStreamStatus {
        kCFStreamStatusNotOpen = 0,
        kCFStreamStatusOpening = 1,
        kCFStreamStatusOpen = 2,
        kCFStreamStatusReading = 3,
        kCFStreamStatusWriting = 4,
        kCFStreamStatusAtEnd = 5,
        kCFStreamStatusClosed = 6,
        kCFStreamStatusError = 7
    }
    export enum CFStringBuiltInEncodings {
        kCFStringEncodingMacRoman = 0,
        kCFStringEncodingWindowsLatin1 = 1280,
        kCFStringEncodingISOLatin1 = 513,
        kCFStringEncodingNextStepLatin = 2817,
        kCFStringEncodingASCII = 1536,
        kCFStringEncodingUnicode = 256,
        kCFStringEncodingUTF8 = 134217984,
        kCFStringEncodingNonLossyASCII = 3071,
        kCFStringEncodingUTF16 = 256,
        kCFStringEncodingUTF16BE = 268435712,
        kCFStringEncodingUTF16LE = 335544576,
        kCFStringEncodingUTF32 = 201326848,
        kCFStringEncodingUTF32BE = 402653440,
        kCFStringEncodingUTF32LE = 469762304
    }
    export enum CFStringCompareFlags {
        kCFCompareCaseInsensitive = 1,
        kCFCompareBackwards = 4,
        kCFCompareAnchored = 8,
        kCFCompareNonliteral = 16,
        kCFCompareLocalized = 32,
        kCFCompareNumerically = 64,
        kCFCompareDiacriticInsensitive = 128,
        kCFCompareWidthInsensitive = 256,
        kCFCompareForcedOrdering = 512
    }
    export enum CFStringEncodings {
        kCFStringEncodingMacJapanese = 1,
        kCFStringEncodingMacChineseTrad = 2,
        kCFStringEncodingMacKorean = 3,
        kCFStringEncodingMacArabic = 4,
        kCFStringEncodingMacHebrew = 5,
        kCFStringEncodingMacGreek = 6,
        kCFStringEncodingMacCyrillic = 7,
        kCFStringEncodingMacDevanagari = 9,
        kCFStringEncodingMacGurmukhi = 10,
        kCFStringEncodingMacGujarati = 11,
        kCFStringEncodingMacOriya = 12,
        kCFStringEncodingMacBengali = 13,
        kCFStringEncodingMacTamil = 14,
        kCFStringEncodingMacTelugu = 15,
        kCFStringEncodingMacKannada = 16,
        kCFStringEncodingMacMalayalam = 17,
        kCFStringEncodingMacSinhalese = 18,
        kCFStringEncodingMacBurmese = 19,
        kCFStringEncodingMacKhmer = 20,
        kCFStringEncodingMacThai = 21,
        kCFStringEncodingMacLaotian = 22,
        kCFStringEncodingMacGeorgian = 23,
        kCFStringEncodingMacArmenian = 24,
        kCFStringEncodingMacChineseSimp = 25,
        kCFStringEncodingMacTibetan = 26,
        kCFStringEncodingMacMongolian = 27,
        kCFStringEncodingMacEthiopic = 28,
        kCFStringEncodingMacCentralEurRoman = 29,
        kCFStringEncodingMacVietnamese = 30,
        kCFStringEncodingMacExtArabic = 31,
        kCFStringEncodingMacSymbol = 33,
        kCFStringEncodingMacDingbats = 34,
        kCFStringEncodingMacTurkish = 35,
        kCFStringEncodingMacCroatian = 36,
        kCFStringEncodingMacIcelandic = 37,
        kCFStringEncodingMacRomanian = 38,
        kCFStringEncodingMacCeltic = 39,
        kCFStringEncodingMacGaelic = 40,
        kCFStringEncodingMacFarsi = 140,
        kCFStringEncodingMacUkrainian = 152,
        kCFStringEncodingMacInuit = 236,
        kCFStringEncodingMacVT100 = 252,
        kCFStringEncodingMacHFS = 255,
        kCFStringEncodingISOLatin2 = 514,
        kCFStringEncodingISOLatin3 = 515,
        kCFStringEncodingISOLatin4 = 516,
        kCFStringEncodingISOLatinCyrillic = 517,
        kCFStringEncodingISOLatinArabic = 518,
        kCFStringEncodingISOLatinGreek = 519,
        kCFStringEncodingISOLatinHebrew = 520,
        kCFStringEncodingISOLatin5 = 521,
        kCFStringEncodingISOLatin6 = 522,
        kCFStringEncodingISOLatinThai = 523,
        kCFStringEncodingISOLatin7 = 525,
        kCFStringEncodingISOLatin8 = 526,
        kCFStringEncodingISOLatin9 = 527,
        kCFStringEncodingISOLatin10 = 528,
        kCFStringEncodingDOSLatinUS = 1024,
        kCFStringEncodingDOSGreek = 1029,
        kCFStringEncodingDOSBalticRim = 1030,
        kCFStringEncodingDOSLatin1 = 1040,
        kCFStringEncodingDOSGreek1 = 1041,
        kCFStringEncodingDOSLatin2 = 1042,
        kCFStringEncodingDOSCyrillic = 1043,
        kCFStringEncodingDOSTurkish = 1044,
        kCFStringEncodingDOSPortuguese = 1045,
        kCFStringEncodingDOSIcelandic = 1046,
        kCFStringEncodingDOSHebrew = 1047,
        kCFStringEncodingDOSCanadianFrench = 1048,
        kCFStringEncodingDOSArabic = 1049,
        kCFStringEncodingDOSNordic = 1050,
        kCFStringEncodingDOSRussian = 1051,
        kCFStringEncodingDOSGreek2 = 1052,
        kCFStringEncodingDOSThai = 1053,
        kCFStringEncodingDOSJapanese = 1056,
        kCFStringEncodingDOSChineseSimplif = 1057,
        kCFStringEncodingDOSKorean = 1058,
        kCFStringEncodingDOSChineseTrad = 1059,
        kCFStringEncodingWindowsLatin2 = 1281,
        kCFStringEncodingWindowsCyrillic = 1282,
        kCFStringEncodingWindowsGreek = 1283,
        kCFStringEncodingWindowsLatin5 = 1284,
        kCFStringEncodingWindowsHebrew = 1285,
        kCFStringEncodingWindowsArabic = 1286,
        kCFStringEncodingWindowsBalticRim = 1287,
        kCFStringEncodingWindowsVietnamese = 1288,
        kCFStringEncodingWindowsKoreanJohab = 1296,
        kCFStringEncodingANSEL = 1537,
        kCFStringEncodingJIS_X0201_76 = 1568,
        kCFStringEncodingJIS_X0208_83 = 1569,
        kCFStringEncodingJIS_X0208_90 = 1570,
        kCFStringEncodingJIS_X0212_90 = 1571,
        kCFStringEncodingJIS_C6226_78 = 1572,
        kCFStringEncodingShiftJIS_X0213 = 1576,
        kCFStringEncodingShiftJIS_X0213_MenKuTen = 1577,
        kCFStringEncodingGB_2312_80 = 1584,
        kCFStringEncodingGBK_95 = 1585,
        kCFStringEncodingGB_18030_2000 = 1586,
        kCFStringEncodingKSC_5601_87 = 1600,
        kCFStringEncodingKSC_5601_92_Johab = 1601,
        kCFStringEncodingCNS_11643_92_P1 = 1617,
        kCFStringEncodingCNS_11643_92_P2 = 1618,
        kCFStringEncodingCNS_11643_92_P3 = 1619,
        kCFStringEncodingISO_2022_JP = 2080,
        kCFStringEncodingISO_2022_JP_2 = 2081,
        kCFStringEncodingISO_2022_JP_1 = 2082,
        kCFStringEncodingISO_2022_JP_3 = 2083,
        kCFStringEncodingISO_2022_CN = 2096,
        kCFStringEncodingISO_2022_CN_EXT = 2097,
        kCFStringEncodingISO_2022_KR = 2112,
        kCFStringEncodingEUC_JP = 2336,
        kCFStringEncodingEUC_CN = 2352,
        kCFStringEncodingEUC_TW = 2353,
        kCFStringEncodingEUC_KR = 2368,
        kCFStringEncodingShiftJIS = 2561,
        kCFStringEncodingKOI8_R = 2562,
        kCFStringEncodingBig5 = 2563,
        kCFStringEncodingMacRomanLatin1 = 2564,
        kCFStringEncodingHZ_GB_2312 = 2565,
        kCFStringEncodingBig5_HKSCS_1999 = 2566,
        kCFStringEncodingVISCII = 2567,
        kCFStringEncodingKOI8_U = 2568,
        kCFStringEncodingBig5_E = 2569,
        kCFStringEncodingNextStepJapanese = 2818,
        kCFStringEncodingEBCDIC_US = 3073,
        kCFStringEncodingEBCDIC_CP037 = 3074,
        kCFStringEncodingUTF7 = 67109120,
        kCFStringEncodingUTF7_IMAP = 2576,
        kCFStringEncodingShiftJIS_X0213_00 = 1576
    }
    export enum CFStringNormalizationForm {
        kCFStringNormalizationFormD = 0,
        kCFStringNormalizationFormKD = 1,
        kCFStringNormalizationFormC = 2,
        kCFStringNormalizationFormKC = 3
    }
    export enum CFStringTokenizerTokenType {
        kCFStringTokenizerTokenNone = 0,
        kCFStringTokenizerTokenNormal = 1,
        kCFStringTokenizerTokenHasSubTokensMask = 2,
        kCFStringTokenizerTokenHasDerivedSubTokensMask = 4,
        kCFStringTokenizerTokenHasHasNumbersMask = 8,
        kCFStringTokenizerTokenHasNonLettersMask = 16,
        kCFStringTokenizerTokenIsCJWordMask = 32
    }
    export enum CFTimeZoneNameStyle {
        kCFTimeZoneNameStyleStandard = 0,
        kCFTimeZoneNameStyleShortStandard = 1,
        kCFTimeZoneNameStyleDaylightSaving = 2,
        kCFTimeZoneNameStyleShortDaylightSaving = 3,
        kCFTimeZoneNameStyleGeneric = 4,
        kCFTimeZoneNameStyleShortGeneric = 5
    }
    export enum CFURLBookmarkCreationOptions {
        kCFURLBookmarkCreationMinimalBookmarkMask = 512,
        kCFURLBookmarkCreationSuitableForBookmarkFile = 1024,
        kCFURLBookmarkCreationWithSecurityScope = 2048,
        kCFURLBookmarkCreationSecurityScopeAllowOnlyReadAccess = 4096,
        kCFURLBookmarkCreationPreferFileIDResolutionMask = 256
    }
    export enum CFURLBookmarkResolutionOptions {
        kCFURLBookmarkResolutionWithoutUIMask = 256,
        kCFURLBookmarkResolutionWithoutMountingMask = 512,
        kCFURLBookmarkResolutionWithSecurityScope = 1024,
        kCFBookmarkResolutionWithoutUIMask = 256,
        kCFBookmarkResolutionWithoutMountingMask = 512
    }
    export enum CFURLComponentType {
        kCFURLComponentScheme = 1,
        kCFURLComponentNetLocation = 2,
        kCFURLComponentPath = 3,
        kCFURLComponentResourceSpecifier = 4,
        kCFURLComponentUser = 5,
        kCFURLComponentPassword = 6,
        kCFURLComponentUserInfo = 7,
        kCFURLComponentHost = 8,
        kCFURLComponentPort = 9,
        kCFURLComponentParameterString = 10,
        kCFURLComponentQuery = 11,
        kCFURLComponentFragment = 12
    }
    export enum CFURLEnumeratorOptions {
        kCFURLEnumeratorDefaultBehavior = 0,
        kCFURLEnumeratorDescendRecursively = 1,
        kCFURLEnumeratorSkipInvisibles = 2,
        kCFURLEnumeratorGenerateFileReferenceURLs = 4,
        kCFURLEnumeratorSkipPackageContents = 8,
        kCFURLEnumeratorIncludeDirectoriesPreOrder = 16,
        kCFURLEnumeratorIncludeDirectoriesPostOrder = 32,
        kCFURLEnumeratorGenerateRelativePathURLs = 64
    }
    export enum CFURLEnumeratorResult {
        kCFURLEnumeratorSuccess = 1,
        kCFURLEnumeratorEnd = 2,
        kCFURLEnumeratorError = 3,
        kCFURLEnumeratorDirectoryPostOrderSuccess = 4
    }
    export enum CFURLPathStyle {
        kCFURLPOSIXPathStyle = 0,
        kCFURLHFSPathStyle = 1,
        kCFURLWindowsPathStyle = 2
    }
    export enum CFXMLEntityTypeCode {
        kCFXMLEntityTypeParameter = 0,
        kCFXMLEntityTypeParsedInternal = 1,
        kCFXMLEntityTypeParsedExternal = 2,
        kCFXMLEntityTypeUnparsed = 3,
        kCFXMLEntityTypeCharacter = 4
    }
    export enum CFXMLNodeTypeCode {
        kCFXMLNodeTypeDocument = 1,
        kCFXMLNodeTypeElement = 2,
        kCFXMLNodeTypeAttribute = 3,
        kCFXMLNodeTypeProcessingInstruction = 4,
        kCFXMLNodeTypeComment = 5,
        kCFXMLNodeTypeText = 6,
        kCFXMLNodeTypeCDATASection = 7,
        kCFXMLNodeTypeDocumentFragment = 8,
        kCFXMLNodeTypeEntity = 9,
        kCFXMLNodeTypeEntityReference = 10,
        kCFXMLNodeTypeDocumentType = 11,
        kCFXMLNodeTypeWhitespace = 12,
        kCFXMLNodeTypeNotation = 13,
        kCFXMLNodeTypeElementTypeDeclaration = 14,
        kCFXMLNodeTypeAttributeListDeclaration = 15
    }
    export enum CFXMLParserOptions {
        kCFXMLParserValidateDocument = 1,
        kCFXMLParserSkipMetaData = 2,
        kCFXMLParserReplacePhysicalEntities = 4,
        kCFXMLParserSkipWhitespace = 8,
        kCFXMLParserResolveExternalEntities = 16,
        kCFXMLParserAddImpliedAttributes = 32,
        kCFXMLParserAllOptions = 16777215,
        kCFXMLParserNoOptions = 0
    }
    export enum CFXMLParserStatusCode {
        kCFXMLStatusParseNotBegun = -2,
        kCFXMLStatusParseInProgress = -1,
        kCFXMLStatusParseSuccessful = 0,
        kCFXMLErrorUnexpectedEOF = 1,
        kCFXMLErrorUnknownEncoding = 2,
        kCFXMLErrorEncodingConversionFailure = 3,
        kCFXMLErrorMalformedProcessingInstruction = 4,
        kCFXMLErrorMalformedDTD = 5,
        kCFXMLErrorMalformedName = 6,
        kCFXMLErrorMalformedCDSect = 7,
        kCFXMLErrorMalformedCloseTag = 8,
        kCFXMLErrorMalformedStartTag = 9,
        kCFXMLErrorMalformedDocument = 10,
        kCFXMLErrorElementlessDocument = 11,
        kCFXMLErrorMalformedComment = 12,
        kCFXMLErrorMalformedCharacterReference = 13,
        kCFXMLErrorMalformedParsedCharacterData = 14,
        kCFXMLErrorNoData = 15
    }
    export enum __CFByteOrder {
        CFByteOrderUnknown = 0,
        CFByteOrderLittleEndian = 1,
        CFByteOrderBigEndian = 2
    }
    export enum AlignmentOptions {
        MinXInward = 1,
        MinYInward = 2,
        MaxXInward = 4,
        MaxYInward = 8,
        WidthInward = 16,
        HeightInward = 32,
        MinXOutward = 256,
        MinYOutward = 512,
        MaxXOutward = 1024,
        MaxYOutward = 2048,
        WidthOutward = 4096,
        HeightOutward = 8192,
        MinXNearest = 65536,
        MinYNearest = 131072,
        MaxXNearest = 262144,
        MaxYNearest = 524288,
        WidthNearest = 1048576,
        HeightNearest = 2097152,
        RectFlipped = -9223372036854776000,
        AllEdgesInward = 15,
        AllEdgesOutward = 3840,
        AllEdgesNearest = 983040
    }
    export enum NSBinarySearchingOptions {
        FirstEqual = 256,
        LastEqual = 512,
        InsertionIndex = 1024
    }
    export enum NSCollectionChangeType {
        Insert = 0,
        Remove = 1
    }
    export enum ComparisonResult {
        OrderedAscending = -1,
        OrderedSame = 0,
        OrderedDescending = 1
    }
    export enum NSEnumerationOptions {
        Concurrent = 1,
        Reverse = 2
    }
    export enum NSItemProviderFileOptions {
        OpenInPlace = 1
    }
    export enum NSItemProviderRepresentationVisibility {
        All = 0,
        Team = 1,
        Group = 2,
        OwnProcess = 3
    }
    export enum NSKeyValueChange {
        Setting = 1,
        Insertion = 2,
        Removal = 3,
        Replacement = 4
    }
    export enum NSKeyValueObservingOptions {
        New = 1,
        Old = 2,
        Initial = 4,
        Prior = 8
    }
    export enum NSKeyValueSetMutationKind {
        UnionSetMutation = 1,
        MinusSetMutation = 2,
        IntersectSetMutation = 3,
        SetSetMutation = 4
    }
    export enum NSLinguisticTaggerUnit {
        Word = 0,
        Sentence = 1,
        Paragraph = 2,
        Document = 3
    }
    export enum NSOrderedCollectionDifferenceCalculationOptions {
        OmitInsertedObjects = 1,
        OmitRemovedObjects = 2,
        InferMoves = 4
    }
    export enum QualityOfService {
        UserInteractive = 33,
        UserInitiated = 25,
        Utility = 17,
        Background = 9,
        Default = -1
    }
    export enum NSRectEdge {
        RectEdgeMinX = 0,
        RectEdgeMinY = 1,
        RectEdgeMaxX = 2,
        RectEdgeMaxY = 3,
        MinXEdge = 0,
        MinYEdge = 1,
        MaxXEdge = 2,
        MaxYEdge = 3
    }
    export enum NSSaveOptions {
        Yes = 0,
        No = 1,
        Ask = 2
    }
    export enum NSSortOptions {
        Concurrent = 1,
        Stable = 16
    }
    export enum NSURLErrorNetworkUnavailableReason {
        Cellular = 0,
        Expensive = 1,
        Constrained = 2
    }
    export enum NSURLSessionDelayedRequestDisposition {
        ContinueLoading = 0,
        UseNewRequest = 1,
        Cancel = 2
    }
    export enum NSURLSessionWebSocketMessageType {
        Data = 0,
        String = 1
    }
    export let NSAllRomanInputSourcesLocaleIdentifier: string;
    export let NSAnimationTriggerOrderIn: string;
    export let NSAnimationTriggerOrderOut: string;
    export let NSApp: NSApplication;
    export let NSBlack: number;
    export let NSDarkGray: number;
    export let NSDirectionalEdgeInsetsZero: NSDirectionalEdgeInsets;
    export let NSLightGray: number;
    export let NSMultipleValuesMarker: any;
    export let NSNoSelectionMarker: any;
    export let NSNotApplicableMarker: any;
    export let NSTypeIdentifierAddressText: string;
    export let NSTypeIdentifierDateText: string;
    export let NSTypeIdentifierPhoneNumberText: string;
    export let NSTypeIdentifierTransitInformationText: string;
    export let NSUnderlineByWord: NSUnderlineStyle;
    export let NSUnderlinePatternDash: NSUnderlineStyle;
    export let NSUnderlinePatternDashDot: NSUnderlineStyle;
    export let NSUnderlinePatternDashDotDot: NSUnderlineStyle;
    export let NSUnderlinePatternDot: NSUnderlineStyle;
    export let NSUnderlinePatternSolid: NSUnderlineStyle;
    export let NSUserActivityDocumentURLKey: string;
    export let NSWhite: number;
    export let kCFAbsoluteTimeIntervalSince1904: number;
    export let kCFAbsoluteTimeIntervalSince1970: number;
    export let kCFAllocatorDefault: any;
    export let kCFAllocatorMalloc: any;
    export let kCFAllocatorMallocZone: any;
    export let kCFAllocatorNull: any;
    export let kCFAllocatorSystemDefault: any;
    export let kCFAllocatorUseContext: any;
    export let kCFBooleanFalse: number;
    export let kCFBooleanTrue: number;
    export let kCFBundleDevelopmentRegionKey: string;
    export let kCFBundleExecutableKey: string;
    export let kCFBundleIdentifierKey: string;
    export let kCFBundleInfoDictionaryVersionKey: string;
    export let kCFBundleLocalizationsKey: string;
    export let kCFBundleNameKey: string;
    export let kCFBundleVersionKey: string;
    export let kCFCopyStringBagCallBacks: CFBagCallBacks;
    export let kCFCopyStringDictionaryKeyCallBacks: CFDictionaryKeyCallBacks;
    export let kCFCopyStringSetCallBacks: CFSetCallBacks;
    export let kCFCoreFoundationVersionNumber: number;
    export let kCFErrorDescriptionKey: string;
    export let kCFErrorDomainCocoa: any;
    export let kCFErrorDomainMach: any;
    export let kCFErrorDomainOSStatus: any;
    export let kCFErrorDomainPOSIX: any;
    export let kCFErrorFilePathKey: string;
    export let kCFErrorLocalizedDescriptionKey: string;
    export let kCFErrorLocalizedFailureKey: string;
    export let kCFErrorLocalizedFailureReasonKey: string;
    export let kCFErrorLocalizedRecoverySuggestionKey: string;
    export let kCFErrorURLKey: string;
    export let kCFErrorUnderlyingErrorKey: string;
    export let kCFNotFound: number;
    export let kCFNull: NSNull;
    export let kCFNumberNaN: number;
    export let kCFNumberNegativeInfinity: number;
    export let kCFNumberPositiveInfinity: number;
    export let kCFPlugInDynamicRegisterFunctionKey: string;
    export let kCFPlugInDynamicRegistrationKey: string;
    export let kCFPlugInFactoriesKey: string;
    export let kCFPlugInTypesKey: string;
    export let kCFPlugInUnloadFunctionKey: string;
    export let kCFPreferencesAnyApplication: string;
    export let kCFPreferencesAnyHost: string;
    export let kCFPreferencesAnyUser: string;
    export let kCFPreferencesCurrentApplication: string;
    export let kCFPreferencesCurrentHost: string;
    export let kCFPreferencesCurrentUser: string;
    export let kCFSocketCommandKey: string;
    export let kCFSocketErrorKey: string;
    export let kCFSocketNameKey: string;
    export let kCFSocketRegisterCommand: string;
    export let kCFSocketResultKey: string;
    export let kCFSocketRetrieveCommand: string;
    export let kCFSocketValueKey: string;
    export let kCFStreamErrorDomainSOCKS: number;
    export let kCFStreamErrorDomainSSL: number;
    export let kCFStreamPropertySOCKSPassword: string;
    export let kCFStreamPropertySOCKSProxy: string;
    export let kCFStreamPropertySOCKSProxyHost: string;
    export let kCFStreamPropertySOCKSProxyPort: string;
    export let kCFStreamPropertySOCKSUser: string;
    export let kCFStreamPropertySOCKSVersion: string;
    export let kCFStreamPropertyShouldCloseNativeSocket: string;
    export let kCFStreamPropertySocketSecurityLevel: string;
    export let kCFStreamSocketSOCKSVersion4: string;
    export let kCFStreamSocketSOCKSVersion5: string;
    export let kCFStreamSocketSecurityLevelNegotiatedSSL: string;
    export let kCFStreamSocketSecurityLevelNone: string;
    export let kCFStreamSocketSecurityLevelTLSv1: string;
    export let kCFStringBinaryHeapCallBacks: CFBinaryHeapCallBacks;
    export let kCFStringTransformFullwidthHalfwidth: string;
    export let kCFStringTransformHiraganaKatakana: string;
    export let kCFStringTransformLatinArabic: string;
    export let kCFStringTransformLatinCyrillic: string;
    export let kCFStringTransformLatinGreek: string;
    export let kCFStringTransformLatinHangul: string;
    export let kCFStringTransformLatinHebrew: string;
    export let kCFStringTransformLatinHiragana: string;
    export let kCFStringTransformLatinKatakana: string;
    export let kCFStringTransformLatinThai: string;
    export let kCFStringTransformMandarinLatin: string;
    export let kCFStringTransformStripCombiningMarks: string;
    export let kCFStringTransformStripDiacritics: string;
    export let kCFStringTransformToLatin: string;
    export let kCFStringTransformToUnicodeName: string;
    export let kCFStringTransformToXMLHex: string;
    export let kCFTypeArrayCallBacks: CFArrayCallBacks;
    export let kCFTypeBagCallBacks: CFBagCallBacks;
    export let kCFTypeDictionaryKeyCallBacks: CFDictionaryKeyCallBacks;
    export let kCFTypeDictionaryValueCallBacks: CFDictionaryValueCallBacks;
    export let kCFTypeSetCallBacks: CFSetCallBacks;
    export let kCFURLAddedToDirectoryDateKey: string;
    export let kCFURLApplicationIsScriptableKey: string;
    export let kCFURLAttributeModificationDateKey: string;
    export let kCFURLCanonicalPathKey: string;
    export let kCFURLContentAccessDateKey: string;
    export let kCFURLContentModificationDateKey: string;
    export let kCFURLCreationDateKey: string;
    export let kCFURLDocumentIdentifierKey: string;
    export let kCFURLFileAllocatedSizeKey: string;
    export let kCFURLFileResourceIdentifierKey: string;
    export let kCFURLFileResourceTypeBlockSpecial: string;
    export let kCFURLFileResourceTypeCharacterSpecial: string;
    export let kCFURLFileResourceTypeDirectory: string;
    export let kCFURLFileResourceTypeKey: string;
    export let kCFURLFileResourceTypeNamedPipe: string;
    export let kCFURLFileResourceTypeRegular: string;
    export let kCFURLFileResourceTypeSocket: string;
    export let kCFURLFileResourceTypeSymbolicLink: string;
    export let kCFURLFileResourceTypeUnknown: string;
    export let kCFURLFileSecurityKey: string;
    export let kCFURLFileSizeKey: string;
    export let kCFURLGenerationIdentifierKey: string;
    export let kCFURLHasHiddenExtensionKey: string;
    export let kCFURLIsAliasFileKey: string;
    export let kCFURLIsApplicationKey: string;
    export let kCFURLIsDirectoryKey: string;
    export let kCFURLIsExcludedFromBackupKey: string;
    export let kCFURLIsExecutableKey: string;
    export let kCFURLIsHiddenKey: string;
    export let kCFURLIsMountTriggerKey: string;
    export let kCFURLIsPackageKey: string;
    export let kCFURLIsReadableKey: string;
    export let kCFURLIsRegularFileKey: string;
    export let kCFURLIsSymbolicLinkKey: string;
    export let kCFURLIsSystemImmutableKey: string;
    export let kCFURLIsUbiquitousItemKey: string;
    export let kCFURLIsUserImmutableKey: string;
    export let kCFURLIsVolumeKey: string;
    export let kCFURLIsWritableKey: string;
    export let kCFURLKeysOfUnsetValuesKey: string;
    export let kCFURLLabelNumberKey: string;
    export let kCFURLLinkCountKey: string;
    export let kCFURLLocalizedLabelKey: string;
    export let kCFURLLocalizedNameKey: string;
    export let kCFURLLocalizedTypeDescriptionKey: string;
    export let kCFURLNameKey: string;
    export let kCFURLParentDirectoryURLKey: string;
    export let kCFURLPathKey: string;
    export let kCFURLPreferredIOBlockSizeKey: string;
    export let kCFURLQuarantinePropertiesKey: string;
    export let kCFURLTagNamesKey: string;
    export let kCFURLTotalFileAllocatedSizeKey: string;
    export let kCFURLTotalFileSizeKey: string;
    export let kCFURLTypeIdentifierKey: string;
    export let kCFURLUbiquitousItemDownloadingErrorKey: string;
    export let kCFURLUbiquitousItemDownloadingStatusCurrent: string;
    export let kCFURLUbiquitousItemDownloadingStatusDownloaded: string;
    export let kCFURLUbiquitousItemDownloadingStatusKey: string;
    export let kCFURLUbiquitousItemDownloadingStatusNotDownloaded: string;
    export let kCFURLUbiquitousItemHasUnresolvedConflictsKey: string;
    export let kCFURLUbiquitousItemIsDownloadingKey: string;
    export let kCFURLUbiquitousItemIsUploadedKey: string;
    export let kCFURLUbiquitousItemIsUploadingKey: string;
    export let kCFURLUbiquitousItemUploadingErrorKey: string;
    export let kCFURLVolumeAvailableCapacityForImportantUsageKey: string;
    export let kCFURLVolumeAvailableCapacityForOpportunisticUsageKey: string;
    export let kCFURLVolumeAvailableCapacityKey: string;
    export let kCFURLVolumeCreationDateKey: string;
    export let kCFURLVolumeIdentifierKey: string;
    export let kCFURLVolumeIsAutomountedKey: string;
    export let kCFURLVolumeIsBrowsableKey: string;
    export let kCFURLVolumeIsEjectableKey: string;
    export let kCFURLVolumeIsEncryptedKey: string;
    export let kCFURLVolumeIsInternalKey: string;
    export let kCFURLVolumeIsJournalingKey: string;
    export let kCFURLVolumeIsLocalKey: string;
    export let kCFURLVolumeIsReadOnlyKey: string;
    export let kCFURLVolumeIsRemovableKey: string;
    export let kCFURLVolumeIsRootFileSystemKey: string;
    export let kCFURLVolumeLocalizedFormatDescriptionKey: string;
    export let kCFURLVolumeLocalizedNameKey: string;
    export let kCFURLVolumeMaximumFileSizeKey: string;
    export let kCFURLVolumeNameKey: string;
    export let kCFURLVolumeResourceCountKey: string;
    export let kCFURLVolumeSupportsAccessPermissionsKey: string;
    export let kCFURLVolumeSupportsAdvisoryFileLockingKey: string;
    export let kCFURLVolumeSupportsCasePreservedNamesKey: string;
    export let kCFURLVolumeSupportsCaseSensitiveNamesKey: string;
    export let kCFURLVolumeSupportsCompressionKey: string;
    export let kCFURLVolumeSupportsExclusiveRenamingKey: string;
    export let kCFURLVolumeSupportsExtendedSecurityKey: string;
    export let kCFURLVolumeSupportsFileCloningKey: string;
    export let kCFURLVolumeSupportsHardLinksKey: string;
    export let kCFURLVolumeSupportsImmutableFilesKey: string;
    export let kCFURLVolumeSupportsJournalingKey: string;
    export let kCFURLVolumeSupportsPersistentIDsKey: string;
    export let kCFURLVolumeSupportsRenamingKey: string;
    export let kCFURLVolumeSupportsRootDirectoryDatesKey: string;
    export let kCFURLVolumeSupportsSparseFilesKey: string;
    export let kCFURLVolumeSupportsSwapRenamingKey: string;
    export let kCFURLVolumeSupportsSymbolicLinksKey: string;
    export let kCFURLVolumeSupportsVolumeSizesKey: string;
    export let kCFURLVolumeSupportsZeroRunsKey: string;
    export let kCFURLVolumeTotalCapacityKey: string;
    export let kCFURLVolumeURLForRemountingKey: string;
    export let kCFURLVolumeURLKey: string;
    export let kCFURLVolumeUUIDStringKey: string;
    export let kCFUserNotificationAlertHeaderKey: string;
    export let kCFUserNotificationAlertMessageKey: string;
    export let kCFUserNotificationAlertTopMostKey: string;
    export let kCFUserNotificationAlternateButtonTitleKey: string;
    export let kCFUserNotificationCheckBoxTitlesKey: string;
    export let kCFUserNotificationDefaultButtonTitleKey: string;
    export let kCFUserNotificationIconURLKey: string;
    export let kCFUserNotificationKeyboardTypesKey: string;
    export let kCFUserNotificationLocalizationURLKey: string;
    export let kCFUserNotificationOtherButtonTitleKey: string;
    export let kCFUserNotificationPopUpSelectionKey: string;
    export let kCFUserNotificationPopUpTitlesKey: string;
    export let kCFUserNotificationProgressIndicatorValueKey: string;
    export let kCFUserNotificationSoundURLKey: string;
    export let kCFUserNotificationTextFieldTitlesKey: string;
    export let kCFUserNotificationTextFieldValuesKey: string;
    export let kCFXMLTreeErrorDescription: string;
    export let kCFXMLTreeErrorLineNumber: string;
    export let kCFXMLTreeErrorLocation: string;
    export let kCFXMLTreeErrorStatusCode: string;
    export let NSAppleEventTimeOutDefault: number;
    export let NSAppleEventTimeOutNone: number;
    export let NSAssertionHandlerKey: string;
    export let NSCocoaErrorDomain: string;
    export let NSDeallocateZombies: boolean;
    export let NSDebugDescriptionErrorKey: string;
    export let NSDebugEnabled: boolean;
    export let NSEdgeInsetsZero: NSEdgeInsets;
    export let NSExtensionItemAttachmentsKey: string;
    export let NSExtensionItemAttributedContentTextKey: string;
    export let NSExtensionItemAttributedTitleKey: string;
    export let NSExtensionItemsAndErrorsKey: string;
    export let NSExtensionJavaScriptPreprocessingResultsKey: string;
    export let NSFileHandleNotificationDataItem: string;
    export let NSFileHandleNotificationFileHandleItem: string;
    export let NSFileManagerUnmountDissentingProcessIdentifierErrorKey: string;
    export let NSFilePathErrorKey: string;
    export let NSFoundationVersionNumber: number;
    export let NSGrammarCorrections: string;
    export let NSGrammarRange: string;
    export let NSGrammarUserDescription: string;
    export let NSHashTableCopyIn: NSPointerFunctions.Options;
    export let NSHashTableObjectPointerPersonality: NSPointerFunctions.Options;
    export let NSHashTableStrongMemory: NSPointerFunctions.Options;
    export let NSHashTableWeakMemory: NSPointerFunctions.Options;
    export let NSHelpAnchorErrorKey: string;
    export let NSIntegerHashCallBacks: NSHashTableCallBacks;
    export let NSIntegerMapKeyCallBacks: NSMapTableKeyCallBacks;
    export let NSIntegerMapValueCallBacks: NSMapTableValueCallBacks;
    export let NSItemProviderPreferredImageSizeKey: string;
    export let NSKeepAllocationStatistics: boolean;
    export let NSKeyedArchiveRootObjectKey: string;
    export let NSLoadedClasses: string;
    export let NSLocalizedDescriptionKey: string;
    export let NSLocalizedFailureErrorKey: string;
    export let NSLocalizedFailureReasonErrorKey: string;
    export let NSLocalizedRecoveryOptionsErrorKey: string;
    export let NSLocalizedRecoverySuggestionErrorKey: string;
    export let NSMachErrorDomain: string;
    export let NSMapTableCopyIn: NSPointerFunctions.Options;
    export let NSMapTableObjectPointerPersonality: NSPointerFunctions.Options;
    export let NSMapTableStrongMemory: NSPointerFunctions.Options;
    export let NSMapTableWeakMemory: NSPointerFunctions.Options;
    export let NSMetadataItemAcquisitionMakeKey: string;
    export let NSMetadataItemAcquisitionModelKey: string;
    export let NSMetadataItemAlbumKey: string;
    export let NSMetadataItemAltitudeKey: string;
    export let NSMetadataItemApertureKey: string;
    export let NSMetadataItemAppleLoopDescriptorsKey: string;
    export let NSMetadataItemAppleLoopsKeyFilterTypeKey: string;
    export let NSMetadataItemAppleLoopsLoopModeKey: string;
    export let NSMetadataItemAppleLoopsRootKeyKey: string;
    export let NSMetadataItemApplicationCategoriesKey: string;
    export let NSMetadataItemAttributeChangeDateKey: string;
    export let NSMetadataItemAudiencesKey: string;
    export let NSMetadataItemAudioBitRateKey: string;
    export let NSMetadataItemAudioChannelCountKey: string;
    export let NSMetadataItemAudioEncodingApplicationKey: string;
    export let NSMetadataItemAudioSampleRateKey: string;
    export let NSMetadataItemAudioTrackNumberKey: string;
    export let NSMetadataItemAuthorAddressesKey: string;
    export let NSMetadataItemAuthorEmailAddressesKey: string;
    export let NSMetadataItemAuthorsKey: string;
    export let NSMetadataItemBitsPerSampleKey: string;
    export let NSMetadataItemCFBundleIdentifierKey: string;
    export let NSMetadataItemCameraOwnerKey: string;
    export let NSMetadataItemCityKey: string;
    export let NSMetadataItemCodecsKey: string;
    export let NSMetadataItemColorSpaceKey: string;
    export let NSMetadataItemCommentKey: string;
    export let NSMetadataItemComposerKey: string;
    export let NSMetadataItemContactKeywordsKey: string;
    export let NSMetadataItemContentCreationDateKey: string;
    export let NSMetadataItemContentModificationDateKey: string;
    export let NSMetadataItemContentTypeKey: string;
    export let NSMetadataItemContentTypeTreeKey: string;
    export let NSMetadataItemContributorsKey: string;
    export let NSMetadataItemCopyrightKey: string;
    export let NSMetadataItemCountryKey: string;
    export let NSMetadataItemCoverageKey: string;
    export let NSMetadataItemCreatorKey: string;
    export let NSMetadataItemDateAddedKey: string;
    export let NSMetadataItemDeliveryTypeKey: string;
    export let NSMetadataItemDescriptionKey: string;
    export let NSMetadataItemDirectorKey: string;
    export let NSMetadataItemDisplayNameKey: string;
    export let NSMetadataItemDownloadedDateKey: string;
    export let NSMetadataItemDueDateKey: string;
    export let NSMetadataItemDurationSecondsKey: string;
    export let NSMetadataItemEXIFGPSVersionKey: string;
    export let NSMetadataItemEXIFVersionKey: string;
    export let NSMetadataItemEditorsKey: string;
    export let NSMetadataItemEmailAddressesKey: string;
    export let NSMetadataItemEncodingApplicationsKey: string;
    export let NSMetadataItemExecutableArchitecturesKey: string;
    export let NSMetadataItemExecutablePlatformKey: string;
    export let NSMetadataItemExposureModeKey: string;
    export let NSMetadataItemExposureProgramKey: string;
    export let NSMetadataItemExposureTimeSecondsKey: string;
    export let NSMetadataItemExposureTimeStringKey: string;
    export let NSMetadataItemFNumberKey: string;
    export let NSMetadataItemFSContentChangeDateKey: string;
    export let NSMetadataItemFSCreationDateKey: string;
    export let NSMetadataItemFSNameKey: string;
    export let NSMetadataItemFSSizeKey: string;
    export let NSMetadataItemFinderCommentKey: string;
    export let NSMetadataItemFlashOnOffKey: string;
    export let NSMetadataItemFocalLength35mmKey: string;
    export let NSMetadataItemFocalLengthKey: string;
    export let NSMetadataItemFontsKey: string;
    export let NSMetadataItemGPSAreaInformationKey: string;
    export let NSMetadataItemGPSDOPKey: string;
    export let NSMetadataItemGPSDateStampKey: string;
    export let NSMetadataItemGPSDestBearingKey: string;
    export let NSMetadataItemGPSDestDistanceKey: string;
    export let NSMetadataItemGPSDestLatitudeKey: string;
    export let NSMetadataItemGPSDestLongitudeKey: string;
    export let NSMetadataItemGPSDifferentalKey: string;
    export let NSMetadataItemGPSMapDatumKey: string;
    export let NSMetadataItemGPSMeasureModeKey: string;
    export let NSMetadataItemGPSProcessingMethodKey: string;
    export let NSMetadataItemGPSStatusKey: string;
    export let NSMetadataItemGPSTrackKey: string;
    export let NSMetadataItemGenreKey: string;
    export let NSMetadataItemHasAlphaChannelKey: string;
    export let NSMetadataItemHeadlineKey: string;
    export let NSMetadataItemISOSpeedKey: string;
    export let NSMetadataItemIdentifierKey: string;
    export let NSMetadataItemImageDirectionKey: string;
    export let NSMetadataItemInformationKey: string;
    export let NSMetadataItemInstantMessageAddressesKey: string;
    export let NSMetadataItemInstructionsKey: string;
    export let NSMetadataItemIsApplicationManagedKey: string;
    export let NSMetadataItemIsGeneralMIDISequenceKey: string;
    export let NSMetadataItemIsLikelyJunkKey: string;
    export let NSMetadataItemIsUbiquitousKey: string;
    export let NSMetadataItemKeySignatureKey: string;
    export let NSMetadataItemKeywordsKey: string;
    export let NSMetadataItemKindKey: string;
    export let NSMetadataItemLanguagesKey: string;
    export let NSMetadataItemLastUsedDateKey: string;
    export let NSMetadataItemLatitudeKey: string;
    export let NSMetadataItemLayerNamesKey: string;
    export let NSMetadataItemLensModelKey: string;
    export let NSMetadataItemLongitudeKey: string;
    export let NSMetadataItemLyricistKey: string;
    export let NSMetadataItemMaxApertureKey: string;
    export let NSMetadataItemMediaTypesKey: string;
    export let NSMetadataItemMeteringModeKey: string;
    export let NSMetadataItemMusicalGenreKey: string;
    export let NSMetadataItemMusicalInstrumentCategoryKey: string;
    export let NSMetadataItemMusicalInstrumentNameKey: string;
    export let NSMetadataItemNamedLocationKey: string;
    export let NSMetadataItemNumberOfPagesKey: string;
    export let NSMetadataItemOrganizationsKey: string;
    export let NSMetadataItemOrientationKey: string;
    export let NSMetadataItemOriginalFormatKey: string;
    export let NSMetadataItemOriginalSourceKey: string;
    export let NSMetadataItemPageHeightKey: string;
    export let NSMetadataItemPageWidthKey: string;
    export let NSMetadataItemParticipantsKey: string;
    export let NSMetadataItemPathKey: string;
    export let NSMetadataItemPerformersKey: string;
    export let NSMetadataItemPhoneNumbersKey: string;
    export let NSMetadataItemPixelCountKey: string;
    export let NSMetadataItemPixelHeightKey: string;
    export let NSMetadataItemPixelWidthKey: string;
    export let NSMetadataItemProducerKey: string;
    export let NSMetadataItemProfileNameKey: string;
    export let NSMetadataItemProjectsKey: string;
    export let NSMetadataItemPublishersKey: string;
    export let NSMetadataItemRecipientAddressesKey: string;
    export let NSMetadataItemRecipientEmailAddressesKey: string;
    export let NSMetadataItemRecipientsKey: string;
    export let NSMetadataItemRecordingDateKey: string;
    export let NSMetadataItemRecordingYearKey: string;
    export let NSMetadataItemRedEyeOnOffKey: string;
    export let NSMetadataItemResolutionHeightDPIKey: string;
    export let NSMetadataItemResolutionWidthDPIKey: string;
    export let NSMetadataItemRightsKey: string;
    export let NSMetadataItemSecurityMethodKey: string;
    export let NSMetadataItemSpeedKey: string;
    export let NSMetadataItemStarRatingKey: string;
    export let NSMetadataItemStateOrProvinceKey: string;
    export let NSMetadataItemStreamableKey: string;
    export let NSMetadataItemSubjectKey: string;
    export let NSMetadataItemTempoKey: string;
    export let NSMetadataItemTextContentKey: string;
    export let NSMetadataItemThemeKey: string;
    export let NSMetadataItemTimeSignatureKey: string;
    export let NSMetadataItemTimestampKey: string;
    export let NSMetadataItemTitleKey: string;
    export let NSMetadataItemTotalBitRateKey: string;
    export let NSMetadataItemURLKey: string;
    export let NSMetadataItemVersionKey: string;
    export let NSMetadataItemVideoBitRateKey: string;
    export let NSMetadataItemWhereFromsKey: string;
    export let NSMetadataItemWhiteBalanceKey: string;
    export let NSMetadataQueryAccessibleUbiquitousExternalDocumentsScope: string;
    export let NSMetadataQueryIndexedLocalComputerScope: string;
    export let NSMetadataQueryIndexedNetworkScope: string;
    export let NSMetadataQueryLocalComputerScope: string;
    export let NSMetadataQueryNetworkScope: string;
    export let NSMetadataQueryResultContentRelevanceAttribute: string;
    export let NSMetadataQueryUbiquitousDataScope: string;
    export let NSMetadataQueryUbiquitousDocumentsScope: string;
    export let NSMetadataQueryUpdateAddedItemsKey: string;
    export let NSMetadataQueryUpdateChangedItemsKey: string;
    export let NSMetadataQueryUpdateRemovedItemsKey: string;
    export let NSMetadataQueryUserHomeScope: string;
    export let NSMetadataUbiquitousItemContainerDisplayNameKey: string;
    export let NSMetadataUbiquitousItemDownloadRequestedKey: string;
    export let NSMetadataUbiquitousItemDownloadingErrorKey: string;
    export let NSMetadataUbiquitousItemDownloadingStatusCurrent: string;
    export let NSMetadataUbiquitousItemDownloadingStatusDownloaded: string;
    export let NSMetadataUbiquitousItemDownloadingStatusKey: string;
    export let NSMetadataUbiquitousItemDownloadingStatusNotDownloaded: string;
    export let NSMetadataUbiquitousItemHasUnresolvedConflictsKey: string;
    export let NSMetadataUbiquitousItemIsDownloadingKey: string;
    export let NSMetadataUbiquitousItemIsExternalDocumentKey: string;
    export let NSMetadataUbiquitousItemIsSharedKey: string;
    export let NSMetadataUbiquitousItemIsUploadedKey: string;
    export let NSMetadataUbiquitousItemIsUploadingKey: string;
    export let NSMetadataUbiquitousItemPercentDownloadedKey: string;
    export let NSMetadataUbiquitousItemPercentUploadedKey: string;
    export let NSMetadataUbiquitousItemURLInLocalContainerKey: string;
    export let NSMetadataUbiquitousItemUploadingErrorKey: string;
    export let NSMetadataUbiquitousSharedItemCurrentUserPermissionsKey: string;
    export let NSMetadataUbiquitousSharedItemCurrentUserRoleKey: string;
    export let NSMetadataUbiquitousSharedItemMostRecentEditorNameComponentsKey: string;
    export let NSMetadataUbiquitousSharedItemOwnerNameComponentsKey: string;
    export let NSMetadataUbiquitousSharedItemPermissionsReadOnly: string;
    export let NSMetadataUbiquitousSharedItemPermissionsReadWrite: string;
    export let NSMetadataUbiquitousSharedItemRoleOwner: string;
    export let NSMetadataUbiquitousSharedItemRoleParticipant: string;
    export let NSNonOwnedPointerHashCallBacks: NSHashTableCallBacks;
    export let NSNonOwnedPointerMapKeyCallBacks: NSMapTableKeyCallBacks;
    export let NSNonOwnedPointerMapValueCallBacks: NSMapTableValueCallBacks;
    export let NSNonOwnedPointerOrNullMapKeyCallBacks: NSMapTableKeyCallBacks;
    export let NSNonRetainedObjectHashCallBacks: NSHashTableCallBacks;
    export let NSNonRetainedObjectMapKeyCallBacks: NSMapTableKeyCallBacks;
    export let NSNonRetainedObjectMapValueCallBacks: NSMapTableValueCallBacks;
    export let NSNotFound: number;
    export let NSNotificationDeliverImmediately: DistributedNotificationCenter.Options;
    export let NSNotificationPostToAllSessions: DistributedNotificationCenter.Options;
    export let NSOSStatusErrorDomain: string;
    export let NSObjectHashCallBacks: NSHashTableCallBacks;
    export let NSObjectMapKeyCallBacks: NSMapTableKeyCallBacks;
    export let NSObjectMapValueCallBacks: NSMapTableValueCallBacks;
    export let NSOperationNotSupportedForKeyException: string;
    export let NSOwnedObjectIdentityHashCallBacks: NSHashTableCallBacks;
    export let NSOwnedPointerHashCallBacks: NSHashTableCallBacks;
    export let NSOwnedPointerMapKeyCallBacks: NSMapTableKeyCallBacks;
    export let NSOwnedPointerMapValueCallBacks: NSMapTableValueCallBacks;
    export let NSPOSIXErrorDomain: string;
    export let NSPersonNameComponentDelimiter: string;
    export let NSPersonNameComponentFamilyName: string;
    export let NSPersonNameComponentGivenName: string;
    export let NSPersonNameComponentKey: string;
    export let NSPersonNameComponentMiddleName: string;
    export let NSPersonNameComponentNickname: string;
    export let NSPersonNameComponentPrefix: string;
    export let NSPersonNameComponentSuffix: string;
    export let NSPointerToStructHashCallBacks: NSHashTableCallBacks;
    export let NSRecoveryAttempterErrorKey: string;
    export let NSStreamSOCKSErrorDomain: string;
    export let NSStreamSocketSSLErrorDomain: string;
    export let NSStringEncodingErrorKey: string;
    export let NSURLAuthenticationMethodClientCertificate: string;
    export let NSURLAuthenticationMethodDefault: string;
    export let NSURLAuthenticationMethodHTMLForm: string;
    export let NSURLAuthenticationMethodHTTPBasic: string;
    export let NSURLAuthenticationMethodHTTPDigest: string;
    export let NSURLAuthenticationMethodNTLM: string;
    export let NSURLAuthenticationMethodNegotiate: string;
    export let NSURLAuthenticationMethodServerTrust: string;
    export let NSURLCredentialStorageRemoveSynchronizableCredentials: string;
    export let NSURLErrorBackgroundTaskCancelledReasonKey: string;
    export let NSURLErrorDomain: string;
    export let NSURLErrorFailingURLErrorKey: string;
    export let NSURLErrorFailingURLPeerTrustErrorKey: string;
    export let NSURLErrorFailingURLStringErrorKey: string;
    export let NSURLErrorKey: string;
    export let NSURLErrorNetworkUnavailableReasonKey: string;
    export let NSURLFileScheme: string;
    export let NSURLProtectionSpaceFTP: string;
    export let NSURLProtectionSpaceFTPProxy: string;
    export let NSURLProtectionSpaceHTTP: string;
    export let NSURLProtectionSpaceHTTPProxy: string;
    export let NSURLProtectionSpaceHTTPS: string;
    export let NSURLProtectionSpaceHTTPSProxy: string;
    export let NSURLProtectionSpaceSOCKSProxy: string;
    export let NSURLSessionDownloadTaskResumeData: string;
    export let NSURLSessionTransferSizeUnknown: number;
    export let NSUbiquitousKeyValueStoreChangeReasonKey: string;
    export let NSUbiquitousKeyValueStoreChangedKeysKey: string;
    export let NSUnderlyingErrorKey: string;
    export let NSUndoCloseGroupingRunLoopOrdering: number;
    export let NSUndoManagerGroupIsDiscardableKey: string;
    export let NSUserActivityTypeBrowsingWeb: string;
    export let NSUserNotificationDefaultSoundName: string;
    export let NSZeroPoint: CGPoint;
    export let NSZeroRect: CGRect;
    export let NSZeroSize: CGSize;
    export let NSZombieEnabled: boolean;
}
declare namespace Bundle {
}
declare namespace ByteCountFormatter {
    enum CountStyle {
        File = 0,
        Memory = 1,
        Decimal = 2,
        Binary = 3
    }
    enum Units {
        UseDefault = 0,
        UseBytes = 1,
        UseKB = 2,
        UseMB = 4,
        UseGB = 8,
        UseTB = 16,
        UsePB = 32,
        UseEB = 64,
        UseZB = 128,
        UseYBOrHigher = 65280,
        UseAll = 65535
    }
}
declare namespace CFCalendarIdentifier {
}
declare namespace CFDateFormatterKey {
}
declare namespace CFLocaleKey {
}
declare namespace CFNotificationName {
}
declare namespace CFNumberFormatterKey {
}
declare namespace CFRunLoopMode {
}
declare namespace CFStreamPropertyKey {
}
declare namespace DateComponentsFormatter {
    enum UnitsStyle {
        Positional = 0,
        Abbreviated = 1,
        Short = 2,
        Full = 3,
        SpellOut = 4,
        Brief = 5
    }
    enum ZeroFormattingBehavior {
        None = 0,
        Default = 1,
        DropLeading = 2,
        DropMiddle = 4,
        DropTrailing = 8,
        DropAll = 14,
        Pad = 65536
    }
}
declare namespace DateFormatter {
    enum Behavior {
        BehaviorDefault = 0,
        Behavior10_0 = 1000,
        Behavior10_4 = 1040
    }
    enum Style {
        NoStyle = 0,
        ShortStyle = 1,
        MediumStyle = 2,
        LongStyle = 3,
        FullStyle = 4
    }
}
declare namespace DateIntervalFormatter {
    enum Style {
        NoStyle = 0,
        ShortStyle = 1,
        MediumStyle = 2,
        LongStyle = 3,
        FullStyle = 4
    }
}
declare namespace DistributedNotificationCenter {
    enum Options {
        DeliverImmediately = 1,
        PostToAllSessions = 2
    }
    enum SuspensionBehavior {
        Drop = 1,
        Coalesce = 2,
        Hold = 3,
        DeliverImmediately = 4
    }
}
declare namespace EnergyFormatter {
    enum Unit {
        Joule = 11,
        Kilojoule = 14,
        Calorie = 1793,
        Kilocalorie = 1794
    }
}
declare namespace FileAttributeKey {
}
declare namespace FileAttributeType {
}
declare namespace FileHandle {
}
declare namespace FileManager {
    enum DirectoryEnumerationOptions {
        SkipsSubdirectoryDescendants = 1,
        SkipsPackageDescendants = 2,
        SkipsHiddenFiles = 4,
        IncludesDirectoriesPostOrder = 8,
        ProducesRelativePathURLs = 16
    }
    enum ItemReplacementOptions {
        UsingNewMetadataOnly = 1,
        WithoutDeletingBackupItem = 2
    }
    enum UnmountOptions {
        AllPartitionsAndEjectDisk = 1,
        WithoutUI = 2
    }
    enum SearchPathDirectory {
        ApplicationDirectory = 1,
        DemoApplicationDirectory = 2,
        DeveloperApplicationDirectory = 3,
        AdminApplicationDirectory = 4,
        LibraryDirectory = 5,
        DeveloperDirectory = 6,
        UserDirectory = 7,
        DocumentationDirectory = 8,
        DocumentDirectory = 9,
        CoreServiceDirectory = 10,
        AutosavedInformationDirectory = 11,
        DesktopDirectory = 12,
        CachesDirectory = 13,
        ApplicationSupportDirectory = 14,
        DownloadsDirectory = 15,
        InputMethodsDirectory = 16,
        MoviesDirectory = 17,
        MusicDirectory = 18,
        PicturesDirectory = 19,
        PrinterDescriptionDirectory = 20,
        SharedPublicDirectory = 21,
        PreferencePanesDirectory = 22,
        ApplicationScriptsDirectory = 23,
        ItemReplacementDirectory = 99,
        AllApplicationsDirectory = 100,
        AllLibrariesDirectory = 101,
        TrashDirectory = 102
    }
    enum SearchPathDomainMask {
        UserDomainMask = 1,
        LocalDomainMask = 2,
        NetworkDomainMask = 4,
        SystemDomainMask = 8,
        AllDomainsMask = 65535
    }
    enum URLRelationship {
        Contains = 0,
        Same = 1,
        Other = 2
    }
    enum VolumeEnumerationOptions {
        SkipHiddenVolumes = 2,
        ProduceFileReferenceURLs = 4
    }
}
declare namespace FileProtectionType {
}
declare namespace FileWrapper {
    enum ReadingOptions {
        Immediate = 1,
        WithoutMapping = 2
    }
    enum WritingOptions {
        Atomic = 1,
        WithNameUpdating = 2
    }
}
declare namespace Formatter {
    enum Context {
        Unknown = 0,
        Dynamic = 1,
        Standalone = 2,
        ListItem = 3,
        BeginningOfSentence = 4,
        MiddleOfSentence = 5
    }
    enum UnitStyle {
        Short = 1,
        Medium = 2,
        Long = 3
    }
}
declare namespace HTTPCookie {
    enum AcceptPolicy {
        Always = 0,
        Never = 1,
        OnlyFromMainDocumentDomain = 2
    }
}
declare namespace HTTPCookiePropertyKey {
}
declare namespace HTTPCookieStringPolicy {
}
declare namespace ISO8601DateFormatter {
    enum Options {
        WithYear = 1,
        WithMonth = 2,
        WithWeekOfYear = 4,
        WithDay = 16,
        WithTime = 32,
        WithTimeZone = 64,
        WithSpaceBetweenDateAndTime = 128,
        WithDashSeparatorInDate = 256,
        WithColonSeparatorInTime = 512,
        WithColonSeparatorInTimeZone = 1024,
        WithFractionalSeconds = 2048,
        WithFullDate = 275,
        WithFullTime = 1632,
        WithInternetDateTime = 1907
    }
}
declare namespace JSONSerialization {
    enum ReadingOptions {
        MutableContainers = 1,
        MutableLeaves = 2,
        FragmentsAllowed = 4,
        AllowFragments = 4
    }
    enum WritingOptions {
        PrettyPrinted = 1,
        SortedKeys = 2,
        FragmentsAllowed = 4,
        WithoutEscapingSlashes = 8
    }
}
declare namespace LengthFormatter {
    enum Unit {
        Millimeter = 8,
        Centimeter = 9,
        Meter = 11,
        Kilometer = 14,
        Inch = 1281,
        Foot = 1282,
        Yard = 1283,
        Mile = 1284
    }
}
declare namespace MassFormatter {
    enum Unit {
        Gram = 11,
        Kilogram = 14,
        Ounce = 1537,
        Pound = 1538,
        Stone = 1539
    }
}
declare namespace MeasurementFormatter {
    enum UnitOptions {
        ProvidedUnit = 1,
        NaturalScale = 2,
        TemperatureWithoutUnit = 4
    }
}
declare namespace NSAccessibility {
    enum AnnotationPosition {
        FullRange = 0,
        Start = 1,
        End = 2
    }
    enum Orientation {
        Unknown = 0,
        Vertical = 1,
        Horizontal = 2
    }
    enum RulerMarkerType {
        Unknown = 0,
        TabStopLeft = 1,
        TabStopRight = 2,
        TabStopCenter = 3,
        TabStopDecimal = 4,
        IndentHead = 5,
        IndentTail = 6,
        IndentFirstLine = 7
    }
    enum SortDirection {
        Unknown = 0,
        Ascending = 1,
        Descending = 2
    }
    enum Units {
        Unknown = 0,
        Inches = 1,
        Centimeters = 2,
        Points = 3,
        Picas = 4
    }
}
declare namespace NSAccessibilityCustomRotor {
    enum SearchDirection {
        Previous = 0,
        Next = 1
    }
    enum RotorType {
        Custom = 0,
        Any = 1,
        Annotation = 2,
        BoldText = 3,
        Heading = 4,
        HeadingLevel1 = 5,
        HeadingLevel2 = 6,
        HeadingLevel3 = 7,
        HeadingLevel4 = 8,
        HeadingLevel5 = 9,
        HeadingLevel6 = 10,
        Image = 11,
        ItalicText = 12,
        Landmark = 13,
        Link = 14,
        List = 15,
        MisspelledWord = 16,
        Table = 17,
        TextField = 18,
        UnderlinedText = 19,
        VisitedLink = 20
    }
}
declare namespace NSAlert {
    enum Style {
        Warning = 0,
        Informational = 1,
        Critical = 2
    }
}
declare namespace NSAnimation {
    enum BlockingMode {
        Blocking = 0,
        Nonblocking = 1,
        NonblockingThreaded = 2
    }
    enum Curve {
        EaseInOut = 0,
        EaseIn = 1,
        EaseOut = 2,
        Linear = 3
    }
}
declare namespace NSAppKitVersion {
}
declare namespace NSAppearance {
}
declare namespace NSAppleEventDescriptor {
    enum SendOptions {
        NoReply = 1,
        QueueReply = 2,
        WaitForReply = 3,
        NeverInteract = 16,
        CanInteract = 32,
        AlwaysInteract = 48,
        CanSwitchLayer = 64,
        DontRecord = 4096,
        DontExecute = 8192,
        DontAnnotate = 65536,
        DefaultOptions = 35
    }
}
declare namespace NSAppleEventManager {
}
declare namespace NSAppleScript {
}
declare namespace NSApplication {
    enum ActivationOptions {
        ActivateAllWindows = 1,
        ActivateIgnoringOtherApps = 2
    }
    enum ActivationPolicy {
        Regular = 0,
        Accessory = 1,
        Prohibited = 2
    }
    enum DelegateReply {
        Success = 0,
        Cancel = 1,
        Failure = 2
    }
    enum OcclusionState {
        Visible = 2
    }
    enum PresentationOptions {
        Default = 0,
        AutoHideDock = 1,
        HideDock = 2,
        AutoHideMenuBar = 4,
        HideMenuBar = 8,
        DisableAppleMenu = 16,
        DisableProcessSwitching = 32,
        DisableForceQuit = 64,
        DisableSessionTermination = 128,
        DisableHideApplication = 256,
        DisableMenuBarTransparency = 512,
        FullScreen = 1024,
        AutoHideToolbar = 2048,
        DisableCursorLocationAssistance = 4096
    }
    enum PrintReply {
        PrintingCancelled = 0,
        PrintingSuccess = 1,
        PrintingFailure = 3,
        PrintingReplyLater = 2
    }
    enum TerminateReply {
        TerminateCancel = 0,
        TerminateNow = 1,
        TerminateLater = 2
    }
    enum RemoteNotificationType {
        None = 0,
        Badge = 1,
        Sound = 2,
        Alert = 4
    }
    enum RequestUserAttentionType {
        CriticalRequest = 0,
        InformationalRequest = 10
    }
    enum WindowListOptions {
        OrderedFrontToBack = 1
    }
}
declare namespace NSArray {
}
declare namespace NSAttributedString {
    enum SpellingState {
        SpellingFlag = 1,
        GrammarFlag = 2
    }
    enum EnumerationOptions {
        Reverse = 2,
        LongestEffectiveRangeNotRequired = 1048576
    }
}
declare namespace NSBackgroundActivityScheduler {
    enum Result {
        Finished = 1,
        Deferred = 2
    }
}
declare namespace NSBezierPath {
    enum ElementType {
        MoveTo = 0,
        LineTo = 1,
        CurveTo = 2,
        ClosePath = 3
    }
    enum LineCapStyle {
        Butt = 0,
        Round = 1,
        Square = 2
    }
    enum LineJoinStyle {
        Miter = 0,
        Round = 1,
        Bevel = 2
    }
    enum WindingRule {
        NonZero = 0,
        EvenOdd = 1
    }
}
declare namespace NSBindingInfoKey {
}
declare namespace NSBindingName {
}
declare namespace NSBindingOption {
}
declare namespace NSBitmapImageRep {
    enum Format {
        AlphaFirst = 1,
        AlphaNonpremultiplied = 2,
        FloatingPointSamples = 4,
        SixteenBitLittleEndian = 256,
        ThirtyTwoBitLittleEndian = 512,
        SixteenBitBigEndian = 1024,
        ThirtyTwoBitBigEndian = 2048
    }
    enum FileType {
        TIFF = 0,
        BMP = 1,
        GIF = 2,
        JPEG = 3,
        PNG = 4,
        JPEG2000 = 5
    }
    enum LoadStatus {
        UnknownType = -1,
        ReadingHeader = -2,
        WillNeedAllData = -3,
        InvalidData = -4,
        UnexpectedEOF = -5,
        Completed = -6
    }
    enum TIFFCompression {
        None = 1,
        CCITTFAX3 = 3,
        CCITTFAX4 = 4,
        LZW = 5,
        JPEG = 6,
        NEXT = 32766,
        PackBits = 32773,
        OldJPEG = 32865
    }
}
declare namespace NSBox {
    enum BoxType {
        Primary = 0,
        Separator = 2,
        Custom = 4
    }
    enum TitlePosition {
        NoTitle = 0,
        AboveTop = 1,
        AtTop = 2,
        BelowTop = 3,
        AboveBottom = 4,
        AtBottom = 5,
        BelowBottom = 6
    }
}
declare namespace NSBrowser {
    enum ColumnResizingType {
        NoColumnResizing = 0,
        AutoColumnResizing = 1,
        UserColumnResizing = 2
    }
    enum DropOperation {
        On = 0,
        Above = 1
    }
}
declare namespace NSButton {
    enum BezelStyle {
        Rounded = 1,
        RegularSquare = 2,
        Disclosure = 5,
        ShadowlessSquare = 6,
        Circular = 7,
        TexturedSquare = 8,
        HelpButton = 9,
        SmallSquare = 10,
        TexturedRounded = 11,
        RoundRect = 12,
        Recessed = 13,
        RoundedDisclosure = 14,
        Inline = 15
    }
    enum ButtonType {
        MomentaryLight = 0,
        PushOnPushOff = 1,
        Toggle = 2,
        Switch = 3,
        Radio = 4,
        MomentaryChange = 5,
        OnOff = 6,
        MomentaryPushIn = 7,
        Accelerator = 8,
        MultiLevelAccelerator = 9
    }
}
declare namespace NSCalendar {
    enum Options {
        WrapComponents = 1,
        MatchStrictly = 2,
        SearchBackwards = 4,
        MatchPreviousTimePreservingSmallerUnits = 256,
        MatchNextTimePreservingSmallerUnits = 512,
        MatchNextTime = 1024,
        MatchFirst = 4096,
        MatchLast = 8192
    }
    enum Unit {
        CalendarUnitEra = 2,
        CalendarUnitYear = 4,
        CalendarUnitMonth = 8,
        CalendarUnitDay = 16,
        CalendarUnitHour = 32,
        CalendarUnitMinute = 64,
        CalendarUnitSecond = 128,
        CalendarUnitWeekday = 512,
        CalendarUnitWeekdayOrdinal = 1024,
        CalendarUnitQuarter = 2048,
        CalendarUnitWeekOfMonth = 4096,
        CalendarUnitWeekOfYear = 8192,
        CalendarUnitYearForWeekOfYear = 16384,
        CalendarUnitNanosecond = 32768,
        CalendarUnitCalendar = 1048576,
        CalendarUnitTimeZone = 2097152,
        EraCalendarUnit = 2,
        YearCalendarUnit = 4,
        MonthCalendarUnit = 8,
        DayCalendarUnit = 16,
        HourCalendarUnit = 32,
        MinuteCalendarUnit = 64,
        SecondCalendarUnit = 128,
        WeekCalendarUnit = 256,
        WeekdayCalendarUnit = 512,
        WeekdayOrdinalCalendarUnit = 1024,
        QuarterCalendarUnit = 2048,
        WeekOfMonthCalendarUnit = 4096,
        WeekOfYearCalendarUnit = 8192,
        YearForWeekOfYearCalendarUnit = 16384,
        CalendarCalendarUnit = 1048576,
        TimeZoneCalendarUnit = 2097152
    }
}
declare namespace NSCell {
    enum Attribute {
        CellDisabled = 0,
        CellState = 1,
        PushInCell = 2,
        CellEditable = 3,
        ChangeGrayCell = 4,
        CellHighlighted = 5,
        CellLightsByContents = 6,
        CellLightsByGray = 7,
        ChangeBackgroundCell = 8,
        CellLightsByBackground = 9,
        CellIsBordered = 10,
        CellHasOverlappingImage = 11,
        CellHasImageHorizontal = 12,
        CellHasImageOnLeftOrBottom = 13,
        CellChangesContents = 14,
        CellIsInsetButton = 15,
        CellAllowsMixedState = 16
    }
    enum HitResult {
        None = 0,
        ContentArea = 1,
        EditableTextArea = 2,
        TrackableArea = 4
    }
    enum StyleMask {
        NoCellMask = 0,
        ContentsCellMask = 1,
        PushInCellMask = 2,
        ChangeGrayCellMask = 4,
        ChangeBackgroundCellMask = 8
    }
    enum CellType {
        NullCellType = 0,
        TextCellType = 1,
        ImageCellType = 2
    }
}
declare namespace NSCoder {
    enum DecodingFailurePolicy {
        RaiseException = 0,
        SetErrorAndReturn = 1
    }
}
declare namespace NSCollectionView {
    enum UpdateAction {
        Insert = 0,
        Delete = 1,
        Reload = 2,
        Move = 3,
        None = 4
    }
    enum DropOperation {
        On = 0,
        Before = 1
    }
    enum ScrollDirection {
        Vertical = 0,
        Horizontal = 1
    }
    enum ScrollPosition {
        None = 0,
        Top = 1,
        CenteredVertically = 2,
        Bottom = 4,
        NearestHorizontalEdge = 512,
        Left = 8,
        CenteredHorizontally = 16,
        Right = 32,
        LeadingEdge = 64,
        TrailingEdge = 128,
        NearestVerticalEdge = 256
    }
}
declare namespace NSCollectionViewItem {
    enum HighlightState {
        None = 0,
        ForSelection = 1,
        ForDeselection = 2,
        AsDropTarget = 3
    }
}
declare namespace NSCollectionViewTransitionLayout {
}
declare namespace NSColor {
    enum SystemEffect {
        None = 0,
        Pressed = 1,
        DeepPressed = 2,
        Disabled = 3,
        Rollover = 4
    }
    enum ColorType {
        ComponentBased = 0,
        Pattern = 1,
        Catalog = 2
    }
}
declare namespace NSColorList {
}
declare namespace NSColorPanel {
    enum Mode {
        None = -1,
        Gray = 0,
        RGB = 1,
        CMYK = 2,
        HSB = 3,
        CustomPalette = 4,
        ColorList = 5,
        Wheel = 6,
        Crayon = 7
    }
    enum Options {
        GrayModeMask = 1,
        RGBModeMask = 2,
        CMYKModeMask = 4,
        HSBModeMask = 8,
        CustomPaletteModeMask = 16,
        ColorListModeMask = 32,
        WheelModeMask = 64,
        CrayonModeMask = 128,
        AllModesMask = 65535
    }
}
declare namespace NSColorSpace {
    enum Model {
        Unknown = -1,
        Gray = 0,
        RGB = 1,
        CMYK = 2,
        LAB = 3,
        DeviceN = 4,
        Indexed = 5,
        Patterned = 6
    }
}
declare namespace NSColorSpaceName {
}
declare namespace NSComboBox {
}
declare namespace NSComparisonPredicate {
    enum Modifier {
        DirectPredicateModifier = 0,
        AllPredicateModifier = 1,
        AnyPredicateModifier = 2
    }
    enum Options {
        CaseInsensitivePredicateOption = 1,
        DiacriticInsensitivePredicateOption = 2,
        NormalizedPredicateOption = 4
    }
    enum Operator {
        LessThanPredicateOperatorType = 0,
        LessThanOrEqualToPredicateOperatorType = 1,
        GreaterThanPredicateOperatorType = 2,
        GreaterThanOrEqualToPredicateOperatorType = 3,
        EqualToPredicateOperatorType = 4,
        NotEqualToPredicateOperatorType = 5,
        MatchesPredicateOperatorType = 6,
        LikePredicateOperatorType = 7,
        BeginsWithPredicateOperatorType = 8,
        EndsWithPredicateOperatorType = 9,
        InPredicateOperatorType = 10,
        CustomSelectorPredicateOperatorType = 11,
        ContainsPredicateOperatorType = 99,
        BetweenPredicateOperatorType = 100
    }
}
declare namespace NSCompoundPredicate {
    enum LogicalType {
        NotPredicateType = 0,
        AndPredicateType = 1,
        OrPredicateType = 2
    }
}
declare namespace NSControl {
    enum ImagePosition {
        NoImage = 0,
        ImageOnly = 1,
        ImageLeft = 2,
        ImageRight = 3,
        ImageBelow = 4,
        ImageAbove = 5,
        ImageOverlaps = 6,
        ImageLeading = 7,
        ImageTrailing = 8
    }
    enum ControlSize {
        Regular = 0,
        Small = 1,
        Mini = 2
    }
}
declare namespace NSData {
    enum Base64DecodingOptions {
        IgnoreUnknownCharacters = 1
    }
    enum Base64EncodingOptions {
        Encoding64CharacterLineLength = 1,
        Encoding76CharacterLineLength = 2,
        EncodingEndLineWithCarriageReturn = 16,
        EncodingEndLineWithLineFeed = 32
    }
    enum CompressionAlgorithm {
        LZFSE = 0,
        LZ4 = 1,
        LZMA = 2,
        Zlib = 3
    }
    enum ReadingOptions {
        DataReadingMappedIfSafe = 1,
        DataReadingUncached = 2,
        DataReadingMappedAlways = 8,
        DataReadingMapped = 1,
        MappedRead = 1,
        UncachedRead = 2
    }
    enum SearchOptions {
        Backwards = 1,
        Anchored = 2
    }
    enum WritingOptions {
        DataWritingAtomic = 1,
        DataWritingWithoutOverwriting = 2,
        DataWritingFileProtectionNone = 268435456,
        DataWritingFileProtectionComplete = 536870912,
        DataWritingFileProtectionCompleteUnlessOpen = 805306368,
        DataWritingFileProtectionCompleteUntilFirstUserAuthentication = 1073741824,
        DataWritingFileProtectionMask = 4026531840,
        AtomicWrite = 1
    }
}
declare namespace NSDatePicker {
    enum ElementFlags {
        HourMinute = 12,
        HourMinuteSecond = 14,
        TimeZone = 16,
        YearMonth = 192,
        YearMonthDay = 224,
        Era = 256
    }
    enum Mode {
        Single = 0,
        Range = 1
    }
    enum Style {
        TextFieldAndStepper = 0,
        ClockAndCalendar = 1,
        TextField = 2
    }
}
declare namespace NSDecimalNumber {
    enum CalculationError {
        NoError = 0,
        LossOfPrecision = 1,
        Underflow = 2,
        Overflow = 3,
        DivideByZero = 4
    }
    enum RoundingMode {
        Plain = 0,
        Down = 1,
        Up = 2,
        Bankers = 3
    }
}
declare namespace NSDeviceDescriptionKey {
}
declare namespace NSDocument {
    enum ChangeType {
        ChangeDone = 0,
        ChangeUndone = 1,
        ChangeRedone = 5,
        ChangeCleared = 2,
        ChangeReadOtherContents = 3,
        ChangeAutosaved = 4,
        ChangeDiscardable = 256
    }
    enum SaveOperationType {
        SaveOperation = 0,
        SaveAsOperation = 1,
        SaveToOperation = 2,
        AutosaveInPlaceOperation = 4,
        AutosaveElsewhereOperation = 3,
        AutosaveAsOperation = 5,
        AutosaveOperation = 3
    }
}
declare namespace NSDraggingItem {
}
declare namespace NSDrawer {
    enum State {
        ClosedState = 0,
        OpeningState = 1,
        OpenState = 2,
        ClosingState = 3
    }
}
declare namespace NSEnumerator {
}
declare namespace NSError {
}
declare namespace NSEvent {
    enum ButtonMask {
        PenTip = 1,
        PenLowerSide = 2,
        PenUpperSide = 4
    }
    enum GestureAxis {
        None = 0,
        Horizontal = 1,
        Vertical = 2
    }
    enum EventTypeMask {
        LeftMouseDown = 2,
        LeftMouseUp = 4,
        RightMouseDown = 8,
        RightMouseUp = 16,
        MouseMoved = 32,
        LeftMouseDragged = 64,
        RightMouseDragged = 128,
        MouseEntered = 256,
        MouseExited = 512,
        KeyDown = 1024,
        KeyUp = 2048,
        FlagsChanged = 4096,
        AppKitDefined = 8192,
        SystemDefined = 16384,
        ApplicationDefined = 32768,
        Periodic = 65536,
        CursorUpdate = 131072,
        ScrollWheel = 4194304,
        TabletPoint = 8388608,
        TabletProximity = 16777216,
        OtherMouseDown = 33554432,
        OtherMouseUp = 67108864,
        OtherMouseDragged = 134217728,
        Gesture = 536870912,
        Magnify = 1073741824,
        Swipe = 2147483648,
        Rotate = 262144,
        BeginGesture = 524288,
        EndGesture = 1048576,
        SmartMagnify = 4294967296,
        Pressure = 17179869184,
        DirectTouch = 137438953472,
        ChangeMode = 274877906944,
        Any = -1
    }
    enum ModifierFlags {
        CapsLock = 65536,
        Shift = 131072,
        Control = 262144,
        Option = 524288,
        Command = 1048576,
        NumericPad = 2097152,
        Help = 4194304,
        Function = 8388608,
        DeviceIndependentFlagsMask = 4294901760
    }
    enum Phase {
        None = 0,
        Began = 1,
        Stationary = 2,
        Changed = 4,
        Ended = 8,
        Cancelled = 16,
        MayBegin = 32
    }
    enum EventSubtype {
        WindowExposed = 0,
        ApplicationActivated = 1,
        ApplicationDeactivated = 2,
        WindowMoved = 4,
        ScreenChanged = 8,
        PowerOff = 1,
        MouseEvent = 0,
        TabletPoint = 1,
        TabletProximity = 2,
        Touch = 3
    }
    enum SwipeTrackingOptions {
        LockDirection = 1,
        ClampGestureAmount = 2
    }
    enum EventType {
        LeftMouseDown = 1,
        LeftMouseUp = 2,
        RightMouseDown = 3,
        RightMouseUp = 4,
        MouseMoved = 5,
        LeftMouseDragged = 6,
        RightMouseDragged = 7,
        MouseEntered = 8,
        MouseExited = 9,
        KeyDown = 10,
        KeyUp = 11,
        FlagsChanged = 12,
        AppKitDefined = 13,
        SystemDefined = 14,
        ApplicationDefined = 15,
        Periodic = 16,
        CursorUpdate = 17,
        ScrollWheel = 22,
        TabletPoint = 23,
        TabletProximity = 24,
        OtherMouseDown = 25,
        OtherMouseUp = 26,
        OtherMouseDragged = 27,
        Gesture = 29,
        Magnify = 30,
        Swipe = 31,
        Rotate = 18,
        BeginGesture = 19,
        EndGesture = 20,
        SmartMagnify = 32,
        QuickLook = 33,
        Pressure = 34,
        DirectTouch = 37,
        ChangeMode = 38
    }
    enum PointingDeviceType {
        Unknown = 0,
        Pen = 1,
        Cursor = 2,
        Eraser = 3
    }
    enum PressureBehavior {
        Unknown = -1,
        PrimaryDefault = 0,
        PrimaryClick = 1,
        PrimaryGeneric = 2,
        PrimaryAccelerator = 3,
        PrimaryDeepClick = 5,
        PrimaryDeepDrag = 6
    }
}
declare namespace NSExceptionName {
}
declare namespace NSExpression {
    enum ExpressionType {
        ConstantValueExpressionType = 0,
        EvaluatedObjectExpressionType = 1,
        VariableExpressionType = 2,
        KeyPathExpressionType = 3,
        FunctionExpressionType = 4,
        UnionSetExpressionType = 5,
        IntersectSetExpressionType = 6,
        MinusSetExpressionType = 7,
        SubqueryExpressionType = 13,
        AggregateExpressionType = 14,
        AnyKeyExpressionType = 15,
        BlockExpressionType = 19,
        ConditionalExpressionType = 20
    }
}
declare namespace NSFileCoordinator {
    enum ReadingOptions {
        WithoutChanges = 1,
        ResolvesSymbolicLink = 2,
        ImmediatelyAvailableMetadataOnly = 4,
        ForUploading = 8
    }
    enum WritingOptions {
        ForDeleting = 1,
        ForMoving = 2,
        ForMerging = 4,
        ForReplacing = 8,
        ContentIndependentMetadataOnly = 16
    }
}
declare namespace NSFileVersion {
    enum AddingOptions {
        ByMoving = 1
    }
    enum ReplacingOptions {
        ByMoving = 1
    }
}
declare namespace NSFont {
}
declare namespace NSFontAssetRequest {
    enum Options {
        UsesStandardUI = 1
    }
}
declare namespace NSFontCollection {
    enum Visibility {
        Process = 1,
        User = 2,
        Computer = 4
    }
}
declare namespace NSFontDescriptor {
    enum SymbolicTraits {
        TraitItalic = 1,
        TraitBold = 2,
        TraitExpanded = 32,
        TraitCondensed = 64,
        TraitMonoSpace = 1024,
        TraitVertical = 2048,
        TraitUIOptimized = 4096,
        TraitTightLeading = 32768,
        TraitLooseLeading = 65536,
        ClassMask = 4026531840,
        ClassUnknown = 0,
        ClassOldStyleSerifs = 268435456,
        ClassTransitionalSerifs = 536870912,
        ClassModernSerifs = 805306368,
        ClassClarendonSerifs = 1073741824,
        ClassSlabSerifs = 1342177280,
        ClassFreeformSerifs = 1879048192,
        ClassSansSerif = 2147483648,
        ClassOrnamentals = 2415919104,
        ClassScripts = 2684354560,
        ClassSymbolic = 3221225472
    }
}
declare namespace NSFontPanel {
    enum ModeMask {
        ModeMaskFace = 1,
        ModeMaskSize = 2,
        ModeMaskCollection = 4,
        ModeMaskUnderlineEffect = 256,
        ModeMaskStrikethroughEffect = 512,
        ModeMaskTextColorEffect = 1024,
        ModeMaskDocumentColorEffect = 2048,
        ModeMaskShadowEffect = 4096,
        ModeMaskAllEffects = 1048320,
        ModesMaskStandardModes = 65535,
        ModesMaskAllModes = 4294967295
    }
}
declare namespace NSGestureRecognizer {
    enum State {
        Possible = 0,
        Began = 1,
        Changed = 2,
        Ended = 3,
        Cancelled = 4,
        Failed = 5,
        Recognized = 3
    }
}
declare namespace NSGradient {
    enum DrawingOptions {
        DrawsBeforeStartingLocation = 1,
        DrawsAfterEndingLocation = 2
    }
}
declare namespace NSGraphicsContext {
}
declare namespace NSGridCell {
    enum Placement {
        Inherited = 0,
        None = 1,
        Leading = 2,
        Top = 2,
        Trailing = 3,
        Bottom = 3,
        Center = 4,
        Fill = 5
    }
}
declare namespace NSGridRow {
    enum Alignment {
        Inherited = 0,
        None = 1,
        FirstBaseline = 2,
        LastBaseline = 3
    }
}
declare namespace NSGridView {
}
declare namespace NSHapticFeedbackManager {
    enum FeedbackPattern {
        Generic = 0,
        Alignment = 1,
        LevelChange = 2
    }
    enum PerformanceTime {
        Default = 0,
        Now = 1,
        DrawCompleted = 2
    }
}
declare namespace NSHelpManager {
}
declare namespace NSImage {
    enum CacheMode {
        Default = 0,
        Always = 1,
        BySize = 2,
        Never = 3
    }
    enum LayoutDirection {
        Unspecified = -1,
        LeftToRight = 2,
        RightToLeft = 3
    }
    enum LoadStatus {
        Completed = 0,
        Cancelled = 1,
        InvalidData = 2,
        UnexpectedEOF = 3,
        ReadError = 4
    }
    enum ResizingMode {
        Stretch = 0,
        Tile = 1
    }
}
declare namespace NSImageRep {
}
declare namespace NSImageView {
    enum FrameStyle {
        None = 0,
        Photo = 1,
        GrayBezel = 2,
        Groove = 3,
        Button = 4
    }
}
declare namespace NSIndexSet {
}
declare namespace NSItemProvider {
    enum ErrorCode {
        UnknownError = -1,
        ItemUnavailableError = -1000,
        UnexpectedValueClassError = -1100,
        UnavailableCoercionError = -1200
    }
}
declare namespace NSKeyValueChangeKey {
}
declare namespace NSKeyValueOperator {
}
declare namespace NSLayoutConstraint {
    enum Attribute {
        Left = 1,
        Right = 2,
        Top = 3,
        Bottom = 4,
        Leading = 5,
        Trailing = 6,
        Width = 7,
        Height = 8,
        CenterX = 9,
        CenterY = 10,
        LastBaseline = 11,
        Baseline = 11,
        FirstBaseline = 12,
        NotAnAttribute = 0
    }
    enum Orientation {
        Horizontal = 0,
        Vertical = 1
    }
    enum FormatOptions {
        AlignAllLeft = 2,
        AlignAllRight = 4,
        AlignAllTop = 8,
        AlignAllBottom = 16,
        AlignAllLeading = 32,
        AlignAllTrailing = 64,
        AlignAllCenterX = 512,
        AlignAllCenterY = 1024,
        AlignAllLastBaseline = 2048,
        AlignAllFirstBaseline = 4096,
        AlignAllBaseline = 2048,
        AlignmentMask = 65535,
        DirectionLeadingToTrailing = 0,
        DirectionLeftToRight = 65536,
        DirectionRightToLeft = 131072,
        DirectionMask = 196608
    }
    enum Relation {
        LessThanOrEqual = -1,
        Equal = 0,
        GreaterThanOrEqual = 1
    }
}
declare namespace NSLayoutManager {
    enum ControlCharacterAction {
        ZeroAdvancement = 1,
        Whitespace = 2,
        HorizontalTab = 4,
        LineBreak = 8,
        ParagraphBreak = 16,
        ContainerBreak = 32
    }
    enum GlyphProperty {
        Null = 1,
        ControlCharacter = 2,
        Elastic = 4,
        NonBaseCharacter = 8
    }
    enum TextLayoutOrientation {
        Horizontal = 0,
        Vertical = 1
    }
    enum TypesetterBehavior {
        LatestBehavior = -1,
        OriginalBehavior = 0,
        Behavior_10_2_WithCompatibility = 1,
        Behavior_10_2 = 2,
        Behavior_10_3 = 3,
        Behavior_10_4 = 4
    }
}
declare namespace NSLevelIndicator {
    enum PlaceholderVisibility {
        Automatic = 0,
        Always = 1,
        WhileEditing = 2
    }
    enum Style {
        Relevancy = 0,
        ContinuousCapacity = 1,
        DiscreteCapacity = 2,
        Rating = 3
    }
}
declare namespace NSLinguisticTag {
}
declare namespace NSLinguisticTagScheme {
}
declare namespace NSLinguisticTagger {
    enum Options {
        OmitWords = 1,
        OmitPunctuation = 2,
        OmitWhitespace = 4,
        OmitOther = 8,
        JoinNames = 16
    }
}
declare namespace NSLocale {
    enum LanguageDirection {
        Unknown = 0,
        LeftToRight = 1,
        RightToLeft = 2,
        TopToBottom = 3,
        BottomToTop = 4
    }
}
declare namespace NSMachPort {
    enum Options {
        DeallocateNone = 0,
        DeallocateSendRight = 1,
        DeallocateReceiveRight = 2
    }
}
declare namespace NSMatrix {
    enum Mode {
        RadioModeMatrix = 0,
        HighlightModeMatrix = 1,
        ListModeMatrix = 2,
        TrackModeMatrix = 3
    }
}
declare namespace NSMediaLibraryBrowserController {
    enum Library {
        Audio = 1,
        Image = 2,
        Movie = 4
    }
}
declare namespace NSMenu {
    enum Properties {
        PropertyItemTitle = 1,
        PropertyItemAttributedTitle = 2,
        PropertyItemKeyEquivalent = 4,
        PropertyItemImage = 8,
        PropertyItemEnabled = 16,
        PropertyItemAccessibilityDescription = 32
    }
}
declare namespace NSMenuItem {
}
declare namespace NSNib {
}
declare namespace NSNotification {
}
declare namespace NSNumber {
}
declare namespace NSOrderedSet {
}
declare namespace NSOutlineView {
}
declare namespace NSPDFPanel {
    enum Options {
        ShowsPaperSize = 4,
        ShowsOrientation = 8,
        RequestsParentDirectory = 16777216
    }
}
declare namespace NSPageController {
    enum TransitionStyle {
        StackHistory = 0,
        StackBook = 1,
        HorizontalStrip = 2
    }
}
declare namespace NSParagraphStyle {
    enum TextTabType {
        LeftTabStopType = 0,
        RightTabStopType = 1,
        CenterTabStopType = 2,
        DecimalTabStopType = 3
    }
    enum LineBreakStrategy {
        pushOut = 0,
        hangulWordPriority = 1,
        standard = 2
    }
}
declare namespace NSPasteboard {
    enum ContentsOptions {
        CurrentHostOnly = 1
    }
    enum ReadingOptions {
        AsData = 0,
        AsString = 1,
        AsPropertyList = 2,
        AsKeyedArchive = 4
    }
    enum WritingOptions {
        Promised = 512
    }
}
declare namespace NSPathControl {
    enum Style {
        Standard = 0,
        PopUp = 2,
        NavigationBar = 1
    }
}
declare namespace NSPickerTouchBarItem {
    enum ControlRepresentation {
        Automatic = 0,
        Expanded = 1,
        Collapsed = 2
    }
    enum SelectionMode {
        SelectOne = 0,
        SelectAny = 1,
        Momentary = 2
    }
}
declare namespace NSPointerFunctions {
    enum Options {
        StrongMemory = 0,
        ZeroingWeakMemory = 1,
        OpaqueMemory = 2,
        MallocMemory = 3,
        MachVirtualMemory = 4,
        WeakMemory = 5,
        ObjectPersonality = 0,
        OpaquePersonality = 256,
        ObjectPointerPersonality = 512,
        CStringPersonality = 768,
        StructPersonality = 1024,
        IntegerPersonality = 1280,
        CopyIn = 65536
    }
}
declare namespace NSPopUpButton {
    enum ArrowPosition {
        NoArrow = 0,
        ArrowAtCenter = 1,
        ArrowAtBottom = 2
    }
}
declare namespace NSPopUpButtonCell {
}
declare namespace NSPopover {
    enum Behavior {
        ApplicationDefined = 0,
        Transient = 1,
        Semitransient = 2
    }
}
declare namespace NSPositionalSpecifier {
    enum InsertionPosition {
        PositionAfter = 0,
        PositionBefore = 1,
        PositionBeginning = 2,
        PositionEnd = 3,
        PositionReplace = 4
    }
}
declare namespace NSPrintInfo {
    enum PaperOrientation {
        Portrait = 0,
        Landscape = 1
    }
    enum PaginationMode {
        Automatic = 0,
        Fit = 1,
        Clip = 2
    }
}
declare namespace NSPrintOperation {
    enum RenderingQuality {
        Best = 0,
        Responsive = 1
    }
    enum PageOrder {
        DescendingPageOrder = -1,
        SpecialPageOrder = 0,
        AscendingPageOrder = 1,
        UnknownPageOrder = 2
    }
}
declare namespace NSPrintPanel {
    enum Options {
        ShowsCopies = 1,
        ShowsPageRange = 2,
        ShowsPaperSize = 4,
        ShowsOrientation = 8,
        ShowsScaling = 16,
        ShowsPrintSelection = 32,
        ShowsPageSetupAccessory = 256,
        ShowsPreview = 131072
    }
}
declare namespace NSPrinter {
    enum TableStatus {
        OK = 0,
        NotFound = 1,
        Error = 2
    }
}
declare namespace NSProgressIndicator {
    enum Style {
        Bar = 0,
        Spinning = 1
    }
}
declare namespace NSRegularExpression {
    enum MatchingFlags {
        Progress = 1,
        Completed = 2,
        HitEnd = 4,
        RequiredEnd = 8,
        InternalError = 16
    }
    enum MatchingOptions {
        ReportProgress = 1,
        ReportCompletion = 2,
        Anchored = 4,
        WithTransparentBounds = 8,
        WithoutAnchoringBounds = 16
    }
    enum Options {
        CaseInsensitive = 1,
        AllowCommentsAndWhitespace = 2,
        IgnoreMetacharacters = 4,
        DotMatchesLineSeparators = 8,
        AnchorsMatchLines = 16,
        UseUnixLineSeparators = 32,
        UseUnicodeWordBoundaries = 64
    }
}
declare namespace NSRelativeSpecifier {
    enum RelativePosition {
        After = 0,
        Before = 1
    }
}
declare namespace NSRuleEditor {
    enum NestingMode {
        Single = 0,
        List = 1,
        Compound = 2,
        Simple = 3
    }
    enum RowType {
        Simple = 0,
        Compound = 1
    }
}
declare namespace NSRulerView {
    enum Orientation {
        HorizontalRuler = 0,
        VerticalRuler = 1
    }
}
declare namespace NSScreen {
}
declare namespace NSScrollView {
    enum Elasticity {
        Automatic = 0,
        None = 1,
        Allowed = 2
    }
    enum FindBarPosition {
        AboveHorizontalRuler = 0,
        AboveContent = 1,
        BelowContent = 2
    }
}
declare namespace NSScroller {
    enum KnobStyle {
        Default = 0,
        Dark = 1,
        Light = 2
    }
    enum Part {
        NoPart = 0,
        DecrementPage = 1,
        Knob = 2,
        IncrementPage = 3,
        DecrementLine = 4,
        IncrementLine = 5,
        KnobSlot = 6
    }
    enum Style {
        Legacy = 0,
        Overlay = 1
    }
    enum UsableParts {
        NoScrollerParts = 0,
        OnlyScrollerArrows = 1,
        AllScrollerParts = 2
    }
}
declare namespace NSScrubber {
    enum Alignment {
        None = 0,
        Leading = 1,
        Trailing = 2,
        Center = 3
    }
    enum Mode {
        Fixed = 0,
        Free = 1
    }
}
declare namespace NSSearchField {
}
declare namespace NSSegmentedControl {
    enum Distribution {
        Fit = 0,
        Fill = 1,
        FillEqually = 2,
        FillProportionally = 3
    }
    enum Style {
        Automatic = 0,
        Rounded = 1,
        RoundRect = 3,
        TexturedSquare = 4,
        SmallSquare = 6,
        Separated = 8,
        TexturedRounded = 2,
        Capsule = 5
    }
    enum SwitchTracking {
        SelectOne = 0,
        SelectAny = 1,
        Momentary = 2,
        MomentaryAccelerator = 3
    }
}
declare namespace NSSet {
}
declare namespace NSSharingService {
    enum CloudKitOptions {
        Standard = 0,
        AllowPublic = 1,
        AllowPrivate = 2,
        AllowReadOnly = 16,
        AllowReadWrite = 32
    }
    enum SharingContentScope {
        Item = 0,
        Partial = 1,
        Full = 2
    }
}
declare namespace NSSlider {
    enum SliderType {
        Linear = 0,
        Circular = 1
    }
    enum TickMarkPosition {
        Below = 0,
        Above = 1,
        Leading = 1,
        Trailing = 0
    }
}
declare namespace NSSliderAccessory {
}
declare namespace NSSound {
}
declare namespace NSSpecifierTest {
    enum TestComparisonOperation {
        EqualToComparison = 0,
        LessThanOrEqualToComparison = 1,
        LessThanComparison = 2,
        GreaterThanOrEqualToComparison = 3,
        GreaterThanComparison = 4,
        BeginsWithComparison = 5,
        EndsWithComparison = 6,
        ContainsComparison = 7
    }
}
declare namespace NSSpeechSynthesizer {
    enum Boundary {
        ImmediateBoundary = 0,
        WordBoundary = 1,
        SentenceBoundary = 2
    }
}
declare namespace NSSpellChecker {
    enum CorrectionIndicatorType {
        Default = 0,
        Reversion = 1,
        Guesses = 2
    }
    enum CorrectionResponse {
        None = 0,
        Accepted = 1,
        Rejected = 2,
        Ignored = 3,
        Edited = 4,
        Reverted = 5
    }
}
declare namespace NSSplitView {
    enum DividerStyle {
        Thick = 1,
        Thin = 2,
        PaneSplitter = 3
    }
}
declare namespace NSSplitViewController {
}
declare namespace NSSplitViewItem {
    enum Behavior {
        Default = 0,
        Sidebar = 1,
        ContentList = 2
    }
    enum CollapseBehavior {
        Default = 0,
        PreferResizingSplitViewWithFixedSiblings = 1,
        PreferResizingSiblingsWithFixedSplitView = 2,
        UseConstraints = 3
    }
}
declare namespace NSStackView {
    enum Distribution {
        GravityAreas = -1,
        Fill = 0,
        FillEqually = 1,
        FillProportionally = 2,
        EqualSpacing = 3,
        EqualCentering = 4
    }
    enum Gravity {
        Top = 1,
        Leading = 1,
        Center = 2,
        Bottom = 3,
        Trailing = 3
    }
}
declare namespace NSStatusItem {
    enum Behavior {
        RemovalAllowed = 2,
        TerminationOnRemoval = 4
    }
}
declare namespace NSStoryboard {
}
declare namespace NSStoryboardSegue {
}
declare namespace NSString {
    enum DrawingOptions {
        UsesLineFragmentOrigin = 1,
        UsesFontLeading = 2,
        UsesDeviceMetrics = 8,
        TruncatesLastVisibleLine = 32,
        DisableScreenFontSubstitution = 4,
        OneShot = 16
    }
    enum CompareOptions {
        CaseInsensitiveSearch = 1,
        LiteralSearch = 2,
        BackwardsSearch = 4,
        AnchoredSearch = 8,
        NumericSearch = 64,
        DiacriticInsensitiveSearch = 128,
        WidthInsensitiveSearch = 256,
        ForcedOrderingSearch = 512,
        RegularExpressionSearch = 1024
    }
    enum EncodingConversionOptions {
        AllowLossy = 1,
        ExternalRepresentation = 2
    }
    enum EnumerationOptions {
        ByLines = 0,
        ByParagraphs = 1,
        ByComposedCharacterSequences = 2,
        ByWords = 3,
        BySentences = 4,
        Reverse = 256,
        SubstringNotRequired = 512,
        Localized = 1024
    }
}
declare namespace NSTabView {
    enum TabPosition {
        None = 0,
        Top = 1,
        Left = 2,
        Bottom = 3,
        Right = 4
    }
    enum TabViewBorderType {
        None = 0,
        Line = 1,
        Bezel = 2
    }
    enum TabType {
        TopTabsBezelBorder = 0,
        LeftTabsBezelBorder = 1,
        BottomTabsBezelBorder = 2,
        RightTabsBezelBorder = 3,
        NoTabsBezelBorder = 4,
        NoTabsLineBorder = 5,
        NoTabsNoBorder = 6
    }
}
declare namespace NSTabViewController {
    enum TabStyle {
        SegmentedControlOnTop = 0,
        SegmentedControlOnBottom = 1,
        Toolbar = 2,
        Unspecified = -1
    }
}
declare namespace NSTabViewItem {
    enum State {
        SelectedTab = 0,
        BackgroundTab = 1,
        PressedTab = 2
    }
}
declare namespace NSTableColumn {
    enum ResizingOptions {
        NoResizing = 0,
        AutoresizingMask = 1,
        UserResizingMask = 2
    }
}
declare namespace NSTableView {
    enum RowActionEdge {
        Leading = 0,
        Trailing = 1
    }
    enum AnimationOptions {
        EffectNone = 0,
        EffectFade = 1,
        EffectGap = 2,
        SlideUp = 16,
        SlideDown = 32,
        SlideLeft = 48,
        SlideRight = 64
    }
    enum ColumnAutoresizingStyle {
        NoColumnAutoresizing = 0,
        UniformColumnAutoresizingStyle = 1,
        SequentialColumnAutoresizingStyle = 2,
        ReverseSequentialColumnAutoresizingStyle = 3,
        LastColumnOnlyAutoresizingStyle = 4,
        FirstColumnOnlyAutoresizingStyle = 5
    }
    enum DraggingDestinationFeedbackStyle {
        None = -1,
        Regular = 0,
        SourceList = 1,
        Gap = 2
    }
    enum DropOperation {
        On = 0,
        Above = 1
    }
    enum GridLineStyle {
        GridNone = 0,
        SolidVerticalGridLineMask = 1,
        SolidHorizontalGridLineMask = 2,
        DashedHorizontalGridLineMask = 8
    }
    enum RowSizeStyle {
        Default = -1,
        Custom = 0,
        Small = 1,
        Medium = 2,
        Large = 3
    }
    enum SelectionHighlightStyle {
        None = -1,
        Regular = 0,
        SourceList = 1
    }
}
declare namespace NSTableViewRowAction {
    enum Style {
        Regular = 0,
        Destructive = 1
    }
}
declare namespace NSText {
}
declare namespace NSTextAlternatives {
}
declare namespace NSTextBlock {
    enum Dimension {
        Width = 0,
        MinimumWidth = 1,
        MaximumWidth = 2,
        Height = 4,
        MinimumHeight = 5,
        MaximumHeight = 6
    }
    enum Layer {
        Padding = -1,
        Border = 0,
        Margin = 1
    }
    enum ValueType {
        AbsoluteValueType = 0,
        PercentageValueType = 1
    }
    enum VerticalAlignment {
        TopAlignment = 0,
        MiddleAlignment = 1,
        BottomAlignment = 2,
        BaselineAlignment = 3
    }
}
declare namespace NSTextCheckingKey {
}
declare namespace NSTextCheckingResult {
    enum CheckingType {
        Orthography = 1,
        Spelling = 2,
        Grammar = 4,
        Date = 8,
        Address = 16,
        Link = 32,
        Quote = 64,
        Dash = 128,
        Replacement = 256,
        Correction = 512,
        RegularExpression = 1024,
        PhoneNumber = 2048,
        TransitInformation = 4096
    }
}
declare namespace NSTextField {
    enum BezelStyle {
        SquareBezel = 0,
        RoundedBezel = 1
    }
}
declare namespace NSTextFinder {
    enum Action {
        ShowFindInterface = 1,
        NextMatch = 2,
        PreviousMatch = 3,
        ReplaceAll = 4,
        Replace = 5,
        ReplaceAndFind = 6,
        SetSearchString = 7,
        ReplaceAllInSelection = 8,
        SelectAll = 9,
        SelectAllInSelection = 10,
        HideFindInterface = 11,
        ShowReplaceInterface = 12,
        HideReplaceInterface = 13
    }
    enum MatchingType {
        Contains = 0,
        StartsWith = 1,
        FullWord = 2,
        EndsWith = 3
    }
}
declare namespace NSTextInputContext {
}
declare namespace NSTextList {
    enum Options {
        PrependEnclosingMarker = 1
    }
}
declare namespace NSTextStorage {
}
declare namespace NSTextTab {
}
declare namespace NSTextTable {
    enum LayoutAlgorithm {
        AutomaticLayoutAlgorithm = 0,
        FixedLayoutAlgorithm = 1
    }
}
declare namespace NSTextView {
}
declare namespace NSTimeZone {
    enum NameStyle {
        Standard = 0,
        ShortStandard = 1,
        DaylightSaving = 2,
        ShortDaylightSaving = 3,
        Generic = 4,
        ShortGeneric = 5
    }
}
declare namespace NSTokenField {
    enum TokenStyle {
        Default = 0,
        None = 1,
        Rounded = 2,
        Squared = 3,
        PlainSquared = 4
    }
}
declare namespace NSToolbar {
    enum DisplayMode {
        Default = 0,
        IconAndLabel = 1,
        IconOnly = 2,
        LabelOnly = 3
    }
    enum SizeMode {
        Default = 0,
        Regular = 1,
        Small = 2
    }
}
declare namespace NSToolbarItem {
}
declare namespace NSToolbarItemGroup {
    enum ControlRepresentation {
        Automatic = 0,
        Expanded = 1,
        Collapsed = 2
    }
    enum SelectionMode {
        SelectOne = 0,
        SelectAny = 1,
        Momentary = 2
    }
}
declare namespace NSTouch {
    enum Phase {
        Began = 1,
        Moved = 2,
        Stationary = 4,
        Ended = 8,
        Cancelled = 16,
        Touching = 7,
        Any = -1
    }
    enum TouchType {
        Direct = 0,
        Indirect = 1
    }
    enum TouchTypeMask {
        Direct = 1,
        Indirect = 2
    }
}
declare namespace NSTouchBar {
}
declare namespace NSTouchBarItem {
}
declare namespace NSTrackingArea {
    enum Options {
        MouseEnteredAndExited = 1,
        MouseMoved = 2,
        CursorUpdate = 4,
        ActiveWhenFirstResponder = 16,
        ActiveInKeyWindow = 32,
        ActiveInActiveApp = 64,
        ActiveAlways = 128,
        AssumeInside = 256,
        InVisibleRect = 512,
        EnabledDuringMouseDrag = 1024
    }
}
declare namespace NSURL {
    enum BookmarkCreationOptions {
        PreferFileIDResolution = 256,
        MinimalBookmark = 512,
        SuitableForBookmarkFile = 1024,
        WithSecurityScope = 2048,
        SecurityScopeAllowOnlyReadAccess = 4096
    }
    enum BookmarkResolutionOptions {
        WithoutUI = 256,
        WithoutMounting = 512,
        WithSecurityScope = 1024
    }
}
declare namespace NSURLHandle {
    enum Status {
        NotLoaded = 0,
        LoadSucceeded = 1,
        LoadInProgress = 2,
        LoadFailed = 3
    }
}
declare namespace NSURLRequest {
    enum CachePolicy {
        UseProtocolCachePolicy = 0,
        ReloadIgnoringLocalCacheData = 1,
        ReloadIgnoringLocalAndRemoteCacheData = 4,
        ReloadIgnoringCacheData = 1,
        ReturnCacheDataElseLoad = 2,
        ReturnCacheDataDontLoad = 3,
        ReloadRevalidatingCacheData = 5
    }
    enum NetworkServiceType {
        NetworkServiceTypeDefault = 0,
        NetworkServiceTypeVoIP = 1,
        NetworkServiceTypeVideo = 2,
        NetworkServiceTypeBackground = 3,
        NetworkServiceTypeVoice = 4,
        NetworkServiceTypeResponsiveData = 6,
        NetworkServiceTypeAVStreaming = 8,
        NetworkServiceTypeResponsiveAV = 9,
        NetworkServiceTypeCallSignaling = 11
    }
}
declare namespace NSUbiquitousKeyValueStore {
}
declare namespace NSUserNotification {
    enum ActivationType {
        None = 0,
        ContentsClicked = 1,
        ActionButtonClicked = 2,
        Replied = 3,
        AdditionalActionClicked = 4
    }
}
declare namespace NSValueTransformerName {
}
declare namespace NSView {
    enum AutoresizingMask {
        ViewNotSizable = 0,
        ViewMinXMargin = 1,
        ViewWidthSizable = 2,
        ViewMaxXMargin = 4,
        ViewMinYMargin = 8,
        ViewHeightSizable = 16,
        ViewMaxYMargin = 32
    }
    enum BackgroundStyle {
        Normal = 0,
        Emphasized = 1,
        Raised = 2,
        Lowered = 3
    }
    enum LayerContentsPlacement {
        ScaleAxesIndependently = 0,
        ScaleProportionallyToFit = 1,
        ScaleProportionallyToFill = 2,
        Center = 3,
        Top = 4,
        TopRight = 5,
        Right = 6,
        BottomRight = 7,
        Bottom = 8,
        BottomLeft = 9,
        Left = 10,
        TopLeft = 11
    }
    enum LayerContentsRedrawPolicy {
        Never = 0,
        OnSetNeedsDisplay = 1,
        DuringViewResize = 2,
        BeforeViewResize = 3,
        Crossfade = 4
    }
}
declare namespace NSViewAnimation {
}
declare namespace NSViewController {
    enum TransitionOptions {
        None = 0,
        Crossfade = 1,
        SlideUp = 16,
        SlideDown = 32,
        SlideLeft = 64,
        SlideRight = 128,
        SlideForward = 320,
        SlideBackward = 384,
        AllowUserInteraction = 4096
    }
}
declare namespace NSVisualEffectView {
    enum BlendingMode {
        BehindWindow = 0,
        WithinWindow = 1
    }
    enum Material {
        Titlebar = 3,
        Selection = 4,
        Menu = 5,
        Popover = 6,
        Sidebar = 7,
        HeaderView = 10,
        Sheet = 11,
        WindowBackground = 12,
        HUDWindow = 13,
        FullScreenUI = 15,
        ToolTip = 17,
        ContentBackground = 18,
        UnderWindowBackground = 21,
        UnderPageBackground = 22,
        AppearanceBased = 0,
        Light = 1,
        Dark = 2,
        MediumLight = 8,
        UltraDark = 9
    }
    enum State {
        FollowsWindowActiveState = 0,
        Active = 1,
        Inactive = 2
    }
}
declare namespace NSWhoseSpecifier {
    enum SubelementIdentifier {
        IndexSubelement = 0,
        EverySubelement = 1,
        MiddleSubelement = 2,
        RandomSubelement = 3,
        NoSubelement = 4
    }
}
declare namespace NSWindow {
    enum BackingStoreType {
        Retained = 0,
        Nonretained = 1,
        Buffered = 2
    }
    enum SelectionDirection {
        DirectSelection = 0,
        SelectingNext = 1,
        SelectingPrevious = 2
    }
    enum AnimationBehavior {
        Default = 0,
        None = 2,
        DocumentWindow = 3,
        UtilityWindow = 4,
        AlertPanel = 5
    }
    enum ButtonType {
        CloseButton = 0,
        MiniaturizeButton = 1,
        ZoomButton = 2,
        ToolbarButton = 3,
        DocumentIconButton = 4,
        DocumentVersionsButton = 6
    }
    enum CollectionBehavior {
        Default = 0,
        CanJoinAllSpaces = 1,
        MoveToActiveSpace = 2,
        Managed = 4,
        Transient = 8,
        Stationary = 16,
        ParticipatesInCycle = 32,
        IgnoresCycle = 64,
        FullScreenPrimary = 128,
        FullScreenAuxiliary = 256,
        FullScreenNone = 512,
        FullScreenAllowsTiling = 2048,
        FullScreenDisallowsTiling = 4096
    }
    enum Depth {
        TwentyfourBitRGB = 520,
        SixtyfourBitRGB = 528,
        OnehundredtwentyeightBitRGB = 544
    }
    enum NumberListOptions {
        AllApplications = 1,
        AllSpaces = 16
    }
    enum OcclusionState {
        Visible = 2
    }
    enum OrderingMode {
        Above = 1,
        Below = -1,
        Out = 0
    }
    enum SharingType {
        None = 0,
        ReadOnly = 1,
        ReadWrite = 2
    }
    enum StyleMask {
        Borderless = 0,
        Titled = 1,
        Closable = 2,
        Miniaturizable = 4,
        Resizable = 8,
        TexturedBackground = 256,
        UnifiedTitleAndToolbar = 4096,
        FullScreen = 16384,
        FullSizeContentView = 32768,
        UtilityWindow = 16,
        DocModalWindow = 64,
        NonactivatingPanel = 128,
        HUDWindow = 8192
    }
    enum TabbingMode {
        Automatic = 0,
        Preferred = 1,
        Disallowed = 2
    }
    enum TitleVisibility {
        Visible = 0,
        Hidden = 1
    }
    enum UserTabbingPreference {
        Manual = 0,
        Always = 1,
        InFullScreen = 2
    }
}
declare namespace NSWorkspace {
    enum AuthorizationType {
        CreateSymbolicLink = 0,
        SetAttributes = 1,
        ReplaceFile = 2
    }
    enum IconCreationOptions {
        ExcludeQuickDrawElementsIconCreationOption = 2,
        Exclude10_4ElementsIconCreationOption = 4
    }
    enum LaunchOptions {
        AndPrint = 2,
        WithErrorPresentation = 64,
        InhibitingBackgroundOnly = 128,
        WithoutAddingToRecents = 256,
        WithoutActivation = 512,
        Async = 65536,
        NewInstance = 524288,
        AndHide = 1048576,
        AndHideOthers = 2097152,
        Default = 65536,
        AllowingClassicStartup = 131072,
        PreferringClassic = 262144
    }
}
declare namespace NSXPCConnection {
    enum Options {
        Privileged = 4096
    }
}
declare namespace NetService {
    enum Options {
        noAutoRename = 0,
        listenForConnections = 1,
        center = 2,
        name = 3,
        object = 4
    }
}
declare namespace NotificationQueue {
    enum NotificationCoalescing {
        NoCoalescing = 0,
        CoalescingOnName = 1,
        CoalescingOnSender = 2
    }
    enum PostingStyle {
        WhenIdle = 1,
        ASAP = 2,
        Now = 3
    }
}
declare namespace NumberFormatter {
    enum Behavior {
        BehaviorDefault = 0,
        Behavior10_0 = 1000,
        Behavior10_4 = 1040
    }
    enum PadPosition {
        BeforePrefix = 0,
        AfterPrefix = 1,
        BeforeSuffix = 2,
        AfterSuffix = 3
    }
    enum RoundingMode {
        Ceiling = 0,
        Floor = 1,
        Down = 2,
        Up = 3,
        HalfEven = 4,
        HalfDown = 5,
        HalfUp = 6
    }
    enum Style {
        NoStyle = 0,
        DecimalStyle = 1,
        CurrencyStyle = 2,
        PercentStyle = 3,
        ScientificStyle = 4,
        SpellOutStyle = 5,
        OrdinalStyle = 6,
        CurrencyISOCodeStyle = 8,
        CurrencyPluralStyle = 9,
        CurrencyAccountingStyle = 10
    }
}
declare namespace Operation {
    enum QueuePriority {
        VeryLow = -8,
        Low = -4,
        Normal = 0,
        High = 4,
        VeryHigh = 8
    }
}
declare namespace OperationQueue {
}
declare namespace PersonNameComponentsFormatter {
    enum Options {
        Phonetic = 2
    }
    enum Style {
        Default = 0,
        Short = 1,
        Medium = 2,
        Long = 3,
        Abbreviated = 4
    }
}
declare namespace Port {
}
declare namespace Process {
    enum TerminationReason {
        Exit = 1,
        UncaughtSignal = 2
    }
}
declare namespace ProcessInfo {
    enum ActivityOptions {
        IdleDisplaySleepDisabled = 1099511627776,
        IdleSystemSleepDisabled = 1048576,
        SuddenTerminationDisabled = 16384,
        AutomaticTerminationDisabled = 32768,
        UserInitiated = 16777215,
        UserInitiatedAllowingIdleSystemSleep = 15728639,
        Background = 255,
        LatencyCritical = 1095216660480
    }
    enum ThermalState {
        Nominal = 0,
        Fair = 1,
        Serious = 2,
        Critical = 3
    }
}
declare namespace Progress {
}
declare namespace ProgressKind {
}
declare namespace ProgressUserInfoKey {
}
declare namespace PropertyListSerialization {
    enum PropertyListFormat {
        OpenStepFormat = 1,
        XMLFormat_v1_0 = 100,
        BinaryFormat_v1_0 = 200
    }
    enum MutabilityOptions {
        Immutable = 0,
        MutableContainers = 1,
        MutableContainersAndLeaves = 2
    }
}
declare namespace RelativeDateTimeFormatter {
    enum DateTimeStyle {
        Numeric = 0,
        Named = 1
    }
    enum UnitsStyle {
        Full = 0,
        SpellOut = 1,
        Short = 2,
        Abbreviated = 3
    }
}
declare namespace RunLoop {
}
declare namespace Stream {
    enum Event {
        None = 0,
        OpenCompleted = 1,
        HasBytesAvailable = 2,
        HasSpaceAvailable = 4,
        ErrorOccurred = 8,
        EndEncountered = 16
    }
    enum Status {
        NotOpen = 0,
        Opening = 1,
        Open = 2,
        Reading = 3,
        Writing = 4,
        AtEnd = 5,
        Closed = 6,
        Error = 7
    }
}
declare namespace StreamNetworkServiceTypeValue {
}
declare namespace StreamSOCKSProxyConfiguration {
}
declare namespace StreamSOCKSProxyVersion {
}
declare namespace StreamSocketSecurityLevel {
}
declare namespace StringEncodingDetectionOptionsKey {
}
declare namespace StringTransform {
}
declare namespace URLCache {
    enum StoragePolicy {
        Allowed = 0,
        AllowedInMemoryOnly = 1,
        NotAllowed = 2
    }
}
declare namespace URLCredential {
    enum Persistence {
        None = 0,
        ForSession = 1,
        Permanent = 2,
        Synchronizable = 3
    }
}
declare namespace URLFileProtection {
}
declare namespace URLFileResourceType {
}
declare namespace URLResourceKey {
}
declare namespace URLSession {
    enum AuthChallengeDisposition {
        UseCredential = 0,
        PerformDefaultHandling = 1,
        CancelAuthenticationChallenge = 2,
        RejectProtectionSpace = 3
    }
    enum ResponseDisposition {
        Cancel = 0,
        Allow = 1,
        BecomeDownload = 2,
        BecomeStream = 3
    }
}
declare namespace URLSessionTask {
    enum State {
        Running = 0,
        Suspended = 1,
        Canceling = 2,
        Completed = 3
    }
}
declare namespace URLSessionTaskMetrics {
    enum ResourceFetchType {
        Unknown = 0,
        NetworkLoad = 1,
        ServerPush = 2,
        LocalCache = 3
    }
}
declare namespace URLSessionWebSocketTask {
    enum CloseCode {
        Invalid = 0,
        NormalClosure = 1000,
        GoingAway = 1001,
        ProtocolError = 1002,
        UnsupportedData = 1003,
        NoStatusReceived = 1005,
        AbnormalClosure = 1006,
        InvalidFramePayloadData = 1007,
        PolicyViolation = 1008,
        MessageTooBig = 1009,
        MandatoryExtensionMissing = 1010,
        InternalServerError = 1011,
        TLSHandshakeFailure = 1015
    }
}
declare namespace URLThumbnailDictionaryItem {
}
declare namespace URLUbiquitousItemDownloadingStatus {
}
declare namespace URLUbiquitousSharedItemPermissions {
}
declare namespace URLUbiquitousSharedItemRole {
}
declare namespace UserDefaults {
}
declare namespace XMLDTDNode {
    enum DTDKind {
        EntityGeneralKind = 1,
        EntityParsedKind = 2,
        EntityUnparsedKind = 3,
        EntityParameterKind = 4,
        EntityPredefined = 5,
        AttributeCDATAKind = 6,
        AttributeIDKind = 7,
        AttributeIDRefKind = 8,
        AttributeIDRefsKind = 9,
        AttributeEntityKind = 10,
        AttributeEntitiesKind = 11,
        AttributeNMTokenKind = 12,
        AttributeNMTokensKind = 13,
        AttributeEnumerationKind = 14,
        AttributeNotationKind = 15,
        ElementDeclarationUndefinedKind = 16,
        ElementDeclarationEmptyKind = 17,
        ElementDeclarationAnyKind = 18,
        ElementDeclarationMixedKind = 19,
        ElementDeclarationElementKind = 20
    }
}
declare namespace XMLDocument {
    enum ContentKind {
        XMLKind = 0,
        XHTMLKind = 1,
        HTMLKind = 2,
        TextKind = 3
    }
}
declare namespace XMLNode {
    enum Kind {
        InvalidKind = 0,
        DocumentKind = 1,
        ElementKind = 2,
        AttributeKind = 3,
        NamespaceKind = 4,
        ProcessingInstructionKind = 5,
        CommentKind = 6,
        TextKind = 7,
        DTDKind = 8,
        EntityDeclarationKind = 9,
        AttributeDeclarationKind = 10,
        ElementDeclarationKind = 11,
        NotationDeclarationKind = 12
    }
    enum Options {
        NodeOptionsNone = 0,
        NodeIsCDATA = 1,
        NodeExpandEmptyElement = 2,
        NodeCompactEmptyElement = 4,
        NodeUseSingleQuotes = 8,
        NodeUseDoubleQuotes = 16,
        NodeNeverEscapeContents = 32,
        DocumentTidyHTML = 512,
        DocumentTidyXML = 1024,
        DocumentValidate = 8192,
        NodeLoadExternalEntitiesAlways = 16384,
        NodeLoadExternalEntitiesSameOriginOnly = 32768,
        NodeLoadExternalEntitiesNever = 524288,
        DocumentXInclude = 65536,
        NodePrettyPrint = 131072,
        DocumentIncludeContentTypeDeclaration = 262144,
        NodePreserveNamespaceOrder = 1048576,
        NodePreserveAttributeOrder = 2097152,
        NodePreserveEntities = 4194304,
        NodePreservePrefixes = 8388608,
        NodePreserveCDATA = 16777216,
        NodePreserveWhitespace = 33554432,
        NodePreserveDTD = 67108864,
        NodePreserveCharacterReferences = 134217728,
        NodePromoteSignificantWhitespace = 268435456,
        NodePreserveEmptyElements = 6,
        NodePreserveQuotes = 24,
        NodePreserveAll = 4293918750
    }
}
declare namespace XMLParser {
    enum ErrorCode {
        InternalError = 1,
        OutOfMemoryError = 2,
        DocumentStartError = 3,
        EmptyDocumentError = 4,
        PrematureDocumentEndError = 5,
        InvalidHexCharacterRefError = 6,
        InvalidDecimalCharacterRefError = 7,
        InvalidCharacterRefError = 8,
        InvalidCharacterError = 9,
        CharacterRefAtEOFError = 10,
        CharacterRefInPrologError = 11,
        CharacterRefInEpilogError = 12,
        CharacterRefInDTDError = 13,
        EntityRefAtEOFError = 14,
        EntityRefInPrologError = 15,
        EntityRefInEpilogError = 16,
        EntityRefInDTDError = 17,
        ParsedEntityRefAtEOFError = 18,
        ParsedEntityRefInPrologError = 19,
        ParsedEntityRefInEpilogError = 20,
        ParsedEntityRefInInternalSubsetError = 21,
        EntityReferenceWithoutNameError = 22,
        EntityReferenceMissingSemiError = 23,
        ParsedEntityRefNoNameError = 24,
        ParsedEntityRefMissingSemiError = 25,
        UndeclaredEntityError = 26,
        UnparsedEntityError = 28,
        EntityIsExternalError = 29,
        EntityIsParameterError = 30,
        UnknownEncodingError = 31,
        EncodingNotSupportedError = 32,
        StringNotStartedError = 33,
        StringNotClosedError = 34,
        NamespaceDeclarationError = 35,
        EntityNotStartedError = 36,
        EntityNotFinishedError = 37,
        LessThanSymbolInAttributeError = 38,
        AttributeNotStartedError = 39,
        AttributeNotFinishedError = 40,
        AttributeHasNoValueError = 41,
        AttributeRedefinedError = 42,
        LiteralNotStartedError = 43,
        LiteralNotFinishedError = 44,
        CommentNotFinishedError = 45,
        ProcessingInstructionNotStartedError = 46,
        ProcessingInstructionNotFinishedError = 47,
        NotationNotStartedError = 48,
        NotationNotFinishedError = 49,
        AttributeListNotStartedError = 50,
        AttributeListNotFinishedError = 51,
        MixedContentDeclNotStartedError = 52,
        MixedContentDeclNotFinishedError = 53,
        ElementContentDeclNotStartedError = 54,
        ElementContentDeclNotFinishedError = 55,
        XMLDeclNotStartedError = 56,
        XMLDeclNotFinishedError = 57,
        ConditionalSectionNotStartedError = 58,
        ConditionalSectionNotFinishedError = 59,
        ExternalSubsetNotFinishedError = 60,
        DOCTYPEDeclNotFinishedError = 61,
        MisplacedCDATAEndStringError = 62,
        CDATANotFinishedError = 63,
        MisplacedXMLDeclarationError = 64,
        SpaceRequiredError = 65,
        SeparatorRequiredError = 66,
        NMTOKENRequiredError = 67,
        NAMERequiredError = 68,
        PCDATARequiredError = 69,
        URIRequiredError = 70,
        PublicIdentifierRequiredError = 71,
        LTRequiredError = 72,
        GTRequiredError = 73,
        LTSlashRequiredError = 74,
        EqualExpectedError = 75,
        TagNameMismatchError = 76,
        UnfinishedTagError = 77,
        StandaloneValueError = 78,
        InvalidEncodingNameError = 79,
        CommentContainsDoubleHyphenError = 80,
        InvalidEncodingError = 81,
        ExternalStandaloneEntityError = 82,
        InvalidConditionalSectionError = 83,
        EntityValueRequiredError = 84,
        NotWellBalancedError = 85,
        ExtraContentError = 86,
        InvalidCharacterInEntityError = 87,
        ParsedEntityRefInInternalError = 88,
        EntityRefLoopError = 89,
        EntityBoundaryError = 90,
        InvalidURIError = 91,
        URIFragmentError = 92,
        NoDTDError = 94,
        DelegateAbortedParseError = 512
    }
    enum ExternalEntityResolvingPolicy {
        ResolveExternalEntitiesNever = 0,
        ResolveExternalEntitiesNoNetwork = 1,
        ResolveExternalEntitiesSameOriginOnly = 2,
        ResolveExternalEntitiesAlways = 3
    }
}
export declare enum AVAssetReferenceRestrictions {
    forbidRemoteReferenceToLocal = 0,
    forbidLocalReferenceToRemote = 1,
    forbidCrossSiteReference = 2,
    forbidLocalReferenceToLocal = 3,
    forbidAll = 4,
    defaultPolicy = 5
}
export declare enum AVAudioPlayerNodeBufferOptions {
    byteSwapped = 0,
    scalarCount = 1,
    loops = 2,
    interrupts = 3,
    interruptsAtLoop = 4
}
export declare enum AVAudioSpatializationFormats {
    monoAndStereo = 0,
    multichannel = 1,
    monoStereoAndMultichannel = 2
}
export declare enum AVMovieWritingOptions {
    errorDomain = 0,
    unknown = 1,
    outOfMemory = 2,
    sessionNotRunning = 3,
    deviceAlreadyUsedByAnotherSession = 4,
    noDataCaptured = 5,
    sessionConfigurationChanged = 6,
    diskFull = 7,
    deviceWasDisconnected = 8,
    mediaChanged = 9,
    maximumDurationReached = 10,
    maximumFileSizeReached = 11,
    mediaDiscontinuity = 12,
    maximumNumberOfSamplesForFileFormatReached = 13,
    deviceNotConnected = 14,
    deviceInUseByAnotherApplication = 15,
    deviceLockedForConfigurationByAnotherProcess = 16,
    exportFailed = 17,
    decodeFailed = 18,
    invalidSourceMedia = 19,
    fileAlreadyExists = 20,
    compositionTrackSegmentsNotContiguous = 21,
    invalidCompositionTrackSegmentDuration = 22,
    invalidCompositionTrackSegmentSourceStartTime = 23,
    invalidCompositionTrackSegmentSourceDuration = 24,
    fileFormatNotRecognized = 25,
    fileFailedToParse = 26,
    maximumStillImageCaptureRequestsExceeded = 27,
    contentIsProtected = 28,
    noImageAtTime = 29,
    decoderNotFound = 30,
    encoderNotFound = 31,
    contentIsNotAuthorized = 32,
    applicationIsNotAuthorized = 33,
    operationNotSupportedForAsset = 34,
    decoderTemporarilyUnavailable = 35,
    encoderTemporarilyUnavailable = 36,
    invalidVideoComposition = 37,
    referenceForbiddenByReferencePolicy = 38,
    invalidOutputURLPathExtension = 39,
    screenCaptureFailed = 40,
    displayWasDisabled = 41,
    torchLevelUnavailable = 42,
    incompatibleAsset = 43,
    failedToLoadMediaData = 44,
    serverIncorrectlyConfigured = 45,
    applicationIsNotAuthorizedToUseDevice = 46,
    failedToParse = 47,
    fileTypeDoesNotSupportSampleReferences = 48,
    undecodableMediaData = 49,
    airPlayControllerRequiresInternet = 50,
    airPlayReceiverRequiresInternet = 51,
    videoCompositorFailed = 52,
    createContentKeyRequestFailed = 53,
    unsupportedOutputSettings = 54,
    operationNotAllowed = 55,
    contentIsUnavailable = 56,
    formatUnsupported = 57,
    malformedDepth = 58,
    contentNotUpdated = 59,
    noLongerPlayable = 60,
    noCompatibleAlternatesForExternalDisplay = 61,
    noSourceTrack = 62,
    externalPlaybackNotSupportedForAsset = 63,
    operationNotSupportedForPreset = 64,
    incorrectlyConfigured = 65,
    segmentStartedWithNonSyncSample = 66,
    rosettaNotInstalled = 67,
    addMovieHeaderToDestination = 68,
    truncateDestinationToMovieHeaderOnly = 69
}
export declare enum AVMusicSequenceLoadOptions {
    smfChannelsToTracks = 0,
    scalarCount = 1
}
export declare enum AlignmentOptions {
    alignMinXInward = 0,
    alignMinYInward = 1,
    alignMaxXInward = 2,
    alignMaxYInward = 3,
    alignWidthInward = 4,
    alignHeightInward = 5,
    alignMinXOutward = 6,
    alignMinYOutward = 7,
    alignMaxXOutward = 8,
    alignMaxYOutward = 9,
    alignWidthOutward = 10,
    alignHeightOutward = 11,
    alignMinXNearest = 12,
    alignMinYNearest = 13,
    alignMaxXNearest = 14,
    alignMaxYNearest = 15,
    alignWidthNearest = 16,
    alignHeightNearest = 17,
    alignRectFlipped = 18,
    alignAllEdgesInward = 19,
    alignAllEdgesOutward = 20,
    alignAllEdgesNearest = 21
}
export declare enum AnyObject {
    byteSwapped = 0,
    scalarCount = 1,
    assureMemoryNow = 2,
    alwaysCopyData = 3,
    dontOptimizeDepth = 4,
    permitEmptyReference = 5
}
export declare enum CAAutoresizingMask {
    layerMinXMargin = 0,
    layerWidthSizable = 1,
    layerMaxXMargin = 2,
    layerMinYMargin = 3,
    layerHeightSizable = 4,
    layerMaxYMargin = 5
}
export declare enum CACornerMask {
    layerMinXMinYCorner = 0,
    layerMaxXMinYCorner = 1,
    layerMinXMaxYCorner = 2,
    layerMaxXMaxYCorner = 3
}
export declare enum CAEdgeAntialiasingMask {
    layerLeftEdge = 0,
    layerRightEdge = 1,
    layerBottomEdge = 2,
    layerTopEdge = 3
}
export declare enum CFCalendarUnit {
    magnitude = 0,
    byteSwapped = 1,
    scalarCount = 2,
    era = 3,
    year = 4,
    month = 5,
    day = 6,
    hour = 7,
    minute = 8,
    second = 9,
    week = 10,
    weekday = 11,
    weekdayOrdinal = 12,
    quarter = 13,
    weekOfMonth = 14,
    weekOfYear = 15,
    yearForWeekOfYear = 16
}
export declare enum CFDataSearchFlags {
    backwards = 0,
    anchored = 1
}
export declare enum CFFileSecurityClearOptions {
    magnitude = 0,
    byteSwapped = 1,
    scalarCount = 2,
    owner = 3,
    group = 4,
    mode = 5,
    ownerUUID = 6,
    groupUUID = 7,
    accessControlList = 8
}
export declare enum CFGregorianUnitFlags {
    unitsYears = 0,
    unitsMonths = 1,
    unitsDays = 2,
    unitsHours = 3,
    unitsMinutes = 4,
    unitsSeconds = 5,
    allUnits = 6
}
export declare enum CFISO8601DateFormatOptions {
    byteSwapped = 0,
    scalarCount = 1,
    withYear = 2,
    withMonth = 3,
    withWeekOfYear = 4,
    withDay = 5,
    withTime = 6,
    withTimeZone = 7,
    withSpaceBetweenDateAndTime = 8,
    withDashSeparatorInDate = 9,
    withColonSeparatorInTime = 10,
    withColonSeparatorInTimeZone = 11,
    withFractionalSeconds = 12,
    withFullDate = 13,
    withFullTime = 14,
    withInternetDateTime = 15
}
export declare enum CFNumberFormatterOptionFlags {
    magnitude = 0,
    byteSwapped = 1,
    scalarCount = 2,
    parseIntegersOnly = 3
}
export declare enum CFPropertyListMutabilityOptions {
    byteSwapped = 0,
    scalarCount = 1,
    mutableContainers = 2,
    mutableContainersAndLeaves = 3
}
export declare enum CFRunLoopActivity {
    entry = 0,
    beforeTimers = 1,
    beforeSources = 2,
    beforeWaiting = 3,
    afterWaiting = 4,
    exit = 5,
    allActivities = 6
}
export declare enum CFSocketCallBackType {
    readCallBack = 0,
    acceptCallBack = 1,
    dataCallBack = 2,
    connectCallBack = 3,
    writeCallBack = 4
}
export declare enum CFStreamEventType {
    magnitude = 0,
    byteSwapped = 1,
    scalarCount = 2,
    openCompleted = 3,
    hasBytesAvailable = 4,
    canAcceptBytes = 5,
    errorOccurred = 6,
    endEncountered = 7
}
export declare enum CFStringCompareFlags {
    compareCaseInsensitive = 0,
    compareBackwards = 1,
    compareAnchored = 2,
    compareNonliteral = 3,
    compareLocalized = 4,
    compareNumerically = 5,
    compareDiacriticInsensitive = 6,
    compareWidthInsensitive = 7,
    compareForcedOrdering = 8
}
export declare enum CFStringTokenizerTokenType {
    byteSwapped = 0,
    scalarCount = 1,
    normal = 2,
    hasSubTokensMask = 3,
    hasDerivedSubTokensMask = 4,
    hasHasNumbersMask = 5,
    hasNonLettersMask = 6,
    isCJWordMask = 7
}
export declare enum CFURLBookmarkCreationOptions {
    byteSwapped = 0,
    scalarCount = 1,
    minimalBookmarkMask = 2,
    suitableForBookmarkFile = 3,
    withSecurityScope = 4,
    securityScopeAllowOnlyReadAccess = 5
}
export declare enum CFURLBookmarkResolutionOptions {
    byteSwapped = 0,
    scalarCount = 1,
    cfurlBookmarkResolutionWithoutUIMask = 2,
    cfurlBookmarkResolutionWithoutMountingMask = 3,
    cfurlBookmarkResolutionWithSecurityScope = 4,
    cfBookmarkResolutionWithoutUIMask = 5,
    cfBookmarkResolutionWithoutMountingMask = 6
}
export declare enum CFURLEnumeratorOptions {
    descendRecursively = 0,
    skipInvisibles = 1,
    generateFileReferenceURLs = 2,
    skipPackageContents = 3,
    includeDirectoriesPreOrder = 4,
    includeDirectoriesPostOrder = 5,
    generateRelativePathURLs = 6
}
export declare enum CFXMLParserOptions {
    validateDocument = 0,
    skipMetaData = 1,
    replacePhysicalEntities = 2,
    skipWhitespace = 3,
    resolveExternalEntities = 4,
    addImpliedAttributes = 5,
    allOptions = 6
}
export declare enum CFXMLParserStatusCode {
    statusParseNotBegun = 0,
    statusParseInProgress = 1,
    errorUnexpectedEOF = 2,
    errorUnknownEncoding = 3,
    errorEncodingConversionFailure = 4,
    errorMalformedProcessingInstruction = 5,
    errorMalformedDTD = 6,
    errorMalformedName = 7,
    errorMalformedCDSect = 8,
    errorMalformedCloseTag = 9,
    errorMalformedStartTag = 10,
    errorMalformedDocument = 11,
    errorElementlessDocument = 12,
    errorMalformedComment = 13,
    errorMalformedCharacterReference = 14,
    errorMalformedParsedCharacterData = 15,
    errorNoData = 16
}
export declare enum CGBitmapInfo {
    alphaInfoMask = 0,
    floatInfoMask = 1,
    floatComponents = 2,
    byteOrderMask = 3,
    byteOrder16Little = 4,
    byteOrder32Little = 5,
    byteOrder16Big = 6,
    byteOrder32Big = 7
}
export declare enum CGCaptureOptions {
    byteSwapped = 0,
    scalarCount = 1,
    noFill = 2
}
export declare enum CGConfigureOption {
    byteSwapped = 0,
    scalarCount = 1,
    forAppOnly = 2,
    forSession = 3,
    permanently = 4
}
export declare enum CGDisplayChangeSummaryFlags {
    byteSwapped = 0,
    scalarCount = 1,
    beginConfigurationFlag = 2,
    movedFlag = 3,
    setMainFlag = 4,
    setModeFlag = 5,
    addFlag = 6,
    removeFlag = 7,
    enabledFlag = 8,
    disabledFlag = 9,
    mirrorFlag = 10,
    unMirrorFlag = 11,
    desktopShapeChangedFlag = 12
}
export declare enum CGEventFilterMask {
    byteSwapped = 0,
    scalarCount = 1,
    permitLocalMouseEvents = 2,
    permitLocalKeyboardEvents = 3,
    permitSystemDefinedEvents = 4
}
export declare enum CGEventFlags {
    maskAlphaShift = 0,
    maskShift = 1,
    maskControl = 2,
    maskAlternate = 3,
    maskCommand = 4,
    maskHelp = 5,
    maskSecondaryFn = 6,
    maskNumericPad = 7,
    maskNonCoalesced = 8
}
export declare enum CGGradientDrawingOptions {
    byteSwapped = 0,
    scalarCount = 1,
    drawsBeforeStartLocation = 2,
    drawsAfterEndLocation = 3
}
export declare enum CGPDFAccessPermissions {
    byteSwapped = 0,
    scalarCount = 1,
    allowsLowQualityPrinting = 2,
    allowsHighQualityPrinting = 3,
    allowsDocumentChanges = 4,
    allowsDocumentAssembly = 5,
    allowsContentCopying = 6,
    allowsContentAccessibility = 7,
    allowsCommenting = 8,
    allowsFormFieldEntry = 9
}
export declare enum CGScreenUpdateOperation {
    byteSwapped = 0,
    scalarCount = 1,
    refresh = 2,
    move = 3,
    reducedDirtyRectangleCount = 4
}
export declare enum CGWindowImageOption {
    byteSwapped = 0,
    scalarCount = 1,
    boundsIgnoreFraming = 2,
    shouldBeOpaque = 3,
    onlyShadows = 4,
    bestResolution = 5,
    nominalResolution = 6
}
export declare enum CGWindowListOption {
    magnitude = 0,
    byteSwapped = 1,
    scalarCount = 2,
    optionAll = 3,
    optionOnScreenOnly = 4,
    optionOnScreenAboveWindow = 5,
    optionOnScreenBelowWindow = 6,
    optionIncludingWindow = 7,
    excludeDesktopElements = 8
}
export declare enum CKContainer_Application_Permissions {
    userDiscoverability = 0
}
export declare enum CMSampleBuffer {
    audioBufferListAssure16ByteAlignment = 0
}
export declare enum CMTimeFlags {
    magnitude = 0,
    byteSwapped = 1,
    scalarCount = 2,
    valid = 3,
    hasBeenRounded = 4,
    positiveInfinity = 5,
    negativeInfinity = 6,
    indefinite = 7,
    impliedValueFlagsMask = 8
}
export declare enum Character {
    request = 0,
    session = 1,
    ascii = 2,
    nextstep = 3,
    japaneseEUC = 4,
    utf8 = 5,
    isoLatin1 = 6,
    symbol = 7,
    nonLossyASCII = 8,
    shiftJIS = 9,
    isoLatin2 = 10,
    unicode = 11,
    windowsCP1251 = 12,
    windowsCP1252 = 13,
    windowsCP1253 = 14,
    windowsCP1254 = 15,
    windowsCP1250 = 16,
    iso2022JP = 17,
    macOSRoman = 18,
    utf16 = 19,
    utf16BigEndian = 20,
    utf16LittleEndian = 21,
    utf32 = 22,
    utf32BigEndian = 23,
    utf32LittleEndian = 24
}
export declare enum Data {
    video = 0,
    audio = 1,
    muxed = 2,
    text = 3,
    closedCaption = 4,
    subtitle = 5,
    timeCode = 6,
    metadata = 7,
    linearPCM = 8,
    ac3 = 9,
    iec60958AC3 = 10,
    appleIMA4 = 11,
    mpeg4AAC = 12,
    mpeg4CELP = 13,
    mpeg4HVXC = 14,
    mpeg4TwinVQ = 15,
    mace3 = 16,
    mace6 = 17,
    uLaw = 18,
    aLaw = 19,
    qDesign = 20,
    qDesign2 = 21,
    qualcomm = 22,
    mpegLayer1 = 23,
    mpegLayer2 = 24,
    mpegLayer3 = 25,
    midiStream = 26,
    parameterValueStream = 27,
    appleLossless = 28,
    mpeg4AAC_HE = 29,
    mpeg4AAC_LD = 30,
    mpeg4AAC_ELD = 31,
    mpeg4AAC_ELD_SBR = 32,
    mpeg4AAC_ELD_V2 = 33,
    mpeg4AAC_HE_V2 = 34,
    mpeg4AAC_Spatial = 35,
    mpegD_USAC = 36,
    amr = 37,
    amr_WB = 38,
    audible = 39,
    iLBC = 40,
    dviIntelIMA = 41,
    microsoftGSM = 42,
    aes3 = 43,
    enhancedAC3 = 44,
    flac = 45,
    opus = 46,
    aacLCProtected = 47,
    aacAudibleProtected = 48,
    pixelFormat_32ARGB = 49,
    pixelFormat_32BGRA = 50,
    pixelFormat_24RGB = 51,
    pixelFormat_16BE555 = 52,
    pixelFormat_16BE565 = 53,
    pixelFormat_16LE555 = 54,
    pixelFormat_16LE565 = 55,
    pixelFormat_16LE5551 = 56,
    pixelFormat_422YpCbCr8 = 57,
    pixelFormat_422YpCbCr8_yuvs = 58,
    pixelFormat_444YpCbCr8 = 59,
    pixelFormat_4444YpCbCrA8 = 60,
    pixelFormat_422YpCbCr16 = 61,
    pixelFormat_422YpCbCr10 = 62,
    pixelFormat_444YpCbCr10 = 63,
    pixelFormat_8IndexedGray_WhiteIsZero = 64,
    animation = 65,
    cinepak = 66,
    jpeg = 67,
    jpeg_OpenDML = 68,
    sorensonVideo = 69,
    sorensonVideo3 = 70,
    h263 = 71,
    h264 = 72,
    hevc = 73,
    hevcWithAlpha = 74,
    mpeg4Video = 75,
    mpeg2Video = 76,
    mpeg1Video = 77,
    dvcNTSC = 78,
    dvcPAL = 79,
    dvcProPAL = 80,
    dvcPro50NTSC = 81,
    dvcPro50PAL = 82,
    dvcPROHD720p60 = 83,
    dvcPROHD720p50 = 84,
    dvcPROHD1080i60 = 85,
    dvcPROHD1080i50 = 86,
    dvcPROHD1080p30 = 87,
    dvcPROHD1080p25 = 88,
    proRes4444XQ = 89,
    proRes4444 = 90,
    proRes422HQ = 91,
    proRes422 = 92,
    proRes422LT = 93,
    proRes422Proxy = 94,
    proResRAW = 95,
    proResRAWHQ = 96,
    mpeg1System = 97,
    mpeg2Transport = 98,
    mpeg2Program = 99,
    dv = 100,
    cea608 = 101,
    cea708 = 102,
    atsc = 103,
    qt = 104,
    mobile3GPP = 105,
    webVTT = 106,
    timeCode32 = 107,
    timeCode64 = 108,
    counter32 = 109,
    counter64 = 110,
    icy = 111,
    id3 = 112,
    boxed = 113,
    emsg = 114,
    streamBasicDescription = 115,
    magicCookie = 116,
    channelLayout = 117,
    extensions = 118,
    all = 119,
    startIndex = 120,
    endIndex = 121
}
export declare enum Int {
    byteSwapped = 0,
    scalarCount = 1
}
export declare enum NSBinarySearchingOptions {
    firstEqual = 0,
    lastEqual = 1,
    insertionIndex = 2
}
export declare enum NSDirectionalRectEdge {
    top = 0,
    leading = 1,
    bottom = 2,
    trailing = 3,
    all = 4
}
export declare enum NSDragOperation {
    copy = 0,
    link = 1,
    generic = 2,
    private = 3,
    move = 4,
    delete = 5,
    every = 6,
    all_Obsolete = 7,
    all = 8
}
export declare enum NSDraggingItemEnumerationOptions {
    concurrent = 0,
    clearNonenumeratedImages = 1
}
export declare enum NSEnumerationOptions {
    concurrent = 0,
    reverse = 1
}
export declare enum NSFontCollectionOptions {
    applicationOnlyMask = 0
}
export declare enum NSFontTraitMask {
    byteSwapped = 0,
    scalarCount = 1,
    italicFontMask = 2,
    boldFontMask = 3,
    unboldFontMask = 4,
    nonStandardCharacterSetFontMask = 5,
    narrowFontMask = 6,
    expandedFontMask = 7,
    condensedFontMask = 8,
    smallCapsFontMask = 9,
    posterFontMask = 10,
    compressedFontMask = 11,
    fixedPitchFontMask = 12,
    unitalicFontMask = 13
}
export declare enum NSItemProviderFileOptions {
    openInPlace = 0
}
export declare enum NSKeyValueObservingOptions {
    new = 0,
    old = 1,
    initial = 2,
    prior = 3
}
export declare enum NSOrderedCollectionDifferenceCalculationOptions {
    magnitude = 0,
    timeInterval = 1,
    hashValue = 2,
    omitInsertedObjects = 3,
    omitRemovedObjects = 4,
    inferMoves = 5
}
export declare enum NSSortOptions {
    magnitude = 0,
    byteSwapped = 1,
    scalarCount = 2,
    concurrent = 3,
    stable = 4
}
export declare enum NSSpringLoadingOptions {
    disabled = 0,
    enabled = 1,
    continuousActivation = 2,
    noHover = 3
}
export declare enum NSTextStorageEditActions {
    editedAttributes = 0,
    editedCharacters = 1
}
export declare enum NSTypesetterControlCharacterAction {
    magnitude = 0,
    byteSwapped = 1,
    scalarCount = 2,
    zeroAdvancementAction = 3,
    whitespaceAction = 4,
    horizontalTabAction = 5,
    lineBreakAction = 6,
    paragraphBreakAction = 7,
    containerBreakAction = 8
}
export declare enum NSUnderlineStyle {
    single = 0,
    thick = 1,
    double = 2,
    patternDot = 3,
    patternDash = 4,
    patternDashDot = 5,
    patternDashDotDot = 6,
    byWord = 7
}
export declare enum UInt {
    magnitude = 0,
    byteSwapped = 1,
    scalarCount = 2,
    hashValue = 3,
    bitWidth = 4,
    leadingZeroBitCount = 5,
    trailingZeroBitCount = 6,
    nonzeroBitCount = 7,
    count = 8,
    startIndex = 9,
    endIndex = 10,
    indices = 11,
    words = 12
}
export declare enum UInt8 {
    regions = 0,
    startIndex = 1,
    endIndex = 2,
    indices = 3,
    hashValue = 4,
    autoupdatingCurrent = 5,
    current = 6
}
export declare enum NSAccessibilityPriorityLevel {
    Low = 10,
    Medium = 50,
    High = 90
}
export declare enum NSAnimationEffect {
    DisappearingItemDefault = 0,
    Poof = 10
}
export declare enum NSBorderType {
    NoBorder = 0,
    LineBorder = 1,
    BezelBorder = 2,
    GrooveBorder = 3
}
export declare enum NSCharacterCollection {
    IdentityMappingCharacterCollection = 0,
    AdobeCNS1CharacterCollection = 1,
    AdobeGB1CharacterCollection = 2,
    AdobeJapan1CharacterCollection = 3,
    AdobeJapan2CharacterCollection = 4,
    AdobeKorea1CharacterCollection = 5
}
export declare enum NSCollectionElementCategory {
    Item = 0,
    SupplementaryView = 1,
    DecorationView = 2,
    InterItemGap = 3
}
export declare enum NSCollectionLayoutSectionOrthogonalScrollingBehavior {
    None = 0,
    Continuous = 1,
    ContinuousGroupLeadingBoundary = 2,
    Paging = 3,
    GroupPaging = 4,
    GroupPagingCentered = 5
}
export declare enum NSColorRenderingIntent {
    Default = 0,
    AbsoluteColorimetric = 1,
    RelativeColorimetric = 2,
    Perceptual = 3,
    Saturation = 4
}
export declare enum NSCompositingOperation {
    Clear = 0,
    Copy = 1,
    SourceOver = 2,
    SourceIn = 3,
    SourceOut = 4,
    SourceAtop = 5,
    DestinationOver = 6,
    DestinationIn = 7,
    DestinationOut = 8,
    DestinationAtop = 9,
    XOR = 10,
    PlusDarker = 11,
    Highlight = 12,
    PlusLighter = 13,
    Multiply = 14,
    Screen = 15,
    Overlay = 16,
    Darken = 17,
    Lighten = 18,
    ColorDodge = 19,
    ColorBurn = 20,
    SoftLight = 21,
    HardLight = 22,
    Difference = 23,
    Exclusion = 24,
    Hue = 25,
    Saturation = 26,
    Color = 27,
    Luminosity = 28
}
export declare enum NSControlTint {
    DefaultControlTint = 0,
    BlueControlTint = 1,
    GraphiteControlTint = 6,
    ClearControlTint = 7
}
export declare enum NSDirectionalRectEdge {
    None = 0,
    Top = 1,
    Leading = 2,
    Bottom = 4,
    Trailing = 8,
    All = 15
}
export declare enum NSDisplayGamut {
    SRGB = 1,
    P3 = 2
}
export declare enum NSDragOperation {
    None = 0,
    Copy = 1,
    Link = 2,
    Generic = 4,
    Private = 8,
    Move = 16,
    Delete = 32,
    Every = -1,
    All_Obsolete = 15,
    All = 15
}
export declare enum NSDraggingContext {
    OutsideApplication = 0,
    WithinApplication = 1
}
export declare enum NSDraggingFormation {
    Default = 0,
    None = 1,
    Pile = 2,
    List = 3,
    Stack = 4
}
export declare enum NSDraggingItemEnumerationOptions {
    Concurrent = 1,
    ClearNonenumeratedImages = 65536
}
export declare enum NSFindPanelAction {
    ShowFindPanel = 1,
    Next = 2,
    Previous = 3,
    ReplaceAll = 4,
    Replace = 5,
    ReplaceAndFind = 6,
    SetFindString = 7,
    ReplaceAllInSelection = 8,
    SelectAll = 9,
    SelectAllInSelection = 10
}
export declare enum NSFindPanelSubstringMatchType {
    Contains = 0,
    StartsWith = 1,
    FullWord = 2,
    EndsWith = 3
}
export declare enum NSFocusRingPlacement {
    Only = 0,
    Below = 1,
    Above = 2
}
export declare enum NSFocusRingType {
    Default = 0,
    None = 1,
    Exterior = 2
}
export declare enum NSFontAction {
    NoFontChangeAction = 0,
    ViaPanelFontAction = 1,
    AddTraitFontAction = 2,
    SizeUpFontAction = 3,
    SizeDownFontAction = 4,
    HeavierFontAction = 5,
    LighterFontAction = 6,
    RemoveTraitFontAction = 7
}
export declare enum NSFontCollectionOptions {
    ApplicationOnlyMask = 1
}
export declare enum NSFontRenderingMode {
    DefaultRenderingMode = 0,
    AntialiasedRenderingMode = 1,
    IntegerAdvancementsRenderingMode = 2,
    AntialiasedIntegerAdvancementsRenderingMode = 3
}
export declare enum NSFontTraitMask {
    ItalicFontMask = 1,
    BoldFontMask = 2,
    UnboldFontMask = 4,
    NonStandardCharacterSetFontMask = 8,
    NarrowFontMask = 16,
    ExpandedFontMask = 32,
    CondensedFontMask = 64,
    SmallCapsFontMask = 128,
    PosterFontMask = 256,
    CompressedFontMask = 512,
    FixedPitchFontMask = 1024,
    UnitalicFontMask = 16777216
}
export declare enum NSImageAlignment {
    Center = 0,
    Top = 1,
    TopLeft = 2,
    TopRight = 3,
    Left = 4,
    Bottom = 5,
    BottomLeft = 6,
    BottomRight = 7,
    Right = 8
}
export declare enum NSImageInterpolation {
    Default = 0,
    None = 1,
    Low = 2,
    Medium = 4,
    High = 3
}
export declare enum NSImageScaling {
    ImageScaleProportionallyDown = 0,
    ImageScaleAxesIndependently = 1,
    ImageScaleNone = 2,
    ImageScaleProportionallyUpOrDown = 3,
    ScaleProportionally = 0,
    ScaleToFit = 1,
    ScaleNone = 2
}
export declare enum NSLineBreakMode {
    ByWordWrapping = 0,
    ByCharWrapping = 1,
    ByClipping = 2,
    ByTruncatingHead = 3,
    ByTruncatingTail = 4,
    ByTruncatingMiddle = 5
}
export declare enum NSLineMovementDirection {
    DoesntMove = 0,
    MovesLeft = 1,
    MovesRight = 2,
    MovesDown = 3,
    MovesUp = 4
}
export declare enum NSLineSweepDirection {
    Left = 0,
    Right = 1,
    Down = 2,
    Up = 3
}
export declare enum NSRectAlignment {
    None = 0,
    Top = 1,
    TopLeading = 2,
    Leading = 3,
    BottomLeading = 4,
    Bottom = 5,
    BottomTrailing = 6,
    Trailing = 7,
    TopTrailing = 8
}
export declare enum NSSelectionAffinity {
    Upstream = 0,
    Downstream = 1
}
export declare enum NSSelectionGranularity {
    ByCharacter = 0,
    ByWord = 1,
    ByParagraph = 2
}
export declare enum NSSpringLoadingHighlight {
    None = 0,
    Standard = 1,
    Emphasized = 2
}
export declare enum NSSpringLoadingOptions {
    Disabled = 0,
    Enabled = 1,
    ContinuousActivation = 2,
    NoHover = 8
}
export declare enum NSTextAlignment {
    Left = 0,
    Right = 1,
    Center = 2,
    Justified = 3,
    Natural = 4
}
export declare enum NSTextInputTraitType {
    Default = 0,
    No = 1,
    Yes = 2
}
export declare enum NSTextMovement {
    Return = 16,
    Tab = 17,
    Backtab = 18,
    Left = 19,
    Right = 20,
    Up = 21,
    Down = 22,
    Cancel = 23,
    Other = 0
}
export declare enum NSTextScalingType {
    Standard = 0,
    iOS = 1
}
export declare enum NSTextStorageEditActions {
    EditedAttributes = 1,
    EditedCharacters = 2
}
export declare enum NSTypesetterControlCharacterAction {
    ZeroAdvancementAction = 1,
    WhitespaceAction = 2,
    HorizontalTabAction = 4,
    LineBreakAction = 8,
    ParagraphBreakAction = 16,
    ContainerBreakAction = 32
}
export declare enum NSUnderlineStyle {
    None = 0,
    Single = 1,
    Thick = 2,
    Double = 9,
    PatternSolid = 0,
    PatternDot = 256,
    PatternDash = 512,
    PatternDashDot = 768,
    PatternDashDotDot = 1024,
    ByWord = 32768
}
export declare enum NSUserInterfaceLayoutDirection {
    LeftToRight = 0,
    RightToLeft = 1
}
export declare enum NSUserInterfaceLayoutOrientation {
    Horizontal = 0,
    Vertical = 1
}
export declare enum NSWritingDirection {
    Natural = -1,
    LeftToRight = 0,
    RightToLeft = 1
}
export declare enum NSWritingDirectionFormatType {
    Embedding = 0,
    Override = 2
}
export declare enum CFCalendarUnit {
    kCFCalendarUnitEra = 2,
    kCFCalendarUnitYear = 4,
    kCFCalendarUnitMonth = 8,
    kCFCalendarUnitDay = 16,
    kCFCalendarUnitHour = 32,
    kCFCalendarUnitMinute = 64,
    kCFCalendarUnitSecond = 128,
    kCFCalendarUnitWeek = 256,
    kCFCalendarUnitWeekday = 512,
    kCFCalendarUnitWeekdayOrdinal = 1024,
    kCFCalendarUnitQuarter = 2048,
    kCFCalendarUnitWeekOfMonth = 4096,
    kCFCalendarUnitWeekOfYear = 8192,
    kCFCalendarUnitYearForWeekOfYear = 16384
}
export declare enum CFCharacterSetPredefinedSet {
    kCFCharacterSetControl = 1,
    kCFCharacterSetWhitespace = 2,
    kCFCharacterSetWhitespaceAndNewline = 3,
    kCFCharacterSetDecimalDigit = 4,
    kCFCharacterSetLetter = 5,
    kCFCharacterSetLowercaseLetter = 6,
    kCFCharacterSetUppercaseLetter = 7,
    kCFCharacterSetNonBase = 8,
    kCFCharacterSetDecomposable = 9,
    kCFCharacterSetAlphaNumeric = 10,
    kCFCharacterSetPunctuation = 11,
    kCFCharacterSetCapitalizedLetter = 13,
    kCFCharacterSetSymbol = 14,
    kCFCharacterSetNewline = 15,
    kCFCharacterSetIllegal = 12
}
export declare enum CFComparisonResult {
    kCFCompareLessThan = -1,
    kCFCompareEqualTo = 0,
    kCFCompareGreaterThan = 1
}
export declare enum CFDataSearchFlags {
    kCFDataSearchBackwards = 1,
    kCFDataSearchAnchored = 2
}
export declare enum CFDateFormatterStyle {
    kCFDateFormatterNoStyle = 0,
    kCFDateFormatterShortStyle = 1,
    kCFDateFormatterMediumStyle = 2,
    kCFDateFormatterLongStyle = 3,
    kCFDateFormatterFullStyle = 4
}
export declare enum CFFileSecurityClearOptions {
    kCFFileSecurityClearOwner = 1,
    kCFFileSecurityClearGroup = 2,
    kCFFileSecurityClearMode = 4,
    kCFFileSecurityClearOwnerUUID = 8,
    kCFFileSecurityClearGroupUUID = 16,
    kCFFileSecurityClearAccessControlList = 32
}
export declare enum CFGregorianUnitFlags {
    kCFGregorianUnitsYears = 1,
    kCFGregorianUnitsMonths = 2,
    kCFGregorianUnitsDays = 4,
    kCFGregorianUnitsHours = 8,
    kCFGregorianUnitsMinutes = 16,
    kCFGregorianUnitsSeconds = 32,
    kCFGregorianAllUnits = 16777215
}
export declare enum CFISO8601DateFormatOptions {
    kCFISO8601DateFormatWithYear = 1,
    kCFISO8601DateFormatWithMonth = 2,
    kCFISO8601DateFormatWithWeekOfYear = 4,
    kCFISO8601DateFormatWithDay = 16,
    kCFISO8601DateFormatWithTime = 32,
    kCFISO8601DateFormatWithTimeZone = 64,
    kCFISO8601DateFormatWithSpaceBetweenDateAndTime = 128,
    kCFISO8601DateFormatWithDashSeparatorInDate = 256,
    kCFISO8601DateFormatWithColonSeparatorInTime = 512,
    kCFISO8601DateFormatWithColonSeparatorInTimeZone = 1024,
    kCFISO8601DateFormatWithFractionalSeconds = 2048,
    kCFISO8601DateFormatWithFullDate = 275,
    kCFISO8601DateFormatWithFullTime = 1632,
    kCFISO8601DateFormatWithInternetDateTime = 1907
}
export declare enum CFLocaleLanguageDirection {
    kCFLocaleLanguageDirectionUnknown = 0,
    kCFLocaleLanguageDirectionLeftToRight = 1,
    kCFLocaleLanguageDirectionRightToLeft = 2,
    kCFLocaleLanguageDirectionTopToBottom = 3,
    kCFLocaleLanguageDirectionBottomToTop = 4
}
export declare enum CFNotificationSuspensionBehavior {
    Drop = 1,
    Coalesce = 2,
    Hold = 3,
    DeliverImmediately = 4
}
export declare enum CFNumberFormatterOptionFlags {
    kCFNumberFormatterParseIntegersOnly = 1
}
export declare enum CFNumberFormatterPadPosition {
    kCFNumberFormatterPadBeforePrefix = 0,
    kCFNumberFormatterPadAfterPrefix = 1,
    kCFNumberFormatterPadBeforeSuffix = 2,
    kCFNumberFormatterPadAfterSuffix = 3
}
export declare enum CFNumberFormatterRoundingMode {
    kCFNumberFormatterRoundCeiling = 0,
    kCFNumberFormatterRoundFloor = 1,
    kCFNumberFormatterRoundDown = 2,
    kCFNumberFormatterRoundUp = 3,
    kCFNumberFormatterRoundHalfEven = 4,
    kCFNumberFormatterRoundHalfDown = 5,
    kCFNumberFormatterRoundHalfUp = 6
}
export declare enum CFNumberFormatterStyle {
    kCFNumberFormatterNoStyle = 0,
    kCFNumberFormatterDecimalStyle = 1,
    kCFNumberFormatterCurrencyStyle = 2,
    kCFNumberFormatterPercentStyle = 3,
    kCFNumberFormatterScientificStyle = 4,
    kCFNumberFormatterSpellOutStyle = 5,
    kCFNumberFormatterOrdinalStyle = 6,
    kCFNumberFormatterCurrencyISOCodeStyle = 8,
    kCFNumberFormatterCurrencyPluralStyle = 9,
    kCFNumberFormatterCurrencyAccountingStyle = 10
}
export declare enum CFNumberType {
    kCFNumberSInt8Type = 1,
    kCFNumberSInt16Type = 2,
    kCFNumberSInt32Type = 3,
    kCFNumberSInt64Type = 4,
    kCFNumberFloat32Type = 5,
    kCFNumberFloat64Type = 6,
    kCFNumberCharType = 7,
    kCFNumberShortType = 8,
    kCFNumberIntType = 9,
    kCFNumberLongType = 10,
    kCFNumberLongLongType = 11,
    kCFNumberFloatType = 12,
    kCFNumberDoubleType = 13,
    kCFNumberCFIndexType = 14,
    kCFNumberNSIntegerType = 15,
    kCFNumberCGFloatType = 16,
    kCFNumberMaxType = 16
}
export declare enum CFPropertyListFormat {
    kCFPropertyListOpenStepFormat = 1,
    kCFPropertyListXMLFormat_v1_0 = 100,
    kCFPropertyListBinaryFormat_v1_0 = 200
}
export declare enum CFPropertyListMutabilityOptions {
    kCFPropertyListImmutable = 0,
    kCFPropertyListMutableContainers = 1,
    kCFPropertyListMutableContainersAndLeaves = 2
}
export declare enum CFRunLoopActivity {
    kCFRunLoopEntry = 1,
    kCFRunLoopBeforeTimers = 2,
    kCFRunLoopBeforeSources = 4,
    kCFRunLoopBeforeWaiting = 32,
    kCFRunLoopAfterWaiting = 64,
    kCFRunLoopExit = 128,
    kCFRunLoopAllActivities = 268435455
}
export declare enum CFRunLoopRunResult {
    kCFRunLoopRunFinished = 1,
    kCFRunLoopRunStopped = 2,
    kCFRunLoopRunTimedOut = 3,
    kCFRunLoopRunHandledSource = 4
}
export declare enum CFSocketCallBackType {
    kCFSocketNoCallBack = 0,
    kCFSocketReadCallBack = 1,
    kCFSocketAcceptCallBack = 2,
    kCFSocketDataCallBack = 3,
    kCFSocketConnectCallBack = 4,
    kCFSocketWriteCallBack = 8
}
export declare enum CFSocketError {
    kCFSocketSuccess = 0,
    kCFSocketError = -1,
    kCFSocketTimeout = -2
}
export declare enum CFStreamErrorDomain {
    kCFStreamErrorDomainCustom = -1,
    kCFStreamErrorDomainPOSIX = 1,
    kCFStreamErrorDomainMacOSStatus = 2
}
export declare enum CFStreamEventType {
    kCFStreamEventNone = 0,
    kCFStreamEventOpenCompleted = 1,
    kCFStreamEventHasBytesAvailable = 2,
    kCFStreamEventCanAcceptBytes = 4,
    kCFStreamEventErrorOccurred = 8,
    kCFStreamEventEndEncountered = 16
}
export declare enum CFStreamStatus {
    kCFStreamStatusNotOpen = 0,
    kCFStreamStatusOpening = 1,
    kCFStreamStatusOpen = 2,
    kCFStreamStatusReading = 3,
    kCFStreamStatusWriting = 4,
    kCFStreamStatusAtEnd = 5,
    kCFStreamStatusClosed = 6,
    kCFStreamStatusError = 7
}
export declare enum CFStringBuiltInEncodings {
    kCFStringEncodingMacRoman = 0,
    kCFStringEncodingWindowsLatin1 = 1280,
    kCFStringEncodingISOLatin1 = 513,
    kCFStringEncodingNextStepLatin = 2817,
    kCFStringEncodingASCII = 1536,
    kCFStringEncodingUnicode = 256,
    kCFStringEncodingUTF8 = 134217984,
    kCFStringEncodingNonLossyASCII = 3071,
    kCFStringEncodingUTF16 = 256,
    kCFStringEncodingUTF16BE = 268435712,
    kCFStringEncodingUTF16LE = 335544576,
    kCFStringEncodingUTF32 = 201326848,
    kCFStringEncodingUTF32BE = 402653440,
    kCFStringEncodingUTF32LE = 469762304
}
export declare enum CFStringCompareFlags {
    kCFCompareCaseInsensitive = 1,
    kCFCompareBackwards = 4,
    kCFCompareAnchored = 8,
    kCFCompareNonliteral = 16,
    kCFCompareLocalized = 32,
    kCFCompareNumerically = 64,
    kCFCompareDiacriticInsensitive = 128,
    kCFCompareWidthInsensitive = 256,
    kCFCompareForcedOrdering = 512
}
export declare enum CFStringEncodings {
    kCFStringEncodingMacJapanese = 1,
    kCFStringEncodingMacChineseTrad = 2,
    kCFStringEncodingMacKorean = 3,
    kCFStringEncodingMacArabic = 4,
    kCFStringEncodingMacHebrew = 5,
    kCFStringEncodingMacGreek = 6,
    kCFStringEncodingMacCyrillic = 7,
    kCFStringEncodingMacDevanagari = 9,
    kCFStringEncodingMacGurmukhi = 10,
    kCFStringEncodingMacGujarati = 11,
    kCFStringEncodingMacOriya = 12,
    kCFStringEncodingMacBengali = 13,
    kCFStringEncodingMacTamil = 14,
    kCFStringEncodingMacTelugu = 15,
    kCFStringEncodingMacKannada = 16,
    kCFStringEncodingMacMalayalam = 17,
    kCFStringEncodingMacSinhalese = 18,
    kCFStringEncodingMacBurmese = 19,
    kCFStringEncodingMacKhmer = 20,
    kCFStringEncodingMacThai = 21,
    kCFStringEncodingMacLaotian = 22,
    kCFStringEncodingMacGeorgian = 23,
    kCFStringEncodingMacArmenian = 24,
    kCFStringEncodingMacChineseSimp = 25,
    kCFStringEncodingMacTibetan = 26,
    kCFStringEncodingMacMongolian = 27,
    kCFStringEncodingMacEthiopic = 28,
    kCFStringEncodingMacCentralEurRoman = 29,
    kCFStringEncodingMacVietnamese = 30,
    kCFStringEncodingMacExtArabic = 31,
    kCFStringEncodingMacSymbol = 33,
    kCFStringEncodingMacDingbats = 34,
    kCFStringEncodingMacTurkish = 35,
    kCFStringEncodingMacCroatian = 36,
    kCFStringEncodingMacIcelandic = 37,
    kCFStringEncodingMacRomanian = 38,
    kCFStringEncodingMacCeltic = 39,
    kCFStringEncodingMacGaelic = 40,
    kCFStringEncodingMacFarsi = 140,
    kCFStringEncodingMacUkrainian = 152,
    kCFStringEncodingMacInuit = 236,
    kCFStringEncodingMacVT100 = 252,
    kCFStringEncodingMacHFS = 255,
    kCFStringEncodingISOLatin2 = 514,
    kCFStringEncodingISOLatin3 = 515,
    kCFStringEncodingISOLatin4 = 516,
    kCFStringEncodingISOLatinCyrillic = 517,
    kCFStringEncodingISOLatinArabic = 518,
    kCFStringEncodingISOLatinGreek = 519,
    kCFStringEncodingISOLatinHebrew = 520,
    kCFStringEncodingISOLatin5 = 521,
    kCFStringEncodingISOLatin6 = 522,
    kCFStringEncodingISOLatinThai = 523,
    kCFStringEncodingISOLatin7 = 525,
    kCFStringEncodingISOLatin8 = 526,
    kCFStringEncodingISOLatin9 = 527,
    kCFStringEncodingISOLatin10 = 528,
    kCFStringEncodingDOSLatinUS = 1024,
    kCFStringEncodingDOSGreek = 1029,
    kCFStringEncodingDOSBalticRim = 1030,
    kCFStringEncodingDOSLatin1 = 1040,
    kCFStringEncodingDOSGreek1 = 1041,
    kCFStringEncodingDOSLatin2 = 1042,
    kCFStringEncodingDOSCyrillic = 1043,
    kCFStringEncodingDOSTurkish = 1044,
    kCFStringEncodingDOSPortuguese = 1045,
    kCFStringEncodingDOSIcelandic = 1046,
    kCFStringEncodingDOSHebrew = 1047,
    kCFStringEncodingDOSCanadianFrench = 1048,
    kCFStringEncodingDOSArabic = 1049,
    kCFStringEncodingDOSNordic = 1050,
    kCFStringEncodingDOSRussian = 1051,
    kCFStringEncodingDOSGreek2 = 1052,
    kCFStringEncodingDOSThai = 1053,
    kCFStringEncodingDOSJapanese = 1056,
    kCFStringEncodingDOSChineseSimplif = 1057,
    kCFStringEncodingDOSKorean = 1058,
    kCFStringEncodingDOSChineseTrad = 1059,
    kCFStringEncodingWindowsLatin2 = 1281,
    kCFStringEncodingWindowsCyrillic = 1282,
    kCFStringEncodingWindowsGreek = 1283,
    kCFStringEncodingWindowsLatin5 = 1284,
    kCFStringEncodingWindowsHebrew = 1285,
    kCFStringEncodingWindowsArabic = 1286,
    kCFStringEncodingWindowsBalticRim = 1287,
    kCFStringEncodingWindowsVietnamese = 1288,
    kCFStringEncodingWindowsKoreanJohab = 1296,
    kCFStringEncodingANSEL = 1537,
    kCFStringEncodingJIS_X0201_76 = 1568,
    kCFStringEncodingJIS_X0208_83 = 1569,
    kCFStringEncodingJIS_X0208_90 = 1570,
    kCFStringEncodingJIS_X0212_90 = 1571,
    kCFStringEncodingJIS_C6226_78 = 1572,
    kCFStringEncodingShiftJIS_X0213 = 1576,
    kCFStringEncodingShiftJIS_X0213_MenKuTen = 1577,
    kCFStringEncodingGB_2312_80 = 1584,
    kCFStringEncodingGBK_95 = 1585,
    kCFStringEncodingGB_18030_2000 = 1586,
    kCFStringEncodingKSC_5601_87 = 1600,
    kCFStringEncodingKSC_5601_92_Johab = 1601,
    kCFStringEncodingCNS_11643_92_P1 = 1617,
    kCFStringEncodingCNS_11643_92_P2 = 1618,
    kCFStringEncodingCNS_11643_92_P3 = 1619,
    kCFStringEncodingISO_2022_JP = 2080,
    kCFStringEncodingISO_2022_JP_2 = 2081,
    kCFStringEncodingISO_2022_JP_1 = 2082,
    kCFStringEncodingISO_2022_JP_3 = 2083,
    kCFStringEncodingISO_2022_CN = 2096,
    kCFStringEncodingISO_2022_CN_EXT = 2097,
    kCFStringEncodingISO_2022_KR = 2112,
    kCFStringEncodingEUC_JP = 2336,
    kCFStringEncodingEUC_CN = 2352,
    kCFStringEncodingEUC_TW = 2353,
    kCFStringEncodingEUC_KR = 2368,
    kCFStringEncodingShiftJIS = 2561,
    kCFStringEncodingKOI8_R = 2562,
    kCFStringEncodingBig5 = 2563,
    kCFStringEncodingMacRomanLatin1 = 2564,
    kCFStringEncodingHZ_GB_2312 = 2565,
    kCFStringEncodingBig5_HKSCS_1999 = 2566,
    kCFStringEncodingVISCII = 2567,
    kCFStringEncodingKOI8_U = 2568,
    kCFStringEncodingBig5_E = 2569,
    kCFStringEncodingNextStepJapanese = 2818,
    kCFStringEncodingEBCDIC_US = 3073,
    kCFStringEncodingEBCDIC_CP037 = 3074,
    kCFStringEncodingUTF7 = 67109120,
    kCFStringEncodingUTF7_IMAP = 2576,
    kCFStringEncodingShiftJIS_X0213_00 = 1576
}
export declare enum CFStringNormalizationForm {
    kCFStringNormalizationFormD = 0,
    kCFStringNormalizationFormKD = 1,
    kCFStringNormalizationFormC = 2,
    kCFStringNormalizationFormKC = 3
}
export declare enum CFStringTokenizerTokenType {
    kCFStringTokenizerTokenNone = 0,
    kCFStringTokenizerTokenNormal = 1,
    kCFStringTokenizerTokenHasSubTokensMask = 2,
    kCFStringTokenizerTokenHasDerivedSubTokensMask = 4,
    kCFStringTokenizerTokenHasHasNumbersMask = 8,
    kCFStringTokenizerTokenHasNonLettersMask = 16,
    kCFStringTokenizerTokenIsCJWordMask = 32
}
export declare enum CFTimeZoneNameStyle {
    kCFTimeZoneNameStyleStandard = 0,
    kCFTimeZoneNameStyleShortStandard = 1,
    kCFTimeZoneNameStyleDaylightSaving = 2,
    kCFTimeZoneNameStyleShortDaylightSaving = 3,
    kCFTimeZoneNameStyleGeneric = 4,
    kCFTimeZoneNameStyleShortGeneric = 5
}
export declare enum CFURLBookmarkCreationOptions {
    kCFURLBookmarkCreationMinimalBookmarkMask = 512,
    kCFURLBookmarkCreationSuitableForBookmarkFile = 1024,
    kCFURLBookmarkCreationWithSecurityScope = 2048,
    kCFURLBookmarkCreationSecurityScopeAllowOnlyReadAccess = 4096,
    kCFURLBookmarkCreationPreferFileIDResolutionMask = 256
}
export declare enum CFURLBookmarkResolutionOptions {
    kCFURLBookmarkResolutionWithoutUIMask = 256,
    kCFURLBookmarkResolutionWithoutMountingMask = 512,
    kCFURLBookmarkResolutionWithSecurityScope = 1024,
    kCFBookmarkResolutionWithoutUIMask = 256,
    kCFBookmarkResolutionWithoutMountingMask = 512
}
export declare enum CFURLComponentType {
    kCFURLComponentScheme = 1,
    kCFURLComponentNetLocation = 2,
    kCFURLComponentPath = 3,
    kCFURLComponentResourceSpecifier = 4,
    kCFURLComponentUser = 5,
    kCFURLComponentPassword = 6,
    kCFURLComponentUserInfo = 7,
    kCFURLComponentHost = 8,
    kCFURLComponentPort = 9,
    kCFURLComponentParameterString = 10,
    kCFURLComponentQuery = 11,
    kCFURLComponentFragment = 12
}
export declare enum CFURLEnumeratorOptions {
    kCFURLEnumeratorDefaultBehavior = 0,
    kCFURLEnumeratorDescendRecursively = 1,
    kCFURLEnumeratorSkipInvisibles = 2,
    kCFURLEnumeratorGenerateFileReferenceURLs = 4,
    kCFURLEnumeratorSkipPackageContents = 8,
    kCFURLEnumeratorIncludeDirectoriesPreOrder = 16,
    kCFURLEnumeratorIncludeDirectoriesPostOrder = 32,
    kCFURLEnumeratorGenerateRelativePathURLs = 64
}
export declare enum CFURLEnumeratorResult {
    kCFURLEnumeratorSuccess = 1,
    kCFURLEnumeratorEnd = 2,
    kCFURLEnumeratorError = 3,
    kCFURLEnumeratorDirectoryPostOrderSuccess = 4
}
export declare enum CFURLPathStyle {
    kCFURLPOSIXPathStyle = 0,
    kCFURLHFSPathStyle = 1,
    kCFURLWindowsPathStyle = 2
}
export declare enum CFXMLEntityTypeCode {
    kCFXMLEntityTypeParameter = 0,
    kCFXMLEntityTypeParsedInternal = 1,
    kCFXMLEntityTypeParsedExternal = 2,
    kCFXMLEntityTypeUnparsed = 3,
    kCFXMLEntityTypeCharacter = 4
}
export declare enum CFXMLNodeTypeCode {
    kCFXMLNodeTypeDocument = 1,
    kCFXMLNodeTypeElement = 2,
    kCFXMLNodeTypeAttribute = 3,
    kCFXMLNodeTypeProcessingInstruction = 4,
    kCFXMLNodeTypeComment = 5,
    kCFXMLNodeTypeText = 6,
    kCFXMLNodeTypeCDATASection = 7,
    kCFXMLNodeTypeDocumentFragment = 8,
    kCFXMLNodeTypeEntity = 9,
    kCFXMLNodeTypeEntityReference = 10,
    kCFXMLNodeTypeDocumentType = 11,
    kCFXMLNodeTypeWhitespace = 12,
    kCFXMLNodeTypeNotation = 13,
    kCFXMLNodeTypeElementTypeDeclaration = 14,
    kCFXMLNodeTypeAttributeListDeclaration = 15
}
export declare enum CFXMLParserOptions {
    kCFXMLParserValidateDocument = 1,
    kCFXMLParserSkipMetaData = 2,
    kCFXMLParserReplacePhysicalEntities = 4,
    kCFXMLParserSkipWhitespace = 8,
    kCFXMLParserResolveExternalEntities = 16,
    kCFXMLParserAddImpliedAttributes = 32,
    kCFXMLParserAllOptions = 16777215,
    kCFXMLParserNoOptions = 0
}
export declare enum CFXMLParserStatusCode {
    kCFXMLStatusParseNotBegun = -2,
    kCFXMLStatusParseInProgress = -1,
    kCFXMLStatusParseSuccessful = 0,
    kCFXMLErrorUnexpectedEOF = 1,
    kCFXMLErrorUnknownEncoding = 2,
    kCFXMLErrorEncodingConversionFailure = 3,
    kCFXMLErrorMalformedProcessingInstruction = 4,
    kCFXMLErrorMalformedDTD = 5,
    kCFXMLErrorMalformedName = 6,
    kCFXMLErrorMalformedCDSect = 7,
    kCFXMLErrorMalformedCloseTag = 8,
    kCFXMLErrorMalformedStartTag = 9,
    kCFXMLErrorMalformedDocument = 10,
    kCFXMLErrorElementlessDocument = 11,
    kCFXMLErrorMalformedComment = 12,
    kCFXMLErrorMalformedCharacterReference = 13,
    kCFXMLErrorMalformedParsedCharacterData = 14,
    kCFXMLErrorNoData = 15
}
export declare enum __CFByteOrder {
    CFByteOrderUnknown = 0,
    CFByteOrderLittleEndian = 1,
    CFByteOrderBigEndian = 2
}
export declare enum AlignmentOptions {
    MinXInward = 1,
    MinYInward = 2,
    MaxXInward = 4,
    MaxYInward = 8,
    WidthInward = 16,
    HeightInward = 32,
    MinXOutward = 256,
    MinYOutward = 512,
    MaxXOutward = 1024,
    MaxYOutward = 2048,
    WidthOutward = 4096,
    HeightOutward = 8192,
    MinXNearest = 65536,
    MinYNearest = 131072,
    MaxXNearest = 262144,
    MaxYNearest = 524288,
    WidthNearest = 1048576,
    HeightNearest = 2097152,
    RectFlipped = -9223372036854776000,
    AllEdgesInward = 15,
    AllEdgesOutward = 3840,
    AllEdgesNearest = 983040
}
export declare enum NSBinarySearchingOptions {
    FirstEqual = 256,
    LastEqual = 512,
    InsertionIndex = 1024
}
export declare enum NSCollectionChangeType {
    Insert = 0,
    Remove = 1
}
export declare enum ComparisonResult {
    OrderedAscending = -1,
    OrderedSame = 0,
    OrderedDescending = 1
}
export declare enum NSEnumerationOptions {
    Concurrent = 1,
    Reverse = 2
}
export declare enum NSItemProviderFileOptions {
    OpenInPlace = 1
}
export declare enum NSItemProviderRepresentationVisibility {
    All = 0,
    Team = 1,
    Group = 2,
    OwnProcess = 3
}
export declare enum NSKeyValueChange {
    Setting = 1,
    Insertion = 2,
    Removal = 3,
    Replacement = 4
}
export declare enum NSKeyValueObservingOptions {
    New = 1,
    Old = 2,
    Initial = 4,
    Prior = 8
}
export declare enum NSKeyValueSetMutationKind {
    UnionSetMutation = 1,
    MinusSetMutation = 2,
    IntersectSetMutation = 3,
    SetSetMutation = 4
}
export declare enum NSLinguisticTaggerUnit {
    Word = 0,
    Sentence = 1,
    Paragraph = 2,
    Document = 3
}
export declare enum NSOrderedCollectionDifferenceCalculationOptions {
    OmitInsertedObjects = 1,
    OmitRemovedObjects = 2,
    InferMoves = 4
}
export declare enum QualityOfService {
    UserInteractive = 33,
    UserInitiated = 25,
    Utility = 17,
    Background = 9,
    Default = -1
}
export declare enum NSRectEdge {
    RectEdgeMinX = 0,
    RectEdgeMinY = 1,
    RectEdgeMaxX = 2,
    RectEdgeMaxY = 3,
    MinXEdge = 0,
    MinYEdge = 1,
    MaxXEdge = 2,
    MaxYEdge = 3
}
export declare enum NSSaveOptions {
    Yes = 0,
    No = 1,
    Ask = 2
}
export declare enum NSSortOptions {
    Concurrent = 1,
    Stable = 16
}
export declare enum NSURLErrorNetworkUnavailableReason {
    Cellular = 0,
    Expensive = 1,
    Constrained = 2
}
export declare enum NSURLSessionDelayedRequestDisposition {
    ContinueLoading = 0,
    UseNewRequest = 1,
    Cancel = 2
}
export declare enum NSURLSessionWebSocketMessageType {
    Data = 0,
    String = 1
}
export declare let NSAllRomanInputSourcesLocaleIdentifier: string;
export declare let NSAnimationTriggerOrderIn: string;
export declare let NSAnimationTriggerOrderOut: string;
export declare let NSApp: NSApplication;
export declare let NSBlack: number;
export declare let NSDarkGray: number;
export declare let NSDirectionalEdgeInsetsZero: NSDirectionalEdgeInsets;
export declare let NSLightGray: number;
export declare let NSMultipleValuesMarker: any;
export declare let NSNoSelectionMarker: any;
export declare let NSNotApplicableMarker: any;
export declare let NSTypeIdentifierAddressText: string;
export declare let NSTypeIdentifierDateText: string;
export declare let NSTypeIdentifierPhoneNumberText: string;
export declare let NSTypeIdentifierTransitInformationText: string;
export declare let NSUnderlineByWord: NSUnderlineStyle;
export declare let NSUnderlinePatternDash: NSUnderlineStyle;
export declare let NSUnderlinePatternDashDot: NSUnderlineStyle;
export declare let NSUnderlinePatternDashDotDot: NSUnderlineStyle;
export declare let NSUnderlinePatternDot: NSUnderlineStyle;
export declare let NSUnderlinePatternSolid: NSUnderlineStyle;
export declare let NSUserActivityDocumentURLKey: string;
export declare let NSWhite: number;
export declare let kCFAbsoluteTimeIntervalSince1904: number;
export declare let kCFAbsoluteTimeIntervalSince1970: number;
export declare let kCFAllocatorDefault: any;
export declare let kCFAllocatorMalloc: any;
export declare let kCFAllocatorMallocZone: any;
export declare let kCFAllocatorNull: any;
export declare let kCFAllocatorSystemDefault: any;
export declare let kCFAllocatorUseContext: any;
export declare let kCFBooleanFalse: number;
export declare let kCFBooleanTrue: number;
export declare let kCFBundleDevelopmentRegionKey: string;
export declare let kCFBundleExecutableKey: string;
export declare let kCFBundleIdentifierKey: string;
export declare let kCFBundleInfoDictionaryVersionKey: string;
export declare let kCFBundleLocalizationsKey: string;
export declare let kCFBundleNameKey: string;
export declare let kCFBundleVersionKey: string;
export declare let kCFCopyStringBagCallBacks: CFBagCallBacks;
export declare let kCFCopyStringDictionaryKeyCallBacks: CFDictionaryKeyCallBacks;
export declare let kCFCopyStringSetCallBacks: CFSetCallBacks;
export declare let kCFCoreFoundationVersionNumber: number;
export declare let kCFErrorDescriptionKey: string;
export declare let kCFErrorDomainCocoa: any;
export declare let kCFErrorDomainMach: any;
export declare let kCFErrorDomainOSStatus: any;
export declare let kCFErrorDomainPOSIX: any;
export declare let kCFErrorFilePathKey: string;
export declare let kCFErrorLocalizedDescriptionKey: string;
export declare let kCFErrorLocalizedFailureKey: string;
export declare let kCFErrorLocalizedFailureReasonKey: string;
export declare let kCFErrorLocalizedRecoverySuggestionKey: string;
export declare let kCFErrorURLKey: string;
export declare let kCFErrorUnderlyingErrorKey: string;
export declare let kCFNotFound: number;
export declare let kCFNull: NSNull;
export declare let kCFNumberNaN: number;
export declare let kCFNumberNegativeInfinity: number;
export declare let kCFNumberPositiveInfinity: number;
export declare let kCFPlugInDynamicRegisterFunctionKey: string;
export declare let kCFPlugInDynamicRegistrationKey: string;
export declare let kCFPlugInFactoriesKey: string;
export declare let kCFPlugInTypesKey: string;
export declare let kCFPlugInUnloadFunctionKey: string;
export declare let kCFPreferencesAnyApplication: string;
export declare let kCFPreferencesAnyHost: string;
export declare let kCFPreferencesAnyUser: string;
export declare let kCFPreferencesCurrentApplication: string;
export declare let kCFPreferencesCurrentHost: string;
export declare let kCFPreferencesCurrentUser: string;
export declare let kCFSocketCommandKey: string;
export declare let kCFSocketErrorKey: string;
export declare let kCFSocketNameKey: string;
export declare let kCFSocketRegisterCommand: string;
export declare let kCFSocketResultKey: string;
export declare let kCFSocketRetrieveCommand: string;
export declare let kCFSocketValueKey: string;
export declare let kCFStreamErrorDomainSOCKS: number;
export declare let kCFStreamErrorDomainSSL: number;
export declare let kCFStreamPropertySOCKSPassword: string;
export declare let kCFStreamPropertySOCKSProxy: string;
export declare let kCFStreamPropertySOCKSProxyHost: string;
export declare let kCFStreamPropertySOCKSProxyPort: string;
export declare let kCFStreamPropertySOCKSUser: string;
export declare let kCFStreamPropertySOCKSVersion: string;
export declare let kCFStreamPropertyShouldCloseNativeSocket: string;
export declare let kCFStreamPropertySocketSecurityLevel: string;
export declare let kCFStreamSocketSOCKSVersion4: string;
export declare let kCFStreamSocketSOCKSVersion5: string;
export declare let kCFStreamSocketSecurityLevelNegotiatedSSL: string;
export declare let kCFStreamSocketSecurityLevelNone: string;
export declare let kCFStreamSocketSecurityLevelTLSv1: string;
export declare let kCFStringBinaryHeapCallBacks: CFBinaryHeapCallBacks;
export declare let kCFStringTransformFullwidthHalfwidth: string;
export declare let kCFStringTransformHiraganaKatakana: string;
export declare let kCFStringTransformLatinArabic: string;
export declare let kCFStringTransformLatinCyrillic: string;
export declare let kCFStringTransformLatinGreek: string;
export declare let kCFStringTransformLatinHangul: string;
export declare let kCFStringTransformLatinHebrew: string;
export declare let kCFStringTransformLatinHiragana: string;
export declare let kCFStringTransformLatinKatakana: string;
export declare let kCFStringTransformLatinThai: string;
export declare let kCFStringTransformMandarinLatin: string;
export declare let kCFStringTransformStripCombiningMarks: string;
export declare let kCFStringTransformStripDiacritics: string;
export declare let kCFStringTransformToLatin: string;
export declare let kCFStringTransformToUnicodeName: string;
export declare let kCFStringTransformToXMLHex: string;
export declare let kCFTypeArrayCallBacks: CFArrayCallBacks;
export declare let kCFTypeBagCallBacks: CFBagCallBacks;
export declare let kCFTypeDictionaryKeyCallBacks: CFDictionaryKeyCallBacks;
export declare let kCFTypeDictionaryValueCallBacks: CFDictionaryValueCallBacks;
export declare let kCFTypeSetCallBacks: CFSetCallBacks;
export declare let kCFURLAddedToDirectoryDateKey: string;
export declare let kCFURLApplicationIsScriptableKey: string;
export declare let kCFURLAttributeModificationDateKey: string;
export declare let kCFURLCanonicalPathKey: string;
export declare let kCFURLContentAccessDateKey: string;
export declare let kCFURLContentModificationDateKey: string;
export declare let kCFURLCreationDateKey: string;
export declare let kCFURLDocumentIdentifierKey: string;
export declare let kCFURLFileAllocatedSizeKey: string;
export declare let kCFURLFileResourceIdentifierKey: string;
export declare let kCFURLFileResourceTypeBlockSpecial: string;
export declare let kCFURLFileResourceTypeCharacterSpecial: string;
export declare let kCFURLFileResourceTypeDirectory: string;
export declare let kCFURLFileResourceTypeKey: string;
export declare let kCFURLFileResourceTypeNamedPipe: string;
export declare let kCFURLFileResourceTypeRegular: string;
export declare let kCFURLFileResourceTypeSocket: string;
export declare let kCFURLFileResourceTypeSymbolicLink: string;
export declare let kCFURLFileResourceTypeUnknown: string;
export declare let kCFURLFileSecurityKey: string;
export declare let kCFURLFileSizeKey: string;
export declare let kCFURLGenerationIdentifierKey: string;
export declare let kCFURLHasHiddenExtensionKey: string;
export declare let kCFURLIsAliasFileKey: string;
export declare let kCFURLIsApplicationKey: string;
export declare let kCFURLIsDirectoryKey: string;
export declare let kCFURLIsExcludedFromBackupKey: string;
export declare let kCFURLIsExecutableKey: string;
export declare let kCFURLIsHiddenKey: string;
export declare let kCFURLIsMountTriggerKey: string;
export declare let kCFURLIsPackageKey: string;
export declare let kCFURLIsReadableKey: string;
export declare let kCFURLIsRegularFileKey: string;
export declare let kCFURLIsSymbolicLinkKey: string;
export declare let kCFURLIsSystemImmutableKey: string;
export declare let kCFURLIsUbiquitousItemKey: string;
export declare let kCFURLIsUserImmutableKey: string;
export declare let kCFURLIsVolumeKey: string;
export declare let kCFURLIsWritableKey: string;
export declare let kCFURLKeysOfUnsetValuesKey: string;
export declare let kCFURLLabelNumberKey: string;
export declare let kCFURLLinkCountKey: string;
export declare let kCFURLLocalizedLabelKey: string;
export declare let kCFURLLocalizedNameKey: string;
export declare let kCFURLLocalizedTypeDescriptionKey: string;
export declare let kCFURLNameKey: string;
export declare let kCFURLParentDirectoryURLKey: string;
export declare let kCFURLPathKey: string;
export declare let kCFURLPreferredIOBlockSizeKey: string;
export declare let kCFURLQuarantinePropertiesKey: string;
export declare let kCFURLTagNamesKey: string;
export declare let kCFURLTotalFileAllocatedSizeKey: string;
export declare let kCFURLTotalFileSizeKey: string;
export declare let kCFURLTypeIdentifierKey: string;
export declare let kCFURLUbiquitousItemDownloadingErrorKey: string;
export declare let kCFURLUbiquitousItemDownloadingStatusCurrent: string;
export declare let kCFURLUbiquitousItemDownloadingStatusDownloaded: string;
export declare let kCFURLUbiquitousItemDownloadingStatusKey: string;
export declare let kCFURLUbiquitousItemDownloadingStatusNotDownloaded: string;
export declare let kCFURLUbiquitousItemHasUnresolvedConflictsKey: string;
export declare let kCFURLUbiquitousItemIsDownloadingKey: string;
export declare let kCFURLUbiquitousItemIsUploadedKey: string;
export declare let kCFURLUbiquitousItemIsUploadingKey: string;
export declare let kCFURLUbiquitousItemUploadingErrorKey: string;
export declare let kCFURLVolumeAvailableCapacityForImportantUsageKey: string;
export declare let kCFURLVolumeAvailableCapacityForOpportunisticUsageKey: string;
export declare let kCFURLVolumeAvailableCapacityKey: string;
export declare let kCFURLVolumeCreationDateKey: string;
export declare let kCFURLVolumeIdentifierKey: string;
export declare let kCFURLVolumeIsAutomountedKey: string;
export declare let kCFURLVolumeIsBrowsableKey: string;
export declare let kCFURLVolumeIsEjectableKey: string;
export declare let kCFURLVolumeIsEncryptedKey: string;
export declare let kCFURLVolumeIsInternalKey: string;
export declare let kCFURLVolumeIsJournalingKey: string;
export declare let kCFURLVolumeIsLocalKey: string;
export declare let kCFURLVolumeIsReadOnlyKey: string;
export declare let kCFURLVolumeIsRemovableKey: string;
export declare let kCFURLVolumeIsRootFileSystemKey: string;
export declare let kCFURLVolumeLocalizedFormatDescriptionKey: string;
export declare let kCFURLVolumeLocalizedNameKey: string;
export declare let kCFURLVolumeMaximumFileSizeKey: string;
export declare let kCFURLVolumeNameKey: string;
export declare let kCFURLVolumeResourceCountKey: string;
export declare let kCFURLVolumeSupportsAccessPermissionsKey: string;
export declare let kCFURLVolumeSupportsAdvisoryFileLockingKey: string;
export declare let kCFURLVolumeSupportsCasePreservedNamesKey: string;
export declare let kCFURLVolumeSupportsCaseSensitiveNamesKey: string;
export declare let kCFURLVolumeSupportsCompressionKey: string;
export declare let kCFURLVolumeSupportsExclusiveRenamingKey: string;
export declare let kCFURLVolumeSupportsExtendedSecurityKey: string;
export declare let kCFURLVolumeSupportsFileCloningKey: string;
export declare let kCFURLVolumeSupportsHardLinksKey: string;
export declare let kCFURLVolumeSupportsImmutableFilesKey: string;
export declare let kCFURLVolumeSupportsJournalingKey: string;
export declare let kCFURLVolumeSupportsPersistentIDsKey: string;
export declare let kCFURLVolumeSupportsRenamingKey: string;
export declare let kCFURLVolumeSupportsRootDirectoryDatesKey: string;
export declare let kCFURLVolumeSupportsSparseFilesKey: string;
export declare let kCFURLVolumeSupportsSwapRenamingKey: string;
export declare let kCFURLVolumeSupportsSymbolicLinksKey: string;
export declare let kCFURLVolumeSupportsVolumeSizesKey: string;
export declare let kCFURLVolumeSupportsZeroRunsKey: string;
export declare let kCFURLVolumeTotalCapacityKey: string;
export declare let kCFURLVolumeURLForRemountingKey: string;
export declare let kCFURLVolumeURLKey: string;
export declare let kCFURLVolumeUUIDStringKey: string;
export declare let kCFUserNotificationAlertHeaderKey: string;
export declare let kCFUserNotificationAlertMessageKey: string;
export declare let kCFUserNotificationAlertTopMostKey: string;
export declare let kCFUserNotificationAlternateButtonTitleKey: string;
export declare let kCFUserNotificationCheckBoxTitlesKey: string;
export declare let kCFUserNotificationDefaultButtonTitleKey: string;
export declare let kCFUserNotificationIconURLKey: string;
export declare let kCFUserNotificationKeyboardTypesKey: string;
export declare let kCFUserNotificationLocalizationURLKey: string;
export declare let kCFUserNotificationOtherButtonTitleKey: string;
export declare let kCFUserNotificationPopUpSelectionKey: string;
export declare let kCFUserNotificationPopUpTitlesKey: string;
export declare let kCFUserNotificationProgressIndicatorValueKey: string;
export declare let kCFUserNotificationSoundURLKey: string;
export declare let kCFUserNotificationTextFieldTitlesKey: string;
export declare let kCFUserNotificationTextFieldValuesKey: string;
export declare let kCFXMLTreeErrorDescription: string;
export declare let kCFXMLTreeErrorLineNumber: string;
export declare let kCFXMLTreeErrorLocation: string;
export declare let kCFXMLTreeErrorStatusCode: string;
export declare let NSAppleEventTimeOutDefault: number;
export declare let NSAppleEventTimeOutNone: number;
export declare let NSAssertionHandlerKey: string;
export declare let NSCocoaErrorDomain: string;
export declare let NSDeallocateZombies: boolean;
export declare let NSDebugDescriptionErrorKey: string;
export declare let NSDebugEnabled: boolean;
export declare let NSEdgeInsetsZero: NSEdgeInsets;
export declare let NSExtensionItemAttachmentsKey: string;
export declare let NSExtensionItemAttributedContentTextKey: string;
export declare let NSExtensionItemAttributedTitleKey: string;
export declare let NSExtensionItemsAndErrorsKey: string;
export declare let NSExtensionJavaScriptPreprocessingResultsKey: string;
export declare let NSFileHandleNotificationDataItem: string;
export declare let NSFileHandleNotificationFileHandleItem: string;
export declare let NSFileManagerUnmountDissentingProcessIdentifierErrorKey: string;
export declare let NSFilePathErrorKey: string;
export declare let NSFoundationVersionNumber: number;
export declare let NSGrammarCorrections: string;
export declare let NSGrammarRange: string;
export declare let NSGrammarUserDescription: string;
export declare let NSHashTableCopyIn: NSPointerFunctions.Options;
export declare let NSHashTableObjectPointerPersonality: NSPointerFunctions.Options;
export declare let NSHashTableStrongMemory: NSPointerFunctions.Options;
export declare let NSHashTableWeakMemory: NSPointerFunctions.Options;
export declare let NSHelpAnchorErrorKey: string;
export declare let NSIntegerHashCallBacks: NSHashTableCallBacks;
export declare let NSIntegerMapKeyCallBacks: NSMapTableKeyCallBacks;
export declare let NSIntegerMapValueCallBacks: NSMapTableValueCallBacks;
export declare let NSItemProviderPreferredImageSizeKey: string;
export declare let NSKeepAllocationStatistics: boolean;
export declare let NSKeyedArchiveRootObjectKey: string;
export declare let NSLoadedClasses: string;
export declare let NSLocalizedDescriptionKey: string;
export declare let NSLocalizedFailureErrorKey: string;
export declare let NSLocalizedFailureReasonErrorKey: string;
export declare let NSLocalizedRecoveryOptionsErrorKey: string;
export declare let NSLocalizedRecoverySuggestionErrorKey: string;
export declare let NSMachErrorDomain: string;
export declare let NSMapTableCopyIn: NSPointerFunctions.Options;
export declare let NSMapTableObjectPointerPersonality: NSPointerFunctions.Options;
export declare let NSMapTableStrongMemory: NSPointerFunctions.Options;
export declare let NSMapTableWeakMemory: NSPointerFunctions.Options;
export declare let NSMetadataItemAcquisitionMakeKey: string;
export declare let NSMetadataItemAcquisitionModelKey: string;
export declare let NSMetadataItemAlbumKey: string;
export declare let NSMetadataItemAltitudeKey: string;
export declare let NSMetadataItemApertureKey: string;
export declare let NSMetadataItemAppleLoopDescriptorsKey: string;
export declare let NSMetadataItemAppleLoopsKeyFilterTypeKey: string;
export declare let NSMetadataItemAppleLoopsLoopModeKey: string;
export declare let NSMetadataItemAppleLoopsRootKeyKey: string;
export declare let NSMetadataItemApplicationCategoriesKey: string;
export declare let NSMetadataItemAttributeChangeDateKey: string;
export declare let NSMetadataItemAudiencesKey: string;
export declare let NSMetadataItemAudioBitRateKey: string;
export declare let NSMetadataItemAudioChannelCountKey: string;
export declare let NSMetadataItemAudioEncodingApplicationKey: string;
export declare let NSMetadataItemAudioSampleRateKey: string;
export declare let NSMetadataItemAudioTrackNumberKey: string;
export declare let NSMetadataItemAuthorAddressesKey: string;
export declare let NSMetadataItemAuthorEmailAddressesKey: string;
export declare let NSMetadataItemAuthorsKey: string;
export declare let NSMetadataItemBitsPerSampleKey: string;
export declare let NSMetadataItemCFBundleIdentifierKey: string;
export declare let NSMetadataItemCameraOwnerKey: string;
export declare let NSMetadataItemCityKey: string;
export declare let NSMetadataItemCodecsKey: string;
export declare let NSMetadataItemColorSpaceKey: string;
export declare let NSMetadataItemCommentKey: string;
export declare let NSMetadataItemComposerKey: string;
export declare let NSMetadataItemContactKeywordsKey: string;
export declare let NSMetadataItemContentCreationDateKey: string;
export declare let NSMetadataItemContentModificationDateKey: string;
export declare let NSMetadataItemContentTypeKey: string;
export declare let NSMetadataItemContentTypeTreeKey: string;
export declare let NSMetadataItemContributorsKey: string;
export declare let NSMetadataItemCopyrightKey: string;
export declare let NSMetadataItemCountryKey: string;
export declare let NSMetadataItemCoverageKey: string;
export declare let NSMetadataItemCreatorKey: string;
export declare let NSMetadataItemDateAddedKey: string;
export declare let NSMetadataItemDeliveryTypeKey: string;
export declare let NSMetadataItemDescriptionKey: string;
export declare let NSMetadataItemDirectorKey: string;
export declare let NSMetadataItemDisplayNameKey: string;
export declare let NSMetadataItemDownloadedDateKey: string;
export declare let NSMetadataItemDueDateKey: string;
export declare let NSMetadataItemDurationSecondsKey: string;
export declare let NSMetadataItemEXIFGPSVersionKey: string;
export declare let NSMetadataItemEXIFVersionKey: string;
export declare let NSMetadataItemEditorsKey: string;
export declare let NSMetadataItemEmailAddressesKey: string;
export declare let NSMetadataItemEncodingApplicationsKey: string;
export declare let NSMetadataItemExecutableArchitecturesKey: string;
export declare let NSMetadataItemExecutablePlatformKey: string;
export declare let NSMetadataItemExposureModeKey: string;
export declare let NSMetadataItemExposureProgramKey: string;
export declare let NSMetadataItemExposureTimeSecondsKey: string;
export declare let NSMetadataItemExposureTimeStringKey: string;
export declare let NSMetadataItemFNumberKey: string;
export declare let NSMetadataItemFSContentChangeDateKey: string;
export declare let NSMetadataItemFSCreationDateKey: string;
export declare let NSMetadataItemFSNameKey: string;
export declare let NSMetadataItemFSSizeKey: string;
export declare let NSMetadataItemFinderCommentKey: string;
export declare let NSMetadataItemFlashOnOffKey: string;
export declare let NSMetadataItemFocalLength35mmKey: string;
export declare let NSMetadataItemFocalLengthKey: string;
export declare let NSMetadataItemFontsKey: string;
export declare let NSMetadataItemGPSAreaInformationKey: string;
export declare let NSMetadataItemGPSDOPKey: string;
export declare let NSMetadataItemGPSDateStampKey: string;
export declare let NSMetadataItemGPSDestBearingKey: string;
export declare let NSMetadataItemGPSDestDistanceKey: string;
export declare let NSMetadataItemGPSDestLatitudeKey: string;
export declare let NSMetadataItemGPSDestLongitudeKey: string;
export declare let NSMetadataItemGPSDifferentalKey: string;
export declare let NSMetadataItemGPSMapDatumKey: string;
export declare let NSMetadataItemGPSMeasureModeKey: string;
export declare let NSMetadataItemGPSProcessingMethodKey: string;
export declare let NSMetadataItemGPSStatusKey: string;
export declare let NSMetadataItemGPSTrackKey: string;
export declare let NSMetadataItemGenreKey: string;
export declare let NSMetadataItemHasAlphaChannelKey: string;
export declare let NSMetadataItemHeadlineKey: string;
export declare let NSMetadataItemISOSpeedKey: string;
export declare let NSMetadataItemIdentifierKey: string;
export declare let NSMetadataItemImageDirectionKey: string;
export declare let NSMetadataItemInformationKey: string;
export declare let NSMetadataItemInstantMessageAddressesKey: string;
export declare let NSMetadataItemInstructionsKey: string;
export declare let NSMetadataItemIsApplicationManagedKey: string;
export declare let NSMetadataItemIsGeneralMIDISequenceKey: string;
export declare let NSMetadataItemIsLikelyJunkKey: string;
export declare let NSMetadataItemIsUbiquitousKey: string;
export declare let NSMetadataItemKeySignatureKey: string;
export declare let NSMetadataItemKeywordsKey: string;
export declare let NSMetadataItemKindKey: string;
export declare let NSMetadataItemLanguagesKey: string;
export declare let NSMetadataItemLastUsedDateKey: string;
export declare let NSMetadataItemLatitudeKey: string;
export declare let NSMetadataItemLayerNamesKey: string;
export declare let NSMetadataItemLensModelKey: string;
export declare let NSMetadataItemLongitudeKey: string;
export declare let NSMetadataItemLyricistKey: string;
export declare let NSMetadataItemMaxApertureKey: string;
export declare let NSMetadataItemMediaTypesKey: string;
export declare let NSMetadataItemMeteringModeKey: string;
export declare let NSMetadataItemMusicalGenreKey: string;
export declare let NSMetadataItemMusicalInstrumentCategoryKey: string;
export declare let NSMetadataItemMusicalInstrumentNameKey: string;
export declare let NSMetadataItemNamedLocationKey: string;
export declare let NSMetadataItemNumberOfPagesKey: string;
export declare let NSMetadataItemOrganizationsKey: string;
export declare let NSMetadataItemOrientationKey: string;
export declare let NSMetadataItemOriginalFormatKey: string;
export declare let NSMetadataItemOriginalSourceKey: string;
export declare let NSMetadataItemPageHeightKey: string;
export declare let NSMetadataItemPageWidthKey: string;
export declare let NSMetadataItemParticipantsKey: string;
export declare let NSMetadataItemPathKey: string;
export declare let NSMetadataItemPerformersKey: string;
export declare let NSMetadataItemPhoneNumbersKey: string;
export declare let NSMetadataItemPixelCountKey: string;
export declare let NSMetadataItemPixelHeightKey: string;
export declare let NSMetadataItemPixelWidthKey: string;
export declare let NSMetadataItemProducerKey: string;
export declare let NSMetadataItemProfileNameKey: string;
export declare let NSMetadataItemProjectsKey: string;
export declare let NSMetadataItemPublishersKey: string;
export declare let NSMetadataItemRecipientAddressesKey: string;
export declare let NSMetadataItemRecipientEmailAddressesKey: string;
export declare let NSMetadataItemRecipientsKey: string;
export declare let NSMetadataItemRecordingDateKey: string;
export declare let NSMetadataItemRecordingYearKey: string;
export declare let NSMetadataItemRedEyeOnOffKey: string;
export declare let NSMetadataItemResolutionHeightDPIKey: string;
export declare let NSMetadataItemResolutionWidthDPIKey: string;
export declare let NSMetadataItemRightsKey: string;
export declare let NSMetadataItemSecurityMethodKey: string;
export declare let NSMetadataItemSpeedKey: string;
export declare let NSMetadataItemStarRatingKey: string;
export declare let NSMetadataItemStateOrProvinceKey: string;
export declare let NSMetadataItemStreamableKey: string;
export declare let NSMetadataItemSubjectKey: string;
export declare let NSMetadataItemTempoKey: string;
export declare let NSMetadataItemTextContentKey: string;
export declare let NSMetadataItemThemeKey: string;
export declare let NSMetadataItemTimeSignatureKey: string;
export declare let NSMetadataItemTimestampKey: string;
export declare let NSMetadataItemTitleKey: string;
export declare let NSMetadataItemTotalBitRateKey: string;
export declare let NSMetadataItemURLKey: string;
export declare let NSMetadataItemVersionKey: string;
export declare let NSMetadataItemVideoBitRateKey: string;
export declare let NSMetadataItemWhereFromsKey: string;
export declare let NSMetadataItemWhiteBalanceKey: string;
export declare let NSMetadataQueryAccessibleUbiquitousExternalDocumentsScope: string;
export declare let NSMetadataQueryIndexedLocalComputerScope: string;
export declare let NSMetadataQueryIndexedNetworkScope: string;
export declare let NSMetadataQueryLocalComputerScope: string;
export declare let NSMetadataQueryNetworkScope: string;
export declare let NSMetadataQueryResultContentRelevanceAttribute: string;
export declare let NSMetadataQueryUbiquitousDataScope: string;
export declare let NSMetadataQueryUbiquitousDocumentsScope: string;
export declare let NSMetadataQueryUpdateAddedItemsKey: string;
export declare let NSMetadataQueryUpdateChangedItemsKey: string;
export declare let NSMetadataQueryUpdateRemovedItemsKey: string;
export declare let NSMetadataQueryUserHomeScope: string;
export declare let NSMetadataUbiquitousItemContainerDisplayNameKey: string;
export declare let NSMetadataUbiquitousItemDownloadRequestedKey: string;
export declare let NSMetadataUbiquitousItemDownloadingErrorKey: string;
export declare let NSMetadataUbiquitousItemDownloadingStatusCurrent: string;
export declare let NSMetadataUbiquitousItemDownloadingStatusDownloaded: string;
export declare let NSMetadataUbiquitousItemDownloadingStatusKey: string;
export declare let NSMetadataUbiquitousItemDownloadingStatusNotDownloaded: string;
export declare let NSMetadataUbiquitousItemHasUnresolvedConflictsKey: string;
export declare let NSMetadataUbiquitousItemIsDownloadingKey: string;
export declare let NSMetadataUbiquitousItemIsExternalDocumentKey: string;
export declare let NSMetadataUbiquitousItemIsSharedKey: string;
export declare let NSMetadataUbiquitousItemIsUploadedKey: string;
export declare let NSMetadataUbiquitousItemIsUploadingKey: string;
export declare let NSMetadataUbiquitousItemPercentDownloadedKey: string;
export declare let NSMetadataUbiquitousItemPercentUploadedKey: string;
export declare let NSMetadataUbiquitousItemURLInLocalContainerKey: string;
export declare let NSMetadataUbiquitousItemUploadingErrorKey: string;
export declare let NSMetadataUbiquitousSharedItemCurrentUserPermissionsKey: string;
export declare let NSMetadataUbiquitousSharedItemCurrentUserRoleKey: string;
export declare let NSMetadataUbiquitousSharedItemMostRecentEditorNameComponentsKey: string;
export declare let NSMetadataUbiquitousSharedItemOwnerNameComponentsKey: string;
export declare let NSMetadataUbiquitousSharedItemPermissionsReadOnly: string;
export declare let NSMetadataUbiquitousSharedItemPermissionsReadWrite: string;
export declare let NSMetadataUbiquitousSharedItemRoleOwner: string;
export declare let NSMetadataUbiquitousSharedItemRoleParticipant: string;
export declare let NSNonOwnedPointerHashCallBacks: NSHashTableCallBacks;
export declare let NSNonOwnedPointerMapKeyCallBacks: NSMapTableKeyCallBacks;
export declare let NSNonOwnedPointerMapValueCallBacks: NSMapTableValueCallBacks;
export declare let NSNonOwnedPointerOrNullMapKeyCallBacks: NSMapTableKeyCallBacks;
export declare let NSNonRetainedObjectHashCallBacks: NSHashTableCallBacks;
export declare let NSNonRetainedObjectMapKeyCallBacks: NSMapTableKeyCallBacks;
export declare let NSNonRetainedObjectMapValueCallBacks: NSMapTableValueCallBacks;
export declare let NSNotFound: number;
export declare let NSNotificationDeliverImmediately: DistributedNotificationCenter.Options;
export declare let NSNotificationPostToAllSessions: DistributedNotificationCenter.Options;
export declare let NSOSStatusErrorDomain: string;
export declare let NSObjectHashCallBacks: NSHashTableCallBacks;
export declare let NSObjectMapKeyCallBacks: NSMapTableKeyCallBacks;
export declare let NSObjectMapValueCallBacks: NSMapTableValueCallBacks;
export declare let NSOperationNotSupportedForKeyException: string;
export declare let NSOwnedObjectIdentityHashCallBacks: NSHashTableCallBacks;
export declare let NSOwnedPointerHashCallBacks: NSHashTableCallBacks;
export declare let NSOwnedPointerMapKeyCallBacks: NSMapTableKeyCallBacks;
export declare let NSOwnedPointerMapValueCallBacks: NSMapTableValueCallBacks;
export declare let NSPOSIXErrorDomain: string;
export declare let NSPersonNameComponentDelimiter: string;
export declare let NSPersonNameComponentFamilyName: string;
export declare let NSPersonNameComponentGivenName: string;
export declare let NSPersonNameComponentKey: string;
export declare let NSPersonNameComponentMiddleName: string;
export declare let NSPersonNameComponentNickname: string;
export declare let NSPersonNameComponentPrefix: string;
export declare let NSPersonNameComponentSuffix: string;
export declare let NSPointerToStructHashCallBacks: NSHashTableCallBacks;
export declare let NSRecoveryAttempterErrorKey: string;
export declare let NSStreamSOCKSErrorDomain: string;
export declare let NSStreamSocketSSLErrorDomain: string;
export declare let NSStringEncodingErrorKey: string;
export declare let NSURLAuthenticationMethodClientCertificate: string;
export declare let NSURLAuthenticationMethodDefault: string;
export declare let NSURLAuthenticationMethodHTMLForm: string;
export declare let NSURLAuthenticationMethodHTTPBasic: string;
export declare let NSURLAuthenticationMethodHTTPDigest: string;
export declare let NSURLAuthenticationMethodNTLM: string;
export declare let NSURLAuthenticationMethodNegotiate: string;
export declare let NSURLAuthenticationMethodServerTrust: string;
export declare let NSURLCredentialStorageRemoveSynchronizableCredentials: string;
export declare let NSURLErrorBackgroundTaskCancelledReasonKey: string;
export declare let NSURLErrorDomain: string;
export declare let NSURLErrorFailingURLErrorKey: string;
export declare let NSURLErrorFailingURLPeerTrustErrorKey: string;
export declare let NSURLErrorFailingURLStringErrorKey: string;
export declare let NSURLErrorKey: string;
export declare let NSURLErrorNetworkUnavailableReasonKey: string;
export declare let NSURLFileScheme: string;
export declare let NSURLProtectionSpaceFTP: string;
export declare let NSURLProtectionSpaceFTPProxy: string;
export declare let NSURLProtectionSpaceHTTP: string;
export declare let NSURLProtectionSpaceHTTPProxy: string;
export declare let NSURLProtectionSpaceHTTPS: string;
export declare let NSURLProtectionSpaceHTTPSProxy: string;
export declare let NSURLProtectionSpaceSOCKSProxy: string;
export declare let NSURLSessionDownloadTaskResumeData: string;
export declare let NSURLSessionTransferSizeUnknown: number;
export declare let NSUbiquitousKeyValueStoreChangeReasonKey: string;
export declare let NSUbiquitousKeyValueStoreChangedKeysKey: string;
export declare let NSUnderlyingErrorKey: string;
export declare let NSUndoCloseGroupingRunLoopOrdering: number;
export declare let NSUndoManagerGroupIsDiscardableKey: string;
export declare let NSUserActivityTypeBrowsingWeb: string;
export declare let NSUserNotificationDefaultSoundName: string;
export declare let NSZeroPoint: CGPoint;
export declare let NSZeroRect: CGRect;
export declare let NSZeroSize: CGSize;
export declare let NSZombieEnabled: boolean;
export { Authorization, BlockOperation, Bundle, ByteCountFormatter, CFCalendarIdentifier, CFDateFormatterKey, CFLocaleKey, CFNotificationName, CFNumberFormatterKey, CFRunLoopMode, CFStreamPropertyKey, CachedURLResponse, DateComponentsFormatter, DateFormatter, DateIntervalFormatter, Dimension, DirectoryEnumerator, DistributedNotificationCenter, EnergyFormatter, FileAttributeKey, FileAttributeType, FileHandle, FileManager, FileManagerDelegate, FileProtectionType, FileWrapper, Formatter, HTTPCookie, HTTPCookiePropertyKey, HTTPCookieStorage, HTTPCookieStringPolicy, HTTPURLResponse, Host, ISO8601DateFormatter, InputStream, ItemResult, JSONSerialization, LengthFormatter, ListFormatter, MassFormatter, MeasurementFormatter, MessagePort, NSATSTypesetter, NSAccessibility, NSAccessibilityButton, NSAccessibilityCheckBox, NSAccessibilityContainsTransientUI, NSAccessibilityCustomAction, NSAccessibilityCustomRotor, NSAccessibilityCustomRotorItemSearchDelegate, NSAccessibilityElement, NSAccessibilityElementLoading, NSAccessibilityGroup, NSAccessibilityImage, NSAccessibilityLayoutArea, NSAccessibilityLayoutItem, NSAccessibilityList, NSAccessibilityNavigableStaticText, NSAccessibilityOutline, NSAccessibilityProgressIndicator, NSAccessibilityRadioButton, NSAccessibilityRow, NSAccessibilitySlider, NSAccessibilityStaticText, NSAccessibilityStepper, NSAccessibilitySwitch, NSAccessibilityTable, NSActionCell, NSAffineTransform, NSAlert, NSAlertDelegate, NSAlignmentFeedbackFilter, NSAlignmentFeedbackToken, NSAnimatablePropertyContainer, NSAnimation, NSAnimationContext, NSAnimationDelegate, NSAppKitVersion, NSAppearance, NSAppearanceCustomization, NSAppleEventDescriptor, NSAppleEventManager, NSAppleScript, NSApplication, NSApplicationDelegate, NSArray, NSArrayController, NSAssertionHandler, NSAttributedString, NSAutoreleasePool, NSBackgroundActivityScheduler, NSBezierPath, NSBindingInfoKey, NSBindingName, NSBindingOption, NSBindingSelectionMarker, NSBitmapImageRep, NSBox, NSBrowser, NSBrowserCell, NSBrowserDelegate, NSButton, NSButtonCell, NSButtonTouchBarItem, NSCIImageRep, NSCache, NSCacheDelegate, NSCalendar, NSCandidateListTouchBarItem, NSCandidateListTouchBarItemDelegate, NSCell, NSChangeSpelling, NSCharacterSet, NSClassDescription, NSClickGestureRecognizer, NSClipView, NSCloneCommand, NSCloseCommand, NSCloudSharingServiceDelegate, NSCloudSharingValidation, NSCoder, NSCoding, NSCollectionLayoutAnchor, NSCollectionLayoutBoundarySupplementaryItem, NSCollectionLayoutContainer, NSCollectionLayoutDecorationItem, NSCollectionLayoutDimension, NSCollectionLayoutEdgeSpacing, NSCollectionLayoutEnvironment, NSCollectionLayoutGroup, NSCollectionLayoutGroupCustomItem, NSCollectionLayoutItem, NSCollectionLayoutSection, NSCollectionLayoutSize, NSCollectionLayoutSpacing, NSCollectionLayoutSupplementaryItem, NSCollectionLayoutVisibleItem, NSCollectionView, NSCollectionViewCompositionalLayout, NSCollectionViewCompositionalLayoutConfiguration, NSCollectionViewDataSource, NSCollectionViewDelegate, NSCollectionViewDelegateFlowLayout, NSCollectionViewDiffableDataSourceReference, NSCollectionViewElement, NSCollectionViewFlowLayout, NSCollectionViewFlowLayoutInvalidationContext, NSCollectionViewGridLayout, NSCollectionViewItem, NSCollectionViewLayout, NSCollectionViewLayoutAttributes, NSCollectionViewLayoutInvalidationContext, NSCollectionViewPrefetching, NSCollectionViewSectionHeaderView, NSCollectionViewTransitionLayout, NSCollectionViewUpdateItem, NSColor, NSColorChanging, NSColorList, NSColorPanel, NSColorPicker, NSColorPickerTouchBarItem, NSColorPickingCustom, NSColorPickingDefault, NSColorSampler, NSColorSpace, NSColorSpaceName, NSColorWell, NSComboBox, NSComboBoxCell, NSComboBoxCellDataSource, NSComboBoxDataSource, NSComboBoxDelegate, NSComparisonPredicate, NSCompoundPredicate, NSCondition, NSConditionLock, NSControl, NSControlTextEditingDelegate, NSController, NSCopying, NSCountCommand, NSCountedSet, NSCreateCommand, NSCursor, NSCustomImageRep, NSCustomTouchBarItem, NSData, NSDataAsset, NSDataDetector, NSDate, NSDateComponents, NSDateInterval, NSDatePicker, NSDatePickerCell, NSDatePickerCellDelegate, NSDecimalNumber, NSDecimalNumberBehaviors, NSDecimalNumberHandler, NSDeleteCommand, NSDeviceDescriptionKey, NSDictionary, NSDictionaryController, NSDictionaryControllerKeyValuePair, NSDiffableDataSourceSnapshotReference, NSDiscardableContent, NSDistributedLock, NSDockTile, NSDockTilePlugIn, NSDocument, NSDocumentController, NSDraggingDestination, NSDraggingImageComponent, NSDraggingInfo, NSDraggingItem, NSDraggingSession, NSDraggingSource, NSDrawer, NSDrawerDelegate, NSEPSImageRep, NSEditor, NSEditorRegistration, NSEnumerator, NSError, NSEvent, NSException, NSExceptionName, NSExistsCommand, NSExpression, NSExtensionContext, NSExtensionItem, NSExtensionRequestHandling, NSFastEnumeration, NSFileAccessIntent, NSFileCoordinator, NSFilePresenter, NSFilePromiseProvider, NSFilePromiseProviderDelegate, NSFilePromiseReceiver, NSFileProviderService, NSFileSecurity, NSFileVersion, NSFont, NSFontAssetRequest, NSFontChanging, NSFontCollection, NSFontDescriptor, NSFontManager, NSFontPanel, NSFormCell, NSGestureRecognizer, NSGestureRecognizerDelegate, NSGetCommand, NSGlyphGenerator, NSGlyphInfo, NSGlyphStorage, NSGradient, NSGraphicsContext, NSGridCell, NSGridColumn, NSGridRow, NSGridView, NSGroupTouchBarItem, NSHapticFeedbackManager, NSHapticFeedbackPerformer, NSHashTable, NSHelpManager, NSIgnoreMisspelledWords, NSImage, NSImageCell, NSImageDelegate, NSImageRep, NSImageView, NSIndexPath, NSIndexSet, NSIndexSpecifier, NSInputServerMouseTracker, NSInputServiceProvider, NSItemProvider, NSItemProviderReading, NSItemProviderWriting, NSKeyValueChangeKey, NSKeyValueOperator, NSKeyedArchiver, NSKeyedArchiverDelegate, NSKeyedUnarchiver, NSKeyedUnarchiverDelegate, NSLayoutAnchor, NSLayoutConstraint, NSLayoutDimension, NSLayoutGuide, NSLayoutManager, NSLayoutManagerDelegate, NSLayoutXAxisAnchor, NSLayoutYAxisAnchor, NSLevelIndicator, NSLevelIndicatorCell, NSLinguisticTag, NSLinguisticTagScheme, NSLinguisticTagger, NSLocale, NSLock, NSLocking, NSLogicalTest, NSMachPort, NSMachPortDelegate, NSMagnificationGestureRecognizer, NSMapTable, NSMatrix, NSMatrixDelegate, NSMeasurement, NSMediaLibraryBrowserController, NSMenu, NSMenuDelegate, NSMenuItem, NSMenuItemCell, NSMenuItemValidation, NSMenuToolbarItem, NSMetadataItem, NSMetadataQuery, NSMetadataQueryAttributeValueTuple, NSMetadataQueryDelegate, NSMetadataQueryResultGroup, NSMiddleSpecifier, NSMoveCommand, NSMutableArray, NSMutableAttributedString, NSMutableCharacterSet, NSMutableCopying, NSMutableData, NSMutableDictionary, NSMutableFontCollection, NSMutableIndexSet, NSMutableOrderedSet, NSMutableParagraphStyle, NSMutableSet, NSMutableString, NSMutableURLRequest, NSNameSpecifier, NSNib, NSNotification, NSNull, NSNumber, NSObjectController, NSOpenPanel, NSOpenSavePanelDelegate, NSOrderedCollectionChange, NSOrderedCollectionDifference, NSOrderedSet, NSOrthography, NSOutlineView, NSOutlineViewDataSource, NSOutlineViewDelegate, NSPDFImageRep, NSPDFInfo, NSPDFPanel, NSPICTImageRep, NSPageController, NSPageControllerDelegate, NSPageLayout, NSPanGestureRecognizer, NSPanel, NSParagraphStyle, NSPasteboard, NSPasteboardItem, NSPasteboardItemDataProvider, NSPasteboardReading, NSPasteboardTypeOwner, NSPasteboardWriting, NSPathCell, NSPathCellDelegate, NSPathComponentCell, NSPathControl, NSPathControlDelegate, NSPathControlItem, NSPersistentDocument, NSPersonNameComponents, NSPickerTouchBarItem, NSPointerArray, NSPointerFunctions, NSPopUpButton, NSPopUpButtonCell, NSPopover, NSPopoverDelegate, NSPopoverTouchBarItem, NSPositionalSpecifier, NSPredicate, NSPredicateEditor, NSPredicateEditorRowTemplate, NSPressGestureRecognizer, NSPressureConfiguration, NSPrintInfo, NSPrintOperation, NSPrintPanel, NSPrintPanelAccessorizing, NSPrinter, NSProgressIndicator, NSPropertySpecifier, NSProtocolChecker, NSProxy, NSPurgeableData, NSQuitCommand, NSRandomSpecifier, NSRangeSpecifier, NSRecursiveLock, NSRegularExpression, NSRelativeSpecifier, NSResponder, NSRotationGestureRecognizer, NSRuleEditor, NSRuleEditorDelegate, NSRulerMarker, NSRulerView, NSRunningApplication, NSSavePanel, NSScreen, NSScriptClassDescription, NSScriptCoercionHandler, NSScriptCommand, NSScriptCommandDescription, NSScriptExecutionContext, NSScriptObjectSpecifier, NSScriptSuiteRegistry, NSScriptWhoseTest, NSScrollView, NSScroller, NSScrubber, NSScrubberArrangedView, NSScrubberDataSource, NSScrubberDelegate, NSScrubberFlowLayout, NSScrubberFlowLayoutDelegate, NSScrubberImageItemView, NSScrubberItemView, NSScrubberLayout, NSScrubberLayoutAttributes, NSScrubberProportionalLayout, NSScrubberSelectionStyle, NSScrubberSelectionView, NSScrubberTextItemView, NSSearchField, NSSearchFieldCell, NSSearchFieldDelegate, NSSecureCoding, NSSecureTextField, NSSecureTextFieldCell, NSSecureUnarchiveFromDataTransformer, NSSegmentedCell, NSSegmentedControl, NSSeguePerforming, NSServicesMenuRequestor, NSSet, NSSetCommand, NSShadow, NSSharingService, NSSharingServiceDelegate, NSSharingServicePicker, NSSharingServicePickerDelegate, NSSharingServicePickerToolbarItem, NSSharingServicePickerToolbarItemDelegate, NSSharingServicePickerTouchBarItem, NSSharingServicePickerTouchBarItemDelegate, NSSlider, NSSliderAccessory, NSSliderAccessoryBehavior, NSSliderCell, NSSliderTouchBarItem, NSSortDescriptor, NSSound, NSSoundDelegate, NSSpecifierTest, NSSpeechRecognizer, NSSpeechRecognizerDelegate, NSSpeechSynthesizer, NSSpeechSynthesizerDelegate, NSSpellChecker, NSSpellServer, NSSpellServerDelegate, NSSplitView, NSSplitViewController, NSSplitViewDelegate, NSSplitViewItem, NSSpringLoadingDestination, NSStackView, NSStackViewDelegate, NSStandardKeyBindingResponding, NSStatusBar, NSStatusBarButton, NSStatusItem, NSStepper, NSStepperCell, NSStepperTouchBarItem, NSStoryboard, NSStoryboardSegue, NSString, NSStringDrawingContext, NSSwitch, NSTabView, NSTabViewController, NSTabViewDelegate, NSTabViewItem, NSTableCellView, NSTableColumn, NSTableHeaderCell, NSTableHeaderView, NSTableRowView, NSTableView, NSTableViewDataSource, NSTableViewDelegate, NSTableViewRowAction, NSText, NSTextAlternatives, NSTextAttachment, NSTextAttachmentCell, NSTextAttachmentContainer, NSTextBlock, NSTextCheckingClient, NSTextCheckingController, NSTextCheckingKey, NSTextCheckingResult, NSTextContainer, NSTextDelegate, NSTextField, NSTextFieldCell, NSTextFieldDelegate, NSTextFinder, NSTextFinderBarContainer, NSTextFinderClient, NSTextInput, NSTextInputClient, NSTextInputContext, NSTextInputTraits, NSTextLayoutOrientationProvider, NSTextList, NSTextStorage, NSTextStorageDelegate, NSTextTab, NSTextTable, NSTextTableBlock, NSTextView, NSTextViewDelegate, NSTimeZone, NSTitlebarAccessoryViewController, NSTokenField, NSTokenFieldCell, NSTokenFieldCellDelegate, NSTokenFieldDelegate, NSToolbar, NSToolbarDelegate, NSToolbarItem, NSToolbarItemGroup, NSToolbarItemValidation, NSTouch, NSTouchBar, NSTouchBarDelegate, NSTouchBarItem, NSTouchBarProvider, NSTrackingArea, NSTreeController, NSTreeNode, NSTypesetter, NSURL, NSURLComponents, NSURLConnection, NSURLConnectionDataDelegate, NSURLConnectionDelegate, NSURLConnectionDownloadDelegate, NSURLDownload, NSURLDownloadDelegate, NSURLHandle, NSURLQueryItem, NSURLRequest, NSURLSessionWebSocketMessage, NSUUID, NSUbiquitousKeyValueStore, NSUniqueIDSpecifier, NSUnitInformationStorage, NSUserActivity, NSUserActivityDelegate, NSUserActivityRestoring, NSUserAppleScriptTask, NSUserAutomatorTask, NSUserDefaultsController, NSUserInterfaceCompression, NSUserInterfaceCompressionOptions, NSUserInterfaceItemIdentification, NSUserInterfaceItemSearching, NSUserInterfaceValidations, NSUserNotification, NSUserNotificationAction, NSUserNotificationCenter, NSUserNotificationCenterDelegate, NSUserScriptTask, NSUserUnixTask, NSValidatedUserInterfaceItem, NSValue, NSValueTransformerName, NSView, NSViewAnimation, NSViewController, NSViewControllerPresentationAnimator, NSViewLayerContentScaleDelegate, NSViewToolTipOwner, NSVisualEffectView, NSWhoseSpecifier, NSWindow, NSWindowController, NSWindowDelegate, NSWindowRestoration, NSWindowTab, NSWindowTabGroup, NSWorkspace, NSXPCCoder, NSXPCConnection, NSXPCInterface, NSXPCListener, NSXPCListenerDelegate, NSXPCListenerEndpoint, NSXPCProxyCreating, NetService, NetServiceBrowser, NetServiceBrowserDelegate, NetServiceDelegate, NotificationCenter, NotificationQueue, NumberFormatter, OpenConfiguration, Operation, OperationQueue, OutputStream, PersonNameComponentsFormatter, Pipe, Port, PortDelegate, PortMessage, Process, ProcessInfo, Progress, ProgressKind, ProgressReporting, ProgressUserInfoKey, PropertyListSerialization, RelativeDateTimeFormatter, RunLoop, Scanner, SearchParameters, SocketPort, Stream, StreamDelegate, StreamNetworkServiceTypeValue, StreamSOCKSProxyConfiguration, StreamSOCKSProxyVersion, StreamSocketSecurityLevel, StringEncodingDetectionOptionsKey, StringTransform, Thread, Timer, URLAuthenticationChallenge, URLAuthenticationChallengeSender, URLCache, URLCredential, URLCredentialStorage, URLFileProtection, URLFileResourceType, URLProtectionSpace, URLProtocol, URLProtocolClient, URLResourceKey, URLResponse, URLSession, URLSessionConfiguration, URLSessionDataDelegate, URLSessionDataTask, URLSessionDelegate, URLSessionDownloadDelegate, URLSessionDownloadTask, URLSessionStreamDelegate, URLSessionStreamTask, URLSessionTask, URLSessionTaskDelegate, URLSessionTaskMetrics, URLSessionTaskTransactionMetrics, URLSessionUploadTask, URLSessionWebSocketDelegate, URLSessionWebSocketTask, URLThumbnailDictionaryItem, URLUbiquitousItemDownloadingStatus, URLUbiquitousSharedItemPermissions, URLUbiquitousSharedItemRole, UndoManager, Unit, UnitAcceleration, UnitAngle, UnitArea, UnitConcentrationMass, UnitConverter, UnitConverterLinear, UnitDispersion, UnitDuration, UnitElectricCharge, UnitElectricCurrent, UnitElectricPotentialDifference, UnitElectricResistance, UnitEnergy, UnitFrequency, UnitFuelEfficiency, UnitIlluminance, UnitLength, UnitMass, UnitPower, UnitPressure, UnitSpeed, UnitTemperature, UnitVolume, UserDefaults, ValueTransformer, XMLDTD, XMLDTDNode, XMLDocument, XMLElement, XMLNode, XMLParser, XMLParserDelegate, };
