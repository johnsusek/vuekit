declare global {
    class AVAsset extends NSObject {
        allMediaSelections: AVMediaSelection[];
        availableChapterLocales: NSLocale[];
        availableMediaCharacteristicsWithMediaSelectionOptions: string[];
        availableMetadataFormats: string[];
        canContainFragments: boolean;
        commonMetadata: AVMetadataItem[];
        isCompatibleWithAirPlayVideo: boolean;
        isComposable: boolean;
        containsFragments: boolean;
        creationDate: AVMetadataItem;
        duration: CMTime;
        isExportable: boolean;
        hasProtectedContent: boolean;
        lyrics: string;
        metadata: AVMetadataItem[];
        minimumTimeOffsetFromLive: CMTime;
        overallDurationHint: CMTime;
        isPlayable: boolean;
        preferredMediaSelection: AVMediaSelection;
        preferredRate: number;
        preferredTransform: CGAffineTransform;
        preferredVolume: number;
        providesPreciseDurationAndTiming: boolean;
        isReadable: boolean;
        referenceRestrictions: AVAssetReferenceRestrictions;
        trackGroups: AVAssetTrackGroup[];
        tracks: AVAssetTrack[];
        cancelLoading(): void;
        chapterMetadataGroupsBestMatchingPreferredLanguages(bestMatchingPreferredLanguages: string[]): AVTimedMetadataGroup[];
        chapterMetadataGroupsWithTitleLocaleContainingItemsWithCommonKeys(withTitleLocale: NSLocale, containingItemsWithCommonKeys?: string[]): AVTimedMetadataGroup[];
        mediaSelectionGroupForMediaCharacteristic(forMediaCharacteristic: string): AVMediaSelectionGroup;
        metadataForFormat(forFormat: string): AVMetadataItem[];
        trackWithTrackID(withTrackID: number): AVAssetTrack;
        tracksWithMediaCharacteristic(withMediaCharacteristic: string): AVAssetTrack[];
        tracksWithMediaType(withMediaType: string): AVAssetTrack[];
        unusedTrackID(): number;
    }
    class AVAssetCache extends NSObject {
        isPlayableOffline: boolean;
        mediaSelectionOptionsInMediaSelectionGroup(in_: AVMediaSelectionGroup): AVMediaSelectionOption[];
    }
    class AVAssetExportSession extends NSObject {
        static allExportPresets(): string[];
        static determineCompatibilityWithOfExportPresetWithOutputFileTypeCompletionHandler(ofExportPreset: string, with_: AVAsset, outputFileType?: string, completionHandler?: (p1: boolean) => void): void;
        static exportPresetsCompatibleWithAsset(compatibleWith: AVAsset): string[];
        asset: AVAsset;
        audioMix: AVAudioMix;
        setAudioMix(_: AVAudioMix): any;
        audioTimePitchAlgorithm: string;
        setAudioTimePitchAlgorithm(_: string): any;
        canPerformMultiplePassesOverSourceMediaData: boolean;
        setCanPerformMultiplePassesOverSourceMediaData(_: boolean): any;
        customVideoCompositor: AVVideoCompositing;
        directoryForTemporaryFiles: NSURL;
        setDirectoryForTemporaryFiles(_: NSURL): any;
        error: NSError;
        estimatedOutputFileLength: number;
        fileLengthLimit: number;
        setFileLengthLimit(_: number): any;
        maxDuration: CMTime;
        metadata: AVMetadataItem[];
        setMetadata(_: AVMetadataItem[]): any;
        metadataItemFilter: AVMetadataItemFilter;
        setMetadataItemFilter(_: AVMetadataItemFilter): any;
        outputFileType: string;
        setOutputFileType(_: string): any;
        outputURL: NSURL;
        setOutputURL(_: NSURL): any;
        presetName: string;
        progress: number;
        shouldOptimizeForNetworkUse: boolean;
        setShouldOptimizeForNetworkUse(_: boolean): any;
        status: AVAssetExportSession.Status;
        supportedFileTypes: string[];
        timeRange: CMTimeRange;
        setTimeRange(_: CMTimeRange): any;
        videoComposition: AVVideoComposition;
        setVideoComposition(_: AVVideoComposition): any;
        cancelExport(): void;
        determineCompatibleFileTypesWithCompletionHandler(completionHandler: (p1: string[]) => void): void;
        estimateMaximumDurationWithCompletionHandler(completionHandler?: (p1: CMTime, p2: NSError) => void): void;
        estimateOutputFileLengthWithCompletionHandler(completionHandler?: (p1: number, p2: NSError) => void): void;
        exportAsynchronouslyWithCompletionHandler(completionHandler: () => void): void;
        static createWithAssetPresetName(asset: AVAsset, presetName: string): AVAssetExportSession;
    }
    class AVAssetImageGenerator extends NSObject {
        apertureMode: string;
        setApertureMode(_: string): any;
        appliesPreferredTrackTransform: boolean;
        setAppliesPreferredTrackTransform(_: boolean): any;
        asset: AVAsset;
        customVideoCompositor: AVVideoCompositing;
        maximumSize: CGSize;
        setMaximumSize(_: CGSize): any;
        requestedTimeToleranceAfter: CMTime;
        setRequestedTimeToleranceAfter(_: CMTime): any;
        requestedTimeToleranceBefore: CMTime;
        setRequestedTimeToleranceBefore(_: CMTime): any;
        videoComposition: AVVideoComposition;
        setVideoComposition(_: AVVideoComposition): any;
        cancelAllCGImageGeneration(): void;
        copyCGImageAtTimeActualTimeError(actualTime: CMTime, error?: CMTime): any;
        generateCGImagesAsynchronouslyWithForTimesCompletionHandler(forTimes: NSValue[], completionHandler: (p1: CMTime, p2: any, p3: CMTime, p4: AVAssetImageGenerator.Result, p5: NSError) => void): void;
        static createWithAsset(asset: AVAsset): AVAssetImageGenerator;
    }
    class AVAssetReader extends NSObject {
        static assetReaderWithAssetError(error: AVAsset): AVAssetReader;
        asset: AVAsset;
        error: NSError;
        outputs: AVAssetReaderOutput[];
        status: AVAssetReader.Status;
        timeRange: CMTimeRange;
        setTimeRange(_: CMTimeRange): any;
        addOutput(_: AVAssetReaderOutput): void;
        canAddOutput(_: AVAssetReaderOutput): boolean;
        cancelReading(): void;
        static createWithAsset(asset: AVAsset): AVAssetReader;
        startReading(): boolean;
    }
    class AVAssetReaderAudioMixOutput extends AVAssetReaderOutput {
        static assetReaderAudioMixOutputWithAudioTracksAudioSettings(audioTracks: AVAssetTrack[], audioSettings?: Map<string, any>): AVAssetReaderAudioMixOutput;
        audioMix: AVAudioMix;
        setAudioMix(_: AVAudioMix): any;
        audioSettings: Map<string, any>;
        audioTimePitchAlgorithm: string;
        setAudioTimePitchAlgorithm(_: string): any;
        audioTracks: AVAssetTrack[];
        static createWithAudioTracksAudioSettings(audioTracks: AVAssetTrack[], audioSettings?: Map<string, any>): AVAssetReaderAudioMixOutput;
    }
    class AVAssetReaderOutput extends NSObject {
        alwaysCopiesSampleData: boolean;
        setAlwaysCopiesSampleData(_: boolean): any;
        mediaType: string;
        supportsRandomAccess: boolean;
        setSupportsRandomAccess(_: boolean): any;
        copyNextSampleBuffer(): any;
        markConfigurationAsFinal(): void;
        resetForReadingTimeRanges(forReadingTimeRanges: NSValue[]): void;
    }
    class AVAssetReaderOutputMetadataAdaptor extends NSObject {
        static assetReaderOutputMetadataAdaptorWithAssetReaderTrackOutput(assetReaderTrackOutput: AVAssetReaderTrackOutput): AVAssetReaderOutputMetadataAdaptor;
        assetReaderTrackOutput: AVAssetReaderTrackOutput;
        static createWithAssetReaderTrackOutput(assetReaderTrackOutput: AVAssetReaderTrackOutput): AVAssetReaderOutputMetadataAdaptor;
        nextTimedMetadataGroup(): AVTimedMetadataGroup;
    }
    class AVAssetReaderSampleReferenceOutput extends AVAssetReaderOutput {
        static assetReaderSampleReferenceOutputWithTrack(track: AVAssetTrack): AVAssetReaderSampleReferenceOutput;
        track: AVAssetTrack;
        static createWithTrack(track: AVAssetTrack): AVAssetReaderSampleReferenceOutput;
    }
    class AVAssetReaderTrackOutput extends AVAssetReaderOutput {
        static assetReaderTrackOutputWithTrackOutputSettings(track: AVAssetTrack, outputSettings?: Map<string, any>): AVAssetReaderTrackOutput;
        audioTimePitchAlgorithm: string;
        setAudioTimePitchAlgorithm(_: string): any;
        outputSettings: Map<string, any>;
        track: AVAssetTrack;
        static createWithTrackOutputSettings(track: AVAssetTrack, outputSettings?: Map<string, any>): AVAssetReaderTrackOutput;
    }
    class AVAssetReaderVideoCompositionOutput extends AVAssetReaderOutput {
        static assetReaderVideoCompositionOutputWithVideoTracksVideoSettings(videoTracks: AVAssetTrack[], videoSettings?: Map<string, any>): AVAssetReaderVideoCompositionOutput;
        customVideoCompositor: AVVideoCompositing;
        videoComposition: AVVideoComposition;
        setVideoComposition(_: AVVideoComposition): any;
        videoSettings: Map<string, any>;
        videoTracks: AVAssetTrack[];
        static createWithVideoTracksVideoSettings(videoTracks: AVAssetTrack[], videoSettings?: Map<string, any>): AVAssetReaderVideoCompositionOutput;
    }
    class AVAssetResourceLoader extends NSObject {
        delegate: AVAssetResourceLoaderDelegate;
        delegateQueue: NSObject;
        preloadsEligibleContentKeys: boolean;
        setPreloadsEligibleContentKeys(_: boolean): any;
        setDelegateQueue(_?: AVAssetResourceLoaderDelegate, queue?: NSObject): void;
    }
    interface AVAssetResourceLoaderDelegate extends NSObject {
        resourceLoaderDidCancelLoadingRequest?(_: AVAssetResourceLoader, didCancel: AVAssetResourceLoadingRequest): void;
        resourceLoaderShouldWaitForResponseToAuthenticationChallenge?(_: AVAssetResourceLoader, shouldWaitForResponseTo: URLAuthenticationChallenge): boolean;
        resourceLoaderDidCancelAuthenticationChallenge?(_: AVAssetResourceLoader, didCancel: URLAuthenticationChallenge): void;
        resourceLoaderShouldWaitForLoadingOfRequestedResource?(_: AVAssetResourceLoader, shouldWaitForLoadingOfRequestedResource: AVAssetResourceLoadingRequest): boolean;
        resourceLoaderShouldWaitForRenewalOfRequestedResource?(_: AVAssetResourceLoader, shouldWaitForRenewalOfRequestedResource: AVAssetResourceRenewalRequest): boolean;
    }
    class AVAssetResourceLoadingContentInformationRequest extends NSObject {
        allowedContentTypes: string[];
        isByteRangeAccessSupported: boolean;
        setByteRangeAccessSupported(_: boolean): any;
        contentLength: number;
        setContentLength(_: number): any;
        contentType: string;
        setContentType(_: string): any;
        renewalDate: Date;
        setRenewalDate(_: Date): any;
    }
    class AVAssetResourceLoadingDataRequest extends NSObject {
        currentOffset: number;
        requestedLength: number;
        requestedOffset: number;
        requestsAllDataToEndOfResource: boolean;
        respondWithData(with_: NSData): void;
    }
    class AVAssetResourceLoadingRequest extends NSObject {
        isCancelled: boolean;
        contentInformationRequest: AVAssetResourceLoadingContentInformationRequest;
        dataRequest: AVAssetResourceLoadingDataRequest;
        isFinished: boolean;
        redirect: NSURLRequest;
        setRedirect(_: NSURLRequest): any;
        request: NSURLRequest;
        requestor: AVAssetResourceLoadingRequestor;
        response: URLResponse;
        setResponse(_: URLResponse): any;
        finishLoading(): void;
        finishLoadingWithError(with_?: NSError): void;
        persistentContentKeyFromKeyVendorResponseOptionsError(options: NSData, error?: Map<string, any>): NSData;
        streamingContentKeyRequestDataForAppContentIdentifierOptionsError(contentIdentifier: NSData, options: NSData, error?: Map<string, any>): NSData;
    }
    class AVAssetResourceLoadingRequestor extends NSObject {
        providesExpiredSessionReports: boolean;
    }
    class AVAssetResourceRenewalRequest extends AVAssetResourceLoadingRequest {
    }
    class AVAssetTrack extends NSObject {
        asset: AVAsset;
        availableMetadataFormats: string[];
        availableTrackAssociationTypes: string[];
        canProvideSampleCursors: boolean;
        commonMetadata: AVMetadataItem[];
        isDecodable: boolean;
        isEnabled: boolean;
        estimatedDataRate: number;
        extendedLanguageTag: string;
        formatDescriptions: any[];
        hasAudioSampleDependencies: boolean;
        languageCode: string;
        mediaType: string;
        metadata: AVMetadataItem[];
        minFrameDuration: CMTime;
        naturalSize: CGSize;
        naturalTimeScale: number;
        nominalFrameRate: number;
        isPlayable: boolean;
        preferredTransform: CGAffineTransform;
        preferredVolume: number;
        requiresFrameReordering: boolean;
        segments: AVAssetTrackSegment[];
        isSelfContained: boolean;
        timeRange: CMTimeRange;
        totalSampleDataLength: number;
        trackID: number;
        associatedTracksOfType(ofType: string): AVAssetTrack[];
        hasMediaCharacteristic(_: string): boolean;
        makeSampleCursorAtFirstSampleInDecodeOrder(): AVSampleCursor;
        makeSampleCursorAtLastSampleInDecodeOrder(): AVSampleCursor;
        makeSampleCursorWithPresentationTimeStamp(presentationTimeStamp: CMTime): AVSampleCursor;
        metadataForFormat(forFormat: string): AVMetadataItem[];
        samplePresentationTimeForTrackTime(forTrackTime: CMTime): CMTime;
        segmentForTrackTime(forTrackTime: CMTime): AVAssetTrackSegment;
    }
    class AVAssetTrackGroup extends NSObject {
        trackIDs: number[];
    }
    class AVAssetTrackSegment extends NSObject {
        isEmpty: boolean;
        timeMapping: CMTimeMapping;
    }
    class AVAssetWriter extends NSObject {
        static assetWriterWithURLFileTypeError(fileType: NSURL, error: string): AVAssetWriter;
        availableMediaTypes: string[];
        directoryForTemporaryFiles: NSURL;
        setDirectoryForTemporaryFiles(_: NSURL): any;
        error: NSError;
        inputGroups: AVAssetWriterInputGroup[];
        inputs: AVAssetWriterInput[];
        metadata: AVMetadataItem[];
        setMetadata(_: AVMetadataItem[]): any;
        movieFragmentInterval: CMTime;
        setMovieFragmentInterval(_: CMTime): any;
        movieTimeScale: number;
        setMovieTimeScale(_: number): any;
        outputFileType: string;
        outputURL: NSURL;
        overallDurationHint: CMTime;
        setOverallDurationHint(_: CMTime): any;
        shouldOptimizeForNetworkUse: boolean;
        setShouldOptimizeForNetworkUse(_: boolean): any;
        status: AVAssetWriter.Status;
        addInput(_: AVAssetWriterInput): void;
        addInputGroup(_: AVAssetWriterInputGroup): void;
        canAddInput(_: AVAssetWriterInput): boolean;
        canAddInputGroup(_: AVAssetWriterInputGroup): boolean;
        canApplyOutputSettingsForMediaType(outputSettings?: Map<string, any>, forMediaType?: string): boolean;
        cancelWriting(): void;
        endSessionAtSourceTime(atSourceTime: CMTime): void;
        finishWritingWithCompletionHandler(completionHandler: () => void): void;
        static createWithUrlFileType(URL: NSURL, fileType: string): AVAssetWriter;
        startSessionAtSourceTime(atSourceTime: CMTime): void;
        startWriting(): boolean;
    }
    class AVAssetWriterInput extends NSObject {
        canPerformMultiplePasses: boolean;
        currentPassDescription: AVAssetWriterInputPassDescription;
        expectsMediaDataInRealTime: boolean;
        setExpectsMediaDataInRealTime(_: boolean): any;
        extendedLanguageTag: string;
        setExtendedLanguageTag(_: string): any;
        languageCode: string;
        setLanguageCode(_: string): any;
        marksOutputTrackAsEnabled: boolean;
        setMarksOutputTrackAsEnabled(_: boolean): any;
        mediaDataLocation: string;
        setMediaDataLocation(_: string): any;
        mediaTimeScale: number;
        setMediaTimeScale(_: number): any;
        mediaType: string;
        metadata: AVMetadataItem[];
        setMetadata(_: AVMetadataItem[]): any;
        naturalSize: CGSize;
        setNaturalSize(_: CGSize): any;
        outputSettings: Map<string, any>;
        performsMultiPassEncodingIfSupported: boolean;
        setPerformsMultiPassEncodingIfSupported(_: boolean): any;
        preferredMediaChunkAlignment: number;
        setPreferredMediaChunkAlignment(_: number): any;
        preferredMediaChunkDuration: CMTime;
        setPreferredMediaChunkDuration(_: CMTime): any;
        preferredVolume: number;
        setPreferredVolume(_: number): any;
        isReadyForMoreMediaData: boolean;
        sampleReferenceBaseURL: NSURL;
        setSampleReferenceBaseURL(_: NSURL): any;
        sourceFormatHint: any;
        transform: CGAffineTransform;
        setTransform(_: CGAffineTransform): any;
        addTrackAssociationWithTrackOfInputType(withTrackOf: AVAssetWriterInput, type: string): void;
        appendSampleBuffer(_: any): boolean;
        canAddTrackAssociationWithTrackOfInputType(withTrackOf: AVAssetWriterInput, type: string): boolean;
        static createWithMediaTypeOutputSettings(mediaType: string, outputSettings?: Map<string, any>): AVAssetWriterInput;
        static createWithMediaTypeOutputSettingsSourceFormatHint(mediaType: string, outputSettings?: Map<string, any>, sourceFormatHint?: any): AVAssetWriterInput;
        markAsFinished(): void;
        markCurrentPassAsFinished(): void;
        requestMediaDataWhenReadyWithOnUsing(on: NSObject, using: () => void): void;
        respondToEachPassDescriptionWithOnUsing(on: NSObject, using: () => void): void;
    }
    class AVAssetWriterInputGroup extends AVMediaSelectionGroup {
        static assetWriterInputGroupWithInputsDefaultInput(inputs: AVAssetWriterInput[], defaultInput?: AVAssetWriterInput): AVAssetWriterInputGroup;
        defaultInput: AVAssetWriterInput;
        inputs: AVAssetWriterInput[];
        static createWithInputsDefaultInput(inputs: AVAssetWriterInput[], defaultInput?: AVAssetWriterInput): AVAssetWriterInputGroup;
    }
    class AVAssetWriterInputMetadataAdaptor extends NSObject {
        static assetWriterInputMetadataAdaptorWithAssetWriterInput(assetWriterInput: AVAssetWriterInput): AVAssetWriterInputMetadataAdaptor;
        assetWriterInput: AVAssetWriterInput;
        appendTimedMetadataGroup(_: AVTimedMetadataGroup): boolean;
        static createWithAssetWriterInput(assetWriterInput: AVAssetWriterInput): AVAssetWriterInputMetadataAdaptor;
    }
    class AVAssetWriterInputPassDescription extends NSObject {
        sourceTimeRanges: NSValue[];
    }
    class AVAssetWriterInputPixelBufferAdaptor extends NSObject {
        static assetWriterInputPixelBufferAdaptorWithAssetWriterInputSourcePixelBufferAttributes(assetWriterInput: AVAssetWriterInput, sourcePixelBufferAttributes?: Map<string, any>): AVAssetWriterInputPixelBufferAdaptor;
        assetWriterInput: AVAssetWriterInput;
        pixelBufferPool: any;
        sourcePixelBufferAttributes: Map<string, any>;
        appendPixelBufferWithPresentationTime(_: any, withPresentationTime: CMTime): boolean;
        static createWithAssetWriterInputSourcePixelBufferAttributes(assetWriterInput: AVAssetWriterInput, sourcePixelBufferAttributes?: Map<string, any>): AVAssetWriterInputPixelBufferAdaptor;
    }
    class AVAsynchronousCIImageFilteringRequest extends NSObject {
        compositionTime: CMTime;
        renderSize: CGSize;
        sourceImage: CIImage;
        finishWithError(with_: NSError): void;
        finishWithImageContext(with_: CIImage, context?: CIContext): void;
    }
    interface AVAsynchronousKeyValueLoading {
        loadValuesAsynchronouslyWithForKeysCompletionHandler(forKeys: string[], completionHandler?: () => void): void;
        statusOfValueForKeyError(forKey: string): AVKeyValueStatus;
    }
    class AVAsynchronousVideoCompositionRequest extends NSObject {
        compositionTime: CMTime;
        renderContext: AVVideoCompositionRenderContext;
        sourceTrackIDs: number[];
        videoCompositionInstruction: AVVideoCompositionInstruction;
        finishCancelledRequest(): void;
        finishWithComposedVideoFrame(withComposedVideoFrame: any): void;
        finishWithError(with_: NSError): void;
        sourceFrameByTrackID(byTrackID: number): any;
    }
    interface AVAudio3DMixing extends NSObject {
        obstruction: number;
        setObstruction(_: number): any;
        occlusion: number;
        setOcclusion(_: number): any;
        pointSourceInHeadMode: AVAudio3DMixingPointSourceInHeadMode;
        setPointSourceInHeadMode(_: AVAudio3DMixingPointSourceInHeadMode): any;
        rate: number;
        setRate(_: number): any;
        renderingAlgorithm: AVAudio3DMixingRenderingAlgorithm;
        setRenderingAlgorithm(_: AVAudio3DMixingRenderingAlgorithm): any;
        reverbBlend: number;
        setReverbBlend(_: number): any;
        sourceMode: AVAudio3DMixingSourceMode;
        setSourceMode(_: AVAudio3DMixingSourceMode): any;
    }
    class AVAudioBuffer extends NSObject {
        audioBufferList: AudioBufferList;
        format: AVAudioFormat;
        mutableAudioBufferList: AudioBufferList;
    }
    class AVAudioChannelLayout extends NSObject {
        channelCount: number;
        layout: AudioChannelLayout;
        layoutTag: number;
        static createWithLayout(layout: AudioChannelLayout): AVAudioChannelLayout;
        static createWithLayoutTag(layoutTag: number): AVAudioChannelLayout;
    }
    class AVAudioCompressedBuffer extends AVAudioBuffer {
        byteCapacity: number;
        byteLength: number;
        setByteLength(_: number): any;
        data: any;
        maximumPacketSize: number;
        packetCapacity: number;
        packetCount: number;
        setPacketCount(_: number): any;
        packetDescriptions: AudioStreamPacketDescription;
        static createWithFormatPacketCapacity(format: AVAudioFormat, packetCapacity: number): AVAudioCompressedBuffer;
        static createWithFormatPacketCapacityMaximumPacketSize(format: AVAudioFormat, packetCapacity: number, maximumPacketSize: number): AVAudioCompressedBuffer;
    }
    class AVAudioConnectionPoint extends NSObject {
        bus: number;
        node: AVAudioNode;
        static createWithNodeBus(node: AVAudioNode, bus: number): AVAudioConnectionPoint;
    }
    class AVAudioConverter extends NSObject {
        applicableEncodeBitRates: number[];
        applicableEncodeSampleRates: number[];
        availableEncodeBitRates: number[];
        availableEncodeChannelLayoutTags: number[];
        availableEncodeSampleRates: number[];
        bitRate: number;
        setBitRate(_: number): any;
        bitRateStrategy: string;
        setBitRateStrategy(_: string): any;
        channelMap: number[];
        setChannelMap(_: number[]): any;
        dither: boolean;
        setDither(_: boolean): any;
        downmix: boolean;
        setDownmix(_: boolean): any;
        inputFormat: AVAudioFormat;
        magicCookie: NSData;
        setMagicCookie(_: NSData): any;
        maximumOutputPacketSize: number;
        outputFormat: AVAudioFormat;
        primeInfo: AVAudioConverter;
        setPrimeInfo(_: AVAudioConverter): any;
        primeMethod: AVAudioConverterPrimeMethod;
        setPrimeMethod(_: AVAudioConverterPrimeMethod): any;
        sampleRateConverterAlgorithm: string;
        setSampleRateConverterAlgorithm(_: string): any;
        sampleRateConverterQuality: number;
        setSampleRateConverterQuality(_: number): any;
        convertWithToErrorWithInputFrom(to: AVAudioBuffer, error?: Error, withInputFrom?: (p1: number, p2: AVAudioConverterInputStatus) => AVAudioBuffer): AVAudioConverterOutputStatus;
        convertToBufferFromBufferError(fromBuffer: AVAudioPCMBuffer, error: AVAudioPCMBuffer): boolean;
        static createWithFromFormatToFormat(fromFormat: AVAudioFormat, toFormat: AVAudioFormat): AVAudioConverter;
        reset(): void;
    }
    class AVAudioEngine extends NSObject {
        attachedNodes: NSSet<AVAudioNode>;
        isAutoShutdownEnabled: boolean;
        setAutoShutdownEnabled(_: boolean): any;
        inputNode: AVAudioInputNode;
        isInManualRenderingMode: boolean;
        mainMixerNode: AVAudioMixerNode;
        manualRenderingBlock: (p1: number, p2: AudioBufferList, p3: number) => AVAudioEngineManualRenderingStatus;
        manualRenderingFormat: AVAudioFormat;
        manualRenderingMaximumFrameCount: number;
        manualRenderingMode: AVAudioEngineManualRenderingMode;
        manualRenderingSampleTime: number;
        musicSequence: any;
        setMusicSequence(_: any): any;
        outputNode: AVAudioOutputNode;
        isRunning: boolean;
        attachNode(_: AVAudioNode): void;
        connectToFormat(_: AVAudioNode, to: AVAudioNode, format?: AVAudioFormat): void;
        connectToFromBusToBusFormat(_: AVAudioNode, to: AVAudioNode, fromBus: number, toBus: number, format?: AVAudioFormat): void;
        connectToConnectionPointsFromBusFormat(_: AVAudioNode, to: AVAudioConnectionPoint[], fromBus: number, format?: AVAudioFormat): void;
        connectMIDIWithToFormatBlock(_: AVAudioNode, to: AVAudioNode, format?: AVAudioFormat, block?: (p1: number, p2: number, p3: number, p4: string) => number): void;
        connectMIDIToFormatBlock(_: AVAudioNode, to: AVAudioNode[], format?: AVAudioFormat, block?: (p1: number, p2: number, p3: number, p4: string) => number): void;
        detachNode(_: AVAudioNode): void;
        disableManualRenderingMode(): void;
        disconnectMIDIFrom(_: AVAudioNode, from: AVAudioNode): void;
        disconnectMIDIFromNodes(_: AVAudioNode, from: AVAudioNode[]): void;
        disconnectMIDIInput(_: AVAudioNode): void;
        disconnectMIDIOutput(_: AVAudioNode): void;
        disconnectNodeInput(_: AVAudioNode): void;
        disconnectNodeInputBus(_: AVAudioNode, bus: number): void;
        disconnectNodeOutput(_: AVAudioNode): void;
        disconnectNodeOutputBus(_: AVAudioNode, bus: number): void;
        enableManualRenderingModeFormatMaximumFrameCountError(format: AVAudioEngineManualRenderingMode, maximumFrameCount: AVAudioFormat, error: number): boolean;
        inputConnectionPointForNodeInputBus(for_: AVAudioNode, inputBus: number): AVAudioConnectionPoint;
        outputConnectionPointsForNodeOutputBus(for_: AVAudioNode, outputBus: number): AVAudioConnectionPoint[];
        pause(): void;
        prepare(): void;
        renderOfflineToBufferError(toBuffer: number, error: AVAudioPCMBuffer): AVAudioEngineManualRenderingStatus;
        reset(): void;
        startAndReturnError(): boolean;
        stop(): void;
    }
    class AVAudioEnvironmentDistanceAttenuationParameters extends NSObject {
        distanceAttenuationModel: AVAudioEnvironmentDistanceAttenuationModel;
        setDistanceAttenuationModel(_: AVAudioEnvironmentDistanceAttenuationModel): any;
        maximumDistance: number;
        setMaximumDistance(_: number): any;
        referenceDistance: number;
        setReferenceDistance(_: number): any;
        rolloffFactor: number;
        setRolloffFactor(_: number): any;
    }
    class AVAudioEnvironmentNode extends AVAudioNode {
        applicableRenderingAlgorithms: number[];
        distanceAttenuationParameters: AVAudioEnvironmentDistanceAttenuationParameters;
        nextAvailableInputBus: number;
        outputType: AVAudioEnvironmentOutputType;
        setOutputType(_: AVAudioEnvironmentOutputType): any;
        outputVolume: number;
        setOutputVolume(_: number): any;
        reverbParameters: AVAudioEnvironmentReverbParameters;
    }
    class AVAudioEnvironmentReverbParameters extends NSObject {
        enable: boolean;
        setEnable(_: boolean): any;
        filterParameters: AVAudioUnitEQFilterParameters;
        level: number;
        setLevel(_: number): any;
        loadFactoryReverbPreset(_: AVAudioUnitReverbPreset): void;
    }
    class AVAudioFile extends NSObject {
        fileFormat: AVAudioFormat;
        framePosition: number;
        setFramePosition(_: number): any;
        length: number;
        processingFormat: AVAudioFormat;
        url: NSURL;
        static createWithForReadingCommonFormatInterleaved(forReading: NSURL, commonFormat: AVAudioCommonFormat, interleaved: boolean): AVAudioFile;
        static createWithForReading(forReading: NSURL): AVAudioFile;
        static createWithForWritingSettingsCommonFormatInterleaved(forWriting: NSURL, settings: Map<string, any>, commonFormat: AVAudioCommonFormat, interleaved: boolean): AVAudioFile;
        static createWithForWritingSettings(forWriting: NSURL, settings: Map<string, any>): AVAudioFile;
        readIntoBufferError(error: AVAudioPCMBuffer): boolean;
        readIntoBufferFrameCountError(frameCount: AVAudioPCMBuffer, error: number): boolean;
        writeFromBufferError(error: AVAudioPCMBuffer): boolean;
    }
    class AVAudioFormat extends NSObject {
        channelCount: number;
        channelLayout: AVAudioChannelLayout;
        commonFormat: AVAudioCommonFormat;
        formatDescription: any;
        isInterleaved: boolean;
        magicCookie: NSData;
        setMagicCookie(_: NSData): any;
        sampleRate: number;
        settings: Map<string, any>;
        isStandard: boolean;
        streamDescription: AudioStreamBasicDescription;
        static createWithStandardFormatWithSampleRateChannelLayout(standardFormatWithSampleRate: number, channelLayout: AVAudioChannelLayout): AVAudioFormat;
        static createWithStandardFormatWithSampleRateChannels(standardFormatWithSampleRate: number, channels: number): AVAudioFormat;
        static createWithCMAudioFormatDescription(CMAudioFormatDescription: any): AVAudioFormat;
        static createWithCommonFormatSampleRateChannelsInterleaved(commonFormat: AVAudioCommonFormat, sampleRate: number, channels: number, interleaved: boolean): AVAudioFormat;
        static createWithCommonFormatSampleRateInterleavedChannelLayout(commonFormat: AVAudioCommonFormat, sampleRate: number, interleaved: boolean, channelLayout: AVAudioChannelLayout): AVAudioFormat;
        static createWithSettings(settings: Map<string, any>): AVAudioFormat;
        static createWithStreamDescription(streamDescription: AudioStreamBasicDescription): AVAudioFormat;
        static createWithStreamDescriptionChannelLayout(streamDescription: AudioStreamBasicDescription, channelLayout?: AVAudioChannelLayout): AVAudioFormat;
    }
    class AVAudioIONode extends AVAudioNode {
        presentationLatency: number;
        isVoiceProcessingEnabled: boolean;
        setVoiceProcessingEnabledError(error: boolean): boolean;
    }
    class AVAudioInputNode extends AVAudioIONode {
        isVoiceProcessingAGCEnabled: boolean;
        setVoiceProcessingAGCEnabled(_: boolean): any;
        isVoiceProcessingBypassed: boolean;
        setVoiceProcessingBypassed(_: boolean): any;
        isVoiceProcessingInputMuted: boolean;
        setVoiceProcessingInputMuted(_: boolean): any;
        setManualRenderingInputPCMFormatWithInputBlock(_: AVAudioFormat, inputBlock: (p1: number) => AudioBufferList): boolean;
    }
    class AVAudioMix extends NSObject {
        inputParameters: AVAudioMixInputParameters[];
    }
    class AVAudioMixInputParameters extends NSObject {
        audioTapProcessor: any;
        audioTimePitchAlgorithm: string;
        trackID: number;
        getVolumeRampForTimeStartVolumeEndVolumeTimeRange(for_: CMTime, startVolume?: number, endVolume?: number, timeRange?: CMTimeRange): boolean;
    }
    class AVAudioMixerNode extends AVAudioNode {
        nextAvailableInputBus: number;
        outputVolume: number;
        setOutputVolume(_: number): any;
    }
    interface AVAudioMixing extends AVAudio3DMixing, AVAudioStereoMixing {
        volume: number;
        setVolume(_: number): any;
        destinationForMixerBus(forMixer: AVAudioNode, bus: number): AVAudioMixingDestination;
    }
    class AVAudioMixingDestination extends NSObject {
        connectionPoint: AVAudioConnectionPoint;
    }
    class AVAudioNode extends NSObject {
        AUAudioUnit: AUAudioUnit;
        engine: AVAudioEngine;
        lastRenderTime: AVAudioTime;
        latency: number;
        numberOfInputs: number;
        numberOfOutputs: number;
        outputPresentationLatency: number;
        inputFormatForBus(forBus: number): AVAudioFormat;
        installTapWithOnBusBufferSizeFormatBlock(onBus: number, bufferSize: number, format?: AVAudioFormat, block?: (p1: AVAudioPCMBuffer, p2: AVAudioTime) => void): void;
        nameForInputBus(forInputBus: number): string;
        nameForOutputBus(forOutputBus: number): string;
        outputFormatForBus(forBus: number): AVAudioFormat;
        removeTapOnBus(onBus: number): void;
        reset(): void;
    }
    class AVAudioOutputNode extends AVAudioIONode {
    }
    class AVAudioPCMBuffer extends AVAudioBuffer {
        floatChannelData: number;
        frameCapacity: number;
        frameLength: number;
        setFrameLength(_: number): any;
        int16ChannelData: number;
        int32ChannelData: number;
        stride: number;
        static createWithPCMFormatFrameCapacity(PCMFormat: AVAudioFormat, frameCapacity: number): AVAudioPCMBuffer;
    }
    class AVAudioPlayer extends NSObject {
        currentDevice: string;
        setCurrentDevice(_: string): any;
        currentTime: number;
        setCurrentTime(_: number): any;
        data: NSData;
        delegate: AVAudioPlayerDelegate;
        setDelegate(_: AVAudioPlayerDelegate): any;
        deviceCurrentTime: number;
        duration: number;
        enableRate: boolean;
        setEnableRate(_: boolean): any;
        format: AVAudioFormat;
        isMeteringEnabled: boolean;
        setMeteringEnabled(_: boolean): any;
        numberOfChannels: number;
        numberOfLoops: number;
        setNumberOfLoops(_: number): any;
        pan: number;
        setPan(_: number): any;
        isPlaying: boolean;
        rate: number;
        setRate(_: number): any;
        settings: Map<string, any>;
        url: NSURL;
        volume: number;
        setVolume(_: number): any;
        averagePowerForChannel(forChannel: number): number;
        static createWithContentsOfURL(contentsOfURL: NSURL): AVAudioPlayer;
        static createWithContentsOfURLFileTypeHint(contentsOfURL: NSURL, fileTypeHint?: string): AVAudioPlayer;
        static createWithData(data: NSData): AVAudioPlayer;
        static createWithDataFileTypeHint(data: NSData, fileTypeHint?: string): AVAudioPlayer;
        pause(): void;
        peakPowerForChannel(forChannel: number): number;
        play(): boolean;
        playAtTime(atTime: number): boolean;
        prepareToPlay(): boolean;
        setVolumeFadeDuration(_: number, fadeDuration: number): void;
        stop(): void;
        updateMeters(): void;
    }
    interface AVAudioPlayerDelegate extends NSObject {
        audioPlayerDecodeErrorDidOccurError?(_: AVAudioPlayer, error?: NSError): void;
        audioPlayerDidFinishPlayingSuccessfully?(_: AVAudioPlayer, successfully: boolean): void;
    }
    class AVAudioPlayerNode extends AVAudioNode {
        isPlaying: boolean;
        nodeTimeForPlayerTime(forPlayerTime: AVAudioTime): AVAudioTime;
        pause(): void;
        play(): void;
        playAtTime(at?: AVAudioTime): void;
        playerTimeForNodeTime(forNodeTime: AVAudioTime): AVAudioTime;
        prepareWithFrameCount(withFrameCount: number): void;
        scheduleBufferAtOptionsCompletionCallbackTypeCompletionHandler(_: AVAudioPCMBuffer, at?: AVAudioTime, options?: AVAudioPlayerNodeBufferOptions, completionCallbackType?: AVAudioPlayerNodeCompletionCallbackType, completionHandler?: (p1: AVAudioPlayerNodeCompletionCallbackType) => void): void;
        scheduleBufferAtOptionsCompletionHandler(_: AVAudioPCMBuffer, at?: AVAudioTime, options?: AVAudioPlayerNodeBufferOptions, completionHandler?: () => void): void;
        scheduleBufferWithCompletionCallbackTypeCompletionHandler(_: AVAudioPCMBuffer, completionCallbackType: AVAudioPlayerNodeCompletionCallbackType, completionHandler?: (p1: AVAudioPlayerNodeCompletionCallbackType) => void): void;
        scheduleBufferWithCompletionHandler(_: AVAudioPCMBuffer, completionHandler?: () => void): void;
        scheduleFileAtCompletionCallbackTypeCompletionHandler(_: AVAudioFile, at?: AVAudioTime, completionCallbackType?: AVAudioPlayerNodeCompletionCallbackType, completionHandler?: (p1: AVAudioPlayerNodeCompletionCallbackType) => void): void;
        scheduleFileAtCompletionHandler(_: AVAudioFile, at?: AVAudioTime, completionHandler?: () => void): void;
        scheduleSegmentStartingFrameFrameCountAtCompletionCallbackTypeCompletionHandler(_: AVAudioFile, startingFrame: number, frameCount: number, at?: AVAudioTime, completionCallbackType?: AVAudioPlayerNodeCompletionCallbackType, completionHandler?: (p1: AVAudioPlayerNodeCompletionCallbackType) => void): void;
        scheduleSegmentStartingFrameFrameCountAtCompletionHandler(_: AVAudioFile, startingFrame: number, frameCount: number, at?: AVAudioTime, completionHandler?: () => void): void;
        stop(): void;
    }
    class AVAudioRecorder extends NSObject {
        currentTime: number;
        delegate: AVAudioRecorderDelegate;
        setDelegate(_: AVAudioRecorderDelegate): any;
        deviceCurrentTime: number;
        format: AVAudioFormat;
        isMeteringEnabled: boolean;
        setMeteringEnabled(_: boolean): any;
        isRecording: boolean;
        settings: Map<string, any>;
        url: NSURL;
        averagePowerForChannel(forChannel: number): number;
        deleteRecording(): boolean;
        static createWithUrlFormat(URL: NSURL, format: AVAudioFormat): AVAudioRecorder;
        static createWithUrlSettings(URL: NSURL, settings: Map<string, any>): AVAudioRecorder;
        pause(): void;
        peakPowerForChannel(forChannel: number): number;
        prepareToRecord(): boolean;
        record(): boolean;
        recordAtTime(atTime: number): boolean;
        recordAtTimeForDuration(atTime: number, forDuration: number): boolean;
        recordForDuration(forDuration: number): boolean;
        stop(): void;
        updateMeters(): void;
    }
    interface AVAudioRecorderDelegate extends NSObject {
        audioRecorderDidFinishRecordingSuccessfully?(_: AVAudioRecorder, successfully: boolean): void;
        audioRecorderEncodeErrorDidOccurError?(_: AVAudioRecorder, error?: NSError): void;
    }
    class AVAudioSequencer extends NSObject {
        currentPositionInBeats: number;
        setCurrentPositionInBeats(_: number): any;
        currentPositionInSeconds: number;
        setCurrentPositionInSeconds(_: number): any;
        isPlaying: boolean;
        rate: number;
        setRate(_: number): any;
        tempoTrack: AVMusicTrack;
        tracks: AVMusicTrack[];
        userInfo: Map<string, any>;
        beatsForHostTimeError(forHostTime: number): number;
        beatsForSeconds(forSeconds: number): number;
        dataWithSMPTEResolutionError(withSMPTEResolution: number): NSData;
        hostTimeForBeatsError(forBeats: number): number;
        static createWithAudioEngine(audioEngine: AVAudioEngine): AVAudioSequencer;
        loadFromDataOptionsError(options: NSData, error: AVMusicSequenceLoadOptions): boolean;
        loadFromURLOptionsError(options: NSURL, error: AVMusicSequenceLoadOptions): boolean;
        prepareToPlay(): void;
        secondsForBeats(forBeats: number): number;
        startAndReturnError(): boolean;
        stop(): void;
        writeToURLSMPTEResolutionReplaceExistingError(SMPTEResolution: NSURL, replaceExisting: number, error: boolean): boolean;
    }
    class AVAudioSinkNode extends AVAudioNode {
        static createWithReceiverBlock(receiverBlock: (p1: AudioTimeStamp, p2: number, p3: AudioBufferList) => number): AVAudioSinkNode;
    }
    class AVAudioSourceNode extends AVAudioNode {
        static createWithFormatRenderBlock(format: AVAudioFormat, renderBlock: (p1: boolean, p2: AudioTimeStamp, p3: number, p4: AudioBufferList) => number): AVAudioSourceNode;
        static createWithRenderBlock(renderBlock: (p1: boolean, p2: AudioTimeStamp, p3: number, p4: AudioBufferList) => number): AVAudioSourceNode;
    }
    interface AVAudioStereoMixing extends NSObject {
        pan: number;
        setPan(_: number): any;
    }
    class AVAudioTime extends NSObject {
        static hostTimeForSeconds(forSeconds: number): number;
        static secondsForHostTime(forHostTime: number): number;
        audioTimeStamp: AudioTimeStamp;
        hostTime: number;
        isHostTimeValid: boolean;
        sampleRate: number;
        sampleTime: number;
        isSampleTimeValid: boolean;
        extrapolateTimeFromAnchor(fromAnchor: AVAudioTime): AVAudioTime;
        static createWithAudioTimeStampSampleRate(audioTimeStamp: AudioTimeStamp, sampleRate: number): AVAudioTime;
        static createWithHostTime(hostTime: number): AVAudioTime;
        static createWithHostTimeSampleTimeAtRate(hostTime: number, sampleTime: number, atRate: number): AVAudioTime;
        static createWithSampleTimeAtRate(sampleTime: number, atRate: number): AVAudioTime;
    }
    class AVAudioUnit extends AVAudioNode {
        static instantiateWithWithOptionsCompletionHandler(with_: AudioComponentDescription, options: AudioComponentInstantiationOptions, completionHandler?: (p1: AVAudioUnit, p2: NSError) => void): void;
        audioComponentDescription: AudioComponentDescription;
        manufacturerName: string;
        name: string;
        loadAudioUnitPresetAtURLError(error: NSURL): boolean;
    }
    class AVAudioUnitComponent extends NSObject {
        allTagNames: string[];
        audioComponent: any;
        audioComponentDescription: AudioComponentDescription;
        availableArchitectures: number[];
        configurationDictionary: Map<string, any>;
        hasCustomView: boolean;
        hasMIDIInput: boolean;
        hasMIDIOutput: boolean;
        icon: NSImage;
        iconURL: NSURL;
        localizedTypeName: string;
        manufacturerName: string;
        name: string;
        passesAUVal: boolean;
        isSandboxSafe: boolean;
        typeName: string;
        userTagNames: string[];
        setUserTagNames(_: string[]): any;
        versionString: string;
        supportsNumberInputChannelsOutputChannels(_: number, outputChannels: number): boolean;
    }
    class AVAudioUnitComponentManager extends NSObject {
        static sharedAudioUnitComponentManager(): AVAudioUnitComponentManager;
        standardLocalizedTagNames: string[];
        tagNames: string[];
        componentsMatchingDescription(matching: AudioComponentDescription): AVAudioUnitComponent[];
        componentsMatchingPredicate(matching: NSPredicate): AVAudioUnitComponent[];
        componentsWithPassingTest(passingTest: (p1: AVAudioUnitComponent, p2: boolean) => boolean): AVAudioUnitComponent[];
    }
    class AVAudioUnitDelay extends AVAudioUnitEffect {
        delayTime: number;
        setDelayTime(_: number): any;
        feedback: number;
        setFeedback(_: number): any;
        lowPassCutoff: number;
        setLowPassCutoff(_: number): any;
        wetDryMix: number;
        setWetDryMix(_: number): any;
    }
    class AVAudioUnitDistortion extends AVAudioUnitEffect {
        preGain: number;
        setPreGain(_: number): any;
        wetDryMix: number;
        setWetDryMix(_: number): any;
        loadFactoryPreset(_: AVAudioUnitDistortionPreset): void;
    }
    class AVAudioUnitEQ extends AVAudioUnitEffect {
        bands: AVAudioUnitEQFilterParameters[];
        globalGain: number;
        setGlobalGain(_: number): any;
        static createWithNumberOfBands(numberOfBands: number): AVAudioUnitEQ;
    }
    class AVAudioUnitEQFilterParameters extends NSObject {
        bandwidth: number;
        setBandwidth(_: number): any;
        bypass: boolean;
        setBypass(_: boolean): any;
        filterType: AVAudioUnitEQFilterType;
        setFilterType(_: AVAudioUnitEQFilterType): any;
        frequency: number;
        setFrequency(_: number): any;
        gain: number;
        setGain(_: number): any;
    }
    class AVAudioUnitEffect extends AVAudioUnit {
        bypass: boolean;
        setBypass(_: boolean): any;
        static createWithAudioComponentDescription(audioComponentDescription: AudioComponentDescription): AVAudioUnitEffect;
    }
    class AVAudioUnitGenerator extends AVAudioUnit {
        bypass: boolean;
        setBypass(_: boolean): any;
        static createWithAudioComponentDescription(audioComponentDescription: AudioComponentDescription): AVAudioUnitGenerator;
    }
    class AVAudioUnitMIDIInstrument extends AVAudioUnit {
        static createWithAudioComponentDescription(audioComponentDescription: AudioComponentDescription): AVAudioUnitMIDIInstrument;
        sendControllerWithValueOnChannel(_: number, withValue: number, onChannel: number): void;
        sendMIDIEventData1(_: number, data1: number): void;
        sendMIDIEventData1Data2(_: number, data1: number, data2: number): void;
        sendMIDISysExEvent(_: NSData): void;
        sendPitchBendOnChannel(_: number, onChannel: number): void;
        sendPressureOnChannel(_: number, onChannel: number): void;
        sendPressureForKeyWithValueOnChannel(forKey: number, withValue: number, onChannel: number): void;
        sendProgramChangeBankMSBBankLSBOnChannel(_: number, bankMSB: number, bankLSB: number, onChannel: number): void;
        sendProgramChangeOnChannel(_: number, onChannel: number): void;
        startNoteWithVelocityOnChannel(_: number, withVelocity: number, onChannel: number): void;
        stopNoteOnChannel(_: number, onChannel: number): void;
    }
    class AVAudioUnitReverb extends AVAudioUnitEffect {
        wetDryMix: number;
        setWetDryMix(_: number): any;
        loadFactoryPreset(_: AVAudioUnitReverbPreset): void;
    }
    class AVAudioUnitSampler extends AVAudioUnitMIDIInstrument {
        globalTuning: number;
        setGlobalTuning(_: number): any;
        masterGain: number;
        setMasterGain(_: number): any;
        stereoPan: number;
        setStereoPan(_: number): any;
        loadAudioFilesAtURLsError(error: NSURL[]): boolean;
        loadInstrumentAtURLError(error: NSURL): boolean;
        loadSoundBankInstrumentAtURLProgramBankMSBBankLSBError(program: NSURL, bankMSB: number, bankLSB: number, error: number): boolean;
    }
    class AVAudioUnitTimeEffect extends AVAudioUnit {
        bypass: boolean;
        setBypass(_: boolean): any;
        static createWithAudioComponentDescription(audioComponentDescription: AudioComponentDescription): AVAudioUnitTimeEffect;
    }
    class AVAudioUnitTimePitch extends AVAudioUnitTimeEffect {
        overlap: number;
        setOverlap(_: number): any;
        pitch: number;
        setPitch(_: number): any;
        rate: number;
        setRate(_: number): any;
    }
    class AVAudioUnitVarispeed extends AVAudioUnitTimeEffect {
        rate: number;
        setRate(_: number): any;
    }
    class AVCameraCalibrationData extends NSObject {
        extrinsicMatrix: simd_float4x3;
        intrinsicMatrix: simd_float3x3;
        intrinsicMatrixReferenceDimensions: CGSize;
        inverseLensDistortionLookupTable: NSData;
        lensDistortionCenter: CGPoint;
        lensDistortionLookupTable: NSData;
        pixelSize: number;
    }
    class AVCaptureAudioChannel extends NSObject {
        averagePowerLevel: number;
        isEnabled: boolean;
        setEnabled(_: boolean): any;
        peakHoldLevel: number;
        volume: number;
        setVolume(_: number): any;
    }
    class AVCaptureAudioDataOutput extends AVCaptureOutput {
        audioSettings: Map<string, any>;
        setAudioSettings(_: Map<string, any>): any;
        sampleBufferCallbackQueue: NSObject;
        sampleBufferDelegate: AVCaptureAudioDataOutputSampleBufferDelegate;
        recommendedAudioSettingsForAssetWriterWithOutputFileType(writingTo: string): Map<any, any>;
        setSampleBufferDelegateQueue(_?: AVCaptureAudioDataOutputSampleBufferDelegate, queue?: NSObject): void;
    }
    interface AVCaptureAudioDataOutputSampleBufferDelegate extends NSObject {
        captureOutputDidOutputSampleBufferFromConnection?(_: AVCaptureOutput, didOutput: any, from: AVCaptureConnection): void;
    }
    class AVCaptureAudioFileOutput extends AVCaptureFileOutput {
        static availableOutputFileTypes(): string[];
        audioSettings: Map<string, any>;
        setAudioSettings(_: Map<string, any>): any;
        metadata: AVMetadataItem[];
        setMetadata(_: AVMetadataItem[]): any;
        startRecordingToOutputFileURLOutputFileTypeRecordingDelegate(to: NSURL, outputFileType: string, recordingDelegate: AVCaptureFileOutputRecordingDelegate): void;
    }
    class AVCaptureAudioPreviewOutput extends AVCaptureOutput {
        outputDeviceUniqueID: string;
        setOutputDeviceUniqueID(_: string): any;
        volume: number;
        setVolume(_: number): any;
    }
    class AVCaptureConnection extends NSObject {
        static connectionWithInputPortVideoPreviewLayer(inputPort: Port, videoPreviewLayer: AVCaptureVideoPreviewLayer): AVCaptureConnection;
        static connectionWithInputPortsOutput(inputPorts: Port[], output: AVCaptureOutput): AVCaptureConnection;
        isActive: boolean;
        audioChannels: AVCaptureAudioChannel[];
        automaticallyAdjustsVideoMirroring: boolean;
        setAutomaticallyAdjustsVideoMirroring(_: boolean): any;
        isEnabled: boolean;
        setEnabled(_: boolean): any;
        inputPorts: Port[];
        output: AVCaptureOutput;
        isVideoFieldModeSupported: boolean;
        isVideoMaxFrameDurationSupported: boolean;
        isVideoMinFrameDurationSupported: boolean;
        isVideoMirroringSupported: boolean;
        isVideoOrientationSupported: boolean;
        videoFieldMode: AVVideoFieldMode;
        setVideoFieldMode(_: AVVideoFieldMode): any;
        videoMaxFrameDuration: CMTime;
        setVideoMaxFrameDuration(_: CMTime): any;
        videoMinFrameDuration: CMTime;
        setVideoMinFrameDuration(_: CMTime): any;
        isVideoMirrored: boolean;
        setVideoMirrored(_: boolean): any;
        videoOrientation: AVCaptureVideoOrientation;
        setVideoOrientation(_: AVCaptureVideoOrientation): any;
        videoPreviewLayer: AVCaptureVideoPreviewLayer;
        static createWithInputPortVideoPreviewLayer(inputPort: Port, videoPreviewLayer: AVCaptureVideoPreviewLayer): AVCaptureConnection;
        static createWithInputPortsOutput(inputPorts: Port[], output: AVCaptureOutput): AVCaptureConnection;
    }
    class AVCaptureDevice extends NSObject {
        static authorizationStatusForMediaType(for_: string): AVAuthorizationStatus;
        static defaultDeviceWithDeviceTypeMediaTypePosition(_: string, for_?: string, position?: AVCaptureDevice.Position): AVCaptureDevice;
        static defaultDeviceWithMediaType(for_: string): AVCaptureDevice;
        static requestAccessForCompletionHandler(for_: string, completionHandler: (p1: boolean) => void): void;
        activeColorSpace: AVCaptureColorSpace;
        setActiveColorSpace(_: AVCaptureColorSpace): any;
        activeFormat: Format;
        setActiveFormat(_: Format): any;
        activeInputSource: InputSource;
        setActiveInputSource(_: InputSource): any;
        activeVideoMaxFrameDuration: CMTime;
        setActiveVideoMaxFrameDuration(_: CMTime): any;
        activeVideoMinFrameDuration: CMTime;
        setActiveVideoMinFrameDuration(_: CMTime): any;
        isAdjustingExposure: boolean;
        isAdjustingFocus: boolean;
        isAdjustingWhiteBalance: boolean;
        isConnected: boolean;
        deviceType: string;
        exposureMode: AVCaptureDevice.ExposureMode;
        setExposureMode(_: AVCaptureDevice.ExposureMode): any;
        exposurePointOfInterest: CGPoint;
        setExposurePointOfInterest(_: CGPoint): any;
        isExposurePointOfInterestSupported: boolean;
        isFlashAvailable: boolean;
        flashMode: AVCaptureDevice.FlashMode;
        setFlashMode(_: AVCaptureDevice.FlashMode): any;
        focusMode: AVCaptureDevice.FocusMode;
        setFocusMode(_: AVCaptureDevice.FocusMode): any;
        focusPointOfInterest: CGPoint;
        setFocusPointOfInterest(_: CGPoint): any;
        isFocusPointOfInterestSupported: boolean;
        formats: Format[];
        hasFlash: boolean;
        hasTorch: boolean;
        isInUseByAnotherApplication: boolean;
        inputSources: InputSource[];
        linkedDevices: AVCaptureDevice[];
        localizedName: string;
        manufacturer: string;
        modelID: string;
        position: AVCaptureDevice.Position;
        isSuspended: boolean;
        isTorchActive: boolean;
        isTorchAvailable: boolean;
        torchLevel: number;
        torchMode: AVCaptureDevice.TorchMode;
        setTorchMode(_: AVCaptureDevice.TorchMode): any;
        transportControlsPlaybackMode: AVCaptureDevice.TransportControlsPlaybackMode;
        transportControlsSpeed: number;
        transportControlsSupported: boolean;
        transportType: number;
        uniqueID: string;
        whiteBalanceMode: AVCaptureDevice.WhiteBalanceMode;
        setWhiteBalanceMode(_: AVCaptureDevice.WhiteBalanceMode): any;
        hasMediaType(_: string): boolean;
        isExposureModeSupported(_: AVCaptureDevice.ExposureMode): boolean;
        isFlashModeSupported(_: AVCaptureDevice.FlashMode): boolean;
        isFocusModeSupported(_: AVCaptureDevice.FocusMode): boolean;
        isTorchModeSupported(_: AVCaptureDevice.TorchMode): boolean;
        isWhiteBalanceModeSupported(_: AVCaptureDevice.WhiteBalanceMode): boolean;
        lockForConfiguration(): boolean;
        setTorchModeOnWithLevelError(level: number): boolean;
        setTransportControlsPlaybackModeSpeed(_: AVCaptureDevice.TransportControlsPlaybackMode, speed: number): void;
        supportsAVCaptureSessionPreset(_: string): boolean;
        unlockForConfiguration(): void;
    }
    class DiscoverySession extends NSObject {
        static discoverySessionWithDeviceTypesMediaTypePosition(_: string[], mediaType?: string, position?: AVCaptureDevice.Position): DiscoverySession;
    }
    class Format extends NSObject {
        formatDescription: any;
        mediaType: string;
        supportedColorSpaces: number[];
        videoSupportedFrameRateRanges: AVFrameRateRange[];
    }
    class AVCaptureDeviceInput extends AVCaptureInput {
        static deviceInputWithDeviceError(error: AVCaptureDevice): AVCaptureDeviceInput;
        device: AVCaptureDevice;
        static createWithDevice(device: AVCaptureDevice): AVCaptureDeviceInput;
    }
    class InputSource extends NSObject {
        inputSourceID: string;
        localizedName: string;
    }
    class AVCaptureFileOutput extends AVCaptureOutput {
        delegate: AVCaptureFileOutputDelegate;
        setDelegate(_: AVCaptureFileOutputDelegate): any;
        maxRecordedDuration: CMTime;
        setMaxRecordedDuration(_: CMTime): any;
        maxRecordedFileSize: number;
        setMaxRecordedFileSize(_: number): any;
        minFreeDiskSpaceLimit: number;
        setMinFreeDiskSpaceLimit(_: number): any;
        outputFileURL: NSURL;
        recordedDuration: CMTime;
        recordedFileSize: number;
        isRecording: boolean;
        isRecordingPaused: boolean;
        pauseRecording(): void;
        resumeRecording(): void;
        startRecordingToOutputFileURLRecordingDelegate(to: NSURL, recordingDelegate: AVCaptureFileOutputRecordingDelegate): void;
        stopRecording(): void;
    }
    interface AVCaptureFileOutputDelegate extends NSObject {
        captureOutputDidOutputSampleBufferFromConnection?(_: AVCaptureFileOutput, didOutputSampleBuffer: any, from: AVCaptureConnection): void;
        captureOutputShouldProvideSampleAccurateRecordingStart(_: AVCaptureOutput): boolean;
    }
    interface AVCaptureFileOutputRecordingDelegate extends NSObject {
        captureOutputDidStartRecordingToOutputFileAtURLFromConnections?(_: AVCaptureFileOutput, didStartRecordingTo: NSURL, from: AVCaptureConnection[]): void;
        captureOutputDidPauseRecordingToOutputFileAtURLFromConnections?(_: AVCaptureFileOutput, didPauseRecordingTo: NSURL, from: AVCaptureConnection[]): void;
        captureOutputDidResumeRecordingToOutputFileAtURLFromConnections?(_: AVCaptureFileOutput, didResumeRecordingTo: NSURL, from: AVCaptureConnection[]): void;
        captureOutputWillFinishRecordingToOutputFileAtURLFromConnectionsError?(_: AVCaptureFileOutput, willFinishRecordingTo: NSURL, from: AVCaptureConnection[], error?: NSError): void;
        captureOutputDidFinishRecordingToOutputFileAtURLFromConnectionsError(_: AVCaptureFileOutput, didFinishRecordingTo: NSURL, from: AVCaptureConnection[], error?: NSError): void;
    }
    class AVCaptureInput extends NSObject {
        ports: Port[];
    }
    class AVCaptureMovieFileOutput extends AVCaptureFileOutput {
        metadata: AVMetadataItem[];
        setMetadata(_: AVMetadataItem[]): any;
        movieFragmentInterval: CMTime;
        setMovieFragmentInterval(_: CMTime): any;
        outputSettingsForConnection(for_: AVCaptureConnection): Map<string, any>;
        setOutputSettingsForConnection(_?: Map<string, any>, for_?: AVCaptureConnection): void;
    }
    class AVCaptureOutput extends NSObject {
        connections: AVCaptureConnection[];
        connectionWithMediaType(with_: string): AVCaptureConnection;
        metadataOutputRectOfInterestForRect(fromOutputRect: CGRect): CGRect;
        rectForMetadataOutputRectOfInterest(fromMetadataOutputRect: CGRect): CGRect;
        transformedMetadataObjectForMetadataObjectConnection(for_: AVMetadataObject, connection: AVCaptureConnection): AVMetadataObject;
    }
    class AVCapturePhoto extends NSObject {
        photoCount: number;
        pixelBuffer: any;
        resolvedSettings: AVCaptureResolvedPhotoSettings;
        timestamp: CMTime;
        CGImageRepresentation(): any;
        fileDataRepresentation(): NSData;
    }
    interface AVCapturePhotoCaptureDelegate extends NSObject {
        captureOutputWillBeginCaptureForResolvedSettings?(_: AVCapturePhotoOutput, willBeginCaptureFor: AVCaptureResolvedPhotoSettings): void;
        captureOutputWillCapturePhotoForResolvedSettings?(_: AVCapturePhotoOutput, willCapturePhotoFor: AVCaptureResolvedPhotoSettings): void;
        captureOutputDidCapturePhotoForResolvedSettings?(_: AVCapturePhotoOutput, didCapturePhotoFor: AVCaptureResolvedPhotoSettings): void;
        captureOutputDidFinishProcessingPhotoError?(_: AVCapturePhotoOutput, didFinishProcessingPhoto: AVCapturePhoto, error?: NSError): void;
        captureOutputDidFinishCaptureForResolvedSettingsError?(_: AVCapturePhotoOutput, didFinishCaptureFor: AVCaptureResolvedPhotoSettings, error?: NSError): void;
    }
    class AVCapturePhotoOutput extends AVCaptureOutput {
        availablePhotoCodecTypes: string[];
        availablePhotoFileTypes: string[];
        availablePhotoPixelFormatTypes: number[];
        capturePhotoWithSettingsDelegate(with_: AVCapturePhotoSettings, delegate: AVCapturePhotoCaptureDelegate): void;
        supportedPhotoCodecTypesForFileType(for_: string): string[];
        supportedPhotoPixelFormatTypesForFileType(for_: string): number[];
    }
    class AVCapturePhotoSettings extends NSObject {
        static photoSettings(): AVCapturePhotoSettings;
        static photoSettingsFromPhotoSettings(from: AVCapturePhotoSettings): AVCapturePhotoSettings;
        static photoSettingsWithFormat(format?: Map<string, any>): AVCapturePhotoSettings;
        format: Map<string, any>;
        processedFileType: string;
        uniqueID: number;
    }
    class AVCaptureResolvedPhotoSettings extends NSObject {
        expectedPhotoCount: number;
        photoDimensions: CMVideoDimensions;
        uniqueID: number;
    }
    class AVCaptureScreenInput extends AVCaptureInput {
        capturesCursor: boolean;
        setCapturesCursor(_: boolean): any;
        capturesMouseClicks: boolean;
        setCapturesMouseClicks(_: boolean): any;
        cropRect: CGRect;
        setCropRect(_: CGRect): any;
        minFrameDuration: CMTime;
        setMinFrameDuration(_: CMTime): any;
        scaleFactor: number;
        setScaleFactor(_: number): any;
        static createWithDisplayID(displayID: number): AVCaptureScreenInput;
    }
    class AVCaptureSession extends NSObject {
        connections: AVCaptureConnection[];
        inputs: AVCaptureInput[];
        masterClock: any;
        outputs: AVCaptureOutput[];
        isRunning: boolean;
        sessionPreset: string;
        setSessionPreset(_: string): any;
        addConnection(_: AVCaptureConnection): void;
        addInput(_: AVCaptureInput): void;
        addInputWithNoConnections(_: AVCaptureInput): void;
        addOutput(_: AVCaptureOutput): void;
        addOutputWithNoConnections(_: AVCaptureOutput): void;
        beginConfiguration(): void;
        canAddConnection(_: AVCaptureConnection): boolean;
        canAddInput(_: AVCaptureInput): boolean;
        canAddOutput(_: AVCaptureOutput): boolean;
        canSetSessionPreset(_: string): boolean;
        commitConfiguration(): void;
        removeConnection(_: AVCaptureConnection): void;
        removeInput(_: AVCaptureInput): void;
        removeOutput(_: AVCaptureOutput): void;
        startRunning(): void;
        stopRunning(): void;
    }
    class SystemPressureState extends NSObject {
        level: string;
    }
    class AVCaptureVideoDataOutput extends AVCaptureOutput {
        alwaysDiscardsLateVideoFrames: boolean;
        setAlwaysDiscardsLateVideoFrames(_: boolean): any;
        availableVideoCVPixelFormatTypes: number[];
        availableVideoCodecTypes: string[];
        sampleBufferCallbackQueue: NSObject;
        sampleBufferDelegate: AVCaptureVideoDataOutputSampleBufferDelegate;
        videoSettings: Map<string, any>;
        setVideoSettings(_: Map<string, any>): any;
        availableVideoCodecTypesForAssetWriterWithOutputFileType(writingTo: string): string[];
        recommendedVideoSettingsForAssetWriterWithOutputFileType(writingTo: string): Map<string, any>;
        recommendedVideoSettingsForVideoCodecTypeAssetWriterOutputFileType(forVideoCodecType: string, assetWriterOutputFileType: string): Map<any, any>;
        setSampleBufferDelegateQueue(_?: AVCaptureVideoDataOutputSampleBufferDelegate, queue?: NSObject): void;
    }
    interface AVCaptureVideoDataOutputSampleBufferDelegate extends NSObject {
        captureOutputDidOutputSampleBufferFromConnection?(_: AVCaptureOutput, didOutput: any, from: AVCaptureConnection): void;
        captureOutputDidDropSampleBufferFromConnection?(_: AVCaptureOutput, didDrop: any, from: AVCaptureConnection): void;
    }
    class AVCaptureVideoPreviewLayer extends CALayer {
        connection: AVCaptureConnection;
        session: AVCaptureSession;
        setSession(_: AVCaptureSession): any;
        videoGravity: string;
        setVideoGravity(_: string): any;
        captureDevicePointOfInterestForPoint(fromLayerPoint: CGPoint): CGPoint;
        static createWithSession(session: AVCaptureSession): AVCaptureVideoPreviewLayer;
        static createWithSessionWithNoConnection(sessionWithNoConnection: AVCaptureSession): AVCaptureVideoPreviewLayer;
        metadataOutputRectOfInterestForRect(fromLayerRect: CGRect): CGRect;
        pointForCaptureDevicePointOfInterest(fromCaptureDevicePoint: CGPoint): CGPoint;
        rectForMetadataOutputRectOfInterest(fromMetadataOutputRect: CGRect): CGRect;
        setSessionWithNoConnection(_: AVCaptureSession): void;
        transformedMetadataObjectForMetadataObject(for_: AVMetadataObject): AVMetadataObject;
    }
    class AVComposition extends AVAsset {
        URLAssetInitializationOptions: Map<string, any>;
        naturalSize: CGSize;
    }
    class AVCompositionTrack extends AVAssetTrack {
        formatDescriptionReplacements: AVCompositionTrackFormatDescriptionReplacement[];
    }
    class AVCompositionTrackFormatDescriptionReplacement extends NSObject {
        originalFormatDescription: any;
        replacementFormatDescription: any;
    }
    class AVCompositionTrackSegment extends AVAssetTrackSegment {
        sourceTrackID: number;
        sourceURL: NSURL;
        static createWithTimeRange(timeRange: CMTimeRange): AVCompositionTrackSegment;
        static createWithUrlTrackIDSourceTimeRangeTargetTimeRange(URL: NSURL, trackID: number, sourceTimeRange: CMTimeRange, targetTimeRange: CMTimeRange): AVCompositionTrackSegment;
    }
    interface AVContentKeyRecipient {
        mayRequireContentKeysForMediaDataProcessing: boolean;
    }
    class AVContentKeyRequest extends NSObject {
        canProvidePersistableContentKey: boolean;
        error: NSError;
        identifier: any;
        initializationData: NSData;
        options: Map<string, any>;
        renewsExpiringResponseData: boolean;
        status: AVContentKeyRequest.Status;
        makeStreamingContentKeyRequestDataWithForAppContentIdentifierOptionsCompletionHandler(forApp: NSData, contentIdentifier?: NSData, options?: Map<string, any>, completionHandler?: (p1: NSData, p2: NSError) => void): void;
        processContentKeyResponse(_: AVContentKeyResponse): void;
        processContentKeyResponseError(_: NSError): void;
        respondByRequestingPersistableContentKeyRequestAndReturnError(): boolean;
    }
    class AVContentKeyResponse extends NSObject {
        static contentKeyResponseWithAuthorizationTokenData(authorizationTokenData: NSData): AVContentKeyResponse;
        static contentKeyResponseWithClearKeyDataInitializationVector(clearKeyData: NSData, initializationVector?: NSData): AVContentKeyResponse;
        static contentKeyResponseWithFairPlayStreamingKeyResponseData(fairPlayStreamingKeyResponseData: NSData): AVContentKeyResponse;
    }
    class AVContentKeySession extends NSObject {
        static pendingExpiredSessionReportsWithAppIdentifierStorageDirectoryAtURL(withAppIdentifier: NSData, storageDirectoryAt: NSURL): NSData[];
        static removePendingExpiredSessionReportsWithAppIdentifierStorageDirectoryAtURL(_: NSData[], withAppIdentifier: NSData, storageDirectoryAt: NSURL): void;
        contentKeyRecipients: AVContentKeyRecipient[];
        contentProtectionSessionIdentifier: NSData;
        delegate: AVContentKeySessionDelegate;
        delegateQueue: NSObject;
        keySystem: string;
        storageURL: NSURL;
        addContentKeyRecipient(_: AVContentKeyRecipient): void;
        expire(): void;
        invalidateAllPersistableContentKeysWithForAppOptionsCompletionHandler(forApp: NSData, options?: Map<string, any>, completionHandler?: (p1: NSData, p2: NSError) => void): void;
        invalidatePersistableContentKeyWithOptionsCompletionHandler(_: NSData, options?: Map<string, any>, completionHandler?: (p1: NSData, p2: NSError) => void): void;
        makeSecureTokenForExpirationDateWithOfPersistableContentKeyCompletionHandler(ofPersistableContentKey: NSData, completionHandler?: (p1: NSData, p2: NSError) => void): void;
        processContentKeyRequestWithIdentifierInitializationDataOptions(withIdentifier?: any, initializationData?: NSData, options?: Map<string, any>): void;
        removeContentKeyRecipient(_: AVContentKeyRecipient): void;
        renewExpiringResponseDataForContentKeyRequest(for_: AVContentKeyRequest): void;
        setDelegateQueue(_?: AVContentKeySessionDelegate, queue?: NSObject): void;
    }
    interface AVContentKeySessionDelegate extends NSObject {
        contentKeySessionDidProvideContentKeyRequest(_: AVContentKeySession, didProvide: AVContentKeyRequest): void;
        contentKeySessionDidProvidePersistableContentKeyRequest?(_: AVContentKeySession, didProvide: AVPersistableContentKeyRequest): void;
        contentKeySessionShouldRetryContentKeyRequestReason?(_: AVContentKeySession, shouldRetry: AVContentKeyRequest, reason: string): boolean;
        contentKeySessionContentKeyRequestDidFailWithError?(_: AVContentKeySession, contentKeyRequest: AVContentKeyRequest, didFailWithError: NSError): void;
        contentKeySessionContentKeyRequestDidSucceed?(_: AVContentKeySession, contentKeyRequestDidSucceed: AVContentKeyRequest): void;
        contentKeySessionDidProvideRenewingContentKeyRequest?(_: AVContentKeySession, didProvideRenewingContentKeyRequest: AVContentKeyRequest): void;
        contentKeySessionDidUpdatePersistableContentKeyForContentKeyIdentifier?(_: AVContentKeySession, didUpdatePersistableContentKey: NSData, forContentKeyIdentifier: any): void;
        contentKeySessionContentProtectionSessionIdentifierDidChange?(_: AVContentKeySession): void;
        contentKeySessionDidGenerateExpiredSessionReport?(_: AVContentKeySession): void;
    }
    class AVDateRangeMetadataGroup extends AVMetadataGroup {
        endDate: Date;
        startDate: Date;
        static createWithItemsStartDateEndDate(items: AVMetadataItem[], startDate: Date, endDate?: Date): AVDateRangeMetadataGroup;
    }
    class AVDepthData extends NSObject {
        static depthDataFromDictionaryRepresentationError(error: Map<any, any>): AVDepthData;
        availableDepthDataTypes: number[];
        cameraCalibrationData: AVCameraCalibrationData;
        depthDataAccuracy: AVDepthData.Accuracy;
        isDepthDataFiltered: boolean;
        depthDataMap: any;
        depthDataQuality: AVDepthData.Quality;
        depthDataType: number;
        depthDataByApplyingExifOrientation(_: CGImagePropertyOrientation): AVDepthData;
        depthDataByConvertingToDepthDataType(toDepthDataType: number): AVDepthData;
        depthDataByReplacingDepthDataMapWithPixelBufferError(error: any): AVDepthData;
        dictionaryRepresentationForAuxiliaryDataType(forAuxiliaryDataType?: string): Map<any, any>;
    }
    interface AVFragmentMinding {
        isAssociatedWithFragmentMinder: boolean;
    }
    class AVFragmentedAsset extends AVURLAsset {
        static fragmentedAssetWithURLOptions(url: NSURL, options?: Map<string, any>): AVFragmentedAsset;
    }
    class AVFragmentedAssetMinder extends NSObject {
        static fragmentedAssetMinderWithAssetMindingInterval(asset: AVAsset, mindingInterval: number): AVFragmentedAssetMinder;
        assets: AVAsset[];
        mindingInterval: number;
        setMindingInterval(_: number): any;
        addFragmentedAsset(_: AVAsset): void;
        static createWithAssetMindingInterval(asset: AVAsset, mindingInterval: number): AVFragmentedAssetMinder;
        removeFragmentedAsset(_: AVAsset): void;
    }
    class AVFragmentedAssetTrack extends AVAssetTrack {
    }
    class AVFragmentedMovie extends AVMovie {
    }
    class AVFragmentedMovieMinder extends AVFragmentedAssetMinder {
        static fragmentedMovieMinderWithMovieMindingInterval(movie: AVFragmentedMovie, mindingInterval: number): AVFragmentedMovieMinder;
        movies: AVFragmentedMovie[];
        addFragmentedMovie(_: AVFragmentedMovie): void;
        static createWithMovieMindingInterval(movie: AVFragmentedMovie, mindingInterval: number): AVFragmentedMovieMinder;
        removeFragmentedMovie(_: AVFragmentedMovie): void;
    }
    class AVFragmentedMovieTrack extends AVMovieTrack {
    }
    class AVFrameRateRange extends NSObject {
        maxFrameDuration: CMTime;
        maxFrameRate: number;
        minFrameDuration: CMTime;
        minFrameRate: number;
    }
    class AVMIDIPlayer extends NSObject {
        currentPosition: number;
        setCurrentPosition(_: number): any;
        duration: number;
        isPlaying: boolean;
        rate: number;
        setRate(_: number): any;
        static createWithContentsOfURLSoundBankURL(contentsOfURL: NSURL, soundBankURL?: NSURL): AVMIDIPlayer;
        static createWithDataSoundBankURL(data: NSData, soundBankURL?: NSURL): AVMIDIPlayer;
        play(_?: () => void): void;
        prepareToPlay(): void;
        stop(): void;
    }
    class AVMediaDataStorage extends NSObject {
        URL(): NSURL;
        static createWithUrlOptions(URL: NSURL, options?: Map<string, any>): AVMediaDataStorage;
    }
    class AVMediaSelection extends NSObject {
        asset: AVAsset;
        mediaSelectionCriteriaCanBeAppliedAutomaticallyToMediaSelectionGroup(to: AVMediaSelectionGroup): boolean;
        selectedMediaOptionInMediaSelectionGroup(in_: AVMediaSelectionGroup): AVMediaSelectionOption;
    }
    class AVMediaSelectionGroup extends NSObject {
        static mediaSelectionOptionsFromArrayFilteredAndSortedAccordingToPreferredLanguages(from: AVMediaSelectionOption[], filteredAndSortedAccordingToPreferredLanguages: string[]): AVMediaSelectionOption[];
        static mediaSelectionOptionsFromArrayWithLocale(from: AVMediaSelectionOption[], with_: NSLocale): AVMediaSelectionOption[];
        static mediaSelectionOptionsFromArrayWithMediaCharacteristics(from: AVMediaSelectionOption[], withMediaCharacteristics: string[]): AVMediaSelectionOption[];
        static mediaSelectionOptionsFromArrayWithoutMediaCharacteristics(from: AVMediaSelectionOption[], withoutMediaCharacteristics: string[]): AVMediaSelectionOption[];
        static playableMediaSelectionOptionsFromArray(from: AVMediaSelectionOption[]): AVMediaSelectionOption[];
        allowsEmptySelection: boolean;
        defaultOption: AVMediaSelectionOption;
        options: AVMediaSelectionOption[];
        mediaSelectionOptionWithPropertyList(withPropertyList: any): AVMediaSelectionOption;
    }
    class AVMediaSelectionOption extends NSObject {
        availableMetadataFormats: string[];
        commonMetadata: AVMetadataItem[];
        displayName: string;
        extendedLanguageTag: string;
        locale: NSLocale;
        mediaSubTypes: number[];
        mediaType: string;
        isPlayable: boolean;
        associatedMediaSelectionOptionInMediaSelectionGroup(in_: AVMediaSelectionGroup): AVMediaSelectionOption;
        displayNameWithLocale(with_: NSLocale): string;
        hasMediaCharacteristic(_: string): boolean;
        metadataForFormat(forFormat: string): AVMetadataItem[];
        propertyList(): any;
    }
    class AVMetadataBodyObject extends AVMetadataObject {
        bodyID: number;
    }
    class AVMetadataCatBodyObject extends AVMetadataBodyObject {
    }
    class AVMetadataDogBodyObject extends AVMetadataBodyObject {
    }
    class AVMetadataFaceObject extends AVMetadataObject {
        faceID: number;
        hasRollAngle: boolean;
        hasYawAngle: boolean;
        rollAngle: number;
        yawAngle: number;
    }
    class AVMetadataGroup extends NSObject {
        classifyingLabel: string;
        items: AVMetadataItem[];
        uniqueID: string;
    }
    class AVMetadataHumanBodyObject extends AVMetadataBodyObject {
    }
    class AVMetadataItem extends NSObject {
        static identifierForKeyKeySpace(forKey: any, keySpace: string): string;
        static keyForIdentifier(forIdentifier: string): any;
        static keySpaceForIdentifier(forIdentifier: string): string;
        static metadataItemsFromArrayFilteredAndSortedAccordingToPreferredLanguages(from: AVMetadataItem[], filteredAndSortedAccordingToPreferredLanguages: string[]): AVMetadataItem[];
        static metadataItemsFromArrayFilteredByIdentifier(from: AVMetadataItem[], filteredByIdentifier: string): AVMetadataItem[];
        static metadataItemsFromArrayFilteredByMetadataItemFilter(from: AVMetadataItem[], filteredBy: AVMetadataItemFilter): AVMetadataItem[];
        static metadataItemsFromArrayWithKeyKeySpace(from: AVMetadataItem[], withKey?: any, keySpace?: string): AVMetadataItem[];
        static metadataItemsFromArrayWithLocale(from: AVMetadataItem[], with_: NSLocale): AVMetadataItem[];
        commonKey: string;
        dataType: string;
        dataValue: NSData;
        dateValue: Date;
        duration: CMTime;
        extendedLanguageTag: string;
        extraAttributes: Map<string, any>;
        identifier: string;
        key: any;
        keySpace: string;
        locale: NSLocale;
        numberValue: number;
        startDate: Date;
        stringValue: string;
        time: CMTime;
        value: any;
    }
    class AVMetadataItemFilter extends NSObject {
        static metadataItemFilterForSharing(): AVMetadataItemFilter;
    }
    class AVMetadataItemValueRequest extends NSObject {
        metadataItem: AVMetadataItem;
        respondWithError(error: NSError): void;
        respondWithValue(value: any): void;
    }
    class AVMetadataMachineReadableCodeObject extends AVMetadataObject {
        corners: Map<any, any>[];
        descriptor: CIBarcodeDescriptor;
        stringValue: string;
    }
    class AVMetadataObject extends NSObject {
        bounds: CGRect;
        duration: CMTime;
        time: CMTime;
        type: string;
    }
    class AVMetadataSalientObject extends AVMetadataObject {
        objectID: number;
    }
    class AVMovie extends AVAsset {
        static movieTypes(): string[];
        URL: NSURL;
        canContainMovieFragments: boolean;
        containsMovieFragments: boolean;
        data: NSData;
        defaultMediaDataStorage: AVMediaDataStorage;
        static createWithDataOptions(data: NSData, options?: Map<string, any>): AVMovie;
        static createWithUrlOptions(URL: NSURL, options?: Map<string, any>): AVMovie;
        isCompatibleWithFileType(compatibleWithFileType: string): boolean;
        movieHeaderWithFileTypeError(fileType: string): NSData;
        writeMovieHeaderToURLFileTypeOptionsError(fileType: NSURL, options: string, error: AVMovieWritingOptions): boolean;
    }
    class AVMovieTrack extends AVAssetTrack {
        alternateGroupID: number;
        mediaDataStorage: AVMediaDataStorage;
        mediaDecodeTimeRange: CMTimeRange;
        mediaPresentationTimeRange: CMTimeRange;
    }
    class AVMusicTrack extends NSObject {
        destinationAudioUnit: AVAudioUnit;
        setDestinationAudioUnit(_: AVAudioUnit): any;
        destinationMIDIEndpoint: number;
        setDestinationMIDIEndpoint(_: number): any;
        lengthInBeats: number;
        setLengthInBeats(_: number): any;
        lengthInSeconds: number;
        setLengthInSeconds(_: number): any;
        loopRange: AVAudioSequencer;
        setLoopRange(_: AVAudioSequencer): any;
        isLoopingEnabled: boolean;
        setLoopingEnabled(_: boolean): any;
        isMuted: boolean;
        setMuted(_: boolean): any;
        numberOfLoops: number;
        setNumberOfLoops(_: number): any;
        offsetTime: number;
        setOffsetTime(_: number): any;
        isSoloed: boolean;
        setSoloed(_: boolean): any;
        timeResolution: number;
    }
    class AVMutableAudioMix extends AVAudioMix {
        static audioMix(): AVMutableAudioMix;
    }
    class AVMutableAudioMixInputParameters extends AVAudioMixInputParameters {
        static audioMixInputParameters(): AVMutableAudioMixInputParameters;
        static audioMixInputParametersWithTrack(track?: AVAssetTrack): AVMutableAudioMixInputParameters;
        setVolumeAtTime(_: number, at: CMTime): void;
        setVolumeRampFromStartVolumeToEndVolumeTimeRange(fromStartVolume: number, toEndVolume: number, timeRange: CMTimeRange): void;
    }
    class AVMutableComposition extends AVComposition {
        static composition(): AVMutableComposition;
        static compositionWithURLAssetInitializationOptions(urlAssetInitializationOptions?: Map<string, any>): AVMutableComposition;
        addMutableTrackWithMediaTypePreferredTrackID(withMediaType: string, preferredTrackID: number): AVMutableCompositionTrack;
        insertEmptyTimeRange(_: CMTimeRange): void;
        insertTimeRangeOfAssetAtTimeError(_: CMTimeRange, of: AVAsset, at: CMTime): boolean;
        mutableTrackCompatibleWithTrack(compatibleWith: AVAssetTrack): AVMutableCompositionTrack;
        removeTimeRange(_: CMTimeRange): void;
        removeTrack(_: AVCompositionTrack): void;
        scaleTimeRangeToDuration(_: CMTimeRange, toDuration: CMTime): void;
    }
    class AVMutableCompositionTrack extends AVCompositionTrack {
        addTrackAssociationToTrackType(to: AVCompositionTrack, type: string): void;
        insertEmptyTimeRange(_: CMTimeRange): void;
        insertTimeRangeOfTrackAtTimeError(ofTrack: CMTimeRange, atTime: AVAssetTrack, error: CMTime): boolean;
        insertTimeRangesOfTracksAtTimeError(ofTracks: NSValue[], atTime: AVAssetTrack[], error: CMTime): boolean;
        removeTimeRange(_: CMTimeRange): void;
        removeTrackAssociationToTrackType(to: AVCompositionTrack, type: string): void;
        replaceFormatDescriptionWithFormatDescription(_: any, with_?: any): void;
        scaleTimeRangeToDuration(_: CMTimeRange, toDuration: CMTime): void;
        validateTrackSegmentsError(error: AVCompositionTrackSegment[]): boolean;
    }
    class AVMutableDateRangeMetadataGroup extends AVDateRangeMetadataGroup {
    }
    class AVMutableMediaSelection extends AVMediaSelection {
        selectMediaOptionInMediaSelectionGroup(_?: AVMediaSelectionOption, in_?: AVMediaSelectionGroup): void;
    }
    class AVMutableMetadataItem extends AVMetadataItem {
        static metadataItem(): AVMutableMetadataItem;
    }
    class AVMutableMovie extends AVMovie {
        static movieWithDataOptionsError(data: NSData, options?: Map<string, any>): AVMutableMovie;
        static movieWithSettingsFromMovieOptionsError(options?: AVMovie, error?: Map<string, any>): AVMutableMovie;
        static movieWithURLOptionsError(url: NSURL, options?: Map<string, any>): AVMutableMovie;
        interleavingPeriod: CMTime;
        setInterleavingPeriod(_: CMTime): any;
        isModified: boolean;
        setModified(_: boolean): any;
        timescale: number;
        setTimescale(_: number): any;
        addMutableTrackWithMediaTypeCopySettingsFromTrackOptions(withMediaType: string, copySettingsFrom?: AVAssetTrack, options?: Map<string, any>): AVMutableMovieTrack;
        addMutableTracksCopyingSettingsFromTracksOptions(from: AVAssetTrack[], options?: Map<string, any>): AVMutableMovieTrack[];
        static createWithSettingsFromMovieOptions(settingsFromMovie?: AVMovie, options?: Map<string, any>): AVMutableMovie;
        insertEmptyTimeRange(_: CMTimeRange): void;
        insertTimeRangeOfAssetAtTimeCopySampleDataError(_: CMTimeRange, of: AVAsset, at: CMTime, copySampleData: boolean): boolean;
        mutableTrackCompatibleWithTrack(compatibleWith: AVAssetTrack): AVMutableMovieTrack;
        removeTimeRange(_: CMTimeRange): void;
        removeTrack(_: AVMovieTrack): void;
        scaleTimeRangeToDuration(_: CMTimeRange, toDuration: CMTime): void;
    }
    class AVMutableMovieTrack extends AVMovieTrack {
        cleanApertureDimensions: CGSize;
        setCleanApertureDimensions(_: CGSize): any;
        encodedPixelsDimensions: CGSize;
        setEncodedPixelsDimensions(_: CGSize): any;
        hasProtectedContent: boolean;
        layer: number;
        setLayer(_: number): any;
        isModified: boolean;
        setModified(_: boolean): any;
        preferredMediaChunkAlignment: number;
        setPreferredMediaChunkAlignment(_: number): any;
        preferredMediaChunkDuration: CMTime;
        setPreferredMediaChunkDuration(_: CMTime): any;
        preferredMediaChunkSize: number;
        setPreferredMediaChunkSize(_: number): any;
        productionApertureDimensions: CGSize;
        setProductionApertureDimensions(_: CGSize): any;
        sampleReferenceBaseURL: NSURL;
        setSampleReferenceBaseURL(_: NSURL): any;
        timescale: number;
        setTimescale(_: number): any;
        addTrackAssociationToTrackType(to: AVMovieTrack, type: string): void;
        appendSampleBufferDecodeTimePresentationTimeError(_: any, decodeTime?: CMTime, presentationTime?: CMTime): boolean;
        insertEmptyTimeRange(_: CMTimeRange): void;
        insertMediaTimeRangeIntoTimeRange(_: CMTimeRange, into: CMTimeRange): boolean;
        insertTimeRangeOfTrackAtTimeCopySampleDataError(ofTrack: CMTimeRange, atTime: AVAssetTrack, copySampleData: CMTime, error: boolean): boolean;
        removeTimeRange(_: CMTimeRange): void;
        removeTrackAssociationToTrackType(to: AVMovieTrack, type: string): void;
        replaceFormatDescriptionWithFormatDescription(_: any, with_: any): void;
        scaleTimeRangeToDuration(_: CMTimeRange, toDuration: CMTime): void;
    }
    class AVMutableTimedMetadataGroup extends AVTimedMetadataGroup {
    }
    class AVMutableVideoComposition extends AVVideoComposition {
        static videoComposition(): AVMutableVideoComposition;
        static videoCompositionWithPropertiesOfAssetPrototypeInstruction(propertiesOf: AVAsset, prototypeInstruction: AVVideoCompositionInstruction): AVMutableVideoComposition;
    }
    class AVMutableVideoCompositionInstruction extends AVVideoCompositionInstruction {
        static videoCompositionInstruction(): AVMutableVideoCompositionInstruction;
        enablePostProcessing: boolean;
        setEnablePostProcessing(_: boolean): any;
        timeRange: CMTimeRange;
        setTimeRange(_: CMTimeRange): any;
    }
    class AVMutableVideoCompositionLayerInstruction extends AVVideoCompositionLayerInstruction {
        static videoCompositionLayerInstruction(): AVMutableVideoCompositionLayerInstruction;
        static videoCompositionLayerInstructionWithAssetTrack(assetTrack: AVAssetTrack): AVMutableVideoCompositionLayerInstruction;
        setCropRectangleAtTime(_: CGRect, at: CMTime): void;
        setCropRectangleRampFromStartCropRectangleToEndCropRectangleTimeRange(fromStartCropRectangle: CGRect, toEndCropRectangle: CGRect, timeRange: CMTimeRange): void;
        setOpacityAtTime(_: number, at: CMTime): void;
        setOpacityRampFromStartOpacityToEndOpacityTimeRange(fromStartOpacity: number, toEndOpacity: number, timeRange: CMTimeRange): void;
        setTransformAtTime(_: CGAffineTransform, at: CMTime): void;
        setTransformRampFromStartTransformToEndTransformTimeRange(fromStart: CGAffineTransform, toEnd: CGAffineTransform, timeRange: CMTimeRange): void;
    }
    class AVOutputSettingsAssistant extends NSObject {
        static availableOutputSettingsPresets(): string[];
        audioSettings: Map<string, any>;
        outputFileType: string;
        sourceAudioFormat: any;
        setSourceAudioFormat(_: any): any;
        sourceVideoAverageFrameDuration: CMTime;
        setSourceVideoAverageFrameDuration(_: CMTime): any;
        sourceVideoFormat: any;
        setSourceVideoFormat(_: any): any;
        sourceVideoMinFrameDuration: CMTime;
        setSourceVideoMinFrameDuration(_: CMTime): any;
        videoSettings: Map<string, any>;
    }
    class AVPersistableContentKeyRequest extends AVContentKeyRequest {
        persistableContentKeyFromKeyVendorResponseOptionsError(options: NSData, error?: Map<string, any>): NSData;
    }
    class AVPlayer extends NSObject {
        actionAtItemEnd: AVPlayer.ActionAtItemEnd;
        setActionAtItemEnd(_: AVPlayer.ActionAtItemEnd): any;
        allowsExternalPlayback: boolean;
        setAllowsExternalPlayback(_: boolean): any;
        appliesMediaSelectionCriteriaAutomatically: boolean;
        setAppliesMediaSelectionCriteriaAutomatically(_: boolean): any;
        audioOutputDeviceUniqueID: string;
        setAudioOutputDeviceUniqueID(_: string): any;
        automaticallyWaitsToMinimizeStalling: boolean;
        setAutomaticallyWaitsToMinimizeStalling(_: boolean): any;
        currentItem: AVPlayerItem;
        error: NSError;
        isExternalPlaybackActive: boolean;
        masterClock: any;
        setMasterClock(_: any): any;
        isMuted: boolean;
        setMuted(_: boolean): any;
        outputObscuredDueToInsufficientExternalProtection: boolean;
        preferredVideoDecoderGPURegistryID: number;
        setPreferredVideoDecoderGPURegistryID(_: number): any;
        preventsDisplaySleepDuringVideoPlayback: boolean;
        setPreventsDisplaySleepDuringVideoPlayback(_: boolean): any;
        rate: number;
        setRate(_: number): any;
        reasonForWaitingToPlay: string;
        status: AVPlayer.Status;
        timeControlStatus: AVPlayer.TimeControlStatus;
        volume: number;
        setVolume(_: number): any;
        static eligibleForHDRPlayback: boolean;
        addBoundaryTimeObserverWithForTimesQueueUsing(forTimes: NSValue[], queue?: NSObject, using?: () => void): any;
        addPeriodicTimeObserverWithForIntervalQueueUsing(forInterval: CMTime, queue?: NSObject, using?: (p1: CMTime) => void): any;
        cancelPendingPrerolls(): void;
        currentTime(): CMTime;
        static createWithPlayerItem(playerItem?: AVPlayerItem): AVPlayer;
        static createWithUrl(URL: NSURL): AVPlayer;
        mediaSelectionCriteriaForMediaCharacteristic(forMediaCharacteristic: string): AVPlayerMediaSelectionCriteria;
        pause(): void;
        play(): void;
        playImmediatelyAtRate(atRate: number): void;
        prerollWithAtRateCompletionHandler(atRate: number, completionHandler?: (p1: boolean) => void): void;
        removeTimeObserver(_: any): void;
        replaceCurrentItemWithPlayerItem(with_?: AVPlayerItem): void;
        seekToDate(to: Date): void;
        seekWithToCompletionHandler(to: Date, completionHandler: (p1: boolean) => void): void;
        seekToTime(to: CMTime): void;
        seekWithToCompletionHandler(to: CMTime, completionHandler: (p1: boolean) => void): void;
        seekToTimeToleranceBeforeToleranceAfter(to: CMTime, toleranceBefore: CMTime, toleranceAfter: CMTime): void;
        seekWithToToleranceBeforeToleranceAfterCompletionHandler(to: CMTime, toleranceBefore: CMTime, toleranceAfter: CMTime, completionHandler: (p1: boolean) => void): void;
        setMediaSelectionCriteriaForMediaCharacteristic(_?: AVPlayerMediaSelectionCriteria, forMediaCharacteristic?: string): void;
        setRateTimeAtHostTime(_: number, time: CMTime, atHostTime: CMTime): void;
    }
    class AVPlayerItem extends NSObject {
        isApplicationAuthorizedForPlayback: boolean;
        asset: AVAsset;
        audioMix: AVAudioMix;
        setAudioMix(_: AVAudioMix): any;
        isAudioSpatializationAllowed: boolean;
        setAudioSpatializationAllowed(_: boolean): any;
        audioTimePitchAlgorithm: string;
        setAudioTimePitchAlgorithm(_: string): any;
        isAuthorizationRequiredForPlayback: boolean;
        automaticallyLoadedAssetKeys: string[];
        automaticallyPreservesTimeOffsetFromLive: boolean;
        setAutomaticallyPreservesTimeOffsetFromLive(_: boolean): any;
        canPlayFastForward: boolean;
        canPlayFastReverse: boolean;
        canPlayReverse: boolean;
        canPlaySlowForward: boolean;
        canPlaySlowReverse: boolean;
        canStepBackward: boolean;
        canStepForward: boolean;
        canUseNetworkResourcesForLiveStreamingWhilePaused: boolean;
        setCanUseNetworkResourcesForLiveStreamingWhilePaused(_: boolean): any;
        configuredTimeOffsetFromLive: CMTime;
        setConfiguredTimeOffsetFromLive(_: CMTime): any;
        contentAuthorizationRequestStatus: AVContentAuthorizationStatus;
        isContentAuthorizedForPlayback: boolean;
        currentMediaSelection: AVMediaSelection;
        customVideoCompositor: AVVideoCompositing;
        duration: CMTime;
        error: NSError;
        forwardPlaybackEndTime: CMTime;
        setForwardPlaybackEndTime(_: CMTime): any;
        loadedTimeRanges: NSValue[];
        mediaDataCollectors: AVPlayerItemMediaDataCollector[];
        outputs: AVPlayerItemOutput[];
        isPlaybackBufferEmpty: boolean;
        isPlaybackBufferFull: boolean;
        isPlaybackLikelyToKeepUp: boolean;
        preferredForwardBufferDuration: number;
        setPreferredForwardBufferDuration(_: number): any;
        preferredMaximumResolution: CGSize;
        setPreferredMaximumResolution(_: CGSize): any;
        preferredPeakBitRate: number;
        setPreferredPeakBitRate(_: number): any;
        presentationSize: CGSize;
        recommendedTimeOffsetFromLive: CMTime;
        reversePlaybackEndTime: CMTime;
        setReversePlaybackEndTime(_: CMTime): any;
        seekableTimeRanges: NSValue[];
        seekingWaitsForVideoCompositionRendering: boolean;
        setSeekingWaitsForVideoCompositionRendering(_: boolean): any;
        status: AVPlayerItem.Status;
        textStyleRules: AVTextStyleRule[];
        setTextStyleRules(_: AVTextStyleRule[]): any;
        timebase: any;
        tracks: AVPlayerItemTrack[];
        videoApertureMode: string;
        setVideoApertureMode(_: string): any;
        videoComposition: AVVideoComposition;
        setVideoComposition(_: AVVideoComposition): any;
        accessLog(): AVPlayerItemAccessLog;
        addMediaDataCollector(_: AVPlayerItemMediaDataCollector): void;
        addOutput(_: AVPlayerItemOutput): void;
        cancelContentAuthorizationRequest(): void;
        cancelPendingSeeks(): void;
        currentDate(): Date;
        currentTime(): CMTime;
        errorLog(): AVPlayerItemErrorLog;
        static createWithAsset(asset: AVAsset): AVPlayerItem;
        static createWithAssetAutomaticallyLoadedAssetKeys(asset: AVAsset, automaticallyLoadedAssetKeys?: string[]): AVPlayerItem;
        static createWithUrl(URL: NSURL): AVPlayerItem;
        removeMediaDataCollector(_: AVPlayerItemMediaDataCollector): void;
        removeOutput(_: AVPlayerItemOutput): void;
        requestContentAuthorizationAsynchronouslyWithWithTimeoutIntervalCompletionHandler(withTimeoutInterval: number, completionHandler: () => void): void;
        seekWithToCompletionHandler(to: Date, completionHandler?: (p1: boolean) => void): boolean;
        seekWithToCompletionHandler(to: CMTime, completionHandler?: (p1: boolean) => void): void;
        seekWithToToleranceBeforeToleranceAfterCompletionHandler(to: CMTime, toleranceBefore: CMTime, toleranceAfter: CMTime, completionHandler?: (p1: boolean) => void): void;
        selectMediaOptionInMediaSelectionGroup(_?: AVMediaSelectionOption, in_?: AVMediaSelectionGroup): void;
        selectMediaOptionAutomaticallyInMediaSelectionGroup(in_: AVMediaSelectionGroup): void;
        stepByCount(byCount: number): void;
    }
    class AVPlayerItemAccessLog extends NSObject {
        events: AVPlayerItemAccessLogEvent[];
        extendedLogDataStringEncoding: number;
        extendedLogData(): NSData;
    }
    class AVPlayerItemAccessLogEvent extends NSObject {
        URI: string;
        averageAudioBitrate: number;
        averageVideoBitrate: number;
        downloadOverdue: number;
        durationWatched: number;
        indicatedAverageBitrate: number;
        indicatedBitrate: number;
        mediaRequestsWWAN: number;
        numberOfBytesTransferred: number;
        numberOfDroppedVideoFrames: number;
        numberOfMediaRequests: number;
        numberOfServerAddressChanges: number;
        numberOfStalls: number;
        observedBitrate: number;
        observedBitrateStandardDeviation: number;
        observedMaxBitrate: number;
        observedMinBitrate: number;
        playbackSessionID: string;
        playbackStartDate: Date;
        playbackStartOffset: number;
        playbackType: string;
        segmentsDownloadedDuration: number;
        serverAddress: string;
        startupTime: number;
        switchBitrate: number;
        transferDuration: number;
    }
    class AVPlayerItemErrorLog extends NSObject {
        events: AVPlayerItemErrorLogEvent[];
        extendedLogDataStringEncoding: number;
        extendedLogData(): NSData;
    }
    class AVPlayerItemErrorLogEvent extends NSObject {
        URI: string;
        date: Date;
        errorComment: string;
        errorDomain: string;
        errorStatusCode: number;
        playbackSessionID: string;
        serverAddress: string;
    }
    class AVPlayerItemLegibleOutput extends AVPlayerItemOutput {
        advanceIntervalForDelegateInvocation: number;
        setAdvanceIntervalForDelegateInvocation(_: number): any;
        delegate: AVPlayerItemLegibleOutputPushDelegate;
        delegateQueue: NSObject;
        textStylingResolution: string;
        setTextStylingResolution(_: string): any;
        static createWithMediaSubtypesForNativeRepresentation(mediaSubtypesForNativeRepresentation: number[]): AVPlayerItemLegibleOutput;
        setDelegateQueue(_?: AVPlayerItemLegibleOutputPushDelegate, queue?: NSObject): void;
    }
    interface AVPlayerItemLegibleOutputPushDelegate extends AVPlayerItemOutputPushDelegate {
        legibleOutputDidOutputAttributedStringsNativeSampleBuffersForItemTime?(_: AVPlayerItemLegibleOutput, didOutputAttributedStrings: NSAttributedString[], nativeSampleBuffers: any[], forItemTime: CMTime): void;
    }
    class AVPlayerItemMediaDataCollector extends NSObject {
    }
    class AVPlayerItemMetadataCollector extends AVPlayerItemMediaDataCollector {
        delegate: AVPlayerItemMetadataCollectorPushDelegate;
        delegateQueue: NSObject;
        static createWithIdentifiersClassifyingLabels(identifiers?: string[], classifyingLabels?: string[]): AVPlayerItemMetadataCollector;
        setDelegateQueue(_?: AVPlayerItemMetadataCollectorPushDelegate, queue?: NSObject): void;
    }
    interface AVPlayerItemMetadataCollectorPushDelegate extends NSObject {
        metadataCollectorDidCollectDateRangeMetadataGroupsIndexesOfNewGroupsIndexesOfModifiedGroups(_: AVPlayerItemMetadataCollector, didCollect: AVDateRangeMetadataGroup[], indexesOfNewGroups: NSIndexSet, indexesOfModifiedGroups: NSIndexSet): void;
    }
    class AVPlayerItemMetadataOutput extends AVPlayerItemOutput {
        advanceIntervalForDelegateInvocation: number;
        setAdvanceIntervalForDelegateInvocation(_: number): any;
        delegate: AVPlayerItemMetadataOutputPushDelegate;
        delegateQueue: NSObject;
        static createWithIdentifiers(identifiers?: string[]): AVPlayerItemMetadataOutput;
        setDelegateQueue(_?: AVPlayerItemMetadataOutputPushDelegate, queue?: NSObject): void;
    }
    interface AVPlayerItemMetadataOutputPushDelegate extends AVPlayerItemOutputPushDelegate {
        metadataOutputDidOutputTimedMetadataGroupsFromPlayerItemTrack?(_: AVPlayerItemMetadataOutput, didOutputTimedMetadataGroups: AVTimedMetadataGroup[], from?: AVPlayerItemTrack): void;
    }
    class AVPlayerItemOutput extends NSObject {
        suppressesPlayerRendering: boolean;
        setSuppressesPlayerRendering(_: boolean): any;
        itemTimeForCVTimeStamp(for_: CVTimeStamp): CMTime;
        itemTimeForHostTime(forHostTime: number): CMTime;
        itemTimeForMachAbsoluteTime(forMachAbsoluteTime: number): CMTime;
    }
    interface AVPlayerItemOutputPullDelegate extends NSObject {
        outputMediaDataWillChange?(_: AVPlayerItemOutput): void;
        outputSequenceWasFlushed?(_: AVPlayerItemOutput): void;
    }
    interface AVPlayerItemOutputPushDelegate extends NSObject {
        outputSequenceWasFlushed?(_: AVPlayerItemOutput): void;
    }
    class AVPlayerItemTrack extends NSObject {
        assetTrack: AVAssetTrack;
        currentVideoFrameRate: number;
        isEnabled: boolean;
        setEnabled(_: boolean): any;
        videoFieldMode: string;
        setVideoFieldMode(_: string): any;
    }
    class AVPlayerItemVideoOutput extends AVPlayerItemOutput {
        delegate: AVPlayerItemOutputPullDelegate;
        delegateQueue: NSObject;
        copyPixelBufferForItemTimeItemTimeForDisplay(forItemTime: CMTime, itemTimeForDisplay?: CMTime): any;
        hasNewPixelBufferForItemTime(forItemTime: CMTime): boolean;
        static createWithOutputSettings(outputSettings?: Map<string, any>): AVPlayerItemVideoOutput;
        static createWithPixelBufferAttributes(pixelBufferAttributes?: Map<string, any>): AVPlayerItemVideoOutput;
        requestNotificationOfMediaDataChangeWithAdvanceInterval(withAdvanceInterval: number): void;
        setDelegateQueue(_?: AVPlayerItemOutputPullDelegate, queue?: NSObject): void;
    }
    class AVPlayerLayer extends CALayer {
        pixelBufferAttributes: Map<string, any>;
        setPixelBufferAttributes(_: Map<string, any>): any;
        player: AVPlayer;
        setPlayer(_: AVPlayer): any;
        isReadyForDisplay: boolean;
        videoGravity: string;
        setVideoGravity(_: string): any;
        videoRect: CGRect;
    }
    class AVPlayerLooper extends NSObject {
        error: NSError;
        loopCount: number;
        loopingPlayerItems: AVPlayerItem[];
        status: AVPlayerLooper.Status;
        disableLooping(): void;
        static createWithPlayerTemplateItemTimeRange(player: AVQueuePlayer, templateItem: AVPlayerItem, timeRange: CMTimeRange): AVPlayerLooper;
    }
    class AVPlayerMediaSelectionCriteria extends NSObject {
        preferredLanguages: string[];
        preferredMediaCharacteristics: string[];
        principalMediaCharacteristics: string[];
        static createWithPreferredLanguagesPreferredMediaCharacteristics(preferredLanguages?: string[], preferredMediaCharacteristics?: string[]): AVPlayerMediaSelectionCriteria;
        static createWithPrincipalMediaCharacteristicsPreferredLanguagesPreferredMediaCharacteristics(principalMediaCharacteristics?: string[], preferredLanguages?: string[], preferredMediaCharacteristics?: string[]): AVPlayerMediaSelectionCriteria;
    }
    class AVPortraitEffectsMatte extends NSObject {
        static portraitEffectsMatteFromDictionaryRepresentationError(error: Map<any, any>): AVPortraitEffectsMatte;
        mattingImage: any;
        pixelFormatType: number;
        dictionaryRepresentationForAuxiliaryDataType(forAuxiliaryDataType?: string): Map<any, any>;
        portraitEffectsMatteByApplyingExifOrientation(_: CGImagePropertyOrientation): AVPortraitEffectsMatte;
        portraitEffectsMatteByReplacingPortraitEffectsMatteWithPixelBufferError(error: any): AVPortraitEffectsMatte;
    }
    class AVQueuePlayer extends AVPlayer {
        static queuePlayerWithItems(items: AVPlayerItem[]): AVQueuePlayer;
        advanceToNextItem(): void;
        canInsertItemAfterItem(_: AVPlayerItem, after?: AVPlayerItem): boolean;
        static createWithItems(items: AVPlayerItem[]): AVQueuePlayer;
        insertItemAfterItem(_: AVPlayerItem, after?: AVPlayerItem): void;
        items(): AVPlayerItem[];
        removeAllItems(): void;
        removeItem(_: AVPlayerItem): void;
    }
    interface AVQueuedSampleBufferRendering extends NSObject {
        isReadyForMoreMediaData: boolean;
        timebase: any;
        enqueueSampleBuffer(_: any): void;
        flush(): void;
        requestMediaDataWhenReadyWithOnUsing(on: NSObject, using: () => void): void;
        stopRequestingMediaData(): void;
    }
    class AVRouteDetector extends NSObject {
        multipleRoutesDetected: boolean;
        isRouteDetectionEnabled: boolean;
        setRouteDetectionEnabled(_: boolean): any;
    }
    class AVSampleBufferAudioRenderer extends NSObject {
        audioOutputDeviceUniqueID: string;
        setAudioOutputDeviceUniqueID(_: string): any;
        audioTimePitchAlgorithm: string;
        setAudioTimePitchAlgorithm(_: string): any;
        error: NSError;
        isMuted: boolean;
        setMuted(_: boolean): any;
        status: AVQueuedSampleBufferRenderingStatus;
        volume: number;
        setVolume(_: number): any;
        flushWithFromSourceTimeCompletionHandler(fromSourceTime: CMTime, completionHandler: (p1: boolean) => void): void;
    }
    class AVSampleBufferDisplayLayer extends CALayer {
        controlTimebase: any;
        setControlTimebase(_: any): any;
        error: NSError;
        preventsCapture: boolean;
        setPreventsCapture(_: boolean): any;
        preventsDisplaySleepDuringVideoPlayback: boolean;
        setPreventsDisplaySleepDuringVideoPlayback(_: boolean): any;
        status: AVQueuedSampleBufferRenderingStatus;
        videoGravity: string;
        setVideoGravity(_: string): any;
        flushAndRemoveImage(): void;
    }
    class AVSampleBufferGenerator extends NSObject {
        static notifyOfDataReadyForCompletionHandler(for_: any, completionHandler: (p1: boolean, p2: NSError) => void): void;
        createSampleBufferForRequest(for_: AVSampleBufferRequest): any;
        static createWithAssetTimebase(asset: AVAsset, timebase?: any): AVSampleBufferGenerator;
    }
    class AVSampleBufferRenderSynchronizer extends NSObject {
        rate: number;
        setRate(_: number): any;
        renderers: AVQueuedSampleBufferRendering[];
        timebase: any;
        addBoundaryTimeObserverWithForTimesQueueUsing(forTimes: NSValue[], queue?: NSObject, using?: () => void): any;
        addPeriodicTimeObserverWithForIntervalQueueUsing(forInterval: CMTime, queue?: NSObject, using?: (p1: CMTime) => void): any;
        addRenderer(_: AVQueuedSampleBufferRendering): void;
        currentTime(): CMTime;
        removeRendererAtCompletionHandler(_: AVQueuedSampleBufferRendering, at: CMTime, completionHandler?: (p1: boolean) => void): void;
        removeTimeObserver(_: any): void;
        setRateTime(_: number, time: CMTime): void;
    }
    class AVSampleBufferRequest extends NSObject {
        direction: AVSampleBufferRequest.Direction;
        setDirection(_: AVSampleBufferRequest.Direction): any;
        limitCursor: AVSampleCursor;
        setLimitCursor(_: AVSampleCursor): any;
        maxSampleCount: number;
        setMaxSampleCount(_: number): any;
        mode: AVSampleBufferRequest.Mode;
        setMode(_: AVSampleBufferRequest.Mode): any;
        overrideTime: CMTime;
        setOverrideTime(_: CMTime): any;
        preferredMinSampleCount: number;
        setPreferredMinSampleCount(_: number): any;
        startCursor: AVSampleCursor;
        static createWithStartCursor(startCursor: AVSampleCursor): AVSampleBufferRequest;
    }
    class AVSampleCursor extends NSObject {
        currentChunkInfo: AVSampleCursorChunkInfo;
        currentChunkStorageRange: AVSampleCursorStorageRange;
        currentChunkStorageURL: NSURL;
        currentSampleAudioDependencyInfo: AVSampleCursorAudioDependencyInfo;
        currentSampleDependencyInfo: AVSampleCursorDependencyInfo;
        currentSampleDuration: CMTime;
        currentSampleIndexInChunk: number;
        currentSampleStorageRange: AVSampleCursorStorageRange;
        currentSampleSyncInfo: AVSampleCursorSyncInfo;
        decodeTimeStamp: CMTime;
        presentationTimeStamp: CMTime;
        samplesRequiredForDecoderRefresh: number;
        comparePositionInDecodeOrderWithPositionOfCursor(withPositionOf: AVSampleCursor): ComparisonResult;
        copyCurrentSampleFormatDescription(): any;
        samplesWithEarlierDecodeTimeStampsMayHaveLaterPresentationTimeStampsThanCursor(laterThan: AVSampleCursor): boolean;
        samplesWithLaterDecodeTimeStampsMayHaveEarlierPresentationTimeStampsThanCursor(earlierThan: AVSampleCursor): boolean;
        stepByDecodeTimeWasPinned(byDecodeTime: CMTime, wasPinned?: boolean): CMTime;
        stepByPresentationTimeWasPinned(byPresentationTime: CMTime, wasPinned?: boolean): CMTime;
        stepInDecodeOrderByCount(byCount: number): number;
        stepInPresentationOrderByCount(byCount: number): number;
    }
    class AVSemanticSegmentationMatte extends NSObject {
        static semanticSegmentationMatteFromImageSourceAuxiliaryDataTypeDictionaryRepresentationError(dictionaryRepresentation: string, error: Map<any, any>): AVSemanticSegmentationMatte;
        matteType: string;
        mattingImage: any;
        pixelFormatType: number;
        dictionaryRepresentationForAuxiliaryDataType(forAuxiliaryDataType?: string): Map<any, any>;
        semanticSegmentationMatteByApplyingExifOrientation(_: CGImagePropertyOrientation): AVSemanticSegmentationMatte;
        semanticSegmentationMatteByReplacingSemanticSegmentationMatteWithPixelBufferError(error: any): AVSemanticSegmentationMatte;
    }
    class AVSpeechSynthesisVoice extends NSObject {
        static currentLanguageCode(): string;
        static speechVoices(): AVSpeechSynthesisVoice[];
        static voiceWithIdentifier(identifier: string): AVSpeechSynthesisVoice;
        static voiceWithLanguage(language?: string): AVSpeechSynthesisVoice;
        audioFileSettings: Map<string, any>;
        gender: AVSpeechSynthesisVoiceGender;
        identifier: string;
        language: string;
        name: string;
        quality: AVSpeechSynthesisVoiceQuality;
    }
    class AVSpeechSynthesizer extends NSObject {
        delegate: AVSpeechSynthesizerDelegate;
        setDelegate(_: AVSpeechSynthesizerDelegate): any;
        isPaused: boolean;
        isSpeaking: boolean;
        continueSpeaking(): boolean;
        pauseSpeakingAtBoundary(at: AVSpeechBoundary): boolean;
        speakUtterance(_: AVSpeechUtterance): void;
        stopSpeakingAtBoundary(at: AVSpeechBoundary): boolean;
        writeToBufferCallback(_: AVSpeechUtterance, toBufferCallback: (p1: AVAudioBuffer) => void): void;
    }
    interface AVSpeechSynthesizerDelegate extends NSObject {
        speechSynthesizerDidStartSpeechUtterance?(_: AVSpeechSynthesizer, didStart: AVSpeechUtterance): void;
        speechSynthesizerDidFinishSpeechUtterance?(_: AVSpeechSynthesizer, didFinish: AVSpeechUtterance): void;
        speechSynthesizerDidPauseSpeechUtterance?(_: AVSpeechSynthesizer, didPause: AVSpeechUtterance): void;
        speechSynthesizerDidContinueSpeechUtterance?(_: AVSpeechSynthesizer, didContinue: AVSpeechUtterance): void;
        speechSynthesizerDidCancelSpeechUtterance?(_: AVSpeechSynthesizer, didCancel: AVSpeechUtterance): void;
        speechSynthesizerWillSpeakRangeOfSpeechStringUtterance?(_: AVSpeechSynthesizer, willSpeakRangeOfSpeechString: NSRange, utterance: AVSpeechUtterance): void;
    }
    class AVSpeechUtterance extends NSObject {
        static speechUtteranceWithAttributedString(attributedString: NSAttributedString): AVSpeechUtterance;
        static speechUtteranceWithString(string: string): AVSpeechUtterance;
        attributedSpeechString: NSAttributedString;
        pitchMultiplier: number;
        setPitchMultiplier(_: number): any;
        postUtteranceDelay: number;
        setPostUtteranceDelay(_: number): any;
        preUtteranceDelay: number;
        setPreUtteranceDelay(_: number): any;
        rate: number;
        setRate(_: number): any;
        speechString: string;
        voice: AVSpeechSynthesisVoice;
        setVoice(_: AVSpeechSynthesisVoice): any;
        volume: number;
        setVolume(_: number): any;
        static createWithAttributedString(attributedString: NSAttributedString): AVSpeechUtterance;
        static createWithString(string: string): AVSpeechUtterance;
    }
    class AVSynchronizedLayer extends CALayer {
        playerItem: AVPlayerItem;
        setPlayerItem(_: AVPlayerItem): any;
    }
    class AVTextStyleRule extends NSObject {
        static propertyListForTextStyleRules(for_: AVTextStyleRule[]): any;
        static textStyleRulesFromPropertyList(fromPropertyList: any): AVTextStyleRule[];
        textMarkupAttributes: Map<string, any>;
        textSelector: string;
        static createWithTextMarkupAttributes(textMarkupAttributes: Map<string, any>): AVTextStyleRule;
        static createWithTextMarkupAttributesTextSelector(textMarkupAttributes: Map<string, any>, textSelector?: string): AVTextStyleRule;
    }
    class AVTimedMetadataGroup extends AVMetadataGroup {
        timeRange: CMTimeRange;
        copyFormatDescription(): any;
        static createWithItemsTimeRange(items: AVMetadataItem[], timeRange: CMTimeRange): AVTimedMetadataGroup;
        static createWithSampleBuffer(sampleBuffer: any): AVTimedMetadataGroup;
    }
    class AVURLAsset extends AVAsset {
        static URLAssetWithURLOptions(url: NSURL, options?: Map<string, any>): AVURLAsset;
        static audiovisualMIMETypes(): string[];
        static audiovisualTypes(): string[];
        static isPlayableExtendedMIMEType(_: string): boolean;
        URL: NSURL;
        assetCache: AVAssetCache;
        resourceLoader: AVAssetResourceLoader;
        compatibleTrackForCompositionTrack(for_: AVCompositionTrack): AVAssetTrack;
        static createWithUrlOptions(URL: NSURL, options?: Map<string, any>): AVURLAsset;
    }
    interface AVVideoCompositing extends NSObject {
        requiredPixelBufferAttributesForRenderContext: Map<string, any>;
        sourcePixelBufferAttributes: Map<string, any>;
        supportsWideColorSourceFrames?: boolean;
        anticipateRenderingUsingHint?(using: AVVideoCompositionRenderHint): void;
        cancelAllPendingVideoCompositionRequests?(): void;
        prerollForRenderingUsingHint?(using: AVVideoCompositionRenderHint): void;
        renderContextChanged(_: AVVideoCompositionRenderContext): void;
        startVideoCompositionRequest(_: AVAsynchronousVideoCompositionRequest): void;
    }
    class AVVideoComposition extends NSObject {
        animationTool: AVVideoCompositionCoreAnimationTool;
        colorPrimaries: string;
        colorTransferFunction: string;
        colorYCbCrMatrix: string;
        customVideoCompositorClass: typeof NSObject;
        frameDuration: CMTime;
        instructions: AVVideoCompositionInstruction[];
        renderScale: number;
        renderSize: CGSize;
        sourceTrackIDForFrameTiming: number;
        isValidForAssetTimeRangeValidationDelegate(for_?: AVAsset, timeRange?: CMTimeRange, validationDelegate?: AVVideoCompositionValidationHandling): boolean;
    }
    class AVVideoCompositionCoreAnimationTool extends NSObject {
        static videoCompositionCoreAnimationToolWithAdditionalLayerAsTrackID(additionalLayer: CALayer, asTrackID: number): AVVideoCompositionCoreAnimationTool;
        static videoCompositionCoreAnimationToolWithPostProcessingAsVideoLayerInLayer(postProcessingAsVideoLayer: CALayer, in_: CALayer): AVVideoCompositionCoreAnimationTool;
        static videoCompositionCoreAnimationToolWithPostProcessingAsVideoLayersInLayer(postProcessingAsVideoLayers: CALayer[], in_: CALayer): AVVideoCompositionCoreAnimationTool;
    }
    class AVVideoCompositionInstruction extends NSObject {
        backgroundColor: any;
        layerInstructions: AVVideoCompositionLayerInstruction[];
    }
    interface AVVideoCompositionInstruction extends NSObject {
        containsTweening: boolean;
        enablePostProcessing: boolean;
        passthroughTrackID: number;
        requiredSourceTrackIDs: NSValue[];
        timeRange: CMTimeRange;
    }
    class AVVideoCompositionLayerInstruction extends NSObject {
        trackID: number;
        getCropRectangleRampForTimeStartCropRectangleEndCropRectangleTimeRange(for_: CMTime, startCropRectangle?: NSRect, endCropRectangle?: NSRect, timeRange?: CMTimeRange): boolean;
        getOpacityRampForTimeStartOpacityEndOpacityTimeRange(for_: CMTime, startOpacity?: number, endOpacity?: number, timeRange?: CMTimeRange): boolean;
        getTransformRampForTimeStartTransformEndTransformTimeRange(for_: CMTime, start?: CGAffineTransform, end?: CGAffineTransform, timeRange?: CMTimeRange): boolean;
    }
    class AVVideoCompositionRenderContext extends NSObject {
        edgeWidths: AVEdgeWidths;
        highQualityRendering: boolean;
        pixelAspectRatio: AVPixelAspectRatio;
        renderScale: number;
        renderTransform: CGAffineTransform;
        size: CGSize;
        videoComposition: AVVideoComposition;
        newPixelBuffer(): any;
    }
    class AVVideoCompositionRenderHint extends NSObject {
        endCompositionTime: CMTime;
        startCompositionTime: CMTime;
    }
    interface AVVideoCompositionValidationHandling extends NSObject {
        videoCompositionShouldContinueValidatingAfterFindingInvalidTimeRangeInInstruction?(_: AVVideoComposition, shouldContinueValidatingAfterFindingInvalidTimeRangeIn: AVVideoCompositionInstruction): boolean;
        videoCompositionShouldContinueValidatingAfterFindingInvalidTrackIDInInstructionLayerInstructionAsset?(_: AVVideoComposition, shouldContinueValidatingAfterFindingInvalidTrackIDIn: AVVideoCompositionInstruction, layerInstruction: AVVideoCompositionLayerInstruction, asset: AVAsset): boolean;
        videoCompositionShouldContinueValidatingAfterFindingEmptyTimeRange?(_: AVVideoComposition, shouldContinueValidatingAfterFindingEmptyTimeRange: CMTimeRange): boolean;
        videoCompositionShouldContinueValidatingAfterFindingInvalidValueForKey?(_: AVVideoComposition, shouldContinueValidatingAfterFindingInvalidValueForKey: string): boolean;
    }
    class AVCaptureView extends NSView {
        controlsStyle: AVCaptureViewControlsStyle;
        setControlsStyle(_: AVCaptureViewControlsStyle): any;
        delegate: AVCaptureViewDelegate;
        setDelegate(_: AVCaptureViewDelegate): any;
        fileOutput: AVCaptureFileOutput;
        session: AVCaptureSession;
        videoGravity: string;
        setVideoGravity(_: string): any;
        setSessionShowVideoPreviewShowAudioPreview(_?: AVCaptureSession, showVideoPreview?: boolean, showAudioPreview?: boolean): void;
    }
    interface AVCaptureViewDelegate extends NSObject {
        captureViewStartRecordingToFileOutput(_: AVCaptureView, startRecordingTo: AVCaptureFileOutput): void;
    }
    class AVPictureInPictureController extends NSObject {
        static isPictureInPictureSupported(): boolean;
        delegate: AVPictureInPictureControllerDelegate;
        setDelegate(_: AVPictureInPictureControllerDelegate): any;
        isPictureInPictureActive: boolean;
        isPictureInPicturePossible: boolean;
        isPictureInPictureSuspended: boolean;
        playerLayer: AVPlayerLayer;
        static pictureInPictureButtonStartImage: NSImage;
        static pictureInPictureButtonStopImage: NSImage;
        static createWithPlayerLayer(playerLayer: AVPlayerLayer): AVPictureInPictureController;
        startPictureInPicture(): void;
        stopPictureInPicture(): void;
    }
    interface AVPictureInPictureControllerDelegate extends NSObject {
        pictureInPictureControllerFailedToStartPictureInPictureWithError?(_: AVPictureInPictureController, failedToStartPictureInPictureWithError: NSError): void;
        pictureInPictureControllerWithRestoreUserInterfaceForPictureInPictureStopWithCompletionHandler?(_: AVPictureInPictureController, restoreUserInterfaceForPictureInPictureStopWithCompletionHandler: (p1: boolean) => void): void;
        pictureInPictureControllerDidStartPictureInPicture?(_: AVPictureInPictureController): void;
        pictureInPictureControllerDidStopPictureInPicture?(_: AVPictureInPictureController): void;
        pictureInPictureControllerWillStartPictureInPicture?(_: AVPictureInPictureController): void;
        pictureInPictureControllerWillStopPictureInPicture?(_: AVPictureInPictureController): void;
    }
    class AVPlayerView extends NSView {
        actionPopUpButtonMenu: NSMenu;
        setActionPopUpButtonMenu(_: NSMenu): any;
        allowsPictureInPicturePlayback: boolean;
        setAllowsPictureInPicturePlayback(_: boolean): any;
        canBeginTrimming: boolean;
        contentOverlayView: NSView;
        controlsStyle: AVPlayerViewControlsStyle;
        setControlsStyle(_: AVPlayerViewControlsStyle): any;
        pictureInPictureDelegate: AVPlayerViewPictureInPictureDelegate;
        setPictureInPictureDelegate(_: AVPlayerViewPictureInPictureDelegate): any;
        player: AVPlayer;
        setPlayer(_: AVPlayer): any;
        isReadyForDisplay: boolean;
        showsFrameSteppingButtons: boolean;
        setShowsFrameSteppingButtons(_: boolean): any;
        showsFullScreenToggleButton: boolean;
        setShowsFullScreenToggleButton(_: boolean): any;
        showsSharingServiceButton: boolean;
        setShowsSharingServiceButton(_: boolean): any;
        showsTimecodes: boolean;
        setShowsTimecodes(_: boolean): any;
        updatesNowPlayingInfoCenter: boolean;
        setUpdatesNowPlayingInfoCenter(_: boolean): any;
        videoBounds: CGRect;
        videoGravity: string;
        setVideoGravity(_: string): any;
        beginTrimmingWithCompletionHandler(completionHandler?: (p1: AVPlayerViewTrimResult) => void): void;
        flashChapterNumberChapterTitle(_: number, chapterTitle?: string): void;
    }
    interface AVPlayerViewPictureInPictureDelegate extends NSObject {
        playerViewFailedToStartPictureInPictureWithError?(_: AVPlayerView, failedToStartPictureInPictureWithError: NSError): void;
        playerViewWithRestoreUserInterfaceForPictureInPictureStopWithCompletionHandler?(_: AVPlayerView, restoreUserInterfaceForPictureInPictureStopWithCompletionHandler: (p1: boolean) => void): void;
        playerViewDidStartPictureInPicture?(inPicture: AVPlayerView): void;
        playerViewDidStopPictureInPicture?(inPicture: AVPlayerView): void;
        playerViewShouldAutomaticallyDismissAtPictureInPictureStart?(inPictureStart: AVPlayerView): boolean;
        playerViewWillStartPictureInPicture?(inPicture: AVPlayerView): void;
        playerViewWillStopPictureInPicture?(inPicture: AVPlayerView): void;
    }
    class AVRoutePickerView extends NSView {
        delegate: AVRoutePickerViewDelegate;
        setDelegate(_: AVRoutePickerViewDelegate): any;
        player: AVPlayer;
        setPlayer(_: AVPlayer): any;
        isRoutePickerButtonBordered: boolean;
        setRoutePickerButtonBordered(_: boolean): any;
        routePickerButtonColorForState(for_: AVRoutePickerViewButtonState): NSColor;
        setRoutePickerButtonColorForState(_?: NSColor, for_?: AVRoutePickerViewButtonState): void;
    }
    interface AVRoutePickerViewDelegate extends NSObject {
        routePickerViewDidEndPresentingRoutes?(_: AVRoutePickerView): void;
        routePickerViewWillBeginPresentingRoutes?(_: AVRoutePickerView): void;
    }
    class NSATSTypesetter extends NSTypesetter {
        static sharedTypesetter: NSATSTypesetter;
    }
    interface NSAccessibility extends NSObject {
        accessibilityActivationPoint: CGPoint;
        setAccessibilityActivationPoint(_: CGPoint): any;
        accessibilityAllowedValues: number[];
        setAccessibilityAllowedValues(_: number[]): any;
        isAccessibilityAlternateUIVisible: boolean;
        setAccessibilityAlternateUIVisible(_: boolean): any;
        accessibilityApplicationFocusedUIElement: any;
        setAccessibilityApplicationFocusedUIElement(_: any): any;
        accessibilityCancelButton: any;
        setAccessibilityCancelButton(_: any): any;
        accessibilityChildren: any[];
        setAccessibilityChildren(_: any[]): any;
        accessibilityChildrenInNavigationOrder: NSAccessibilityElement[];
        setAccessibilityChildrenInNavigationOrder(_: NSAccessibilityElement[]): any;
        accessibilityClearButton: any;
        setAccessibilityClearButton(_: any): any;
        accessibilityCloseButton: any;
        setAccessibilityCloseButton(_: any): any;
        accessibilityColumnCount: number;
        setAccessibilityColumnCount(_: number): any;
        accessibilityColumnHeaderUIElements: any[];
        setAccessibilityColumnHeaderUIElements(_: any[]): any;
        accessibilityColumnIndexRange: NSRange;
        setAccessibilityColumnIndexRange(_: NSRange): any;
        accessibilityColumns: any[];
        setAccessibilityColumns(_: any[]): any;
        accessibilityColumnTitles: any[];
        setAccessibilityColumnTitles(_: any[]): any;
        accessibilityContents: any[];
        setAccessibilityContents(_: any[]): any;
        accessibilityCriticalValue: any;
        setAccessibilityCriticalValue(_: any): any;
        accessibilityCustomActions: NSAccessibilityCustomAction[];
        setAccessibilityCustomActions(_: NSAccessibilityCustomAction[]): any;
        accessibilityCustomRotors: NSAccessibilityCustomRotor[];
        setAccessibilityCustomRotors(_: NSAccessibilityCustomRotor[]): any;
        accessibilityDecrementButton: any;
        setAccessibilityDecrementButton(_: any): any;
        accessibilityDefaultButton: any;
        setAccessibilityDefaultButton(_: any): any;
        isAccessibilityDisclosed: boolean;
        setAccessibilityDisclosed(_: boolean): any;
        accessibilityDisclosedByRow: any;
        setAccessibilityDisclosedByRow(_: any): any;
        accessibilityDisclosedRows: any;
        setAccessibilityDisclosedRows(_: any): any;
        accessibilityDisclosureLevel: number;
        setAccessibilityDisclosureLevel(_: number): any;
        accessibilityDocument: string;
        setAccessibilityDocument(_: string): any;
        isAccessibilityEdited: boolean;
        setAccessibilityEdited(_: boolean): any;
        isAccessibilityElement: boolean;
        setAccessibilityElement(_: boolean): any;
        isAccessibilityEnabled: boolean;
        setAccessibilityEnabled(_: boolean): any;
        isAccessibilityExpanded: boolean;
        setAccessibilityExpanded(_: boolean): any;
        accessibilityExtrasMenuBar: any;
        setAccessibilityExtrasMenuBar(_: any): any;
        accessibilityFilename: string;
        setAccessibilityFilename(_: string): any;
        isAccessibilityFocused: boolean;
        setAccessibilityFocused(_: boolean): any;
        accessibilityFocusedWindow: any;
        setAccessibilityFocusedWindow(_: any): any;
        accessibilityFrame: CGRect;
        setAccessibilityFrame(_: CGRect): any;
        isAccessibilityFrontmost: boolean;
        setAccessibilityFrontmost(_: boolean): any;
        accessibilityFullScreenButton: any;
        setAccessibilityFullScreenButton(_: any): any;
        accessibilityGrowArea: any;
        setAccessibilityGrowArea(_: any): any;
        accessibilityHandles: any[];
        setAccessibilityHandles(_: any[]): any;
        accessibilityHeader: any;
        setAccessibilityHeader(_: any): any;
        accessibilityHelp: string;
        setAccessibilityHelp(_: string): any;
        isAccessibilityHidden: boolean;
        setAccessibilityHidden(_: boolean): any;
        accessibilityHorizontalScrollBar: any;
        setAccessibilityHorizontalScrollBar(_: any): any;
        accessibilityHorizontalUnitDescription: string;
        setAccessibilityHorizontalUnitDescription(_: string): any;
        accessibilityHorizontalUnits: NSAccessibility.Units;
        setAccessibilityHorizontalUnits(_: NSAccessibility.Units): any;
        accessibilityIdentifier: string;
        setAccessibilityIdentifier(_: string): any;
        accessibilityIncrementButton: any;
        setAccessibilityIncrementButton(_: any): any;
        accessibilityIndex: number;
        setAccessibilityIndex(_: number): any;
        accessibilityInsertionPointLineNumber: number;
        setAccessibilityInsertionPointLineNumber(_: number): any;
        accessibilityLabel: string;
        setAccessibilityLabel(_: string): any;
        accessibilityLabelUIElements: any[];
        setAccessibilityLabelUIElements(_: any[]): any;
        accessibilityLabelValue: number;
        setAccessibilityLabelValue(_: number): any;
        accessibilityLinkedUIElements: any[];
        setAccessibilityLinkedUIElements(_: any[]): any;
        isAccessibilityMain: boolean;
        setAccessibilityMain(_: boolean): any;
        accessibilityMainWindow: any;
        setAccessibilityMainWindow(_: any): any;
        accessibilityMarkerGroupUIElement: any;
        setAccessibilityMarkerGroupUIElement(_: any): any;
        accessibilityMarkerTypeDescription: string;
        setAccessibilityMarkerTypeDescription(_: string): any;
        accessibilityMarkerUIElements: any[];
        setAccessibilityMarkerUIElements(_: any[]): any;
        accessibilityMarkerValues: any;
        setAccessibilityMarkerValues(_: any): any;
        accessibilityMaxValue: any;
        setAccessibilityMaxValue(_: any): any;
        accessibilityMenuBar: any;
        setAccessibilityMenuBar(_: any): any;
        accessibilityMinimizeButton: any;
        setAccessibilityMinimizeButton(_: any): any;
        isAccessibilityMinimized: boolean;
        setAccessibilityMinimized(_: boolean): any;
        accessibilityMinValue: any;
        setAccessibilityMinValue(_: any): any;
        isAccessibilityModal: boolean;
        setAccessibilityModal(_: boolean): any;
        accessibilityNextContents: any[];
        setAccessibilityNextContents(_: any[]): any;
        accessibilityNumberOfCharacters: number;
        setAccessibilityNumberOfCharacters(_: number): any;
        isAccessibilityOrderedByRow: boolean;
        setAccessibilityOrderedByRow(_: boolean): any;
        accessibilityOrientation: NSAccessibility.Orientation;
        setAccessibilityOrientation(_: NSAccessibility.Orientation): any;
        accessibilityOverflowButton: any;
        setAccessibilityOverflowButton(_: any): any;
        accessibilityParent: any;
        setAccessibilityParent(_: any): any;
        accessibilityPlaceholderValue: string;
        setAccessibilityPlaceholderValue(_: string): any;
        accessibilityPreviousContents: any[];
        setAccessibilityPreviousContents(_: any[]): any;
        isAccessibilityProtectedContent: boolean;
        setAccessibilityProtectedContent(_: boolean): any;
        accessibilityProxy: any;
        setAccessibilityProxy(_: any): any;
        isAccessibilityRequired: boolean;
        setAccessibilityRequired(_: boolean): any;
        accessibilityRole: string;
        setAccessibilityRole(_: string): any;
        accessibilityRoleDescription: string;
        setAccessibilityRoleDescription(_: string): any;
        accessibilityRowCount: number;
        setAccessibilityRowCount(_: number): any;
        accessibilityRowHeaderUIElements: any[];
        setAccessibilityRowHeaderUIElements(_: any[]): any;
        accessibilityRowIndexRange: NSRange;
        setAccessibilityRowIndexRange(_: NSRange): any;
        accessibilityRows: any[];
        setAccessibilityRows(_: any[]): any;
        accessibilityRulerMarkerType: NSAccessibility.RulerMarkerType;
        setAccessibilityRulerMarkerType(_: NSAccessibility.RulerMarkerType): any;
        accessibilitySearchButton: any;
        setAccessibilitySearchButton(_: any): any;
        accessibilitySearchMenu: any;
        setAccessibilitySearchMenu(_: any): any;
        isAccessibilitySelected: boolean;
        setAccessibilitySelected(_: boolean): any;
        accessibilitySelectedCells: any[];
        setAccessibilitySelectedCells(_: any[]): any;
        accessibilitySelectedChildren: any[];
        setAccessibilitySelectedChildren(_: any[]): any;
        accessibilitySelectedColumns: any[];
        setAccessibilitySelectedColumns(_: any[]): any;
        accessibilitySelectedRows: any[];
        setAccessibilitySelectedRows(_: any[]): any;
        accessibilitySelectedText: string;
        setAccessibilitySelectedText(_: string): any;
        accessibilitySelectedTextRange: NSRange;
        setAccessibilitySelectedTextRange(_: NSRange): any;
        accessibilitySelectedTextRanges: NSValue[];
        setAccessibilitySelectedTextRanges(_: NSValue[]): any;
        accessibilityServesAsTitleForUIElements: any[];
        setAccessibilityServesAsTitleForUIElements(_: any[]): any;
        accessibilitySharedCharacterRange: NSRange;
        setAccessibilitySharedCharacterRange(_: NSRange): any;
        accessibilitySharedFocusElements: any[];
        setAccessibilitySharedFocusElements(_: any[]): any;
        accessibilitySharedTextUIElements: any[];
        setAccessibilitySharedTextUIElements(_: any[]): any;
        accessibilityShownMenu: any;
        setAccessibilityShownMenu(_: any): any;
        accessibilitySortDirection: NSAccessibility.SortDirection;
        setAccessibilitySortDirection(_: NSAccessibility.SortDirection): any;
        accessibilitySplitters: any[];
        setAccessibilitySplitters(_: any[]): any;
        accessibilitySubrole: string;
        setAccessibilitySubrole(_: string): any;
        accessibilityTabs: any[];
        setAccessibilityTabs(_: any[]): any;
        accessibilityTitle: string;
        setAccessibilityTitle(_: string): any;
        accessibilityTitleUIElement: any;
        setAccessibilityTitleUIElement(_: any): any;
        accessibilityToolbarButton: any;
        setAccessibilityToolbarButton(_: any): any;
        accessibilityTopLevelUIElement: any;
        setAccessibilityTopLevelUIElement(_: any): any;
        accessibilityUnitDescription: string;
        setAccessibilityUnitDescription(_: string): any;
        accessibilityUnits: NSAccessibility.Units;
        setAccessibilityUnits(_: NSAccessibility.Units): any;
        accessibilityURL: NSURL;
        setAccessibilityURL(_: NSURL): any;
        accessibilityValue: any;
        setAccessibilityValue(_: any): any;
        accessibilityValueDescription: string;
        setAccessibilityValueDescription(_: string): any;
        accessibilityVerticalScrollBar: any;
        setAccessibilityVerticalScrollBar(_: any): any;
        accessibilityVerticalUnitDescription: string;
        setAccessibilityVerticalUnitDescription(_: string): any;
        accessibilityVerticalUnits: NSAccessibility.Units;
        setAccessibilityVerticalUnits(_: NSAccessibility.Units): any;
        accessibilityVisibleCells: any[];
        setAccessibilityVisibleCells(_: any[]): any;
        accessibilityVisibleCharacterRange: NSRange;
        setAccessibilityVisibleCharacterRange(_: NSRange): any;
        accessibilityVisibleChildren: any[];
        setAccessibilityVisibleChildren(_: any[]): any;
        accessibilityVisibleColumns: any[];
        setAccessibilityVisibleColumns(_: any[]): any;
        accessibilityVisibleRows: any[];
        setAccessibilityVisibleRows(_: any[]): any;
        accessibilityWarningValue: any;
        setAccessibilityWarningValue(_: any): any;
        accessibilityWindow: any;
        setAccessibilityWindow(_: any): any;
        accessibilityWindows: any[];
        setAccessibilityWindows(_: any[]): any;
        accessibilityZoomButton: any;
        setAccessibilityZoomButton(_: any): any;
        accessibilityAttributedStringForRange(_: NSRange): NSAttributedString;
        accessibilityCellForColumnRow(_: number, row: number): any;
        accessibilityFrameForRange(_: NSRange): CGRect;
        accessibilityLayoutPointForScreenPoint(_: CGPoint): CGPoint;
        accessibilityLayoutSizeForScreenSize(_: CGSize): CGSize;
        accessibilityLineForIndex(_: number): number;
        accessibilityPerformCancel(): boolean;
        accessibilityPerformConfirm(): boolean;
        accessibilityPerformDecrement(): boolean;
        accessibilityPerformDelete(): boolean;
        accessibilityPerformIncrement(): boolean;
        accessibilityPerformPick(): boolean;
        accessibilityPerformPress(): boolean;
        accessibilityPerformRaise(): boolean;
        accessibilityPerformShowAlternateUI(): boolean;
        accessibilityPerformShowDefaultUI(): boolean;
        accessibilityPerformShowMenu(): boolean;
        accessibilityRangeForIndex(_: number): NSRange;
        accessibilityRangeForLine(_: number): NSRange;
        accessibilityRangeForPosition(_: CGPoint): NSRange;
        accessibilityRTFForRange(_: NSRange): NSData;
        accessibilityScreenPointForLayoutPoint(_: CGPoint): CGPoint;
        accessibilityScreenSizeForLayoutSize(_: CGSize): CGSize;
        accessibilityStringForRange(_: NSRange): string;
        accessibilityStyleRangeForIndex(_: number): NSRange;
        isAccessibilitySelectorAllowed(_: string): boolean;
    }
    interface NSAccessibilityButton extends NSAccessibilityElement {
        accessibilityLabel(): string;
        accessibilityPerformPress(): boolean;
    }
    interface NSAccessibilityCheckBox extends NSAccessibilityButton {
        accessibilityValue(): number;
    }
    interface NSAccessibilityContainsTransientUI extends NSAccessibilityElement {
        accessibilityPerformShowAlternateUI(): boolean;
        accessibilityPerformShowDefaultUI(): boolean;
        isAccessibilityAlternateUIVisible(): boolean;
    }
    class NSAccessibilityCustomAction extends NSObject {
        handler: () => boolean;
        setHandler(_: () => boolean): any;
        name: string;
        setName(_: string): any;
        selector: string;
        setSelector(_: string): any;
        target: NSObject;
        setTarget(_: NSObject): any;
        static createWithNameHandler(name: string, handler?: () => boolean): NSAccessibilityCustomAction;
        static createWithNameTargetSelector(name: string, target: NSObject, selector: string): NSAccessibilityCustomAction;
    }
    class NSAccessibilityCustomRotor extends NSObject {
        itemLoadingDelegate: NSAccessibilityElementLoading;
        setItemLoadingDelegate(_: NSAccessibilityElementLoading): any;
        itemSearchDelegate: NSAccessibilityCustomRotorItemSearchDelegate;
        setItemSearchDelegate(_: NSAccessibilityCustomRotorItemSearchDelegate): any;
        label: string;
        setLabel(_: string): any;
        type: NSAccessibilityCustomRotor.RotorType;
        setType(_: NSAccessibilityCustomRotor.RotorType): any;
        static createWithLabelItemSearchDelegate(label: string, itemSearchDelegate: NSAccessibilityCustomRotorItemSearchDelegate): NSAccessibilityCustomRotor;
        static createWithRotorTypeItemSearchDelegate(rotorType: NSAccessibilityCustomRotor.RotorType, itemSearchDelegate: NSAccessibilityCustomRotorItemSearchDelegate): NSAccessibilityCustomRotor;
    }
    class ItemResult extends NSObject {
        customLabel: string;
        setCustomLabel(_: string): any;
        itemLoadingToken: any;
        targetElement: NSAccessibilityElement;
        targetRange: NSRange;
        setTargetRange(_: NSRange): any;
        static createWithItemLoadingTokenCustomLabel(itemLoadingToken: any, customLabel: string): ItemResult;
        static createWithTargetElement(targetElement: NSAccessibilityElement): ItemResult;
    }
    interface NSAccessibilityCustomRotorItemSearchDelegate extends NSObject {
        rotorResultForSearchParameters(_: NSAccessibilityCustomRotor, resultFor: SearchParameters): ItemResult;
    }
    class SearchParameters extends NSObject {
        currentItem: ItemResult;
        setCurrentItem(_: ItemResult): any;
        filterString: string;
        setFilterString(_: string): any;
        searchDirection: NSAccessibilityCustomRotor.SearchDirection;
        setSearchDirection(_: NSAccessibilityCustomRotor.SearchDirection): any;
    }
    class NSAccessibilityElement extends NSObject {
        static accessibilityElementWithRoleFrameLabelParent(withRole: string, frame: CGRect, label?: string, parent?: any): any;
        accessibilityFrameInParentSpace: CGRect;
        setAccessibilityFrameInParentSpace(_: CGRect): any;
        accessibilityAddChildElement(_: NSAccessibilityElement): void;
    }
    interface NSAccessibilityElementLoading extends NSObject {
        accessibilityElementWithToken(withToken: any): NSAccessibilityElement;
        accessibilityRangeInTargetElementWithToken?(withToken: any): NSRange;
    }
    interface NSAccessibilityElement extends NSObject {
        accessibilityFrame(): CGRect;
        accessibilityIdentifier?(): string;
        accessibilityParent(): any;
        isAccessibilityFocused?(): boolean;
    }
    type NSAccessibilityGroup = NSAccessibilityElement;
    interface NSAccessibilityImage extends NSAccessibilityElement {
        accessibilityLabel(): string;
    }
    interface NSAccessibilityLayoutArea extends NSAccessibilityGroup {
        accessibilityFocusedUIElement: any;
        accessibilityChildren(): any[];
        accessibilityLabel(): string;
        accessibilitySelectedChildren(): any[];
    }
    interface NSAccessibilityLayoutItem extends NSAccessibilityGroup {
        setAccessibilityFrame?(_: CGRect): void;
    }
    type NSAccessibilityList = NSAccessibilityTable;
    interface NSAccessibilityNavigableStaticText extends NSAccessibilityStaticText {
        accessibilityFrameForRange(for_: NSRange): CGRect;
        accessibilityLineForIndex(for_: number): number;
        accessibilityRangeForLine(forLine: number): NSRange;
        accessibilityStringForRange(for_: NSRange): string;
    }
    type NSAccessibilityOutline = NSAccessibilityTable;
    interface NSAccessibilityProgressIndicator extends NSAccessibilityGroup {
        accessibilityValue(): number;
    }
    interface NSAccessibilityRadioButton extends NSAccessibilityButton {
        accessibilityValue(): number;
    }
    interface NSAccessibilityRow extends NSAccessibilityGroup {
        accessibilityDisclosureLevel?(): number;
        accessibilityIndex(): number;
    }
    interface NSAccessibilitySlider extends NSAccessibilityElement {
        accessibilityLabel(): string;
        accessibilityPerformDecrement(): boolean;
        accessibilityPerformIncrement(): boolean;
        accessibilityValue(): any;
    }
    interface NSAccessibilityStaticText extends NSAccessibilityElement {
        accessibilityAttributedStringForRange?(for_: NSRange): NSAttributedString;
        accessibilityValue(): string;
        accessibilityVisibleCharacterRange?(): NSRange;
    }
    interface NSAccessibilityStepper extends NSAccessibilityElement {
        accessibilityLabel(): string;
        accessibilityPerformDecrement(): boolean;
        accessibilityPerformIncrement(): boolean;
        accessibilityValue?(): any;
    }
    interface NSAccessibilitySwitch extends NSAccessibilityButton {
        accessibilityPerformDecrement?(): boolean;
        accessibilityPerformIncrement?(): boolean;
        accessibilityValue(): string;
    }
    interface NSAccessibilityTable extends NSAccessibilityGroup {
        accessibilityColumnHeaderUIElements?(): any[];
        accessibilityColumns?(): any[];
        accessibilityLabel(): string;
        accessibilityRowHeaderUIElements?(): any[];
        accessibilityRows(): NSAccessibilityRow[];
        accessibilitySelectedCells?(): any[];
        accessibilitySelectedColumns?(): any[];
        accessibilitySelectedRows?(): NSAccessibilityRow[];
        accessibilityVisibleCells?(): any[];
        accessibilityVisibleColumns?(): any[];
        accessibilityVisibleRows?(): NSAccessibilityRow[];
        setAccessibilitySelectedRows?(_: NSAccessibilityRow[]): void;
    }
    class NSActionCell extends NSCell {
    }
    class NSAlert extends NSObject {
        accessoryView: NSView;
        setAccessoryView(_: NSView): any;
        alertStyle: NSAlert.Style;
        setAlertStyle(_: NSAlert.Style): any;
        buttons: NSButton[];
        delegate: NSAlertDelegate;
        setDelegate(_: NSAlertDelegate): any;
        helpAnchor: string;
        setHelpAnchor(_: string): any;
        icon: NSImage;
        setIcon(_: NSImage): any;
        informativeText: string;
        setInformativeText(_: string): any;
        messageText: string;
        setMessageText(_: string): any;
        showsHelp: boolean;
        setShowsHelp(_: boolean): any;
        showsSuppressionButton: boolean;
        setShowsSuppressionButton(_: boolean): any;
        suppressionButton: NSButton;
        window: NSWindow;
        addButtonWithTitle(withTitle: string): NSButton;
        beginSheetModalForCompletionHandler(for_: NSWindow, completionHandler?: (p1: number) => void): void;
        layout(): void;
        runModal(): number;
    }
    interface NSAlertDelegate extends NSObject {
        alertShowHelp?(_: NSAlert): boolean;
    }
    class NSAlignmentFeedbackFilter extends NSObject {
        static inputEventMask: NSEvent.EventTypeMask;
        alignmentFeedbackTokenForHorizontalMovementInViewPreviousXAlignedXDefaultX(in_?: NSView, previousX?: number, alignedX?: number, defaultX?: number): NSAlignmentFeedbackToken;
        alignmentFeedbackTokenForMovementInViewPreviousPointAlignedPointDefaultPoint(in_?: NSView, previousPoint?: CGPoint, alignedPoint?: CGPoint, defaultPoint?: CGPoint): NSAlignmentFeedbackToken;
        alignmentFeedbackTokenForVerticalMovementInViewPreviousYAlignedYDefaultY(in_?: NSView, previousY?: number, alignedY?: number, defaultY?: number): NSAlignmentFeedbackToken;
        performFeedbackWithPerformanceTime(_: NSAlignmentFeedbackToken[], performanceTime: NSHapticFeedbackManager.PerformanceTime): void;
        updateWithEvent(with_: NSEvent): void;
        updateWithPanRecognizer(withPanRecognizer: NSPanGestureRecognizer): void;
    }
    type NSAlignmentFeedbackToken = NSObject;
    interface NSAnimatablePropertyContainer {
        animations: Map<string, any>;
        setAnimations(_: Map<string, any>): any;
        animationForKey(forKey: string): any;
        animator(): NSAnimatablePropertyContainer;
    }
    class NSAnimation extends NSObject {
        isAnimating: boolean;
        animationBlockingMode: NSAnimation.BlockingMode;
        setAnimationBlockingMode(_: NSAnimation.BlockingMode): any;
        animationCurve: NSAnimation.Curve;
        setAnimationCurve(_: NSAnimation.Curve): any;
        currentProgress: number;
        setCurrentProgress(_: number): any;
        currentValue: number;
        delegate: NSAnimationDelegate;
        setDelegate(_: NSAnimationDelegate): any;
        duration: number;
        setDuration(_: number): any;
        frameRate: number;
        setFrameRate(_: number): any;
        progressMarks: number[];
        setProgressMarks(_: number[]): any;
        runLoopModesForAnimating: string[];
        addProgressMark(_: number): void;
        clearStartAnimation(): void;
        clearStopAnimation(): void;
        static createWithDurationAnimationCurve(duration: number, animationCurve: NSAnimation.Curve): NSAnimation;
        removeProgressMark(_: number): void;
        startAnimation(): void;
        startWhenAnimationReachesProgress(when: NSAnimation, reachesProgress: number): void;
        stopAnimation(): void;
        stopWhenAnimationReachesProgress(when: NSAnimation, reachesProgress: number): void;
    }
    class NSAnimationContext extends NSObject {
        static beginGrouping(): void;
        static endGrouping(): void;
        static runAnimationGroup(_: (p1: NSAnimationContext) => void): void;
        static runAnimationGroupWithCompletionHandler(_: (p1: NSAnimationContext) => void, completionHandler?: () => void): void;
        allowsImplicitAnimation: boolean;
        setAllowsImplicitAnimation(_: boolean): any;
        completionHandler: () => void;
        setCompletionHandler(_: () => void): any;
        duration: number;
        setDuration(_: number): any;
        timingFunction: CAMediaTimingFunction;
        setTimingFunction(_: CAMediaTimingFunction): any;
        static currentContext: NSAnimationContext;
    }
    interface NSAnimationDelegate extends NSObject {
        animationDidReachProgressMark?(_: NSAnimation, didReachProgressMark: number): void;
        animationValueForProgress?(_: NSAnimation, valueForProgress: number): number;
        animationDidEnd?(_: NSAnimation): void;
        animationDidStop?(_: NSAnimation): void;
        animationShouldStart?(_: NSAnimation): boolean;
    }
    class NSAppearance extends NSObject {
        allowsVibrancy: boolean;
        name: string;
        static currentAppearance: NSAppearance;
        setCurrentAppearance(_: NSAppearance): any;
        bestMatchFromAppearancesWithNames(from: string[]): string;
        static createWithAppearanceNamedBundle(appearanceNamed: string, bundle?: Bundle): NSAppearance;
    }
    interface NSAppearanceCustomization extends NSObject {
        appearance: NSAppearance;
        setAppearance(_: NSAppearance): any;
        effectiveAppearance: NSAppearance;
    }
    class NSApplication extends NSResponder {
        static detachDrawingThreadToTargetWithObject(_: string, toTarget: any, with_?: any): void;
        isActive: boolean;
        applicationIconImage: NSImage;
        setApplicationIconImage(_: NSImage): any;
        isAutomaticCustomizeTouchBarMenuItemEnabled: boolean;
        setAutomaticCustomizeTouchBarMenuItemEnabled(_: boolean): any;
        currentEvent: NSEvent;
        currentSystemPresentationOptions: NSApplication.PresentationOptions;
        delegate: NSApplicationDelegate;
        setDelegate(_: NSApplicationDelegate): any;
        dockTile: NSDockTile;
        enabledRemoteNotificationTypes: NSApplication.RemoteNotificationType;
        isFullKeyboardAccessEnabled: boolean;
        helpMenu: NSMenu;
        setHelpMenu(_: NSMenu): any;
        isHidden: boolean;
        keyWindow: NSWindow;
        mainMenu: NSMenu;
        setMainMenu(_: NSMenu): any;
        mainWindow: NSWindow;
        modalWindow: NSWindow;
        occlusionState: NSApplication.OcclusionState;
        orderedDocuments: NSDocument[];
        orderedWindows: NSWindow[];
        presentationOptions: NSApplication.PresentationOptions;
        setPresentationOptions(_: NSApplication.PresentationOptions): any;
        isRegisteredForRemoteNotifications: boolean;
        isRunning: boolean;
        servicesMenu: NSMenu;
        setServicesMenu(_: NSMenu): any;
        servicesProvider: any;
        setServicesProvider(_: any): any;
        userInterfaceLayoutDirection: NSUserInterfaceLayoutDirection;
        windows: NSWindow[];
        windowsMenu: NSMenu;
        setWindowsMenu(_: NSMenu): any;
        static sharedApplication: NSApplication;
        abortModal(): void;
        activateContextHelpMode(_?: any): void;
        activateIgnoringOtherApps(ignoringOtherApps: boolean): void;
        activationPolicy(): NSApplication.ActivationPolicy;
        addWindowsItemTitleFilename(_: NSWindow, title: string, filename: boolean): void;
        arrangeInFront(_?: any): void;
        beginModalSessionForWindow(for_: NSWindow): any;
        cancelUserAttentionRequest(_: number): void;
        changeWindowsItemTitleFilename(_: NSWindow, title: string, filename: boolean): void;
        completeStateRestoration(): void;
        deactivate(): void;
        disableRelaunchOnLogin(): void;
        discardEventsMatchingMaskBeforeEvent(matching: NSEvent.EventTypeMask, before?: NSEvent): void;
        enableRelaunchOnLogin(): void;
        endModalSession(_: any): void;
        enumerateWindowsWithOptionsUsing(options: NSApplication.WindowListOptions, using: (p1: NSWindow, p2: boolean) => void): void;
        extendStateRestoration(): void;
        finishLaunching(): void;
        hide(_?: any): void;
        hideOtherApplications(_?: any): void;
        miniaturizeAll(_?: any): void;
        nextEventMatchingMaskUntilDateInModeDequeue(matching: NSEvent.EventTypeMask, until?: Date, inMode?: string, dequeue?: boolean): NSEvent;
        orderFrontCharacterPalette(_?: any): void;
        orderFrontColorPanel(_?: any): void;
        orderFrontStandardAboutPanel(_?: any): void;
        orderFrontStandardAboutPanelWithOptions(options: Map<string, any>): void;
        postEventAtStart(_: NSEvent, atStart: boolean): void;
        preventWindowOrdering(): void;
        registerForRemoteNotificationTypes(matching: NSApplication.RemoteNotificationType): void;
        registerForRemoteNotifications(): void;
        registerServicesMenuSendTypesReturnTypes(_: string[], returnTypes: string[]): void;
        registerUserInterfaceItemSearchHandler(_: NSUserInterfaceItemSearching): void;
        removeWindowsItem(_: NSWindow): void;
        replyToApplicationShouldTerminate(toApplicationShouldTerminate: boolean): void;
        replyToOpenOrPrint(toOpenOrPrint: NSApplication.DelegateReply): void;
        reportException(_: NSException): void;
        requestUserAttention(_: NSApplication.RequestUserAttentionType): number;
        restoreWindowWithWithIdentifierStateCompletionHandler(withIdentifier: string, state: NSCoder, completionHandler?: (p1: NSWindow, p2: NSError) => void): boolean;
        run(): void;
        runModalForWindow(for_: NSWindow): number;
        runModalSession(_: any): number;
        runPageLayout(_?: any): void;
        searchStringInUserInterfaceItemStringSearchRangeFoundRange(_: string, inUserInterfaceItemString: string, range: NSRange, found?: NSRange): boolean;
        sendActionToFrom(_: string, to?: any, from?: any): boolean;
        sendEvent(_: NSEvent): void;
        setActivationPolicy(_: NSApplication.ActivationPolicy): boolean;
        setWindowsNeedUpdate(_: boolean): void;
        showHelp(_?: any): void;
        stop(_?: any): void;
        stopModal(): void;
        stopModalWithCode(withCode: number): void;
        targetForAction(forAction: string): any;
        targetForActionToFrom(forAction: string, to?: any, from?: any): any;
        terminate(_?: any): void;
        toggleTouchBarCustomizationPalette(_?: any): void;
        unhide(_?: any): void;
        unhideAllApplications(_?: any): void;
        unhideWithoutActivation(): void;
        unregisterForRemoteNotifications(): void;
        unregisterUserInterfaceItemSearchHandler(_: NSUserInterfaceItemSearching): void;
        updateWindows(): void;
        updateWindowsItem(_: NSWindow): void;
        windowWithWindowNumber(withWindowNumber: number): NSWindow;
    }
    interface NSApplicationDelegate extends NSObject {
        applicationContinueRestorationHandler?(_: NSApplication, continue_: NSUserActivity, restorationHandler: (p1: NSUserActivityRestoring[]) => void): boolean;
        applicationOpenURLs?(_: NSApplication, open: NSURL[]): void;
        applicationUserDidAcceptCloudKitShareWithMetadata?(_: NSApplication, userDidAcceptCloudKitShareWith: Metadata): void;
        applicationDidUpdateUserActivity?(_: NSApplication, didUpdate: NSUserActivity): void;
        applicationDelegateHandlesKey?(_: NSApplication, delegateHandlesKey: string): boolean;
        applicationDidDecodeRestorableState?(_: NSApplication, didDecodeRestorableState: NSCoder): void;
        applicationDidFailToContinueUserActivityWithTypeError?(_: NSApplication, didFailToContinueUserActivityWithType: string, error: NSError): void;
        applicationDidFailToRegisterForRemoteNotificationsWithError?(_: NSApplication, didFailToRegisterForRemoteNotificationsWithError: NSError): void;
        applicationDidReceiveRemoteNotification?(_: NSApplication, didReceiveRemoteNotification: Map<string, any>): void;
        applicationDidRegisterForRemoteNotificationsWithDeviceToken?(_: NSApplication, didRegisterForRemoteNotificationsWithDeviceToken: NSData): void;
        applicationOpenFile?(_: NSApplication, openFile: string): boolean;
        applicationOpenFiles?(_: NSApplication, openFiles: string[]): void;
        applicationOpenFileWithoutUI?(_: any, openFileWithoutUI: string): boolean;
        applicationOpenTempFile?(_: NSApplication, openTempFile: string): boolean;
        applicationPrintFile?(_: NSApplication, printFile: string): boolean;
        applicationPrintFilesWithSettingsShowPrintPanels?(_: NSApplication, printFiles: string[], withSettings: Map<string, any>, showPrintPanels: boolean): NSApplication.PrintReply;
        applicationWillContinueUserActivityWithType?(_: NSApplication, willContinueUserActivityWithType: string): boolean;
        applicationWillEncodeRestorableState?(_: NSApplication, willEncodeRestorableState: NSCoder): void;
        applicationWillPresentError?(_: NSApplication, willPresentError: NSError): NSError;
        applicationDidBecomeActive?(_: NSNotification): void;
        applicationDidChangeOcclusionState?(_: NSNotification): void;
        applicationDidChangeScreenParameters?(_: NSNotification): void;
        applicationDidFinishLaunching?(_: NSNotification): void;
        applicationDidHide?(_: NSNotification): void;
        applicationDidResignActive?(_: NSNotification): void;
        applicationDidUnhide?(_: NSNotification): void;
        applicationDidUpdate?(_: NSNotification): void;
        applicationDockMenu?(_: NSApplication): NSMenu;
        applicationOpenUntitledFile?(_: NSApplication): boolean;
        applicationShouldHandleReopenHasVisibleWindows?(_: NSApplication, hasVisibleWindows: boolean): boolean;
        applicationShouldOpenUntitledFile?(_: NSApplication): boolean;
        applicationShouldTerminate?(_: NSApplication): NSApplication.TerminateReply;
        applicationShouldTerminateAfterLastWindowClosed?(_: NSApplication): boolean;
        applicationWillBecomeActive?(_: NSNotification): void;
        applicationWillFinishLaunching?(_: NSNotification): void;
        applicationWillHide?(_: NSNotification): void;
        applicationWillResignActive?(_: NSNotification): void;
        applicationWillTerminate?(_: NSNotification): void;
        applicationWillUnhide?(_: NSNotification): void;
        applicationWillUpdate?(_: NSNotification): void;
    }
    class NSArrayController extends NSObjectController {
        alwaysUsesMultipleValuesMarker: boolean;
        setAlwaysUsesMultipleValuesMarker(_: boolean): any;
        arrangedObjects: any;
        automaticRearrangementKeyPaths: string[];
        automaticallyRearrangesObjects: boolean;
        setAutomaticallyRearrangesObjects(_: boolean): any;
        avoidsEmptySelection: boolean;
        setAvoidsEmptySelection(_: boolean): any;
        canInsert: boolean;
        canSelectNext: boolean;
        canSelectPrevious: boolean;
        clearsFilterPredicateOnInsertion: boolean;
        setClearsFilterPredicateOnInsertion(_: boolean): any;
        filterPredicate: NSPredicate;
        setFilterPredicate(_: NSPredicate): any;
        preservesSelection: boolean;
        setPreservesSelection(_: boolean): any;
        selectionIndex: number;
        selectionIndexes: NSIndexSet;
        selectsInsertedObjects: boolean;
        setSelectsInsertedObjects(_: boolean): any;
        sortDescriptors: NSSortDescriptor[];
        setSortDescriptors(_: NSSortDescriptor[]): any;
        addObjects(contentsOf: any[]): void;
        addSelectedObjects(_: any[]): boolean;
        addSelectionIndexes(_: NSIndexSet): boolean;
        arrangeObjects(_: any[]): any[];
        didChangeArrangementCriteria(): void;
        insert(_?: any): void;
        insertObjectAtArrangedObjectIndex(_: any, atArrangedObjectIndex: number): void;
        insertObjectsAtArrangedObjectIndexes(contentsOf: any[], atArrangedObjectIndexes: NSIndexSet): void;
        rearrangeObjects(): void;
        removeObjectAtArrangedObjectIndex(atArrangedObjectIndex: number): void;
        removeObjects(contentsOf: any[]): void;
        removeObjectsAtArrangedObjectIndexes(atArrangedObjectIndexes: NSIndexSet): void;
        removeSelectedObjects(_: any[]): boolean;
        removeSelectionIndexes(_: NSIndexSet): boolean;
        selectNext(_?: any): void;
        selectPrevious(_?: any): void;
        setSelectedObjects(_: any[]): boolean;
        setSelectionIndex(_: number): boolean;
        setSelectionIndexes(_: NSIndexSet): boolean;
    }
    class NSBezierPath extends NSObject {
        static clipRect(_: CGRect): void;
        static drawPackedGlyphsAtPoint(_: string, at: CGPoint): void;
        static fillRect(_: CGRect): void;
        static strokeLineFromPointToPoint(from: CGPoint, to: CGPoint): void;
        static strokeRect(_: CGRect): void;
        bezierPathByFlatteningPath: NSBezierPath;
        bezierPathByReversingPath: NSBezierPath;
        bounds: CGRect;
        controlPointBounds: CGRect;
        currentPoint: CGPoint;
        elementCount: number;
        isEmpty: boolean;
        flatness: number;
        setFlatness(_: number): any;
        lineCapStyle: NSBezierPath.LineCapStyle;
        setLineCapStyle(_: NSBezierPath.LineCapStyle): any;
        lineJoinStyle: NSBezierPath.LineJoinStyle;
        setLineJoinStyle(_: NSBezierPath.LineJoinStyle): any;
        lineWidth: number;
        setLineWidth(_: number): any;
        miterLimit: number;
        setMiterLimit(_: number): any;
        windingRule: NSBezierPath.WindingRule;
        setWindingRule(_: NSBezierPath.WindingRule): any;
        static defaultFlatness: number;
        setDefaultFlatness(_: number): any;
        static defaultLineCapStyle: NSBezierPath.LineCapStyle;
        setDefaultLineCapStyle(_: NSBezierPath.LineCapStyle): any;
        static defaultLineJoinStyle: NSBezierPath.LineJoinStyle;
        setDefaultLineJoinStyle(_: NSBezierPath.LineJoinStyle): any;
        static defaultLineWidth: number;
        setDefaultLineWidth(_: number): any;
        static defaultMiterLimit: number;
        setDefaultMiterLimit(_: number): any;
        static defaultWindingRule: NSBezierPath.WindingRule;
        setDefaultWindingRule(_: NSBezierPath.WindingRule): any;
        addClip(): void;
        appendBezierPath(_: NSBezierPath): void;
        appendBezierPathWithArcFromPointToPointRadius(from: CGPoint, to: CGPoint, radius: number): void;
        appendBezierPathWithArcWithCenterRadiusStartAngleEndAngle(withCenter: CGPoint, radius: number, startAngle: number, endAngle: number): void;
        appendBezierPathWithArcWithCenterRadiusStartAngleEndAngleClockwise(withCenter: CGPoint, radius: number, startAngle: number, endAngle: number, clockwise: boolean): void;
        appendBezierPathWithCGGlyphInFont(withCGGlyph: number, in_: NSFont): void;
        appendBezierPathWithCGGlyphsCountInFont(withCGGlyphs: number, count: number, in_: NSFont): void;
        appendBezierPathWithOvalInRect(in_: CGRect): void;
        appendBezierPathWithPointsCount(_: NSPoint, count: number): void;
        appendBezierPathWithRect(_: CGRect): void;
        appendBezierPathWithRoundedRectXRadiusYRadius(_: CGRect, xRadius: number, yRadius: number): void;
        closePath(): void;
        containsPoint(_: CGPoint): boolean;
        curveToPointControlPoint1ControlPoint2(to: CGPoint, controlPoint1: CGPoint, controlPoint2: CGPoint): void;
        elementAtIndex(at: number): NSBezierPath.ElementType;
        elementAtIndexAssociatedPoints(at: number, associatedPoints?: NSPoint): NSBezierPath.ElementType;
        fill(): void;
        getLineDashCountPhase(_?: number, count?: number, phase?: number): void;
        lineToPoint(to: CGPoint): void;
        moveToPoint(to: CGPoint): void;
        relativeCurveToPointControlPoint1ControlPoint2(to: CGPoint, controlPoint1: CGPoint, controlPoint2: CGPoint): void;
        relativeLineToPoint(to: CGPoint): void;
        relativeMoveToPoint(to: CGPoint): void;
        removeAllPoints(): void;
        setAssociatedPointsAtIndex(_?: NSPoint, at?: number): void;
        setClip(): void;
        setLineDashCountPhase(_?: number, count?: number, phase?: number): void;
        stroke(): void;
        transformUsingAffineTransform(using: NSAffineTransform): void;
    }
    class NSBindingSelectionMarker extends NSObject {
        static defaultPlaceholderForMarkerOnClassWithBinding(for_?: NSBindingSelectionMarker, on?: typeof NSObject, withBinding?: string): any;
        static setDefaultPlaceholderForMarkerOnClassWithBinding(_?: any, for_?: NSBindingSelectionMarker, on?: typeof NSObject, withBinding?: string): void;
        static multipleValuesSelectionMarker: NSBindingSelectionMarker;
        static noSelectionMarker: NSBindingSelectionMarker;
        static notApplicableSelectionMarker: NSBindingSelectionMarker;
    }
    class NSBitmapImageRep extends NSImageRep {
        static TIFFRepresentationOfImageRepsInArray(in_: NSImageRep[]): NSData;
        static TIFFRepresentationOfImageRepsInArrayUsingCompressionFactor(in_: NSImageRep[], using: NSBitmapImageRep.TIFFCompression, factor: number): NSData;
        static getTIFFCompressionTypesCount(_?: NSBitmapImageRep.TIFFCompression, count?: number): void;
        static imageRepsWithData(with_: NSData): NSImageRep[];
        static localizedNameForTIFFCompressionType(forTIFFCompressionType: NSBitmapImageRep.TIFFCompression): string;
        static representationOfImageRepsInArrayUsingTypeProperties(in_: NSImageRep[], using: NSBitmapImageRep.FileType, properties: Map<string, any>): NSData;
        CGImage: any;
        TIFFRepresentation: NSData;
        bitmapData: string;
        bitmapFormat: NSBitmapImageRep.Format;
        bitsPerPixel: number;
        bytesPerPlane: number;
        bytesPerRow: number;
        colorSpace: NSColorSpace;
        numberOfPlanes: number;
        isPlanar: boolean;
        samplesPerPixel: number;
        TIFFRepresentationUsingCompressionFactor(using: NSBitmapImageRep.TIFFCompression, factor: number): NSData;
        bitmapImageRepByConvertingToColorSpaceRenderingIntent(to: NSColorSpace, renderingIntent: NSColorRenderingIntent): NSBitmapImageRep;
        bitmapImageRepByRetaggingWithColorSpace(with_: NSColorSpace): NSBitmapImageRep;
        canBeCompressedUsing(using: NSBitmapImageRep.TIFFCompression): boolean;
        colorAtXY(x: number, y: number): NSColor;
        colorizeByMappingGrayToColorBlackMappingWhiteMapping(byMappingGray: number, to?: NSColor, blackMapping?: NSColor, whiteMapping?: NSColor): void;
        getBitmapDataPlanes(_?: string): void;
        getCompressionFactor(_?: NSBitmapImageRep.TIFFCompression, factor?: number): void;
        getPixelAtXY(_: number, atX: number, y: number): void;
        incrementalLoadFromDataComplete(from: NSData, complete: boolean): number;
        static createWithForIncrementalLoad(): NSBitmapImageRep;
        static createWithBitmapDataPlanesPixelsWidePixelsHighBitsPerSampleSamplesPerPixelHasAlphaIsPlanarColorSpaceNameBitmapFormatBytesPerRowBitsPerPixel(bitmapDataPlanes?: string, pixelsWide?: number, pixelsHigh?: number, bitsPerSample?: number, samplesPerPixel?: number, hasAlpha?: boolean, isPlanar?: boolean, colorSpaceName?: string, bitmapFormat?: NSBitmapImageRep.Format, bytesPerRow?: number, bitsPerPixel?: number): NSBitmapImageRep;
        static createWithBitmapDataPlanesPixelsWidePixelsHighBitsPerSampleSamplesPerPixelHasAlphaIsPlanarColorSpaceNameBytesPerRowBitsPerPixel(bitmapDataPlanes?: string, pixelsWide?: number, pixelsHigh?: number, bitsPerSample?: number, samplesPerPixel?: number, hasAlpha?: boolean, isPlanar?: boolean, colorSpaceName?: string, bytesPerRow?: number, bitsPerPixel?: number): NSBitmapImageRep;
        static createWithCGImage(CGImage: any): NSBitmapImageRep;
        static createWithCIImage(CIImage: CIImage): NSBitmapImageRep;
        static createWithData(data: NSData): NSBitmapImageRep;
        representationUsingTypeProperties(using: NSBitmapImageRep.FileType, properties: Map<string, any>): NSData;
        setColorAtXY(_: NSColor, atX: number, y: number): void;
        setCompressionFactor(_: NSBitmapImageRep.TIFFCompression, factor: number): void;
        setPixelAtXY(_: number, atX: number, y: number): void;
        setPropertyWithValue(_: string, withValue?: any): void;
        valueForProperty(forProperty: string): any;
    }
    class NSBox extends NSView {
        borderColor: NSColor;
        setBorderColor(_: NSColor): any;
        borderRect: CGRect;
        borderWidth: number;
        setBorderWidth(_: number): any;
        boxType: NSBox.BoxType;
        setBoxType(_: NSBox.BoxType): any;
        contentView: NSView;
        setContentView(_: NSView): any;
        contentViewMargins: CGSize;
        setContentViewMargins(_: CGSize): any;
        cornerRadius: number;
        setCornerRadius(_: number): any;
        fillColor: NSColor;
        setFillColor(_: NSColor): any;
        title: string;
        setTitle(_: string): any;
        titleCell: any;
        titleFont: NSFont;
        setTitleFont(_: NSFont): any;
        titlePosition: NSBox.TitlePosition;
        setTitlePosition(_: NSBox.TitlePosition): any;
        titleRect: CGRect;
        isTransparent: boolean;
        setTransparent(_: boolean): any;
        setFrameFromContentFrame(_: CGRect): void;
        sizeToFit(): void;
    }
    class NSBrowser extends NSControl {
        static removeSavedColumnsWithAutosaveName(withAutosaveName: string): void;
        allowsBranchSelection: boolean;
        setAllowsBranchSelection(_: boolean): any;
        allowsEmptySelection: boolean;
        setAllowsEmptySelection(_: boolean): any;
        allowsMultipleSelection: boolean;
        setAllowsMultipleSelection(_: boolean): any;
        allowsTypeSelect: boolean;
        setAllowsTypeSelect(_: boolean): any;
        autohidesScroller: boolean;
        setAutohidesScroller(_: boolean): any;
        backgroundColor: NSColor;
        setBackgroundColor(_: NSColor): any;
        cellPrototype: any;
        setCellPrototype(_: any): any;
        clickedColumn: number;
        clickedRow: number;
        columnResizingType: NSBrowser.ColumnResizingType;
        setColumnResizingType(_: NSBrowser.ColumnResizingType): any;
        columnsAutosaveName: string;
        setColumnsAutosaveName(_: string): any;
        delegate: NSBrowserDelegate;
        setDelegate(_: NSBrowserDelegate): any;
        doubleAction: string;
        setDoubleAction(_: string): any;
        firstVisibleColumn: number;
        hasHorizontalScroller: boolean;
        setHasHorizontalScroller(_: boolean): any;
        lastColumn: number;
        setLastColumn(_: number): any;
        lastVisibleColumn: number;
        isLoaded: boolean;
        maxVisibleColumns: number;
        setMaxVisibleColumns(_: number): any;
        minColumnWidth: number;
        setMinColumnWidth(_: number): any;
        numberOfVisibleColumns: number;
        pathSeparator: string;
        setPathSeparator(_: string): any;
        prefersAllColumnUserResizing: boolean;
        setPrefersAllColumnUserResizing(_: boolean): any;
        reusesColumns: boolean;
        setReusesColumns(_: boolean): any;
        rowHeight: number;
        setRowHeight(_: number): any;
        selectedCells: NSCell[];
        selectedColumn: number;
        selectionIndexPath: NSIndexPath;
        setSelectionIndexPath(_: NSIndexPath): any;
        selectionIndexPaths: NSIndexPath[];
        setSelectionIndexPaths(_: NSIndexPath[]): any;
        sendsActionOnArrowKeys: boolean;
        setSendsActionOnArrowKeys(_: boolean): any;
        separatesColumns: boolean;
        setSeparatesColumns(_: boolean): any;
        takesTitleFromPreviousColumn: boolean;
        setTakesTitleFromPreviousColumn(_: boolean): any;
        titleHeight: number;
        isTitled: boolean;
        setTitled(_: boolean): any;
        static cellClass: typeof NSObject;
        addColumn(): void;
        canDragRowsWithIndexesInColumnWithEvent(with_: NSIndexSet, inColumn: number, with_2: NSEvent): boolean;
        columnContentWidthForColumnWidth(forColumnWidth: number): number;
        columnWidthForColumnContentWidth(forColumnContentWidth: number): number;
        defaultColumnWidth(): number;
        doClick(_?: any): void;
        doDoubleClick(_?: any): void;
        draggingImageForRowsWithIndexesInColumnWithEventOffset(with_: NSIndexSet, inColumn: number, with_2: NSEvent, offset?: NSPoint): NSImage;
        drawTitleOfColumnInRect(ofColumn: number, in_: CGRect): void;
        editItemAtIndexPathWithEventSelect(at: NSIndexPath, with_?: NSEvent, select?: boolean): void;
        frameOfColumn(ofColumn: number): CGRect;
        frameOfInsideOfColumn(ofInsideOfColumn: number): CGRect;
        frameOfRowInColumn(ofRow: number, inColumn: number): CGRect;
        getRowColumnForPoint(_?: number, column?: number, for_?: CGPoint): boolean;
        indexPathForColumn(forColumn: number): NSIndexPath;
        isLeafItem(_?: any): boolean;
        itemAtIndexPath(at: NSIndexPath): any;
        itemAtRowInColumn(atRow: number, inColumn: number): any;
        loadColumnZero(): void;
        loadedCellAtRowColumn(atRow: number, column: number): any;
        noteHeightOfRowsWithIndexesChangedInColumn(_: NSIndexSet, inColumn: number): void;
        parentForItemsInColumn(inColumn: number): any;
        path(): string;
        pathToColumn(toColumn: number): string;
        reloadColumn(_: number): void;
        reloadDataForRowIndexesInColumn(forRowIndexes: NSIndexSet, inColumn: number): void;
        scrollColumnToVisible(_: number): void;
        scrollColumnsLeftBy(by: number): void;
        scrollColumnsRightBy(by: number): void;
        scrollRowToVisibleInColumn(_: number, inColumn: number): void;
        selectRowInColumn(_: number, inColumn: number): void;
        selectRowIndexesInColumn(_: NSIndexSet, inColumn: number): void;
        selectedCellInColumn(inColumn: number): any;
        selectedRowInColumn(inColumn: number): number;
        selectedRowIndexesInColumn(inColumn: number): NSIndexSet;
        sendAction(): boolean;
        setCellClass(_: typeof NSObject): void;
        setDefaultColumnWidth(_: number): void;
        setDraggingSourceOperationMaskForLocal(_: NSDragOperation, forLocal: boolean): void;
        setPath(_: string): boolean;
        setTitleOfColumn(_: string, ofColumn: number): void;
        setWidthOfColumn(_: number, ofColumn: number): void;
        tile(): void;
        titleFrameOfColumn(ofColumn: number): CGRect;
        titleOfColumn(ofColumn: number): string;
        validateVisibleColumns(): void;
        widthOfColumn(ofColumn: number): number;
    }
    class NSBrowserCell extends NSCell {
        alternateImage: NSImage;
        setAlternateImage(_: NSImage): any;
        isLeaf: boolean;
        setLeaf(_: boolean): any;
        isLoaded: boolean;
        setLoaded(_: boolean): any;
        static branchImage: NSImage;
        static highlightedBranchImage: NSImage;
        highlightColorInView(in_: NSView): NSColor;
        reset(): void;
        set(): void;
    }
    interface NSBrowserDelegate extends NSObject {
        browserCreateRowsForColumnInMatrix?(_: NSBrowser, createRowsForColumn: number, in_: NSMatrix): void;
        browserNextTypeSelectMatchFromRowToRowInColumnForString?(_: NSBrowser, nextTypeSelectMatchFromRow: number, toRow: number, inColumn: number, for_?: string): number;
        browserShouldTypeSelectForEventWithCurrentSearchString?(_: NSBrowser, shouldTypeSelectFor: NSEvent, withCurrentSearch?: string): boolean;
        browserSelectCellWithStringInColumn?(_: NSBrowser, selectCellWith: string, inColumn: number): boolean;
        browserDraggingImageForRowsWithIndexesInColumnWithEventOffset?(_: NSBrowser, draggingImageForRowsWith: NSIndexSet, inColumn: number, with_: NSEvent, offset: NSPoint): NSImage;
        browserCanDragRowsWithIndexesInColumnWithEvent?(_: NSBrowser, canDragRowsWith: NSIndexSet, inColumn: number, with_: NSEvent): boolean;
        browserWriteRowsWithIndexesInColumnToPasteboard?(_: NSBrowser, writeRowsWith: NSIndexSet, inColumn: number, to: NSPasteboard): boolean;
        browserAcceptDropAtRowColumnDropOperation?(_: NSBrowser, acceptDrop: NSDraggingInfo, atRow: number, column: number, dropOperation: NSBrowser.DropOperation): boolean;
        browserChildOfItem?(_: NSBrowser, child: number, ofItem?: any): any;
        browserDidChangeLastColumnToColumn?(_: NSBrowser, didChangeLastColumn: number, toColumn: number): void;
        browserHeaderViewControllerForItem?(_: NSBrowser, headerViewControllerForItem?: any): NSViewController;
        browserHeightOfRowInColumn?(_: NSBrowser, heightOfRow: number, inColumn: number): number;
        browserIsColumnValid?(_: NSBrowser, isColumnValid: number): boolean;
        browserIsLeafItem?(_: NSBrowser, isLeafItem?: any): boolean;
        browserNumberOfChildrenOfItem?(_: NSBrowser, numberOfChildrenOfItem?: any): number;
        browserNumberOfRowsInColumn?(_: NSBrowser, numberOfRowsInColumn: number): number;
        browserObjectValueForItem?(_: NSBrowser, objectValueForItem?: any): any;
        browserPreviewViewControllerForLeafItem?(_: NSBrowser, previewViewControllerForLeafItem: any): NSViewController;
        browserSelectionIndexesForProposedSelectionInColumn?(_: NSBrowser, selectionIndexesForProposedSelection: NSIndexSet, inColumn: number): NSIndexSet;
        browserSelectRowInColumn?(_: NSBrowser, selectRow: number, inColumn: number): boolean;
        browserSetObjectValueForItem?(_: NSBrowser, setObjectValue?: any, forItem?: any): void;
        browserShouldEditItem?(_: NSBrowser, shouldEditItem?: any): boolean;
        browserShouldShowCellExpansionForRowColumn?(_: NSBrowser, shouldShowCellExpansionForRow: number, column: number): boolean;
        browserShouldSizeColumnForUserResizeToWidth?(_: NSBrowser, shouldSizeColumn: number, forUserResize: boolean, toWidth: number): number;
        browserSizeToFitWidthOfColumn?(_: NSBrowser, sizeToFitWidthOfColumn: number): number;
        browserTitleOfColumn?(_: NSBrowser, titleOfColumn: number): string;
        browserTypeSelectStringForRowInColumn?(_: NSBrowser, typeSelectStringForRow: number, inColumn: number): string;
        browserValidateDropProposedRowColumnDropOperation?(_: NSBrowser, validateDrop: NSDraggingInfo, proposedRow: number, column: number, dropOperation: NSBrowser.DropOperation): NSDragOperation;
        browserWillDisplayCellAtRowColumn?(_: NSBrowser, willDisplayCell: any, atRow: number, column: number): void;
        browserColumnConfigurationDidChange?(_: NSNotification): void;
        browserDidScroll?(_: NSBrowser): void;
        browserWillScroll?(_: NSBrowser): void;
        rootItemForBrowser?(for_: NSBrowser): any;
    }
    class NSButton extends NSControl {
        static checkboxWithTitleTargetAction(checkboxWithTitle: string, target?: any, action?: string): NSButton;
        static radioButtonWithTitleTargetAction(radioButtonWithTitle: string, target?: any, action?: string): NSButton;
        allowsMixedState: boolean;
        setAllowsMixedState(_: boolean): any;
        alternateImage: NSImage;
        setAlternateImage(_: NSImage): any;
        alternateTitle: string;
        setAlternateTitle(_: string): any;
        attributedAlternateTitle: NSAttributedString;
        setAttributedAlternateTitle(_: NSAttributedString): any;
        attributedTitle: NSAttributedString;
        setAttributedTitle(_: NSAttributedString): any;
        bezelColor: NSColor;
        setBezelColor(_: NSColor): any;
        bezelStyle: NSButton.BezelStyle;
        setBezelStyle(_: NSButton.BezelStyle): any;
        isBordered: boolean;
        setBordered(_: boolean): any;
        contentTintColor: NSColor;
        setContentTintColor(_: NSColor): any;
        image: NSImage;
        setImage(_: NSImage): any;
        imageHugsTitle: boolean;
        setImageHugsTitle(_: boolean): any;
        imagePosition: NSControl.ImagePosition;
        setImagePosition(_: NSControl.ImagePosition): any;
        imageScaling: NSImageScaling;
        setImageScaling(_: NSImageScaling): any;
        keyEquivalent: string;
        setKeyEquivalent(_: string): any;
        keyEquivalentModifierMask: NSEvent.ModifierFlags;
        setKeyEquivalentModifierMask(_: NSEvent.ModifierFlags): any;
        maxAcceleratorLevel: number;
        setMaxAcceleratorLevel(_: number): any;
        showsBorderOnlyWhileMouseInside: boolean;
        setShowsBorderOnlyWhileMouseInside(_: boolean): any;
        sound: NSSound;
        setSound(_: NSSound): any;
        isSpringLoaded: boolean;
        setSpringLoaded(_: boolean): any;
        state: number;
        setState(_: number): any;
        title: string;
        setTitle(_: string): any;
        isTransparent: boolean;
        setTransparent(_: boolean): any;
        getPeriodicDelayInterval(_: number, interval: number): void;
        highlight(_: boolean): void;
        setButtonType(_: NSButton.ButtonType): void;
        setNextState(): void;
        setPeriodicDelayInterval(_: number, interval: number): void;
    }
    class NSButtonCell extends NSActionCell {
        alternateImage: NSImage;
        setAlternateImage(_: NSImage): any;
        alternateTitle: string;
        setAlternateTitle(_: string): any;
        attributedAlternateTitle: NSAttributedString;
        setAttributedAlternateTitle(_: NSAttributedString): any;
        attributedTitle: NSAttributedString;
        setAttributedTitle(_: NSAttributedString): any;
        backgroundColor: NSColor;
        setBackgroundColor(_: NSColor): any;
        bezelStyle: NSButton.BezelStyle;
        setBezelStyle(_: NSButton.BezelStyle): any;
        highlightsBy: NSCell.StyleMask;
        setHighlightsBy(_: NSCell.StyleMask): any;
        imageDimsWhenDisabled: boolean;
        setImageDimsWhenDisabled(_: boolean): any;
        imagePosition: NSControl.ImagePosition;
        setImagePosition(_: NSControl.ImagePosition): any;
        imageScaling: NSImageScaling;
        setImageScaling(_: NSImageScaling): any;
        keyEquivalentModifierMask: NSEvent.ModifierFlags;
        setKeyEquivalentModifierMask(_: NSEvent.ModifierFlags): any;
        showsBorderOnlyWhileMouseInside: boolean;
        setShowsBorderOnlyWhileMouseInside(_: boolean): any;
        showsStateBy: NSCell.StyleMask;
        setShowsStateBy(_: NSCell.StyleMask): any;
        sound: NSSound;
        setSound(_: NSSound): any;
        isTransparent: boolean;
        setTransparent(_: boolean): any;
        drawBezelWithFrameInView(withFrame: CGRect, in_: NSView): void;
        drawImageWithFrameInView(_: NSImage, withFrame: CGRect, in_: NSView): void;
        drawTitleWithFrameInView(_: NSAttributedString, withFrame: CGRect, in_: NSView): CGRect;
        mouseEntered(with_: NSEvent): void;
        mouseExited(with_: NSEvent): void;
        setButtonType(_: NSButton.ButtonType): void;
        setPeriodicDelayInterval(_: number, interval: number): void;
    }
    class NSButtonTouchBarItem extends NSTouchBarItem {
        action: string;
        setAction(_: string): any;
        bezelColor: NSColor;
        setBezelColor(_: NSColor): any;
        isEnabled: boolean;
        setEnabled(_: boolean): any;
        image: NSImage;
        setImage(_: NSImage): any;
        target: any;
        setTarget(_: any): any;
        title: string;
        setTitle(_: string): any;
    }
    class NSCIImageRep extends NSImageRep {
        CIImage: CIImage;
        static createWithCIImage(CIImage: CIImage): NSCIImageRep;
    }
    class NSCandidateListTouchBarItem<CandidateType> extends NSTouchBarItem {
        allowsCollapsing: boolean;
        setAllowsCollapsing(_: boolean): any;
        allowsTextInputContextCandidates: boolean;
        setAllowsTextInputContextCandidates(_: boolean): any;
        attributedStringForCandidate: (p1: CandidateType, p2: number) => NSAttributedString;
        setAttributedStringForCandidate(_: (p1: CandidateType, p2: number) => NSAttributedString): any;
        isCandidateListVisible: boolean;
        candidates: CandidateType[];
        client: NSView;
        setClient(_: NSView): any;
        isCollapsed: boolean;
        setCollapsed(_: boolean): any;
        delegate: NSCandidateListTouchBarItemDelegate;
        setDelegate(_: NSCandidateListTouchBarItemDelegate): any;
        setCandidatesForSelectedRangeInString(_: CandidateType[], forSelectedRange: NSRange, in_?: string): void;
        updateWithInsertionPointVisibility(withInsertionPointVisibility: boolean): void;
    }
    interface NSCandidateListTouchBarItemDelegate extends NSObject {
        candidateListTouchBarItemBeginSelectingCandidateAtIndex?(_: NSCandidateListTouchBarItem<any>, beginSelectingCandidateAt: number): void;
        candidateListTouchBarItemChangeSelectionFromCandidateAtIndexToIndex?(_: NSCandidateListTouchBarItem<any>, changeSelectionFromCandidateAt: number, to: number): void;
        candidateListTouchBarItemEndSelectingCandidateAtIndex?(_: NSCandidateListTouchBarItem<any>, endSelectingCandidateAt: number): void;
        candidateListTouchBarItemChangedCandidateListVisibility?(_: NSCandidateListTouchBarItem<any>, changedCandidateListVisibility: boolean): void;
    }
    class NSCell extends NSObject {
        acceptsFirstResponder: boolean;
        action: string;
        setAction(_: string): any;
        alignment: NSTextAlignment;
        setAlignment(_: NSTextAlignment): any;
        allowsEditingTextAttributes: boolean;
        setAllowsEditingTextAttributes(_: boolean): any;
        allowsMixedState: boolean;
        setAllowsMixedState(_: boolean): any;
        allowsUndo: boolean;
        setAllowsUndo(_: boolean): any;
        attributedStringValue: NSAttributedString;
        setAttributedStringValue(_: NSAttributedString): any;
        backgroundStyle: NSView.BackgroundStyle;
        setBackgroundStyle(_: NSView.BackgroundStyle): any;
        baseWritingDirection: NSWritingDirection;
        setBaseWritingDirection(_: NSWritingDirection): any;
        isBezeled: boolean;
        setBezeled(_: boolean): any;
        isBordered: boolean;
        setBordered(_: boolean): any;
        cellSize: CGSize;
        isContinuous: boolean;
        setContinuous(_: boolean): any;
        controlSize: NSControl.ControlSize;
        setControlSize(_: NSControl.ControlSize): any;
        controlView: NSView;
        setControlView(_: NSView): any;
        doubleValue: number;
        setDoubleValue(_: number): any;
        isEditable: boolean;
        setEditable(_: boolean): any;
        isEnabled: boolean;
        setEnabled(_: boolean): any;
        floatValue: number;
        setFloatValue(_: number): any;
        focusRingType: NSFocusRingType;
        setFocusRingType(_: NSFocusRingType): any;
        font: NSFont;
        setFont(_: NSFont): any;
        formatter: Formatter;
        setFormatter(_: Formatter): any;
        hasValidObjectValue: boolean;
        isHighlighted: boolean;
        setHighlighted(_: boolean): any;
        image: NSImage;
        setImage(_: NSImage): any;
        importsGraphics: boolean;
        setImportsGraphics(_: boolean): any;
        intValue: number;
        setIntValue(_: number): any;
        integerValue: number;
        setIntegerValue(_: number): any;
        interiorBackgroundStyle: NSView.BackgroundStyle;
        keyEquivalent: string;
        lineBreakMode: NSLineBreakMode;
        setLineBreakMode(_: NSLineBreakMode): any;
        menu: NSMenu;
        setMenu(_: NSMenu): any;
        mouseDownFlags: number;
        nextState: number;
        objectValue: any;
        setObjectValue(_: any): any;
        isOpaque: boolean;
        refusesFirstResponder: boolean;
        setRefusesFirstResponder(_: boolean): any;
        representedObject: any;
        setRepresentedObject(_: any): any;
        isScrollable: boolean;
        setScrollable(_: boolean): any;
        isSelectable: boolean;
        setSelectable(_: boolean): any;
        sendsActionOnEndEditing: boolean;
        setSendsActionOnEndEditing(_: boolean): any;
        showsFirstResponder: boolean;
        setShowsFirstResponder(_: boolean): any;
        state: number;
        setState(_: number): any;
        stringValue: string;
        setStringValue(_: string): any;
        tag: number;
        setTag(_: number): any;
        target: any;
        setTarget(_: any): any;
        title: string;
        setTitle(_: string): any;
        truncatesLastVisibleLine: boolean;
        setTruncatesLastVisibleLine(_: boolean): any;
        type: NSCell.CellType;
        setType(_: NSCell.CellType): any;
        userInterfaceLayoutDirection: NSUserInterfaceLayoutDirection;
        setUserInterfaceLayoutDirection(_: NSUserInterfaceLayoutDirection): any;
        usesSingleLineMode: boolean;
        setUsesSingleLineMode(_: boolean): any;
        wantsNotificationForMarkedText: boolean;
        wraps: boolean;
        setWraps(_: boolean): any;
        static defaultFocusRingType: NSFocusRingType;
        static defaultMenu: NSMenu;
        static prefersTrackingUntilMouseUp: boolean;
        calcDrawInfo(_: CGRect): void;
        cellAttribute(_: NSCell.Attribute): number;
        cellSizeForBounds(forBounds: CGRect): CGSize;
        compare(_: any): ComparisonResult;
        continueTrackingAtInView(last: CGPoint, current: CGPoint, in_: NSView): boolean;
        draggingImageComponentsWithFrameInView(withFrame: CGRect, in_: NSView): NSDraggingImageComponent[];
        drawFocusRingMaskWithFrameInView(withFrame: CGRect, in_: NSView): void;
        drawInteriorWithFrameInView(withFrame: CGRect, in_: NSView): void;
        drawWithExpansionFrameInView(withExpansionFrame: CGRect, in_: NSView): void;
        drawWithFrameInView(withFrame: CGRect, in_: NSView): void;
        drawingRectForBounds(forBounds: CGRect): CGRect;
        editWithFrameInViewEditorDelegateEvent(withFrame: CGRect, in_: NSView, editor: NSText, delegate?: any, event?: NSEvent): void;
        endEditing(_: NSText): void;
        expansionFrameWithFrameInView(withFrame: CGRect, in_: NSView): CGRect;
        fieldEditorForView(for_: NSView): NSTextView;
        focusRingMaskBoundsForFrameInView(forFrame: CGRect, in_: NSView): CGRect;
        getPeriodicDelayInterval(_: number, interval: number): void;
        highlightWithFrameInView(_: boolean, withFrame: CGRect, in_: NSView): void;
        highlightColorWithFrameInView(withFrame: CGRect, in_: NSView): NSColor;
        hitTestForEventInRectOfView(for_: NSEvent, in_: CGRect, of: NSView): NSCell.HitResult;
        imageRectForBounds(forBounds: CGRect): CGRect;
        static createWithImageCell(imageCell?: NSImage): NSCell;
        static createWithTextCell(textCell: string): NSCell;
        menuForEventInRectOfView(for_: NSEvent, in_: CGRect, of: NSView): NSMenu;
        performClick(_?: any): void;
        resetCursorRectInView(_: CGRect, in_: NSView): void;
        selectWithFrameInViewEditorDelegateStartLength(withFrame: CGRect, in_: NSView, editor: NSText, delegate?: any, start?: number, length?: number): void;
        sendActionOn(on: NSEvent.EventTypeMask): number;
        setCellAttributeTo(_: NSCell.Attribute, to: number): void;
        setNextState(): void;
        setUpFieldEditorAttributes(_: NSText): NSText;
        startTrackingAtInView(at: CGPoint, in_: NSView): boolean;
        stopTrackingAtInViewMouseIsUp(last: CGPoint, current: CGPoint, in_: NSView, mouseIsUp: boolean): void;
        takeDoubleValueFrom(_?: any): void;
        takeFloatValueFrom(_?: any): void;
        takeIntValueFrom(_?: any): void;
        takeIntegerValueFrom(_?: any): void;
        takeObjectValueFrom(_?: any): void;
        takeStringValueFrom(_?: any): void;
        titleRectForBounds(forBounds: CGRect): CGRect;
        trackMouseInRectOfViewUntilMouseUp(with_: NSEvent, in_: CGRect, of: NSView, untilMouseUp: boolean): boolean;
    }
    interface NSChangeSpelling {
        changeSpelling(_?: any): void;
    }
    class NSClickGestureRecognizer extends NSGestureRecognizer {
        buttonMask: number;
        setButtonMask(_: number): any;
        numberOfClicksRequired: number;
        setNumberOfClicksRequired(_: number): any;
        numberOfTouchesRequired: number;
        setNumberOfTouchesRequired(_: number): any;
    }
    class NSClipView extends NSView {
        automaticallyAdjustsContentInsets: boolean;
        setAutomaticallyAdjustsContentInsets(_: boolean): any;
        backgroundColor: NSColor;
        setBackgroundColor(_: NSColor): any;
        contentInsets: NSEdgeInsets;
        setContentInsets(_: NSEdgeInsets): any;
        documentCursor: NSCursor;
        setDocumentCursor(_: NSCursor): any;
        documentRect: CGRect;
        documentView: NSView;
        setDocumentView(_: NSView): any;
        documentVisibleRect: CGRect;
        drawsBackground: boolean;
        setDrawsBackground(_: boolean): any;
        constrainBoundsRect(_: CGRect): CGRect;
        scrollToPoint(to: CGPoint): void;
        viewBoundsChanged(_: NSNotification): void;
        viewFrameChanged(_: NSNotification): void;
    }
    interface NSCloudSharingServiceDelegate extends NSSharingServiceDelegate {
        optionsForSharingServiceShareProvider?(for_: NSSharingService, share: NSItemProvider): NSSharingService.CloudKitOptions;
        sharingServiceDidSaveShare?(_: NSSharingService, didSave: CKShare): void;
        sharingServiceDidCompleteForItemsError?(_: NSSharingService, didCompleteForItems: any[], error?: NSError): void;
        sharingServiceDidStopSharing?(_: NSSharingService, didStopSharing: CKShare): void;
    }
    interface NSCloudSharingValidation extends NSObject {
        cloudShareForUserInterfaceItem(for_: NSValidatedUserInterfaceItem): CKShare;
    }
    class NSCollectionLayoutAnchor extends NSObject {
        static layoutAnchorWithEdges(edges: NSDirectionalRectEdge): NSCollectionLayoutAnchor;
        static layoutAnchorWithEdgesAbsoluteOffset(edges: NSDirectionalRectEdge, absoluteOffset: CGPoint): NSCollectionLayoutAnchor;
        static layoutAnchorWithEdgesFractionalOffset(edges: NSDirectionalRectEdge, fractionalOffset: CGPoint): NSCollectionLayoutAnchor;
        edges: NSDirectionalRectEdge;
        isAbsoluteOffset: boolean;
        isFractionalOffset: boolean;
        offset: CGPoint;
    }
    class NSCollectionLayoutBoundarySupplementaryItem extends NSCollectionLayoutSupplementaryItem {
        static boundarySupplementaryItemWithLayoutSizeElementKindAlignment(layoutSize: NSCollectionLayoutSize, elementKind: string, alignment: NSRectAlignment): NSCollectionLayoutBoundarySupplementaryItem;
        static boundarySupplementaryItemWithLayoutSizeElementKindAlignmentAbsoluteOffset(layoutSize: NSCollectionLayoutSize, elementKind: string, alignment: NSRectAlignment, absoluteOffset: CGPoint): NSCollectionLayoutBoundarySupplementaryItem;
        alignment: NSRectAlignment;
        extendsBoundary: boolean;
        setExtendsBoundary(_: boolean): any;
        offset: CGPoint;
        pinToVisibleBounds: boolean;
        setPinToVisibleBounds(_: boolean): any;
    }
    interface NSCollectionLayoutContainer extends NSObject {
        contentInsets: NSDirectionalEdgeInsets;
        contentSize: CGSize;
        effectiveContentInsets: NSDirectionalEdgeInsets;
        effectiveContentSize: CGSize;
    }
    class NSCollectionLayoutDecorationItem extends NSCollectionLayoutItem {
        static backgroundDecorationItemWithElementKind(elementKind: string): NSCollectionLayoutDecorationItem;
        elementKind: string;
        zIndex: number;
        setZIndex(_: number): any;
    }
    class NSCollectionLayoutDimension extends NSObject {
        static absoluteDimension(_: number): NSCollectionLayoutDimension;
        static estimatedDimension(_: number): NSCollectionLayoutDimension;
        static fractionalHeightDimension(_: number): NSCollectionLayoutDimension;
        static fractionalWidthDimension(_: number): NSCollectionLayoutDimension;
        dimension: number;
        isAbsolute: boolean;
        isEstimated: boolean;
        isFractionalHeight: boolean;
        isFractionalWidth: boolean;
    }
    class NSCollectionLayoutEdgeSpacing extends NSObject {
        static spacingForLeadingTopTrailingBottom(leading?: NSCollectionLayoutSpacing, top?: NSCollectionLayoutSpacing, trailing?: NSCollectionLayoutSpacing, bottom?: NSCollectionLayoutSpacing): NSCollectionLayoutEdgeSpacing;
        bottom: NSCollectionLayoutSpacing;
        leading: NSCollectionLayoutSpacing;
        top: NSCollectionLayoutSpacing;
        trailing: NSCollectionLayoutSpacing;
    }
    interface NSCollectionLayoutEnvironment extends NSObject {
        container: NSCollectionLayoutContainer;
    }
    class NSCollectionLayoutGroup extends NSCollectionLayoutItem {
        static customWithLayoutSizeItemProvider(layoutSize: NSCollectionLayoutSize, itemProvider: (p1: NSCollectionLayoutEnvironment) => NSCollectionLayoutGroupCustomItem[]): NSCollectionLayoutGroup;
        static horizontalGroupWithLayoutSizeSubitemCount(layoutSize: NSCollectionLayoutSize, subitem: NSCollectionLayoutItem, count: number): NSCollectionLayoutGroup;
        static horizontalGroupWithLayoutSizeSubitems(layoutSize: NSCollectionLayoutSize, subitems: NSCollectionLayoutItem[]): NSCollectionLayoutGroup;
        static verticalGroupWithLayoutSizeSubitemCount(layoutSize: NSCollectionLayoutSize, subitem: NSCollectionLayoutItem, count: number): NSCollectionLayoutGroup;
        static verticalGroupWithLayoutSizeSubitems(layoutSize: NSCollectionLayoutSize, subitems: NSCollectionLayoutItem[]): NSCollectionLayoutGroup;
        interItemSpacing: NSCollectionLayoutSpacing;
        setInterItemSpacing(_: NSCollectionLayoutSpacing): any;
        subitems: NSCollectionLayoutItem[];
        visualDescription(): string;
    }
    class NSCollectionLayoutGroupCustomItem extends NSObject {
        static customItemWithFrame(frame: CGRect): NSCollectionLayoutGroupCustomItem;
        static customItemWithFrameZIndex(frame: CGRect, zIndex: number): NSCollectionLayoutGroupCustomItem;
        frame: CGRect;
        zIndex: number;
    }
    class NSCollectionLayoutItem extends NSObject {
        static itemWithLayoutSize(layoutSize: NSCollectionLayoutSize): NSCollectionLayoutItem;
        static itemWithLayoutSizeSupplementaryItems(layoutSize: NSCollectionLayoutSize, supplementaryItems: NSCollectionLayoutSupplementaryItem[]): NSCollectionLayoutItem;
        contentInsets: NSDirectionalEdgeInsets;
        setContentInsets(_: NSDirectionalEdgeInsets): any;
        edgeSpacing: NSCollectionLayoutEdgeSpacing;
        setEdgeSpacing(_: NSCollectionLayoutEdgeSpacing): any;
        layoutSize: NSCollectionLayoutSize;
        supplementaryItems: NSCollectionLayoutSupplementaryItem[];
    }
    class NSCollectionLayoutSection extends NSObject {
        static sectionWithGroup(group: NSCollectionLayoutGroup): NSCollectionLayoutSection;
        boundarySupplementaryItems: NSCollectionLayoutBoundarySupplementaryItem[];
        setBoundarySupplementaryItems(_: NSCollectionLayoutBoundarySupplementaryItem[]): any;
        contentInsets: NSDirectionalEdgeInsets;
        setContentInsets(_: NSDirectionalEdgeInsets): any;
        decorationItems: NSCollectionLayoutDecorationItem[];
        setDecorationItems(_: NSCollectionLayoutDecorationItem[]): any;
        interGroupSpacing: number;
        setInterGroupSpacing(_: number): any;
        orthogonalScrollingBehavior: NSCollectionLayoutSectionOrthogonalScrollingBehavior;
        setOrthogonalScrollingBehavior(_: NSCollectionLayoutSectionOrthogonalScrollingBehavior): any;
        supplementariesFollowContentInsets: boolean;
        setSupplementariesFollowContentInsets(_: boolean): any;
        visibleItemsInvalidationHandler: (p1: NSCollectionLayoutVisibleItem[], p2: CGPoint, p3: NSCollectionLayoutEnvironment) => void;
        setVisibleItemsInvalidationHandler(_: (p1: NSCollectionLayoutVisibleItem[], p2: CGPoint, p3: NSCollectionLayoutEnvironment) => void): any;
    }
    class NSCollectionLayoutSize extends NSObject {
        static sizeWithWidthDimensionHeightDimension(widthDimension: NSCollectionLayoutDimension, heightDimension: NSCollectionLayoutDimension): NSCollectionLayoutSize;
        heightDimension: NSCollectionLayoutDimension;
        widthDimension: NSCollectionLayoutDimension;
    }
    class NSCollectionLayoutSpacing extends NSObject {
        static fixedSpacing(_: number): NSCollectionLayoutSpacing;
        static flexibleSpacing(_: number): NSCollectionLayoutSpacing;
        isFixedSpacing: boolean;
        isFlexibleSpacing: boolean;
        spacing: number;
    }
    class NSCollectionLayoutSupplementaryItem extends NSCollectionLayoutItem {
        static supplementaryItemWithLayoutSizeElementKindContainerAnchor(layoutSize: NSCollectionLayoutSize, elementKind: string, containerAnchor: NSCollectionLayoutAnchor): NSCollectionLayoutSupplementaryItem;
        static supplementaryItemWithLayoutSizeElementKindContainerAnchorItemAnchor(layoutSize: NSCollectionLayoutSize, elementKind: string, containerAnchor: NSCollectionLayoutAnchor, itemAnchor: NSCollectionLayoutAnchor): NSCollectionLayoutSupplementaryItem;
        containerAnchor: NSCollectionLayoutAnchor;
        elementKind: string;
        itemAnchor: NSCollectionLayoutAnchor;
        zIndex: number;
        setZIndex(_: number): any;
    }
    interface NSCollectionLayoutVisibleItem extends NSObject {
        alpha: number;
        setAlpha(_: number): any;
        bounds: CGRect;
        center: CGPoint;
        setCenter(_: CGPoint): any;
        frame: CGRect;
        isHidden: boolean;
        setHidden(_: boolean): any;
        indexPath: NSIndexPath;
        name: string;
        representedElementCategory: NSCollectionElementCategory;
        representedElementKind: string;
        zIndex: number;
        setZIndex(_: number): any;
    }
    class NSCollectionView extends NSView {
        allowsEmptySelection: boolean;
        setAllowsEmptySelection(_: boolean): any;
        allowsMultipleSelection: boolean;
        setAllowsMultipleSelection(_: boolean): any;
        backgroundColors: NSColor[];
        setBackgroundColors(_: NSColor[]): any;
        backgroundView: NSView;
        setBackgroundView(_: NSView): any;
        backgroundViewScrollsWithContent: boolean;
        setBackgroundViewScrollsWithContent(_: boolean): any;
        collectionViewLayout: NSCollectionViewLayout;
        setCollectionViewLayout(_: NSCollectionViewLayout): any;
        content: any[];
        setContent(_: any[]): any;
        dataSource: NSCollectionViewDataSource;
        setDataSource(_: NSCollectionViewDataSource): any;
        delegate: NSCollectionViewDelegate;
        setDelegate(_: NSCollectionViewDelegate): any;
        isFirstResponder: boolean;
        numberOfSections: number;
        prefetchDataSource: NSCollectionViewPrefetching;
        setPrefetchDataSource(_: NSCollectionViewPrefetching): any;
        isSelectable: boolean;
        setSelectable(_: boolean): any;
        selectionIndexPaths: NSSet<IndexPath>;
        setSelectionIndexPaths(_: NSSet<IndexPath>): any;
        selectionIndexes: NSIndexSet;
        setSelectionIndexes(_: NSIndexSet): any;
        deleteItemsWithAt(at: NSSet<IndexPath>): void;
        deleteSections(_: NSIndexSet): void;
        deselectAll(_?: any): void;
        deselectItemsWithAt(at: NSSet<IndexPath>): void;
        draggingImageForItemsWithAtWithOffset(at: NSSet<IndexPath>, with_: NSEvent, offset: NSPoint): NSImage;
        draggingImageForItemsAtIndexesWithEventOffset(at: NSIndexSet, with_: NSEvent, offset: NSPoint): NSImage;
        frameForItemAtIndex(at: number): CGRect;
        frameForItemAtIndexWithNumberOfItems(at: number, withNumberOfItems: number): CGRect;
        indexPathForItem(for_: NSCollectionViewItem): NSIndexPath;
        indexPathForItemAtPoint(at: CGPoint): NSIndexPath;
        indexPathsForVisibleItems(): NSSet<IndexPath>;
        indexPathsForVisibleSupplementaryElementsOfKind(ofKind: string): NSSet<IndexPath>;
        insertItemsWithAt(at: NSSet<IndexPath>): void;
        insertSections(_: NSIndexSet): void;
        itemAtIndex(at: number): NSCollectionViewItem;
        itemAtIndexPath(at: NSIndexPath): NSCollectionViewItem;
        layoutAttributesForItemAtIndexPath(at: NSIndexPath): NSCollectionViewLayoutAttributes;
        layoutAttributesForSupplementaryElementOfKindAtIndexPath(ofKind: string, at: NSIndexPath): NSCollectionViewLayoutAttributes;
        makeItemWithIdentifierForIndexPath(withIdentifier: string, for_: NSIndexPath): NSCollectionViewItem;
        makeSupplementaryViewOfKindWithIdentifierForIndexPath(ofKind: string, withIdentifier: string, for_: NSIndexPath): NSView;
        moveItemAtIndexPathToIndexPath(at: NSIndexPath, to: NSIndexPath): void;
        moveSectionToSection(_: number, toSection: number): void;
        numberOfItemsInSection(inSection: number): number;
        performBatchUpdatesWithCompletionHandler(_?: () => void, completionHandler?: (p1: boolean) => void): void;
        registerClassForItemWithIdentifier(_?: typeof NSObject, forItemWithIdentifier?: string): void;
        registerClassForSupplementaryViewOfKindWithIdentifier(_?: typeof NSObject, forSupplementaryViewOfKind?: string, withIdentifier?: string): void;
        registerNibForItemWithIdentifier(_?: NSNib, forItemWithIdentifier?: string): void;
        registerNibForSupplementaryViewOfKindWithIdentifier(_?: NSNib, forSupplementaryViewOfKind?: string, withIdentifier?: string): void;
        reloadData(): void;
        reloadItemsWithAt(at: NSSet<IndexPath>): void;
        reloadSections(_: NSIndexSet): void;
        scrollToItemsWithAtScrollPosition(at: NSSet<IndexPath>, scrollPosition: NSCollectionView.ScrollPosition): void;
        selectItemsWithAtScrollPosition(at: NSSet<IndexPath>, scrollPosition: NSCollectionView.ScrollPosition): void;
        setDraggingSourceOperationMaskForLocal(_: NSDragOperation, forLocal: boolean): void;
        supplementaryViewForElementKindAtIndexPath(forElementKind: string, at: NSIndexPath): NSView;
        toggleSectionCollapse(_: any): void;
        visibleItems(): NSCollectionViewItem[];
        visibleSupplementaryViewsOfKind(ofKind: string): NSView[];
    }
    class NSCollectionViewCompositionalLayout extends NSCollectionViewLayout {
        configuration: NSCollectionViewCompositionalLayoutConfiguration;
        setConfiguration(_: NSCollectionViewCompositionalLayoutConfiguration): any;
        static createWithSection(section: NSCollectionLayoutSection): NSCollectionViewCompositionalLayout;
        static createWithSectionConfiguration(section: NSCollectionLayoutSection, configuration: NSCollectionViewCompositionalLayoutConfiguration): NSCollectionViewCompositionalLayout;
        static createWithSectionProvider(sectionProvider: (p1: number, p2: NSCollectionLayoutEnvironment) => NSCollectionLayoutSection): NSCollectionViewCompositionalLayout;
        static createWithSectionProviderConfiguration(sectionProvider: (p1: number, p2: NSCollectionLayoutEnvironment) => NSCollectionLayoutSection, configuration: NSCollectionViewCompositionalLayoutConfiguration): NSCollectionViewCompositionalLayout;
    }
    class NSCollectionViewCompositionalLayoutConfiguration extends NSObject {
        boundarySupplementaryItems: NSCollectionLayoutBoundarySupplementaryItem[];
        setBoundarySupplementaryItems(_: NSCollectionLayoutBoundarySupplementaryItem[]): any;
        interSectionSpacing: number;
        setInterSectionSpacing(_: number): any;
        scrollDirection: NSCollectionView.ScrollDirection;
        setScrollDirection(_: NSCollectionView.ScrollDirection): any;
    }
    interface NSCollectionViewDataSource extends NSObject {
        collectionViewItemForRepresentedObjectAtIndexPath(_: NSCollectionView, itemForRepresentedObjectAt: NSIndexPath): NSCollectionViewItem;
        collectionViewViewForSupplementaryElementOfKindAtIndexPath?(_: NSCollectionView, viewForSupplementaryElementOfKind: string, at: NSIndexPath): NSView;
        collectionViewNumberOfItemsInSection(_: NSCollectionView, numberOfItemsInSection: number): number;
        numberOfSectionsInCollectionView?(in_: NSCollectionView): number;
    }
    interface NSCollectionViewDelegate extends NSObject {
        collectionViewCanDragItemsAtWith?(_: NSCollectionView, canDragItemsAt: NSSet<IndexPath>, with_: NSEvent): boolean;
        collectionViewCanDragItemsAtIndexesWithEvent?(_: NSCollectionView, canDragItemsAt: NSIndexSet, with_: NSEvent): boolean;
        collectionViewWriteItemsAtTo?(_: NSCollectionView, writeItemsAt: NSSet<IndexPath>, to: NSPasteboard): boolean;
        collectionViewWriteItemsAtIndexesToPasteboard?(_: NSCollectionView, writeItemsAt: NSIndexSet, to: NSPasteboard): boolean;
        collectionViewDraggingImageForItemsAtWithOffset?(_: NSCollectionView, draggingImageForItemsAt: NSSet<IndexPath>, with_: NSEvent, offset: NSPoint): NSImage;
        collectionViewDraggingImageForItemsAtIndexesWithEventOffset?(_: NSCollectionView, draggingImageForItemsAt: NSIndexSet, with_: NSEvent, offset: NSPoint): NSImage;
        collectionViewPasteboardWriterForItemAtIndexPath?(_: NSCollectionView, pasteboardWriterForItemAt: NSIndexPath): NSPasteboardWriting;
        collectionViewPasteboardWriterForItemAtIndex?(_: NSCollectionView, pasteboardWriterForItemAt: number): NSPasteboardWriting;
        collectionViewDraggingSessionWillBeginAtForItemsAt?(_: NSCollectionView, draggingSession: NSDraggingSession, willBeginAt: CGPoint, forItemsAt: NSSet<IndexPath>): void;
        collectionViewDraggingSessionWillBeginAtPointForItemsAtIndexes?(_: NSCollectionView, draggingSession: NSDraggingSession, willBeginAt: CGPoint, forItemsAt: NSIndexSet): void;
        collectionViewDraggingSessionEndedAtPointDragOperation?(_: NSCollectionView, draggingSession: NSDraggingSession, endedAt: CGPoint, dragOperation: NSDragOperation): void;
        collectionViewShouldChangeItemsAtTo?(_: NSCollectionView, shouldChangeItemsAt: NSSet<IndexPath>, to: NSCollectionViewItem.HighlightState): NSSet<IndexPath>;
        collectionViewDidChangeItemsAtTo?(_: NSCollectionView, didChangeItemsAt: NSSet<IndexPath>, to: NSCollectionViewItem.HighlightState): void;
        collectionViewShouldSelectItemsAt?(_: NSCollectionView, shouldSelectItemsAt: NSSet<IndexPath>): NSSet<IndexPath>;
        collectionViewShouldDeselectItemsAt?(_: NSCollectionView, shouldDeselectItemsAt: NSSet<IndexPath>): NSSet<IndexPath>;
        collectionViewDidSelectItemsAt?(_: NSCollectionView, didSelectItemsAt: NSSet<IndexPath>): void;
        collectionViewDidDeselectItemsAt?(_: NSCollectionView, didDeselectItemsAt: NSSet<IndexPath>): void;
        collectionViewWillDisplayItemForRepresentedObjectAtIndexPath?(_: NSCollectionView, willDisplay: NSCollectionViewItem, forRepresentedObjectAt: NSIndexPath): void;
        collectionViewWillDisplaySupplementaryViewForElementKindAtIndexPath?(_: NSCollectionView, willDisplaySupplementaryView: NSView, forElementKind: string, at: NSIndexPath): void;
        collectionViewDidEndDisplayingItemForRepresentedObjectAtIndexPath?(_: NSCollectionView, didEndDisplaying: NSCollectionViewItem, forRepresentedObjectAt: NSIndexPath): void;
        collectionViewDidEndDisplayingSupplementaryViewForElementOfKindAtIndexPath?(_: NSCollectionView, didEndDisplayingSupplementaryView: NSView, forElementOfKind: string, at: NSIndexPath): void;
        collectionViewAcceptDropIndexDropOperation?(_: NSCollectionView, acceptDrop: NSDraggingInfo, index: number, dropOperation: NSCollectionView.DropOperation): boolean;
        collectionViewAcceptDropIndexPathDropOperation?(_: NSCollectionView, acceptDrop: NSDraggingInfo, indexPath: NSIndexPath, dropOperation: NSCollectionView.DropOperation): boolean;
        collectionViewTransitionLayoutForOldLayoutNewLayout?(_: NSCollectionView, transitionLayoutForOldLayout: NSCollectionViewLayout, newLayout: NSCollectionViewLayout): NSCollectionViewTransitionLayout;
        collectionViewUpdateDraggingItemsForDrag?(_: NSCollectionView, updateDraggingItemsForDrag: NSDraggingInfo): void;
        collectionViewValidateDropProposedIndexDropOperation?(_: NSCollectionView, validateDrop: NSDraggingInfo, proposedIndex: number, dropOperation: NSCollectionView.DropOperation): NSDragOperation;
        collectionViewValidateDropProposedIndexPathDropOperation?(_: NSCollectionView, validateDrop: NSDraggingInfo, proposedIndexPath: IndexPath, dropOperation: NSCollectionView.DropOperation): NSDragOperation;
    }
    interface NSCollectionViewDelegateFlowLayout extends NSCollectionViewDelegate {
        collectionViewLayoutSizeForItemAtIndexPath?(_: NSCollectionView, layout: NSCollectionViewLayout, sizeForItemAt: NSIndexPath): CGSize;
        collectionViewLayoutInsetForSectionAtIndex?(_: NSCollectionView, layout: NSCollectionViewLayout, insetForSectionAt: number): NSEdgeInsets;
        collectionViewLayoutMinimumLineSpacingForSectionAtIndex?(_: NSCollectionView, layout: NSCollectionViewLayout, minimumLineSpacingForSectionAt: number): number;
        collectionViewLayoutMinimumInteritemSpacingForSectionAtIndex?(_: NSCollectionView, layout: NSCollectionViewLayout, minimumInteritemSpacingForSectionAt: number): number;
        collectionViewLayoutReferenceSizeForFooterInSection?(_: NSCollectionView, layout: NSCollectionViewLayout, referenceSizeForFooterInSection: number): CGSize;
        collectionViewLayoutReferenceSizeForHeaderInSection?(_: NSCollectionView, layout: NSCollectionViewLayout, referenceSizeForHeaderInSection: number): CGSize;
    }
    class NSCollectionViewDiffableDataSourceReference<SectionIdentifierType, ItemIdentifierType> extends NSObject {
        supplementaryViewProvider: (p1: NSCollectionView, p2: string, p3: NSIndexPath) => NSView;
        setSupplementaryViewProvider(_: (p1: NSCollectionView, p2: string, p3: NSIndexPath) => NSView): any;
        applySnapshotWithAnimatingDifferences(_: NSDiffableDataSourceSnapshotReference<SectionIdentifierType, ItemIdentifierType>, animatingDifferences: boolean): void;
        indexPathForItemIdentifier(_: ItemIdentifierType): NSIndexPath;
        itemIdentifierForIndexPath(_: NSIndexPath): ItemIdentifierType;
        snapshot(): NSDiffableDataSourceSnapshotReference<SectionIdentifierType, ItemIdentifierType>;
    }
    interface NSCollectionViewElement extends NSObject, NSUserInterfaceItemIdentification {
        applyLayoutAttributes?(_: NSCollectionViewLayoutAttributes): void;
        didTransitionFromLayoutToLayout?(from: NSCollectionViewLayout, to: NSCollectionViewLayout): void;
        preferredLayoutAttributesFittingAttributes?(_: NSCollectionViewLayoutAttributes): NSCollectionViewLayoutAttributes;
        prepareForReuse?(): void;
        willTransitionFromLayoutToLayout?(from: NSCollectionViewLayout, to: NSCollectionViewLayout): void;
    }
    class NSCollectionViewFlowLayout extends NSCollectionViewLayout {
        estimatedItemSize: CGSize;
        setEstimatedItemSize(_: CGSize): any;
        footerReferenceSize: CGSize;
        setFooterReferenceSize(_: CGSize): any;
        headerReferenceSize: CGSize;
        setHeaderReferenceSize(_: CGSize): any;
        itemSize: CGSize;
        setItemSize(_: CGSize): any;
        minimumInteritemSpacing: number;
        setMinimumInteritemSpacing(_: number): any;
        minimumLineSpacing: number;
        setMinimumLineSpacing(_: number): any;
        scrollDirection: NSCollectionView.ScrollDirection;
        setScrollDirection(_: NSCollectionView.ScrollDirection): any;
        sectionFootersPinToVisibleBounds: boolean;
        setSectionFootersPinToVisibleBounds(_: boolean): any;
        sectionHeadersPinToVisibleBounds: boolean;
        setSectionHeadersPinToVisibleBounds(_: boolean): any;
        sectionInset: NSEdgeInsets;
        setSectionInset(_: NSEdgeInsets): any;
        collapseSectionAtIndex(at: number): void;
        expandSectionAtIndex(at: number): void;
        sectionAtIndexIsCollapsed(atIndexIsCollapsed: number): boolean;
    }
    class NSCollectionViewFlowLayoutInvalidationContext extends NSCollectionViewLayoutInvalidationContext {
        invalidateFlowLayoutAttributes: boolean;
        setInvalidateFlowLayoutAttributes(_: boolean): any;
        invalidateFlowLayoutDelegateMetrics: boolean;
        setInvalidateFlowLayoutDelegateMetrics(_: boolean): any;
    }
    class NSCollectionViewGridLayout extends NSCollectionViewLayout {
        backgroundColors: NSColor[];
        setBackgroundColors(_: NSColor[]): any;
        margins: NSEdgeInsets;
        setMargins(_: NSEdgeInsets): any;
        maximumItemSize: CGSize;
        setMaximumItemSize(_: CGSize): any;
        maximumNumberOfColumns: number;
        setMaximumNumberOfColumns(_: number): any;
        maximumNumberOfRows: number;
        setMaximumNumberOfRows(_: number): any;
        minimumInteritemSpacing: number;
        setMinimumInteritemSpacing(_: number): any;
        minimumItemSize: CGSize;
        setMinimumItemSize(_: CGSize): any;
        minimumLineSpacing: number;
        setMinimumLineSpacing(_: number): any;
    }
    class NSCollectionViewItem extends NSViewController {
        collectionView: NSCollectionView;
        draggingImageComponents: NSDraggingImageComponent[];
        highlightState: NSCollectionViewItem.HighlightState;
        setHighlightState(_: NSCollectionViewItem.HighlightState): any;
        imageView: NSImageView;
        setImageView(_: NSImageView): any;
        isSelected: boolean;
        setSelected(_: boolean): any;
        textField: NSTextField;
        setTextField(_: NSTextField): any;
    }
    class NSCollectionViewLayout extends NSObject {
        collectionView: NSCollectionView;
        collectionViewContentSize: CGSize;
        static invalidationContextClass: typeof NSObject;
        static layoutAttributesClass: typeof NSObject;
        finalLayoutAttributesForDisappearingDecorationElementOfKindAtIndexPath(ofKind: string, at: NSIndexPath): NSCollectionViewLayoutAttributes;
        finalLayoutAttributesForDisappearingItemAtIndexPath(at: NSIndexPath): NSCollectionViewLayoutAttributes;
        finalLayoutAttributesForDisappearingSupplementaryElementOfKindAtIndexPath(ofKind: string, at: NSIndexPath): NSCollectionViewLayoutAttributes;
        finalizeAnimatedBoundsChange(): void;
        finalizeCollectionViewUpdates(): void;
        finalizeLayoutTransition(): void;
        indexPathsToDeleteForDecorationViewOfKind(ofKind: string): NSSet<IndexPath>;
        indexPathsToDeleteForSupplementaryViewOfKind(ofKind: string): NSSet<IndexPath>;
        indexPathsToInsertForDecorationViewOfKind(ofKind: string): NSSet<IndexPath>;
        indexPathsToInsertForSupplementaryViewOfKind(ofKind: string): NSSet<IndexPath>;
        initialLayoutAttributesForAppearingDecorationElementOfKindAtIndexPath(ofKind: string, at: NSIndexPath): NSCollectionViewLayoutAttributes;
        initialLayoutAttributesForAppearingItemAtIndexPath(at: NSIndexPath): NSCollectionViewLayoutAttributes;
        initialLayoutAttributesForAppearingSupplementaryElementOfKindAtIndexPath(ofKind: string, at: NSIndexPath): NSCollectionViewLayoutAttributes;
        invalidateLayout(): void;
        invalidateLayoutWithContext(with_: NSCollectionViewLayoutInvalidationContext): void;
        invalidationContextForBoundsChange(forBoundsChange: CGRect): NSCollectionViewLayoutInvalidationContext;
        invalidationContextForPreferredLayoutAttributesWithOriginalAttributes(forPreferredLayoutAttributes: NSCollectionViewLayoutAttributes, withOriginalAttributes: NSCollectionViewLayoutAttributes): NSCollectionViewLayoutInvalidationContext;
        layoutAttributesForDecorationViewOfKindAtIndexPath(ofKind: string, at: NSIndexPath): NSCollectionViewLayoutAttributes;
        layoutAttributesForDropTargetAtPoint(at: CGPoint): NSCollectionViewLayoutAttributes;
        layoutAttributesForElementsInRect(in_: CGRect): NSCollectionViewLayoutAttributes[];
        layoutAttributesForInterItemGapBeforeIndexPath(before: NSIndexPath): NSCollectionViewLayoutAttributes;
        layoutAttributesForItemAtIndexPath(at: NSIndexPath): NSCollectionViewLayoutAttributes;
        layoutAttributesForSupplementaryViewOfKindAtIndexPath(ofKind: string, at: NSIndexPath): NSCollectionViewLayoutAttributes;
        prepareForAnimatedBoundsChange(forAnimatedBoundsChange: CGRect): void;
        prepareForCollectionViewUpdates(forCollectionViewUpdates: NSCollectionViewUpdateItem[]): void;
        prepareForTransitionFromLayout(from: NSCollectionViewLayout): void;
        prepareForTransitionToLayout(to: NSCollectionViewLayout): void;
        prepareLayout(): void;
        registerClassForDecorationViewOfKind(_?: typeof NSObject, forDecorationViewOfKind?: string): void;
        registerNibForDecorationViewOfKind(_?: NSNib, forDecorationViewOfKind?: string): void;
        shouldInvalidateLayoutForBoundsChange(forBoundsChange: CGRect): boolean;
        shouldInvalidateLayoutForPreferredLayoutAttributesWithOriginalAttributes(forPreferredLayoutAttributes: NSCollectionViewLayoutAttributes, withOriginalAttributes: NSCollectionViewLayoutAttributes): boolean;
        targetContentOffsetForProposedContentOffset(forProposedContentOffset: CGPoint): CGPoint;
        targetContentOffsetForProposedContentOffsetWithScrollingVelocity(forProposedContentOffset: CGPoint, withScrollingVelocity: CGPoint): CGPoint;
    }
    class NSCollectionViewLayoutAttributes extends NSObject {
        static layoutAttributesForDecorationViewOfKindWithIndexPath(forDecorationViewOfKind: string, with_: NSIndexPath): NSCollectionViewLayoutAttributes;
        static layoutAttributesForInterItemGapBeforeIndexPath(forInterItemGapBefore: NSIndexPath): NSCollectionViewLayoutAttributes;
        static layoutAttributesForItemWithIndexPath(forItemWith: NSIndexPath): NSCollectionViewLayoutAttributes;
        static layoutAttributesForSupplementaryViewOfKindWithIndexPath(forSupplementaryViewOfKind: string, with_: NSIndexPath): NSCollectionViewLayoutAttributes;
        alpha: number;
        setAlpha(_: number): any;
        frame: CGRect;
        setFrame(_: CGRect): any;
        isHidden: boolean;
        setHidden(_: boolean): any;
        indexPath: NSIndexPath;
        setIndexPath(_: NSIndexPath): any;
        representedElementCategory: NSCollectionElementCategory;
        representedElementKind: string;
        size: CGSize;
        setSize(_: CGSize): any;
        zIndex: number;
        setZIndex(_: number): any;
    }
    class NSCollectionViewLayoutInvalidationContext extends NSObject {
        contentOffsetAdjustment: CGPoint;
        setContentOffsetAdjustment(_: CGPoint): any;
        contentSizeAdjustment: CGSize;
        setContentSizeAdjustment(_: CGSize): any;
        invalidateDataSourceCounts: boolean;
        invalidateEverything: boolean;
        invalidatedDecorationIndexPaths: Map<string, NSSet<IndexPath>>;
        invalidatedItemIndexPaths: NSSet<IndexPath>;
        invalidatedSupplementaryIndexPaths: Map<string, NSSet<IndexPath>>;
        invalidateDecorationElementsWithOfKindAt(ofKind: string, at: NSSet<IndexPath>): void;
        invalidateItemsWithAt(at: NSSet<IndexPath>): void;
        invalidateSupplementaryElementsWithOfKindAt(ofKind: string, at: NSSet<IndexPath>): void;
    }
    interface NSCollectionViewPrefetching extends NSObject {
        collectionViewPrefetchItemsAtIndexPaths(_: NSCollectionView, prefetchItemsAt: NSIndexPath[]): void;
        collectionViewCancelPrefetchingForItemsAtIndexPaths?(_: NSCollectionView, cancelPrefetchingForItemsAt: NSIndexPath[]): void;
    }
    interface NSCollectionViewSectionHeaderView extends NSCollectionViewElement {
        sectionCollapseButton?: NSButton;
        setSectionCollapseButton(_: NSButton): any;
    }
    class NSCollectionViewTransitionLayout extends NSCollectionViewLayout {
        currentLayout: NSCollectionViewLayout;
        nextLayout: NSCollectionViewLayout;
        transitionProgress: number;
        setTransitionProgress(_: number): any;
        static createWithCurrentLayoutNextLayout(currentLayout: NSCollectionViewLayout, nextLayout: NSCollectionViewLayout): NSCollectionViewTransitionLayout;
        updateValueForAnimatedKey(_: number, forAnimatedKey: string): void;
        valueForAnimatedKey(forAnimatedKey: string): number;
    }
    class NSCollectionViewUpdateItem extends NSObject {
        indexPathAfterUpdate: NSIndexPath;
        indexPathBeforeUpdate: NSIndexPath;
        updateAction: NSCollectionView.UpdateAction;
    }
    class NSColor extends NSObject {
        CGColor: any;
        alphaComponent: number;
        blackComponent: number;
        blueComponent: number;
        brightnessComponent: number;
        catalogNameComponent: string;
        colorNameComponent: string;
        colorSpace: NSColorSpace;
        cyanComponent: number;
        greenComponent: number;
        hueComponent: number;
        localizedCatalogNameComponent: string;
        localizedColorNameComponent: string;
        magentaComponent: number;
        numberOfComponents: number;
        patternImage: NSImage;
        redComponent: number;
        saturationComponent: number;
        type: NSColor.ColorType;
        whiteComponent: number;
        yellowComponent: number;
        static alternateSelectedControlTextColor: NSColor;
        static alternatingContentBackgroundColors: NSColor[];
        static blackColor: NSColor;
        static blueColor: NSColor;
        static brownColor: NSColor;
        static clearColor: NSColor;
        static controlAccentColor: NSColor;
        static controlBackgroundColor: NSColor;
        static controlColor: NSColor;
        static controlTextColor: NSColor;
        static currentControlTint: NSControlTint;
        static cyanColor: NSColor;
        static darkGrayColor: NSColor;
        static disabledControlTextColor: NSColor;
        static findHighlightColor: NSColor;
        static grayColor: NSColor;
        static greenColor: NSColor;
        static gridColor: NSColor;
        static headerTextColor: NSColor;
        static highlightColor: NSColor;
        static ignoresAlpha: boolean;
        setIgnoresAlpha(_: boolean): any;
        static keyboardFocusIndicatorColor: NSColor;
        static labelColor: NSColor;
        static lightGrayColor: NSColor;
        static linkColor: NSColor;
        static magentaColor: NSColor;
        static orangeColor: NSColor;
        static placeholderTextColor: NSColor;
        static purpleColor: NSColor;
        static quaternaryLabelColor: NSColor;
        static redColor: NSColor;
        static scrubberTexturedBackgroundColor: NSColor;
        static secondaryLabelColor: NSColor;
        static selectedContentBackgroundColor: NSColor;
        static selectedControlColor: NSColor;
        static selectedControlTextColor: NSColor;
        static selectedMenuItemTextColor: NSColor;
        static selectedTextBackgroundColor: NSColor;
        static selectedTextColor: NSColor;
        static separatorColor: NSColor;
        static shadowColor: NSColor;
        static systemBlueColor: NSColor;
        static systemBrownColor: NSColor;
        static systemGrayColor: NSColor;
        static systemGreenColor: NSColor;
        static systemIndigoColor: NSColor;
        static systemOrangeColor: NSColor;
        static systemPinkColor: NSColor;
        static systemPurpleColor: NSColor;
        static systemRedColor: NSColor;
        static systemTealColor: NSColor;
        static systemYellowColor: NSColor;
        static tertiaryLabelColor: NSColor;
        static textBackgroundColor: NSColor;
        static textColor: NSColor;
        static underPageBackgroundColor: NSColor;
        static unemphasizedSelectedContentBackgroundColor: NSColor;
        static unemphasizedSelectedTextBackgroundColor: NSColor;
        static unemphasizedSelectedTextColor: NSColor;
        static whiteColor: NSColor;
        static windowBackgroundColor: NSColor;
        static windowFrameTextColor: NSColor;
        static yellowColor: NSColor;
        blendedColorWithFractionOfColor(withFraction: number, of: NSColor): NSColor;
        colorUsingColorSpace(_: NSColorSpace): NSColor;
        colorUsingType(_: NSColor.ColorType): NSColor;
        colorWithAlphaComponent(_: number): NSColor;
        colorWithSystemEffect(_: NSColor.SystemEffect): NSColor;
        drawSwatchInRect(in_: CGRect): void;
        getComponents(_: number): void;
        getCyanMagentaYellowBlackAlpha(_?: number, magenta?: number, yellow?: number, black?: number, alpha?: number): void;
        getHueSaturationBrightnessAlpha(_?: number, saturation?: number, brightness?: number, alpha?: number): void;
        getRedGreenBlueAlpha(_?: number, green?: number, blue?: number, alpha?: number): void;
        getWhiteAlpha(_?: number, alpha?: number): void;
        highlightWithLevel(withLevel: number): NSColor;
        set(): void;
        setFill(): void;
        setStroke(): void;
        shadowWithLevel(withLevel: number): NSColor;
        writeToPasteboard(to: NSPasteboard): void;
    }
    interface NSColorChanging extends NSObject {
        changeColor(_?: NSColorPanel): void;
    }
    class NSColorList extends NSObject {
        allKeys: string[];
        isEditable: boolean;
        name: string;
        static availableColorLists: NSColorList[];
        colorWithKey(withKey: string): NSColor;
        static createWithName(name: string): NSColorList;
        static createWithNameFromFile(name: string, fromFile?: string): NSColorList;
        insertColorKeyAtIndex(_: NSColor, key: string, at: number): void;
        removeColorWithKey(withKey: string): void;
        removeFile(): void;
        setColorForKey(_: NSColor, forKey: string): void;
        writeToURLError(error?: NSURL): boolean;
    }
    class NSColorPanel extends NSPanel {
        static dragColorWithEventFromView(_: NSColor, with_: NSEvent, from: NSView): boolean;
        static setPickerMask(_: NSColorPanel.Options): void;
        static setPickerMode(_: NSColorPanel.Mode): void;
        accessoryView: NSView;
        setAccessoryView(_: NSView): any;
        alpha: number;
        color: NSColor;
        setColor(_: NSColor): any;
        isContinuous: boolean;
        setContinuous(_: boolean): any;
        mode: NSColorPanel.Mode;
        setMode(_: NSColorPanel.Mode): any;
        showsAlpha: boolean;
        setShowsAlpha(_: boolean): any;
        static sharedColorPanel: NSColorPanel;
        static sharedColorPanelExists: boolean;
        attachColorList(_: NSColorList): void;
        detachColorList(_: NSColorList): void;
        setAction(_?: string): void;
        setTarget(_?: any): void;
    }
    class NSColorPicker extends NSObject {
        buttonToolTip: string;
        colorPanel: NSColorPanel;
        minContentSize: CGSize;
        provideNewButtonImage: NSImage;
    }
    class NSColorPickerTouchBarItem extends NSTouchBarItem {
        static colorPickerWithIdentifier(withIdentifier: string): NSColorPickerTouchBarItem;
        static colorPickerWithIdentifierButtonImage(withIdentifier: string, buttonImage: NSImage): NSColorPickerTouchBarItem;
        static strokeColorPickerWithIdentifier(withIdentifier: string): NSColorPickerTouchBarItem;
        static textColorPickerWithIdentifier(withIdentifier: string): NSColorPickerTouchBarItem;
        action: string;
        setAction(_: string): any;
        allowedColorSpaces: NSColorSpace[];
        setAllowedColorSpaces(_: NSColorSpace[]): any;
        color: NSColor;
        setColor(_: NSColor): any;
        colorList: NSColorList;
        setColorList(_: NSColorList): any;
        isEnabled: boolean;
        setEnabled(_: boolean): any;
        showsAlpha: boolean;
        setShowsAlpha(_: boolean): any;
        target: any;
        setTarget(_: any): any;
    }
    interface NSColorPickingCustom extends NSColorPickingDefault {
        currentMode(): NSColorPanel.Mode;
        provideNewView(_: boolean): NSView;
        setColor(_: NSColor): void;
        supportsMode(_: NSColorPanel.Mode): boolean;
    }
    interface NSColorPickingDefault {
        provideNewButtonImage: NSImage;
        buttonToolTip: string;
        minContentSize: CGSize;
        alphaControlAddedOrRemoved(_?: any): void;
        attachColorList(_: NSColorList): void;
        detachColorList(_: NSColorList): void;
        insertNewButtonImageIn(_: NSImage, in_: NSButtonCell): void;
        setMode(_: NSColorPanel.Mode): void;
        viewSizeChanged(_?: any): void;
    }
    class NSColorSampler extends NSObject {
        showWithSelectionHandler(selectionHandler?: (p1: NSColor) => void): void;
    }
    class NSColorSpace extends NSObject {
        static availableColorSpacesWithModel(with_: NSColorSpace.Model): NSColorSpace[];
        CGColorSpace: any;
        ICCProfileData: NSData;
        colorSpaceModel: NSColorSpace.Model;
        colorSyncProfile: any;
        localizedName: string;
        numberOfColorComponents: number;
        static adobeRGB1998ColorSpace: NSColorSpace;
        static deviceCMYKColorSpace: NSColorSpace;
        static deviceGrayColorSpace: NSColorSpace;
        static deviceRGBColorSpace: NSColorSpace;
        static displayP3ColorSpace: NSColorSpace;
        static extendedGenericGamma22GrayColorSpace: NSColorSpace;
        static extendedSRGBColorSpace: NSColorSpace;
        static genericCMYKColorSpace: NSColorSpace;
        static genericGamma22GrayColorSpace: NSColorSpace;
        static genericGrayColorSpace: NSColorSpace;
        static genericRGBColorSpace: NSColorSpace;
        static sRGBColorSpace: NSColorSpace;
        static createWithCGColorSpace(CGColorSpace: any): NSColorSpace;
        static createWithColorSyncProfile(colorSyncProfile: any): NSColorSpace;
        static createWithICCProfileData(ICCProfileData: NSData): NSColorSpace;
    }
    class NSColorWell extends NSControl {
        isActive: boolean;
        isBordered: boolean;
        setBordered(_: boolean): any;
        color: NSColor;
        setColor(_: NSColor): any;
        activate(_: boolean): void;
        deactivate(): void;
        drawWellInside(inside: CGRect): void;
        takeColorFrom(_?: any): void;
    }
    class NSComboBox extends NSTextField {
        isButtonBordered: boolean;
        setButtonBordered(_: boolean): any;
        completes: boolean;
        setCompletes(_: boolean): any;
        dataSource: NSComboBoxDataSource;
        setDataSource(_: NSComboBoxDataSource): any;
        hasVerticalScroller: boolean;
        setHasVerticalScroller(_: boolean): any;
        indexOfSelectedItem: number;
        intercellSpacing: CGSize;
        setIntercellSpacing(_: CGSize): any;
        itemHeight: number;
        setItemHeight(_: number): any;
        numberOfItems: number;
        numberOfVisibleItems: number;
        setNumberOfVisibleItems(_: number): any;
        objectValueOfSelectedItem: any;
        objectValues: any[];
        usesDataSource: boolean;
        setUsesDataSource(_: boolean): any;
        addItemWithObjectValue(withObjectValue: any): void;
        addItemsWithObjectValues(withObjectValues: any[]): void;
        deselectItemAtIndex(at: number): void;
        indexOfItemWithObjectValue(withObjectValue: any): number;
        insertItemWithObjectValueAtIndex(withObjectValue: any, at: number): void;
        itemObjectValueAtIndex(at: number): any;
        noteNumberOfItemsChanged(): void;
        reloadData(): void;
        removeAllItems(): void;
        removeItemAtIndex(at: number): void;
        removeItemWithObjectValue(withObjectValue: any): void;
        scrollItemAtIndexToTop(_: number): void;
        scrollItemAtIndexToVisible(_: number): void;
        selectItemAtIndex(at: number): void;
        selectItemWithObjectValue(withObjectValue?: any): void;
    }
    class NSComboBoxCell extends NSTextFieldCell {
        isButtonBordered: boolean;
        setButtonBordered(_: boolean): any;
        completes: boolean;
        setCompletes(_: boolean): any;
        dataSource: NSComboBoxCellDataSource;
        setDataSource(_: NSComboBoxCellDataSource): any;
        hasVerticalScroller: boolean;
        setHasVerticalScroller(_: boolean): any;
        indexOfSelectedItem: number;
        intercellSpacing: CGSize;
        setIntercellSpacing(_: CGSize): any;
        itemHeight: number;
        setItemHeight(_: number): any;
        numberOfItems: number;
        numberOfVisibleItems: number;
        setNumberOfVisibleItems(_: number): any;
        objectValueOfSelectedItem: any;
        objectValues: any[];
        usesDataSource: boolean;
        setUsesDataSource(_: boolean): any;
        addItemWithObjectValue(withObjectValue: any): void;
        addItemsWithObjectValues(withObjectValues: any[]): void;
        completedString(_: string): string;
        deselectItemAtIndex(at: number): void;
        indexOfItemWithObjectValue(withObjectValue: any): number;
        insertItemWithObjectValueAtIndex(withObjectValue: any, at: number): void;
        itemObjectValueAtIndex(at: number): any;
        noteNumberOfItemsChanged(): void;
        reloadData(): void;
        removeAllItems(): void;
        removeItemAtIndex(at: number): void;
        removeItemWithObjectValue(withObjectValue: any): void;
        scrollItemAtIndexToTop(_: number): void;
        scrollItemAtIndexToVisible(_: number): void;
        selectItemAtIndex(at: number): void;
        selectItemWithObjectValue(withObjectValue?: any): void;
    }
    interface NSComboBoxCellDataSource extends NSObject {
        comboBoxCellObjectValueForItemAtIndex?(_: NSComboBoxCell, objectValueForItemAt: number): any;
        comboBoxCellCompletedString?(_: NSComboBoxCell, completedString: string): string;
        comboBoxCellIndexOfItemWithStringValue?(_: NSComboBoxCell, indexOfItemWithStringValue: string): number;
        numberOfItemsInComboBoxCell?(in_: NSComboBoxCell): number;
    }
    interface NSComboBoxDataSource extends NSObject {
        comboBoxObjectValueForItemAtIndex?(_: NSComboBox, objectValueForItemAt: number): any;
        comboBoxCompletedString?(_: NSComboBox, completedString: string): string;
        comboBoxIndexOfItemWithStringValue?(_: NSComboBox, indexOfItemWithStringValue: string): number;
        numberOfItemsInComboBox?(in_: NSComboBox): number;
    }
    interface NSComboBoxDelegate extends NSTextFieldDelegate {
        comboBoxSelectionDidChange?(_: NSNotification): void;
        comboBoxSelectionIsChanging?(_: NSNotification): void;
        comboBoxWillDismiss?(_: NSNotification): void;
        comboBoxWillPopUp?(_: NSNotification): void;
    }
    class NSControl extends NSView {
        action: string;
        setAction(_: string): any;
        alignment: NSTextAlignment;
        setAlignment(_: NSTextAlignment): any;
        allowsExpansionToolTips: boolean;
        setAllowsExpansionToolTips(_: boolean): any;
        attributedStringValue: NSAttributedString;
        setAttributedStringValue(_: NSAttributedString): any;
        baseWritingDirection: NSWritingDirection;
        setBaseWritingDirection(_: NSWritingDirection): any;
        cell: NSCell;
        setCell(_: NSCell): any;
        isContinuous: boolean;
        setContinuous(_: boolean): any;
        controlSize: NSControl.ControlSize;
        setControlSize(_: NSControl.ControlSize): any;
        doubleValue: number;
        setDoubleValue(_: number): any;
        isEnabled: boolean;
        setEnabled(_: boolean): any;
        floatValue: number;
        setFloatValue(_: number): any;
        font: NSFont;
        setFont(_: NSFont): any;
        formatter: Formatter;
        setFormatter(_: Formatter): any;
        isHighlighted: boolean;
        setHighlighted(_: boolean): any;
        ignoresMultiClick: boolean;
        setIgnoresMultiClick(_: boolean): any;
        intValue: number;
        setIntValue(_: number): any;
        integerValue: number;
        setIntegerValue(_: number): any;
        lineBreakMode: NSLineBreakMode;
        setLineBreakMode(_: NSLineBreakMode): any;
        objectValue: any;
        setObjectValue(_: any): any;
        refusesFirstResponder: boolean;
        setRefusesFirstResponder(_: boolean): any;
        stringValue: string;
        setStringValue(_: string): any;
        target: any;
        setTarget(_: any): any;
        usesSingleLineMode: boolean;
        setUsesSingleLineMode(_: boolean): any;
        static cellClass: typeof NSObject;
        setCellClass(_: typeof NSObject): any;
        abortEditing(): boolean;
        currentEditor(): NSText;
        drawCell(_: NSCell): void;
        drawCellInside(_: NSCell): void;
        drawWithExpansionFrameInView(withExpansionFrame: CGRect, in_: NSView): void;
        editWithFrameEditorDelegateEvent(withFrame: CGRect, editor: NSText, delegate?: any, event?: NSEvent): void;
        endEditing(_: NSText): void;
        expansionFrameWithFrame(withFrame: CGRect): CGRect;
        invalidateIntrinsicContentSizeForCell(for_: NSCell): void;
        performClick(_?: any): void;
        selectCell(_: NSCell): void;
        selectWithFrameEditorDelegateStartLength(withFrame: CGRect, editor: NSText, delegate?: any, start?: number, length?: number): void;
        selectedCell(): NSCell;
        selectedTag(): number;
        sendActionTo(_?: string, to?: any): boolean;
        sendActionOn(on: NSEvent.EventTypeMask): number;
        sizeThatFits(_: CGSize): CGSize;
        sizeToFit(): void;
        takeDoubleValueFrom(_?: any): void;
        takeFloatValueFrom(_?: any): void;
        takeIntValueFrom(_?: any): void;
        takeIntegerValueFrom(_?: any): void;
        takeObjectValueFrom(_?: any): void;
        takeStringValueFrom(_?: any): void;
        updateCell(_: NSCell): void;
        updateCellInside(_: NSCell): void;
        validateEditing(): void;
    }
    interface NSControlTextEditingDelegate extends NSObject {
        controlTextViewDoCommandBySelector?(_: NSControl, textView: NSTextView, doCommandBy: string): boolean;
        controlDidFailToFormatStringErrorDescription?(_: NSControl, didFailToFormatString: string, errorDescription?: string): boolean;
        controlDidFailToValidatePartialStringErrorDescription?(_: NSControl, didFailToValidatePartialString: string, errorDescription?: string): void;
        controlIsValidObject?(_: NSControl, isValidObject?: any): boolean;
        controlTextShouldBeginEditing?(_: NSControl, textShouldBeginEditing: NSText): boolean;
        controlTextShouldEndEditing?(_: NSControl, textShouldEndEditing: NSText): boolean;
        controlTextViewCompletionsForPartialWordRangeIndexOfSelectedItem?(_: NSControl, textView: NSTextView, completions: string[], forPartialWordRange: NSRange, indexOfSelectedItem: number): string[];
        controlTextDidBeginEditing?(_: NSNotification): void;
        controlTextDidChange?(_: NSNotification): void;
        controlTextDidEndEditing?(_: NSNotification): void;
    }
    class NSController extends NSObject {
        isEditing: boolean;
    }
    class NSCursor extends NSObject {
        static hide(): void;
        static pop(): void;
        static setHiddenUntilMouseMoves(_: boolean): void;
        static unhide(): void;
        hotSpot: CGPoint;
        image: NSImage;
        static IBeamCursor: NSCursor;
        static IBeamCursorForVerticalLayout: NSCursor;
        static arrowCursor: NSCursor;
        static closedHandCursor: NSCursor;
        static contextualMenuCursor: NSCursor;
        static crosshairCursor: NSCursor;
        static currentCursor: NSCursor;
        static currentSystemCursor: NSCursor;
        static disappearingItemCursor: NSCursor;
        static dragCopyCursor: NSCursor;
        static dragLinkCursor: NSCursor;
        static openHandCursor: NSCursor;
        static operationNotAllowedCursor: NSCursor;
        static pointingHandCursor: NSCursor;
        static resizeDownCursor: NSCursor;
        static resizeLeftCursor: NSCursor;
        static resizeLeftRightCursor: NSCursor;
        static resizeRightCursor: NSCursor;
        static resizeUpCursor: NSCursor;
        static resizeUpDownCursor: NSCursor;
        static createWithImageHotSpot(image: NSImage, hotSpot: CGPoint): NSCursor;
        pop(): void;
        push(): void;
        set(): void;
    }
    class NSCustomImageRep extends NSImageRep {
        delegate: any;
        drawSelector: string;
        drawingHandler: (p1: CGRect) => boolean;
        static createWithDrawSelectorDelegate(drawSelector: string, delegate: any): NSCustomImageRep;
        static createWithSizeFlippedDrawingHandler(size: CGSize, flipped: boolean, drawingHandler: (p1: CGRect) => boolean): NSCustomImageRep;
    }
    class NSCustomTouchBarItem extends NSTouchBarItem {
    }
    class NSDataAsset extends NSObject {
        data: NSData;
        name: string;
        typeIdentifier: string;
        static createWithName(name: string): NSDataAsset;
        static createWithNameBundle(name: string, bundle: Bundle): NSDataAsset;
    }
    class NSDatePicker extends NSControl {
        backgroundColor: NSColor;
        setBackgroundColor(_: NSColor): any;
        isBezeled: boolean;
        setBezeled(_: boolean): any;
        isBordered: boolean;
        setBordered(_: boolean): any;
        calendar: NSCalendar;
        setCalendar(_: NSCalendar): any;
        datePickerElements: NSDatePicker.ElementFlags;
        setDatePickerElements(_: NSDatePicker.ElementFlags): any;
        datePickerMode: NSDatePicker.Mode;
        setDatePickerMode(_: NSDatePicker.Mode): any;
        datePickerStyle: NSDatePicker.Style;
        setDatePickerStyle(_: NSDatePicker.Style): any;
        dateValue: Date;
        setDateValue(_: Date): any;
        delegate: NSDatePickerCellDelegate;
        setDelegate(_: NSDatePickerCellDelegate): any;
        drawsBackground: boolean;
        setDrawsBackground(_: boolean): any;
        locale: NSLocale;
        setLocale(_: NSLocale): any;
        maxDate: Date;
        setMaxDate(_: Date): any;
        minDate: Date;
        setMinDate(_: Date): any;
        presentsCalendarOverlay: boolean;
        setPresentsCalendarOverlay(_: boolean): any;
        textColor: NSColor;
        setTextColor(_: NSColor): any;
        timeInterval: number;
        setTimeInterval(_: number): any;
        timeZone: NSTimeZone;
        setTimeZone(_: NSTimeZone): any;
    }
    class NSDatePickerCell extends NSActionCell {
        backgroundColor: NSColor;
        setBackgroundColor(_: NSColor): any;
        calendar: NSCalendar;
        setCalendar(_: NSCalendar): any;
        datePickerElements: NSDatePicker.ElementFlags;
        setDatePickerElements(_: NSDatePicker.ElementFlags): any;
        datePickerMode: NSDatePicker.Mode;
        setDatePickerMode(_: NSDatePicker.Mode): any;
        datePickerStyle: NSDatePicker.Style;
        setDatePickerStyle(_: NSDatePicker.Style): any;
        dateValue: Date;
        setDateValue(_: Date): any;
        delegate: NSDatePickerCellDelegate;
        setDelegate(_: NSDatePickerCellDelegate): any;
        drawsBackground: boolean;
        setDrawsBackground(_: boolean): any;
        locale: NSLocale;
        setLocale(_: NSLocale): any;
        maxDate: Date;
        setMaxDate(_: Date): any;
        minDate: Date;
        setMinDate(_: Date): any;
        textColor: NSColor;
        setTextColor(_: NSColor): any;
        timeInterval: number;
        setTimeInterval(_: number): any;
        timeZone: NSTimeZone;
        setTimeZone(_: NSTimeZone): any;
    }
    interface NSDatePickerCellDelegate extends NSObject {
        datePickerCellValidateProposedDateValueTimeInterval?(_: NSDatePickerCell, validateProposedDateValue: Date, timeInterval?: number): void;
    }
    class NSDictionaryController extends NSArrayController {
        excludedKeys: string[];
        setExcludedKeys(_: string[]): any;
        includedKeys: string[];
        setIncludedKeys(_: string[]): any;
        initialKey: string;
        setInitialKey(_: string): any;
        initialValue: any;
        setInitialValue(_: any): any;
        localizedKeyDictionary: Map<string, string>;
        setLocalizedKeyDictionary(_: Map<string, string>): any;
        localizedKeyTable: string;
        setLocalizedKeyTable(_: string): any;
    }
    class NSDictionaryControllerKeyValuePair extends NSObject {
        isExplicitlyIncluded: boolean;
        key: string;
        setKey(_: string): any;
        localizedKey: string;
        setLocalizedKey(_: string): any;
        value: any;
        setValue(_: any): any;
    }
    class NSDiffableDataSourceSnapshotReference<SectionIdentifierType, ItemIdentifierType> extends NSObject {
        itemIdentifiers: ItemIdentifierType[];
        numberOfItems: number;
        numberOfSections: number;
        sectionIdentifiers: SectionIdentifierType[];
        appendItemsWithIdentifiers(_: ItemIdentifierType[]): void;
        appendItemsWithIdentifiersIntoSectionWithIdentifier(_: ItemIdentifierType[], intoSectionWithIdentifier: SectionIdentifierType): void;
        appendSectionsWithIdentifiers(_: any[]): void;
        deleteAllItems(): void;
        deleteItemsWithIdentifiers(_: ItemIdentifierType[]): void;
        deleteSectionsWithIdentifiers(_: SectionIdentifierType[]): void;
        indexOfItemIdentifier(_: ItemIdentifierType): number;
        indexOfSectionIdentifier(_: SectionIdentifierType): number;
        insertItemsWithIdentifiersAfterItemWithIdentifier(_: ItemIdentifierType[], afterItemWithIdentifier: ItemIdentifierType): void;
        insertItemsWithIdentifiersBeforeItemWithIdentifier(_: ItemIdentifierType[], beforeItemWithIdentifier: ItemIdentifierType): void;
        insertSectionsWithIdentifiersAfterSectionWithIdentifier(_: SectionIdentifierType[], afterSectionWithIdentifier: SectionIdentifierType): void;
        insertSectionsWithIdentifiersBeforeSectionWithIdentifier(_: SectionIdentifierType[], beforeSectionWithIdentifier: SectionIdentifierType): void;
        itemIdentifiersInSectionWithIdentifier(_: SectionIdentifierType): ItemIdentifierType[];
        moveItemWithIdentifierAfterItemWithIdentifier(_: ItemIdentifierType, afterItemWithIdentifier: ItemIdentifierType): void;
        moveItemWithIdentifierBeforeItemWithIdentifier(_: ItemIdentifierType, beforeItemWithIdentifier: ItemIdentifierType): void;
        moveSectionWithIdentifierAfterSectionWithIdentifier(_: SectionIdentifierType, afterSectionWithIdentifier: SectionIdentifierType): void;
        moveSectionWithIdentifierBeforeSectionWithIdentifier(_: SectionIdentifierType, beforeSectionWithIdentifier: SectionIdentifierType): void;
        numberOfItemsInSection(_: SectionIdentifierType): number;
        reloadItemsWithIdentifiers(_: ItemIdentifierType[]): void;
        reloadSectionsWithIdentifiers(_: SectionIdentifierType[]): void;
        sectionIdentifierForSectionContainingItemIdentifier(_: ItemIdentifierType): SectionIdentifierType;
    }
    class NSDockTile extends NSObject {
        badgeLabel: string;
        setBadgeLabel(_: string): any;
        contentView: NSView;
        setContentView(_: NSView): any;
        owner: any;
        showsApplicationBadge: boolean;
        setShowsApplicationBadge(_: boolean): any;
        size: CGSize;
        display(): void;
    }
    interface NSDockTilePlugIn extends NSObject {
        dockMenu?(): NSMenu;
        setDockTile(_?: NSDockTile): void;
    }
    class NSDocument extends NSObject {
        static canConcurrentlyReadDocumentsOfType(ofType: string): boolean;
        static isNativeType(_: string): boolean;
        PDFPrintOperation: NSPrintOperation;
        allowsDocumentSharing: boolean;
        autosavedContentsFileURL: NSURL;
        setAutosavedContentsFileURL(_: NSURL): any;
        autosavingFileType: string;
        autosavingIsImplicitlyCancellable: boolean;
        backupFileURL: NSURL;
        isBrowsingVersions: boolean;
        displayName: string;
        setDisplayName(_: string): any;
        isDocumentEdited: boolean;
        isDraft: boolean;
        setDraft(_: boolean): any;
        isEntireFileLoaded: boolean;
        fileModificationDate: Date;
        setFileModificationDate(_: Date): any;
        fileNameExtensionWasHiddenInLastRunSavePanel: boolean;
        fileType: string;
        setFileType(_: string): any;
        fileTypeFromLastRunSavePanel: string;
        fileURL: NSURL;
        setFileURL(_: NSURL): any;
        hasUnautosavedChanges: boolean;
        hasUndoManager: boolean;
        setHasUndoManager(_: boolean): any;
        isInViewingMode: boolean;
        keepBackupFile: boolean;
        lastComponentOfFileName: string;
        setLastComponentOfFileName(_: string): any;
        isLocked: boolean;
        printInfo: NSPrintInfo;
        setPrintInfo(_: NSPrintInfo): any;
        shouldRunSavePanelWithAccessoryView: boolean;
        undoManager: UndoManager;
        setUndoManager(_: UndoManager): any;
        userActivity: NSUserActivity;
        setUserActivity(_: NSUserActivity): any;
        windowControllers: NSWindowController[];
        windowForSheet: NSWindow;
        windowNibName: string;
        static autosavesDrafts: boolean;
        static autosavesInPlace: boolean;
        static preservesVersions: boolean;
        static readableTypes: string[];
        static restorableStateKeyPaths: string[];
        static usesUbiquitousStorage: boolean;
        static writableTypes: string[];
        addWindowController(_: NSWindowController): void;
        autosaveDocumentWithDelegateDidAutosaveSelectorContextInfo(withDelegate?: any, didAutosave?: string, contextInfo?: any): void;
        autosaveWithWithImplicitCancellabilityCompletionHandler(withImplicitCancellability: boolean, completionHandler?: (p1: NSError) => void): void;
        browseDocumentVersions(_?: any): void;
        canAsynchronouslyWriteToURLOfTypeForSaveOperation(to: NSURL, ofType: string, for_: NSDocument.SaveOperationType): boolean;
        canCloseDocumentWithDelegateShouldCloseSelectorContextInfo(withDelegate: any, shouldClose?: string, contextInfo?: any): void;
        changeCountTokenForSaveOperation(for_: NSDocument.SaveOperationType): any;
        checkAutosavingSafetyAndReturnError(): boolean;
        close(): void;
        continueActivity(_: () => void): void;
        continueAsynchronousWorkOnMainThread(_: () => void): void;
        dataOfTypeError(error: string): NSData;
        defaultDraftName(): string;
        duplicateAndReturnError(): NSDocument;
        duplicateDocument(_?: any): void;
        duplicateDocumentWithDelegateDidDuplicateSelectorContextInfo(withDelegate?: any, didDuplicate?: string, contextInfo?: any): void;
        encodeRestorableStateWithCoder(with_: NSCoder): void;
        encodeRestorableStateWithCoderBackgroundQueue(with_: NSCoder, backgroundQueue: OperationQueue): void;
        fileAttributesToWriteToURLOfTypeForSaveOperationOriginalContentsURLError(ofType: NSURL, forSaveOperation: string, originalContentsURL: NSDocument.SaveOperationType, error?: NSURL): Map<string, any>;
        fileNameExtensionForTypeSaveOperation(forType: string, saveOperation: NSDocument.SaveOperationType): string;
        fileWrapperOfTypeError(error: string): FileWrapper;
        handleCloseScriptCommand(_: NSCloseCommand): any;
        handlePrintScriptCommand(_: NSScriptCommand): any;
        handleSaveScriptCommand(_: NSScriptCommand): any;
        static createWithForURLWithContentsOfURLOfType(forURL?: NSURL, withContentsOfURL?: NSURL, ofType?: string): NSDocument;
        static createWithContentsOfURLOfType(contentsOfURL: NSURL, ofType: string): NSDocument;
        static createWithType(type: string): NSDocument;
        invalidateRestorableState(): void;
        lockDocument(_?: any): void;
        lockWithCompletionHandler(completionHandler?: (p1: boolean) => void): void;
        lockWithCompletionHandler(completionHandler?: (p1: NSError) => void): void;
        makeWindowControllers(): void;
        moveDocument(_?: any): void;
        moveDocumentToUbiquityContainer(_?: any): void;
        moveWithCompletionHandler(completionHandler?: (p1: boolean) => void): void;
        moveWithToCompletionHandler(to: NSURL, completionHandler?: (p1: NSError) => void): void;
        performActivityWithWithSynchronousWaitingUsing(withSynchronousWaiting: boolean, using: (p1: () => void) => void): void;
        performAsynchronousFileAccess(_: (p1: () => void) => void): void;
        performSynchronousFileAccess(_: () => void): void;
        preparePageLayout(_: NSPageLayout): boolean;
        prepareSavePanel(_: NSSavePanel): boolean;
        prepareSharingServicePicker(_: NSSharingServicePicker): void;
        presentError(_: NSError): boolean;
        presentErrorModalForWindowDelegateDidPresentSelectorContextInfo(_: NSError, modalFor: NSWindow, delegate?: any, didPresent?: string, contextInfo?: any): void;
        printDocument(_?: any): void;
        printDocumentWithSettingsShowPrintPanelDelegateDidPrintSelectorContextInfo(withSettings: Map<string, any>, showPrintPanel: boolean, delegate?: any, didPrint?: string, contextInfo?: any): void;
        printOperationWithSettingsError(error: Map<string, any>): NSPrintOperation;
        readFromDataOfTypeError(ofType: NSData, error: string): boolean;
        readFromFileWrapperOfTypeError(ofType: FileWrapper, error: string): boolean;
        readFromURLOfTypeError(ofType: NSURL, error: string): boolean;
        removeWindowController(_: NSWindowController): void;
        renameDocument(_?: any): void;
        restoreWindowWithWithIdentifierStateCompletionHandler(withIdentifier: string, state: NSCoder, completionHandler?: (p1: NSWindow, p2: NSError) => void): void;
        restoreStateWithCoder(with_: NSCoder): void;
        revertDocumentToSaved(_?: any): void;
        revertToContentsOfURLOfTypeError(ofType: NSURL, error: string): boolean;
        runModalPageLayoutWithPrintInfoDelegateDidRunSelectorContextInfo(with_: NSPrintInfo, delegate?: any, didRun?: string, contextInfo?: any): void;
        runModalPrintOperationDelegateDidRunSelectorContextInfo(_: NSPrintOperation, delegate?: any, didRun?: string, contextInfo?: any): void;
        runModalSavePanelForSaveOperationDelegateDidSaveSelectorContextInfo(for_: NSDocument.SaveOperationType, delegate?: any, didSave?: string, contextInfo?: any): void;
        runPageLayout(_?: any): void;
        saveDocument(_?: any): void;
        saveDocumentAs(_?: any): void;
        saveDocumentTo(_?: any): void;
        saveDocumentToPDF(_?: any): void;
        saveDocumentWithDelegateDidSaveSelectorContextInfo(withDelegate?: any, didSave?: string, contextInfo?: any): void;
        saveWithToOfTypeForCompletionHandler(to: NSURL, ofType: string, for_: NSDocument.SaveOperationType, completionHandler?: (p1: NSError) => void): void;
        saveToURLOfTypeForSaveOperationDelegateDidSaveSelectorContextInfo(to: NSURL, ofType: string, for_: NSDocument.SaveOperationType, delegate?: any, didSave?: string, contextInfo?: any): void;
        scheduleAutosaving(): void;
        setDisplayName(_?: string): void;
        setWindow(_?: NSWindow): void;
        shareWithWithCompletionHandler(with_: NSSharingService, completionHandler?: (p1: boolean) => void): void;
        shouldChangePrintInfo(_: NSPrintInfo): boolean;
        shouldCloseWindowControllerDelegateShouldCloseSelectorContextInfo(_: NSWindowController, delegate?: any, shouldClose?: string, contextInfo?: any): void;
        showWindows(): void;
        stopBrowsingVersionsWithCompletionHandler(completionHandler?: () => void): void;
        unblockUserInteraction(): void;
        unlockDocument(_?: any): void;
        unlockWithCompletionHandler(completionHandler?: (p1: boolean) => void): void;
        unlockWithCompletionHandler(completionHandler?: (p1: NSError) => void): void;
        updateChangeCount(_: NSDocument.ChangeType): void;
        updateChangeCountWithTokenForSaveOperation(withToken: any, for_: NSDocument.SaveOperationType): void;
        updateUserActivityState(_: NSUserActivity): void;
        willNotPresentError(_: NSError): void;
        willPresentError(_: NSError): NSError;
        windowControllerDidLoadNib(_: NSWindowController): void;
        windowControllerWillLoadNib(_: NSWindowController): void;
        writableTypesForSaveOperation(for_: NSDocument.SaveOperationType): string[];
        writeSafelyToURLOfTypeForSaveOperationError(ofType: NSURL, forSaveOperation: string, error: NSDocument.SaveOperationType): boolean;
        writeToURLOfTypeError(ofType: NSURL, error: string): boolean;
        writeToURLOfTypeForSaveOperationOriginalContentsURLError(ofType: NSURL, forSaveOperation: string, originalContentsURL: NSDocument.SaveOperationType, error?: NSURL): boolean;
    }
    class NSDocumentController extends NSObject {
        allowsAutomaticShareMenu: boolean;
        autosavingDelay: number;
        setAutosavingDelay(_: number): any;
        currentDirectory: string;
        currentDocument: NSDocument;
        defaultType: string;
        documentClassNames: string[];
        documents: NSDocument[];
        hasEditedDocuments: boolean;
        maximumRecentDocumentCount: number;
        recentDocumentURLs: NSURL[];
        static sharedDocumentController: NSDocumentController;
        URLsFromRunningOpenPanel(): NSURL[];
        addDocument(_: NSDocument): void;
        beginOpenPanelForTypesCompletionHandler(_: NSOpenPanel, forTypes?: string[], completionHandler?: (p1: number) => void): void;
        beginOpenPanelWithCompletionHandler(completionHandler?: (p1: NSURL[]) => void): void;
        clearRecentDocuments(_?: any): void;
        closeAllDocumentsWithDelegateDidCloseAllSelectorContextInfo(withDelegate?: any, didCloseAllSelector?: string, contextInfo?: any): void;
        displayNameForType(forType: string): string;
        documentClassForType(forType: string): typeof NSObject;
        documentForURL(for_: NSURL): NSDocument;
        documentForWindow(for_: NSWindow): NSDocument;
        duplicateDocumentWithContentsOfURLCopyingDisplayNameError(copying: NSURL, displayName: boolean, error?: string): NSDocument;
        makeDocumentForURLWithContentsOfURLOfTypeError(withContentsOfURL?: NSURL, ofType?: NSURL, error?: string): NSDocument;
        makeDocumentWithContentsOfURLOfTypeError(ofType: NSURL, error: string): NSDocument;
        makeUntitledDocumentOfTypeError(error: string): NSDocument;
        newDocument(_?: any): void;
        noteNewRecentDocument(_: NSDocument): void;
        noteNewRecentDocumentURL(_: NSURL): void;
        openDocument(_?: any): void;
        openDocumentWithWithContentsOfDisplayCompletionHandler(withContentsOf: NSURL, display: boolean, completionHandler?: (p1: NSDocument, p2: boolean, p3: NSError) => void): void;
        openUntitledDocumentAndDisplayError(error: boolean): NSDocument;
        presentError(_: NSError): boolean;
        presentErrorModalForWindowDelegateDidPresentSelectorContextInfo(_: NSError, modalFor: NSWindow, delegate?: any, didPresent?: string, contextInfo?: any): void;
        removeDocument(_: NSDocument): void;
        reopenDocumentForWithContentsOfDisplayCompletionHandler(for_?: NSURL, withContentsOf?: NSURL, display?: boolean, completionHandler?: (p1: NSDocument, p2: boolean, p3: NSError) => void): void;
        reviewUnsavedDocumentsWithAlertTitleCancellableDelegateDidReviewAllSelectorContextInfo(withAlertTitle?: string, cancellable?: boolean, delegate?: any, didReviewAllSelector?: string, contextInfo?: any): void;
        runModalOpenPanelForTypes(_: NSOpenPanel, forTypes?: string[]): number;
        saveAllDocuments(_?: any): void;
        standardShareMenuItem(): NSMenuItem;
        typeForContentsOfURLError(error: NSURL): string;
        willPresentError(_: NSError): NSError;
    }
    interface NSDraggingDestination extends NSObject {
        concludeDragOperation?(_?: NSDraggingInfo): void;
        draggingEnded?(_: NSDraggingInfo): void;
        draggingEntered?(_: NSDraggingInfo): NSDragOperation;
        draggingExited?(_?: NSDraggingInfo): void;
        draggingUpdated?(_: NSDraggingInfo): NSDragOperation;
        performDragOperation?(_: NSDraggingInfo): boolean;
        prepareForDragOperation?(_: NSDraggingInfo): boolean;
        updateDraggingItemsForDrag?(_?: NSDraggingInfo): void;
        wantsPeriodicDraggingUpdates?(): boolean;
    }
    class NSDraggingImageComponent extends NSObject {
        static draggingImageComponentWithKey(key: string): NSDraggingImageComponent;
        contents: any;
        setContents(_: any): any;
        frame: CGRect;
        setFrame(_: CGRect): any;
        key: string;
        setKey(_: string): any;
        static createWithKey(key: string): NSDraggingImageComponent;
    }
    interface NSDraggingInfo extends NSObject {
        animatesToDestination: boolean;
        setAnimatesToDestination(_: boolean): any;
        draggedImage: NSImage;
        draggedImageLocation: CGPoint;
        draggingDestinationWindow: NSWindow;
        draggingFormation: NSDraggingFormation;
        setDraggingFormation(_: NSDraggingFormation): any;
        draggingLocation: CGPoint;
        draggingPasteboard: NSPasteboard;
        draggingSequenceNumber: number;
        draggingSource: any;
        draggingSourceOperationMask: NSDragOperation;
        numberOfValidItemsForDrop: number;
        setNumberOfValidItemsForDrop(_: number): any;
        springLoadingHighlight: NSSpringLoadingHighlight;
        enumerateDraggingItemsWithOptionsForClassesSearchOptionsUsing(options: NSDraggingItemEnumerationOptions, for_?: NSView, classes?: typeof NSObject[], searchOptions?: Map<string, any>, using?: (p1: NSDraggingItem, p2: number, p3: boolean) => void): void;
        resetSpringLoading(): void;
        slideDraggedImageTo(to: CGPoint): void;
    }
    class NSDraggingItem extends NSObject {
        draggingFrame: CGRect;
        setDraggingFrame(_: CGRect): any;
        imageComponents: NSDraggingImageComponent[];
        imageComponentsProvider: () => NSDraggingImageComponent[];
        setImageComponentsProvider(_: () => NSDraggingImageComponent[]): any;
        item: any;
        static createWithPasteboardWriter(pasteboardWriter: NSPasteboardWriting): NSDraggingItem;
        setDraggingFrameContents(_: CGRect, contents?: any): void;
    }
    class NSDraggingSession extends NSObject {
        animatesToStartingPositionsOnCancelOrFail: boolean;
        setAnimatesToStartingPositionsOnCancelOrFail(_: boolean): any;
        draggingFormation: NSDraggingFormation;
        setDraggingFormation(_: NSDraggingFormation): any;
        draggingLeaderIndex: number;
        setDraggingLeaderIndex(_: number): any;
        draggingLocation: CGPoint;
        draggingPasteboard: NSPasteboard;
        draggingSequenceNumber: number;
        enumerateDraggingItemsWithOptionsForClassesSearchOptionsUsing(options: NSDraggingItemEnumerationOptions, for_?: NSView, classes?: typeof NSObject[], searchOptions?: Map<string, any>, using?: (p1: NSDraggingItem, p2: number, p3: boolean) => void): void;
    }
    interface NSDraggingSource extends NSObject {
        draggingSessionSourceOperationMaskForDraggingContext(_: NSDraggingSession, sourceOperationMaskFor: NSDraggingContext): NSDragOperation;
        draggingSessionWillBeginAtPoint?(_: NSDraggingSession, willBeginAt: CGPoint): void;
        draggingSessionMovedToPoint?(_: NSDraggingSession, movedTo: CGPoint): void;
        draggingSessionEndedAtPointOperation?(_: NSDraggingSession, endedAt: CGPoint, operation: NSDragOperation): void;
        ignoreModifierKeysForDraggingSession?(for_: NSDraggingSession): boolean;
    }
    type NSDrawerDelegate = NSObject;
    class NSEPSImageRep extends NSImageRep {
        EPSRepresentation: NSData;
        boundingBox: CGRect;
        static createWithData(data: NSData): NSEPSImageRep;
    }
    interface NSEditor extends NSObject {
        commitEditing(): boolean;
        commitEditingWithDelegateDidCommitSelectorContextInfo(withDelegate?: any, didCommit?: string, contextInfo?: any): void;
        commitEditingAndReturnError(): boolean;
        discardEditing(): void;
    }
    interface NSEditorRegistration extends NSObject {
        objectDidBeginEditing?(_: NSEditor): void;
        objectDidEndEditing?(_: NSEditor): void;
    }
    class NSEvent extends NSObject {
        static addGlobalMonitorForEventsWithMatchingHandler(matching: NSEvent.EventTypeMask, handler: (p1: NSEvent) => void): any;
        static addLocalMonitorForEventsWithMatchingHandler(matching: NSEvent.EventTypeMask, handler?: (p1: NSEvent) => NSEvent): any;
        static enterExitEventWithTypeLocationModifierFlagsTimestampWindowNumberContextEventNumberTrackingNumberUserData(with_: NSEvent.EventType, location: CGPoint, modifierFlags: NSEvent.ModifierFlags, timestamp: number, windowNumber: number, context?: NSGraphicsContext, eventNumber?: number, trackingNumber?: number, userData?: any): NSEvent;
        static keyEventWithTypeLocationModifierFlagsTimestampWindowNumberContextCharactersCharactersIgnoringModifiersIsARepeatKeyCode(with_: NSEvent.EventType, location: CGPoint, modifierFlags: NSEvent.ModifierFlags, timestamp: number, windowNumber: number, context?: NSGraphicsContext, characters?: string, charactersIgnoringModifiers?: string, isARepeat?: boolean, keyCode?: number): NSEvent;
        static mouseEventWithTypeLocationModifierFlagsTimestampWindowNumberContextEventNumberClickCountPressure(with_: NSEvent.EventType, location: CGPoint, modifierFlags: NSEvent.ModifierFlags, timestamp: number, windowNumber: number, context?: NSGraphicsContext, eventNumber?: number, clickCount?: number, pressure?: number): NSEvent;
        static otherEventWithTypeLocationModifierFlagsTimestampWindowNumberContextSubtypeData1Data2(with_: NSEvent.EventType, location: CGPoint, modifierFlags: NSEvent.ModifierFlags, timestamp: number, windowNumber: number, context?: NSGraphicsContext, subtype?: number, data1?: number, data2?: number): NSEvent;
        static removeMonitor(_: any): void;
        static startPeriodicEventsAfterDelayWithPeriod(afterDelay: number, withPeriod: number): void;
        static stopPeriodicEvents(): void;
        isARepeat: boolean;
        CGEvent: any;
        absoluteX: number;
        absoluteY: number;
        absoluteZ: number;
        associatedEventsMask: NSEvent.EventTypeMask;
        buttonMask: NSEvent.ButtonMask;
        buttonNumber: number;
        capabilityMask: number;
        characters: string;
        charactersIgnoringModifiers: string;
        clickCount: number;
        data1: number;
        data2: number;
        deltaX: number;
        deltaY: number;
        deltaZ: number;
        deviceID: number;
        isDirectionInvertedFromDevice: boolean;
        isEnteringProximity: boolean;
        eventNumber: number;
        eventRef: any;
        hasPreciseScrollingDeltas: boolean;
        keyCode: number;
        locationInWindow: CGPoint;
        magnification: number;
        momentumPhase: NSEvent.Phase;
        phase: NSEvent.Phase;
        pointingDeviceID: number;
        pointingDeviceSerialNumber: number;
        pointingDeviceType: NSEvent.PointingDeviceType;
        pressure: number;
        pressureBehavior: NSEvent.PressureBehavior;
        rotation: number;
        scrollingDeltaX: number;
        scrollingDeltaY: number;
        stage: number;
        stageTransition: number;
        subtype: NSEvent.EventSubtype;
        systemTabletID: number;
        tabletID: number;
        tangentialPressure: number;
        tilt: CGPoint;
        timestamp: number;
        trackingArea: NSTrackingArea;
        trackingNumber: number;
        type: NSEvent.EventType;
        uniqueID: number;
        userData: any;
        vendorDefined: any;
        vendorID: number;
        vendorPointingDeviceType: number;
        window: NSWindow;
        windowNumber: number;
        static doubleClickInterval: number;
        static keyRepeatDelay: number;
        static keyRepeatInterval: number;
        static modifierFlags: NSEvent.ModifierFlags;
        static isMouseCoalescingEnabled: boolean;
        setMouseCoalescingEnabled(_: boolean): any;
        static mouseLocation: CGPoint;
        static pressedMouseButtons: number;
        static isSwipeTrackingFromScrollEventsEnabled: boolean;
        allTouches(): NSSet<NSTouch>;
        charactersByApplyingModifiers(byApplyingModifiers: NSEvent.ModifierFlags): string;
        coalescedTouchesForTouch(for_: NSTouch): NSTouch[];
        touchesForView(for_: NSView): NSSet<NSTouch>;
        touchesMatchingPhaseInView(matching: NSTouch.Phase, in_?: NSView): NSSet<NSTouch>;
        trackSwipeEventWithOptionsDampenAmountThresholdMinMaxUsingHandler(options: NSEvent.SwipeTrackingOptions, dampenAmountThresholdMin: number, max: number, usingHandler: (p1: number, p2: NSEvent.Phase, p3: boolean, p4: boolean) => void): void;
    }
    class NSFilePromiseProvider extends NSObject {
        delegate: NSFilePromiseProviderDelegate;
        setDelegate(_: NSFilePromiseProviderDelegate): any;
        fileType: string;
        setFileType(_: string): any;
        userInfo: any;
        setUserInfo(_: any): any;
        static createWithFileTypeDelegate(fileType: string, delegate: NSFilePromiseProviderDelegate): NSFilePromiseProvider;
    }
    interface NSFilePromiseProviderDelegate extends NSObject {
        filePromiseProviderWritePromiseToCompletionHandler(_: NSFilePromiseProvider, writePromiseTo: NSURL, completionHandler?: (p1: NSError) => void): void;
        filePromiseProviderFileNameForType(_: NSFilePromiseProvider, fileNameForType: string): string;
        operationQueueForFilePromiseProvider?(for_: NSFilePromiseProvider): OperationQueue;
    }
    class NSFilePromiseReceiver extends NSObject {
        fileNames: string[];
        fileTypes: string[];
        static readableDraggedTypes: string[];
        receivePromisedFilesWithAtDestinationOptionsOperationQueueReader(atDestination: NSURL, options: Map<any, any>, operationQueue: OperationQueue, reader?: (p1: NSURL, p2: NSError) => void): void;
    }
    class NSFont extends NSObject {
        static boldSystemFontOfSize(ofSize: number): NSFont;
        static controlContentFontOfSize(ofSize: number): NSFont;
        static labelFontOfSize(ofSize: number): NSFont;
        static menuBarFontOfSize(ofSize: number): NSFont;
        static menuFontOfSize(ofSize: number): NSFont;
        static messageFontOfSize(ofSize: number): NSFont;
        static monospacedDigitSystemFontOfSizeWeight(ofSize: number, weight: number): NSFont;
        static monospacedSystemFontOfSizeWeight(ofSize: number, weight: number): NSFont;
        static paletteFontOfSize(ofSize: number): NSFont;
        static setUserFixedPitchFont(_?: NSFont): void;
        static setUserFont(_?: NSFont): void;
        static systemFontOfSize(ofSize: number): NSFont;
        static systemFontOfSizeWeight(ofSize: number, weight: number): NSFont;
        static systemFontSizeForControlSize(for_: NSControl.ControlSize): number;
        static titleBarFontOfSize(ofSize: number): NSFont;
        static toolTipsFontOfSize(ofSize: number): NSFont;
        static userFixedPitchFontOfSize(ofSize: number): NSFont;
        static userFontOfSize(ofSize: number): NSFont;
        ascender: number;
        boundingRectForFont: CGRect;
        capHeight: number;
        coveredCharacterSet: NSCharacterSet;
        descender: number;
        displayName: string;
        familyName: string;
        isFixedPitch: boolean;
        fontDescriptor: NSFontDescriptor;
        fontName: string;
        italicAngle: number;
        leading: number;
        matrix: number;
        maximumAdvancement: CGSize;
        mostCompatibleStringEncoding: number;
        numberOfGlyphs: number;
        pointSize: number;
        printerFont: NSFont;
        renderingMode: NSFontRenderingMode;
        screenFont: NSFont;
        textTransform: NSAffineTransform;
        underlinePosition: number;
        underlineThickness: number;
        isVertical: boolean;
        verticalFont: NSFont;
        xHeight: number;
        static labelFontSize: number;
        static smallSystemFontSize: number;
        static systemFontSize: number;
        advancementForCGGlyph(forCGGlyph: number): CGSize;
        advancementForGlyph(forGlyph: number): CGSize;
        boundingRectForCGGlyph(forCGGlyph: number): CGRect;
        boundingRectForGlyph(forGlyph: number): CGRect;
        getAdvancementsForCGGlyphsCount(_: NSSize, forCGGlyphs: number, count: number): void;
        getAdvancementsForGlyphsCount(_: NSSize, forGlyphs: number, count: number): void;
        getAdvancementsForPackedGlyphsLength(_: NSSize, forPackedGlyphs: any, length: number): void;
        getBoundingRectsForCGGlyphsCount(_: NSRect, forCGGlyphs: number, count: number): void;
        getBoundingRectsForGlyphsCount(_: NSRect, forGlyphs: number, count: number): void;
        glyphWithName(withName: string): number;
        screenFontWithRenderingMode(with_: NSFontRenderingMode): NSFont;
        set(): void;
        setInContext(in_: NSGraphicsContext): void;
    }
    class NSFontAssetRequest extends NSObject {
        downloadedFontDescriptors: NSFontDescriptor[];
        downloadWithWithCompletionHandler(withCompletionHandler?: (p1: NSError) => boolean): void;
        static createWithFontDescriptorsOptions(fontDescriptors: NSFontDescriptor[], options: NSFontAssetRequest.Options): NSFontAssetRequest;
    }
    interface NSFontChanging extends NSObject {
        changeFont?(_?: NSFontManager): void;
        validModesForFontPanel?(_: NSFontPanel): NSFontPanel.ModeMask;
    }
    class NSFontCollection extends NSObject {
        static hideFontCollectionWithNameVisibilityError(visibility: string, error: NSFontCollection.Visibility): boolean;
        static renameFontCollectionWithNameVisibilityToNameError(fromName: string, visibility: NSFontCollection.Visibility, toName: string): boolean;
        static showFontCollectionWithNameVisibilityError(withName: NSFontCollection, visibility: string, error: NSFontCollection.Visibility): boolean;
        exclusionDescriptors: NSFontDescriptor[];
        matchingDescriptors: NSFontDescriptor[];
        queryDescriptors: NSFontDescriptor[];
        static allFontCollectionNames: string[];
        static fontCollectionWithAllAvailableDescriptors: NSFontCollection;
        matchingDescriptorsForFamily(forFamily: string): NSFontDescriptor[];
        matchingDescriptorsForFamilyOptions(forFamily: string, options?: Map<string, number>): NSFontDescriptor[];
        matchingDescriptorsWithOptions(options?: Map<string, number>): NSFontDescriptor[];
    }
    class NSFontDescriptor extends NSObject {
        fontAttributes: Map<string, any>;
        matrix: NSAffineTransform;
        pointSize: number;
        postscriptName: string;
        requiresFontAssetRequest: boolean;
        symbolicTraits: NSFontDescriptor.SymbolicTraits;
        fontDescriptorByAddingAttributes(_: Map<string, any>): NSFontDescriptor;
        fontDescriptorWithDesign(_: string): NSFontDescriptor;
        fontDescriptorWithFace(_: string): NSFontDescriptor;
        fontDescriptorWithFamily(_: string): NSFontDescriptor;
        fontDescriptorWithMatrix(_: NSAffineTransform): NSFontDescriptor;
        fontDescriptorWithSize(_: number): NSFontDescriptor;
        fontDescriptorWithSymbolicTraits(_: NSFontDescriptor.SymbolicTraits): NSFontDescriptor;
        static createWithFontAttributes(fontAttributes?: Map<string, any>): NSFontDescriptor;
        matchingFontDescriptorWithWithMandatoryKeys(withMandatoryKeys?: NSSet<string>): NSFontDescriptor;
        matchingFontDescriptorsWithWithMandatoryKeys(withMandatoryKeys?: NSSet<string>): NSFontDescriptor[];
        objectForKey(forKey: string): any;
    }
    class NSFontManager extends NSObject {
        static setFontManagerFactory(_?: typeof NSObject): void;
        static setFontPanelFactory(_?: typeof NSObject): void;
        action: string;
        setAction(_: string): any;
        availableFontFamilies: string[];
        availableFonts: string[];
        currentFontAction: NSFontAction;
        isEnabled: boolean;
        setEnabled(_: boolean): any;
        isMultiple: boolean;
        selectedFont: NSFont;
        target: any;
        setTarget(_: any): any;
        static sharedFontManager: NSFontManager;
        addFontTrait(_?: any): void;
        availableFontNamesWithTraits(with_: NSFontTraitMask): string[];
        availableMembersOfFontFamily(ofFontFamily: string): any[][];
        convertAttributes(_: Map<string, any>): Map<string, any>;
        convertFont(_: NSFont): NSFont;
        convertFontToFace(_: NSFont, toFace: string): NSFont;
        convertFontToFamily(_: NSFont, toFamily: string): NSFont;
        convertFontToHaveTrait(_: NSFont, toHaveTrait: NSFontTraitMask): NSFont;
        convertFontToNotHaveTrait(_: NSFont, toNotHaveTrait: NSFontTraitMask): NSFont;
        convertFontToSize(_: NSFont, toSize: number): NSFont;
        convertFontTraits(_: NSFontTraitMask): NSFontTraitMask;
        convertWeightOfFont(_: boolean, of: NSFont): NSFont;
        fontMenu(_: boolean): NSMenu;
        fontNamedHasTraits(_: string, hasTraits: NSFontTraitMask): boolean;
        fontPanel(_: boolean): NSFontPanel;
        fontWithFamilyTraitsWeightSize(withFamily: string, traits: NSFontTraitMask, weight: number, size: number): NSFont;
        localizedNameForFamilyFace(forFamily: string, face?: string): string;
        modifyFont(_?: any): void;
        modifyFontViaPanel(_?: any): void;
        orderFrontFontPanel(_?: any): void;
        orderFrontStylesPanel(_?: any): void;
        removeFontTrait(_?: any): void;
        sendAction(): boolean;
        setFontMenu(_: NSMenu): void;
        setSelectedAttributesIsMultiple(_: Map<string, any>, isMultiple: boolean): void;
        setSelectedFontIsMultiple(_: NSFont, isMultiple: boolean): void;
        traitsOfFont(of: NSFont): NSFontTraitMask;
        weightOfFont(of: NSFont): number;
    }
    class NSFontPanel extends NSPanel {
        accessoryView: NSView;
        setAccessoryView(_: NSView): any;
        isEnabled: boolean;
        setEnabled(_: boolean): any;
        static sharedFontPanel: NSFontPanel;
        static sharedFontPanelExists: boolean;
        panelConvertFont(_: NSFont): NSFont;
        reloadDefaultFontFamilies(): void;
        setPanelFontIsMultiple(_: NSFont, isMultiple: boolean): void;
    }
    class NSFormCell extends NSActionCell {
        attributedTitle: NSAttributedString;
        setAttributedTitle(_: NSAttributedString): any;
        placeholderAttributedString: NSAttributedString;
        setPlaceholderAttributedString(_: NSAttributedString): any;
        placeholderString: string;
        setPlaceholderString(_: string): any;
        preferredTextFieldWidth: number;
        setPreferredTextFieldWidth(_: number): any;
        titleAlignment: NSTextAlignment;
        setTitleAlignment(_: NSTextAlignment): any;
        titleBaseWritingDirection: NSWritingDirection;
        setTitleBaseWritingDirection(_: NSWritingDirection): any;
        titleFont: NSFont;
        setTitleFont(_: NSFont): any;
        titleWidth: number;
        setTitleWidth(_: number): any;
    }
    class NSGestureRecognizer extends NSObject {
        action: string;
        setAction(_: string): any;
        allowedTouchTypes: NSTouch.TouchTypeMask;
        setAllowedTouchTypes(_: NSTouch.TouchTypeMask): any;
        delaysKeyEvents: boolean;
        setDelaysKeyEvents(_: boolean): any;
        delaysMagnificationEvents: boolean;
        setDelaysMagnificationEvents(_: boolean): any;
        delaysOtherMouseButtonEvents: boolean;
        setDelaysOtherMouseButtonEvents(_: boolean): any;
        delaysPrimaryMouseButtonEvents: boolean;
        setDelaysPrimaryMouseButtonEvents(_: boolean): any;
        delaysRotationEvents: boolean;
        setDelaysRotationEvents(_: boolean): any;
        delaysSecondaryMouseButtonEvents: boolean;
        setDelaysSecondaryMouseButtonEvents(_: boolean): any;
        delegate: NSGestureRecognizerDelegate;
        setDelegate(_: NSGestureRecognizerDelegate): any;
        isEnabled: boolean;
        setEnabled(_: boolean): any;
        pressureConfiguration: NSPressureConfiguration;
        setPressureConfiguration(_: NSPressureConfiguration): any;
        state: NSGestureRecognizer.State;
        setState(_: NSGestureRecognizer.State): any;
        target: any;
        setTarget(_: any): any;
        view: NSView;
        canBePreventedByGestureRecognizer(by: NSGestureRecognizer): boolean;
        canPreventGestureRecognizer(_: NSGestureRecognizer): boolean;
        flagsChanged(with_: NSEvent): void;
        static createWithTargetAction(target?: any, action?: string): NSGestureRecognizer;
        keyDown(with_: NSEvent): void;
        keyUp(with_: NSEvent): void;
        locationInView(in_?: NSView): CGPoint;
        magnifyWithEvent(with_: NSEvent): void;
        mouseDown(with_: NSEvent): void;
        mouseDragged(with_: NSEvent): void;
        mouseUp(with_: NSEvent): void;
        otherMouseDown(with_: NSEvent): void;
        otherMouseDragged(with_: NSEvent): void;
        otherMouseUp(with_: NSEvent): void;
        pressureChangeWithEvent(with_: NSEvent): void;
        reset(): void;
        rightMouseDown(with_: NSEvent): void;
        rightMouseDragged(with_: NSEvent): void;
        rightMouseUp(with_: NSEvent): void;
        rotateWithEvent(with_: NSEvent): void;
        shouldBeRequiredToFailByGestureRecognizer(by: NSGestureRecognizer): boolean;
        shouldRequireFailureOfGestureRecognizer(of: NSGestureRecognizer): boolean;
        tabletPoint(with_: NSEvent): void;
        touchesBeganWithEvent(with_: NSEvent): void;
        touchesCancelledWithEvent(with_: NSEvent): void;
        touchesEndedWithEvent(with_: NSEvent): void;
        touchesMovedWithEvent(with_: NSEvent): void;
    }
    interface NSGestureRecognizerDelegate extends NSObject {
        gestureRecognizerShouldAttemptToRecognizeWithEvent?(_: NSGestureRecognizer, shouldAttemptToRecognizeWith: NSEvent): boolean;
        gestureRecognizerShouldRecognizeSimultaneouslyWithGestureRecognizer?(_: NSGestureRecognizer, shouldRecognizeSimultaneouslyWith: NSGestureRecognizer): boolean;
        gestureRecognizerShouldRequireFailureOfGestureRecognizer?(_: NSGestureRecognizer, shouldRequireFailureOf: NSGestureRecognizer): boolean;
        gestureRecognizerShouldBeRequiredToFailByGestureRecognizer?(_: NSGestureRecognizer, shouldBeRequiredToFailBy: NSGestureRecognizer): boolean;
        gestureRecognizerShouldReceiveTouch?(_: NSGestureRecognizer, shouldReceive: NSTouch): boolean;
        gestureRecognizerShouldBegin?(_: NSGestureRecognizer): boolean;
    }
    class NSGlyphGenerator extends NSObject {
        static sharedGlyphGenerator: NSGlyphGenerator;
        generateGlyphsForGlyphStorageDesiredNumberOfCharactersGlyphIndexCharacterIndex(for_: NSGlyphStorage, desiredNumberOfCharacters: number, glyphIndex?: number, characterIndex?: number): void;
    }
    class NSGlyphInfo extends NSObject {
        baseString: string;
        characterCollection: NSCharacterCollection;
        characterIdentifier: number;
        glyphID: number;
        glyphName: string;
    }
    interface NSGlyphStorage {
        attributedString(): NSAttributedString;
        insertGlyphsLengthForStartingGlyphAtIndexCharacterIndex(_: number, length: number, forStartingGlyphAt: number, characterIndex: number): void;
        layoutOptions(): number;
        setIntAttributeValueForGlyphAtIndex(_: number, value: number, forGlyphAt: number): void;
    }
    class NSGradient extends NSObject {
        colorSpace: NSColorSpace;
        numberOfColorStops: number;
        drawFromCenterRadiusToCenterRadiusOptions(fromCenter: CGPoint, radius: number, toCenter: CGPoint, radius2: number, options: NSGradient.DrawingOptions): void;
        drawFromPointToPointOptions(from: CGPoint, to: CGPoint, options: NSGradient.DrawingOptions): void;
        drawInBezierPathAngle(in_: NSBezierPath, angle: number): void;
        drawInBezierPathRelativeCenterPosition(in_: NSBezierPath, relativeCenterPosition: CGPoint): void;
        drawInRectAngle(in_: CGRect, angle: number): void;
        drawInRectRelativeCenterPosition(in_: CGRect, relativeCenterPosition: CGPoint): void;
        getColorLocationAtIndex(_?: NSColor, location?: number, at?: number): void;
        static createWithColors(colors: NSColor[]): NSGradient;
        static createWithColorsAtLocationsColorSpace(colors: NSColor[], atLocations?: number, colorSpace?: NSColorSpace): NSGradient;
        static createWithColorsAndLocations(colorsAndLocations: NSColor): NSGradient;
        static createWithStartingColorEndingColor(startingColor: NSColor, endingColor: NSColor): NSGradient;
        interpolatedColorAtLocation(atLocation: number): NSColor;
    }
    class NSGraphicsContext extends NSObject {
        static currentContextDrawingToScreen(): boolean;
        static restoreGraphicsState(): void;
        static saveGraphicsState(): void;
        CGContext: any;
        CIContext: CIContext;
        attributes: Map<string, any>;
        colorRenderingIntent: NSColorRenderingIntent;
        setColorRenderingIntent(_: NSColorRenderingIntent): any;
        compositingOperation: NSCompositingOperation;
        setCompositingOperation(_: NSCompositingOperation): any;
        isDrawingToScreen: boolean;
        isFlipped: boolean;
        imageInterpolation: NSImageInterpolation;
        setImageInterpolation(_: NSImageInterpolation): any;
        patternPhase: CGPoint;
        setPatternPhase(_: CGPoint): any;
        shouldAntialias: boolean;
        setShouldAntialias(_: boolean): any;
        static currentContext: NSGraphicsContext;
        setCurrentContext(_: NSGraphicsContext): any;
        flushGraphics(): void;
        restoreGraphicsState(): void;
        saveGraphicsState(): void;
    }
    class NSGridCell extends NSObject {
        column: NSGridColumn;
        contentView: NSView;
        setContentView(_: NSView): any;
        customPlacementConstraints: NSLayoutConstraint[];
        setCustomPlacementConstraints(_: NSLayoutConstraint[]): any;
        row: NSGridRow;
        rowAlignment: NSGridRow.Alignment;
        setRowAlignment(_: NSGridRow.Alignment): any;
        xPlacement: NSGridCell.Placement;
        setXPlacement(_: NSGridCell.Placement): any;
        yPlacement: NSGridCell.Placement;
        setYPlacement(_: NSGridCell.Placement): any;
        static emptyContentView: NSView;
    }
    class NSGridColumn extends NSObject {
        gridView: NSGridView;
        isHidden: boolean;
        setHidden(_: boolean): any;
        leadingPadding: number;
        setLeadingPadding(_: number): any;
        numberOfCells: number;
        trailingPadding: number;
        setTrailingPadding(_: number): any;
        width: number;
        setWidth(_: number): any;
        xPlacement: NSGridCell.Placement;
        setXPlacement(_: NSGridCell.Placement): any;
        cellAtIndex(at: number): NSGridCell;
        mergeCellsInRange(in_: NSRange): void;
    }
    class NSGridRow extends NSObject {
        bottomPadding: number;
        setBottomPadding(_: number): any;
        gridView: NSGridView;
        height: number;
        setHeight(_: number): any;
        isHidden: boolean;
        setHidden(_: boolean): any;
        numberOfCells: number;
        rowAlignment: NSGridRow.Alignment;
        setRowAlignment(_: NSGridRow.Alignment): any;
        topPadding: number;
        setTopPadding(_: number): any;
        yPlacement: NSGridCell.Placement;
        setYPlacement(_: NSGridCell.Placement): any;
        cellAtIndex(at: number): NSGridCell;
        mergeCellsInRange(in_: NSRange): void;
    }
    class NSGridView extends NSView {
        columnSpacing: number;
        setColumnSpacing(_: number): any;
        numberOfColumns: number;
        numberOfRows: number;
        rowAlignment: NSGridRow.Alignment;
        setRowAlignment(_: NSGridRow.Alignment): any;
        rowSpacing: number;
        setRowSpacing(_: number): any;
        xPlacement: NSGridCell.Placement;
        setXPlacement(_: NSGridCell.Placement): any;
        yPlacement: NSGridCell.Placement;
        setYPlacement(_: NSGridCell.Placement): any;
        addColumnWithViews(with_: NSView[]): NSGridColumn;
        addRowWithViews(with_: NSView[]): NSGridRow;
        cellAtColumnIndexRowIndex(atColumnIndex: number, rowIndex: number): NSGridCell;
        cellForView(for_: NSView): NSGridCell;
        columnAtIndex(at: number): NSGridColumn;
        indexOfColumn(of: NSGridColumn): number;
        indexOfRow(of: NSGridRow): number;
        insertColumnAtIndexWithViews(at: number, with_: NSView[]): NSGridColumn;
        insertRowAtIndexWithViews(at: number, with_: NSView[]): NSGridRow;
        mergeCellsInHorizontalRangeVerticalRange(inHorizontalRange: NSRange, verticalRange: NSRange): void;
        moveColumnAtIndexToIndex(at: number, to: number): void;
        moveRowAtIndexToIndex(at: number, to: number): void;
        removeColumnAtIndex(at: number): void;
        removeRowAtIndex(at: number): void;
        rowAtIndex(at: number): NSGridRow;
    }
    class NSGroupTouchBarItem extends NSTouchBarItem {
        static alertStyleGroupItemWithIdentifier(alertStyleWithIdentifier: string): NSGroupTouchBarItem;
        static groupItemWithIdentifierItems(identifier: string, items: NSTouchBarItem[]): NSGroupTouchBarItem;
        static groupItemWithIdentifierItemsAllowedCompressionOptions(identifier: string, items: NSTouchBarItem[], allowedCompressionOptions: NSUserInterfaceCompressionOptions): NSGroupTouchBarItem;
        effectiveCompressionOptions: NSUserInterfaceCompressionOptions;
        groupTouchBar: NSTouchBar;
        setGroupTouchBar(_: NSTouchBar): any;
        groupUserInterfaceLayoutDirection: NSUserInterfaceLayoutDirection;
        setGroupUserInterfaceLayoutDirection(_: NSUserInterfaceLayoutDirection): any;
        preferredItemWidth: number;
        setPreferredItemWidth(_: number): any;
        prefersEqualWidths: boolean;
        setPrefersEqualWidths(_: boolean): any;
        prioritizedCompressionOptions: NSUserInterfaceCompressionOptions[];
        setPrioritizedCompressionOptions(_: NSUserInterfaceCompressionOptions[]): any;
    }
    class NSHapticFeedbackManager extends NSObject {
        static defaultPerformer: NSHapticFeedbackPerformer;
    }
    interface NSHapticFeedbackPerformer extends NSObject {
        performFeedbackPatternPerformanceTime(_: NSHapticFeedbackManager.FeedbackPattern, performanceTime: NSHapticFeedbackManager.PerformanceTime): void;
    }
    class NSHelpManager extends NSObject {
        static isContextHelpModeActive: boolean;
        setContextHelpModeActive(_: boolean): any;
        static sharedHelpManager: NSHelpManager;
        contextHelpForObject(for_: any): NSAttributedString;
        findStringInBook(_: string, inBook?: string): void;
        openHelpAnchorInBook(_: string, inBook?: string): void;
        registerBooksInBundle(in_: Bundle): boolean;
        removeContextHelpForObject(for_: any): void;
        setContextHelpForObject(_: NSAttributedString, for_: any): void;
        showContextHelpForObjectLocationHint(for_: any, locationHint: CGPoint): boolean;
    }
    interface NSIgnoreMisspelledWords {
        ignoreSpelling(_?: any): void;
    }
    class NSImage extends NSObject {
        static canInitWithPasteboard(with_: NSPasteboard): boolean;
        TIFFRepresentation: NSData;
        accessibilityDescription: string;
        setAccessibilityDescription(_: string): any;
        alignmentRect: CGRect;
        setAlignmentRect(_: CGRect): any;
        backgroundColor: NSColor;
        setBackgroundColor(_: NSColor): any;
        cacheMode: NSImage.CacheMode;
        setCacheMode(_: NSImage.CacheMode): any;
        capInsets: NSEdgeInsets;
        setCapInsets(_: NSEdgeInsets): any;
        delegate: NSImageDelegate;
        setDelegate(_: NSImageDelegate): any;
        matchesOnMultipleResolution: boolean;
        setMatchesOnMultipleResolution(_: boolean): any;
        matchesOnlyOnBestFittingAxis: boolean;
        setMatchesOnlyOnBestFittingAxis(_: boolean): any;
        prefersColorMatch: boolean;
        setPrefersColorMatch(_: boolean): any;
        representations: NSImageRep[];
        resizingMode: NSImage.ResizingMode;
        setResizingMode(_: NSImage.ResizingMode): any;
        size: CGSize;
        setSize(_: CGSize): any;
        isTemplate: boolean;
        setTemplate(_: boolean): any;
        usesEPSOnResolutionMismatch: boolean;
        setUsesEPSOnResolutionMismatch(_: boolean): any;
        isValid: boolean;
        static imageTypes: string[];
        static imageUnfilteredTypes: string[];
        CGImageForProposedRectContextHints(forProposedRect?: NSRect, context?: NSGraphicsContext, hints?: Map<string, any>): any;
        TIFFRepresentationUsingCompressionFactor(using: NSBitmapImageRep.TIFFCompression, factor: number): NSData;
        addRepresentation(_: NSImageRep): void;
        addRepresentations(_: NSImageRep[]): void;
        bestRepresentationForRectContextHints(for_: CGRect, context?: NSGraphicsContext, hints?: Map<string, any>): NSImageRep;
        cancelIncrementalLoad(): void;
        drawAtPointFromRectOperationFraction(at: CGPoint, from: CGRect, operation: NSCompositingOperation, fraction: number): void;
        drawInRect(in_: CGRect): void;
        drawInRectFromRectOperationFraction(in_: CGRect, from: CGRect, operation: NSCompositingOperation, fraction: number): void;
        drawInRectFromRectOperationFractionRespectFlippedHints(in_: CGRect, from: CGRect, operation: NSCompositingOperation, fraction: number, respectFlipped: boolean, hints?: Map<string, any>): void;
        drawRepresentationInRect(_: NSImageRep, in_: CGRect): boolean;
        hitTestRectWithImageDestinationRectContextHintsFlipped(_: CGRect, withDestinationRect: CGRect, context?: NSGraphicsContext, hints?: Map<string, any>, flipped?: boolean): boolean;
        static createWithByReferencingFile(byReferencingFile: string): NSImage;
        static createWithByReferencingURL(byReferencingURL: NSURL): NSImage;
        static createWithCGImageSize(CGImage: any, size: CGSize): NSImage;
        static createWithContentsOfFile(contentsOfFile: string): NSImage;
        static createWithContentsOfURL(contentsOfURL: NSURL): NSImage;
        static createWithData(data: NSData): NSImage;
        static createWithDataIgnoringOrientation(dataIgnoringOrientation: NSData): NSImage;
        static createWithIconRef(iconRef: any): NSImage;
        static createWithPasteboard(pasteboard: NSPasteboard): NSImage;
        static createWithSize(size: CGSize): NSImage;
        layerContentsForContentsScale(forContentsScale: number): any;
        lockFocus(): void;
        lockFocusFlipped(_: boolean): void;
        name(): string;
        recache(): void;
        recommendedLayerContentsScale(_: number): number;
        removeRepresentation(_: NSImageRep): void;
        setName(_?: string): boolean;
        unlockFocus(): void;
    }
    class NSImageCell extends NSCell {
        imageAlignment: NSImageAlignment;
        setImageAlignment(_: NSImageAlignment): any;
        imageFrameStyle: NSImageView.FrameStyle;
        setImageFrameStyle(_: NSImageView.FrameStyle): any;
        imageScaling: NSImageScaling;
        setImageScaling(_: NSImageScaling): any;
    }
    interface NSImageDelegate extends NSObject {
        imageDidLoadRepresentationWithStatus?(_: NSImage, didLoadRepresentation: NSImageRep, with_: NSImage.LoadStatus): void;
        imageDidLoadPartOfRepresentationWithValidRows?(_: NSImage, didLoadPartOfRepresentation: NSImageRep, withValidRows: number): void;
        imageDidLoadRepresentationHeader?(_: NSImage, didLoadRepresentationHeader: NSImageRep): void;
        imageWillLoadRepresentation?(_: NSImage, willLoadRepresentation: NSImageRep): void;
        imageDidNotDrawInRect?(_: NSImage, in_: CGRect): NSImage;
    }
    class NSImageRep extends NSObject {
        static canInitWithData(with_: NSData): boolean;
        static canInitWithPasteboard(with_: NSPasteboard): boolean;
        static imageRepClassForData(for_: NSData): typeof NSObject;
        static imageRepClassForType(forType: string): typeof NSObject;
        static imageRepsWithContentsOfFile(withContentsOfFile: string): NSImageRep[];
        static imageRepsWithContentsOfURL(withContentsOf: NSURL): NSImageRep[];
        static imageRepsWithPasteboard(with_: NSPasteboard): NSImageRep[];
        static registerImageRepClass(_: typeof NSObject): void;
        static unregisterImageRepClass(_: typeof NSObject): void;
        hasAlpha: boolean;
        setAlpha(_: boolean): any;
        bitsPerSample: number;
        setBitsPerSample(_: number): any;
        colorSpaceName: string;
        setColorSpaceName(_: string): any;
        layoutDirection: NSImage.LayoutDirection;
        setLayoutDirection(_: NSImage.LayoutDirection): any;
        isOpaque: boolean;
        setOpaque(_: boolean): any;
        pixelsHigh: number;
        setPixelsHigh(_: number): any;
        pixelsWide: number;
        setPixelsWide(_: number): any;
        size: CGSize;
        setSize(_: CGSize): any;
        static imageTypes: string[];
        static imageUnfilteredTypes: string[];
        static registeredImageRepClasses: typeof NSObject[];
        CGImageForProposedRectContextHints(forProposedRect?: NSRect, context?: NSGraphicsContext, hints?: Map<string, any>): any;
        draw(): boolean;
        drawAtPoint(at: CGPoint): boolean;
        drawInRect(in_: CGRect): boolean;
        drawInRectFromRectOperationFractionRespectFlippedHints(in_: CGRect, from: CGRect, operation: NSCompositingOperation, fraction: number, respectFlipped: boolean, hints?: Map<string, any>): boolean;
    }
    class NSImageView extends NSControl {
        allowsCutCopyPaste: boolean;
        setAllowsCutCopyPaste(_: boolean): any;
        animates: boolean;
        setAnimates(_: boolean): any;
        contentTintColor: NSColor;
        setContentTintColor(_: NSColor): any;
        isEditable: boolean;
        setEditable(_: boolean): any;
        image: NSImage;
        setImage(_: NSImage): any;
        imageAlignment: NSImageAlignment;
        setImageAlignment(_: NSImageAlignment): any;
        imageFrameStyle: NSImageView.FrameStyle;
        setImageFrameStyle(_: NSImageView.FrameStyle): any;
        imageScaling: NSImageScaling;
        setImageScaling(_: NSImageScaling): any;
    }
    interface NSInputServerMouseTracker {
    }
    interface NSInputServiceProvider {
    }
    class NSLayoutAnchor<AnchorType> extends NSObject {
        constraintsAffectingLayout: NSLayoutConstraint[];
        hasAmbiguousLayout: boolean;
        item: any;
        name: string;
        constraintWithEqualTo(equalTo: NSLayoutAnchor<AnchorType>): NSLayoutConstraint;
        constraintWithEqualToConstant(equalTo: NSLayoutAnchor<AnchorType>, constant: number): NSLayoutConstraint;
        constraintWithGreaterThanOrEqualTo(greaterThanOrEqualTo: NSLayoutAnchor<AnchorType>): NSLayoutConstraint;
        constraintWithGreaterThanOrEqualToConstant(greaterThanOrEqualTo: NSLayoutAnchor<AnchorType>, constant: number): NSLayoutConstraint;
        constraintWithLessThanOrEqualTo(lessThanOrEqualTo: NSLayoutAnchor<AnchorType>): NSLayoutConstraint;
        constraintWithLessThanOrEqualToConstant(lessThanOrEqualTo: NSLayoutAnchor<AnchorType>, constant: number): NSLayoutConstraint;
    }
    class NSLayoutConstraint extends NSObject {
        static activateConstraints(_: NSLayoutConstraint[]): void;
        static constraintsWithVisualFormatOptionsMetricsViews(withVisualFormat: string, options: NSLayoutConstraint.FormatOptions, metrics?: Map<string, any>, views?: Map<string, any>): NSLayoutConstraint[];
        static deactivateConstraints(_: NSLayoutConstraint[]): void;
        isActive: boolean;
        setActive(_: boolean): any;
        constant: number;
        setConstant(_: number): any;
        firstAnchor: NSLayoutAnchor<any>;
        firstAttribute: NSLayoutConstraint.Attribute;
        firstItem: any;
        identifier: string;
        setIdentifier(_: string): any;
        multiplier: number;
        priority: number;
        setPriority(_: number): any;
        relation: NSLayoutConstraint.Relation;
        secondAnchor: NSLayoutAnchor<any>;
        secondAttribute: NSLayoutConstraint.Attribute;
        secondItem: any;
        shouldBeArchived: boolean;
        setShouldBeArchived(_: boolean): any;
    }
    class NSLayoutDimension extends NSLayoutAnchor<NSLayoutDimension> {
        constraintEqualToAnchorMultiplier(equalTo: NSLayoutDimension, multiplier: number): NSLayoutConstraint;
        constraintEqualToAnchorMultiplierConstant(equalTo: NSLayoutDimension, multiplier: number, constant: number): NSLayoutConstraint;
        constraintEqualToConstant(equalToConstant: number): NSLayoutConstraint;
        constraintGreaterThanOrEqualToAnchorMultiplier(greaterThanOrEqualTo: NSLayoutDimension, multiplier: number): NSLayoutConstraint;
        constraintGreaterThanOrEqualToAnchorMultiplierConstant(greaterThanOrEqualTo: NSLayoutDimension, multiplier: number, constant: number): NSLayoutConstraint;
        constraintGreaterThanOrEqualToConstant(greaterThanOrEqualToConstant: number): NSLayoutConstraint;
        constraintLessThanOrEqualToAnchorMultiplier(lessThanOrEqualTo: NSLayoutDimension, multiplier: number): NSLayoutConstraint;
        constraintLessThanOrEqualToAnchorMultiplierConstant(lessThanOrEqualTo: NSLayoutDimension, multiplier: number, constant: number): NSLayoutConstraint;
        constraintLessThanOrEqualToConstant(lessThanOrEqualToConstant: number): NSLayoutConstraint;
    }
    class NSLayoutGuide extends NSObject {
        bottomAnchor: NSLayoutYAxisAnchor;
        centerXAnchor: NSLayoutXAxisAnchor;
        centerYAnchor: NSLayoutYAxisAnchor;
        frame: CGRect;
        hasAmbiguousLayout: boolean;
        heightAnchor: NSLayoutDimension;
        leadingAnchor: NSLayoutXAxisAnchor;
        leftAnchor: NSLayoutXAxisAnchor;
        owningView: NSView;
        setOwningView(_: NSView): any;
        rightAnchor: NSLayoutXAxisAnchor;
        topAnchor: NSLayoutYAxisAnchor;
        trailingAnchor: NSLayoutXAxisAnchor;
        widthAnchor: NSLayoutDimension;
        constraintsAffectingLayoutForOrientation(for_: NSLayoutConstraint.Orientation): NSLayoutConstraint[];
    }
    class NSLayoutManager extends NSObject {
        allowsNonContiguousLayout: boolean;
        setAllowsNonContiguousLayout(_: boolean): any;
        backgroundLayoutEnabled: boolean;
        setBackgroundLayoutEnabled(_: boolean): any;
        defaultAttachmentScaling: NSImageScaling;
        setDefaultAttachmentScaling(_: NSImageScaling): any;
        delegate: NSLayoutManagerDelegate;
        setDelegate(_: NSLayoutManagerDelegate): any;
        extraLineFragmentRect: CGRect;
        extraLineFragmentTextContainer: NSTextContainer;
        extraLineFragmentUsedRect: CGRect;
        firstTextView: NSTextView;
        glyphGenerator: NSGlyphGenerator;
        setGlyphGenerator(_: NSGlyphGenerator): any;
        hasNonContiguousLayout: boolean;
        limitsLayoutForSuspiciousContents: boolean;
        setLimitsLayoutForSuspiciousContents(_: boolean): any;
        numberOfGlyphs: number;
        showsControlCharacters: boolean;
        setShowsControlCharacters(_: boolean): any;
        showsInvisibleCharacters: boolean;
        setShowsInvisibleCharacters(_: boolean): any;
        textContainers: NSTextContainer[];
        textStorage: NSTextStorage;
        setTextStorage(_: NSTextStorage): any;
        textViewForBeginningOfSelection: NSTextView;
        typesetter: NSTypesetter;
        setTypesetter(_: NSTypesetter): any;
        typesetterBehavior: NSLayoutManager.TypesetterBehavior;
        setTypesetterBehavior(_: NSLayoutManager.TypesetterBehavior): any;
        usesDefaultHyphenation: boolean;
        setUsesDefaultHyphenation(_: boolean): any;
        usesFontLeading: boolean;
        setUsesFontLeading(_: boolean): any;
        CGGlyphAtIndex(at: number): number;
        CGGlyphAtIndexIsValidIndex(at: number, isValidIndex?: boolean): number;
        addTemporaryAttributeValueForCharacterRange(_: string, value: any, forCharacterRange: NSRange): void;
        addTemporaryAttributesForCharacterRange(_: Map<string, any>, forCharacterRange: NSRange): void;
        addTextContainer(_: NSTextContainer): void;
        attachmentSizeForGlyphAtIndex(forGlyphAt: number): CGSize;
        boundingRectForGlyphRangeInTextContainer(forGlyphRange: NSRange, in_: NSTextContainer): CGRect;
        boundsRectForTextBlockAtIndexEffectiveRange(for_: NSTextBlock, at: number, effectiveRange?: NSRange): CGRect;
        boundsRectForTextBlockGlyphRange(for_: NSTextBlock, glyphRange: NSRange): CGRect;
        characterIndexForGlyphAtIndex(at: number): number;
        characterIndexForPointInTextContainerFractionOfDistanceBetweenInsertionPoints(for_: CGPoint, in_: NSTextContainer, fractionOfDistanceBetweenInsertionPoints?: number): number;
        characterRangeForGlyphRangeActualGlyphRange(forGlyphRange: NSRange, actualGlyphRange?: NSRange): NSRange;
        defaultBaselineOffsetForFont(for_: NSFont): number;
        defaultLineHeightForFont(for_: NSFont): number;
        drawBackgroundForGlyphRangeAtPoint(forGlyphRange: NSRange, at: CGPoint): void;
        drawGlyphsForGlyphRangeAtPoint(forGlyphRange: NSRange, at: CGPoint): void;
        drawStrikethroughForGlyphRangeStrikethroughTypeBaselineOffsetLineFragmentRectLineFragmentGlyphRangeContainerOrigin(forGlyphRange: NSRange, strikethroughType: NSUnderlineStyle, baselineOffset: number, lineFragmentRect: CGRect, lineFragmentGlyphRange: NSRange, containerOrigin: CGPoint): void;
        drawUnderlineForGlyphRangeUnderlineTypeBaselineOffsetLineFragmentRectLineFragmentGlyphRangeContainerOrigin(forGlyphRange: NSRange, underlineType: NSUnderlineStyle, baselineOffset: number, lineFragmentRect: CGRect, lineFragmentGlyphRange: NSRange, containerOrigin: CGPoint): void;
        drawsOutsideLineFragmentForGlyphAtIndex(forGlyphAt: number): boolean;
        ensureGlyphsForCharacterRange(forCharacterRange: NSRange): void;
        ensureGlyphsForGlyphRange(forGlyphRange: NSRange): void;
        ensureLayoutForBoundingRectInTextContainer(forBoundingRect: CGRect, in_: NSTextContainer): void;
        ensureLayoutForCharacterRange(forCharacterRange: NSRange): void;
        ensureLayoutForGlyphRange(forGlyphRange: NSRange): void;
        ensureLayoutForTextContainer(for_: NSTextContainer): void;
        enumerateEnclosingRectsWithForGlyphRangeWithinSelectedGlyphRangeInUsing(forGlyphRange: NSRange, withinSelectedGlyphRange: NSRange, in_: NSTextContainer, using: (p1: CGRect, p2: boolean) => void): void;
        enumerateLineFragmentsWithForGlyphRangeUsing(forGlyphRange: NSRange, using: (p1: CGRect, p2: CGRect, p3: NSTextContainer, p4: NSRange, p5: boolean) => void): void;
        fillBackgroundRectArrayCountForCharacterRangeColor(_: NSRect, count: number, forCharacterRange: NSRange, color: NSColor): void;
        firstUnlaidCharacterIndex(): number;
        firstUnlaidGlyphIndex(): number;
        fractionOfDistanceThroughGlyphForPointInTextContainer(for_: CGPoint, in_: NSTextContainer): number;
        getFirstUnlaidCharacterIndexGlyphIndex(_?: number, glyphIndex?: number): void;
        getGlyphsInRangeGlyphsPropertiesCharacterIndexesBidiLevels(in_: NSRange, glyphs?: number, properties?: NSLayoutManager.GlyphProperty, characterIndexes?: number, bidiLevels?: string): number;
        getLineFragmentInsertionPointsForCharacterAtIndexAlternatePositionsInDisplayOrderPositionsCharacterIndexes(forCharacterAt: number, alternatePositions: boolean, inDisplayOrder: boolean, positions?: number, characterIndexes?: number): number;
        glyphAtIndex(at: number): number;
        glyphAtIndexIsValidIndex(at: number, isValidIndex?: boolean): number;
        glyphIndexForCharacterAtIndex(at: number): number;
        glyphIndexForPointInTextContainer(for_: CGPoint, in_: NSTextContainer): number;
        glyphIndexForPointInTextContainerFractionOfDistanceThroughGlyph(for_: CGPoint, in_: NSTextContainer, fractionOfDistanceThroughGlyph?: number): number;
        glyphRangeForBoundingRectInTextContainer(forBoundingRect: CGRect, in_: NSTextContainer): NSRange;
        glyphRangeForBoundingRectWithoutAdditionalLayoutInTextContainer(forBoundingRectWithoutAdditionalLayout: CGRect, in_: NSTextContainer): NSRange;
        glyphRangeForCharacterRangeActualCharacterRange(forCharacterRange: NSRange, actualCharacterRange?: NSRange): NSRange;
        glyphRangeForTextContainer(for_: NSTextContainer): NSRange;
        insertTextContainerAtIndex(_: NSTextContainer, at: number): void;
        invalidateDisplayForCharacterRange(forCharacterRange: NSRange): void;
        invalidateDisplayForGlyphRange(forGlyphRange: NSRange): void;
        invalidateGlyphsForCharacterRangeChangeInLengthActualCharacterRange(forCharacterRange: NSRange, changeInLength: number, actualCharacterRange?: NSRange): void;
        invalidateLayoutForCharacterRangeActualCharacterRange(forCharacterRange: NSRange, actualCharacterRange?: NSRange): void;
        isValidGlyphIndex(_: number): boolean;
        layoutManagerOwnsFirstResponderInWindow(in_: NSWindow): boolean;
        layoutRectForTextBlockAtIndexEffectiveRange(for_: NSTextBlock, at: number, effectiveRange?: NSRange): CGRect;
        layoutRectForTextBlockGlyphRange(for_: NSTextBlock, glyphRange: NSRange): CGRect;
        lineFragmentRectForGlyphAtIndexEffectiveRange(forGlyphAt: number, effectiveRange?: NSRange): CGRect;
        lineFragmentRectForGlyphAtIndexEffectiveRangeWithoutAdditionalLayout(forGlyphAt: number, effectiveRange?: NSRange, withoutAdditionalLayout?: boolean): CGRect;
        lineFragmentUsedRectForGlyphAtIndexEffectiveRange(forGlyphAt: number, effectiveRange?: NSRange): CGRect;
        lineFragmentUsedRectForGlyphAtIndexEffectiveRangeWithoutAdditionalLayout(forGlyphAt: number, effectiveRange?: NSRange, withoutAdditionalLayout?: boolean): CGRect;
        locationForGlyphAtIndex(forGlyphAt: number): CGPoint;
        notShownAttributeForGlyphAtIndex(forGlyphAt: number): boolean;
        processEditingForTextStorageEditedRangeChangeInLengthInvalidatedRange(for_: NSTextStorage, edited: NSTextStorageEditActions, range: NSRange, changeInLength: number, invalidatedRange: NSRange): void;
        propertyForGlyphAtIndex(at: number): NSLayoutManager.GlyphProperty;
        rangeOfNominallySpacedGlyphsContainingIndex(ofNominallySpacedGlyphsContaining: number): NSRange;
        rectArrayForCharacterRangeWithinSelectedCharacterRangeInTextContainerRectCount(forCharacterRange: NSRange, withinSelectedCharacterRange: NSRange, in_: NSTextContainer, rectCount: number): NSRect;
        rectArrayForGlyphRangeWithinSelectedGlyphRangeInTextContainerRectCount(forGlyphRange: NSRange, withinSelectedGlyphRange: NSRange, in_: NSTextContainer, rectCount: number): NSRect;
        removeTemporaryAttributeForCharacterRange(_: string, forCharacterRange: NSRange): void;
        removeTextContainerAtIndex(at: number): void;
        replaceTextStorage(_: NSTextStorage): void;
        rulerAccessoryViewForTextViewParagraphStyleRulerEnabled(for_: NSTextView, paragraphStyle: NSParagraphStyle, ruler: NSRulerView, enabled: boolean): NSView;
        rulerMarkersForTextViewParagraphStyleRuler(for_: NSTextView, paragraphStyle: NSParagraphStyle, ruler: NSRulerView): NSRulerMarker[];
        setAttachmentSizeForGlyphRange(_: CGSize, forGlyphRange: NSRange): void;
        setBoundsRectForTextBlockGlyphRange(_: CGRect, for_: NSTextBlock, glyphRange: NSRange): void;
        setDrawsOutsideLineFragmentForGlyphAtIndex(_: boolean, forGlyphAt: number): void;
        setExtraLineFragmentRectUsedRectTextContainer(_: CGRect, usedRect: CGRect, textContainer: NSTextContainer): void;
        setGlyphsPropertiesCharacterIndexesFontForGlyphRange(_: number, properties: NSLayoutManager.GlyphProperty, characterIndexes: number, font: NSFont, forGlyphRange: NSRange): void;
        setLayoutRectForTextBlockGlyphRange(_: CGRect, for_: NSTextBlock, glyphRange: NSRange): void;
        setLineFragmentRectForGlyphRangeUsedRect(_: CGRect, forGlyphRange: NSRange, usedRect: CGRect): void;
        setLocationForStartOfGlyphRange(_: CGPoint, forStartOfGlyphRange: NSRange): void;
        setNotShownAttributeForGlyphAtIndex(_: boolean, forGlyphAt: number): void;
        setTemporaryAttributesForCharacterRange(_: Map<string, any>, forCharacterRange: NSRange): void;
        setTextContainerForGlyphRange(_: NSTextContainer, forGlyphRange: NSRange): void;
        showAttachmentCellInRectCharacterIndex(_: NSCell, in_: CGRect, characterIndex: number): void;
        showCGGlyphsPositionsCountFontTextMatrixAttributesInContext(_: number, positions: NSPoint, count: number, font: NSFont, textMatrix: CGAffineTransform, attributes: Map<string, any>, in_: any): void;
        strikethroughGlyphRangeStrikethroughTypeLineFragmentRectLineFragmentGlyphRangeContainerOrigin(_: NSRange, strikethroughType: NSUnderlineStyle, lineFragmentRect: CGRect, lineFragmentGlyphRange: NSRange, containerOrigin: CGPoint): void;
        temporaryAttributeAtCharacterIndexEffectiveRange(_: string, atCharacterIndex: number, effectiveRange?: NSRange): any;
        temporaryAttributeAtCharacterIndexLongestEffectiveRangeInRange(_: string, atCharacterIndex: number, longestEffectiveRange?: NSRange, in_?: NSRange): any;
        temporaryAttributesAtCharacterIndexEffectiveRange(atCharacterIndex: number, effectiveRange?: NSRange): Map<string, any>;
        temporaryAttributesAtCharacterIndexLongestEffectiveRangeInRange(atCharacterIndex: number, longestEffectiveRange?: NSRange, in_?: NSRange): Map<string, any>;
        textContainerChangedGeometry(_: NSTextContainer): void;
        textContainerChangedTextView(_: NSTextContainer): void;
        textContainerForGlyphAtIndexEffectiveRange(forGlyphAt: number, effectiveRange?: NSRange): NSTextContainer;
        textContainerForGlyphAtIndexEffectiveRangeWithoutAdditionalLayout(forGlyphAt: number, effectiveRange?: NSRange, withoutAdditionalLayout?: boolean): NSTextContainer;
        truncatedGlyphRangeInLineFragmentForGlyphAtIndex(inLineFragmentForGlyphAt: number): NSRange;
        underlineGlyphRangeUnderlineTypeLineFragmentRectLineFragmentGlyphRangeContainerOrigin(_: NSRange, underlineType: NSUnderlineStyle, lineFragmentRect: CGRect, lineFragmentGlyphRange: NSRange, containerOrigin: CGPoint): void;
        usedRectForTextContainer(for_: NSTextContainer): CGRect;
    }
    interface NSLayoutManagerDelegate extends NSObject {
        layoutManagerLineSpacingAfterGlyphAtIndexWithProposedLineFragmentRect?(_: NSLayoutManager, lineSpacingAfterGlyphAt: number, withProposedLineFragmentRect: CGRect): number;
        layoutManagerParagraphSpacingBeforeGlyphAtIndexWithProposedLineFragmentRect?(_: NSLayoutManager, paragraphSpacingBeforeGlyphAt: number, withProposedLineFragmentRect: CGRect): number;
        layoutManagerParagraphSpacingAfterGlyphAtIndexWithProposedLineFragmentRect?(_: NSLayoutManager, paragraphSpacingAfterGlyphAt: number, withProposedLineFragmentRect: CGRect): number;
        layoutManagerShouldUseActionForControlCharacterAtIndex?(_: NSLayoutManager, shouldUse: NSLayoutManager.ControlCharacterAction, forControlCharacterAt: number): NSLayoutManager.ControlCharacterAction;
        layoutManagerShouldBreakLineByWordBeforeCharacterAtIndex?(_: NSLayoutManager, shouldBreakLineByWordBeforeCharacterAt: number): boolean;
        layoutManagerShouldBreakLineByHyphenatingBeforeCharacterAtIndex?(_: NSLayoutManager, shouldBreakLineByHyphenatingBeforeCharacterAt: number): boolean;
        layoutManagerBoundingBoxForControlGlyphAtIndexForTextContainerProposedLineFragmentGlyphPositionCharacterIndex?(_: NSLayoutManager, boundingBoxForControlGlyphAt: number, for_: NSTextContainer, proposedLineFragment: CGRect, glyphPosition: CGPoint, characterIndex: number): CGRect;
        layoutManagerShouldSetLineFragmentRectLineFragmentUsedRectBaselineOffsetInTextContainerForGlyphRange?(_: NSLayoutManager, shouldSetLineFragmentRect: NSRect, lineFragmentUsedRect: NSRect, baselineOffset: number, in_: NSTextContainer, forGlyphRange: NSRange): boolean;
        layoutManagerDidCompleteLayoutForTextContainerAtEnd?(_: NSLayoutManager, didCompleteLayoutFor?: NSTextContainer, atEnd?: boolean): void;
        layoutManagerTextContainerDidChangeGeometryFromSize?(_: NSLayoutManager, textContainer: NSTextContainer, didChangeGeometryFrom: CGSize): void;
        layoutManagerShouldGenerateGlyphsPropertiesCharacterIndexesFontForGlyphRange?(_: NSLayoutManager, shouldGenerateGlyphs: number, properties: NSLayoutManager.GlyphProperty, characterIndexes: number, font: NSFont, forGlyphRange: NSRange): number;
        layoutManagerShouldUseTemporaryAttributesForDrawingToScreenAtCharacterIndexEffectiveRange?(_: NSLayoutManager, shouldUseTemporaryAttributes: Map<string, any>, forDrawingToScreen: boolean, atCharacterIndex: number, effectiveRange?: NSRange): Map<string, any>;
        layoutManagerDidInvalidateLayout?(_: NSLayoutManager): void;
    }
    class NSLayoutXAxisAnchor extends NSLayoutAnchor<NSLayoutXAxisAnchor> {
        anchorWithOffsetToAnchor(to: NSLayoutXAxisAnchor): NSLayoutDimension;
    }
    class NSLayoutYAxisAnchor extends NSLayoutAnchor<NSLayoutYAxisAnchor> {
        anchorWithOffsetToAnchor(to: NSLayoutYAxisAnchor): NSLayoutDimension;
    }
    class NSLevelIndicator extends NSControl {
        criticalFillColor: NSColor;
        setCriticalFillColor(_: NSColor): any;
        criticalValue: number;
        setCriticalValue(_: number): any;
        drawsTieredCapacityLevels: boolean;
        setDrawsTieredCapacityLevels(_: boolean): any;
        isEditable: boolean;
        setEditable(_: boolean): any;
        fillColor: NSColor;
        setFillColor(_: NSColor): any;
        levelIndicatorStyle: NSLevelIndicator.Style;
        setLevelIndicatorStyle(_: NSLevelIndicator.Style): any;
        maxValue: number;
        setMaxValue(_: number): any;
        minValue: number;
        setMinValue(_: number): any;
        numberOfMajorTickMarks: number;
        setNumberOfMajorTickMarks(_: number): any;
        numberOfTickMarks: number;
        setNumberOfTickMarks(_: number): any;
        placeholderVisibility: NSLevelIndicator.PlaceholderVisibility;
        setPlaceholderVisibility(_: NSLevelIndicator.PlaceholderVisibility): any;
        ratingImage: NSImage;
        setRatingImage(_: NSImage): any;
        ratingPlaceholderImage: NSImage;
        setRatingPlaceholderImage(_: NSImage): any;
        tickMarkPosition: NSSlider.TickMarkPosition;
        setTickMarkPosition(_: NSSlider.TickMarkPosition): any;
        warningFillColor: NSColor;
        setWarningFillColor(_: NSColor): any;
        warningValue: number;
        setWarningValue(_: number): any;
        rectOfTickMarkAtIndex(at: number): CGRect;
        tickMarkValueAtIndex(at: number): number;
    }
    class NSLevelIndicatorCell extends NSActionCell {
        criticalValue: number;
        setCriticalValue(_: number): any;
        levelIndicatorStyle: NSLevelIndicator.Style;
        setLevelIndicatorStyle(_: NSLevelIndicator.Style): any;
        maxValue: number;
        setMaxValue(_: number): any;
        minValue: number;
        setMinValue(_: number): any;
        numberOfMajorTickMarks: number;
        setNumberOfMajorTickMarks(_: number): any;
        numberOfTickMarks: number;
        setNumberOfTickMarks(_: number): any;
        tickMarkPosition: NSSlider.TickMarkPosition;
        setTickMarkPosition(_: NSSlider.TickMarkPosition): any;
        warningValue: number;
        setWarningValue(_: number): any;
        static createWithLevelIndicatorStyle(levelIndicatorStyle: NSLevelIndicator.Style): NSLevelIndicatorCell;
        rectOfTickMarkAtIndex(at: number): CGRect;
        tickMarkValueAtIndex(at: number): number;
    }
    class NSMagnificationGestureRecognizer extends NSGestureRecognizer {
        magnification: number;
        setMagnification(_: number): any;
    }
    class NSMatrix extends NSControl {
        allowsEmptySelection: boolean;
        setAllowsEmptySelection(_: boolean): any;
        autorecalculatesCellSize: boolean;
        setAutorecalculatesCellSize(_: boolean): any;
        isAutoscroll: boolean;
        setAutoscroll(_: boolean): any;
        autosizesCells: boolean;
        setAutosizesCells(_: boolean): any;
        backgroundColor: NSColor;
        setBackgroundColor(_: NSColor): any;
        cellBackgroundColor: NSColor;
        setCellBackgroundColor(_: NSColor): any;
        cellClass: typeof NSObject;
        setCellClass(_: typeof NSObject): any;
        cellSize: CGSize;
        setCellSize(_: CGSize): any;
        cells: NSCell[];
        delegate: NSMatrixDelegate;
        setDelegate(_: NSMatrixDelegate): any;
        doubleAction: string;
        setDoubleAction(_: string): any;
        drawsBackground: boolean;
        setDrawsBackground(_: boolean): any;
        drawsCellBackground: boolean;
        setDrawsCellBackground(_: boolean): any;
        intercellSpacing: CGSize;
        setIntercellSpacing(_: CGSize): any;
        keyCell: NSCell;
        setKeyCell(_: NSCell): any;
        mode: NSMatrix.Mode;
        setMode(_: NSMatrix.Mode): any;
        mouseDownFlags: number;
        numberOfColumns: number;
        numberOfRows: number;
        prototype: NSCell;
        setPrototype(_: NSCell): any;
        selectedCells: NSCell[];
        selectedColumn: number;
        selectedRow: number;
        isSelectionByRect: boolean;
        setSelectionByRect(_: boolean): any;
        tabKeyTraversesCells: boolean;
        setTabKeyTraversesCells(_: boolean): any;
        addColumn(): void;
        addColumnWithCells(with_: NSCell[]): void;
        addRow(): void;
        addRowWithCells(with_: NSCell[]): void;
        cellAtRowColumn(atRow: number, column: number): NSCell;
        cellFrameAtRowColumn(atRow: number, column: number): CGRect;
        cellWithTag(withTag: number): NSCell;
        deselectAllCells(): void;
        deselectSelectedCell(): void;
        drawCellAtRowColumn(atRow: number, column: number): void;
        getNumberOfRowsColumns(_?: number, columns?: number): void;
        getRowColumnForPoint(_: number, column: number, for_: CGPoint): boolean;
        getRowColumnOfCell(_: number, column: number, of: NSCell): boolean;
        highlightCellAtRowColumn(_: boolean, atRow: number, column: number): void;
        static createWithFrameModeCellClassNumberOfRowsNumberOfColumns(frame: CGRect, mode: NSMatrix.Mode, cellClass?: typeof NSObject, numberOfRows?: number, numberOfColumns?: number): NSMatrix;
        static createWithFrameModePrototypeNumberOfRowsNumberOfColumns(frame: CGRect, mode: NSMatrix.Mode, prototype: NSCell, numberOfRows: number, numberOfColumns: number): NSMatrix;
        insertColumn(_: number): void;
        insertColumnWithCells(_: number, with_?: NSCell[]): void;
        insertRow(_: number): void;
        insertRowWithCells(_: number, with_?: NSCell[]): void;
        makeCellAtRowColumn(atRow: number, column: number): NSCell;
        putCellAtRowColumn(_: NSCell, atRow: number, column: number): void;
        removeColumn(_: number): void;
        removeRow(_: number): void;
        renewRowsColumns(_: number, columns: number): void;
        scrollCellToVisibleAtRowColumn(atRow: number, column: number): void;
        selectCellAtRowColumn(atRow: number, column: number): void;
        selectCellWithTag(withTag: number): boolean;
        selectText(_?: any): void;
        selectTextAtRowColumn(atRow: number, column: number): NSCell;
        sendAction(): boolean;
        sendActionToForAllCells(_: string, to: any, forAllCells: boolean): void;
        sendDoubleAction(): void;
        setScrollable(_: boolean): void;
        setSelectionFromToAnchorHighlight(_: number, to: number, anchor: number, highlight: boolean): void;
        setStateAtRowColumn(_: number, atRow: number, column: number): void;
        setToolTipForCell(_?: string, for_?: NSCell): void;
        setValidateSize(_: boolean): void;
        sizeToCells(): void;
        sortWithUsingContext(using?: (p1: any, p2: any, p3: any) => number, context?: any): void;
        sortUsingSelector(using: string): void;
        textDidBeginEditing(_: NSNotification): void;
        textDidChange(_: NSNotification): void;
        textDidEndEditing(_: NSNotification): void;
        textShouldBeginEditing(_: NSText): boolean;
        textShouldEndEditing(_: NSText): boolean;
        toolTipForCell(for_: NSCell): string;
    }
    type NSMatrixDelegate = NSControlTextEditingDelegate;
    class NSMediaLibraryBrowserController extends NSObject {
        frame: CGRect;
        setFrame(_: CGRect): any;
        mediaLibraries: NSMediaLibraryBrowserController.Library;
        setMediaLibraries(_: NSMediaLibraryBrowserController.Library): any;
        isVisible: boolean;
        setVisible(_: boolean): any;
        static sharedMediaLibraryBrowserController: NSMediaLibraryBrowserController;
        togglePanel(_?: any): void;
    }
    class NSMenu extends NSObject {
        static menuBarVisible(): boolean;
        static popUpContextMenuWithEventForView(_: NSMenu, with_: NSEvent, for_: NSView): void;
        static popUpContextMenuWithEventForViewWithFont(_: NSMenu, with_: NSEvent, for_: NSView, with_2?: NSFont): void;
        static setMenuBarVisible(_: boolean): void;
        allowsContextMenuPlugIns: boolean;
        setAllowsContextMenuPlugIns(_: boolean): any;
        autoenablesItems: boolean;
        setAutoenablesItems(_: boolean): any;
        delegate: NSMenuDelegate;
        setDelegate(_: NSMenuDelegate): any;
        font: NSFont;
        setFont(_: NSFont): any;
        highlightedItem: NSMenuItem;
        itemArray: NSMenuItem[];
        setItemArray(_: NSMenuItem[]): any;
        menuBarHeight: number;
        minimumWidth: number;
        setMinimumWidth(_: number): any;
        numberOfItems: number;
        propertiesToUpdate: NSMenu.Properties;
        showsStateColumn: boolean;
        setShowsStateColumn(_: boolean): any;
        size: CGSize;
        supermenu: NSMenu;
        setSupermenu(_: NSMenu): any;
        title: string;
        setTitle(_: string): any;
        userInterfaceLayoutDirection: NSUserInterfaceLayoutDirection;
        setUserInterfaceLayoutDirection(_: NSUserInterfaceLayoutDirection): any;
        addItem(_: NSMenuItem): void;
        addItemWithTitleActionKeyEquivalent(withTitle: string, action?: string, keyEquivalent?: string): NSMenuItem;
        cancelTracking(): void;
        cancelTrackingWithoutAnimation(): void;
        indexOfItem(of: NSMenuItem): number;
        indexOfItemWithRepresentedObject(withRepresentedObject?: any): number;
        indexOfItemWithSubmenu(withSubmenu?: NSMenu): number;
        indexOfItemWithTag(withTag: number): number;
        indexOfItemWithTargetAndAction(withTarget?: any, andAction?: string): number;
        indexOfItemWithTitle(withTitle: string): number;
        static createWithTitle(title: string): NSMenu;
        insertItemAtIndex(_: NSMenuItem, at: number): void;
        insertItemWithTitleActionKeyEquivalentAtIndex(withTitle: string, action?: string, keyEquivalent?: string, at?: number): NSMenuItem;
        itemAtIndex(at: number): NSMenuItem;
        itemChanged(_: NSMenuItem): void;
        itemWithTag(withTag: number): NSMenuItem;
        itemWithTitle(withTitle: string): NSMenuItem;
        performActionForItemAtIndex(at: number): void;
        performKeyEquivalent(with_: NSEvent): boolean;
        popUpMenuPositioningItemAtLocationInView(positioning?: NSMenuItem, at?: CGPoint, in_?: NSView): boolean;
        removeAllItems(): void;
        removeItem(_: NSMenuItem): void;
        removeItemAtIndex(at: number): void;
        setSubmenuForItem(_?: NSMenu, for_?: NSMenuItem): void;
        submenuAction(_?: any): void;
        update(): void;
    }
    interface NSMenuDelegate extends NSObject {
        confinementRectForMenuOnScreen?(for_: NSMenu, on?: NSScreen): CGRect;
        menuUpdateItemAtIndexShouldCancel?(_: NSMenu, update: NSMenuItem, at: number, shouldCancel: boolean): boolean;
        menuWillHighlightItem?(_: NSMenu, willHighlight?: NSMenuItem): void;
        menuDidClose?(_: NSMenu): void;
        menuHasKeyEquivalentForEventTargetAction?(_: NSMenu, for_: NSEvent, target?: any, action?: string): boolean;
        menuNeedsUpdate?(_: NSMenu): void;
        menuWillOpen?(_: NSMenu): void;
        numberOfItemsInMenu?(in_: NSMenu): number;
    }
    class NSMenuItem extends NSObject {
        static separatorItem(): NSMenuItem;
        action: string;
        setAction(_: string): any;
        allowsKeyEquivalentWhenHidden: boolean;
        setAllowsKeyEquivalentWhenHidden(_: boolean): any;
        isAlternate: boolean;
        setAlternate(_: boolean): any;
        attributedTitle: NSAttributedString;
        setAttributedTitle(_: NSAttributedString): any;
        isEnabled: boolean;
        setEnabled(_: boolean): any;
        hasSubmenu: boolean;
        isHidden: boolean;
        setHidden(_: boolean): any;
        isHiddenOrHasHiddenAncestor: boolean;
        isHighlighted: boolean;
        image: NSImage;
        setImage(_: NSImage): any;
        indentationLevel: number;
        setIndentationLevel(_: number): any;
        keyEquivalent: string;
        setKeyEquivalent(_: string): any;
        keyEquivalentModifierMask: NSEvent.ModifierFlags;
        setKeyEquivalentModifierMask(_: NSEvent.ModifierFlags): any;
        menu: NSMenu;
        setMenu(_: NSMenu): any;
        mixedStateImage: NSImage;
        setMixedStateImage(_: NSImage): any;
        offStateImage: NSImage;
        setOffStateImage(_: NSImage): any;
        onStateImage: NSImage;
        setOnStateImage(_: NSImage): any;
        parentItem: NSMenuItem;
        representedObject: any;
        setRepresentedObject(_: any): any;
        isSeparatorItem: boolean;
        state: number;
        setState(_: number): any;
        submenu: NSMenu;
        setSubmenu(_: NSMenu): any;
        tag: number;
        setTag(_: number): any;
        target: any;
        setTarget(_: any): any;
        title: string;
        setTitle(_: string): any;
        toolTip: string;
        setToolTip(_: string): any;
        userKeyEquivalent: string;
        view: NSView;
        setView(_: NSView): any;
        static usesUserKeyEquivalents: boolean;
        setUsesUserKeyEquivalents(_: boolean): any;
        static createWithTitleActionKeyEquivalent(title: string, action?: string, keyEquivalent?: string): NSMenuItem;
    }
    class NSMenuItemCell extends NSButtonCell {
        imageWidth: number;
        keyEquivalentWidth: number;
        menuItem: NSMenuItem;
        setMenuItem(_: NSMenuItem): any;
        needsDisplay: boolean;
        setNeedsDisplay(_: boolean): any;
        needsSizing: boolean;
        setNeedsSizing(_: boolean): any;
        stateImageWidth: number;
        titleWidth: number;
        calcSize(): void;
        drawBorderAndBackgroundWithFrameInView(withFrame: CGRect, in_: NSView): void;
        drawKeyEquivalentWithFrameInView(withFrame: CGRect, in_: NSView): void;
        drawSeparatorItemWithFrameInView(withFrame: CGRect, in_: NSView): void;
        drawStateImageWithFrameInView(withFrame: CGRect, in_: NSView): void;
        keyEquivalentRectForBounds(forBounds: CGRect): CGRect;
        stateImageRectForBounds(forBounds: CGRect): CGRect;
    }
    interface NSMenuItemValidation extends NSObject {
        validateMenuItem(_: NSMenuItem): boolean;
    }
    class NSMenuToolbarItem extends NSToolbarItem {
        menu: NSMenu;
        setMenu(_: NSMenu): any;
        showsIndicator: boolean;
        setShowsIndicator(_: boolean): any;
    }
    class NSMutableFontCollection extends NSFontCollection {
        static fontCollectionWithAllAvailableDescriptors: NSMutableFontCollection;
        addQueryForDescriptors(for_: NSFontDescriptor[]): void;
        removeQueryForDescriptors(for_: NSFontDescriptor[]): void;
    }
    class NSMutableParagraphStyle extends NSParagraphStyle {
        addTabStop(_: NSTextTab): void;
        removeTabStop(_: NSTextTab): void;
        setParagraphStyle(_: NSParagraphStyle): void;
    }
    class NSNib extends NSObject {
        static createWithNibDataBundle(nibData: NSData, bundle?: Bundle): NSNib;
        static createWithNibNamedBundle(nibNamed: string, bundle?: Bundle): NSNib;
        instantiateWithOwnerTopLevelObjects(withOwner?: any, topLevelObjects?: any[]): boolean;
    }
    class NSObjectController extends NSController {
        automaticallyPreparesContent: boolean;
        setAutomaticallyPreparesContent(_: boolean): any;
        canAdd: boolean;
        canRemove: boolean;
        content: any;
        setContent(_: any): any;
        isEditable: boolean;
        setEditable(_: boolean): any;
        entityName: string;
        setEntityName(_: string): any;
        fetchPredicate: NSPredicate;
        setFetchPredicate(_: NSPredicate): any;
        managedObjectContext: NSManagedObjectContext;
        setManagedObjectContext(_: NSManagedObjectContext): any;
        objectClass: typeof NSObject;
        setObjectClass(_: typeof NSObject): any;
        selectedObjects: any[];
        selection: any;
        usesLazyFetching: boolean;
        setUsesLazyFetching(_: boolean): any;
        add(_?: any): void;
        addObject(_: any): void;
        defaultFetchRequest(): NSFetchRequest<any>;
        fetch(_?: any): void;
        fetchWithRequestMergeError(merge?: NSFetchRequest<any>, error?: boolean): boolean;
        static createWithContent(content?: any): NSObjectController;
        newObject(): any;
        prepareContent(): void;
        remove(_?: any): void;
        removeObject(_: any): void;
        validateUserInterfaceItem(_: NSValidatedUserInterfaceItem): boolean;
    }
    class NSOpenPanel extends NSSavePanel {
        URLs: NSURL[];
        isAccessoryViewDisclosed: boolean;
        setAccessoryViewDisclosed(_: boolean): any;
        allowsMultipleSelection: boolean;
        setAllowsMultipleSelection(_: boolean): any;
        canChooseDirectories: boolean;
        setCanChooseDirectories(_: boolean): any;
        canChooseFiles: boolean;
        setCanChooseFiles(_: boolean): any;
        canDownloadUbiquitousContents: boolean;
        setCanDownloadUbiquitousContents(_: boolean): any;
        canResolveUbiquitousConflicts: boolean;
        setCanResolveUbiquitousConflicts(_: boolean): any;
        resolvesAliases: boolean;
        setResolvesAliases(_: boolean): any;
    }
    interface NSOpenSavePanelDelegate extends NSObject {
        panelShouldEnableURL?(_: any, shouldEnable: NSURL): boolean;
        panelDidChangeToDirectoryURL?(_: any, didChangeToDirectoryURL?: NSURL): void;
        panelUserEnteredFilenameConfirmed?(_: any, userEnteredFilename: string, confirmed: boolean): string;
        panelValidateURLError?(validateURL: any, error: NSURL): boolean;
        panelWillExpand?(_: any, willExpand: boolean): void;
        panelSelectionDidChange?(_?: any): void;
    }
    class NSOutlineView extends NSTableView {
        autoresizesOutlineColumn: boolean;
        setAutoresizesOutlineColumn(_: boolean): any;
        autosaveExpandedItems: boolean;
        setAutosaveExpandedItems(_: boolean): any;
        indentationMarkerFollowsCell: boolean;
        setIndentationMarkerFollowsCell(_: boolean): any;
        indentationPerLevel: number;
        setIndentationPerLevel(_: number): any;
        outlineTableColumn: NSTableColumn;
        setOutlineTableColumn(_: NSTableColumn): any;
        stronglyReferencesItems: boolean;
        setStronglyReferencesItems(_: boolean): any;
        childOfItem(_: number, ofItem?: any): any;
        childIndexForItem(forItem: any): number;
        collapseItem(_?: any): void;
        collapseItemCollapseChildren(_?: any, collapseChildren?: boolean): void;
        expandItem(_?: any): void;
        expandItemExpandChildren(_?: any, expandChildren?: boolean): void;
        frameOfOutlineCellAtRow(atRow: number): CGRect;
        insertItemsAtIndexesInParentWithAnimation(at: NSIndexSet, inParent?: any, withAnimation?: NSTableView.AnimationOptions): void;
        isExpandable(_?: any): boolean;
        isItemExpanded(_?: any): boolean;
        itemAtRow(atRow: number): any;
        levelForItem(forItem?: any): number;
        levelForRow(forRow: number): number;
        moveItemAtIndexInParentToIndexInParent(at: number, inParent?: any, to?: number, inParent2?: any): void;
        numberOfChildrenOfItem(ofItem?: any): number;
        parentForItem(forItem?: any): any;
        reloadItem(_?: any): void;
        reloadItemReloadChildren(_?: any, reloadChildren?: boolean): void;
        removeItemsAtIndexesInParentWithAnimation(at: NSIndexSet, inParent?: any, withAnimation?: NSTableView.AnimationOptions): void;
        rowForItem(forItem?: any): number;
        setDropItemDropChildIndex(_?: any, dropChildIndex?: number): void;
        shouldCollapseAutoExpandedItemsForDeposited(forDeposited: boolean): boolean;
    }
    interface NSOutlineViewDataSource extends NSObject {
        outlineViewObjectValueForTableColumnByItem?(_: NSOutlineView, objectValueFor?: NSTableColumn, byItem?: any): any;
        outlineViewSetObjectValueForTableColumnByItem?(_: NSOutlineView, setObjectValue?: any, for_?: NSTableColumn, byItem?: any): void;
        outlineViewDraggingSessionWillBeginAtPointForItems?(_: NSOutlineView, draggingSession: NSDraggingSession, willBeginAt: CGPoint, forItems: any[]): void;
        outlineViewDraggingSessionEndedAtPointOperation?(_: NSOutlineView, draggingSession: NSDraggingSession, endedAt: CGPoint, operation: NSDragOperation): void;
        outlineViewWriteItemsToPasteboard?(_: NSOutlineView, writeItems: any[], to: NSPasteboard): boolean;
        outlineViewAcceptDropItemChildIndex?(_: NSOutlineView, acceptDrop: NSDraggingInfo, item?: any, childIndex?: number): boolean;
        outlineViewChildOfItem?(_: NSOutlineView, child: number, ofItem?: any): any;
        outlineViewIsItemExpandable?(_: NSOutlineView, isItemExpandable: any): boolean;
        outlineViewItemForPersistentObject?(_: NSOutlineView, itemForPersistentObject: any): any;
        outlineViewNumberOfChildrenOfItem?(_: NSOutlineView, numberOfChildrenOfItem?: any): number;
        outlineViewPasteboardWriterForItem?(_: NSOutlineView, pasteboardWriterForItem: any): NSPasteboardWriting;
        outlineViewPersistentObjectForItem?(_: NSOutlineView, persistentObjectForItem?: any): any;
        outlineViewSortDescriptorsDidChange?(_: NSOutlineView, sortDescriptorsDidChange: NSSortDescriptor[]): void;
        outlineViewUpdateDraggingItemsForDrag?(_: NSOutlineView, updateDraggingItemsForDrag: NSDraggingInfo): void;
        outlineViewValidateDropProposedItemProposedChildIndex?(_: NSOutlineView, validateDrop: NSDraggingInfo, proposedItem?: any, proposedChildIndex?: number): NSDragOperation;
    }
    interface NSOutlineViewDelegate extends NSControlTextEditingDelegate {
        outlineViewViewForTableColumnItem?(_: NSOutlineView, viewFor?: NSTableColumn, item?: any): NSView;
        outlineViewWillDisplayOutlineCellForTableColumnItem?(_: NSOutlineView, willDisplayOutlineCell: any, for_?: NSTableColumn, item?: any): void;
        outlineViewDidAddRowViewForRow?(_: NSOutlineView, didAdd: NSTableRowView, forRow: number): void;
        outlineViewDidRemoveRowViewForRow?(_: NSOutlineView, didRemove: NSTableRowView, forRow: number): void;
        outlineViewWillDisplayCellForTableColumnItem?(_: NSOutlineView, willDisplayCell: any, for_?: NSTableColumn, item?: any): void;
        outlineViewShouldEditTableColumnItem?(_: NSOutlineView, shouldEdit?: NSTableColumn, item?: any): boolean;
        outlineViewDataCellForTableColumnItem?(_: NSOutlineView, dataCellFor?: NSTableColumn, item?: any): NSCell;
        outlineViewShouldTrackCellForTableColumnItem?(_: NSOutlineView, shouldTrackCell: NSCell, for_?: NSTableColumn, item?: any): boolean;
        outlineViewShouldShowCellExpansionForTableColumnItem?(_: NSOutlineView, shouldShowCellExpansionFor?: NSTableColumn, item?: any): boolean;
        outlineViewShouldSelectTableColumn?(_: NSOutlineView, shouldSelect?: NSTableColumn): boolean;
        outlineViewMouseDownInHeaderOfTableColumn?(_: NSOutlineView, mouseDownInHeaderOf: NSTableColumn): void;
        outlineViewDidClickTableColumn?(_: NSOutlineView, didClick: NSTableColumn): void;
        outlineViewDidDragTableColumn?(_: NSOutlineView, didDrag: NSTableColumn): void;
        outlineViewToolTipForCellRectTableColumnItemMouseLocation?(_: NSOutlineView, toolTipFor: NSCell, rect: NSRect, tableColumn?: NSTableColumn, item?: any, mouseLocation?: CGPoint): string;
        outlineViewShouldTypeSelectForEventWithCurrentSearchString?(_: NSOutlineView, shouldTypeSelectFor: NSEvent, withCurrentSearch?: string): boolean;
        outlineViewTypeSelectStringForTableColumnItem?(_: NSOutlineView, typeSelectStringFor?: NSTableColumn, item?: any): string;
        outlineViewNextTypeSelectMatchFromItemToItemForString?(_: NSOutlineView, nextTypeSelectMatchFromItem: any, toItem: any, for_: string): any;
        outlineViewHeightOfRowByItem?(_: NSOutlineView, heightOfRowByItem: any): number;
        outlineViewIsGroupItem?(_: NSOutlineView, isGroupItem: any): boolean;
        outlineViewRowViewForItem?(_: NSOutlineView, rowViewForItem: any): NSTableRowView;
        outlineViewSelectionIndexesForProposedSelection?(_: NSOutlineView, selectionIndexesForProposedSelection: NSIndexSet): NSIndexSet;
        outlineViewShouldCollapseItem?(_: NSOutlineView, shouldCollapseItem: any): boolean;
        outlineViewShouldExpandItem?(_: NSOutlineView, shouldExpandItem: any): boolean;
        outlineViewShouldReorderColumnToColumn?(_: NSOutlineView, shouldReorderColumn: number, toColumn: number): boolean;
        outlineViewShouldSelectItem?(_: NSOutlineView, shouldSelectItem: any): boolean;
        outlineViewShouldShowOutlineCellForItem?(_: NSOutlineView, shouldShowOutlineCellForItem: any): boolean;
        outlineViewSizeToFitWidthOfColumn?(_: NSOutlineView, sizeToFitWidthOfColumn: number): number;
        outlineViewColumnDidMove?(_: NSNotification): void;
        outlineViewColumnDidResize?(_: NSNotification): void;
        outlineViewItemDidCollapse?(_: NSNotification): void;
        outlineViewItemDidExpand?(_: NSNotification): void;
        outlineViewItemWillCollapse?(_: NSNotification): void;
        outlineViewItemWillExpand?(_: NSNotification): void;
        outlineViewSelectionDidChange?(_: NSNotification): void;
        outlineViewSelectionIsChanging?(_: NSNotification): void;
        selectionShouldChangeInOutlineView?(in_: NSOutlineView): boolean;
    }
    class NSPDFImageRep extends NSImageRep {
        PDFRepresentation: NSData;
        bounds: CGRect;
        currentPage: number;
        setCurrentPage(_: number): any;
        pageCount: number;
        static createWithData(data: NSData): NSPDFImageRep;
    }
    class NSPDFInfo extends NSObject {
        URL: NSURL;
        setURL(_: NSURL): any;
        attributes: NSMutableDictionary<string, any>;
        isFileExtensionHidden: boolean;
        setFileExtensionHidden(_: boolean): any;
        orientation: NSPrintInfo.PaperOrientation;
        setOrientation(_: NSPrintInfo.PaperOrientation): any;
        paperSize: CGSize;
        setPaperSize(_: CGSize): any;
        tagNames: string[];
        setTagNames(_: string[]): any;
    }
    class NSPDFPanel extends NSObject {
        accessoryController: NSViewController;
        setAccessoryController(_: NSViewController): any;
        defaultFileName: string;
        setDefaultFileName(_: string): any;
        options: NSPDFPanel.Options;
        setOptions(_: NSPDFPanel.Options): any;
        beginSheetWithWithModalForCompletionHandler(with_: NSPDFInfo, modalFor?: NSWindow, completionHandler?: (p1: number) => void): void;
    }
    class NSPICTImageRep extends NSImageRep {
        PICTRepresentation: NSData;
        boundingBox: CGRect;
        static createWithData(data: NSData): NSPICTImageRep;
    }
    class NSPageController extends NSViewController {
        arrangedObjects: any[];
        setArrangedObjects(_: any[]): any;
        delegate: NSPageControllerDelegate;
        setDelegate(_: NSPageControllerDelegate): any;
        selectedIndex: number;
        setSelectedIndex(_: number): any;
        selectedViewController: NSViewController;
        transitionStyle: NSPageController.TransitionStyle;
        setTransitionStyle(_: NSPageController.TransitionStyle): any;
        completeTransition(): void;
        navigateBack(_?: any): void;
        navigateForward(_?: any): void;
        navigateForwardToObject(to: any): void;
        takeSelectedIndexFrom(_?: any): void;
    }
    interface NSPageControllerDelegate extends NSObject {
        pageControllerIdentifierForObject?(_: NSPageController, identifierFor: any): string;
        pageControllerFrameForObject?(_: NSPageController, frameFor?: any): CGRect;
        pageControllerPrepareViewControllerWithObject?(_: NSPageController, prepare: NSViewController, with_?: any): void;
        pageControllerDidTransitionToObject?(_: NSPageController, didTransitionTo: any): void;
        pageControllerViewControllerForIdentifier?(_: NSPageController, viewControllerForIdentifier: string): NSViewController;
        pageControllerDidEndLiveTransition?(_: NSPageController): void;
        pageControllerWillStartLiveTransition?(_: NSPageController): void;
    }
    class NSPageLayout extends NSObject {
        accessoryControllers: NSViewController[];
        printInfo: NSPrintInfo;
        addAccessoryController(_: NSViewController): void;
        beginSheetWithPrintInfoModalForWindowDelegateDidEndSelectorContextInfo(with_: NSPrintInfo, modalFor: NSWindow, delegate?: any, didEnd?: string, contextInfo?: any): void;
        removeAccessoryController(_: NSViewController): void;
        runModal(): number;
        runModalWithPrintInfo(with_: NSPrintInfo): number;
    }
    class NSPanGestureRecognizer extends NSGestureRecognizer {
        buttonMask: number;
        setButtonMask(_: number): any;
        numberOfTouchesRequired: number;
        setNumberOfTouchesRequired(_: number): any;
        setTranslationInView(_: CGPoint, in_?: NSView): void;
        translationInView(in_?: NSView): CGPoint;
        velocityInView(in_?: NSView): CGPoint;
    }
    class NSPanel extends NSWindow {
        becomesKeyOnlyIfNeeded: boolean;
        setBecomesKeyOnlyIfNeeded(_: boolean): any;
    }
    class NSParagraphStyle extends NSObject {
        static defaultWritingDirectionForLanguage(forLanguage?: string): NSWritingDirection;
        alignment: NSTextAlignment;
        allowsDefaultTighteningForTruncation: boolean;
        baseWritingDirection: NSWritingDirection;
        defaultTabInterval: number;
        firstLineHeadIndent: number;
        headIndent: number;
        headerLevel: number;
        hyphenationFactor: number;
        lineBreakMode: NSLineBreakMode;
        lineHeightMultiple: number;
        lineSpacing: number;
        maximumLineHeight: number;
        minimumLineHeight: number;
        paragraphSpacing: number;
        paragraphSpacingBefore: number;
        tabStops: NSTextTab[];
        tailIndent: number;
        textBlocks: NSTextBlock[];
        textLists: NSTextList[];
        tighteningFactorForTruncation: number;
        static defaultParagraphStyle: NSParagraphStyle;
    }
    class NSPasteboard extends NSObject {
        static pasteboardWithUniqueName(): NSPasteboard;
        static typesFilterableTo(filterableTo: string): string[];
        changeCount: number;
        name: string;
        pasteboardItems: NSPasteboardItem[];
        types: string[];
        static generalPasteboard: NSPasteboard;
        addTypesOwner(_: string[], owner?: any): number;
        availableTypeFromArray(from: string[]): string;
        canReadItemWithDataConformingToTypes(withDataConformingToTypes: string[]): boolean;
        canReadObjectForClassesOptions(forClasses: typeof NSObject[], options?: Map<string, any>): boolean;
        clearContents(): number;
        dataForType(forType: string): NSData;
        declareTypesOwner(_: string[], owner?: any): number;
        indexOfPasteboardItem(of: NSPasteboardItem): number;
        prepareForNewContentsWithOptions(with_: NSPasteboard.ContentsOptions): number;
        propertyListForType(forType: string): any;
        readFileContentsTypeToFile(_?: string, toFile?: string): string;
        readFileWrapper(): FileWrapper;
        readObjectsForClassesOptions(forClasses: typeof NSObject[], options?: Map<string, any>): any[];
        releaseGlobally(): void;
        setDataForType(_?: NSData, forType?: string): boolean;
        setPropertyListForType(_: any, forType: string): boolean;
        setStringForType(_: string, forType: string): boolean;
        stringForType(forType: string): string;
        writeFileContents(_: string): boolean;
        writeFileWrapper(_: FileWrapper): boolean;
        writeObjects(_: NSPasteboardWriting[]): boolean;
    }
    class NSPasteboardItem extends NSObject {
        types: string[];
        availableTypeFromArray(from: string[]): string;
        dataForType(forType: string): NSData;
        propertyListForType(forType: string): any;
        setDataForType(_: NSData, forType: string): boolean;
        setDataProviderForTypes(_: NSPasteboardItemDataProvider, forTypes: string[]): boolean;
        setPropertyListForType(_: any, forType: string): boolean;
        setStringForType(_: string, forType: string): boolean;
        stringForType(forType: string): string;
    }
    interface NSPasteboardItemDataProvider extends NSObject {
        pasteboardItemProvideDataForType(_?: NSPasteboard, item?: NSPasteboardItem, provideDataForType?: string): void;
        pasteboardFinishedWithDataProvider?(_: NSPasteboard): void;
    }
    type NSPasteboardReading = NSObject;
    interface NSPasteboardTypeOwner extends NSObject {
        pasteboardProvideDataForType(_: NSPasteboard, provideDataForType: string): void;
        pasteboardChangedOwner?(_: NSPasteboard): void;
    }
    interface NSPasteboardWriting extends NSObject {
        pasteboardPropertyListForType(forType: string): any;
        writableTypesForPasteboard(for_: NSPasteboard): string[];
        writingOptionsForTypePasteboard?(forType: string, pasteboard: NSPasteboard): NSPasteboard.WritingOptions;
    }
    class NSPathCell extends NSActionCell {
        URL: NSURL;
        setURL(_: NSURL): any;
        allowedTypes: string[];
        setAllowedTypes(_: string[]): any;
        backgroundColor: NSColor;
        setBackgroundColor(_: NSColor): any;
        clickedPathComponentCell: NSPathComponentCell;
        delegate: NSPathCellDelegate;
        setDelegate(_: NSPathCellDelegate): any;
        doubleAction: string;
        setDoubleAction(_: string): any;
        pathComponentCells: NSPathComponentCell[];
        setPathComponentCells(_: NSPathComponentCell[]): any;
        pathStyle: NSPathControl.Style;
        setPathStyle(_: NSPathControl.Style): any;
        placeholderAttributedString: NSAttributedString;
        setPlaceholderAttributedString(_: NSAttributedString): any;
        placeholderString: string;
        setPlaceholderString(_: string): any;
        static pathComponentCellClass: typeof NSObject;
        mouseEnteredWithFrameInView(with_: NSEvent, frame: CGRect, in_: NSView): void;
        mouseExitedWithFrameInView(with_: NSEvent, frame: CGRect, in_: NSView): void;
        pathComponentCellAtPointWithFrameInView(at: CGPoint, withFrame: CGRect, in_: NSView): NSPathComponentCell;
        rectOfPathComponentCellWithFrameInView(of: NSPathComponentCell, withFrame: CGRect, in_: NSView): CGRect;
        setObjectValue(_?: any): void;
    }
    interface NSPathCellDelegate extends NSObject {
        pathCellWillDisplayOpenPanel?(_: NSPathCell, willDisplay: NSOpenPanel): void;
        pathCellWillPopUpMenu?(_: NSPathCell, willPopUp: NSMenu): void;
    }
    class NSPathComponentCell extends NSTextFieldCell {
        URL: NSURL;
        setURL(_: NSURL): any;
    }
    class NSPathControl extends NSControl {
        URL: NSURL;
        setURL(_: NSURL): any;
        allowedTypes: string[];
        setAllowedTypes(_: string[]): any;
        backgroundColor: NSColor;
        setBackgroundColor(_: NSColor): any;
        clickedPathItem: NSPathControlItem;
        delegate: NSPathControlDelegate;
        setDelegate(_: NSPathControlDelegate): any;
        doubleAction: string;
        setDoubleAction(_: string): any;
        isEditable: boolean;
        setEditable(_: boolean): any;
        pathItems: NSPathControlItem[];
        setPathItems(_: NSPathControlItem[]): any;
        pathStyle: NSPathControl.Style;
        setPathStyle(_: NSPathControl.Style): any;
        placeholderAttributedString: NSAttributedString;
        setPlaceholderAttributedString(_: NSAttributedString): any;
        placeholderString: string;
        setPlaceholderString(_: string): any;
        setDraggingSourceOperationMaskForLocal(_: NSDragOperation, forLocal: boolean): void;
    }
    interface NSPathControlDelegate extends NSObject {
        pathControlShouldDragItemWithPasteboard?(_: NSPathControl, shouldDrag: NSPathControlItem, with_: NSPasteboard): boolean;
        pathControlShouldDragPathComponentCellWithPasteboard?(_: NSPathControl, shouldDrag: NSPathComponentCell, with_: NSPasteboard): boolean;
        pathControlWillDisplayOpenPanel?(_: NSPathControl, willDisplay: NSOpenPanel): void;
        pathControlWillPopUpMenu?(_: NSPathControl, willPopUp: NSMenu): void;
        pathControlAcceptDrop?(_: NSPathControl, acceptDrop: NSDraggingInfo): boolean;
        pathControlValidateDrop?(_: NSPathControl, validateDrop: NSDraggingInfo): NSDragOperation;
    }
    class NSPathControlItem extends NSObject {
        URL: NSURL;
        attributedTitle: NSAttributedString;
        setAttributedTitle(_: NSAttributedString): any;
        image: NSImage;
        setImage(_: NSImage): any;
        title: string;
        setTitle(_: string): any;
    }
    class NSPersistentDocument extends NSDocument {
        managedObjectContext: NSManagedObjectContext;
        setManagedObjectContext(_: NSManagedObjectContext): any;
        managedObjectModel: NSManagedObjectModel;
        configurePersistentStoreCoordinatorForURLOfTypeModelConfigurationStoreOptionsError(ofType: NSURL, modelConfiguration: string, storeOptions?: string, error?: Map<string, any>): boolean;
        persistentStoreTypeForFileType(forFileType: string): string;
    }
    class NSPickerTouchBarItem extends NSTouchBarItem {
        action: string;
        setAction(_: string): any;
        collapsedRepresentationImage: NSImage;
        setCollapsedRepresentationImage(_: NSImage): any;
        collapsedRepresentationLabel: string;
        setCollapsedRepresentationLabel(_: string): any;
        controlRepresentation: NSPickerTouchBarItem.ControlRepresentation;
        setControlRepresentation(_: NSPickerTouchBarItem.ControlRepresentation): any;
        isEnabled: boolean;
        setEnabled(_: boolean): any;
        numberOfOptions: number;
        setNumberOfOptions(_: number): any;
        selectedIndex: number;
        setSelectedIndex(_: number): any;
        selectionColor: NSColor;
        setSelectionColor(_: NSColor): any;
        selectionMode: NSPickerTouchBarItem.SelectionMode;
        setSelectionMode(_: NSPickerTouchBarItem.SelectionMode): any;
        target: any;
        setTarget(_: any): any;
        imageAtIndex(at: number): NSImage;
        isEnabledAtIndex(at: number): boolean;
        labelAtIndex(at: number): string;
        setEnabledAtIndex(_: boolean, at: number): void;
        setImageAtIndex(_?: NSImage, at?: number): void;
        setLabelAtIndex(_: string, at: number): void;
    }
    class NSPopUpButton extends NSButton {
        autoenablesItems: boolean;
        setAutoenablesItems(_: boolean): any;
        indexOfSelectedItem: number;
        itemArray: NSMenuItem[];
        itemTitles: string[];
        lastItem: NSMenuItem;
        numberOfItems: number;
        preferredEdge: NSRectEdge;
        setPreferredEdge(_: NSRectEdge): any;
        pullsDown: boolean;
        setPullsDown(_: boolean): any;
        selectedItem: NSMenuItem;
        titleOfSelectedItem: string;
        addItemWithTitle(withTitle: string): void;
        addItemsWithTitles(withTitles: string[]): void;
        indexOfItem(of: NSMenuItem): number;
        indexOfItemWithRepresentedObject(withRepresentedObject?: any): number;
        indexOfItemWithTag(withTag: number): number;
        indexOfItemWithTargetAndAction(withTarget?: any, andAction?: string): number;
        indexOfItemWithTitle(withTitle: string): number;
        static createWithFramePullsDown(frame: CGRect, pullsDown: boolean): NSPopUpButton;
        insertItemWithTitleAtIndex(withTitle: string, at: number): void;
        itemAtIndex(at: number): NSMenuItem;
        itemTitleAtIndex(at: number): string;
        itemWithTitle(withTitle: string): NSMenuItem;
        removeAllItems(): void;
        removeItemAtIndex(at: number): void;
        removeItemWithTitle(withTitle: string): void;
        selectItem(_?: NSMenuItem): void;
        selectItemAtIndex(at: number): void;
        selectItemWithTag(withTag: number): boolean;
        selectItemWithTitle(withTitle: string): void;
        setTitle(_: string): void;
        synchronizeTitleAndSelectedItem(): void;
    }
    class NSPopUpButtonCell extends NSMenuItemCell {
        altersStateOfSelectedItem: boolean;
        setAltersStateOfSelectedItem(_: boolean): any;
        arrowPosition: NSPopUpButton.ArrowPosition;
        setArrowPosition(_: NSPopUpButton.ArrowPosition): any;
        autoenablesItems: boolean;
        setAutoenablesItems(_: boolean): any;
        indexOfSelectedItem: number;
        itemArray: NSMenuItem[];
        itemTitles: string[];
        lastItem: NSMenuItem;
        numberOfItems: number;
        preferredEdge: NSRectEdge;
        setPreferredEdge(_: NSRectEdge): any;
        pullsDown: boolean;
        setPullsDown(_: boolean): any;
        selectedItem: NSMenuItem;
        titleOfSelectedItem: string;
        usesItemFromMenu: boolean;
        setUsesItemFromMenu(_: boolean): any;
        addItemWithTitle(withTitle: string): void;
        addItemsWithTitles(withTitles: string[]): void;
        attachPopUpWithFrameInView(withFrame: CGRect, in_: NSView): void;
        dismissPopUp(): void;
        indexOfItem(of: NSMenuItem): number;
        indexOfItemWithRepresentedObject(withRepresentedObject?: any): number;
        indexOfItemWithTag(withTag: number): number;
        indexOfItemWithTargetAndAction(withTarget?: any, andAction?: string): number;
        indexOfItemWithTitle(withTitle: string): number;
        static createWithTextCellPullsDown(textCell: string, pullsDown: boolean): NSPopUpButtonCell;
        insertItemWithTitleAtIndex(withTitle: string, at: number): void;
        itemAtIndex(at: number): NSMenuItem;
        itemTitleAtIndex(at: number): string;
        itemWithTitle(withTitle: string): NSMenuItem;
        performClickWithFrameInView(withFrame: CGRect, in_: NSView): void;
        removeAllItems(): void;
        removeItemAtIndex(at: number): void;
        removeItemWithTitle(withTitle: string): void;
        selectItem(_?: NSMenuItem): void;
        selectItemAtIndex(at: number): void;
        selectItemWithTag(withTag: number): boolean;
        selectItemWithTitle(withTitle: string): void;
        setTitle(_?: string): void;
        synchronizeTitleAndSelectedItem(): void;
    }
    class NSPopover extends NSResponder {
        animates: boolean;
        setAnimates(_: boolean): any;
        behavior: NSPopover.Behavior;
        setBehavior(_: NSPopover.Behavior): any;
        contentSize: CGSize;
        setContentSize(_: CGSize): any;
        contentViewController: NSViewController;
        setContentViewController(_: NSViewController): any;
        delegate: NSPopoverDelegate;
        setDelegate(_: NSPopoverDelegate): any;
        isDetached: boolean;
        positioningRect: CGRect;
        setPositioningRect(_: CGRect): any;
        isShown: boolean;
        close(): void;
        performClose(_?: any): void;
        showRelativeToRectOfViewPreferredEdge(relativeTo: CGRect, of: NSView, preferredEdge: NSRectEdge): void;
    }
    interface NSPopoverDelegate extends NSObject {
        detachableWindowForPopover?(for_: NSPopover): NSWindow;
        popoverDidClose?(_: NSNotification): void;
        popoverDidDetach?(_: NSPopover): void;
        popoverDidShow?(_: NSNotification): void;
        popoverShouldClose?(_: NSPopover): boolean;
        popoverShouldDetach?(_: NSPopover): boolean;
        popoverWillClose?(_: NSNotification): void;
        popoverWillShow?(_: NSNotification): void;
    }
    class NSPopoverTouchBarItem extends NSTouchBarItem {
        collapsedRepresentation: NSView;
        setCollapsedRepresentation(_: NSView): any;
        collapsedRepresentationImage: NSImage;
        setCollapsedRepresentationImage(_: NSImage): any;
        collapsedRepresentationLabel: string;
        setCollapsedRepresentationLabel(_: string): any;
        popoverTouchBar: NSTouchBar;
        setPopoverTouchBar(_: NSTouchBar): any;
        pressAndHoldTouchBar: NSTouchBar;
        setPressAndHoldTouchBar(_: NSTouchBar): any;
        showsCloseButton: boolean;
        setShowsCloseButton(_: boolean): any;
        dismissPopover(_?: any): void;
        makeStandardActivatePopoverGestureRecognizer(): NSGestureRecognizer;
        showPopover(_?: any): void;
    }
    class NSPredicateEditor extends NSRuleEditor {
        rowTemplates: NSPredicateEditorRowTemplate[];
        setRowTemplates(_: NSPredicateEditorRowTemplate[]): any;
    }
    class NSPredicateEditorRowTemplate extends NSObject {
        static templatesWithAttributeKeyPathsInEntityDescription(withAttributeKeyPaths: string[], in_: NSEntityDescription): NSPredicateEditorRowTemplate[];
        compoundTypes: number[];
        leftExpressions: NSExpression[];
        modifier: NSComparisonPredicate.Modifier;
        operators: number[];
        options: number;
        rightExpressionAttributeType: NSAttributeType;
        rightExpressions: NSExpression[];
        templateViews: NSView[];
        displayableSubpredicatesOfPredicate(of: NSPredicate): NSPredicate[];
        static createWithCompoundTypes(compoundTypes: number[]): NSPredicateEditorRowTemplate;
        static createWithLeftExpressionsRightExpressionAttributeTypeModifierOperatorsOptions(leftExpressions: NSExpression[], rightExpressionAttributeType: NSAttributeType, modifier: NSComparisonPredicate.Modifier, operators: number[], options: number): NSPredicateEditorRowTemplate;
        static createWithLeftExpressionsRightExpressionsModifierOperatorsOptions(leftExpressions: NSExpression[], rightExpressions: NSExpression[], modifier: NSComparisonPredicate.Modifier, operators: number[], options: number): NSPredicateEditorRowTemplate;
        matchForPredicate(for_: NSPredicate): number;
        predicateWithSubpredicates(withSubpredicates?: NSPredicate[]): NSPredicate;
        setPredicate(_: NSPredicate): void;
    }
    class NSPressGestureRecognizer extends NSGestureRecognizer {
        allowableMovement: number;
        setAllowableMovement(_: number): any;
        buttonMask: number;
        setButtonMask(_: number): any;
        minimumPressDuration: number;
        setMinimumPressDuration(_: number): any;
        numberOfTouchesRequired: number;
        setNumberOfTouchesRequired(_: number): any;
    }
    class NSPressureConfiguration extends NSObject {
        pressureBehavior: NSEvent.PressureBehavior;
        static createWithPressureBehavior(pressureBehavior: NSEvent.PressureBehavior): NSPressureConfiguration;
        set(): void;
    }
    class NSPrintInfo extends NSObject {
        bottomMargin: number;
        setBottomMargin(_: number): any;
        horizontalPagination: NSPrintInfo.PaginationMode;
        setHorizontalPagination(_: NSPrintInfo.PaginationMode): any;
        isHorizontallyCentered: boolean;
        setHorizontallyCentered(_: boolean): any;
        imageablePageBounds: CGRect;
        jobDisposition: string;
        setJobDisposition(_: string): any;
        leftMargin: number;
        setLeftMargin(_: number): any;
        localizedPaperName: string;
        orientation: NSPrintInfo.PaperOrientation;
        setOrientation(_: NSPrintInfo.PaperOrientation): any;
        paperName: string;
        setPaperName(_: string): any;
        paperSize: CGSize;
        setPaperSize(_: CGSize): any;
        printSettings: NSMutableDictionary<string, any>;
        printer: NSPrinter;
        setPrinter(_: NSPrinter): any;
        rightMargin: number;
        setRightMargin(_: number): any;
        scalingFactor: number;
        setScalingFactor(_: number): any;
        isSelectionOnly: boolean;
        setSelectionOnly(_: boolean): any;
        topMargin: number;
        setTopMargin(_: number): any;
        verticalPagination: NSPrintInfo.PaginationMode;
        setVerticalPagination(_: NSPrintInfo.PaginationMode): any;
        isVerticallyCentered: boolean;
        setVerticallyCentered(_: boolean): any;
        static defaultPrinter: NSPrinter;
        static sharedPrintInfo: NSPrintInfo;
        setSharedPrintInfo(_: NSPrintInfo): any;
        PMPageFormat(): any;
        PMPrintSession(): any;
        PMPrintSettings(): any;
        dictionary(): NSMutableDictionary<string, any>;
        static createWithDictionary(dictionary: Map<string, any>): NSPrintInfo;
        setUpPrintOperationDefaultValues(): void;
        takeSettingsFromPDFInfo(from: NSPDFInfo): void;
        updateFromPMPageFormat(): void;
        updateFromPMPrintSettings(): void;
    }
    class NSPrintOperation extends NSObject {
        static EPSOperationWithViewInsideRectToData(with_: NSView, inside: CGRect, to?: NSMutableData): NSPrintOperation;
        static EPSOperationWithViewInsideRectToDataPrintInfo(with_: NSView, inside: CGRect, to: NSMutableData, printInfo: NSPrintInfo): NSPrintOperation;
        static EPSOperationWithViewInsideRectToPathPrintInfo(with_: NSView, inside: CGRect, toPath: string, printInfo: NSPrintInfo): NSPrintOperation;
        static PDFOperationWithViewInsideRectToData(with_: NSView, inside: CGRect, to: NSMutableData): NSPrintOperation;
        static PDFOperationWithViewInsideRectToDataPrintInfo(with_: NSView, inside: CGRect, to: NSMutableData, printInfo: NSPrintInfo): NSPrintOperation;
        static PDFOperationWithViewInsideRectToPathPrintInfo(with_: NSView, inside: CGRect, toPath: string, printInfo: NSPrintInfo): NSPrintOperation;
        PDFPanel: NSPDFPanel;
        setPDFPanel(_: NSPDFPanel): any;
        canSpawnSeparateThread: boolean;
        setCanSpawnSeparateThread(_: boolean): any;
        context: NSGraphicsContext;
        isCopyingOperation: boolean;
        currentPage: number;
        jobTitle: string;
        setJobTitle(_: string): any;
        pageOrder: NSPrintOperation.PageOrder;
        setPageOrder(_: NSPrintOperation.PageOrder): any;
        pageRange: NSRange;
        preferredRenderingQuality: NSPrintOperation.RenderingQuality;
        printInfo: NSPrintInfo;
        setPrintInfo(_: NSPrintInfo): any;
        printPanel: NSPrintPanel;
        setPrintPanel(_: NSPrintPanel): any;
        showsPrintPanel: boolean;
        setShowsPrintPanel(_: boolean): any;
        showsProgressPanel: boolean;
        setShowsProgressPanel(_: boolean): any;
        view: NSView;
        static currentOperation: NSPrintOperation;
        setCurrentOperation(_: NSPrintOperation): any;
        cleanUpOperation(): void;
        createContext(): NSGraphicsContext;
        deliverResult(): boolean;
        destroyContext(): void;
        runOperation(): boolean;
        runOperationModalForWindowDelegateDidRunSelectorContextInfo(for_: NSWindow, delegate?: any, didRun?: string, contextInfo?: any): void;
    }
    class NSPrintPanel extends NSObject {
        accessoryControllers: NSViewController[];
        helpAnchor: string;
        setHelpAnchor(_: string): any;
        jobStyleHint: string;
        setJobStyleHint(_: string): any;
        options: NSPrintPanel.Options;
        setOptions(_: NSPrintPanel.Options): any;
        printInfo: NSPrintInfo;
        addAccessoryController(_: NSViewController): void;
        beginSheetWithPrintInfoModalForWindowDelegateDidEndSelectorContextInfo(with_: NSPrintInfo, modalFor: NSWindow, delegate?: any, didEnd?: string, contextInfo?: any): void;
        defaultButtonTitle(): string;
        removeAccessoryController(_: NSViewController): void;
        runModal(): number;
        runModalWithPrintInfo(with_: NSPrintInfo): number;
        setDefaultButtonTitle(_?: string): void;
    }
    interface NSPrintPanelAccessorizing {
        keyPathsForValuesAffectingPreview?(): NSSet<string>;
        localizedSummaryItems(): Map<string, string>[];
    }
    class NSPrinter extends NSObject {
        deviceDescription: Map<string, any>;
        languageLevel: number;
        name: string;
        type: string;
        static printerNames: string[];
        static printerTypes: string[];
        pageSizeForPaper(forPaper: string): CGSize;
    }
    class NSProgressIndicator extends NSView {
        isBezeled: boolean;
        setBezeled(_: boolean): any;
        controlSize: NSControl.ControlSize;
        setControlSize(_: NSControl.ControlSize): any;
        controlTint: NSControlTint;
        setControlTint(_: NSControlTint): any;
        isDisplayedWhenStopped: boolean;
        setDisplayedWhenStopped(_: boolean): any;
        doubleValue: number;
        setDoubleValue(_: number): any;
        isIndeterminate: boolean;
        setIndeterminate(_: boolean): any;
        maxValue: number;
        setMaxValue(_: number): any;
        minValue: number;
        setMinValue(_: number): any;
        style: NSProgressIndicator.Style;
        setStyle(_: NSProgressIndicator.Style): any;
        usesThreadedAnimation: boolean;
        setUsesThreadedAnimation(_: boolean): any;
        incrementBy(by: number): void;
        sizeToFit(): void;
        startAnimation(_?: any): void;
        stopAnimation(_?: any): void;
    }
    class NSResponder extends NSObject {
        acceptsFirstResponder: boolean;
        menu: NSMenu;
        setMenu(_: NSMenu): any;
        nextResponder: NSResponder;
        setNextResponder(_: NSResponder): any;
        touchBar: NSTouchBar;
        setTouchBar(_: NSTouchBar): any;
        undoManager: UndoManager;
        userActivity: NSUserActivity;
        setUserActivity(_: NSUserActivity): any;
        static restorableStateKeyPaths: string[];
        becomeFirstResponder(): boolean;
        beginGestureWithEvent(with_: NSEvent): void;
        changeModeWithEvent(with_: NSEvent): void;
        cursorUpdate(with_: NSEvent): void;
        encodeRestorableStateWithCoder(with_: NSCoder): void;
        encodeRestorableStateWithCoderBackgroundQueue(with_: NSCoder, backgroundQueue: OperationQueue): void;
        endGestureWithEvent(with_: NSEvent): void;
        flagsChanged(with_: NSEvent): void;
        flushBufferedKeyEvents(): void;
        helpRequested(_: NSEvent): void;
        interpretKeyEvents(_: NSEvent[]): void;
        invalidateRestorableState(): void;
        keyDown(with_: NSEvent): void;
        keyUp(with_: NSEvent): void;
        magnifyWithEvent(with_: NSEvent): void;
        makeTouchBar(): NSTouchBar;
        mouseDown(with_: NSEvent): void;
        mouseDragged(with_: NSEvent): void;
        mouseEntered(with_: NSEvent): void;
        mouseExited(with_: NSEvent): void;
        mouseMoved(with_: NSEvent): void;
        mouseUp(with_: NSEvent): void;
        newWindowForTab(_?: any): void;
        noResponderFor(for_: string): void;
        otherMouseDown(with_: NSEvent): void;
        otherMouseDragged(with_: NSEvent): void;
        otherMouseUp(with_: NSEvent): void;
        performKeyEquivalent(with_: NSEvent): boolean;
        performTextFinderAction(_?: any): void;
        presentError(_: NSError): boolean;
        presentErrorModalForWindowDelegateDidPresentSelectorContextInfo(_: NSError, modalFor: NSWindow, delegate?: any, didPresent?: string, contextInfo?: any): void;
        pressureChangeWithEvent(with_: NSEvent): void;
        quickLookWithEvent(with_: NSEvent): void;
        resignFirstResponder(): boolean;
        restoreStateWithCoder(with_: NSCoder): void;
        rightMouseDown(with_: NSEvent): void;
        rightMouseDragged(with_: NSEvent): void;
        rightMouseUp(with_: NSEvent): void;
        rotateWithEvent(with_: NSEvent): void;
        scrollWheel(with_: NSEvent): void;
        shouldBeTreatedAsInkEvent(_: NSEvent): boolean;
        showContextHelp(_?: any): void;
        smartMagnifyWithEvent(with_: NSEvent): void;
        supplementalTargetForActionSender(forAction: string, sender?: any): any;
        swipeWithEvent(with_: NSEvent): void;
        tabletPoint(with_: NSEvent): void;
        tabletProximity(with_: NSEvent): void;
        touchesBeganWithEvent(with_: NSEvent): void;
        touchesCancelledWithEvent(with_: NSEvent): void;
        touchesEndedWithEvent(with_: NSEvent): void;
        touchesMovedWithEvent(with_: NSEvent): void;
        tryToPerformWith(_: string, with_?: any): boolean;
        updateUserActivityState(_: NSUserActivity): void;
        validRequestorForSendTypeReturnType(forSendType?: string, returnType?: string): any;
        validateProposedFirstResponderForEvent(_: NSResponder, for_?: NSEvent): boolean;
        wantsForwardedScrollEventsForAxis(for_: NSEvent.GestureAxis): boolean;
        wantsScrollEventsForSwipeTrackingOnAxis(on: NSEvent.GestureAxis): boolean;
        willPresentError(_: NSError): NSError;
    }
    class NSRotationGestureRecognizer extends NSGestureRecognizer {
        rotation: number;
        setRotation(_: number): any;
        rotationInDegrees: number;
        setRotationInDegrees(_: number): any;
    }
    class NSRuleEditor extends NSControl {
        canRemoveAllRows: boolean;
        setCanRemoveAllRows(_: boolean): any;
        criteriaKeyPath: string;
        setCriteriaKeyPath(_: string): any;
        delegate: NSRuleEditorDelegate;
        setDelegate(_: NSRuleEditorDelegate): any;
        displayValuesKeyPath: string;
        setDisplayValuesKeyPath(_: string): any;
        isEditable: boolean;
        setEditable(_: boolean): any;
        formattingDictionary: Map<string, string>;
        setFormattingDictionary(_: Map<string, string>): any;
        formattingStringsFilename: string;
        setFormattingStringsFilename(_: string): any;
        nestingMode: NSRuleEditor.NestingMode;
        setNestingMode(_: NSRuleEditor.NestingMode): any;
        numberOfRows: number;
        predicate: NSPredicate;
        rowClass: typeof NSObject;
        setRowClass(_: typeof NSObject): any;
        rowHeight: number;
        setRowHeight(_: number): any;
        rowTypeKeyPath: string;
        setRowTypeKeyPath(_: string): any;
        selectedRowIndexes: NSIndexSet;
        subrowsKeyPath: string;
        setSubrowsKeyPath(_: string): any;
        addRow(_?: any): void;
        criteriaForRow(forRow: number): any[];
        displayValuesForRow(forRow: number): any[];
        insertRowAtIndexWithTypeAsSubrowOfRowAnimate(at: number, with_: NSRuleEditor.RowType, asSubrowOfRow: number, animate: boolean): void;
        parentRowForRow(forRow: number): number;
        predicateForRow(forRow: number): NSPredicate;
        reloadCriteria(): void;
        reloadPredicate(): void;
        removeRowAtIndex(at: number): void;
        removeRowsAtIndexesIncludeSubrows(at: NSIndexSet, includeSubrows: boolean): void;
        rowForDisplayValue(forDisplayValue: any): number;
        rowTypeForRow(forRow: number): NSRuleEditor.RowType;
        selectRowIndexesByExtendingSelection(_: NSIndexSet, byExtendingSelection: boolean): void;
        setCriteriaAndDisplayValuesForRowAtIndex(_: any[], andDisplayValues: any[], forRowAt: number): void;
        subrowIndexesForRow(forRow: number): NSIndexSet;
    }
    interface NSRuleEditorDelegate extends NSObject {
        ruleEditorNumberOfChildrenForCriterionWithRowType(_: NSRuleEditor, numberOfChildrenForCriterion?: any, with_?: NSRuleEditor.RowType): number;
        ruleEditorChildForCriterionWithRowType(_: NSRuleEditor, child: number, forCriterion?: any, with_?: NSRuleEditor.RowType): any;
        ruleEditorDisplayValueForCriterionInRow(_: NSRuleEditor, displayValueForCriterion: any, inRow: number): any;
        ruleEditorPredicatePartsForCriterionWithDisplayValueInRow?(_: NSRuleEditor, predicatePartsForCriterion: any, withDisplayValue: any, inRow: number): Map<string, any>;
        ruleEditorRowsDidChange?(_: NSNotification): void;
    }
    class NSRulerMarker extends NSObject {
        isDragging: boolean;
        image: NSImage;
        setImage(_: NSImage): any;
        imageOrigin: CGPoint;
        setImageOrigin(_: CGPoint): any;
        imageRectInRuler: CGRect;
        markerLocation: number;
        setMarkerLocation(_: number): any;
        isMovable: boolean;
        setMovable(_: boolean): any;
        isRemovable: boolean;
        setRemovable(_: boolean): any;
        representedObject: any;
        setRepresentedObject(_: any): any;
        ruler: NSRulerView;
        thicknessRequiredInRuler: number;
        drawRect(_: CGRect): void;
        static createWithRulerViewMarkerLocationImageImageOrigin(rulerView: NSRulerView, markerLocation: number, image: NSImage, imageOrigin: CGPoint): NSRulerMarker;
        trackMouseAdding(with_: NSEvent, adding: boolean): boolean;
    }
    class NSRulerView extends NSView {
        static registerUnitWithNameAbbreviationUnitToPointsConversionFactorStepUpCycleStepDownCycle(withName: string, abbreviation: string, unitToPointsConversionFactor: number, stepUpCycle: number[], stepDownCycle: number[]): void;
        accessoryView: NSView;
        setAccessoryView(_: NSView): any;
        baselineLocation: number;
        clientView: NSView;
        setClientView(_: NSView): any;
        markers: NSRulerMarker[];
        setMarkers(_: NSRulerMarker[]): any;
        measurementUnits: string;
        setMeasurementUnits(_: string): any;
        orientation: NSRulerView.Orientation;
        setOrientation(_: NSRulerView.Orientation): any;
        originOffset: number;
        setOriginOffset(_: number): any;
        requiredThickness: number;
        reservedThicknessForAccessoryView: number;
        setReservedThicknessForAccessoryView(_: number): any;
        reservedThicknessForMarkers: number;
        setReservedThicknessForMarkers(_: number): any;
        ruleThickness: number;
        setRuleThickness(_: number): any;
        scrollView: NSScrollView;
        setScrollView(_: NSScrollView): any;
        addMarker(_: NSRulerMarker): void;
        drawHashMarksAndLabelsInRect(in_: CGRect): void;
        drawMarkersInRect(in_: CGRect): void;
        static createWithScrollViewOrientation(scrollView?: NSScrollView, orientation?: NSRulerView.Orientation): NSRulerView;
        invalidateHashMarks(): void;
        moveRulerlineFromLocationToLocation(fromLocation: number, toLocation: number): void;
        removeMarker(_: NSRulerMarker): void;
        trackMarkerWithMouseEvent(_: NSRulerMarker, withMouseEvent: NSEvent): boolean;
    }
    class NSRunningApplication extends NSObject {
        static runningApplicationsWithBundleIdentifier(withBundleIdentifier: string): NSRunningApplication[];
        static terminateAutomaticallyTerminableApplications(): void;
        activationPolicy: NSApplication.ActivationPolicy;
        isActive: boolean;
        bundleIdentifier: string;
        bundleURL: NSURL;
        executableArchitecture: number;
        executableURL: NSURL;
        isFinishedLaunching: boolean;
        isHidden: boolean;
        icon: NSImage;
        launchDate: Date;
        localizedName: string;
        ownsMenuBar: boolean;
        processIdentifier: number;
        isTerminated: boolean;
        static currentApplication: NSRunningApplication;
        activateWithOptions(options: NSApplication.ActivationOptions): boolean;
        forceTerminate(): boolean;
        hide(): boolean;
        terminate(): boolean;
        unhide(): boolean;
    }
    class NSSavePanel extends NSPanel {
        URL: NSURL;
        accessoryView: NSView;
        setAccessoryView(_: NSView): any;
        allowedFileTypes: string[];
        setAllowedFileTypes(_: string[]): any;
        allowsOtherFileTypes: boolean;
        setAllowsOtherFileTypes(_: boolean): any;
        canCreateDirectories: boolean;
        setCanCreateDirectories(_: boolean): any;
        canSelectHiddenExtension: boolean;
        setCanSelectHiddenExtension(_: boolean): any;
        directoryURL: NSURL;
        setDirectoryURL(_: NSURL): any;
        isExpanded: boolean;
        isExtensionHidden: boolean;
        setExtensionHidden(_: boolean): any;
        message: string;
        setMessage(_: string): any;
        nameFieldLabel: string;
        setNameFieldLabel(_: string): any;
        nameFieldStringValue: string;
        setNameFieldStringValue(_: string): any;
        prompt: string;
        setPrompt(_: string): any;
        showsHiddenFiles: boolean;
        setShowsHiddenFiles(_: boolean): any;
        showsTagField: boolean;
        setShowsTagField(_: boolean): any;
        tagNames: string[];
        setTagNames(_: string[]): any;
        treatsFilePackagesAsDirectories: boolean;
        setTreatsFilePackagesAsDirectories(_: boolean): any;
        beginSheetModalForCompletionHandler(for_: NSWindow, completionHandler: (p1: number) => void): void;
        beginWithCompletionHandler(completionHandler: (p1: number) => void): void;
        cancel(_?: any): void;
        ok(_?: any): void;
        runModal(): number;
        validateVisibleColumns(): void;
    }
    class NSScreen extends NSObject {
        backingScaleFactor: number;
        colorSpace: NSColorSpace;
        depth: NSWindow.Depth;
        deviceDescription: Map<string, any>;
        frame: CGRect;
        localizedName: string;
        maximumExtendedDynamicRangeColorComponentValue: number;
        maximumPotentialExtendedDynamicRangeColorComponentValue: number;
        maximumReferenceExtendedDynamicRangeColorComponentValue: number;
        supportedWindowDepths: NSWindow.Depth;
        visibleFrame: CGRect;
        static deepestScreen: NSScreen;
        static mainScreen: NSScreen;
        static screens: NSScreen[];
        static screensHaveSeparateSpaces: boolean;
        backingAlignedRectOptions(_: CGRect, options: AlignmentOptions): CGRect;
        canRepresentDisplayGamut(_: NSDisplayGamut): boolean;
        convertRectFromBacking(_: CGRect): CGRect;
        convertRectToBacking(_: CGRect): CGRect;
    }
    class NSScrollView extends NSView {
        static contentSizeForFrameSizeHorizontalScrollerClassVerticalScrollerClassBorderTypeControlSizeScrollerStyle(forFrameSize: CGSize, horizontalScrollerClass?: typeof NSObject, verticalScrollerClass?: typeof NSObject, borderType?: NSBorderType, controlSize?: NSControl.ControlSize, scrollerStyle?: NSScroller.Style): CGSize;
        static frameSizeForContentSizeHorizontalScrollerClassVerticalScrollerClassBorderTypeControlSizeScrollerStyle(forContentSize: CGSize, horizontalScrollerClass?: typeof NSObject, verticalScrollerClass?: typeof NSObject, borderType?: NSBorderType, controlSize?: NSControl.ControlSize, scrollerStyle?: NSScroller.Style): CGSize;
        allowsMagnification: boolean;
        setAllowsMagnification(_: boolean): any;
        autohidesScrollers: boolean;
        setAutohidesScrollers(_: boolean): any;
        automaticallyAdjustsContentInsets: boolean;
        setAutomaticallyAdjustsContentInsets(_: boolean): any;
        backgroundColor: NSColor;
        setBackgroundColor(_: NSColor): any;
        borderType: NSBorderType;
        setBorderType(_: NSBorderType): any;
        contentInsets: NSEdgeInsets;
        setContentInsets(_: NSEdgeInsets): any;
        contentSize: CGSize;
        contentView: NSClipView;
        setContentView(_: NSClipView): any;
        documentCursor: NSCursor;
        setDocumentCursor(_: NSCursor): any;
        documentView: NSView;
        setDocumentView(_: NSView): any;
        documentVisibleRect: CGRect;
        drawsBackground: boolean;
        setDrawsBackground(_: boolean): any;
        findBarPosition: NSScrollView.FindBarPosition;
        setFindBarPosition(_: NSScrollView.FindBarPosition): any;
        hasHorizontalRuler: boolean;
        setHasHorizontalRuler(_: boolean): any;
        hasHorizontalScroller: boolean;
        setHasHorizontalScroller(_: boolean): any;
        hasVerticalRuler: boolean;
        setHasVerticalRuler(_: boolean): any;
        hasVerticalScroller: boolean;
        setHasVerticalScroller(_: boolean): any;
        horizontalLineScroll: number;
        setHorizontalLineScroll(_: number): any;
        horizontalPageScroll: number;
        setHorizontalPageScroll(_: number): any;
        horizontalRulerView: NSRulerView;
        setHorizontalRulerView(_: NSRulerView): any;
        horizontalScrollElasticity: NSScrollView.Elasticity;
        setHorizontalScrollElasticity(_: NSScrollView.Elasticity): any;
        horizontalScroller: NSScroller;
        setHorizontalScroller(_: NSScroller): any;
        lineScroll: number;
        setLineScroll(_: number): any;
        magnification: number;
        setMagnification(_: number): any;
        maxMagnification: number;
        setMaxMagnification(_: number): any;
        minMagnification: number;
        setMinMagnification(_: number): any;
        pageScroll: number;
        setPageScroll(_: number): any;
        rulersVisible: boolean;
        setRulersVisible(_: boolean): any;
        scrollerInsets: NSEdgeInsets;
        setScrollerInsets(_: NSEdgeInsets): any;
        scrollerKnobStyle: NSScroller.KnobStyle;
        setScrollerKnobStyle(_: NSScroller.KnobStyle): any;
        scrollerStyle: NSScroller.Style;
        setScrollerStyle(_: NSScroller.Style): any;
        scrollsDynamically: boolean;
        setScrollsDynamically(_: boolean): any;
        usesPredominantAxisScrolling: boolean;
        setUsesPredominantAxisScrolling(_: boolean): any;
        verticalLineScroll: number;
        setVerticalLineScroll(_: number): any;
        verticalPageScroll: number;
        setVerticalPageScroll(_: number): any;
        verticalRulerView: NSRulerView;
        setVerticalRulerView(_: NSRulerView): any;
        verticalScrollElasticity: NSScrollView.Elasticity;
        setVerticalScrollElasticity(_: NSScrollView.Elasticity): any;
        verticalScroller: NSScroller;
        setVerticalScroller(_: NSScroller): any;
        static rulerViewClass: typeof NSObject;
        setRulerViewClass(_: typeof NSObject): any;
        addFloatingSubviewForAxis(_: NSView, for_: NSEvent.GestureAxis): void;
        flashScrollers(): void;
        magnifyToFitRect(toFit: CGRect): void;
        setMagnificationCenteredAtPoint(_: number, centeredAt: CGPoint): void;
        tile(): void;
    }
    class NSScroller extends NSControl {
        static scrollerWidthForControlSizeScrollerStyle(for_: NSControl.ControlSize, scrollerStyle: NSScroller.Style): number;
        hitPart: NSScroller.Part;
        knobProportion: number;
        setKnobProportion(_: number): any;
        knobStyle: NSScroller.KnobStyle;
        setKnobStyle(_: NSScroller.KnobStyle): any;
        scrollerStyle: NSScroller.Style;
        setScrollerStyle(_: NSScroller.Style): any;
        usableParts: NSScroller.UsableParts;
        static isCompatibleWithOverlayScrollers: boolean;
        static preferredScrollerStyle: NSScroller.Style;
        checkSpaceForParts(): void;
        drawKnob(): void;
        drawKnobSlotInRectHighlight(in_: CGRect, highlight: boolean): void;
        rectForPart(for_: NSScroller.Part): CGRect;
        setKnobProportion(_: number): void;
        testPart(_: CGPoint): NSScroller.Part;
        trackKnob(with_: NSEvent): void;
    }
    class NSScrubber extends NSView {
        backgroundColor: NSColor;
        setBackgroundColor(_: NSColor): any;
        backgroundView: NSView;
        setBackgroundView(_: NSView): any;
        isContinuous: boolean;
        setContinuous(_: boolean): any;
        dataSource: NSScrubberDataSource;
        setDataSource(_: NSScrubberDataSource): any;
        delegate: NSScrubberDelegate;
        setDelegate(_: NSScrubberDelegate): any;
        floatsSelectionViews: boolean;
        setFloatsSelectionViews(_: boolean): any;
        highlightedIndex: number;
        itemAlignment: NSScrubber.Alignment;
        setItemAlignment(_: NSScrubber.Alignment): any;
        mode: NSScrubber.Mode;
        setMode(_: NSScrubber.Mode): any;
        numberOfItems: number;
        scrubberLayout: NSScrubberLayout;
        setScrubberLayout(_: NSScrubberLayout): any;
        selectedIndex: number;
        setSelectedIndex(_: number): any;
        selectionBackgroundStyle: NSScrubberSelectionStyle;
        setSelectionBackgroundStyle(_: NSScrubberSelectionStyle): any;
        selectionOverlayStyle: NSScrubberSelectionStyle;
        setSelectionOverlayStyle(_: NSScrubberSelectionStyle): any;
        showsAdditionalContentIndicators: boolean;
        setShowsAdditionalContentIndicators(_: boolean): any;
        showsArrowButtons: boolean;
        setShowsArrowButtons(_: boolean): any;
        insertItemsAtIndexes(at: NSIndexSet): void;
        itemViewForItemAtIndex(at: number): NSScrubberItemView;
        makeItemWithIdentifierOwner(withIdentifier: string, owner?: any): NSScrubberItemView;
        moveItemAtIndexToIndex(at: number, to: number): void;
        performSequentialBatchUpdates(_: () => void): void;
        registerClassForItemIdentifier(_?: typeof NSObject, forItemIdentifier?: string): void;
        registerNibForItemIdentifier(_?: NSNib, forItemIdentifier?: string): void;
        reloadData(): void;
        reloadItemsAtIndexes(at: NSIndexSet): void;
        removeItemsAtIndexes(at: NSIndexSet): void;
        scrollItemAtIndexToAlignment(at: number, to: NSScrubber.Alignment): void;
    }
    class NSScrubberArrangedView extends NSView {
        isHighlighted: boolean;
        setHighlighted(_: boolean): any;
        isSelected: boolean;
        setSelected(_: boolean): any;
        applyLayoutAttributes(_: NSScrubberLayoutAttributes): void;
    }
    interface NSScrubberDataSource extends NSObject {
        numberOfItemsForScrubber(for_: NSScrubber): number;
        scrubberViewForItemAtIndex(_: NSScrubber, viewForItemAt: number): NSScrubberItemView;
    }
    interface NSScrubberDelegate extends NSObject {
        didBeginInteractingWithScrubber?(with_: NSScrubber): void;
        didCancelInteractingWithScrubber?(with_: NSScrubber): void;
        didFinishInteractingWithScrubber?(with_: NSScrubber): void;
        scrubberDidSelectItemAtIndex?(_: NSScrubber, didSelectItemAt: number): void;
        scrubberDidHighlightItemAtIndex?(_: NSScrubber, didHighlightItemAt: number): void;
        scrubberDidChangeVisibleRange?(_: NSScrubber, didChangeVisibleRange: NSRange): void;
    }
    class NSScrubberFlowLayout extends NSScrubberLayout {
        itemSize: CGSize;
        setItemSize(_: CGSize): any;
        itemSpacing: number;
        setItemSpacing(_: number): any;
        invalidateLayoutForItemsAtIndexes(at: NSIndexSet): void;
    }
    interface NSScrubberFlowLayoutDelegate extends NSScrubberDelegate {
        scrubberLayoutSizeForItemAtIndex?(_: NSScrubber, layout: NSScrubberFlowLayout, sizeForItemAt: number): CGSize;
    }
    class NSScrubberImageItemView extends NSScrubberItemView {
        image: NSImage;
        setImage(_: NSImage): any;
        imageAlignment: NSImageAlignment;
        setImageAlignment(_: NSImageAlignment): any;
        imageView: NSImageView;
    }
    class NSScrubberItemView extends NSScrubberArrangedView {
    }
    class NSScrubberLayout extends NSObject {
        automaticallyMirrorsInRightToLeftLayout: boolean;
        scrubber: NSScrubber;
        scrubberContentSize: CGSize;
        shouldInvalidateLayoutForHighlightChange: boolean;
        shouldInvalidateLayoutForSelectionChange: boolean;
        visibleRect: CGRect;
        static layoutAttributesClass: typeof NSObject;
        invalidateLayout(): void;
        layoutAttributesForItemAtIndex(at: number): NSScrubberLayoutAttributes;
        layoutAttributesForItemsInRect(in_: CGRect): NSSet<NSScrubberLayoutAttributes>;
        prepareLayout(): void;
        shouldInvalidateLayoutForChangeFromVisibleRectToVisibleRect(fromVisibleRect: CGRect, toVisibleRect: CGRect): boolean;
    }
    class NSScrubberLayoutAttributes extends NSObject {
        static layoutAttributesForItemAtIndex(forItemAt: number): NSScrubberLayoutAttributes;
        alpha: number;
        setAlpha(_: number): any;
        frame: CGRect;
        setFrame(_: CGRect): any;
        itemIndex: number;
        setItemIndex(_: number): any;
    }
    class NSScrubberProportionalLayout extends NSScrubberLayout {
        numberOfVisibleItems: number;
        setNumberOfVisibleItems(_: number): any;
        static createWithNumberOfVisibleItems(numberOfVisibleItems: number): NSScrubberProportionalLayout;
    }
    class NSScrubberSelectionStyle extends NSObject {
        static outlineOverlayStyle: NSScrubberSelectionStyle;
        static roundedBackgroundStyle: NSScrubberSelectionStyle;
        makeSelectionView(): NSScrubberSelectionView;
    }
    class NSScrubberSelectionView extends NSScrubberArrangedView {
    }
    class NSScrubberTextItemView extends NSScrubberItemView {
        textField: NSTextField;
        title: string;
        setTitle(_: string): any;
    }
    class NSSearchField extends NSTextField {
        centersPlaceholder: boolean;
        setCentersPlaceholder(_: boolean): any;
        maximumRecents: number;
        setMaximumRecents(_: number): any;
        recentSearches: string[];
        setRecentSearches(_: string[]): any;
        recentsAutosaveName: string;
        setRecentsAutosaveName(_: string): any;
        searchMenuTemplate: NSMenu;
        setSearchMenuTemplate(_: NSMenu): any;
        sendsSearchStringImmediately: boolean;
        setSendsSearchStringImmediately(_: boolean): any;
        sendsWholeSearchString: boolean;
        setSendsWholeSearchString(_: boolean): any;
        rectForCancelButtonWhenCentered(whenCentered: boolean): CGRect;
        rectForSearchButtonWhenCentered(whenCentered: boolean): CGRect;
        rectForSearchTextWhenCentered(whenCentered: boolean): CGRect;
    }
    class NSSearchFieldCell extends NSTextFieldCell {
        cancelButtonCell: NSButtonCell;
        setCancelButtonCell(_: NSButtonCell): any;
        maximumRecents: number;
        setMaximumRecents(_: number): any;
        recentSearches: string[];
        setRecentSearches(_: string[]): any;
        recentsAutosaveName: string;
        setRecentsAutosaveName(_: string): any;
        searchButtonCell: NSButtonCell;
        setSearchButtonCell(_: NSButtonCell): any;
        searchMenuTemplate: NSMenu;
        setSearchMenuTemplate(_: NSMenu): any;
        sendsSearchStringImmediately: boolean;
        setSendsSearchStringImmediately(_: boolean): any;
        sendsWholeSearchString: boolean;
        setSendsWholeSearchString(_: boolean): any;
        cancelButtonRectForBounds(forBounds: CGRect): CGRect;
        resetCancelButtonCell(): void;
        resetSearchButtonCell(): void;
        searchButtonRectForBounds(forBounds: CGRect): CGRect;
        searchTextRectForBounds(forBounds: CGRect): CGRect;
    }
    interface NSSearchFieldDelegate extends NSTextFieldDelegate {
        searchFieldDidEndSearching?(_: NSSearchField): void;
        searchFieldDidStartSearching?(_: NSSearchField): void;
    }
    class NSSecureTextField extends NSTextField {
    }
    class NSSecureTextFieldCell extends NSTextFieldCell {
        echosBullets: boolean;
        setEchosBullets(_: boolean): any;
    }
    class NSSegmentedCell extends NSActionCell {
        segmentCount: number;
        setSegmentCount(_: number): any;
        segmentStyle: NSSegmentedControl.Style;
        setSegmentStyle(_: NSSegmentedControl.Style): any;
        selectedSegment: number;
        setSelectedSegment(_: number): any;
        trackingMode: NSSegmentedControl.SwitchTracking;
        setTrackingMode(_: NSSegmentedControl.SwitchTracking): any;
        drawSegmentInFrameWithView(_: number, inFrame: CGRect, with_: NSView): void;
        imageForSegment(forSegment: number): NSImage;
        imageScalingForSegment(forSegment: number): NSImageScaling;
        interiorBackgroundStyleForSegment(forSegment: number): NSView.BackgroundStyle;
        isEnabledForSegment(forSegment: number): boolean;
        isSelectedForSegment(forSegment: number): boolean;
        labelForSegment(forSegment: number): string;
        makeNextSegmentKey(): void;
        makePreviousSegmentKey(): void;
        menuForSegment(forSegment: number): NSMenu;
        selectSegmentWithTag(withTag: number): boolean;
        setEnabledForSegment(_: boolean, forSegment: number): void;
        setImageForSegment(_?: NSImage, forSegment?: number): void;
        setImageScalingForSegment(_: NSImageScaling, forSegment: number): void;
        setLabelForSegment(_: string, forSegment: number): void;
        setMenuForSegment(_?: NSMenu, forSegment?: number): void;
        setSelectedForSegment(_: boolean, forSegment: number): void;
        setTagForSegment(_: number, forSegment: number): void;
        setToolTipForSegment(_?: string, forSegment?: number): void;
        setWidthForSegment(_: number, forSegment: number): void;
        tagForSegment(forSegment: number): number;
        toolTipForSegment(forSegment: number): string;
        widthForSegment(forSegment: number): number;
    }
    class NSSegmentedControl extends NSControl {
        doubleValueForSelectedSegment: number;
        indexOfSelectedItem: number;
        segmentCount: number;
        setSegmentCount(_: number): any;
        segmentDistribution: NSSegmentedControl.Distribution;
        setSegmentDistribution(_: NSSegmentedControl.Distribution): any;
        segmentStyle: NSSegmentedControl.Style;
        setSegmentStyle(_: NSSegmentedControl.Style): any;
        selectedSegment: number;
        setSelectedSegment(_: number): any;
        selectedSegmentBezelColor: NSColor;
        setSelectedSegmentBezelColor(_: NSColor): any;
        isSpringLoaded: boolean;
        setSpringLoaded(_: boolean): any;
        trackingMode: NSSegmentedControl.SwitchTracking;
        setTrackingMode(_: NSSegmentedControl.SwitchTracking): any;
        alignmentForSegment(forSegment: number): NSTextAlignment;
        imageForSegment(forSegment: number): NSImage;
        imageScalingForSegment(forSegment: number): NSImageScaling;
        isEnabledForSegment(forSegment: number): boolean;
        isSelectedForSegment(forSegment: number): boolean;
        labelForSegment(forSegment: number): string;
        menuForSegment(forSegment: number): NSMenu;
        selectSegmentWithTag(withTag: number): boolean;
        setAlignmentForSegment(_: NSTextAlignment, forSegment: number): void;
        setEnabledForSegment(_: boolean, forSegment: number): void;
        setImageForSegment(_?: NSImage, forSegment?: number): void;
        setImageScalingForSegment(_: NSImageScaling, forSegment: number): void;
        setLabelForSegment(_: string, forSegment: number): void;
        setMenuForSegment(_?: NSMenu, forSegment?: number): void;
        setSelectedForSegment(_: boolean, forSegment: number): void;
        setShowsMenuIndicatorForSegment(_: boolean, forSegment: number): void;
        setTagForSegment(_: number, forSegment: number): void;
        setToolTipForSegment(_?: string, forSegment?: number): void;
        setWidthForSegment(_: number, forSegment: number): void;
        showsMenuIndicatorForSegment(forSegment: number): boolean;
        tagForSegment(forSegment: number): number;
        toolTipForSegment(forSegment: number): string;
        widthForSegment(forSegment: number): number;
    }
    interface NSSeguePerforming extends NSObject {
        performSegueWithIdentifierSender?(withIdentifier: string, sender?: any): void;
        prepareForSegueSender?(for_: NSStoryboardSegue, sender?: any): void;
        shouldPerformSegueWithIdentifierSender?(withIdentifier: string, sender?: any): boolean;
    }
    interface NSServicesMenuRequestor extends NSObject {
        readSelectionFromPasteboard?(from: NSPasteboard): boolean;
        writeSelectionToPasteboardTypes?(to: NSPasteboard, types: string[]): boolean;
    }
    class NSShadow extends NSObject {
        shadowBlurRadius: number;
        setShadowBlurRadius(_: number): any;
        shadowColor: NSColor;
        setShadowColor(_: NSColor): any;
        shadowOffset: CGSize;
        setShadowOffset(_: CGSize): any;
        set(): void;
    }
    class NSSharingService extends NSObject {
        static sharingServicesForItems(forItems: any[]): NSSharingService[];
        accountName: string;
        alternateImage: NSImage;
        attachmentFileURLs: NSURL[];
        delegate: NSSharingServiceDelegate;
        setDelegate(_: NSSharingServiceDelegate): any;
        image: NSImage;
        menuItemTitle: string;
        setMenuItemTitle(_: string): any;
        messageBody: string;
        permanentLink: NSURL;
        recipients: string[];
        setRecipients(_: string[]): any;
        subject: string;
        setSubject(_: string): any;
        title: string;
        canPerformWithItems(withItems?: any[]): boolean;
        static createWithTitleImageAlternateImageHandler(title: string, image: NSImage, alternateImage?: NSImage, handler?: () => void): NSSharingService;
        performWithItems(withItems: any[]): void;
    }
    interface NSSharingServiceDelegate extends NSObject {
        anchoringViewForSharingServiceShowRelativeToRectPreferredEdge?(for_: NSSharingService, showRelativeTo: NSRect, preferredEdge: NSRectEdge): NSView;
        sharingServiceDidFailToShareItemsError?(_: NSSharingService, didFailToShareItems: any[], error: NSError): void;
        sharingServiceDidShareItems?(_: NSSharingService, didShareItems: any[]): void;
        sharingServiceSourceFrameOnScreenForShareItem?(_: NSSharingService, sourceFrameOnScreenForShareItem: any): CGRect;
        sharingServiceSourceWindowForShareItemsSharingContentScope?(_: NSSharingService, sourceWindowForShareItems: any[], sharingContentScope: NSSharingService.SharingContentScope): NSWindow;
        sharingServiceTransitionImageForShareItemContentRect?(_: NSSharingService, transitionImageForShareItem: any, contentRect: NSRect): NSImage;
        sharingServiceWillShareItems?(_: NSSharingService, willShareItems: any[]): void;
    }
    class NSSharingServicePicker extends NSObject {
        delegate: NSSharingServicePickerDelegate;
        setDelegate(_: NSSharingServicePickerDelegate): any;
        static createWithItems(items: any[]): NSSharingServicePicker;
        showRelativeToRectOfViewPreferredEdge(relativeTo: CGRect, of: NSView, preferredEdge: NSRectEdge): void;
    }
    interface NSSharingServicePickerDelegate extends NSObject {
        sharingServicePickerDelegateForSharingService?(_: NSSharingServicePicker, delegateFor: NSSharingService): NSSharingServiceDelegate;
        sharingServicePickerDidChooseSharingService?(_: NSSharingServicePicker, didChoose?: NSSharingService): void;
        sharingServicePickerSharingServicesForItemsProposedSharingServices?(_: NSSharingServicePicker, sharingServicesForItems: any[], proposedSharingServices: NSSharingService[]): NSSharingService[];
    }
    class NSSharingServicePickerToolbarItem extends NSToolbarItem {
        delegate: NSSharingServicePickerToolbarItemDelegate;
        setDelegate(_: NSSharingServicePickerToolbarItemDelegate): any;
    }
    interface NSSharingServicePickerToolbarItemDelegate extends NSSharingServicePickerDelegate {
        itemsForSharingServicePickerToolbarItem(for_: NSSharingServicePickerToolbarItem): any[];
    }
    class NSSharingServicePickerTouchBarItem extends NSTouchBarItem {
        buttonImage: NSImage;
        setButtonImage(_: NSImage): any;
        buttonTitle: string;
        setButtonTitle(_: string): any;
        delegate: NSSharingServicePickerTouchBarItemDelegate;
        setDelegate(_: NSSharingServicePickerTouchBarItemDelegate): any;
        isEnabled: boolean;
        setEnabled(_: boolean): any;
    }
    interface NSSharingServicePickerTouchBarItemDelegate extends NSSharingServicePickerDelegate {
        itemsForSharingServicePickerTouchBarItem(for_: NSSharingServicePickerTouchBarItem): any[];
    }
    class NSSlider extends NSControl {
        allowsTickMarkValuesOnly: boolean;
        setAllowsTickMarkValuesOnly(_: boolean): any;
        altIncrementValue: number;
        setAltIncrementValue(_: number): any;
        knobThickness: number;
        maxValue: number;
        setMaxValue(_: number): any;
        minValue: number;
        setMinValue(_: number): any;
        numberOfTickMarks: number;
        setNumberOfTickMarks(_: number): any;
        sliderType: NSSlider.SliderType;
        setSliderType(_: NSSlider.SliderType): any;
        tickMarkPosition: NSSlider.TickMarkPosition;
        setTickMarkPosition(_: NSSlider.TickMarkPosition): any;
        trackFillColor: NSColor;
        setTrackFillColor(_: NSColor): any;
        isVertical: boolean;
        closestTickMarkValueToValue(toValue: number): number;
        indexOfTickMarkAtPoint(at: CGPoint): number;
        rectOfTickMarkAtIndex(at: number): CGRect;
        tickMarkValueAtIndex(at: number): number;
    }
    class NSSliderAccessory extends NSObject {
        behavior: NSSliderAccessoryBehavior;
        setBehavior(_: NSSliderAccessoryBehavior): any;
        isEnabled: boolean;
        setEnabled(_: boolean): any;
    }
    class NSSliderAccessoryBehavior extends NSObject {
        static initWithHandler(handler: (p1: NSSliderAccessory) => void): NSSliderAccessoryBehavior;
        static behaviorWithTargetAction(target?: any, action?: string): NSSliderAccessoryBehavior;
        static automaticBehavior: NSSliderAccessoryBehavior;
        static valueResetBehavior: NSSliderAccessoryBehavior;
        static valueStepBehavior: NSSliderAccessoryBehavior;
        handleAction(_: NSSliderAccessory): void;
    }
    class NSSliderCell extends NSActionCell {
        allowsTickMarkValuesOnly: boolean;
        setAllowsTickMarkValuesOnly(_: boolean): any;
        altIncrementValue: number;
        setAltIncrementValue(_: number): any;
        knobThickness: number;
        maxValue: number;
        setMaxValue(_: number): any;
        minValue: number;
        setMinValue(_: number): any;
        numberOfTickMarks: number;
        setNumberOfTickMarks(_: number): any;
        sliderType: NSSlider.SliderType;
        setSliderType(_: NSSlider.SliderType): any;
        tickMarkPosition: NSSlider.TickMarkPosition;
        setTickMarkPosition(_: NSSlider.TickMarkPosition): any;
        trackRect: CGRect;
        isVertical: boolean;
        barRectFlipped(flipped: boolean): CGRect;
        closestTickMarkValueToValue(toValue: number): number;
        drawBarInsideFlipped(inside: CGRect, flipped: boolean): void;
        drawKnob(): void;
        drawKnob(_: CGRect): void;
        drawTickMarks(): void;
        indexOfTickMarkAtPoint(at: CGPoint): number;
        knobRectFlipped(flipped: boolean): CGRect;
        rectOfTickMarkAtIndex(at: number): CGRect;
        tickMarkValueAtIndex(at: number): number;
    }
    class NSSliderTouchBarItem extends NSTouchBarItem {
        action: string;
        setAction(_: string): any;
        doubleValue: number;
        setDoubleValue(_: number): any;
        label: string;
        setLabel(_: string): any;
        maximumSliderWidth: number;
        setMaximumSliderWidth(_: number): any;
        maximumValueAccessory: NSSliderAccessory;
        setMaximumValueAccessory(_: NSSliderAccessory): any;
        minimumSliderWidth: number;
        setMinimumSliderWidth(_: number): any;
        minimumValueAccessory: NSSliderAccessory;
        setMinimumValueAccessory(_: NSSliderAccessory): any;
        slider: NSSlider;
        setSlider(_: NSSlider): any;
        target: any;
        setTarget(_: any): any;
        valueAccessoryWidth: number;
        setValueAccessoryWidth(_: number): any;
    }
    class NSSound extends NSObject {
        static canInitWithPasteboard(with_: NSPasteboard): boolean;
        currentTime: number;
        setCurrentTime(_: number): any;
        delegate: NSSoundDelegate;
        setDelegate(_: NSSoundDelegate): any;
        duration: number;
        loops: boolean;
        setLoops(_: boolean): any;
        name: string;
        playbackDeviceIdentifier: string;
        setPlaybackDeviceIdentifier(_: string): any;
        isPlaying: boolean;
        volume: number;
        setVolume(_: number): any;
        static soundUnfilteredTypes: string[];
        static createWithContentsOfFileByReference(contentsOfFile: string, byReference: boolean): NSSound;
        static createWithContentsOfURLByReference(contentsOfURL: NSURL, byReference: boolean): NSSound;
        static createWithData(data: NSData): NSSound;
        static createWithPasteboard(pasteboard: NSPasteboard): NSSound;
        pause(): boolean;
        play(): boolean;
        resume(): boolean;
        setName(_?: string): boolean;
        stop(): boolean;
        writeToPasteboard(to: NSPasteboard): void;
    }
    interface NSSoundDelegate extends NSObject {
        soundDidFinishPlaying?(_: NSSound, didFinishPlaying: boolean): void;
    }
    class NSSpeechRecognizer extends NSObject {
        blocksOtherRecognizers: boolean;
        setBlocksOtherRecognizers(_: boolean): any;
        commands: string[];
        setCommands(_: string[]): any;
        delegate: NSSpeechRecognizerDelegate;
        setDelegate(_: NSSpeechRecognizerDelegate): any;
        displayedCommandsTitle: string;
        setDisplayedCommandsTitle(_: string): any;
        listensInForegroundOnly: boolean;
        setListensInForegroundOnly(_: boolean): any;
        startListening(): void;
        stopListening(): void;
    }
    interface NSSpeechRecognizerDelegate extends NSObject {
        speechRecognizerDidRecognizeCommand?(_: NSSpeechRecognizer, didRecognizeCommand: string): void;
    }
    class NSSpeechSynthesizer extends NSObject {
        static attributesForVoice(forVoice: string): Map<string, any>;
        delegate: NSSpeechSynthesizerDelegate;
        setDelegate(_: NSSpeechSynthesizerDelegate): any;
        rate: number;
        setRate(_: number): any;
        isSpeaking: boolean;
        usesFeedbackWindow: boolean;
        setUsesFeedbackWindow(_: boolean): any;
        volume: number;
        setVolume(_: number): any;
        static isAnyApplicationSpeaking: boolean;
        static availableVoices: string[];
        static defaultVoice: string;
        addSpeechDictionary(_: Map<string, any>): void;
        continueSpeaking(): void;
        static createWithVoice(voice?: string): NSSpeechSynthesizer;
        objectForPropertyError(error: string): any;
        pauseSpeakingAtBoundary(at: NSSpeechSynthesizer.Boundary): void;
        phonemesFromText(from: string): string;
        setObjectForPropertyError(forProperty?: any, error?: string): boolean;
        setVoice(_?: string): boolean;
        startSpeakingString(_: string): boolean;
        startSpeakingStringToURL(_: string, to: NSURL): boolean;
        stopSpeaking(): void;
        stopSpeakingAtBoundary(at: NSSpeechSynthesizer.Boundary): void;
        voice(): string;
    }
    interface NSSpeechSynthesizerDelegate extends NSObject {
        speechSynthesizerWillSpeakWordOfString?(_: NSSpeechSynthesizer, willSpeakWord: NSRange, of: string): void;
        speechSynthesizerDidEncounterErrorAtIndexOfStringMessage?(_: NSSpeechSynthesizer, didEncounterErrorAt: number, of: string, message: string): void;
        speechSynthesizerDidEncounterSyncMessage?(_: NSSpeechSynthesizer, didEncounterSyncMessage: string): void;
        speechSynthesizerDidFinishSpeaking?(_: NSSpeechSynthesizer, didFinishSpeaking: boolean): void;
        speechSynthesizerWillSpeakPhoneme?(_: NSSpeechSynthesizer, willSpeakPhoneme: number): void;
    }
    class NSSpellChecker extends NSObject {
        static uniqueSpellDocumentTag(): number;
        accessoryView: NSView;
        setAccessoryView(_: NSView): any;
        automaticallyIdentifiesLanguages: boolean;
        setAutomaticallyIdentifiesLanguages(_: boolean): any;
        availableLanguages: string[];
        spellingPanel: NSPanel;
        substitutionsPanel: NSPanel;
        substitutionsPanelAccessoryViewController: NSViewController;
        setSubstitutionsPanelAccessoryViewController(_: NSViewController): any;
        userPreferredLanguages: string[];
        userReplacementsDictionary: Map<string, string>;
        static isAutomaticCapitalizationEnabled: boolean;
        static isAutomaticDashSubstitutionEnabled: boolean;
        static isAutomaticPeriodSubstitutionEnabled: boolean;
        static isAutomaticQuoteSubstitutionEnabled: boolean;
        static isAutomaticSpellingCorrectionEnabled: boolean;
        static isAutomaticTextCompletionEnabled: boolean;
        static isAutomaticTextReplacementEnabled: boolean;
        static sharedSpellChecker: NSSpellChecker;
        static sharedSpellCheckerExists: boolean;
        checkGrammarOfStringStartingAtLanguageWrapInSpellDocumentWithTagDetails(of: string, startingAt: number, language?: string, wrap?: boolean, inSpellDocumentWithTag?: number, details?: Map<string, any>[]): NSRange;
        checkSpellingOfStringStartingAt(of: string, startingAt: number): NSRange;
        checkSpellingOfStringStartingAtLanguageWrapInSpellDocumentWithTagWordCount(of: string, startingAt: number, language?: string, wrap?: boolean, inSpellDocumentWithTag?: number, wordCount?: number): NSRange;
        checkStringRangeTypesOptionsInSpellDocumentWithTagOrthographyWordCount(_: string, range: NSRange, types: number, options?: Map<string, any>, inSpellDocumentWithTag?: number, orthography?: NSOrthography, wordCount?: number): NSTextCheckingResult[];
        closeSpellDocumentWithTag(withTag: number): void;
        completionsForPartialWordRangeInStringLanguageInSpellDocumentWithTag(forPartialWordRange: NSRange, in_: string, language?: string, inSpellDocumentWithTag?: number): string[];
        correctionForWordRangeInStringLanguageInSpellDocumentWithTag(forWordRange: NSRange, in_: string, language: string, inSpellDocumentWithTag: number): string;
        countWordsInStringLanguage(in_: string, language?: string): number;
        deletesAutospaceBetweenStringAndStringLanguage(_: string, andString: string, language?: string): boolean;
        dismissCorrectionIndicatorForView(for_: NSView): void;
        guessesForWordRangeInStringLanguageInSpellDocumentWithTag(forWordRange: NSRange, in_: string, language?: string, inSpellDocumentWithTag?: number): string[];
        hasLearnedWord(_: string): boolean;
        ignoreWordInSpellDocumentWithTag(_: string, inSpellDocumentWithTag: number): void;
        ignoredWordsInSpellDocumentWithTag(inSpellDocumentWithTag: number): string[];
        language(): string;
        languageForWordRangeInStringOrthography(forWordRange: NSRange, in_: string, orthography?: NSOrthography): string;
        learnWord(_: string): void;
        menuForResultStringOptionsAtLocationInView(for_: NSTextCheckingResult, string: string, options?: Map<string, any>, atLocation?: CGPoint, in_?: NSView): NSMenu;
        preventsAutocorrectionBeforeStringLanguage(before: string, language?: string): boolean;
        recordResponseToCorrectionForWordLanguageInSpellDocumentWithTag(_: NSSpellChecker.CorrectionResponse, toCorrection: string, forWord: string, language?: string, inSpellDocumentWithTag?: number): void;
        requestCandidatesWithForSelectedRangeInTypesOptionsInSpellDocumentWithTagCompletionHandler(forSelectedRange: NSRange, in_: string, types: number, options?: Map<string, any>, inSpellDocumentWithTag?: number, completionHandler?: (p1: number, p2: NSTextCheckingResult[]) => void): number;
        requestCheckingOfRangeTypesOptionsInSpellDocumentWithTagCompletionHandler(of: string, range: NSRange, types: number, options?: Map<string, any>, inSpellDocumentWithTag?: number, completionHandler?: (p1: number, p2: NSTextCheckingResult[], p3: NSOrthography, p4: number) => void): number;
        setIgnoredWordsInSpellDocumentWithTag(_: string[], inSpellDocumentWithTag: number): void;
        setLanguage(_: string): boolean;
        setWordFieldStringValue(_: string): void;
        showCorrectionIndicatorOfPrimaryStringAlternativeStringsForStringInViewCompletionHandler(of: NSSpellChecker.CorrectionIndicatorType, primaryString: string, alternativeStrings: string[], forStringIn: CGRect, view: NSView, completionHandler?: (p1: string) => void): void;
        unlearnWord(_: string): void;
        updatePanels(): void;
        updateSpellingPanelWithGrammarStringDetail(withGrammarString: string, detail: Map<string, any>): void;
        updateSpellingPanelWithMisspelledWord(withMisspelledWord: string): void;
        userQuotesArrayForLanguage(forLanguage: string): string[];
    }
    class NSSplitView extends NSView {
        arrangedSubviews: NSView[];
        arrangesAllSubviews: boolean;
        setArrangesAllSubviews(_: boolean): any;
        autosaveName: string;
        setAutosaveName(_: string): any;
        delegate: NSSplitViewDelegate;
        setDelegate(_: NSSplitViewDelegate): any;
        dividerColor: NSColor;
        dividerStyle: NSSplitView.DividerStyle;
        setDividerStyle(_: NSSplitView.DividerStyle): any;
        dividerThickness: number;
        isVertical: boolean;
        setVertical(_: boolean): any;
        addArrangedSubview(_: NSView): void;
        adjustSubviews(): void;
        drawDividerInRect(in_: CGRect): void;
        holdingPriorityForSubviewAtIndex(at: number): number;
        insertArrangedSubviewAtIndex(_: NSView, at: number): void;
        isSubviewCollapsed(_: NSView): boolean;
        maxPossiblePositionOfDividerAtIndex(at: number): number;
        minPossiblePositionOfDividerAtIndex(at: number): number;
        removeArrangedSubview(_: NSView): void;
        setHoldingPriorityForSubviewAtIndex(_: number, forSubviewAt: number): void;
        setPositionOfDividerAtIndex(_: number, ofDividerAt: number): void;
    }
    class NSSplitViewController extends NSViewController {
        minimumThicknessForInlineSidebars: number;
        setMinimumThicknessForInlineSidebars(_: number): any;
        splitView: NSSplitView;
        setSplitView(_: NSSplitView): any;
        splitViewItems: NSSplitViewItem[];
        setSplitViewItems(_: NSSplitViewItem[]): any;
        addSplitViewItem(_: NSSplitViewItem): void;
        insertSplitViewItemAtIndex(_: NSSplitViewItem, at: number): void;
        removeSplitViewItem(_: NSSplitViewItem): void;
        splitViewItemForViewController(for_: NSViewController): NSSplitViewItem;
        toggleSidebar(_?: any): void;
    }
    interface NSSplitViewDelegate extends NSObject {
        splitViewShouldHideDividerAtIndex?(_: NSSplitView, shouldHideDividerAt: number): boolean;
        splitViewEffectiveRectForDrawnRectOfDividerAtIndex?(_: NSSplitView, effectiveRect: CGRect, forDrawnRect: CGRect, ofDividerAt: number): CGRect;
        splitViewAdditionalEffectiveRectOfDividerAtIndex?(_: NSSplitView, additionalEffectiveRectOfDividerAt: number): CGRect;
        splitViewCanCollapseSubview?(_: NSSplitView, canCollapseSubview: NSView): boolean;
        splitViewConstrainMaxCoordinateOfSubviewAt?(_: NSSplitView, constrainMaxCoordinate: number, ofSubviewAt: number): number;
        splitViewConstrainMinCoordinateOfSubviewAt?(_: NSSplitView, constrainMinCoordinate: number, ofSubviewAt: number): number;
        splitViewConstrainSplitPositionOfSubviewAt?(_: NSSplitView, constrainSplitPosition: number, ofSubviewAt: number): number;
        splitViewResizeSubviewsWithOldSize?(_: NSSplitView, resizeSubviewsWithOldSize: CGSize): void;
        splitViewShouldAdjustSizeOfSubview?(_: NSSplitView, shouldAdjustSizeOfSubview: NSView): boolean;
        splitViewDidResizeSubviews?(_: NSNotification): void;
        splitViewWillResizeSubviews?(_: NSNotification): void;
    }
    class NSSplitViewItem extends NSObject {
        static contentListWithViewController(contentListWithViewController: NSViewController): NSSplitViewItem;
        static sidebarWithViewController(sidebarWithViewController: NSViewController): NSSplitViewItem;
        automaticMaximumThickness: number;
        setAutomaticMaximumThickness(_: number): any;
        behavior: NSSplitViewItem.Behavior;
        canCollapse: boolean;
        setCanCollapse(_: boolean): any;
        collapseBehavior: NSSplitViewItem.CollapseBehavior;
        setCollapseBehavior(_: NSSplitViewItem.CollapseBehavior): any;
        isCollapsed: boolean;
        setCollapsed(_: boolean): any;
        holdingPriority: number;
        setHoldingPriority(_: number): any;
        maximumThickness: number;
        setMaximumThickness(_: number): any;
        minimumThickness: number;
        setMinimumThickness(_: number): any;
        preferredThicknessFraction: number;
        setPreferredThicknessFraction(_: number): any;
        isSpringLoaded: boolean;
        setSpringLoaded(_: boolean): any;
        viewController: NSViewController;
        setViewController(_: NSViewController): any;
    }
    interface NSSpringLoadingDestination extends NSObject {
        draggingEnded?(_: NSDraggingInfo): void;
        springLoadingActivatedDraggingInfo(_: boolean, draggingInfo: NSDraggingInfo): void;
        springLoadingEntered?(_: NSDraggingInfo): NSSpringLoadingOptions;
        springLoadingExited?(_: NSDraggingInfo): void;
        springLoadingHighlightChanged(_: NSDraggingInfo): void;
        springLoadingUpdated?(_: NSDraggingInfo): NSSpringLoadingOptions;
    }
    class NSStackView extends NSView {
        alignment: NSLayoutConstraint.Attribute;
        setAlignment(_: NSLayoutConstraint.Attribute): any;
        arrangedSubviews: NSView[];
        delegate: NSStackViewDelegate;
        setDelegate(_: NSStackViewDelegate): any;
        detachedViews: NSView[];
        detachesHiddenViews: boolean;
        setDetachesHiddenViews(_: boolean): any;
        distribution: NSStackView.Distribution;
        setDistribution(_: NSStackView.Distribution): any;
        edgeInsets: NSEdgeInsets;
        setEdgeInsets(_: NSEdgeInsets): any;
        orientation: NSUserInterfaceLayoutOrientation;
        setOrientation(_: NSUserInterfaceLayoutOrientation): any;
        spacing: number;
        setSpacing(_: number): any;
        views: NSView[];
        addArrangedSubview(_: NSView): void;
        addViewInGravity(_: NSView, in_: NSStackView.Gravity): void;
        clippingResistancePriorityForOrientation(for_: NSLayoutConstraint.Orientation): number;
        customSpacingAfterView(after: NSView): number;
        huggingPriorityForOrientation(for_: NSLayoutConstraint.Orientation): number;
        insertArrangedSubviewAtIndex(_: NSView, at: number): void;
        insertViewAtIndexInGravity(_: NSView, at: number, in_: NSStackView.Gravity): void;
        removeArrangedSubview(_: NSView): void;
        removeView(_: NSView): void;
        setClippingResistancePriorityForOrientation(_: number, for_: NSLayoutConstraint.Orientation): void;
        setCustomSpacingAfterView(_: number, after: NSView): void;
        setHuggingPriorityForOrientation(_: number, for_: NSLayoutConstraint.Orientation): void;
        setViewsInGravity(_: NSView[], in_: NSStackView.Gravity): void;
        setVisibilityPriorityForView(_: number, for_: NSView): void;
        viewsInGravity(in_: NSStackView.Gravity): NSView[];
        visibilityPriorityForView(for_: NSView): number;
    }
    interface NSStackViewDelegate extends NSObject {
        stackViewWillDetachViews?(_: NSStackView, willDetach: NSView[]): void;
        stackViewDidReattachViews?(_: NSStackView, didReattach: NSView[]): void;
    }
    interface NSStandardKeyBindingResponding extends NSObject {
        cancelOperation?(_?: any): void;
        capitalizeWord?(_?: any): void;
        centerSelectionInVisibleArea?(_?: any): void;
        changeCaseOfLetter?(_?: any): void;
        complete?(_?: any): void;
        deleteBackward?(_?: any): void;
        deleteBackwardByDecomposingPreviousCharacter?(_?: any): void;
        deleteForward?(_?: any): void;
        deleteToBeginningOfLine?(_?: any): void;
        deleteToBeginningOfParagraph?(_?: any): void;
        deleteToEndOfLine?(_?: any): void;
        deleteToEndOfParagraph?(_?: any): void;
        deleteToMark?(_?: any): void;
        deleteWordBackward?(_?: any): void;
        deleteWordForward?(_?: any): void;
        doCommandBySelector?(by: string): void;
        indent?(_?: any): void;
        insertBacktab?(_?: any): void;
        insertContainerBreak?(_?: any): void;
        insertDoubleQuoteIgnoringSubstitution?(_?: any): void;
        insertLineBreak?(_?: any): void;
        insertNewline?(_?: any): void;
        insertNewlineIgnoringFieldEditor?(_?: any): void;
        insertParagraphSeparator?(_?: any): void;
        insertSingleQuoteIgnoringSubstitution?(_?: any): void;
        insertTab?(_?: any): void;
        insertTabIgnoringFieldEditor?(_?: any): void;
        insertText?(_: any): void;
        lowercaseWord?(_?: any): void;
        makeBaseWritingDirectionLeftToRight?(_?: any): void;
        makeBaseWritingDirectionNatural?(_?: any): void;
        makeBaseWritingDirectionRightToLeft?(_?: any): void;
        makeTextWritingDirectionLeftToRight?(_?: any): void;
        makeTextWritingDirectionNatural?(_?: any): void;
        makeTextWritingDirectionRightToLeft?(_?: any): void;
        moveBackward?(_?: any): void;
        moveBackwardAndModifySelection?(_?: any): void;
        moveDown?(_?: any): void;
        moveDownAndModifySelection?(_?: any): void;
        moveForward?(_?: any): void;
        moveForwardAndModifySelection?(_?: any): void;
        moveLeft?(_?: any): void;
        moveLeftAndModifySelection?(_?: any): void;
        moveParagraphBackwardAndModifySelection?(_?: any): void;
        moveParagraphForwardAndModifySelection?(_?: any): void;
        moveRight?(_?: any): void;
        moveRightAndModifySelection?(_?: any): void;
        moveToBeginningOfDocument?(_?: any): void;
        moveToBeginningOfDocumentAndModifySelection?(_?: any): void;
        moveToBeginningOfLine?(_?: any): void;
        moveToBeginningOfLineAndModifySelection?(_?: any): void;
        moveToBeginningOfParagraph?(_?: any): void;
        moveToBeginningOfParagraphAndModifySelection?(_?: any): void;
        moveToEndOfDocument?(_?: any): void;
        moveToEndOfDocumentAndModifySelection?(_?: any): void;
        moveToEndOfLine?(_?: any): void;
        moveToEndOfLineAndModifySelection?(_?: any): void;
        moveToEndOfParagraph?(_?: any): void;
        moveToEndOfParagraphAndModifySelection?(_?: any): void;
        moveToLeftEndOfLine?(_?: any): void;
        moveToLeftEndOfLineAndModifySelection?(_?: any): void;
        moveToRightEndOfLine?(_?: any): void;
        moveToRightEndOfLineAndModifySelection?(_?: any): void;
        moveUp?(_?: any): void;
        moveUpAndModifySelection?(_?: any): void;
        moveWordBackward?(_?: any): void;
        moveWordBackwardAndModifySelection?(_?: any): void;
        moveWordForward?(_?: any): void;
        moveWordForwardAndModifySelection?(_?: any): void;
        moveWordLeft?(_?: any): void;
        moveWordLeftAndModifySelection?(_?: any): void;
        moveWordRight?(_?: any): void;
        moveWordRightAndModifySelection?(_?: any): void;
        pageDown?(_?: any): void;
        pageDownAndModifySelection?(_?: any): void;
        pageUp?(_?: any): void;
        pageUpAndModifySelection?(_?: any): void;
        quickLookPreviewItems?(_?: any): void;
        scrollLineDown?(_?: any): void;
        scrollLineUp?(_?: any): void;
        scrollPageDown?(_?: any): void;
        scrollPageUp?(_?: any): void;
        scrollToBeginningOfDocument?(_?: any): void;
        scrollToEndOfDocument?(_?: any): void;
        selectAll?(_?: any): void;
        selectLine?(_?: any): void;
        selectParagraph?(_?: any): void;
        selectToMark?(_?: any): void;
        selectWord?(_?: any): void;
        setMark?(_?: any): void;
        swapWithMark?(_?: any): void;
        transpose?(_?: any): void;
        transposeWords?(_?: any): void;
        uppercaseWord?(_?: any): void;
        yank?(_?: any): void;
    }
    class NSStatusBar extends NSObject {
        thickness: number;
        isVertical: boolean;
        static systemStatusBar: NSStatusBar;
        removeStatusItem(_: NSStatusItem): void;
        statusItemWithLength(withLength: number): NSStatusItem;
    }
    class NSStatusBarButton extends NSButton {
        appearsDisabled: boolean;
        setAppearsDisabled(_: boolean): any;
    }
    class NSStatusItem extends NSObject {
        autosaveName: string;
        setAutosaveName(_: string): any;
        behavior: NSStatusItem.Behavior;
        setBehavior(_: NSStatusItem.Behavior): any;
        button: NSStatusBarButton;
        length: number;
        setLength(_: number): any;
        menu: NSMenu;
        setMenu(_: NSMenu): any;
        statusBar: NSStatusBar;
        isVisible: boolean;
        setVisible(_: boolean): any;
    }
    class NSStepper extends NSControl {
        autorepeat: boolean;
        setAutorepeat(_: boolean): any;
        increment: number;
        setIncrement(_: number): any;
        maxValue: number;
        setMaxValue(_: number): any;
        minValue: number;
        setMinValue(_: number): any;
        valueWraps: boolean;
        setValueWraps(_: boolean): any;
    }
    class NSStepperCell extends NSActionCell {
        autorepeat: boolean;
        setAutorepeat(_: boolean): any;
        increment: number;
        setIncrement(_: number): any;
        maxValue: number;
        setMaxValue(_: number): any;
        minValue: number;
        setMinValue(_: number): any;
        valueWraps: boolean;
        setValueWraps(_: boolean): any;
    }
    class NSStepperTouchBarItem extends NSTouchBarItem {
        action: string;
        setAction(_: string): any;
        increment: number;
        setIncrement(_: number): any;
        maxValue: number;
        setMaxValue(_: number): any;
        minValue: number;
        setMinValue(_: number): any;
        target: any;
        setTarget(_: any): any;
        value: number;
        setValue(_: number): any;
    }
    class NSStoryboard extends NSObject {
        static mainStoryboard: NSStoryboard;
        instantiateControllerWithIdentifier(withIdentifier: string): any;
        instantiateControllerWithIdentifierWithCreator(_: string, creator?: (p1: NSCoder) => any): any;
        instantiateInitialController(): any;
        instantiateInitialControllerWithCreator(_?: (p1: NSCoder) => any): any;
    }
    class NSStoryboardSegue extends NSObject {
        destinationController: any;
        identifier: string;
        sourceController: any;
        static createWithIdentifierSourceDestination(identifier: string, source: any, destination: any): NSStoryboardSegue;
        perform(): void;
    }
    class NSStringDrawingContext extends NSObject {
        actualScaleFactor: number;
        minimumScaleFactor: number;
        setMinimumScaleFactor(_: number): any;
        totalBounds: CGRect;
    }
    class NSSwitch extends NSControl {
        state: number;
        setState(_: number): any;
    }
    class NSTabView extends NSView {
        allowsTruncatedLabels: boolean;
        setAllowsTruncatedLabels(_: boolean): any;
        contentRect: CGRect;
        controlSize: NSControl.ControlSize;
        setControlSize(_: NSControl.ControlSize): any;
        delegate: NSTabViewDelegate;
        setDelegate(_: NSTabViewDelegate): any;
        drawsBackground: boolean;
        setDrawsBackground(_: boolean): any;
        font: NSFont;
        setFont(_: NSFont): any;
        minimumSize: CGSize;
        numberOfTabViewItems: number;
        selectedTabViewItem: NSTabViewItem;
        tabPosition: NSTabView.TabPosition;
        setTabPosition(_: NSTabView.TabPosition): any;
        tabViewBorderType: NSTabView.TabViewBorderType;
        setTabViewBorderType(_: NSTabView.TabViewBorderType): any;
        tabViewItems: NSTabViewItem[];
        setTabViewItems(_: NSTabViewItem[]): any;
        tabViewType: NSTabView.TabType;
        setTabViewType(_: NSTabView.TabType): any;
        addTabViewItem(_: NSTabViewItem): void;
        indexOfTabViewItem(_: NSTabViewItem): number;
        indexOfTabViewItemWithIdentifier(withIdentifier: any): number;
        insertTabViewItemAtIndex(_: NSTabViewItem, at: number): void;
        removeTabViewItem(_: NSTabViewItem): void;
        selectFirstTabViewItem(_?: any): void;
        selectLastTabViewItem(_?: any): void;
        selectNextTabViewItem(_?: any): void;
        selectPreviousTabViewItem(_?: any): void;
        selectTabViewItem(_?: NSTabViewItem): void;
        selectTabViewItemAtIndex(at: number): void;
        selectTabViewItemWithIdentifier(withIdentifier: any): void;
        tabViewItemAtIndex(at: number): NSTabViewItem;
        tabViewItemAtPoint(at: CGPoint): NSTabViewItem;
        takeSelectedTabViewItemFromSender(_?: any): void;
    }
    class NSTabViewController extends NSViewController {
        canPropagateSelectedChildViewControllerTitle: boolean;
        setCanPropagateSelectedChildViewControllerTitle(_: boolean): any;
        selectedTabViewItemIndex: number;
        setSelectedTabViewItemIndex(_: number): any;
        tabStyle: NSTabViewController.TabStyle;
        setTabStyle(_: NSTabViewController.TabStyle): any;
        tabView: NSTabView;
        setTabView(_: NSTabView): any;
        tabViewItems: NSTabViewItem[];
        setTabViewItems(_: NSTabViewItem[]): any;
        transitionOptions: NSViewController.TransitionOptions;
        setTransitionOptions(_: NSViewController.TransitionOptions): any;
        addTabViewItem(_: NSTabViewItem): void;
        insertTabViewItemAtIndex(_: NSTabViewItem, at: number): void;
        removeTabViewItem(_: NSTabViewItem): void;
        tabViewItemForViewController(for_: NSViewController): NSTabViewItem;
    }
    interface NSTabViewDelegate extends NSObject {
        tabViewShouldSelectTabViewItem?(_: NSTabView, shouldSelect?: NSTabViewItem): boolean;
        tabViewWillSelectTabViewItem?(_: NSTabView, willSelect?: NSTabViewItem): void;
        tabViewDidSelectTabViewItem?(_: NSTabView, didSelect?: NSTabViewItem): void;
        tabViewDidChangeNumberOfTabViewItems?(_: NSTabView): void;
    }
    class NSTabViewItem extends NSObject {
        color: NSColor;
        setColor(_: NSColor): any;
        identifier: any;
        setIdentifier(_: any): any;
        image: NSImage;
        setImage(_: NSImage): any;
        initialFirstResponder: NSView;
        setInitialFirstResponder(_: NSView): any;
        label: string;
        setLabel(_: string): any;
        tabState: NSTabViewItem.State;
        tabView: NSTabView;
        toolTip: string;
        setToolTip(_: string): any;
        view: NSView;
        setView(_: NSView): any;
        viewController: NSViewController;
        setViewController(_: NSViewController): any;
        drawLabelInRect(_: boolean, in_: CGRect): void;
        static createWithIdentifier(identifier?: any): NSTabViewItem;
        sizeOfLabel(_: boolean): CGSize;
    }
    class NSTableCellView extends NSView {
        backgroundStyle: NSView.BackgroundStyle;
        setBackgroundStyle(_: NSView.BackgroundStyle): any;
        draggingImageComponents: NSDraggingImageComponent[];
        imageView: NSImageView;
        setImageView(_: NSImageView): any;
        objectValue: any;
        setObjectValue(_: any): any;
        rowSizeStyle: NSTableView.RowSizeStyle;
        setRowSizeStyle(_: NSTableView.RowSizeStyle): any;
        textField: NSTextField;
        setTextField(_: NSTextField): any;
    }
    class NSTableColumn extends NSObject {
        dataCell: any;
        setDataCell(_: any): any;
        isEditable: boolean;
        setEditable(_: boolean): any;
        headerCell: NSTableHeaderCell;
        setHeaderCell(_: NSTableHeaderCell): any;
        headerToolTip: string;
        setHeaderToolTip(_: string): any;
        isHidden: boolean;
        setHidden(_: boolean): any;
        maxWidth: number;
        setMaxWidth(_: number): any;
        minWidth: number;
        setMinWidth(_: number): any;
        resizingMask: NSTableColumn.ResizingOptions;
        setResizingMask(_: NSTableColumn.ResizingOptions): any;
        sortDescriptorPrototype: NSSortDescriptor;
        setSortDescriptorPrototype(_: NSSortDescriptor): any;
        tableView: NSTableView;
        setTableView(_: NSTableView): any;
        title: string;
        setTitle(_: string): any;
        width: number;
        setWidth(_: number): any;
        dataCellForRow(forRow: number): any;
        static createWithIdentifier(identifier: string): NSTableColumn;
        sizeToFit(): void;
    }
    class NSTableHeaderCell extends NSTextFieldCell {
        drawSortIndicatorWithFrameInViewAscendingPriority(withFrame: CGRect, in_: NSView, ascending: boolean, priority: number): void;
        sortIndicatorRectForBounds(forBounds: CGRect): CGRect;
    }
    class NSTableHeaderView extends NSView {
        draggedColumn: number;
        draggedDistance: number;
        resizedColumn: number;
        tableView: NSTableView;
        setTableView(_: NSTableView): any;
        columnAtPoint(at: CGPoint): number;
        headerRectOfColumn(ofColumn: number): CGRect;
    }
    class NSTableRowView extends NSView {
        backgroundColor: NSColor;
        setBackgroundColor(_: NSColor): any;
        draggingDestinationFeedbackStyle: NSTableView.DraggingDestinationFeedbackStyle;
        setDraggingDestinationFeedbackStyle(_: NSTableView.DraggingDestinationFeedbackStyle): any;
        isEmphasized: boolean;
        setEmphasized(_: boolean): any;
        isFloating: boolean;
        setFloating(_: boolean): any;
        isGroupRowStyle: boolean;
        setGroupRowStyle(_: boolean): any;
        indentationForDropOperation: number;
        setIndentationForDropOperation(_: number): any;
        interiorBackgroundStyle: NSView.BackgroundStyle;
        isNextRowSelected: boolean;
        setNextRowSelected(_: boolean): any;
        numberOfColumns: number;
        isPreviousRowSelected: boolean;
        setPreviousRowSelected(_: boolean): any;
        isSelected: boolean;
        setSelected(_: boolean): any;
        selectionHighlightStyle: NSTableView.SelectionHighlightStyle;
        setSelectionHighlightStyle(_: NSTableView.SelectionHighlightStyle): any;
        isTargetForDropOperation: boolean;
        setTargetForDropOperation(_: boolean): any;
        drawBackgroundInRect(in_: CGRect): void;
        drawDraggingDestinationFeedbackInRect(in_: CGRect): void;
        drawSelectionInRect(in_: CGRect): void;
        drawSeparatorInRect(in_: CGRect): void;
        viewAtColumn(atColumn: number): any;
    }
    class NSTableView extends NSControl {
        allowsColumnReordering: boolean;
        setAllowsColumnReordering(_: boolean): any;
        allowsColumnResizing: boolean;
        setAllowsColumnResizing(_: boolean): any;
        allowsColumnSelection: boolean;
        setAllowsColumnSelection(_: boolean): any;
        allowsEmptySelection: boolean;
        setAllowsEmptySelection(_: boolean): any;
        allowsMultipleSelection: boolean;
        setAllowsMultipleSelection(_: boolean): any;
        allowsTypeSelect: boolean;
        setAllowsTypeSelect(_: boolean): any;
        autosaveName: string;
        setAutosaveName(_: string): any;
        autosaveTableColumns: boolean;
        setAutosaveTableColumns(_: boolean): any;
        backgroundColor: NSColor;
        setBackgroundColor(_: NSColor): any;
        clickedColumn: number;
        clickedRow: number;
        columnAutoresizingStyle: NSTableView.ColumnAutoresizingStyle;
        setColumnAutoresizingStyle(_: NSTableView.ColumnAutoresizingStyle): any;
        cornerView: NSView;
        setCornerView(_: NSView): any;
        dataSource: NSTableViewDataSource;
        setDataSource(_: NSTableViewDataSource): any;
        delegate: NSTableViewDelegate;
        setDelegate(_: NSTableViewDelegate): any;
        doubleAction: string;
        setDoubleAction(_: string): any;
        draggingDestinationFeedbackStyle: NSTableView.DraggingDestinationFeedbackStyle;
        setDraggingDestinationFeedbackStyle(_: NSTableView.DraggingDestinationFeedbackStyle): any;
        editedColumn: number;
        editedRow: number;
        effectiveRowSizeStyle: NSTableView.RowSizeStyle;
        floatsGroupRows: boolean;
        setFloatsGroupRows(_: boolean): any;
        gridColor: NSColor;
        setGridColor(_: NSColor): any;
        gridStyleMask: NSTableView.GridLineStyle;
        setGridStyleMask(_: NSTableView.GridLineStyle): any;
        headerView: NSTableHeaderView;
        setHeaderView(_: NSTableHeaderView): any;
        hiddenRowIndexes: NSIndexSet;
        highlightedTableColumn: NSTableColumn;
        setHighlightedTableColumn(_: NSTableColumn): any;
        intercellSpacing: CGSize;
        setIntercellSpacing(_: CGSize): any;
        numberOfColumns: number;
        numberOfRows: number;
        numberOfSelectedColumns: number;
        numberOfSelectedRows: number;
        registeredNibsByIdentifier: Map<string, NSNib>;
        rowActionsVisible: boolean;
        setRowActionsVisible(_: boolean): any;
        rowHeight: number;
        setRowHeight(_: number): any;
        rowSizeStyle: NSTableView.RowSizeStyle;
        setRowSizeStyle(_: NSTableView.RowSizeStyle): any;
        selectedColumn: number;
        selectedColumnIndexes: NSIndexSet;
        selectedRow: number;
        selectedRowIndexes: NSIndexSet;
        selectionHighlightStyle: NSTableView.SelectionHighlightStyle;
        setSelectionHighlightStyle(_: NSTableView.SelectionHighlightStyle): any;
        sortDescriptors: NSSortDescriptor[];
        setSortDescriptors(_: NSSortDescriptor[]): any;
        tableColumns: NSTableColumn[];
        usesAlternatingRowBackgroundColors: boolean;
        setUsesAlternatingRowBackgroundColors(_: boolean): any;
        usesAutomaticRowHeights: boolean;
        setUsesAutomaticRowHeights(_: boolean): any;
        usesStaticContents: boolean;
        setUsesStaticContents(_: boolean): any;
        verticalMotionCanBeginDrag: boolean;
        setVerticalMotionCanBeginDrag(_: boolean): any;
        addTableColumn(_: NSTableColumn): void;
        beginUpdates(): void;
        canDragRowsWithIndexesAtPoint(with_: NSIndexSet, at: CGPoint): boolean;
        columnAtPoint(at: CGPoint): number;
        columnForView(for_: NSView): number;
        columnIndexesInRect(in_: CGRect): NSIndexSet;
        columnWithIdentifier(withIdentifier: string): number;
        deselectAll(_?: any): void;
        deselectColumn(_: number): void;
        deselectRow(_: number): void;
        didAddRowViewForRow(_: NSTableRowView, forRow: number): void;
        didRemoveRowViewForRow(_: NSTableRowView, forRow: number): void;
        dragImageForRowsWithIndexesTableColumnsEventOffset(with_: NSIndexSet, tableColumns: NSTableColumn[], event: NSEvent, offset: NSPoint): NSImage;
        drawBackgroundInClipRect(inClipRect: CGRect): void;
        drawGridInClipRect(inClipRect: CGRect): void;
        drawRowClipRect(_: number, clipRect: CGRect): void;
        editColumnRowWithEventSelect(_: number, row: number, with_?: NSEvent, select?: boolean): void;
        endUpdates(): void;
        enumerateAvailableRowViews(_: (p1: NSTableRowView, p2: number) => void): void;
        frameOfCellAtColumnRow(atColumn: number, row: number): CGRect;
        hideRowsAtIndexesWithAnimation(at: NSIndexSet, withAnimation: NSTableView.AnimationOptions): void;
        highlightSelectionInClipRect(inClipRect: CGRect): void;
        indicatorImageInTableColumn(in_: NSTableColumn): NSImage;
        insertRowsAtIndexesWithAnimation(at: NSIndexSet, withAnimation: NSTableView.AnimationOptions): void;
        isColumnSelected(_: number): boolean;
        isRowSelected(_: number): boolean;
        makeViewWithIdentifierOwner(withIdentifier: string, owner?: any): NSView;
        moveColumnToColumn(_: number, toColumn: number): void;
        moveRowAtIndexToIndex(at: number, to: number): void;
        noteHeightOfRowsWithIndexesChanged(withIndexesChanged: NSIndexSet): void;
        noteNumberOfRowsChanged(): void;
        rectOfColumn(ofColumn: number): CGRect;
        rectOfRow(ofRow: number): CGRect;
        registerNibForIdentifier(_?: NSNib, forIdentifier?: string): void;
        reloadData(): void;
        reloadDataForRowIndexesColumnIndexes(forRowIndexes: NSIndexSet, columnIndexes: NSIndexSet): void;
        removeRowsAtIndexesWithAnimation(at: NSIndexSet, withAnimation: NSTableView.AnimationOptions): void;
        removeTableColumn(_: NSTableColumn): void;
        rowAtPoint(at: CGPoint): number;
        rowForView(for_: NSView): number;
        rowViewAtRowMakeIfNecessary(atRow: number, makeIfNecessary: boolean): NSTableRowView;
        rowsInRect(in_: CGRect): NSRange;
        scrollColumnToVisible(_: number): void;
        scrollRowToVisible(_: number): void;
        selectColumnIndexesByExtendingSelection(_: NSIndexSet, byExtendingSelection: boolean): void;
        selectRowIndexesByExtendingSelection(_: NSIndexSet, byExtendingSelection: boolean): void;
        setDraggingSourceOperationMaskForLocal(_: NSDragOperation, forLocal: boolean): void;
        setDropRowDropOperation(_: number, dropOperation: NSTableView.DropOperation): void;
        setIndicatorImageInTableColumn(_?: NSImage, in_?: NSTableColumn): void;
        sizeLastColumnToFit(): void;
        tableColumnWithIdentifier(withIdentifier: string): NSTableColumn;
        tile(): void;
        unhideRowsAtIndexesWithAnimation(at: NSIndexSet, withAnimation: NSTableView.AnimationOptions): void;
        viewAtColumnRowMakeIfNecessary(atColumn: number, row: number, makeIfNecessary: boolean): NSView;
    }
    interface NSTableViewDataSource extends NSObject {
        numberOfRowsInTableView?(in_: NSTableView): number;
        tableViewObjectValueForTableColumnRow?(_: NSTableView, objectValueFor?: NSTableColumn, row?: number): any;
        tableViewSetObjectValueForTableColumnRow?(_: NSTableView, setObjectValue?: any, for_?: NSTableColumn, row?: number): void;
        tableViewDraggingSessionWillBeginAtPointForRowIndexes?(_: NSTableView, draggingSession: NSDraggingSession, willBeginAt: CGPoint, forRowIndexes: NSIndexSet): void;
        tableViewDraggingSessionEndedAtPointOperation?(_: NSTableView, draggingSession: NSDraggingSession, endedAt: CGPoint, operation: NSDragOperation): void;
        tableViewWriteRowsWithIndexesToPasteboard?(_: NSTableView, writeRowsWith: NSIndexSet, to: NSPasteboard): boolean;
        tableViewAcceptDropRowDropOperation?(_: NSTableView, acceptDrop: NSDraggingInfo, row: number, dropOperation: NSTableView.DropOperation): boolean;
        tableViewPasteboardWriterForRow?(_: NSTableView, pasteboardWriterForRow: number): NSPasteboardWriting;
        tableViewSortDescriptorsDidChange?(_: NSTableView, sortDescriptorsDidChange: NSSortDescriptor[]): void;
        tableViewUpdateDraggingItemsForDrag?(_: NSTableView, updateDraggingItemsForDrag: NSDraggingInfo): void;
        tableViewValidateDropProposedRowProposedDropOperation?(_: NSTableView, validateDrop: NSDraggingInfo, proposedRow: number, proposedDropOperation: NSTableView.DropOperation): NSDragOperation;
    }
    interface NSTableViewDelegate extends NSControlTextEditingDelegate {
        selectionShouldChangeInTableView?(in_: NSTableView): boolean;
        tableViewViewForTableColumnRow?(_: NSTableView, viewFor?: NSTableColumn, row?: number): NSView;
        tableViewDidAddRowViewForRow?(_: NSTableView, didAdd: NSTableRowView, forRow: number): void;
        tableViewDidRemoveRowViewForRow?(_: NSTableView, didRemove: NSTableRowView, forRow: number): void;
        tableViewWillDisplayCellForTableColumnRow?(_: NSTableView, willDisplayCell: any, for_?: NSTableColumn, row?: number): void;
        tableViewShouldEditTableColumnRow?(_: NSTableView, shouldEdit?: NSTableColumn, row?: number): boolean;
        tableViewToolTipForCellRectTableColumnRowMouseLocation?(_: NSTableView, toolTipFor: NSCell, rect: NSRect, tableColumn?: NSTableColumn, row?: number, mouseLocation?: CGPoint): string;
        tableViewShouldShowCellExpansionForTableColumnRow?(_: NSTableView, shouldShowCellExpansionFor?: NSTableColumn, row?: number): boolean;
        tableViewShouldTrackCellForTableColumnRow?(_: NSTableView, shouldTrackCell: NSCell, for_?: NSTableColumn, row?: number): boolean;
        tableViewDataCellForTableColumnRow?(_: NSTableView, dataCellFor?: NSTableColumn, row?: number): NSCell;
        tableViewShouldSelectTableColumn?(_: NSTableView, shouldSelect?: NSTableColumn): boolean;
        tableViewMouseDownInHeaderOfTableColumn?(_: NSTableView, mouseDownInHeaderOf: NSTableColumn): void;
        tableViewDidClickTableColumn?(_: NSTableView, didClick: NSTableColumn): void;
        tableViewDidDragTableColumn?(_: NSTableView, didDrag: NSTableColumn): void;
        tableViewTypeSelectStringForTableColumnRow?(_: NSTableView, typeSelectStringFor?: NSTableColumn, row?: number): string;
        tableViewNextTypeSelectMatchFromRowToRowForString?(_: NSTableView, nextTypeSelectMatchFromRow: number, toRow: number, for_: string): number;
        tableViewShouldTypeSelectForEventWithCurrentSearchString?(_: NSTableView, shouldTypeSelectFor: NSEvent, withCurrentSearch?: string): boolean;
        tableViewHeightOfRow?(_: NSTableView, heightOfRow: number): number;
        tableViewIsGroupRow?(_: NSTableView, isGroupRow: number): boolean;
        tableViewRowActionsForRowEdge?(_: NSTableView, rowActionsForRow: number, edge: NSTableView.RowActionEdge): NSTableViewRowAction[];
        tableViewRowViewForRow?(_: NSTableView, rowViewForRow: number): NSTableRowView;
        tableViewSelectionIndexesForProposedSelection?(_: NSTableView, selectionIndexesForProposedSelection: NSIndexSet): NSIndexSet;
        tableViewShouldReorderColumnToColumn?(_: NSTableView, shouldReorderColumn: number, toColumn: number): boolean;
        tableViewShouldSelectRow?(_: NSTableView, shouldSelectRow: number): boolean;
        tableViewSizeToFitWidthOfColumn?(_: NSTableView, sizeToFitWidthOfColumn: number): number;
        tableViewColumnDidMove?(_: NSNotification): void;
        tableViewColumnDidResize?(_: NSNotification): void;
        tableViewSelectionDidChange?(_: NSNotification): void;
        tableViewSelectionIsChanging?(_: NSNotification): void;
    }
    class NSTableViewRowAction extends NSObject {
        backgroundColor: NSColor;
        setBackgroundColor(_: NSColor): any;
        image: NSImage;
        setImage(_: NSImage): any;
        style: NSTableViewRowAction.Style;
        title: string;
        setTitle(_: string): any;
    }
    class NSText extends NSView {
        alignment: NSTextAlignment;
        setAlignment(_: NSTextAlignment): any;
        backgroundColor: NSColor;
        setBackgroundColor(_: NSColor): any;
        baseWritingDirection: NSWritingDirection;
        setBaseWritingDirection(_: NSWritingDirection): any;
        delegate: NSTextDelegate;
        setDelegate(_: NSTextDelegate): any;
        drawsBackground: boolean;
        setDrawsBackground(_: boolean): any;
        isEditable: boolean;
        setEditable(_: boolean): any;
        isFieldEditor: boolean;
        setFieldEditor(_: boolean): any;
        font: NSFont;
        setFont(_: NSFont): any;
        isHorizontallyResizable: boolean;
        setHorizontallyResizable(_: boolean): any;
        importsGraphics: boolean;
        setImportsGraphics(_: boolean): any;
        maxSize: CGSize;
        setMaxSize(_: CGSize): any;
        minSize: CGSize;
        setMinSize(_: CGSize): any;
        isRichText: boolean;
        setRichText(_: boolean): any;
        isRulerVisible: boolean;
        isSelectable: boolean;
        setSelectable(_: boolean): any;
        selectedRange: NSRange;
        setSelectedRange(_: NSRange): any;
        string: string;
        setString(_: string): any;
        textColor: NSColor;
        setTextColor(_: NSColor): any;
        usesFontPanel: boolean;
        setUsesFontPanel(_: boolean): any;
        isVerticallyResizable: boolean;
        setVerticallyResizable(_: boolean): any;
        RTFDFromRange(from: NSRange): NSData;
        RTFFromRange(from: NSRange): NSData;
        alignCenter(_?: any): void;
        alignLeft(_?: any): void;
        alignRight(_?: any): void;
        checkSpelling(_?: any): void;
        copyFont(_?: any): void;
        copyRuler(_?: any): void;
        cut(_?: any): void;
        delete(_?: any): void;
        paste(_?: any): void;
        pasteFont(_?: any): void;
        pasteRuler(_?: any): void;
        readRTFDFromFile(fromFile: string): boolean;
        replaceCharactersInRangeWithRTF(in_: NSRange, withRTF: NSData): void;
        replaceCharactersInRangeWithRTFD(in_: NSRange, withRTFD: NSData): void;
        replaceCharactersInRangeWithString(in_: NSRange, with_: string): void;
        scrollRangeToVisible(_: NSRange): void;
        setFontRange(_: NSFont, range: NSRange): void;
        setTextColorRange(_?: NSColor, range?: NSRange): void;
        showGuessPanel(_?: any): void;
        sizeToFit(): void;
        subscript(_?: any): void;
        superscript(_?: any): void;
        toggleRuler(_?: any): void;
        underline(_?: any): void;
        unscript(_?: any): void;
        writeRTFDToFileAtomically(toFile: string, atomically: boolean): boolean;
    }
    class NSTextAlternatives extends NSObject {
        alternativeStrings: string[];
        primaryString: string;
        static createWithPrimaryStringAlternativeStrings(primaryString: string, alternativeStrings: string[]): NSTextAlternatives;
        noteSelectedAlternativeString(_: string): void;
    }
    class NSTextAttachment extends NSObject {
        attachmentCell: NSTextAttachmentCell;
        setAttachmentCell(_: NSTextAttachmentCell): any;
        bounds: CGRect;
        setBounds(_: CGRect): any;
        contents: NSData;
        setContents(_: NSData): any;
        fileType: string;
        setFileType(_: string): any;
        fileWrapper: FileWrapper;
        setFileWrapper(_: FileWrapper): any;
        image: NSImage;
        setImage(_: NSImage): any;
        static createWithDataOfType(data?: NSData, ofType?: string): NSTextAttachment;
        static createWithFileWrapper(fileWrapper?: FileWrapper): NSTextAttachment;
    }
    class NSTextAttachmentCell extends NSCell {
    }
    interface NSTextAttachmentCell extends NSObject {
        attachment: NSTextAttachment;
        setAttachment(_: NSTextAttachment): any;
        cellBaselineOffset(): CGPoint;
        cellFrameForTextContainerProposedLineFragmentGlyphPositionCharacterIndex(_: NSTextContainer, proposedLineFragment: CGRect, glyphPosition: CGPoint, characterIndex: number): CGRect;
        cellSize_(): CGSize;
        drawWithFrameInView(_: CGRect, inView?: NSView): void;
        drawWithFrameInViewCharacterIndex(_: CGRect, inView?: NSView, characterIndex?: number): void;
        drawWithFrameInViewCharacterIndexLayoutManager(_: CGRect, inView?: NSView, characterIndex?: number, layoutManager?: NSLayoutManager): void;
        highlightWithFrameInView(_: boolean, withFrame: CGRect, inView?: NSView): void;
        trackMouseInRectOfViewAtCharacterIndexUntilMouseUp(_: NSEvent, inRect: CGRect, ofView?: NSView, atCharacterIndex?: number, untilMouseUp?: boolean): boolean;
        trackMouseInRectOfViewUntilMouseUp(_: NSEvent, inRect: CGRect, ofView?: NSView, untilMouseUp?: boolean): boolean;
        wantsToTrackMouse(): boolean;
        wantsToTrackMouseForEventInRectOfViewAtCharacterIndex(_: NSEvent, inRect: CGRect, ofView?: NSView, atCharacterIndex?: number): boolean;
    }
    interface NSTextAttachmentContainer extends NSObject {
        attachmentBoundsForTextContainerProposedLineFragmentGlyphPositionCharacterIndex(for_?: NSTextContainer, proposedLineFragment?: CGRect, glyphPosition?: CGPoint, characterIndex?: number): CGRect;
        imageForBoundsTextContainerCharacterIndex(forBounds: CGRect, textContainer?: NSTextContainer, characterIndex?: number): NSImage;
    }
    class NSTextBlock extends NSObject {
        backgroundColor: NSColor;
        setBackgroundColor(_: NSColor): any;
        contentWidth: number;
        contentWidthValueType: NSTextBlock.ValueType;
        verticalAlignment: NSTextBlock.VerticalAlignment;
        setVerticalAlignment(_: NSTextBlock.VerticalAlignment): any;
        borderColorForEdge(for_: NSRectEdge): NSColor;
        boundsRectForContentRectInRectTextContainerCharacterRange(forContentRect: CGRect, in_: CGRect, textContainer: NSTextContainer, characterRange: NSRange): CGRect;
        drawBackgroundWithFrameInViewCharacterRangeLayoutManager(withFrame: CGRect, in_: NSView, characterRange: NSRange, layoutManager: NSLayoutManager): void;
        rectForLayoutAtPointInRectTextContainerCharacterRange(at: CGPoint, in_: CGRect, textContainer: NSTextContainer, characterRange: NSRange): CGRect;
        setBorderColor(_?: NSColor): void;
        setBorderColorForEdge(_?: NSColor, for_?: NSRectEdge): void;
        setContentWidthType(_: number, type: NSTextBlock.ValueType): void;
        setValueTypeForDimension(_: number, type: NSTextBlock.ValueType, for_: NSTextBlock.Dimension): void;
        setWidthTypeForLayer(_: number, type: NSTextBlock.ValueType, for_: NSTextBlock.Layer): void;
        setWidthTypeForLayerEdge(_: number, type: NSTextBlock.ValueType, for_: NSTextBlock.Layer, edge: NSRectEdge): void;
        valueForDimension(for_: NSTextBlock.Dimension): number;
        valueTypeForDimension(for_: NSTextBlock.Dimension): NSTextBlock.ValueType;
        widthForLayerEdge(for_: NSTextBlock.Layer, edge: NSRectEdge): number;
        widthValueTypeForLayerEdge(for_: NSTextBlock.Layer, edge: NSRectEdge): NSTextBlock.ValueType;
    }
    interface NSTextCheckingClient extends NSTextInputClient, NSTextInputTraits {
        addAnnotationsRange(_: Map<string, string>, range: NSRange): void;
        annotatedSubstringForProposedRangeActualRange(forProposedRange: NSRange, actualRange?: NSRange): NSAttributedString;
        candidateListTouchBarItem(): NSCandidateListTouchBarItem<any>;
        removeAnnotationRange(_: string, range: NSRange): void;
        replaceCharactersInRangeWithAnnotatedString(in_: NSRange, withAnnotatedString: NSAttributedString): void;
        selectAndShowRange(_: NSRange): void;
        setAnnotationsRange(_: Map<string, string>, range: NSRange): void;
        viewForRangeFirstRectActualRange(for_: NSRange, firstRect?: NSRect, actualRange?: NSRange): NSView;
    }
    class NSTextCheckingController extends NSObject {
        client: NSTextCheckingClient;
        spellCheckerDocumentTag: number;
        setSpellCheckerDocumentTag(_: number): any;
        changeSpelling(_?: any): void;
        checkSpelling(_?: any): void;
        checkTextInDocument(_?: any): void;
        checkTextInRangeTypesOptions(in_: NSRange, types: number, options: Map<string, any>): void;
        checkTextInSelection(_?: any): void;
        considerTextCheckingForRange(for_: NSRange): void;
        didChangeSelectedRange(): void;
        didChangeTextInRange(in_: NSRange): void;
        ignoreSpelling(_?: any): void;
        static createWithClient(client: NSTextCheckingClient): NSTextCheckingController;
        insertedTextInRange(in_: NSRange): void;
        invalidate(): void;
        menuAtIndexClickedOnSelectionEffectiveRange(at: number, clickedOnSelection: boolean, effectiveRange: NSRange): NSMenu;
        orderFrontSubstitutionsPanel(_?: any): void;
        showGuessPanel(_?: any): void;
        updateCandidates(): void;
        validAnnotations(): string[];
    }
    class NSTextContainer extends NSObject {
        containerSize: CGSize;
        setContainerSize(_: CGSize): any;
        exclusionPaths: NSBezierPath[];
        setExclusionPaths(_: NSBezierPath[]): any;
        heightTracksTextView: boolean;
        setHeightTracksTextView(_: boolean): any;
        layoutManager: NSLayoutManager;
        setLayoutManager(_: NSLayoutManager): any;
        lineBreakMode: NSLineBreakMode;
        setLineBreakMode(_: NSLineBreakMode): any;
        lineFragmentPadding: number;
        setLineFragmentPadding(_: number): any;
        maximumNumberOfLines: number;
        setMaximumNumberOfLines(_: number): any;
        isSimpleRectangularTextContainer: boolean;
        size: CGSize;
        setSize(_: CGSize): any;
        textView: NSTextView;
        setTextView(_: NSTextView): any;
        widthTracksTextView: boolean;
        setWidthTracksTextView(_: boolean): any;
        static createWithContainerSize(containerSize: CGSize): NSTextContainer;
        static createWithSize(size: CGSize): NSTextContainer;
        lineFragmentRectForProposedRectAtIndexWritingDirectionRemainingRect(forProposedRect: CGRect, at: number, writingDirection: NSWritingDirection, remaining?: NSRect): CGRect;
        lineFragmentRectForProposedRectSweepDirectionMovementDirectionRemainingRect(forProposedRect: CGRect, sweepDirection: NSLineSweepDirection, movementDirection: NSLineMovementDirection, remaining?: NSRect): CGRect;
        replaceLayoutManager(_: NSLayoutManager): void;
    }
    interface NSTextDelegate extends NSObject {
        textDidBeginEditing?(_: NSNotification): void;
        textDidChange?(_: NSNotification): void;
        textDidEndEditing?(_: NSNotification): void;
        textShouldBeginEditing?(_: NSText): boolean;
        textShouldEndEditing?(_: NSText): boolean;
    }
    class NSTextField extends NSControl {
        static labelWithAttributedString(labelWithAttributedString: NSAttributedString): NSTextField;
        static labelWithString(labelWithString: string): NSTextField;
        static wrappingLabelWithString(wrappingLabelWithString: string): NSTextField;
        allowsCharacterPickerTouchBarItem: boolean;
        setAllowsCharacterPickerTouchBarItem(_: boolean): any;
        allowsDefaultTighteningForTruncation: boolean;
        setAllowsDefaultTighteningForTruncation(_: boolean): any;
        allowsEditingTextAttributes: boolean;
        setAllowsEditingTextAttributes(_: boolean): any;
        isAutomaticTextCompletionEnabled: boolean;
        setAutomaticTextCompletionEnabled(_: boolean): any;
        backgroundColor: NSColor;
        setBackgroundColor(_: NSColor): any;
        bezelStyle: NSTextField.BezelStyle;
        setBezelStyle(_: NSTextField.BezelStyle): any;
        isBezeled: boolean;
        setBezeled(_: boolean): any;
        isBordered: boolean;
        setBordered(_: boolean): any;
        delegate: NSTextFieldDelegate;
        setDelegate(_: NSTextFieldDelegate): any;
        drawsBackground: boolean;
        setDrawsBackground(_: boolean): any;
        isEditable: boolean;
        setEditable(_: boolean): any;
        importsGraphics: boolean;
        setImportsGraphics(_: boolean): any;
        maximumNumberOfLines: number;
        setMaximumNumberOfLines(_: number): any;
        placeholderAttributedString: NSAttributedString;
        setPlaceholderAttributedString(_: NSAttributedString): any;
        placeholderString: string;
        setPlaceholderString(_: string): any;
        preferredMaxLayoutWidth: number;
        setPreferredMaxLayoutWidth(_: number): any;
        isSelectable: boolean;
        setSelectable(_: boolean): any;
        textColor: NSColor;
        setTextColor(_: NSColor): any;
        selectText(_?: any): void;
        textDidBeginEditing(_: NSNotification): void;
        textDidChange(_: NSNotification): void;
        textDidEndEditing(_: NSNotification): void;
        textShouldBeginEditing(_: NSText): boolean;
        textShouldEndEditing(_: NSText): boolean;
    }
    class NSTextFieldCell extends NSActionCell {
        allowedInputSourceLocales: string[];
        setAllowedInputSourceLocales(_: string[]): any;
        backgroundColor: NSColor;
        setBackgroundColor(_: NSColor): any;
        bezelStyle: NSTextField.BezelStyle;
        setBezelStyle(_: NSTextField.BezelStyle): any;
        drawsBackground: boolean;
        setDrawsBackground(_: boolean): any;
        placeholderAttributedString: NSAttributedString;
        setPlaceholderAttributedString(_: NSAttributedString): any;
        placeholderString: string;
        setPlaceholderString(_: string): any;
        textColor: NSColor;
        setTextColor(_: NSColor): any;
        setWantsNotificationForMarkedText(_: boolean): void;
    }
    interface NSTextFieldDelegate extends NSControlTextEditingDelegate {
        textFieldTextViewShouldSelectCandidateAtIndex?(_: NSTextField, textView: NSTextView, shouldSelectCandidateAt: number): boolean;
        textFieldTextViewCandidatesForSelectedRange?(_: NSTextField, textView: NSTextView, candidates: NSTextCheckingResult[], forSelectedRange: NSRange): NSTextCheckingResult[];
        textFieldTextViewCandidatesForSelectedRange?(_: NSTextField, textView: NSTextView, candidatesForSelectedRange: NSRange): any[];
    }
    class NSTextFinder extends NSObject {
        static drawIncrementalMatchHighlightInRect(in_: CGRect): void;
        client: NSTextFinderClient;
        setClient(_: NSTextFinderClient): any;
        findBarContainer: NSTextFinderBarContainer;
        setFindBarContainer(_: NSTextFinderBarContainer): any;
        findIndicatorNeedsUpdate: boolean;
        setFindIndicatorNeedsUpdate(_: boolean): any;
        incrementalMatchRanges: NSValue[];
        isIncrementalSearchingEnabled: boolean;
        setIncrementalSearchingEnabled(_: boolean): any;
        incrementalSearchingShouldDimContentView: boolean;
        setIncrementalSearchingShouldDimContentView(_: boolean): any;
        cancelFindIndicator(): void;
        noteClientStringWillChange(): void;
        performAction(_: NSTextFinder.Action): void;
        validateAction(_: NSTextFinder.Action): boolean;
    }
    interface NSTextFinderBarContainer extends NSObject {
        findBarView: NSView;
        setFindBarView(_: NSView): any;
        isFindBarVisible: boolean;
        setFindBarVisible(_: boolean): any;
        contentView: NSView;
        findBarViewDidChangeHeight(): void;
    }
    interface NSTextFinderClient extends NSObject {
        allowsMultipleSelection?: boolean;
        isEditable?: boolean;
        firstSelectedRange?: NSRange;
        isSelectable?: boolean;
        selectedRanges?: NSValue[];
        setSelectedRanges(_: NSValue[]): any;
        string?: string;
        visibleCharacterRanges?: NSValue[];
        contentViewAtIndexEffectiveCharacterRange?(at: number, effectiveCharacterRange: NSRange): NSView;
        didReplaceCharacters?(): void;
        drawCharactersInRangeForContentView?(in_: NSRange, forContentView: NSView): void;
        rectsForCharacterRange?(forCharacterRange: NSRange): NSValue[];
        replaceCharactersInRangeWithString?(in_: NSRange, with_: string): void;
        scrollRangeToVisible?(_: NSRange): void;
        shouldReplaceCharactersInRangesWithStrings?(inRanges: NSValue[], with_: string[]): boolean;
        stringAtIndexEffectiveRangeEndsWithSearchBoundary?(at: number, effectiveRange: NSRange, endsWithSearchBoundary: boolean): string;
        stringLength?(): number;
    }
    interface NSTextInput {
    }
    interface NSTextInputClient {
        attributedString?(): NSAttributedString;
        attributedSubstringForProposedRangeActualRange(forProposedRange: NSRange, actualRange?: NSRange): NSAttributedString;
        baselineDeltaForCharacterAtIndex?(at: number): number;
        characterIndexForPoint(for_: CGPoint): number;
        doCommandBySelector(by: string): void;
        drawsVerticallyForCharacterAtIndex?(at: number): boolean;
        firstRectForCharacterRangeActualRange(forCharacterRange: NSRange, actualRange?: NSRange): CGRect;
        fractionOfDistanceThroughGlyphForPoint?(for_: CGPoint): number;
        hasMarkedText(): boolean;
        insertTextReplacementRange(_: any, replacementRange: NSRange): void;
        markedRange(): NSRange;
        selectedRange(): NSRange;
        setMarkedTextSelectedRangeReplacementRange(_: any, selectedRange: NSRange, replacementRange: NSRange): void;
        unmarkText(): void;
        validAttributesForMarkedText(): string[];
        windowLevel?(): number;
    }
    class NSTextInputContext extends NSObject {
        static localizedNameForInputSource(forInputSource: string): string;
        acceptsGlyphInfo: boolean;
        setAcceptsGlyphInfo(_: boolean): any;
        allowedInputSourceLocales: string[];
        setAllowedInputSourceLocales(_: string[]): any;
        client: NSTextInputClient;
        keyboardInputSources: string[];
        selectedKeyboardInputSource: string;
        setSelectedKeyboardInputSource(_: string): any;
        static currentInputContext: NSTextInputContext;
        activate(): void;
        deactivate(): void;
        discardMarkedText(): void;
        handleEvent(_: NSEvent): boolean;
        static createWithClient(client: NSTextInputClient): NSTextInputContext;
        invalidateCharacterCoordinates(): void;
    }
    interface NSTextInputTraits {
        autocorrectionType?: NSTextInputTraitType;
        setAutocorrectionType(_: NSTextInputTraitType): any;
        dataDetectionType?: NSTextInputTraitType;
        setDataDetectionType(_: NSTextInputTraitType): any;
        grammarCheckingType?: NSTextInputTraitType;
        setGrammarCheckingType(_: NSTextInputTraitType): any;
        linkDetectionType?: NSTextInputTraitType;
        setLinkDetectionType(_: NSTextInputTraitType): any;
        smartDashesType?: NSTextInputTraitType;
        setSmartDashesType(_: NSTextInputTraitType): any;
        smartInsertDeleteType?: NSTextInputTraitType;
        setSmartInsertDeleteType(_: NSTextInputTraitType): any;
        smartQuotesType?: NSTextInputTraitType;
        setSmartQuotesType(_: NSTextInputTraitType): any;
        spellCheckingType?: NSTextInputTraitType;
        setSpellCheckingType(_: NSTextInputTraitType): any;
        textCompletionType?: NSTextInputTraitType;
        setTextCompletionType(_: NSTextInputTraitType): any;
        textReplacementType?: NSTextInputTraitType;
        setTextReplacementType(_: NSTextInputTraitType): any;
    }
    interface NSTextLayoutOrientationProvider {
        layoutOrientation: NSLayoutManager.TextLayoutOrientation;
    }
    class NSTextList extends NSObject {
        listOptions: NSTextList.Options;
        markerFormat: string;
        startingItemNumber: number;
        setStartingItemNumber(_: number): any;
        static createWithMarkerFormatOptions(markerFormat: string, options: number): NSTextList;
        markerForItemNumber(forItemNumber: number): string;
    }
    class NSTextStorage extends NSMutableAttributedString {
        attributeRuns: NSTextStorage[];
        setAttributeRuns(_: NSTextStorage[]): any;
        changeInLength: number;
        characters: NSTextStorage[];
        setCharacters(_: NSTextStorage[]): any;
        delegate: NSTextStorageDelegate;
        setDelegate(_: NSTextStorageDelegate): any;
        editedMask: NSTextStorageEditActions;
        editedRange: NSRange;
        fixesAttributesLazily: boolean;
        font: NSFont;
        setFont(_: NSFont): any;
        foregroundColor: NSColor;
        setForegroundColor(_: NSColor): any;
        layoutManagers: NSLayoutManager[];
        paragraphs: NSTextStorage[];
        setParagraphs(_: NSTextStorage[]): any;
        words: NSTextStorage[];
        setWords(_: NSTextStorage[]): any;
        addLayoutManager(_: NSLayoutManager): void;
        editedRangeChangeInLength(_: NSTextStorageEditActions, range: NSRange, changeInLength: number): void;
        ensureAttributesAreFixedInRange(in_: NSRange): void;
        invalidateAttributesInRange(in_: NSRange): void;
        processEditing(): void;
        removeLayoutManager(_: NSLayoutManager): void;
    }
    interface NSTextStorageDelegate extends NSObject {
        textStorageDidProcessEditingRangeChangeInLength?(_: NSTextStorage, didProcessEditing: NSTextStorageEditActions, range: NSRange, changeInLength: number): void;
        textStorageWillProcessEditingRangeChangeInLength?(_: NSTextStorage, willProcessEditing: NSTextStorageEditActions, range: NSRange, changeInLength: number): void;
    }
    class NSTextTab extends NSObject {
        static columnTerminatorsForLocale(for_?: NSLocale): NSCharacterSet;
        alignment: NSTextAlignment;
        location: number;
        options: Map<string, any>;
        tabStopType: NSParagraphStyle.TextTabType;
        static createWithTextAlignmentLocationOptions(textAlignment: NSTextAlignment, location: number, options: Map<string, any>): NSTextTab;
        static createWithTypeLocation(type: NSParagraphStyle.TextTabType, location: number): NSTextTab;
    }
    class NSTextTable extends NSTextBlock {
        collapsesBorders: boolean;
        setCollapsesBorders(_: boolean): any;
        hidesEmptyCells: boolean;
        setHidesEmptyCells(_: boolean): any;
        layoutAlgorithm: NSTextTable.LayoutAlgorithm;
        setLayoutAlgorithm(_: NSTextTable.LayoutAlgorithm): any;
        numberOfColumns: number;
        setNumberOfColumns(_: number): any;
        boundsRectForBlockContentRectInRectTextContainerCharacterRange(for_: NSTextTableBlock, contentRect: CGRect, in_: CGRect, textContainer: NSTextContainer, characterRange: NSRange): CGRect;
        drawBackgroundForBlockWithFrameInViewCharacterRangeLayoutManager(for_: NSTextTableBlock, withFrame: CGRect, in_: NSView, characterRange: NSRange, layoutManager: NSLayoutManager): void;
        rectForBlockLayoutAtPointInRectTextContainerCharacterRange(for_: NSTextTableBlock, layoutAt: CGPoint, in_: CGRect, textContainer: NSTextContainer, characterRange: NSRange): CGRect;
    }
    class NSTextTableBlock extends NSTextBlock {
        columnSpan: number;
        rowSpan: number;
        startingColumn: number;
        startingRow: number;
        table: NSTextTable;
        static createWithTableStartingRowRowSpanStartingColumnColumnSpan(table: NSTextTable, startingRow: number, rowSpan: number, startingColumn: number, columnSpan: number): NSTextTableBlock;
    }
    class NSTextView extends NSText {
        static fieldEditor(): NSTextView;
        static registerForServices(): void;
        static scrollableDocumentContentTextView(): NSScrollView;
        static scrollablePlainDocumentContentTextView(): NSScrollView;
        static scrollableTextView(): NSScrollView;
        acceptableDragTypes: string[];
        acceptsGlyphInfo: boolean;
        setAcceptsGlyphInfo(_: boolean): any;
        allowedInputSourceLocales: string[];
        setAllowedInputSourceLocales(_: string[]): any;
        allowsCharacterPickerTouchBarItem: boolean;
        setAllowsCharacterPickerTouchBarItem(_: boolean): any;
        allowsDocumentBackgroundColorChange: boolean;
        setAllowsDocumentBackgroundColorChange(_: boolean): any;
        allowsImageEditing: boolean;
        setAllowsImageEditing(_: boolean): any;
        allowsUndo: boolean;
        setAllowsUndo(_: boolean): any;
        isAutomaticDashSubstitutionEnabled: boolean;
        setAutomaticDashSubstitutionEnabled(_: boolean): any;
        isAutomaticDataDetectionEnabled: boolean;
        setAutomaticDataDetectionEnabled(_: boolean): any;
        isAutomaticLinkDetectionEnabled: boolean;
        setAutomaticLinkDetectionEnabled(_: boolean): any;
        isAutomaticQuoteSubstitutionEnabled: boolean;
        setAutomaticQuoteSubstitutionEnabled(_: boolean): any;
        isAutomaticSpellingCorrectionEnabled: boolean;
        setAutomaticSpellingCorrectionEnabled(_: boolean): any;
        isAutomaticTextCompletionEnabled: boolean;
        setAutomaticTextCompletionEnabled(_: boolean): any;
        isAutomaticTextReplacementEnabled: boolean;
        setAutomaticTextReplacementEnabled(_: boolean): any;
        isCoalescingUndo: boolean;
        isContinuousSpellCheckingEnabled: boolean;
        setContinuousSpellCheckingEnabled(_: boolean): any;
        defaultParagraphStyle: NSParagraphStyle;
        setDefaultParagraphStyle(_: NSParagraphStyle): any;
        displaysLinkToolTips: boolean;
        setDisplaysLinkToolTips(_: boolean): any;
        enabledTextCheckingTypes: number;
        setEnabledTextCheckingTypes(_: number): any;
        isGrammarCheckingEnabled: boolean;
        setGrammarCheckingEnabled(_: boolean): any;
        isIncrementalSearchingEnabled: boolean;
        setIncrementalSearchingEnabled(_: boolean): any;
        insertionPointColor: NSColor;
        setInsertionPointColor(_: NSColor): any;
        layoutManager: NSLayoutManager;
        linkTextAttributes: Map<string, any>;
        setLinkTextAttributes(_: Map<string, any>): any;
        markedTextAttributes: Map<string, any>;
        setMarkedTextAttributes(_: Map<string, any>): any;
        rangeForUserCharacterAttributeChange: NSRange;
        rangeForUserCompletion: NSRange;
        rangeForUserParagraphAttributeChange: NSRange;
        rangeForUserTextChange: NSRange;
        rangesForUserCharacterAttributeChange: NSValue[];
        rangesForUserParagraphAttributeChange: NSValue[];
        rangesForUserTextChange: NSValue[];
        readablePasteboardTypes: string[];
        selectedRanges: NSValue[];
        setSelectedRanges(_: NSValue[]): any;
        selectedTextAttributes: Map<string, any>;
        setSelectedTextAttributes(_: Map<string, any>): any;
        selectionAffinity: NSSelectionAffinity;
        selectionGranularity: NSSelectionGranularity;
        setSelectionGranularity(_: NSSelectionGranularity): any;
        shouldDrawInsertionPoint: boolean;
        smartInsertDeleteEnabled: boolean;
        setSmartInsertDeleteEnabled(_: boolean): any;
        spellCheckerDocumentTag: number;
        textContainer: NSTextContainer;
        setTextContainer(_: NSTextContainer): any;
        textContainerInset: CGSize;
        setTextContainerInset(_: CGSize): any;
        textContainerOrigin: CGPoint;
        textStorage: NSTextStorage;
        typingAttributes: Map<string, any>;
        setTypingAttributes(_: Map<string, any>): any;
        usesAdaptiveColorMappingForDarkAppearance: boolean;
        setUsesAdaptiveColorMappingForDarkAppearance(_: boolean): any;
        usesFindBar: boolean;
        setUsesFindBar(_: boolean): any;
        usesFindPanel: boolean;
        setUsesFindPanel(_: boolean): any;
        usesInspectorBar: boolean;
        setUsesInspectorBar(_: boolean): any;
        usesRolloverButtonForSelection: boolean;
        setUsesRolloverButtonForSelection(_: boolean): any;
        usesRuler: boolean;
        setUsesRuler(_: boolean): any;
        writablePasteboardTypes: string[];
        static stronglyReferencesTextStorage: boolean;
        alignJustified(_?: any): void;
        breakUndoCoalescing(): void;
        changeAttributes(_?: any): void;
        changeDocumentBackgroundColor(_?: any): void;
        changeLayoutOrientation(_?: any): void;
        characterIndexForInsertionAtPoint(at: CGPoint): number;
        checkTextInDocument(_?: any): void;
        checkTextInRangeTypesOptions(in_: NSRange, types: number, options: Map<string, any>): void;
        checkTextInSelection(_?: any): void;
        cleanUpAfterDragOperation(): void;
        clickedOnLinkAtIndex(onLink: any, at: number): void;
        completionsForPartialWordRangeIndexOfSelectedItem(forPartialWordRange: NSRange, indexOfSelectedItem: number): string[];
        didChangeText(): void;
        dragImageForSelectionWithEventOrigin(with_: NSEvent, origin?: NSPoint): NSImage;
        dragOperationForDraggingInfoType(for_: NSDraggingInfo, type: string): NSDragOperation;
        dragSelectionWithEventOffsetSlideBack(with_: NSEvent, offset: CGSize, slideBack: boolean): boolean;
        drawInsertionPointInRectColorTurnedOn(in_: CGRect, color: NSColor, turnedOn: boolean): void;
        drawViewBackgroundInRect(in_: CGRect): void;
        handleTextCheckingResultsForRangeTypesOptionsOrthographyWordCount(_: NSTextCheckingResult[], forRange: NSRange, types: number, options: Map<string, any>, orthography: NSOrthography, wordCount: number): void;
        static createWithFrameTextContainer(frame: CGRect, textContainer?: NSTextContainer): NSTextView;
        insertCompletionForPartialWordRangeMovementIsFinal(_: string, forPartialWordRange: NSRange, movement: number, isFinal: boolean): void;
        invalidateTextContainerOrigin(): void;
        loosenKerning(_?: any): void;
        lowerBaseline(_?: any): void;
        orderFrontLinkPanel(_?: any): void;
        orderFrontListPanel(_?: any): void;
        orderFrontSharingServicePicker(_?: any): void;
        orderFrontSpacingPanel(_?: any): void;
        orderFrontSubstitutionsPanel(_?: any): void;
        orderFrontTablePanel(_?: any): void;
        outline(_?: any): void;
        pasteAsPlainText(_?: any): void;
        pasteAsRichText(_?: any): void;
        performFindPanelAction(_?: any): void;
        performValidatedReplacementInRangeWithAttributedString(in_: NSRange, with_: NSAttributedString): boolean;
        preferredPasteboardTypeFromArrayRestrictedToTypesFromArray(from: string[], restrictedToTypesFrom?: string[]): string;
        quickLookPreviewableItemsInRanges(_: NSValue[]): QLPreviewItem[];
        raiseBaseline(_?: any): void;
        readSelectionFromPasteboard(from: NSPasteboard): boolean;
        readSelectionFromPasteboardType(from: NSPasteboard, type: string): boolean;
        replaceTextContainer(_: NSTextContainer): void;
        selectionRangeForProposedRangeGranularity(forProposedRange: NSRange, granularity: NSSelectionGranularity): NSRange;
        setAlignmentRange(_: NSTextAlignment, range: NSRange): void;
        setBaseWritingDirectionRange(_: NSWritingDirection, range: NSRange): void;
        setConstrainedFrameSize(_: CGSize): void;
        setLayoutOrientation(_: NSLayoutManager.TextLayoutOrientation): void;
        setNeedsDisplayInRectAvoidAdditionalLayout(_: CGRect, avoidAdditionalLayout: boolean): void;
        setSelectedRange(_: NSRange): void;
        setSelectedRangeAffinityStillSelecting(_: NSRange, affinity: NSSelectionAffinity, stillSelecting: boolean): void;
        setSelectedRangesAffinityStillSelecting(_: NSValue[], affinity: NSSelectionAffinity, stillSelecting: boolean): void;
        setSpellingStateRange(_: number, range: NSRange): void;
        shouldChangeTextInRangeReplacementString(in_: NSRange, replacementString?: string): boolean;
        shouldChangeTextInRangesReplacementStrings(inRanges: NSValue[], replacementStrings?: string[]): boolean;
        showFindIndicatorForRange(for_: NSRange): void;
        smartDeleteRangeForProposedRange(forProposedRange: NSRange): NSRange;
        smartInsertAfterStringForStringReplacingRange(afterStringFor: string, replacing: NSRange): string;
        smartInsertBeforeStringForStringReplacingRange(beforeStringFor: string, replacing: NSRange): string;
        smartInsertForStringReplacingRangeBeforeStringAfterString(for_: string, replacing: NSRange, before?: string, after?: string): void;
        startSpeaking(_?: any): void;
        stopSpeaking(_?: any): void;
        tightenKerning(_?: any): void;
        toggleAutomaticDashSubstitution(_?: any): void;
        toggleAutomaticDataDetection(_?: any): void;
        toggleAutomaticLinkDetection(_?: any): void;
        toggleAutomaticQuoteSubstitution(_?: any): void;
        toggleAutomaticSpellingCorrection(_?: any): void;
        toggleAutomaticTextCompletion(_?: any): void;
        toggleAutomaticTextReplacement(_?: any): void;
        toggleContinuousSpellChecking(_?: any): void;
        toggleGrammarChecking(_?: any): void;
        toggleQuickLookPreviewPanel(_?: any): void;
        toggleSmartInsertDelete(_?: any): void;
        turnOffKerning(_?: any): void;
        turnOffLigatures(_?: any): void;
        updateCandidates(): void;
        updateDragTypeRegistration(): void;
        updateFontPanel(): void;
        updateInsertionPointStateAndRestartTimer(_: boolean): void;
        updateQuickLookPreviewPanel(): void;
        updateRuler(): void;
        updateTextTouchBarItems(): void;
        updateTouchBarItemIdentifiers(): void;
        useAllLigatures(_?: any): void;
        useStandardKerning(_?: any): void;
        useStandardLigatures(_?: any): void;
        writeSelectionToPasteboardType(to: NSPasteboard, type: string): boolean;
        writeSelectionToPasteboardTypes(to: NSPasteboard, types: string[]): boolean;
    }
    interface NSTextViewDelegate extends NSTextDelegate {
        textViewClickedOnLinkAtIndex?(_: NSTextView, clickedOnLink: any, at: number): boolean;
        textViewClickedOnCellInRectAtIndex?(_: NSTextView, clickedOn: NSTextAttachmentCell, in_: CGRect, at: number): void;
        textViewDoubleClickedOnCellInRectAtIndex?(_: NSTextView, doubleClickedOn: NSTextAttachmentCell, in_: CGRect, at: number): void;
        textViewDraggedCellInRectEventAtIndex?(_: NSTextView, draggedCell: NSTextAttachmentCell, in_: CGRect, event: NSEvent, at: number): void;
        textViewWritablePasteboardTypesForCellAtIndex?(_: NSTextView, writablePasteboardTypesFor: NSTextAttachmentCell, at: number): string[];
        textViewWriteCellAtIndexToPasteboardType?(_: NSTextView, write: NSTextAttachmentCell, at: number, to: NSPasteboard, type: string): boolean;
        textViewWillDisplayToolTipForCharacterAtIndex?(_: NSTextView, willDisplayToolTip: string, forCharacterAt: number): string;
        textViewShouldChangeTextInRangeReplacementString?(_: NSTextView, shouldChangeTextIn: NSRange, replacementString?: string): boolean;
        textViewDoCommandBySelector?(_: NSTextView, doCommandBy: string): boolean;
        textViewMenuForEventAtIndex?(_: NSTextView, menu: NSMenu, for_: NSEvent, at: number): NSMenu;
        textViewWillCheckTextInRangeOptionsTypes?(_: NSTextView, willCheckTextIn: NSRange, options: Map<string, any>, types: number): Map<string, any>;
        textViewDidCheckTextInRangeTypesOptionsResultsOrthographyWordCount?(_: NSTextView, didCheckTextIn: NSRange, types: number, options: Map<string, any>, results: NSTextCheckingResult[], orthography: NSOrthography, wordCount: number): NSTextCheckingResult[];
        textViewURLForContentsOfTextAttachmentAtIndex?(_: NSTextView, urlForContentsOf: NSTextAttachment, at: number): NSURL;
        textViewWillShowSharingServicePickerForItems?(_: NSTextView, willShow: NSSharingServicePicker, forItems: any[]): NSSharingServicePicker;
        textViewShouldSelectCandidateAtIndex?(_: NSTextView, shouldSelectCandidateAt: number): boolean;
        textViewCandidatesForSelectedRange?(_: NSTextView, candidates: NSTextCheckingResult[], forSelectedRange: NSRange): NSTextCheckingResult[];
        textViewCandidatesForSelectedRange?(_: NSTextView, candidatesForSelectedRange: NSRange): any[];
        textViewCompletionsForPartialWordRangeIndexOfSelectedItem?(_: NSTextView, completions: string[], forPartialWordRange: NSRange, indexOfSelectedItem?: number): string[];
        textViewShouldChangeTextInRangesReplacementStrings?(_: NSTextView, shouldChangeTextInRanges: NSValue[], replacementStrings?: string[]): boolean;
        textViewShouldChangeTypingAttributesToAttributes?(_: NSTextView, shouldChangeTypingAttributes: Map<string, any>, toAttributes: Map<string, any>): Map<string, any>;
        textViewShouldSetSpellingStateRange?(_: NSTextView, shouldSetSpellingState: number, range: NSRange): number;
        textViewShouldUpdateTouchBarItemIdentifiers?(_: NSTextView, shouldUpdateTouchBarItemIdentifiers: string[]): string[];
        textViewWillChangeSelectionFromCharacterRangeToCharacterRange?(_: NSTextView, willChangeSelectionFromCharacterRange: NSRange, toCharacterRange: NSRange): NSRange;
        textViewWillChangeSelectionFromCharacterRangesToCharacterRanges?(_: NSTextView, willChangeSelectionFromCharacterRanges: NSValue[], toCharacterRanges: NSValue[]): NSValue[];
        textViewDidChangeSelection?(_: NSNotification): void;
        textViewDidChangeTypingAttributes?(_: NSNotification): void;
        undoManagerForTextView?(for_: NSTextView): UndoManager;
    }
    class NSTitlebarAccessoryViewController extends NSViewController {
        fullScreenMinHeight: number;
        setFullScreenMinHeight(_: number): any;
        isHidden: boolean;
        setHidden(_: boolean): any;
        layoutAttribute: NSLayoutConstraint.Attribute;
        setLayoutAttribute(_: NSLayoutConstraint.Attribute): any;
    }
    class NSTokenField extends NSTextField {
        completionDelay: number;
        setCompletionDelay(_: number): any;
        tokenStyle: NSTokenField.TokenStyle;
        setTokenStyle(_: NSTokenField.TokenStyle): any;
        tokenizingCharacterSet: NSCharacterSet;
        setTokenizingCharacterSet(_: NSCharacterSet): any;
        static defaultCompletionDelay: number;
        static defaultTokenizingCharacterSet: NSCharacterSet;
    }
    class NSTokenFieldCell extends NSTextFieldCell {
        completionDelay: number;
        setCompletionDelay(_: number): any;
        delegate: NSTokenFieldCellDelegate;
        setDelegate(_: NSTokenFieldCellDelegate): any;
        tokenStyle: NSTokenField.TokenStyle;
        setTokenStyle(_: NSTokenField.TokenStyle): any;
        tokenizingCharacterSet: NSCharacterSet;
        setTokenizingCharacterSet(_: NSCharacterSet): any;
        static defaultCompletionDelay: number;
        static defaultTokenizingCharacterSet: NSCharacterSet;
    }
    interface NSTokenFieldCellDelegate extends NSObject {
        tokenFieldCellShouldAddObjectsAtIndex?(_: NSTokenFieldCell, shouldAdd: any[], at: number): any[];
        tokenFieldCellRepresentedObjectForEditingString?(_: NSTokenFieldCell, representedObjectForEditing: string): any;
        tokenFieldCellWriteRepresentedObjectsToPasteboard?(_: NSTokenFieldCell, writeRepresentedObjects: any[], to: NSPasteboard): boolean;
        tokenFieldCellReadFromPasteboard?(_: NSTokenFieldCell, readFrom: NSPasteboard): any[];
        tokenFieldCellCompletionsForSubstringIndexOfTokenIndexOfSelectedItem?(_: NSTokenFieldCell, completionsForSubstring: string, indexOfToken: number, indexOfSelectedItem: number): any[];
        tokenFieldCellDisplayStringForRepresentedObject?(_: NSTokenFieldCell, displayStringForRepresentedObject: any): string;
        tokenFieldCellEditingStringForRepresentedObject?(_: NSTokenFieldCell, editingStringForRepresentedObject: any): string;
        tokenFieldCellHasMenuForRepresentedObject?(_: NSTokenFieldCell, hasMenuForRepresentedObject: any): boolean;
        tokenFieldCellMenuForRepresentedObject?(_: NSTokenFieldCell, menuForRepresentedObject: any): NSMenu;
        tokenFieldCellStyleForRepresentedObject?(_: NSTokenFieldCell, styleForRepresentedObject: any): NSTokenField.TokenStyle;
    }
    interface NSTokenFieldDelegate extends NSTextFieldDelegate {
        tokenFieldShouldAddObjectsAtIndex?(_: NSTokenField, shouldAdd: any[], at: number): any[];
        tokenFieldRepresentedObjectForEditingString?(_: NSTokenField, representedObjectForEditing: string): any;
        tokenFieldWriteRepresentedObjectsToPasteboard?(_: NSTokenField, writeRepresentedObjects: any[], to: NSPasteboard): boolean;
        tokenFieldReadFromPasteboard?(_: NSTokenField, readFrom: NSPasteboard): any[];
        tokenFieldCompletionsForSubstringIndexOfTokenIndexOfSelectedItem?(_: NSTokenField, completionsForSubstring: string, indexOfToken: number, indexOfSelectedItem?: number): any[];
        tokenFieldDisplayStringForRepresentedObject?(_: NSTokenField, displayStringForRepresentedObject: any): string;
        tokenFieldEditingStringForRepresentedObject?(_: NSTokenField, editingStringForRepresentedObject: any): string;
        tokenFieldHasMenuForRepresentedObject?(_: NSTokenField, hasMenuForRepresentedObject: any): boolean;
        tokenFieldMenuForRepresentedObject?(_: NSTokenField, menuForRepresentedObject: any): NSMenu;
        tokenFieldStyleForRepresentedObject?(_: NSTokenField, styleForRepresentedObject: any): NSTokenField.TokenStyle;
    }
    class NSToolbar extends NSObject {
        allowsExtensionItems: boolean;
        setAllowsExtensionItems(_: boolean): any;
        allowsUserCustomization: boolean;
        setAllowsUserCustomization(_: boolean): any;
        autosavesConfiguration: boolean;
        setAutosavesConfiguration(_: boolean): any;
        centeredItemIdentifier: string;
        setCenteredItemIdentifier(_: string): any;
        configurationDictionary: Map<string, any>;
        customizationPaletteIsRunning: boolean;
        delegate: NSToolbarDelegate;
        setDelegate(_: NSToolbarDelegate): any;
        displayMode: NSToolbar.DisplayMode;
        setDisplayMode(_: NSToolbar.DisplayMode): any;
        identifier: string;
        items: NSToolbarItem[];
        selectedItemIdentifier: string;
        setSelectedItemIdentifier(_: string): any;
        showsBaselineSeparator: boolean;
        setShowsBaselineSeparator(_: boolean): any;
        sizeMode: NSToolbar.SizeMode;
        setSizeMode(_: NSToolbar.SizeMode): any;
        isVisible: boolean;
        setVisible(_: boolean): any;
        visibleItems: NSToolbarItem[];
        static createWithIdentifier(identifier: string): NSToolbar;
        insertItemWithItemIdentifierAtIndex(withItemIdentifier: string, at: number): void;
        removeItemAtIndex(at: number): void;
        runCustomizationPalette(_?: any): void;
        setConfigurationFromDictionary(_: Map<string, any>): void;
        validateVisibleItems(): void;
    }
    interface NSToolbarDelegate extends NSObject {
        toolbarItemForItemIdentifierWillBeInsertedIntoToolbar?(_: NSToolbar, itemForItemIdentifier: string, willBeInsertedIntoToolbar: boolean): NSToolbarItem;
        toolbarAllowedItemIdentifiers?(_: NSToolbar): string[];
        toolbarDefaultItemIdentifiers?(_: NSToolbar): string[];
        toolbarDidRemoveItem?(_: NSNotification): void;
        toolbarSelectableItemIdentifiers?(_: NSToolbar): string[];
        toolbarWillAddItem?(_: NSNotification): void;
    }
    class NSToolbarItem extends NSObject {
        action: string;
        setAction(_: string): any;
        allowsDuplicatesInToolbar: boolean;
        autovalidates: boolean;
        setAutovalidates(_: boolean): any;
        isBordered: boolean;
        setBordered(_: boolean): any;
        isEnabled: boolean;
        setEnabled(_: boolean): any;
        image: NSImage;
        setImage(_: NSImage): any;
        itemIdentifier: string;
        label: string;
        setLabel(_: string): any;
        maxSize: CGSize;
        setMaxSize(_: CGSize): any;
        menuFormRepresentation: NSMenuItem;
        setMenuFormRepresentation(_: NSMenuItem): any;
        minSize: CGSize;
        setMinSize(_: CGSize): any;
        paletteLabel: string;
        setPaletteLabel(_: string): any;
        tag: number;
        setTag(_: number): any;
        target: any;
        setTarget(_: any): any;
        title: string;
        setTitle(_: string): any;
        toolTip: string;
        setToolTip(_: string): any;
        toolbar: NSToolbar;
        view: NSView;
        setView(_: NSView): any;
        visibilityPriority: number;
        setVisibilityPriority(_: number): any;
        static createWithItemIdentifier(itemIdentifier: string): NSToolbarItem;
        validate(): void;
    }
    class NSToolbarItemGroup extends NSToolbarItem {
        controlRepresentation: NSToolbarItemGroup.ControlRepresentation;
        setControlRepresentation(_: NSToolbarItemGroup.ControlRepresentation): any;
        selectedIndex: number;
        setSelectedIndex(_: number): any;
        selectionMode: NSToolbarItemGroup.SelectionMode;
        setSelectionMode(_: NSToolbarItemGroup.SelectionMode): any;
        subitems: NSToolbarItem[];
        setSubitems(_: NSToolbarItem[]): any;
        isSelectedAtIndex(at: number): boolean;
        setSelectedAtIndex(_: boolean, at: number): void;
    }
    interface NSToolbarItemValidation extends NSObject {
        validateToolbarItem(_: NSToolbarItem): boolean;
    }
    class NSTouch extends NSObject {
        device: any;
        deviceSize: CGSize;
        identity: any;
        normalizedPosition: CGPoint;
        phase: NSTouch.Phase;
        isResting: boolean;
        type: NSTouch.TouchType;
        locationInView(in_?: NSView): CGPoint;
        previousLocationInView(in_?: NSView): CGPoint;
    }
    class NSTouchBar extends NSObject {
        customizationAllowedItemIdentifiers: string[];
        setCustomizationAllowedItemIdentifiers(_: string[]): any;
        customizationIdentifier: string;
        setCustomizationIdentifier(_: string): any;
        customizationRequiredItemIdentifiers: string[];
        setCustomizationRequiredItemIdentifiers(_: string[]): any;
        defaultItemIdentifiers: string[];
        setDefaultItemIdentifiers(_: string[]): any;
        delegate: NSTouchBarDelegate;
        setDelegate(_: NSTouchBarDelegate): any;
        escapeKeyReplacementItemIdentifier: string;
        setEscapeKeyReplacementItemIdentifier(_: string): any;
        itemIdentifiers: string[];
        principalItemIdentifier: string;
        setPrincipalItemIdentifier(_: string): any;
        templateItems: NSSet<NSTouchBarItem>;
        setTemplateItems(_: NSSet<NSTouchBarItem>): any;
        isVisible: boolean;
        static isAutomaticCustomizeTouchBarMenuItemEnabled: boolean;
        setAutomaticCustomizeTouchBarMenuItemEnabled(_: boolean): any;
        itemForIdentifier(forIdentifier: string): NSTouchBarItem;
    }
    interface NSTouchBarDelegate extends NSObject {
        touchBarMakeItemForIdentifier?(_: NSTouchBar, makeItemForIdentifier: string): NSTouchBarItem;
    }
    class NSTouchBarItem extends NSObject {
        customizationLabel: string;
        identifier: string;
        view: NSView;
        viewController: NSViewController;
        visibilityPriority: number;
        setVisibilityPriority(_: number): any;
        isVisible: boolean;
        static createWithIdentifier(identifier: string): NSTouchBarItem;
    }
    interface NSTouchBarProvider extends NSObject {
        touchBar: NSTouchBar;
    }
    class NSTrackingArea extends NSObject {
        options: NSTrackingArea.Options;
        owner: any;
        rect: CGRect;
        userInfo: Map<any, any>;
        static createWithRectOptionsOwnerUserInfo(rect: CGRect, options: NSTrackingArea.Options, owner?: any, userInfo?: Map<any, any>): NSTrackingArea;
    }
    class NSTreeController extends NSObjectController {
        alwaysUsesMultipleValuesMarker: boolean;
        setAlwaysUsesMultipleValuesMarker(_: boolean): any;
        arrangedObjects: NSTreeNode;
        avoidsEmptySelection: boolean;
        setAvoidsEmptySelection(_: boolean): any;
        canAddChild: boolean;
        canInsert: boolean;
        canInsertChild: boolean;
        childrenKeyPath: string;
        setChildrenKeyPath(_: string): any;
        countKeyPath: string;
        setCountKeyPath(_: string): any;
        leafKeyPath: string;
        setLeafKeyPath(_: string): any;
        preservesSelection: boolean;
        setPreservesSelection(_: boolean): any;
        selectedNodes: NSTreeNode[];
        selectionIndexPath: NSIndexPath;
        selectionIndexPaths: NSIndexPath[];
        selectsInsertedObjects: boolean;
        setSelectsInsertedObjects(_: boolean): any;
        sortDescriptors: NSSortDescriptor[];
        setSortDescriptors(_: NSSortDescriptor[]): any;
        addChild(_?: any): void;
        addSelectionIndexPaths(_: NSIndexPath[]): boolean;
        childrenKeyPathForNode(for_: NSTreeNode): string;
        countKeyPathForNode(for_: NSTreeNode): string;
        insert(_?: any): void;
        insertChild(_?: any): void;
        insertObjectAtArrangedObjectIndexPath(_?: any, atArrangedObjectIndexPath?: NSIndexPath): void;
        insertObjectsAtArrangedObjectIndexPaths(_: any[], atArrangedObjectIndexPaths: NSIndexPath[]): void;
        leafKeyPathForNode(for_: NSTreeNode): string;
        moveNodeToIndexPath(_: NSTreeNode, to: NSIndexPath): void;
        moveNodesToIndexPath(_: NSTreeNode[], to: NSIndexPath): void;
        rearrangeObjects(): void;
        removeObjectAtArrangedObjectIndexPath(atArrangedObjectIndexPath: NSIndexPath): void;
        removeObjectsAtArrangedObjectIndexPaths(atArrangedObjectIndexPaths: NSIndexPath[]): void;
        removeSelectionIndexPaths(_: NSIndexPath[]): boolean;
        setSelectionIndexPath(_?: NSIndexPath): boolean;
        setSelectionIndexPaths(_: NSIndexPath[]): boolean;
    }
    class NSTreeNode extends NSObject {
        childNodes: NSTreeNode[];
        indexPath: NSIndexPath;
        isLeaf: boolean;
        mutableChildNodes: NSMutableArray<NSTreeNode>;
        parentNode: NSTreeNode;
        representedObject: any;
        descendantNodeAtIndexPath(at: NSIndexPath): NSTreeNode;
        static createWithRepresentedObject(representedObject?: any): NSTreeNode;
        sortWithSortDescriptorsRecursively(with_: NSSortDescriptor[], recursively: boolean): void;
    }
    class NSTypesetter extends NSObject {
        static printingAdjustmentInLayoutManagerForNominallySpacedGlyphRangePackedGlyphsCount(in_: NSLayoutManager, forNominallySpacedGlyphRange: NSRange, packedGlyphs: string, count: number): CGSize;
        static sharedSystemTypesetterForBehavior(for_: NSLayoutManager.TypesetterBehavior): any;
        attributedString: NSAttributedString;
        setAttributedString(_: NSAttributedString): any;
        attributesForExtraLineFragment: Map<string, any>;
        bidiProcessingEnabled: boolean;
        setBidiProcessingEnabled(_: boolean): any;
        currentParagraphStyle: NSParagraphStyle;
        currentTextContainer: NSTextContainer;
        hyphenationFactor: number;
        setHyphenationFactor(_: number): any;
        layoutManager: NSLayoutManager;
        lineFragmentPadding: number;
        setLineFragmentPadding(_: number): any;
        paragraphCharacterRange: NSRange;
        paragraphGlyphRange: NSRange;
        paragraphSeparatorCharacterRange: NSRange;
        paragraphSeparatorGlyphRange: NSRange;
        textContainers: NSTextContainer[];
        typesetterBehavior: NSLayoutManager.TypesetterBehavior;
        setTypesetterBehavior(_: NSLayoutManager.TypesetterBehavior): any;
        usesFontLeading: boolean;
        setUsesFontLeading(_: boolean): any;
        static defaultTypesetterBehavior: NSLayoutManager.TypesetterBehavior;
        static sharedSystemTypesetter: NSTypesetter;
        actionForControlCharacterAtIndex(at: number): NSTypesetterControlCharacterAction;
        baselineOffsetInLayoutManagerGlyphIndex(in_: NSLayoutManager, glyphIndex: number): number;
        beginLineWithGlyphAtIndex(withGlyphAt: number): void;
        beginParagraph(): void;
        boundingBoxForControlGlyphAtIndexForTextContainerProposedLineFragmentGlyphPositionCharacterIndex(forControlGlyphAt: number, for_: NSTextContainer, proposedLineFragment: CGRect, glyphPosition: CGPoint, characterIndex: number): CGRect;
        characterRangeForGlyphRangeActualGlyphRange(forGlyphRange: NSRange, actualGlyphRange?: NSRange): NSRange;
        endLineWithGlyphRange(withGlyphRange: NSRange): void;
        endParagraph(): void;
        getLineFragmentRectUsedRectForParagraphSeparatorGlyphRangeAtProposedOrigin(_: NSRect, usedRect: NSRect, forParagraphSeparatorGlyphRange: NSRange, atProposedOrigin: CGPoint): void;
        getLineFragmentRectUsedRectRemainingRectForStartingGlyphAtIndexProposedRectLineSpacingParagraphSpacingBeforeParagraphSpacingAfter(_: NSRect, usedRect: NSRect, remaining: NSRect, forStartingGlyphAt: number, proposedRect: CGRect, lineSpacing: number, paragraphSpacingBefore: number, paragraphSpacingAfter: number): void;
        glyphRangeForCharacterRangeActualCharacterRange(forCharacterRange: NSRange, actualCharacterRange?: NSRange): NSRange;
        hyphenCharacterForGlyphAtIndex(forGlyphAt: number): number;
        hyphenationFactorForGlyphAtIndex(forGlyphAt: number): number;
        layoutCharactersInRangeForLayoutManagerMaximumNumberOfLineFragments(in_: NSRange, for_: NSLayoutManager, maximumNumberOfLineFragments: number): NSRange;
        layoutGlyphsInLayoutManagerStartingAtGlyphIndexMaxNumberOfLineFragmentsNextGlyphIndex(in_: NSLayoutManager, startingAtGlyphIndex: number, maxNumberOfLineFragments: number, nextGlyphIndex: number): void;
        layoutParagraphAtPoint(at: NSPoint): number;
        lineSpacingAfterGlyphAtIndexWithProposedLineFragmentRect(afterGlyphAt: number, withProposedLineFragmentRect: CGRect): number;
        paragraphSpacingAfterGlyphAtIndexWithProposedLineFragmentRect(afterGlyphAt: number, withProposedLineFragmentRect: CGRect): number;
        paragraphSpacingBeforeGlyphAtIndexWithProposedLineFragmentRect(beforeGlyphAt: number, withProposedLineFragmentRect: CGRect): number;
        setAttachmentSizeForGlyphRange(_: CGSize, forGlyphRange: NSRange): void;
        setBidiLevelsForGlyphRange(_: string, forGlyphRange: NSRange): void;
        setDrawsOutsideLineFragmentForGlyphRange(_: boolean, forGlyphRange: NSRange): void;
        setHardInvalidationForGlyphRange(_: boolean, forGlyphRange: NSRange): void;
        setLineFragmentRectForGlyphRangeUsedRectBaselineOffset(_: CGRect, forGlyphRange: NSRange, usedRect: CGRect, baselineOffset: number): void;
        setLocationWithAdvancementsForStartOfGlyphRange(_: CGPoint, withAdvancements: number, forStartOfGlyphRange: NSRange): void;
        setNotShownAttributeForGlyphRange(_: boolean, forGlyphRange: NSRange): void;
        setParagraphGlyphRangeSeparatorGlyphRange(_: NSRange, separatorGlyphRange: NSRange): void;
        shouldBreakLineByHyphenatingBeforeCharacterAtIndex(byHyphenatingBeforeCharacterAt: number): boolean;
        shouldBreakLineByWordBeforeCharacterAtIndex(byWordBeforeCharacterAt: number): boolean;
        substituteFontForFont(for_: NSFont): NSFont;
        textTabForGlyphLocationWritingDirectionMaxLocation(forGlyphLocation: number, writingDirection: NSWritingDirection, maxLocation: number): NSTextTab;
        willSetLineFragmentRectForGlyphRangeUsedRectBaselineOffset(_: NSRect, forGlyphRange: NSRange, usedRect: NSRect, baselineOffset: number): void;
    }
    interface NSUserActivityRestoring extends NSObject {
        restoreUserActivityState(_: NSUserActivity): void;
    }
    class NSUserDefaultsController extends NSController {
        appliesImmediately: boolean;
        setAppliesImmediately(_: boolean): any;
        defaults: UserDefaults;
        hasUnappliedChanges: boolean;
        initialValues: Map<string, any>;
        setInitialValues(_: Map<string, any>): any;
        values: any;
        static sharedUserDefaultsController: NSUserDefaultsController;
        static createWithDefaultsInitialValues(defaults?: UserDefaults, initialValues?: Map<string, any>): NSUserDefaultsController;
        revert(_?: any): void;
        revertToInitialValues(_?: any): void;
        save(_?: any): void;
    }
    interface NSUserInterfaceCompression {
        activeCompressionOptions: NSUserInterfaceCompressionOptions;
        compressWithPrioritizedCompressionOptions(withPrioritizedCompressionOptions: NSUserInterfaceCompressionOptions[]): void;
        minimumSizeWithPrioritizedCompressionOptions(withPrioritizedCompressionOptions: NSUserInterfaceCompressionOptions[]): CGSize;
    }
    class NSUserInterfaceCompressionOptions extends NSObject {
        isEmpty: boolean;
        static breakEqualWidthsOption: NSUserInterfaceCompressionOptions;
        static hideImagesOption: NSUserInterfaceCompressionOptions;
        static hideTextOption: NSUserInterfaceCompressionOptions;
        static reduceMetricsOption: NSUserInterfaceCompressionOptions;
        static standardOptions: NSUserInterfaceCompressionOptions;
        containsOptions(_: NSUserInterfaceCompressionOptions): boolean;
        static createWithCompressionOptions(compressionOptions: NSSet<NSUserInterfaceCompressionOptions>): NSUserInterfaceCompressionOptions;
        static createWithIdentifier(identifier: string): NSUserInterfaceCompressionOptions;
        intersectsOptions(_: NSUserInterfaceCompressionOptions): boolean;
        optionsByAddingOptions(_: NSUserInterfaceCompressionOptions): NSUserInterfaceCompressionOptions;
        optionsByRemovingOptions(_: NSUserInterfaceCompressionOptions): NSUserInterfaceCompressionOptions;
    }
    interface NSUserInterfaceItemIdentification {
        identifier: string;
        setIdentifier(_: string): any;
    }
    interface NSUserInterfaceItemSearching extends NSObject {
        localizedTitlesForItem(forItem: any): string[];
        performActionForItem?(forItem: any): void;
        searchForItemsWithWithSearchResultLimitMatchedItemHandler(withSearch: string, resultLimit: number, matchedItemHandler: (p1: any[]) => void): void;
        showAllHelpTopicsForSearchString?(forSearch: string): void;
    }
    interface NSUserInterfaceValidations {
        validateUserInterfaceItem(_: NSValidatedUserInterfaceItem): boolean;
    }
    interface NSValidatedUserInterfaceItem {
        action: string;
        tag: number;
    }
    class NSView extends NSResponder {
        alignmentRectInsets: NSEdgeInsets;
        allowedTouchTypes: NSTouch.TouchTypeMask;
        setAllowedTouchTypes(_: NSTouch.TouchTypeMask): any;
        allowsVibrancy: boolean;
        alphaValue: number;
        setAlphaValue(_: number): any;
        autoresizesSubviews: boolean;
        setAutoresizesSubviews(_: boolean): any;
        autoresizingMask: NSView.AutoresizingMask;
        setAutoresizingMask(_: NSView.AutoresizingMask): any;
        backgroundFilters: CIFilter[];
        setBackgroundFilters(_: CIFilter[]): any;
        baselineOffsetFromBottom: number;
        bottomAnchor: NSLayoutYAxisAnchor;
        bounds: CGRect;
        setBounds(_: CGRect): any;
        boundsRotation: number;
        setBoundsRotation(_: number): any;
        canBecomeKeyView: boolean;
        canDrawConcurrently: boolean;
        setCanDrawConcurrently(_: boolean): any;
        canDrawSubviewsIntoLayer: boolean;
        setCanDrawSubviewsIntoLayer(_: boolean): any;
        candidateListTouchBarItem: NSCandidateListTouchBarItem<any>;
        centerXAnchor: NSLayoutXAxisAnchor;
        centerYAnchor: NSLayoutYAxisAnchor;
        compositingFilter: CIFilter;
        setCompositingFilter(_: CIFilter): any;
        constraints: NSLayoutConstraint[];
        contentFilters: CIFilter[];
        setContentFilters(_: CIFilter[]): any;
        isDrawingFindIndicator: boolean;
        enclosingMenuItem: NSMenuItem;
        enclosingScrollView: NSScrollView;
        firstBaselineAnchor: NSLayoutYAxisAnchor;
        firstBaselineOffsetFromTop: number;
        fittingSize: CGSize;
        isFlipped: boolean;
        focusRingMaskBounds: CGRect;
        focusRingType: NSFocusRingType;
        setFocusRingType(_: NSFocusRingType): any;
        frame: CGRect;
        setFrame(_: CGRect): any;
        frameCenterRotation: number;
        setFrameCenterRotation(_: number): any;
        frameRotation: number;
        setFrameRotation(_: number): any;
        gestureRecognizers: NSGestureRecognizer[];
        setGestureRecognizers(_: NSGestureRecognizer[]): any;
        hasAmbiguousLayout: boolean;
        heightAdjustLimit: number;
        heightAnchor: NSLayoutDimension;
        isHidden: boolean;
        setHidden(_: boolean): any;
        isHiddenOrHasHiddenAncestor: boolean;
        isHorizontalContentSizeConstraintActive: boolean;
        setHorizontalContentSizeConstraintActive(_: boolean): any;
        isInFullScreenMode: boolean;
        inLiveResize: boolean;
        inputContext: NSTextInputContext;
        intrinsicContentSize: CGSize;
        lastBaselineAnchor: NSLayoutYAxisAnchor;
        lastBaselineOffsetFromBottom: number;
        layer: CALayer;
        setLayer(_: CALayer): any;
        layerContentsPlacement: NSView.LayerContentsPlacement;
        setLayerContentsPlacement(_: NSView.LayerContentsPlacement): any;
        layerContentsRedrawPolicy: NSView.LayerContentsRedrawPolicy;
        setLayerContentsRedrawPolicy(_: NSView.LayerContentsRedrawPolicy): any;
        layerUsesCoreImageFilters: boolean;
        setLayerUsesCoreImageFilters(_: boolean): any;
        layoutGuides: NSLayoutGuide[];
        leadingAnchor: NSLayoutXAxisAnchor;
        leftAnchor: NSLayoutXAxisAnchor;
        mouseDownCanMoveWindow: boolean;
        needsDisplay: boolean;
        setNeedsDisplay(_: boolean): any;
        needsLayout: boolean;
        setNeedsLayout(_: boolean): any;
        needsPanelToBecomeKey: boolean;
        needsUpdateConstraints: boolean;
        setNeedsUpdateConstraints(_: boolean): any;
        nextKeyView: NSView;
        setNextKeyView(_: NSView): any;
        nextValidKeyView: NSView;
        isOpaque: boolean;
        opaqueAncestor: NSView;
        pageFooter: NSAttributedString;
        pageHeader: NSAttributedString;
        postsBoundsChangedNotifications: boolean;
        setPostsBoundsChangedNotifications(_: boolean): any;
        postsFrameChangedNotifications: boolean;
        setPostsFrameChangedNotifications(_: boolean): any;
        preparedContentRect: CGRect;
        setPreparedContentRect(_: CGRect): any;
        preservesContentDuringLiveResize: boolean;
        pressureConfiguration: NSPressureConfiguration;
        setPressureConfiguration(_: NSPressureConfiguration): any;
        previousKeyView: NSView;
        previousValidKeyView: NSView;
        printJobTitle: string;
        rectPreservedDuringLiveResize: CGRect;
        registeredDraggedTypes: string[];
        rightAnchor: NSLayoutXAxisAnchor;
        isRotatedFromBase: boolean;
        isRotatedOrScaledFromBase: boolean;
        shadow: NSShadow;
        setShadow(_: NSShadow): any;
        subviews: NSView[];
        setSubviews(_: NSView[]): any;
        superview: NSView;
        tag: number;
        toolTip: string;
        setToolTip(_: string): any;
        topAnchor: NSLayoutYAxisAnchor;
        trackingAreas: NSTrackingArea[];
        trailingAnchor: NSLayoutXAxisAnchor;
        translatesAutoresizingMaskIntoConstraints: boolean;
        setTranslatesAutoresizingMaskIntoConstraints(_: boolean): any;
        userInterfaceLayoutDirection: NSUserInterfaceLayoutDirection;
        setUserInterfaceLayoutDirection(_: NSUserInterfaceLayoutDirection): any;
        isVerticalContentSizeConstraintActive: boolean;
        setVerticalContentSizeConstraintActive(_: boolean): any;
        visibleRect: CGRect;
        wantsDefaultClipping: boolean;
        wantsLayer: boolean;
        setWantsLayer(_: boolean): any;
        wantsRestingTouches: boolean;
        setWantsRestingTouches(_: boolean): any;
        wantsUpdateLayer: boolean;
        widthAdjustLimit: number;
        widthAnchor: NSLayoutDimension;
        window: NSWindow;
        static isCompatibleWithResponsiveScrolling: boolean;
        static defaultFocusRingType: NSFocusRingType;
        static defaultMenu: NSMenu;
        static focusView: NSView;
        static requiresConstraintBasedLayout: boolean;
        acceptsFirstMouse(for_?: NSEvent): boolean;
        addConstraint(_: NSLayoutConstraint): void;
        addConstraints(_: NSLayoutConstraint[]): void;
        addCursorRectCursor(_: CGRect, cursor: NSCursor): void;
        addGestureRecognizer(_: NSGestureRecognizer): void;
        addLayoutGuide(_: NSLayoutGuide): void;
        addSubview(_: NSView): void;
        addSubviewPositionedRelativeTo(_: NSView, positioned: NSWindow.OrderingMode, relativeTo?: NSView): void;
        addToolTipRectOwnerUserData(_: CGRect, owner: any, userData?: any): number;
        addTrackingArea(_: NSTrackingArea): void;
        addTrackingRectOwnerUserDataAssumeInside(_: CGRect, owner: any, userData?: any, assumeInside?: boolean): number;
        adjustPageHeightNewTopBottomLimit(_: number, top: number, bottom: number, limit: number): void;
        adjustPageWidthNewLeftRightLimit(_: number, left: number, right: number, limit: number): void;
        adjustScroll(_: CGRect): CGRect;
        alignmentRectForFrame(forFrame: CGRect): CGRect;
        ancestorSharedWithView(with_: NSView): NSView;
        autoscroll(with_: NSEvent): boolean;
        backingAlignedRectOptions(_: CGRect, options: AlignmentOptions): CGRect;
        beginDocument(): void;
        beginDraggingSessionWithItemsEventSource(with_: NSDraggingItem[], event: NSEvent, source: NSDraggingSource): NSDraggingSession;
        beginPageInRectAtPlacement(in_: CGRect, atPlacement: CGPoint): void;
        bitmapImageRepForCachingDisplayInRect(in_: CGRect): NSBitmapImageRep;
        cacheDisplayInRectToBitmapImageRep(in_: CGRect, to: NSBitmapImageRep): void;
        centerScanRect(_: CGRect): CGRect;
        constraintsAffectingLayoutForOrientation(for_: NSLayoutConstraint.Orientation): NSLayoutConstraint[];
        contentCompressionResistancePriorityForOrientation(for_: NSLayoutConstraint.Orientation): number;
        contentHuggingPriorityForOrientation(for_: NSLayoutConstraint.Orientation): number;
        convertPointFromView(_: CGPoint, from?: NSView): CGPoint;
        convertPointToView(_: CGPoint, to?: NSView): CGPoint;
        convertPointFromBacking(_: CGPoint): CGPoint;
        convertPointFromLayer(_: CGPoint): CGPoint;
        convertPointToBacking(_: CGPoint): CGPoint;
        convertPointToLayer(_: CGPoint): CGPoint;
        convertRectFromView(_: CGRect, from?: NSView): CGRect;
        convertRectToView(_: CGRect, to?: NSView): CGRect;
        convertRectFromBacking(_: CGRect): CGRect;
        convertRectFromLayer(_: CGRect): CGRect;
        convertRectToBacking(_: CGRect): CGRect;
        convertRectToLayer(_: CGRect): CGRect;
        convertSizeFromView(_: CGSize, from?: NSView): CGSize;
        convertSizeToView(_: CGSize, to?: NSView): CGSize;
        convertSizeFromBacking(_: CGSize): CGSize;
        convertSizeFromLayer(_: CGSize): CGSize;
        convertSizeToBacking(_: CGSize): CGSize;
        convertSizeToLayer(_: CGSize): CGSize;
        dataWithEPSInsideRect(inside: CGRect): NSData;
        dataWithPDFInsideRect(inside: CGRect): NSData;
        didAddSubview(_: NSView): void;
        didCloseMenuWithEvent(_: NSMenu, with_?: NSEvent): void;
        discardCursorRects(): void;
        display(): void;
        displayIfNeeded(): void;
        displayIfNeededIgnoringOpacity(): void;
        displayIfNeededInRect(_: CGRect): void;
        displayIfNeededInRectIgnoringOpacity(_: CGRect): void;
        displayRect(_: CGRect): void;
        displayRectIgnoringOpacity(_: CGRect): void;
        displayRectIgnoringOpacityInContext(_: CGRect, in_: NSGraphicsContext): void;
        drawFocusRingMask(): void;
        drawPageBorderWithSize(with_: CGSize): void;
        drawRect(_: CGRect): void;
        endDocument(): void;
        endPage(): void;
        enterFullScreenModeWithOptions(_: NSScreen, withOptions?: Map<string, any>): boolean;
        exerciseAmbiguityInLayout(): void;
        exitFullScreenModeWithOptions(options?: Map<string, any>): void;
        frameForAlignmentRect(forAlignmentRect: CGRect): CGRect;
        getRectsBeingDrawnCount(_?: NSRect, count?: number): void;
        getRectsExposedDuringLiveResizeCount(_: NSRect, count: number): void;
        hitTest(_: CGPoint): NSView;
        static createWithFrame(frame: CGRect): NSView;
        invalidateIntrinsicContentSize(): void;
        isDescendantOf(of: NSView): boolean;
        knowsPageRange(_: NSRange): boolean;
        layout(): void;
        layoutSubtreeIfNeeded(): void;
        locationOfPrintRect(_: CGRect): CGPoint;
        makeBackingLayer(): CALayer;
        menuForEvent(for_: NSEvent): NSMenu;
        mouseInRect(_: CGPoint, in_: CGRect): boolean;
        needsToDrawRect(_: CGRect): boolean;
        noteFocusRingMaskChanged(): void;
        prepareContentInRect(in_: CGRect): void;
        prepareForReuse(): void;
        print(_?: any): void;
        rectForPage(_: number): CGRect;
        rectForSmartMagnificationAtPointInRect(at: CGPoint, in_: CGRect): CGRect;
        reflectScrolledClipView(_: NSClipView): void;
        registerForDraggedTypes(_: string[]): void;
        removeAllToolTips(): void;
        removeConstraint(_: NSLayoutConstraint): void;
        removeConstraints(_: NSLayoutConstraint[]): void;
        removeCursorRectCursor(_: CGRect, cursor: NSCursor): void;
        removeFromSuperview(): void;
        removeFromSuperviewWithoutNeedingDisplay(): void;
        removeGestureRecognizer(_: NSGestureRecognizer): void;
        removeLayoutGuide(_: NSLayoutGuide): void;
        removeToolTip(_: number): void;
        removeTrackingArea(_: NSTrackingArea): void;
        removeTrackingRect(_: number): void;
        replaceSubviewWith(_: NSView, with_: NSView): void;
        resetCursorRects(): void;
        resizeSubviewsWithOldSize(withOldSize: CGSize): void;
        resizeWithOldSuperviewSize(withOldSuperviewSize: CGSize): void;
        rotateByAngle(byDegrees: number): void;
        rulerViewDidAddMarker(_: NSRulerView, didAdd: NSRulerMarker): void;
        rulerViewDidMoveMarker(_: NSRulerView, didMove: NSRulerMarker): void;
        rulerViewDidRemoveMarker(_: NSRulerView, didRemove: NSRulerMarker): void;
        rulerViewHandleMouseDown(_: NSRulerView, handleMouseDownWith: NSEvent): void;
        rulerViewLocationForPoint(_: NSRulerView, locationFor: CGPoint): number;
        rulerViewPointForLocation(_: NSRulerView, pointForLocation: number): CGPoint;
        rulerViewShouldAddMarker(_: NSRulerView, shouldAdd: NSRulerMarker): boolean;
        rulerViewShouldMoveMarker(_: NSRulerView, shouldMove: NSRulerMarker): boolean;
        rulerViewShouldRemoveMarker(_: NSRulerView, shouldRemove: NSRulerMarker): boolean;
        rulerViewWillAddMarkerAtLocation(_: NSRulerView, willAdd: NSRulerMarker, atLocation: number): number;
        rulerViewWillMoveMarkerToLocation(_: NSRulerView, willMove: NSRulerMarker, toLocation: number): number;
        rulerViewWillSetClientView(_: NSRulerView, willSetClientView: NSView): void;
        scaleUnitSquareToSize(to: CGSize): void;
        scrollClipViewToPoint(_: NSClipView, to: CGPoint): void;
        scrollPoint(_: CGPoint): void;
        scrollRectToVisible(_: CGRect): boolean;
        setBoundsOrigin(_: CGPoint): void;
        setBoundsSize(_: CGSize): void;
        setContentCompressionResistancePriorityForOrientation(_: number, for_: NSLayoutConstraint.Orientation): void;
        setContentHuggingPriorityForOrientation(_: number, for_: NSLayoutConstraint.Orientation): void;
        setFrameOrigin(_: CGPoint): void;
        setFrameSize(_: CGSize): void;
        setKeyboardFocusRingNeedsDisplayInRect(_: CGRect): void;
        setNeedsDisplayInRect(_: CGRect): void;
        shouldDelayWindowOrderingForEvent(for_: NSEvent): boolean;
        showDefinitionForAttributedStringAtPoint(for_?: NSAttributedString, at?: CGPoint): void;
        showDefinitionForRangeOptionsBaselineOriginProvider(for_?: NSAttributedString, range?: NSRange, options?: Map<string, any>, baselineOriginProvider?: (p1: NSRange) => CGPoint): void;
        sortSubviewsContext(_?: (p1: NSView, p2: NSView, p3: any) => ComparisonResult, context?: any): void;
        translateOriginToPoint(to: CGPoint): void;
        translateRectsNeedingDisplayInRectBy(in_: CGRect, by: CGSize): void;
        unregisterDraggedTypes(): void;
        updateConstraints(): void;
        updateConstraintsForSubtreeIfNeeded(): void;
        updateLayer(): void;
        updateTrackingAreas(): void;
        viewDidChangeBackingProperties(): void;
        viewDidChangeEffectiveAppearance(): void;
        viewDidEndLiveResize(): void;
        viewDidHide(): void;
        viewDidMoveToSuperview(): void;
        viewDidMoveToWindow(): void;
        viewDidUnhide(): void;
        viewWillDraw(): void;
        viewWillMoveToSuperview(toSuperview?: NSView): void;
        viewWillMoveToWindow(toWindow?: NSWindow): void;
        viewWillStartLiveResize(): void;
        viewWithTag(_: number): NSView;
        willOpenMenuWithEvent(_: NSMenu, with_: NSEvent): void;
        willRemoveSubview(_: NSView): void;
        writeEPSInsideRectToPasteboard(inside: CGRect, to: NSPasteboard): void;
        writePDFInsideRectToPasteboard(inside: CGRect, to: NSPasteboard): void;
    }
    class NSViewAnimation extends NSAnimation {
        viewAnimations: Map<string, any>[];
        setViewAnimations(_: Map<string, any>[]): any;
        static createWithViewAnimations(viewAnimations: Map<string, any>[]): NSViewAnimation;
    }
    class NSViewController extends NSResponder {
        childViewControllers: NSViewController[];
        setChildViewControllers(_: NSViewController[]): any;
        extensionContext: NSExtensionContext;
        nibBundle: Bundle;
        nibName: string;
        parentViewController: NSViewController;
        preferredContentSize: CGSize;
        setPreferredContentSize(_: CGSize): any;
        preferredMaximumSize: CGSize;
        preferredMinimumSize: CGSize;
        preferredScreenOrigin: CGPoint;
        setPreferredScreenOrigin(_: CGPoint): any;
        presentedViewControllers: NSViewController[];
        presentingViewController: NSViewController;
        representedObject: any;
        setRepresentedObject(_: any): any;
        sourceItemView: NSView;
        setSourceItemView(_: NSView): any;
        storyboard: NSStoryboard;
        title: string;
        setTitle(_: string): any;
        view: NSView;
        setView(_: NSView): any;
        isViewLoaded: boolean;
        addChildViewController(_: NSViewController): void;
        dismissController(_?: any): void;
        dismissViewController(_: NSViewController): void;
        static createWithNibNameBundle(nibName?: string, bundle?: Bundle): NSViewController;
        insertChildViewControllerAtIndex(_: NSViewController, at: number): void;
        loadView(): void;
        preferredContentSizeDidChangeForViewController(for_: NSViewController): void;
        presentViewControllerAnimator(_: NSViewController, animator: NSViewControllerPresentationAnimator): void;
        presentViewControllerAsPopoverRelativeToRectOfViewPreferredEdgeBehavior(_: NSViewController, asPopoverRelativeTo: CGRect, of: NSView, preferredEdge: NSRectEdge, behavior: NSPopover.Behavior): void;
        presentViewControllerAsModalWindow(_: NSViewController): void;
        presentViewControllerAsSheet(_: NSViewController): void;
        removeChildViewControllerAtIndex(at: number): void;
        removeFromParentViewController(): void;
        transitionWithFromToOptionsCompletionHandler(from: NSViewController, to: NSViewController, options: NSViewController.TransitionOptions, completionHandler?: () => void): void;
        updateViewConstraints(): void;
        viewDidAppear(): void;
        viewDidDisappear(): void;
        viewDidLayout(): void;
        viewDidLoad(): void;
        viewWillAppear(): void;
        viewWillDisappear(): void;
        viewWillLayout(): void;
        viewWillTransitionToSize(to: CGSize): void;
    }
    interface NSViewControllerPresentationAnimator extends NSObject {
        animateDismissalOfViewControllerFromViewController(of: NSViewController, from: NSViewController): void;
        animatePresentationOfViewControllerFromViewController(of: NSViewController, from: NSViewController): void;
    }
    interface NSViewLayerContentScaleDelegate extends NSObject {
        layerShouldInheritContentsScaleFromWindow?(_: CALayer, shouldInheritContentsScale: number, from: NSWindow): boolean;
    }
    interface NSViewToolTipOwner extends NSObject {
        viewStringForToolTipPointUserData(_: NSView, stringForToolTip: number, point: CGPoint, userData?: any): string;
    }
    class NSVisualEffectView extends NSView {
        blendingMode: NSVisualEffectView.BlendingMode;
        setBlendingMode(_: NSVisualEffectView.BlendingMode): any;
        isEmphasized: boolean;
        setEmphasized(_: boolean): any;
        interiorBackgroundStyle: NSView.BackgroundStyle;
        maskImage: NSImage;
        setMaskImage(_: NSImage): any;
        material: NSVisualEffectView.Material;
        setMaterial(_: NSVisualEffectView.Material): any;
        state: NSVisualEffectView.State;
        setState(_: NSVisualEffectView.State): any;
    }
    class NSWindow extends NSResponder {
        static contentRectForFrameRectStyleMask(forFrameRect: CGRect, styleMask: NSWindow.StyleMask): CGRect;
        static frameRectForContentRectStyleMask(forContentRect: CGRect, styleMask: NSWindow.StyleMask): CGRect;
        static minFrameWidthWithTitleStyleMask(withTitle: string, styleMask: NSWindow.StyleMask): number;
        static removeFrameUsingName(usingName: string): void;
        static standardWindowButtonForStyleMask(_: NSWindow.ButtonType, for_: NSWindow.StyleMask): NSButton;
        static windowNumberAtPointBelowWindowWithWindowNumber(at: CGPoint, belowWindowWithWindowNumber: number): number;
        static windowNumbersWithOptions(options: NSWindow.NumberListOptions): number[];
        acceptsMouseMovedEvents: boolean;
        setAcceptsMouseMovedEvents(_: boolean): any;
        allowsConcurrentViewDrawing: boolean;
        setAllowsConcurrentViewDrawing(_: boolean): any;
        allowsToolTipsWhenApplicationIsInactive: boolean;
        setAllowsToolTipsWhenApplicationIsInactive(_: boolean): any;
        alphaValue: number;
        setAlphaValue(_: number): any;
        animationBehavior: NSWindow.AnimationBehavior;
        setAnimationBehavior(_: NSWindow.AnimationBehavior): any;
        appearanceSource: NSObject;
        setAppearanceSource(_: NSObject): any;
        areCursorRectsEnabled: boolean;
        aspectRatio: CGSize;
        setAspectRatio(_: CGSize): any;
        attachedSheet: NSWindow;
        autorecalculatesKeyViewLoop: boolean;
        setAutorecalculatesKeyViewLoop(_: boolean): any;
        backgroundColor: NSColor;
        setBackgroundColor(_: NSColor): any;
        backingScaleFactor: number;
        backingType: NSWindow.BackingStoreType;
        setBackingType(_: NSWindow.BackingStoreType): any;
        canBecomeKeyWindow: boolean;
        canBecomeMainWindow: boolean;
        canBecomeVisibleWithoutLogin: boolean;
        setCanBecomeVisibleWithoutLogin(_: boolean): any;
        canHide: boolean;
        setCanHide(_: boolean): any;
        childWindows: NSWindow[];
        collectionBehavior: NSWindow.CollectionBehavior;
        setCollectionBehavior(_: NSWindow.CollectionBehavior): any;
        colorSpace: NSColorSpace;
        setColorSpace(_: NSColorSpace): any;
        contentAspectRatio: CGSize;
        setContentAspectRatio(_: CGSize): any;
        contentLayoutGuide: any;
        contentLayoutRect: CGRect;
        contentMaxSize: CGSize;
        setContentMaxSize(_: CGSize): any;
        contentMinSize: CGSize;
        setContentMinSize(_: CGSize): any;
        contentResizeIncrements: CGSize;
        setContentResizeIncrements(_: CGSize): any;
        contentView: NSView;
        setContentView(_: NSView): any;
        contentViewController: NSViewController;
        setContentViewController(_: NSViewController): any;
        currentEvent: NSEvent;
        deepestScreen: NSScreen;
        defaultButtonCell: NSButtonCell;
        setDefaultButtonCell(_: NSButtonCell): any;
        delegate: NSWindowDelegate;
        setDelegate(_: NSWindowDelegate): any;
        depthLimit: NSWindow.Depth;
        setDepthLimit(_: NSWindow.Depth): any;
        deviceDescription: Map<string, any>;
        displaysWhenScreenProfileChanges: boolean;
        setDisplaysWhenScreenProfileChanges(_: boolean): any;
        dockTile: NSDockTile;
        isDocumentEdited: boolean;
        setDocumentEdited(_: boolean): any;
        isExcludedFromWindowsMenu: boolean;
        setExcludedFromWindowsMenu(_: boolean): any;
        firstResponder: NSResponder;
        isFloatingPanel: boolean;
        frame: CGRect;
        frameAutosaveName: string;
        hasCloseBox: boolean;
        hasDynamicDepthLimit: boolean;
        hasShadow: boolean;
        setHasShadow(_: boolean): any;
        hasTitleBar: boolean;
        hidesOnDeactivate: boolean;
        setHidesOnDeactivate(_: boolean): any;
        ignoresMouseEvents: boolean;
        setIgnoresMouseEvents(_: boolean): any;
        inLiveResize: boolean;
        initialFirstResponder: NSView;
        setInitialFirstResponder(_: NSView): any;
        keyViewSelectionDirection: NSWindow.SelectionDirection;
        isKeyWindow: boolean;
        level: number;
        setLevel(_: number): any;
        isMainWindow: boolean;
        maxFullScreenContentSize: CGSize;
        setMaxFullScreenContentSize(_: CGSize): any;
        maxSize: CGSize;
        setMaxSize(_: CGSize): any;
        minFullScreenContentSize: CGSize;
        setMinFullScreenContentSize(_: CGSize): any;
        minSize: CGSize;
        setMinSize(_: CGSize): any;
        isMiniaturizable: boolean;
        isMiniaturized: boolean;
        miniwindowImage: NSImage;
        setMiniwindowImage(_: NSImage): any;
        miniwindowTitle: string;
        setMiniwindowTitle(_: string): any;
        isModalPanel: boolean;
        mouseLocationOutsideOfEventStream: CGPoint;
        isMovable: boolean;
        setMovable(_: boolean): any;
        isMovableByWindowBackground: boolean;
        setMovableByWindowBackground(_: boolean): any;
        occlusionState: NSWindow.OcclusionState;
        isOnActiveSpace: boolean;
        isOpaque: boolean;
        setOpaque(_: boolean): any;
        orderedIndex: number;
        setOrderedIndex(_: number): any;
        parentWindow: NSWindow;
        setParentWindow(_: NSWindow): any;
        preservesContentDuringLiveResize: boolean;
        setPreservesContentDuringLiveResize(_: boolean): any;
        preventsApplicationTerminationWhenModal: boolean;
        setPreventsApplicationTerminationWhenModal(_: boolean): any;
        isReleasedWhenClosed: boolean;
        setReleasedWhenClosed(_: boolean): any;
        representedFilename: string;
        setRepresentedFilename(_: string): any;
        representedURL: NSURL;
        setRepresentedURL(_: NSURL): any;
        isResizable: boolean;
        resizeFlags: NSEvent.ModifierFlags;
        resizeIncrements: CGSize;
        setResizeIncrements(_: CGSize): any;
        isRestorable: boolean;
        setRestorable(_: boolean): any;
        restorationClass: typeof NSObject;
        setRestorationClass(_: typeof NSObject): any;
        screen: NSScreen;
        sharingType: NSWindow.SharingType;
        setSharingType(_: NSWindow.SharingType): any;
        isSheet: boolean;
        sheetParent: NSWindow;
        sheets: NSWindow[];
        showsResizeIndicator: boolean;
        setShowsResizeIndicator(_: boolean): any;
        showsToolbarButton: boolean;
        setShowsToolbarButton(_: boolean): any;
        stringWithSavedFrame: string;
        styleMask: NSWindow.StyleMask;
        setStyleMask(_: NSWindow.StyleMask): any;
        tab: NSWindowTab;
        tabGroup: NSWindowTabGroup;
        tabbedWindows: NSWindow[];
        tabbingIdentifier: string;
        setTabbingIdentifier(_: string): any;
        tabbingMode: NSWindow.TabbingMode;
        setTabbingMode(_: NSWindow.TabbingMode): any;
        title: string;
        setTitle(_: string): any;
        titleVisibility: NSWindow.TitleVisibility;
        setTitleVisibility(_: NSWindow.TitleVisibility): any;
        titlebarAccessoryViewControllers: NSTitlebarAccessoryViewController[];
        setTitlebarAccessoryViewControllers(_: NSTitlebarAccessoryViewController[]): any;
        titlebarAppearsTransparent: boolean;
        setTitlebarAppearsTransparent(_: boolean): any;
        toolbar: NSToolbar;
        setToolbar(_: NSToolbar): any;
        viewsNeedDisplay: boolean;
        setViewsNeedDisplay(_: boolean): any;
        isVisible: boolean;
        windowController: NSWindowController;
        setWindowController(_: NSWindowController): any;
        windowNumber: number;
        windowRef: any;
        windowTitlebarLayoutDirection: NSUserInterfaceLayoutDirection;
        worksWhenModal: boolean;
        isZoomable: boolean;
        isZoomed: boolean;
        static allowsAutomaticWindowTabbing: boolean;
        setAllowsAutomaticWindowTabbing(_: boolean): any;
        static defaultDepthLimit: NSWindow.Depth;
        static userTabbingPreference: NSWindow.UserTabbingPreference;
        addChildWindowOrdered(_: NSWindow, ordered: NSWindow.OrderingMode): void;
        addTabbedWindowOrdered(_: NSWindow, ordered: NSWindow.OrderingMode): void;
        addTitlebarAccessoryViewController(_: NSTitlebarAccessoryViewController): void;
        anchorAttributeForOrientation(for_: NSLayoutConstraint.Orientation): NSLayoutConstraint.Attribute;
        animationResizeTime(_: CGRect): number;
        autorecalculatesContentBorderThicknessForEdge(for_: NSRectEdge): boolean;
        backingAlignedRectOptions(_: CGRect, options: AlignmentOptions): CGRect;
        becomeKeyWindow(): void;
        becomeMainWindow(): void;
        beginCriticalSheetWithCompletionHandler(_: NSWindow, completionHandler?: (p1: number) => void): void;
        beginSheetWithCompletionHandler(_: NSWindow, completionHandler?: (p1: number) => void): void;
        canRepresentDisplayGamut(_: NSDisplayGamut): boolean;
        cascadeTopLeftFromPoint(from: CGPoint): CGPoint;
        center(): void;
        close(): void;
        constrainFrameRectToScreen(_: CGRect, to?: NSScreen): CGRect;
        contentBorderThicknessForEdge(for_: NSRectEdge): number;
        contentRectForFrameRect(forFrameRect: CGRect): CGRect;
        convertPointFromBacking(_: CGPoint): CGPoint;
        convertPointFromScreen(fromScreen: CGPoint): CGPoint;
        convertPointToBacking(_: CGPoint): CGPoint;
        convertPointToScreen(toScreen: CGPoint): CGPoint;
        convertRectFromBacking(_: CGRect): CGRect;
        convertRectFromScreen(_: CGRect): CGRect;
        convertRectToBacking(_: CGRect): CGRect;
        convertRectToScreen(_: CGRect): CGRect;
        dataWithEPSInsideRect(inside: CGRect): NSData;
        dataWithPDFInsideRect(inside: CGRect): NSData;
        deminiaturize(_?: any): void;
        disableCursorRects(): void;
        disableKeyEquivalentForDefaultButtonCell(): void;
        disableScreenUpdatesUntilFlush(): void;
        disableSnapshotRestoration(): void;
        discardCursorRects(): void;
        discardEventsMatchingMaskBeforeEvent(matching: NSEvent.EventTypeMask, before?: NSEvent): void;
        display(): void;
        displayIfNeeded(): void;
        dragImageAtOffsetEventPasteboardSourceSlideBack(_: NSImage, at: CGPoint, offset: CGSize, event: NSEvent, pasteboard: NSPasteboard, source: any, slideBack: boolean): void;
        enableCursorRects(): void;
        enableKeyEquivalentForDefaultButtonCell(): void;
        enableSnapshotRestoration(): void;
        endEditingFor(for_?: any): void;
        endSheet(_: NSWindow): void;
        endSheetReturnCode(_: NSWindow, returnCode: number): void;
        fieldEditorForObject(_: boolean, for_?: any): NSText;
        frameRectForContentRect(forContentRect: CGRect): CGRect;
        handleCloseScriptCommand(_: NSCloseCommand): any;
        handlePrintScriptCommand(_: NSScriptCommand): any;
        handleSaveScriptCommand(_: NSScriptCommand): any;
        static createWithContentRectStyleMaskBackingDefer(contentRect: CGRect, styleMask: NSWindow.StyleMask, backing: NSWindow.BackingStoreType, defer: boolean): NSWindow;
        static createWithContentRectStyleMaskBackingDeferScreen(contentRect: CGRect, styleMask: NSWindow.StyleMask, backing: NSWindow.BackingStoreType, defer: boolean, screen?: NSScreen): NSWindow;
        static createWithWindowRef(windowRef: any): NSWindow;
        insertTitlebarAccessoryViewControllerAtIndex(_: NSTitlebarAccessoryViewController, at: number): void;
        invalidateCursorRectsForView(for_: NSView): void;
        invalidateShadow(): void;
        layoutIfNeeded(): void;
        makeFirstResponder(_?: NSResponder): boolean;
        makeKeyAndOrderFront(_?: any): void;
        makeKeyWindow(): void;
        makeMainWindow(): void;
        mergeAllWindows(_?: any): void;
        miniaturize(_?: any): void;
        moveTabToNewWindow(_?: any): void;
        nextEventMatchingMask(matching: NSEvent.EventTypeMask): NSEvent;
        nextEventMatchingMaskUntilDateInModeDequeue(matching: NSEvent.EventTypeMask, until?: Date, inMode?: string, dequeue?: boolean): NSEvent;
        orderBack(_?: any): void;
        orderFront(_?: any): void;
        orderFrontRegardless(): void;
        orderOut(_?: any): void;
        orderWindowRelativeTo(_: NSWindow.OrderingMode, relativeTo: number): void;
        performClose(_?: any): void;
        performMiniaturize(_?: any): void;
        performWindowDragWithEvent(with_: NSEvent): void;
        performZoom(_?: any): void;
        postEventAtStart(_: NSEvent, atStart: boolean): void;
        print(_?: any): void;
        recalculateKeyViewLoop(): void;
        registerForDraggedTypes(_: string[]): void;
        removeChildWindow(_: NSWindow): void;
        removeTitlebarAccessoryViewControllerAtIndex(at: number): void;
        resetCursorRects(): void;
        resignKeyWindow(): void;
        resignMainWindow(): void;
        runToolbarCustomizationPalette(_?: any): void;
        saveFrameUsingName(usingName: string): void;
        selectKeyViewFollowingView(following: NSView): void;
        selectKeyViewPrecedingView(preceding: NSView): void;
        selectNextKeyView(_?: any): void;
        selectNextTab(_?: any): void;
        selectPreviousKeyView(_?: any): void;
        selectPreviousTab(_?: any): void;
        sendEvent(_: NSEvent): void;
        setAnchorAttributeForOrientation(_: NSLayoutConstraint.Attribute, for_: NSLayoutConstraint.Orientation): void;
        setAutorecalculatesContentBorderThicknessForEdge(_: boolean, for_: NSRectEdge): void;
        setContentBorderThicknessForEdge(_: number, for_: NSRectEdge): void;
        setContentSize(_: CGSize): void;
        setDynamicDepthLimit(_: boolean): void;
        setFrameDisplay(_: CGRect, display: boolean): void;
        setFrameDisplayAnimate(_: CGRect, display: boolean, animate: boolean): void;
        setFrameAutosaveName(_: string): boolean;
        setFrameFromString(from: string): void;
        setFrameOrigin(_: CGPoint): void;
        setFrameTopLeftPoint(_: CGPoint): void;
        setFrameUsingName(_: string): boolean;
        setFrameUsingNameForce(_: string, force: boolean): boolean;
        setIsMiniaturized(_: boolean): void;
        setIsVisible(_: boolean): void;
        setIsZoomed(_: boolean): void;
        setTitleWithRepresentedFilename(_: string): void;
        standardWindowButton(_: NSWindow.ButtonType): NSButton;
        toggleFullScreen(_?: any): void;
        toggleTabBar(_?: any): void;
        toggleTabOverview(_?: any): void;
        toggleToolbarShown(_?: any): void;
        trackEventsWithMatchingTimeoutModeHandler(matching: NSEvent.EventTypeMask, timeout: number, mode: string, handler?: (p1: NSEvent, p2: boolean) => void): void;
        unregisterDraggedTypes(): void;
        update(): void;
        updateConstraintsIfNeeded(): void;
        visualizeConstraints(_?: NSLayoutConstraint[]): void;
        zoom(_?: any): void;
    }
    class NSWindowController extends NSResponder {
        contentViewController: NSViewController;
        setContentViewController(_: NSViewController): any;
        document: any;
        setDocument(_: any): any;
        owner: any;
        shouldCascadeWindows: boolean;
        setShouldCascadeWindows(_: boolean): any;
        shouldCloseDocument: boolean;
        setShouldCloseDocument(_: boolean): any;
        storyboard: NSStoryboard;
        window: NSWindow;
        setWindow(_: NSWindow): any;
        windowFrameAutosaveName: string;
        setWindowFrameAutosaveName(_: string): any;
        isWindowLoaded: boolean;
        windowNibName: string;
        windowNibPath: string;
        close(): void;
        dismissController(_?: any): void;
        static createWithWindow(window?: NSWindow): NSWindowController;
        static createWithWindowNibName(windowNibName: string): NSWindowController;
        static createWithWindowNibNameOwner(windowNibName: string, owner: any): NSWindowController;
        static createWithWindowNibPathOwner(windowNibPath: string, owner: any): NSWindowController;
        loadWindow(): void;
        setDocumentEdited(_: boolean): void;
        showWindow(_?: any): void;
        synchronizeWindowTitleWithDocumentName(): void;
        windowDidLoad(): void;
        windowTitleForDocumentDisplayName(forDocumentDisplayName: string): string;
        windowWillLoad(): void;
    }
    interface NSWindowDelegate extends NSObject {
        customWindowsToEnterFullScreenForWindow?(for_: NSWindow): NSWindow[];
        customWindowsToEnterFullScreenForWindowOnScreen?(for_: NSWindow, on: NSScreen): NSWindow[];
        customWindowsToExitFullScreenForWindow?(for_: NSWindow): NSWindow[];
        windowWillPositionSheetUsingRect?(_: NSWindow, willPositionSheet: NSWindow, using: CGRect): CGRect;
        windowShouldDragDocumentWithEventFromWithPasteboard?(_: NSWindow, shouldDragDocumentWith: NSEvent, from: CGPoint, with_: NSPasteboard): boolean;
        windowStartCustomAnimationToEnterFullScreenOnScreenWithDuration?(_: NSWindow, startCustomAnimationToEnterFullScreenOn: NSScreen, withDuration: number): void;
        windowDidDecodeRestorableState?(_: NSWindow, didDecodeRestorableState: NSCoder): void;
        windowShouldPopUpDocumentPathMenu?(_: NSWindow, shouldPopUpDocumentPathMenu: NSMenu): boolean;
        windowStartCustomAnimationToEnterFullScreenWithDuration?(_: NSWindow, startCustomAnimationToEnterFullScreenWithDuration: number): void;
        windowStartCustomAnimationToExitFullScreenWithDuration?(_: NSWindow, startCustomAnimationToExitFullScreenWithDuration: number): void;
        windowWillEncodeRestorableState?(_: NSWindow, willEncodeRestorableState: NSCoder): void;
        windowWillResizeForVersionBrowserWithMaxPreferredSizeMaxAllowedSize?(_: NSWindow, willResizeForVersionBrowserWithMaxPreferredSize: CGSize, maxAllowedSize: CGSize): CGSize;
        windowWillUseFullScreenContentSize?(_: NSWindow, willUseFullScreenContentSize: CGSize): CGSize;
        windowWillUseFullScreenPresentationOptions?(_: NSWindow, willUseFullScreenPresentationOptions: NSApplication.PresentationOptions): NSApplication.PresentationOptions;
        windowDidBecomeKey?(_: NSNotification): void;
        windowDidBecomeMain?(_: NSNotification): void;
        windowDidChangeBackingProperties?(_: NSNotification): void;
        windowDidChangeOcclusionState?(_: NSNotification): void;
        windowDidChangeScreen?(_: NSNotification): void;
        windowDidChangeScreenProfile?(_: NSNotification): void;
        windowDidDeminiaturize?(_: NSNotification): void;
        windowDidEndLiveResize?(_: NSNotification): void;
        windowDidEndSheet?(_: NSNotification): void;
        windowDidEnterFullScreen?(_: NSNotification): void;
        windowDidEnterVersionBrowser?(_: NSNotification): void;
        windowDidExitFullScreen?(_: NSNotification): void;
        windowDidExitVersionBrowser?(_: NSNotification): void;
        windowDidExpose?(_: NSNotification): void;
        windowDidFailToEnterFullScreen?(_: NSWindow): void;
        windowDidFailToExitFullScreen?(_: NSWindow): void;
        windowDidMiniaturize?(_: NSNotification): void;
        windowDidMove?(_: NSNotification): void;
        windowDidResignKey?(_: NSNotification): void;
        windowDidResignMain?(_: NSNotification): void;
        windowDidResize?(_: NSNotification): void;
        windowDidUpdate?(_: NSNotification): void;
        windowShouldClose?(_: NSWindow): boolean;
        windowShouldZoomToFrame?(_: NSWindow, toFrame: CGRect): boolean;
        windowWillBeginSheet?(_: NSNotification): void;
        windowWillClose?(_: NSNotification): void;
        windowWillEnterFullScreen?(_: NSNotification): void;
        windowWillEnterVersionBrowser?(_: NSNotification): void;
        windowWillExitFullScreen?(_: NSNotification): void;
        windowWillExitVersionBrowser?(_: NSNotification): void;
        windowWillMiniaturize?(_: NSNotification): void;
        windowWillMove?(_: NSNotification): void;
        windowWillResizeToSize?(_: NSWindow, to: CGSize): CGSize;
        windowWillReturnFieldEditorToObject?(_: NSWindow, to?: any): any;
        windowWillReturnUndoManager?(_: NSWindow): UndoManager;
        windowWillStartLiveResize?(_: NSNotification): void;
        windowWillUseStandardFrameDefaultFrame?(_: NSWindow, defaultFrame: CGRect): CGRect;
    }
    type NSWindowRestoration = NSObject;
    class NSWindowTab extends NSObject {
        accessoryView: NSView;
        setAccessoryView(_: NSView): any;
        attributedTitle: NSAttributedString;
        setAttributedTitle(_: NSAttributedString): any;
        title: string;
        setTitle(_: string): any;
        toolTip: string;
        setToolTip(_: string): any;
    }
    class NSWindowTabGroup extends NSObject {
        identifier: string;
        isOverviewVisible: boolean;
        setOverviewVisible(_: boolean): any;
        selectedWindow: NSWindow;
        setSelectedWindow(_: NSWindow): any;
        isTabBarVisible: boolean;
        windows: NSWindow[];
        addWindow(_: NSWindow): void;
        insertWindowAtIndex(_: NSWindow, at: number): void;
        removeWindow(_: NSWindow): void;
    }
    class NSWorkspace extends NSObject {
        accessibilityDisplayShouldDifferentiateWithoutColor: boolean;
        accessibilityDisplayShouldIncreaseContrast: boolean;
        accessibilityDisplayShouldInvertColors: boolean;
        accessibilityDisplayShouldReduceMotion: boolean;
        accessibilityDisplayShouldReduceTransparency: boolean;
        fileLabelColors: NSColor[];
        fileLabels: string[];
        frontmostApplication: NSRunningApplication;
        menuBarOwningApplication: NSRunningApplication;
        notificationCenter: NotificationCenter;
        runningApplications: NSRunningApplication[];
        isSwitchControlEnabled: boolean;
        isVoiceOverEnabled: boolean;
        static sharedWorkspace: NSWorkspace;
        URLForApplicationToOpenURL(toOpen: NSURL): NSURL;
        URLForApplicationWithBundleIdentifier(withBundleIdentifier: string): NSURL;
        activateFileViewerSelectingURLs(_: NSURL[]): void;
        desktopImageOptionsForScreen(for_: NSScreen): Map<string, any>;
        desktopImageURLForScreen(for_: NSScreen): NSURL;
        duplicateCompletionHandler(_: NSURL[], completionHandler?: (p1: Map<NSURL, NSURL>, p2: NSError) => void): void;
        extendPowerOffBy(by: number): number;
        filenameExtensionIsValidForType(_: string, isValidForType: string): boolean;
        getFileSystemInfoForPathIsRemovableIsWritableIsUnmountableDescriptionType(forPath: string, isRemovable?: boolean, isWritable?: boolean, isUnmountable?: boolean, description?: string, type?: string): boolean;
        getInfoForFileApplicationType(_: string, application?: string, type?: string): boolean;
        hideOtherApplications(): void;
        iconForFile(forFile: string): NSImage;
        iconForFileType(forFileType: string): NSImage;
        iconForFiles(forFiles: string[]): NSImage;
        isFilePackageAtPath(atPath: string): boolean;
        launchApplicationAtURLOptionsConfigurationError(options: NSURL, configuration: NSWorkspace.LaunchOptions, error: Map<string, any>): NSRunningApplication;
        localizedDescriptionForType(forType: string): string;
        noteFileSystemChanged(_: string): void;
        openApplicationWithAtConfigurationCompletionHandler(at: NSURL, configuration: OpenConfiguration, completionHandler?: (p1: NSRunningApplication, p2: NSError) => void): void;
        openURL(_: NSURL): boolean;
        openConfigurationCompletionHandler(_: NSURL, configuration: OpenConfiguration, completionHandler?: (p1: NSRunningApplication, p2: NSError) => void): void;
        openURLOptionsConfigurationError(options: NSURL, configuration: NSWorkspace.LaunchOptions, error: Map<string, any>): NSRunningApplication;
        openWithApplicationAtConfigurationCompletionHandler(_: NSURL[], withApplicationAt: NSURL, configuration: OpenConfiguration, completionHandler?: (p1: NSRunningApplication, p2: NSError) => void): void;
        openURLsWithApplicationAtURLOptionsConfigurationError(withApplicationAtURL: NSURL[], options: NSURL, configuration: NSWorkspace.LaunchOptions, error: Map<string, any>): NSRunningApplication;
        preferredFilenameExtensionForType(forType: string): string;
        recycleCompletionHandler(_: NSURL[], completionHandler?: (p1: Map<NSURL, NSURL>, p2: NSError) => void): void;
        requestAuthorizationWithToCompletionHandler(to: NSWorkspace.AuthorizationType, completionHandler?: (p1: Authorization, p2: NSError) => void): void;
        selectFileInFileViewerRootedAtPath(_?: string, inFileViewerRootedAtPath?: string): boolean;
        setDesktopImageURLForScreenOptionsError(forScreen: NSURL, options: NSScreen, error: Map<string, any>): boolean;
        setIconForFileOptions(_?: NSImage, forFile?: string, options?: NSWorkspace.IconCreationOptions): boolean;
        showSearchResultsForQueryString(forQueryString: string): boolean;
        typeConformsToType(_: string, conformsToType: string): boolean;
        typeOfFileError(error: string): string;
        unmountAndEjectDeviceAtPath(atPath: string): boolean;
        unmountAndEjectDeviceAtURLError(error: NSURL): boolean;
    }
    class Authorization extends NSObject {
    }
    class OpenConfiguration extends NSObject {
        static configuration(): OpenConfiguration;
        activates: boolean;
        setActivates(_: boolean): any;
        addsToRecentItems: boolean;
        setAddsToRecentItems(_: boolean): any;
        allowsRunningApplicationSubstitution: boolean;
        setAllowsRunningApplicationSubstitution(_: boolean): any;
        appleEvent: NSAppleEventDescriptor;
        setAppleEvent(_: NSAppleEventDescriptor): any;
        architecture: number;
        setArchitecture(_: number): any;
        arguments: string[];
        setArguments(_: string[]): any;
        createsNewApplicationInstance: boolean;
        setCreatesNewApplicationInstance(_: boolean): any;
        environment: Map<string, string>;
        setEnvironment(_: Map<string, string>): any;
        isForPrinting: boolean;
        setForPrinting(_: boolean): any;
        hides: boolean;
        setHides(_: boolean): any;
        hidesOthers: boolean;
        setHidesOthers(_: boolean): any;
        promptsUserIfNeeded: boolean;
        setPromptsUserIfNeeded(_: boolean): any;
        requiresUniversalLinks: boolean;
        setRequiresUniversalLinks(_: boolean): any;
    }
    class NSAsynchronousFetchRequest<ResultType> extends NSPersistentStoreRequest {
        completionBlock: (p1: NSAsynchronousFetchResult<any>) => void;
        estimatedResultCount: number;
        setEstimatedResultCount(_: number): any;
        fetchRequest: NSFetchRequest<ResultType>;
    }
    class NSAsynchronousFetchResult<ResultType> extends NSPersistentStoreAsynchronousResult {
        fetchRequest: NSAsynchronousFetchRequest<ResultType>;
        finalResult: ResultType[];
    }
    class NSAtomicStore extends NSPersistentStore {
        addCacheNodes(_: NSSet<NSAtomicStoreCacheNode>): void;
        cacheNodeForObjectID(_: NSManagedObjectID): NSAtomicStoreCacheNode;
        cacheNodes(): NSSet<NSAtomicStoreCacheNode>;
        load(): boolean;
        newCacheNodeForManagedObject(_: NSManagedObject): NSAtomicStoreCacheNode;
        newReferenceObjectForManagedObject(_: NSManagedObject): any;
        objectIDForEntityReferenceObject(for_: NSEntityDescription, withReferenceObject: any): NSManagedObjectID;
        referenceObjectForObjectID(_: NSManagedObjectID): any;
        save(): boolean;
        updateCacheNodeFromManagedObject(_: NSAtomicStoreCacheNode, fromManagedObject: NSManagedObject): void;
        willRemoveCacheNodes(_: NSSet<NSAtomicStoreCacheNode>): void;
    }
    class NSAtomicStoreCacheNode extends NSObject {
        objectID: NSManagedObjectID;
        propertyCache: NSMutableDictionary<string, any>;
        setPropertyCache(_: NSMutableDictionary<string, any>): any;
        static createWithObjectID(objectID: NSManagedObjectID): NSAtomicStoreCacheNode;
    }
    class NSAttributeDescription extends NSPropertyDescription {
        allowsExternalBinaryDataStorage: boolean;
        setAllowsExternalBinaryDataStorage(_: boolean): any;
        attributeType: NSAttributeType;
        setAttributeType(_: NSAttributeType): any;
        attributeValueClassName: string;
        setAttributeValueClassName(_: string): any;
        defaultValue: any;
        setDefaultValue(_: any): any;
        preservesValueInHistoryOnDeletion: boolean;
        setPreservesValueInHistoryOnDeletion(_: boolean): any;
        valueTransformerName: string;
        setValueTransformerName(_: string): any;
    }
    class NSBatchDeleteRequest extends NSPersistentStoreRequest {
        fetchRequest: NSFetchRequest<any>;
        resultType: NSBatchDeleteRequestResultType;
        setResultType(_: NSBatchDeleteRequestResultType): any;
        static createWithFetchRequest(fetchRequest: NSFetchRequest<any>): NSBatchDeleteRequest;
        static createWithObjectIDs(objectIDs: NSManagedObjectID[]): NSBatchDeleteRequest;
    }
    class NSBatchDeleteResult extends NSPersistentStoreResult {
        result: any;
        resultType: NSBatchDeleteRequestResultType;
    }
    class NSBatchInsertRequest extends NSPersistentStoreRequest {
        static batchInsertRequestWithEntityNameObjects(_: string, objects: Map<string, any>[]): NSBatchInsertRequest;
        entity: NSEntityDescription;
        entityName: string;
        objectsToInsert: Map<string, any>[];
        setObjectsToInsert(_: Map<string, any>[]): any;
        resultType: NSBatchInsertRequestResultType;
        setResultType(_: NSBatchInsertRequestResultType): any;
        static createWithEntityObjects(entity: NSEntityDescription, objects: Map<string, any>[]): NSBatchInsertRequest;
        static createWithEntityNameObjects(entityName: string, objects: Map<string, any>[]): NSBatchInsertRequest;
    }
    class NSBatchInsertResult extends NSPersistentStoreResult {
        result: any;
        resultType: NSBatchInsertRequestResultType;
    }
    class NSBatchUpdateRequest extends NSPersistentStoreRequest {
        static batchUpdateRequestWithEntityName(_: string): NSBatchUpdateRequest;
        entity: NSEntityDescription;
        entityName: string;
        includesSubentities: boolean;
        setIncludesSubentities(_: boolean): any;
        predicate: NSPredicate;
        setPredicate(_: NSPredicate): any;
        propertiesToUpdate: Map<any, any>;
        setPropertiesToUpdate(_: Map<any, any>): any;
        resultType: NSBatchUpdateRequestResultType;
        setResultType(_: NSBatchUpdateRequestResultType): any;
        static createWithEntity(entity: NSEntityDescription): NSBatchUpdateRequest;
        static createWithEntityName(entityName: string): NSBatchUpdateRequest;
    }
    class NSBatchUpdateResult extends NSPersistentStoreResult {
        result: any;
        resultType: NSBatchUpdateRequestResultType;
    }
    class NSConstraintConflict extends NSObject {
        conflictingObjects: NSManagedObject[];
        conflictingSnapshots: Map<any, any>[];
        constraint: string[];
        constraintValues: Map<string, any>;
        databaseObject: NSManagedObject;
        databaseSnapshot: Map<string, any>;
        static createWithConstraintDatabaseObjectDatabaseSnapshotConflictingObjectsConflictingSnapshots(constraint: string[], databaseObject?: NSManagedObject, databaseSnapshot?: Map<any, any>, conflictingObjects?: NSManagedObject[], conflictingSnapshots?: any[]): NSConstraintConflict;
    }
    class NSCoreDataCoreSpotlightDelegate extends NSObject {
        attributeSetForObject(_: NSManagedObject): CSSearchableItemAttributeSet;
        domainIdentifier(): string;
        indexName(): string;
        static createWithForStoreWithDescriptionModel(forStoreWithDescription: NSPersistentStoreDescription, model: NSManagedObjectModel): NSCoreDataCoreSpotlightDelegate;
        searchableIndexWithReindexAllSearchableItemsWithAcknowledgementHandler(_: CSSearchableIndex, reindexAllSearchableItemsWithAcknowledgementHandler: () => void): void;
        searchableIndexWithReindexSearchableItemsWithIdentifiersAcknowledgementHandler(_: CSSearchableIndex, reindexSearchableItemsWithIdentifiers: string[], acknowledgementHandler: () => void): void;
    }
    class NSDerivedAttributeDescription extends NSAttributeDescription {
        derivationExpression: NSExpression;
        setDerivationExpression(_: NSExpression): any;
    }
    class NSEntityDescription extends NSObject {
        static entityForNameInManagedObjectContext(forEntityName: string, in_: NSManagedObjectContext): NSEntityDescription;
        static insertNewObjectForEntityForNameInManagedObjectContext(forEntityName: string, into: NSManagedObjectContext): NSManagedObject;
        isAbstract: boolean;
        setAbstract(_: boolean): any;
        attributesByName: Map<string, NSAttributeDescription>;
        coreSpotlightDisplayNameExpression: NSExpression;
        setCoreSpotlightDisplayNameExpression(_: NSExpression): any;
        indexes: NSFetchIndexDescription[];
        setIndexes(_: NSFetchIndexDescription[]): any;
        managedObjectClassName: string;
        setManagedObjectClassName(_: string): any;
        managedObjectModel: NSManagedObjectModel;
        name: string;
        setName(_: string): any;
        properties: NSPropertyDescription[];
        setProperties(_: NSPropertyDescription[]): any;
        propertiesByName: Map<string, NSPropertyDescription>;
        relationshipsByName: Map<string, NSRelationshipDescription>;
        renamingIdentifier: string;
        setRenamingIdentifier(_: string): any;
        subentities: NSEntityDescription[];
        setSubentities(_: NSEntityDescription[]): any;
        subentitiesByName: Map<string, NSEntityDescription>;
        superentity: NSEntityDescription;
        uniquenessConstraints: any[][];
        setUniquenessConstraints(_: any[][]): any;
        userInfo: Map<any, any>;
        setUserInfo(_: Map<any, any>): any;
        versionHash: NSData;
        versionHashModifier: string;
        setVersionHashModifier(_: string): any;
        isKindOfEntity(entity: NSEntityDescription): boolean;
        relationshipsWithDestinationEntity(forDestination: NSEntityDescription): NSRelationshipDescription[];
    }
    class NSEntityMapping extends NSObject {
        attributeMappings: NSPropertyMapping[];
        setAttributeMappings(_: NSPropertyMapping[]): any;
        destinationEntityName: string;
        setDestinationEntityName(_: string): any;
        destinationEntityVersionHash: NSData;
        setDestinationEntityVersionHash(_: NSData): any;
        entityMigrationPolicyClassName: string;
        setEntityMigrationPolicyClassName(_: string): any;
        mappingType: NSEntityMappingType;
        setMappingType(_: NSEntityMappingType): any;
        name: string;
        setName(_: string): any;
        relationshipMappings: NSPropertyMapping[];
        setRelationshipMappings(_: NSPropertyMapping[]): any;
        sourceEntityName: string;
        setSourceEntityName(_: string): any;
        sourceEntityVersionHash: NSData;
        setSourceEntityVersionHash(_: NSData): any;
        sourceExpression: NSExpression;
        setSourceExpression(_: NSExpression): any;
        userInfo: Map<any, any>;
        setUserInfo(_: Map<any, any>): any;
    }
    class NSEntityMigrationPolicy extends NSObject {
        beginEntityMappingManagerError(_: NSEntityMapping, with_: NSMigrationManager): boolean;
        createDestinationInstancesForSourceInstanceEntityMappingManagerError(forSource: NSManagedObject, in_: NSEntityMapping, manager: NSMigrationManager): boolean;
        createRelationshipsForDestinationInstanceEntityMappingManagerError(forDestination: NSManagedObject, in_: NSEntityMapping, manager: NSMigrationManager): boolean;
        endEntityMappingManagerError(manager: NSEntityMapping, error: NSMigrationManager): boolean;
        endInstanceCreationForEntityMappingManagerError(forMapping: NSEntityMapping, manager: NSMigrationManager): boolean;
        endRelationshipCreationForEntityMappingManagerError(forMapping: NSEntityMapping, manager: NSMigrationManager): boolean;
        performCustomValidationForEntityMappingManagerError(forMapping: NSEntityMapping, manager: NSMigrationManager): boolean;
    }
    class NSExpressionDescription extends NSPropertyDescription {
        expression: NSExpression;
        setExpression(_: NSExpression): any;
        expressionResultType: NSAttributeType;
        setExpressionResultType(_: NSAttributeType): any;
    }
    class NSFetchIndexDescription extends NSObject {
        elements: NSFetchIndexElementDescription[];
        setElements(_: NSFetchIndexElementDescription[]): any;
        entity: NSEntityDescription;
        name: string;
        setName(_: string): any;
        partialIndexPredicate: NSPredicate;
        setPartialIndexPredicate(_: NSPredicate): any;
        static createWithNameElements(name: string, elements?: NSFetchIndexElementDescription[]): NSFetchIndexDescription;
    }
    class NSFetchIndexElementDescription extends NSObject {
        isAscending: boolean;
        setAscending(_: boolean): any;
        collationType: NSFetchIndexElementType;
        setCollationType(_: NSFetchIndexElementType): any;
        indexDescription: NSFetchIndexDescription;
        property: NSPropertyDescription;
        propertyName: string;
        static createWithPropertyCollationType(property: NSPropertyDescription, collationType: NSFetchIndexElementType): NSFetchIndexElementDescription;
    }
    class NSFetchRequest<ResultType> extends NSPersistentStoreRequest {
        static fetchRequestWithEntityName<ResultType>(_: string): NSFetchRequest<ResultType>;
        entity: NSEntityDescription;
        setEntity(_: NSEntityDescription): any;
        entityName: string;
        fetchBatchSize: number;
        setFetchBatchSize(_: number): any;
        fetchLimit: number;
        setFetchLimit(_: number): any;
        fetchOffset: number;
        setFetchOffset(_: number): any;
        havingPredicate: NSPredicate;
        setHavingPredicate(_: NSPredicate): any;
        includesPendingChanges: boolean;
        setIncludesPendingChanges(_: boolean): any;
        includesPropertyValues: boolean;
        setIncludesPropertyValues(_: boolean): any;
        includesSubentities: boolean;
        setIncludesSubentities(_: boolean): any;
        predicate: NSPredicate;
        setPredicate(_: NSPredicate): any;
        propertiesToFetch: any[];
        setPropertiesToFetch(_: any[]): any;
        propertiesToGroupBy: any[];
        setPropertiesToGroupBy(_: any[]): any;
        relationshipKeyPathsForPrefetching: string[];
        setRelationshipKeyPathsForPrefetching(_: string[]): any;
        resultType: NSFetchRequestResultType;
        setResultType(_: NSFetchRequestResultType): any;
        returnsDistinctResults: boolean;
        setReturnsDistinctResults(_: boolean): any;
        returnsObjectsAsFaults: boolean;
        setReturnsObjectsAsFaults(_: boolean): any;
        shouldRefreshRefetchedObjects: boolean;
        setShouldRefreshRefetchedObjects(_: boolean): any;
        sortDescriptors: NSSortDescriptor[];
        setSortDescriptors(_: NSSortDescriptor[]): any;
        execute(): ResultType[];
    }
    class NSFetchRequestExpression extends NSExpression {
        static expressionForFetchContextCountOnly(_: NSExpression, context: NSExpression, countOnly: boolean): NSExpression;
        contextExpression: NSExpression;
        isCountOnlyRequest: boolean;
        requestExpression: NSExpression;
    }
    type NSFetchRequestResult = NSObject;
    class NSFetchedPropertyDescription extends NSPropertyDescription {
        fetchRequest: NSFetchRequest<any>;
        setFetchRequest(_: NSFetchRequest<any>): any;
    }
    class NSFetchedResultsController<ResultType> extends NSObject {
        static deleteCacheWithName(_?: string): void;
        cacheName: string;
        delegate: NSFetchedResultsControllerDelegate;
        setDelegate(_: NSFetchedResultsControllerDelegate): any;
        fetchRequest: NSFetchRequest<ResultType>;
        fetchedObjects: ResultType[];
        managedObjectContext: NSManagedObjectContext;
        sectionIndexTitles: string[];
        sectionNameKeyPath: string;
        sections: NSFetchedResultsSectionInfo[];
        indexPathForObject(_: ResultType): NSIndexPath;
        objectAtIndexPath(_: NSIndexPath): ResultType;
        performFetch(): boolean;
        sectionForSectionIndexTitleAtIndex(_: string, atIndex: number): number;
        sectionIndexTitleForSectionName(_: string): string;
    }
    interface NSFetchedResultsControllerDelegate extends NSObject {
        controllerWithDidChangeContentWithDifference?(_: NSFetchedResultsController<any>, didChangeContentWithDifference: NSOrderedCollectionDifference<NSManagedObjectID>): void;
        controllerWithDidChangeContentWithSnapshot?(_: NSFetchedResultsController<any>, didChangeContentWithSnapshot: NSDiffableDataSourceSnapshotReference<string, NSManagedObjectID>): void;
        controllerDidChangeObjectAtIndexPathForChangeTypeNewIndexPath?(_: NSFetchedResultsController<any>, didChangeObject: any, atIndexPath?: NSIndexPath, forChangeType?: NSFetchedResultsChangeType, newIndexPath?: NSIndexPath): void;
        controllerDidChangeSectionAtIndexForChangeType?(_: NSFetchedResultsController<any>, didChangeSection: NSFetchedResultsSectionInfo, atIndex: number, forChangeType: NSFetchedResultsChangeType): void;
        controllerSectionIndexTitleForSectionName?(_: NSFetchedResultsController<any>, sectionIndexTitleForSectionName: string): string;
        controllerDidChangeContent?(_: NSFetchedResultsController<any>): void;
        controllerWillChangeContent?(_: NSFetchedResultsController<any>): void;
    }
    interface NSFetchedResultsSectionInfo {
        indexTitle: string;
        name: string;
        numberOfObjects: number;
        objects: any[];
    }
    class NSIncrementalStore extends NSPersistentStore {
        static identifierForNewStoreAtURL(_: NSURL): any;
        executeRequestWithContextError(withContext: NSPersistentStoreRequest, error?: NSManagedObjectContext): any;
        managedObjectContextDidRegisterObjectsWithIDs(_: NSManagedObjectID[]): void;
        managedObjectContextDidUnregisterObjectsWithIDs(_: NSManagedObjectID[]): void;
        newObjectIDForEntityReferenceObject(for_: NSEntityDescription, referenceObject: any): NSManagedObjectID;
        newValueForRelationshipForObjectWithIDWithContextError(forObjectWithID: NSRelationshipDescription, withContext: NSManagedObjectID, error?: NSManagedObjectContext): any;
        newValuesForObjectWithIDWithContextError(withContext: NSManagedObjectID, error: NSManagedObjectContext): NSIncrementalStoreNode;
        obtainPermanentIDsForObjectsError(error: NSManagedObject[]): NSManagedObjectID[];
        referenceObjectForObjectID(_: NSManagedObjectID): any;
    }
    class NSIncrementalStoreNode extends NSObject {
        objectID: NSManagedObjectID;
        static createWithObjectIDWithValuesVersion(objectID: NSManagedObjectID, withValues: Map<string, any>, version: number): NSIncrementalStoreNode;
        updateWithValuesVersion(_: Map<string, any>, version: number): void;
        valueForPropertyDescription(_: NSPropertyDescription): any;
    }
    class NSManagedObject extends NSObject {
        static entity(): NSEntityDescription;
        static fetchRequest(): NSFetchRequest<any>;
        isDeleted: boolean;
        entity: NSEntityDescription;
        isFault: boolean;
        faultingState: number;
        hasChanges: boolean;
        hasPersistentChangedValues: boolean;
        isInserted: boolean;
        managedObjectContext: NSManagedObjectContext;
        objectID: NSManagedObjectID;
        isUpdated: boolean;
        static contextShouldIgnoreUnmodeledPropertyChanges: boolean;
        awakeFromFetch(): void;
        awakeFromInsert(): void;
        awakeFromSnapshotEvents(_: NSSnapshotEventType): void;
        changedValues(): Map<string, any>;
        changedValuesForCurrentEvent(): Map<string, any>;
        committedValuesForKeys(_?: string[]): Map<string, any>;
        didAccessValueForKey(_?: string): void;
        didSave(): void;
        didTurnIntoFault(): void;
        hasFaultForRelationshipNamed(_: string): boolean;
        static createWithContext(context: NSManagedObjectContext): NSManagedObject;
        static createWithEntityInsertIntoManagedObjectContext(entity: NSEntityDescription, insertIntoManagedObjectContext?: NSManagedObjectContext): NSManagedObject;
        objectIDsForRelationshipNamed(_: string): NSManagedObjectID[];
        prepareForDeletion(): void;
        primitiveValueForKey(_: string): any;
        setObservationInfo(_?: any): void;
        setPrimitiveValueForKey(_?: any, forKey?: string): void;
        validateForDelete(): boolean;
        validateForInsert(): boolean;
        validateForUpdate(): boolean;
        willAccessValueForKey(_?: string): void;
        willSave(): void;
        willTurnIntoFault(): void;
    }
    class NSManagedObjectContext extends NSObject {
        static mergeChangesFromRemoteContextSaveIntoContexts(_: Map<any, any>, intoContexts: NSManagedObjectContext[]): void;
        automaticallyMergesChangesFromParent: boolean;
        setAutomaticallyMergesChangesFromParent(_: boolean): any;
        concurrencyType: NSManagedObjectContextConcurrencyType;
        deletedObjects: NSSet<NSManagedObject>;
        hasChanges: boolean;
        insertedObjects: NSSet<NSManagedObject>;
        mergePolicy: any;
        setMergePolicy(_: any): any;
        name: string;
        setName(_: string): any;
        parentContext: NSManagedObjectContext;
        setParentContext(_: NSManagedObjectContext): any;
        persistentStoreCoordinator: NSPersistentStoreCoordinator;
        setPersistentStoreCoordinator(_: NSPersistentStoreCoordinator): any;
        propagatesDeletesAtEndOfEvent: boolean;
        setPropagatesDeletesAtEndOfEvent(_: boolean): any;
        queryGenerationToken: NSQueryGenerationToken;
        registeredObjects: NSSet<NSManagedObject>;
        retainsRegisteredObjects: boolean;
        setRetainsRegisteredObjects(_: boolean): any;
        shouldDeleteInaccessibleFaults: boolean;
        setShouldDeleteInaccessibleFaults(_: boolean): any;
        stalenessInterval: number;
        setStalenessInterval(_: number): any;
        transactionAuthor: string;
        setTransactionAuthor(_: string): any;
        undoManager: UndoManager;
        setUndoManager(_: UndoManager): any;
        updatedObjects: NSSet<NSManagedObject>;
        userInfo: NSMutableDictionary<any, any>;
        assignObjectToPersistentStore(_: any, toPersistentStore: NSPersistentStore): void;
        countForFetchRequestError(error: NSFetchRequest<any>): number;
        deleteObject(_: NSManagedObject): void;
        detectConflictsForObject(_: NSManagedObject): void;
        executeFetchRequestError(_: NSFetchRequest<any>): any[];
        executeRequestError(error: NSPersistentStoreRequest): NSPersistentStoreResult;
        existingObjectWithIDError(error: NSManagedObjectID): NSManagedObject;
        static createWithConcurrencyType(concurrencyType: NSManagedObjectContextConcurrencyType): NSManagedObjectContext;
        insertObject(_: NSManagedObject): void;
        mergeChangesFromContextDidSaveNotification(_: NSNotification): void;
        objectRegisteredForID(for_: NSManagedObjectID): NSManagedObject;
        objectWithID(_: NSManagedObjectID): NSManagedObject;
        obtainPermanentIDsForObjectsError(error: NSManagedObject[]): boolean;
        performBlock(_: () => void): void;
        performAndWait(_: () => void): void;
        processPendingChanges(): void;
        redo(): void;
        refreshAllObjects(): void;
        refreshObjectMergeChanges(_: NSManagedObject, mergeChanges: boolean): void;
        reset(): void;
        rollback(): void;
        save(): boolean;
        setQueryGenerationFromTokenError(error?: NSQueryGenerationToken): boolean;
        shouldHandleInaccessibleFaultForObjectIDTriggeredByProperty(_: NSManagedObject, forObjectID: NSManagedObjectID, triggeredByProperty?: NSPropertyDescription): boolean;
        undo(): void;
    }
    class NSManagedObjectID extends NSObject {
        entity: NSEntityDescription;
        persistentStore: NSPersistentStore;
        isTemporaryID: boolean;
        URIRepresentation(): NSURL;
    }
    class NSManagedObjectModel extends NSObject {
        static mergedModelFromBundles(_?: Bundle[]): NSManagedObjectModel;
        static mergedModelFromBundlesForStoreMetadata(_?: Bundle[], forStoreMetadata?: Map<string, any>): NSManagedObjectModel;
        static modelByMergingModels(_?: NSManagedObjectModel[]): NSManagedObjectModel;
        static modelByMergingModelsForStoreMetadata(_: NSManagedObjectModel[], forStoreMetadata: Map<string, any>): NSManagedObjectModel;
        configurations: string[];
        entities: NSEntityDescription[];
        setEntities(_: NSEntityDescription[]): any;
        entitiesByName: Map<string, NSEntityDescription>;
        entityVersionHashesByName: Map<string, Data>;
        fetchRequestTemplatesByName: Map<string, NSFetchRequest<any>>;
        localizationDictionary: Map<string, string>;
        setLocalizationDictionary(_: Map<string, string>): any;
        versionIdentifiers: NSSet<any>;
        setVersionIdentifiers(_: NSSet<any>): any;
        entitiesForConfiguration(forConfigurationName?: string): NSEntityDescription[];
        fetchRequestFromTemplateWithNameSubstitutionVariables(_: string, substitutionVariables: Map<string, any>): NSFetchRequest<any>;
        fetchRequestTemplateForName(_: string): NSFetchRequest<any>;
        static createWithContentsOfURL(contentsOfURL: NSURL): NSManagedObjectModel;
        isConfigurationCompatibleWithStoreMetadata(withName?: string, compatibleWithStoreMetadata?: Map<string, any>): boolean;
        setEntitiesForConfiguration(_: NSEntityDescription[], forConfigurationName: string): void;
        setFetchRequestTemplateForName(_?: NSFetchRequest<any>, forName?: string): void;
    }
    class NSMappingModel extends NSObject {
        static inferredMappingModelForSourceModelDestinationModelError(destinationModel: NSManagedObjectModel, error: NSManagedObjectModel): NSMappingModel;
        static mappingModelFromBundlesForSourceModelDestinationModel(_?: Bundle[], forSourceModel?: NSManagedObjectModel, destinationModel?: NSManagedObjectModel): NSMappingModel;
        entityMappings: NSEntityMapping[];
        setEntityMappings(_: NSEntityMapping[]): any;
        entityMappingsByName: Map<string, NSEntityMapping>;
        static createWithContentsOfURL(contentsOfURL?: NSURL): NSMappingModel;
    }
    class NSMergeConflict extends NSObject {
        cachedSnapshot: Map<string, any>;
        newVersionNumber: number;
        objectSnapshot: Map<string, any>;
        oldVersionNumber: number;
        persistedSnapshot: Map<string, any>;
        sourceObject: NSManagedObject;
        static createWithSourceNewVersionOldVersionCachedSnapshotPersistedSnapshot(source: NSManagedObject, newVersion: number, oldVersion: number, cachedSnapshot?: Map<string, any>, persistedSnapshot?: Map<string, any>): NSMergeConflict;
    }
    class NSMergePolicy extends NSObject {
        mergeType: NSMergePolicyType;
        static errorMergePolicy: NSMergePolicy;
        static mergeByPropertyObjectTrumpMergePolicy: NSMergePolicy;
        static mergeByPropertyStoreTrumpMergePolicy: NSMergePolicy;
        static overwriteMergePolicy: NSMergePolicy;
        static rollbackMergePolicy: NSMergePolicy;
        static createWithMergeType(mergeType: NSMergePolicyType): NSMergePolicy;
        resolveConflictsError(mergeConflicts: any[]): boolean;
        resolveConstraintConflictsError(constraintConflicts: NSConstraintConflict[]): boolean;
        resolveOptimisticLockingVersionConflictsError(optimisticLockingConflicts: NSMergeConflict[]): boolean;
    }
    class NSMigrationManager extends NSObject {
        currentEntityMapping: NSEntityMapping;
        destinationContext: NSManagedObjectContext;
        destinationModel: NSManagedObjectModel;
        mappingModel: NSMappingModel;
        migrationProgress: number;
        sourceContext: NSManagedObjectContext;
        sourceModel: NSManagedObjectModel;
        userInfo: Map<any, any>;
        setUserInfo(_: Map<any, any>): any;
        usesStoreSpecificMigrationManager: boolean;
        setUsesStoreSpecificMigrationManager(_: boolean): any;
        associateSourceInstanceWithDestinationInstanceForEntityMapping(sourceInstance: NSManagedObject, withDestinationInstance: NSManagedObject, for_: NSEntityMapping): void;
        cancelMigrationWithError(_: NSError): void;
        destinationEntityForEntityMapping(_: NSEntityMapping): NSEntityDescription;
        destinationInstancesForEntityMappingNamedSourceInstances(forEntityMappingName: string, sourceInstances?: NSManagedObject[]): NSManagedObject[];
        static createWithSourceModelDestinationModel(sourceModel: NSManagedObjectModel, destinationModel: NSManagedObjectModel): NSMigrationManager;
        migrateStoreFromURLTypeOptionsWithMappingModelToDestinationURLDestinationTypeDestinationOptionsError(from: NSURL, sourceType: string, options?: Map<any, any>, with_?: NSMappingModel, toDestinationURL?: NSURL, destinationType?: string, destinationOptions?: Map<any, any>): boolean;
        reset(): void;
        sourceEntityForEntityMapping(_: NSEntityMapping): NSEntityDescription;
        sourceInstancesForEntityMappingNamedDestinationInstances(forEntityMappingName: string, destinationInstances?: NSManagedObject[]): NSManagedObject[];
    }
    class NSPersistentCloudKitContainer extends NSPersistentContainer {
        initializeCloudKitSchemaWithOptionsError(error: NSPersistentCloudKitContainerSchemaInitializationOptions): boolean;
        recordForManagedObjectID(_: NSManagedObjectID): CKRecord;
        recordIDForManagedObjectID(_: NSManagedObjectID): ID;
        recordIDsForManagedObjectIDs(_: NSManagedObjectID[]): Map<NSManagedObjectID, ID>;
        recordsForManagedObjectIDs(_: NSManagedObjectID[]): Map<NSManagedObjectID, CKRecord>;
    }
    class NSPersistentCloudKitContainerOptions extends NSObject {
        containerIdentifier: string;
        static createWithContainerIdentifier(containerIdentifier: string): NSPersistentCloudKitContainerOptions;
    }
    class NSPersistentContainer extends NSObject {
        static defaultDirectoryURL(): NSURL;
        static persistentContainerWithName(_: string): NSPersistentContainer;
        static persistentContainerWithNameManagedObjectModel(_: string, managedObjectModel: NSManagedObjectModel): NSPersistentContainer;
        managedObjectModel: NSManagedObjectModel;
        name: string;
        persistentStoreCoordinator: NSPersistentStoreCoordinator;
        persistentStoreDescriptions: NSPersistentStoreDescription[];
        setPersistentStoreDescriptions(_: NSPersistentStoreDescription[]): any;
        viewContext: NSManagedObjectContext;
        static createWithName(name: string): NSPersistentContainer;
        static createWithNameManagedObjectModel(name: string, managedObjectModel: NSManagedObjectModel): NSPersistentContainer;
        loadPersistentStoresWithCompletionHandler(_?: (p1: NSPersistentStoreDescription, p2: NSError) => void): void;
        newBackgroundContext(): NSManagedObjectContext;
        performBackgroundTask(_: (p1: NSManagedObjectContext) => void): void;
    }
    class NSPersistentHistoryChange extends NSObject {
        static entityDescriptionWithContext(_: NSManagedObjectContext): NSEntityDescription;
        changeID: number;
        changeType: NSPersistentHistoryChangeType;
        changedObjectID: NSManagedObjectID;
        tombstone: Map<any, any>;
        transaction: NSPersistentHistoryTransaction;
        updatedProperties: NSSet<NSPropertyDescription>;
        static entityDescription: NSEntityDescription;
        static fetchRequest: NSFetchRequest<any>;
    }
    class NSPersistentHistoryChangeRequest extends NSPersistentStoreRequest {
        static deleteHistoryBeforeDate(_: Date): NSPersistentHistoryChangeRequest;
        static deleteHistoryBeforeToken(_?: NSPersistentHistoryToken): NSPersistentHistoryChangeRequest;
        static deleteHistoryBeforeTransaction(_?: NSPersistentHistoryTransaction): NSPersistentHistoryChangeRequest;
        static fetchHistoryAfterDate(_: Date): NSPersistentHistoryChangeRequest;
        static fetchHistoryAfterToken(_?: NSPersistentHistoryToken): NSPersistentHistoryChangeRequest;
        static fetchHistoryAfterTransaction(_?: NSPersistentHistoryTransaction): NSPersistentHistoryChangeRequest;
        static fetchHistoryWithFetchRequest(_: NSFetchRequest<any>): NSPersistentHistoryChangeRequest;
        fetchRequest: NSFetchRequest<any>;
        setFetchRequest(_: NSFetchRequest<any>): any;
        resultType: NSPersistentHistoryResultType;
        setResultType(_: NSPersistentHistoryResultType): any;
        token: NSPersistentHistoryToken;
    }
    class NSPersistentHistoryResult extends NSPersistentStoreResult {
        result: any;
        resultType: NSPersistentHistoryResultType;
    }
    class NSPersistentHistoryToken extends NSObject {
    }
    class NSPersistentHistoryTransaction extends NSObject {
        static entityDescriptionWithContext(_: NSManagedObjectContext): NSEntityDescription;
        author: string;
        bundleID: string;
        changes: NSPersistentHistoryChange[];
        contextName: string;
        processID: string;
        storeID: string;
        timestamp: Date;
        token: NSPersistentHistoryToken;
        transactionNumber: number;
        static entityDescription: NSEntityDescription;
        static fetchRequest: NSFetchRequest<any>;
        objectIDNotification(): NSNotification;
    }
    class NSPersistentStore extends NSObject {
        static metadataForPersistentStoreWithURLError(error: NSURL): Map<string, any>;
        static migrationManagerClass(): typeof NSObject;
        static setMetadataForPersistentStoreWithURLError(_?: Map<string, any>, forPersistentStoreAt?: NSURL): boolean;
        URL: NSURL;
        setURL(_: NSURL): any;
        configurationName: string;
        coreSpotlightExporter: NSCoreDataCoreSpotlightDelegate;
        identifier: string;
        setIdentifier(_: string): any;
        metadata: Map<string, any>;
        setMetadata(_: Map<string, any>): any;
        options: Map<any, any>;
        persistentStoreCoordinator: NSPersistentStoreCoordinator;
        isReadOnly: boolean;
        setReadOnly(_: boolean): any;
        type: string;
        didAddToPersistentStoreCoordinator(_: NSPersistentStoreCoordinator): void;
        static createWithPersistentStoreCoordinatorConfigurationNameUrlOptions(persistentStoreCoordinator?: NSPersistentStoreCoordinator, configurationName?: string, URL?: NSURL, options?: Map<any, any>): NSPersistentStore;
        loadMetadata(): boolean;
        willRemoveFromPersistentStoreCoordinator(_?: NSPersistentStoreCoordinator): void;
    }
    class NSPersistentStoreAsynchronousResult extends NSPersistentStoreResult {
        managedObjectContext: NSManagedObjectContext;
        operationError: NSError;
        progress: Progress;
        cancel(): void;
    }
    class NSPersistentStoreCoordinator extends NSObject {
        static elementsDerivedFromExternalRecordURL(fromExternalRecordAt: NSURL): Map<any, any>;
        static metadataForPersistentStoreOfTypeUrlOptionsError(ofType: string, at: NSURL, options?: Map<any, any>): Map<string, any>;
        static registerStoreClassForStoreType(_?: typeof NSObject, forStoreType?: string): void;
        static setMetadataForPersistentStoreOfTypeUrlOptionsError(_?: Map<string, any>, forPersistentStoreOfType?: string, at?: NSURL, options?: Map<any, any>): boolean;
        managedObjectModel: NSManagedObjectModel;
        name: string;
        setName(_: string): any;
        persistentStores: NSPersistentStore[];
        static registeredStoreTypes: Map<string, NSValue>;
        URLForPersistentStore(_: NSPersistentStore): NSURL;
        addPersistentStoreWithDescriptionWithCompletionHandler(_: NSPersistentStoreDescription, completionHandler?: (p1: NSPersistentStoreDescription, p2: NSError) => void): void;
        addPersistentStoreWithTypeConfigurationUrlOptionsError(ofType: string, configurationName?: string, at?: NSURL, options?: Map<any, any>): NSPersistentStore;
        currentPersistentHistoryTokenFromStores(_?: any[]): NSPersistentHistoryToken;
        destroyPersistentStoreAtURLWithTypeOptionsError(at: NSURL, ofType: string, options?: Map<any, any>): boolean;
        executeRequestWithContextError(withContext: NSPersistentStoreRequest, error: NSManagedObjectContext): any;
        importStoreWithIdentifierFromExternalRecordsDirectoryToURLOptionsWithTypeError(withIdentifier?: string, fromExternalRecordsDirectoryAt?: NSURL, to?: NSURL, options?: Map<any, any>, ofType?: string): NSPersistentStore;
        static createWithManagedObjectModel(managedObjectModel: NSManagedObjectModel): NSPersistentStoreCoordinator;
        managedObjectIDForURIRepresentation(_: NSURL): NSManagedObjectID;
        metadataForPersistentStore(_: NSPersistentStore): Map<string, any>;
        migratePersistentStoreToURLOptionsWithTypeError(toURL: NSPersistentStore, options: NSURL, withType?: Map<any, any>, error?: string): NSPersistentStore;
        performBlock(_: () => void): void;
        performAndWait(_: () => void): void;
        persistentStoreForURL(_: NSURL): NSPersistentStore;
        removePersistentStoreError(_: NSPersistentStore): boolean;
        replacePersistentStoreAtURLDestinationOptionsWithPersistentStoreFromURLSourceOptionsStoreTypeError(at: NSURL, destinationOptions?: Map<any, any>, withPersistentStoreFrom?: NSURL, sourceOptions?: Map<any, any>, ofType?: string): boolean;
        setMetadataForPersistentStore(_?: Map<string, any>, forPersistentStore?: NSPersistentStore): void;
        setURLForPersistentStore(_: NSURL, forPersistentStore: NSPersistentStore): boolean;
    }
    class NSPersistentStoreDescription extends NSObject {
        static persistentStoreDescriptionWithURL(_: NSURL): NSPersistentStoreDescription;
        URL: NSURL;
        setURL(_: NSURL): any;
        cloudKitContainerOptions: NSPersistentCloudKitContainerOptions;
        setCloudKitContainerOptions(_: NSPersistentCloudKitContainerOptions): any;
        configuration: string;
        setConfiguration(_: string): any;
        options: Map<string, NSObject>;
        isReadOnly: boolean;
        setReadOnly(_: boolean): any;
        shouldAddStoreAsynchronously: boolean;
        setShouldAddStoreAsynchronously(_: boolean): any;
        shouldInferMappingModelAutomatically: boolean;
        setShouldInferMappingModelAutomatically(_: boolean): any;
        shouldMigrateStoreAutomatically: boolean;
        setShouldMigrateStoreAutomatically(_: boolean): any;
        sqlitePragmas: Map<string, NSObject>;
        timeout: number;
        setTimeout(_: number): any;
        type: string;
        setType(_: string): any;
        static createWithUrl(URL: NSURL): NSPersistentStoreDescription;
        setOptionForKey(_?: NSObject, forKey?: string): void;
        setValueForPragmaNamed(_?: NSObject, forPragmaNamed?: string): void;
    }
    class NSPersistentStoreRequest extends NSObject {
        affectedStores: NSPersistentStore[];
        setAffectedStores(_: NSPersistentStore[]): any;
        requestType: NSPersistentStoreRequestType;
    }
    class NSPersistentStoreResult extends NSObject {
    }
    class NSPropertyDescription extends NSObject {
        entity: NSEntityDescription;
        isIndexedBySpotlight: boolean;
        setIndexedBySpotlight(_: boolean): any;
        name: string;
        setName(_: string): any;
        isOptional: boolean;
        setOptional(_: boolean): any;
        renamingIdentifier: string;
        setRenamingIdentifier(_: string): any;
        isTransient: boolean;
        setTransient(_: boolean): any;
        userInfo: Map<any, any>;
        setUserInfo(_: Map<any, any>): any;
        validationPredicates: NSPredicate[];
        validationWarnings: any[];
        versionHash: NSData;
        versionHashModifier: string;
        setVersionHashModifier(_: string): any;
        setValidationPredicatesWithValidationWarnings(_?: NSPredicate[], withValidationWarnings?: string[]): void;
    }
    class NSPropertyMapping extends NSObject {
        name: string;
        setName(_: string): any;
        userInfo: Map<any, any>;
        setUserInfo(_: Map<any, any>): any;
        valueExpression: NSExpression;
        setValueExpression(_: NSExpression): any;
    }
    class NSQueryGenerationToken extends NSObject {
        static currentQueryGenerationToken: NSQueryGenerationToken;
    }
    class NSRelationshipDescription extends NSPropertyDescription {
        deleteRule: NSDeleteRule;
        setDeleteRule(_: NSDeleteRule): any;
        destinationEntity: NSEntityDescription;
        setDestinationEntity(_: NSEntityDescription): any;
        inverseRelationship: NSRelationshipDescription;
        setInverseRelationship(_: NSRelationshipDescription): any;
        maxCount: number;
        setMaxCount(_: number): any;
        minCount: number;
        setMinCount(_: number): any;
        isOrdered: boolean;
        setOrdered(_: boolean): any;
        isToMany: boolean;
    }
    class NSSaveChangesRequest extends NSPersistentStoreRequest {
        deletedObjects: NSSet<NSManagedObject>;
        insertedObjects: NSSet<NSManagedObject>;
        lockedObjects: NSSet<NSManagedObject>;
        updatedObjects: NSSet<NSManagedObject>;
        static createWithInsertedObjectsUpdatedObjectsDeletedObjectsLockedObjects(insertedObjects?: NSSet<NSManagedObject>, updatedObjects?: NSSet<NSManagedObject>, deletedObjects?: NSSet<NSManagedObject>, lockedObjects?: NSSet<NSManagedObject>): NSSaveChangesRequest;
    }
    interface CIAccordionFoldTransition extends CITransitionFilter {
        bottomHeight: number;
        setBottomHeight(_: number): any;
        foldShadowAmount: number;
        setFoldShadowAmount(_: number): any;
        numberOfFolds: number;
        setNumberOfFolds(_: number): any;
    }
    interface CIAffineClamp extends CIFilter {
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        transform: CGAffineTransform;
        setTransform(_: CGAffineTransform): any;
    }
    interface CIAffineTile extends CIFilter {
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        transform: CGAffineTransform;
        setTransform(_: CGAffineTransform): any;
    }
    interface CIAttributedTextImageGenerator extends CIFilter {
        scaleFactor: number;
        setScaleFactor(_: number): any;
        text: NSAttributedString;
        setText(_: NSAttributedString): any;
    }
    class CIAztecCodeDescriptor extends CIBarcodeDescriptor {
        static descriptorWithPayloadIsCompactLayerCountDataCodewordCount(payload: NSData, isCompact: boolean, layerCount: number, dataCodewordCount: number): CIAztecCodeDescriptor;
        dataCodewordCount: number;
        errorCorrectedPayload: NSData;
        isCompact: boolean;
        layerCount: number;
        static createWithPayloadIsCompactLayerCountDataCodewordCount(payload: NSData, isCompact: boolean, layerCount: number, dataCodewordCount: number): CIAztecCodeDescriptor;
    }
    interface CIAztecCodeGenerator extends CIFilter {
        compactStyle: number;
        setCompactStyle(_: number): any;
        correctionLevel: number;
        setCorrectionLevel(_: number): any;
        layers: number;
        setLayers(_: number): any;
        message: NSData;
        setMessage(_: NSData): any;
    }
    class CIBarcodeDescriptor extends NSObject {
    }
    interface CIBarcodeGenerator extends CIFilter {
        barcodeDescriptor: CIBarcodeDescriptor;
        setBarcodeDescriptor(_: CIBarcodeDescriptor): any;
    }
    interface CIBarsSwipeTransition extends CITransitionFilter {
        angle: number;
        setAngle(_: number): any;
        barOffset: number;
        setBarOffset(_: number): any;
        width: number;
        setWidth(_: number): any;
    }
    interface CIBicubicScaleTransform extends CIFilter {
        aspectRatio: number;
        setAspectRatio(_: number): any;
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        parameterB: number;
        setParameterB(_: number): any;
        parameterC: number;
        setParameterC(_: number): any;
        scale: number;
        setScale(_: number): any;
    }
    class CIBlendKernel extends CIColorKernel {
        static clear: CIBlendKernel;
        static color: CIBlendKernel;
        static colorBurn: CIBlendKernel;
        static colorDodge: CIBlendKernel;
        static componentAdd: CIBlendKernel;
        static componentMax: CIBlendKernel;
        static componentMin: CIBlendKernel;
        static componentMultiply: CIBlendKernel;
        static darken: CIBlendKernel;
        static darkerColor: CIBlendKernel;
        static destination: CIBlendKernel;
        static destinationAtop: CIBlendKernel;
        static destinationIn: CIBlendKernel;
        static destinationOut: CIBlendKernel;
        static destinationOver: CIBlendKernel;
        static difference: CIBlendKernel;
        static divide: CIBlendKernel;
        static exclusion: CIBlendKernel;
        static exclusiveOr: CIBlendKernel;
        static hardLight: CIBlendKernel;
        static hardMix: CIBlendKernel;
        static hue: CIBlendKernel;
        static lighten: CIBlendKernel;
        static lighterColor: CIBlendKernel;
        static linearBurn: CIBlendKernel;
        static linearDodge: CIBlendKernel;
        static linearLight: CIBlendKernel;
        static luminosity: CIBlendKernel;
        static multiply: CIBlendKernel;
        static overlay: CIBlendKernel;
        static pinLight: CIBlendKernel;
        static saturation: CIBlendKernel;
        static screen: CIBlendKernel;
        static softLight: CIBlendKernel;
        static source: CIBlendKernel;
        static sourceAtop: CIBlendKernel;
        static sourceIn: CIBlendKernel;
        static sourceOut: CIBlendKernel;
        static sourceOver: CIBlendKernel;
        static subtract: CIBlendKernel;
        static vividLight: CIBlendKernel;
        applyWithForegroundBackground(foreground: CIImage, background: CIImage): CIImage;
        applyWithForegroundBackgroundColorSpace(foreground: CIImage, background: CIImage, colorSpace: any): CIImage;
    }
    interface CIBlendWithMask extends CIFilter {
        backgroundImage: CIImage;
        setBackgroundImage(_: CIImage): any;
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        maskImage: CIImage;
        setMaskImage(_: CIImage): any;
    }
    interface CIBloom extends CIFilter {
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        intensity: number;
        setIntensity(_: number): any;
        radius: number;
        setRadius(_: number): any;
    }
    interface CIBokehBlur extends CIFilter {
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        radius: number;
        setRadius(_: number): any;
        ringAmount: number;
        setRingAmount(_: number): any;
        ringSize: number;
        setRingSize(_: number): any;
        softness: number;
        setSoftness(_: number): any;
    }
    interface CIBoxBlur extends CIFilter {
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        radius: number;
        setRadius(_: number): any;
    }
    interface CICMYKHalftone extends CIFilter {
        angle: number;
        setAngle(_: number): any;
        center: CGPoint;
        setCenter(_: CGPoint): any;
        grayComponentReplacement: number;
        setGrayComponentReplacement(_: number): any;
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        sharpness: number;
        setSharpness(_: number): any;
        underColorRemoval: number;
        setUnderColorRemoval(_: number): any;
        width: number;
        setWidth(_: number): any;
    }
    interface CICheckerboardGenerator extends CIFilter {
        center: CGPoint;
        setCenter(_: CGPoint): any;
        color0: CIColor;
        setColor0(_: CIColor): any;
        color1: CIColor;
        setColor1(_: CIColor): any;
        sharpness: number;
        setSharpness(_: number): any;
        width: number;
        setWidth(_: number): any;
    }
    interface CICircularScreen extends CIFilter {
        center: CGPoint;
        setCenter(_: CGPoint): any;
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        sharpness: number;
        setSharpness(_: number): any;
        width: number;
        setWidth(_: number): any;
    }
    interface CICode128BarcodeGenerator extends CIFilter {
        barcodeHeight: number;
        setBarcodeHeight(_: number): any;
        message: NSData;
        setMessage(_: NSData): any;
        quietSpace: number;
        setQuietSpace(_: number): any;
    }
    class CIColor extends NSObject {
        alpha: number;
        blue: number;
        colorSpace: any;
        components: number;
        green: number;
        numberOfComponents: number;
        red: number;
        stringRepresentation: string;
        static blackColor: CIColor;
        static blueColor: CIColor;
        static clearColor: CIColor;
        static cyanColor: CIColor;
        static grayColor: CIColor;
        static greenColor: CIColor;
        static magentaColor: CIColor;
        static redColor: CIColor;
        static whiteColor: CIColor;
        static yellowColor: CIColor;
        static createWithCGColor(CGColor: any): CIColor;
        static createWithColor(color: NSColor): CIColor;
        static createWithRedGreenBlue(red: number, green: number, blue: number): CIColor;
        static createWithRedGreenBlueAlpha(red: number, green: number, blue: number, alpha: number): CIColor;
        static createWithRedGreenBlueAlphaColorSpace(red: number, green: number, blue: number, alpha: number, colorSpace: any): CIColor;
        static createWithRedGreenBlueColorSpace(red: number, green: number, blue: number, colorSpace: any): CIColor;
    }
    interface CIColorClamp extends CIFilter {
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        maxComponents: CIVector;
        setMaxComponents(_: CIVector): any;
        minComponents: CIVector;
        setMinComponents(_: CIVector): any;
    }
    interface CIColorControls extends CIFilter {
        brightness: number;
        setBrightness(_: number): any;
        contrast: number;
        setContrast(_: number): any;
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        saturation: number;
        setSaturation(_: number): any;
    }
    interface CIColorCrossPolynomial extends CIFilter {
        blueCoefficients: CIVector;
        setBlueCoefficients(_: CIVector): any;
        greenCoefficients: CIVector;
        setGreenCoefficients(_: CIVector): any;
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        redCoefficients: CIVector;
        setRedCoefficients(_: CIVector): any;
    }
    interface CIColorCube extends CIFilter {
        cubeData: NSData;
        setCubeData(_: NSData): any;
        cubeDimension: number;
        setCubeDimension(_: number): any;
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
    }
    interface CIColorCubeWithColorSpace extends CIFilter {
        colorSpace: any;
        setColorSpace(_: any): any;
        cubeData: NSData;
        setCubeData(_: NSData): any;
        cubeDimension: number;
        setCubeDimension(_: number): any;
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
    }
    interface CIColorCubesMixedWithMask extends CIFilter {
        colorSpace: any;
        setColorSpace(_: any): any;
        cube0Data: NSData;
        setCube0Data(_: NSData): any;
        cube1Data: NSData;
        setCube1Data(_: NSData): any;
        cubeDimension: number;
        setCubeDimension(_: number): any;
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        maskImage: CIImage;
        setMaskImage(_: CIImage): any;
    }
    interface CIColorCurves extends CIFilter {
        colorSpace: any;
        setColorSpace(_: any): any;
        curvesData: NSData;
        setCurvesData(_: NSData): any;
        curvesDomain: CIVector;
        setCurvesDomain(_: CIVector): any;
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
    }
    interface CIColorInvert extends CIFilter {
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
    }
    class CIColorKernel extends CIKernel {
        applyWithExtentArguments(extent: CGRect, arguments_?: any[]): CIImage;
    }
    interface CIColorMap extends CIFilter {
        gradientImage: CIImage;
        setGradientImage(_: CIImage): any;
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
    }
    interface CIColorMatrix extends CIFilter {
        AVector: CIVector;
        setAVector(_: CIVector): any;
        biasVector: CIVector;
        setBiasVector(_: CIVector): any;
        BVector: CIVector;
        setBVector(_: CIVector): any;
        GVector: CIVector;
        setGVector(_: CIVector): any;
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        RVector: CIVector;
        setRVector(_: CIVector): any;
    }
    interface CIColorMonochrome extends CIFilter {
        color: CIColor;
        setColor(_: CIColor): any;
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        intensity: number;
        setIntensity(_: number): any;
    }
    interface CIColorPolynomial extends CIFilter {
        alphaCoefficients: CIVector;
        setAlphaCoefficients(_: CIVector): any;
        blueCoefficients: CIVector;
        setBlueCoefficients(_: CIVector): any;
        greenCoefficients: CIVector;
        setGreenCoefficients(_: CIVector): any;
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        redCoefficients: CIVector;
        setRedCoefficients(_: CIVector): any;
    }
    interface CIColorPosterize extends CIFilter {
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        levels: number;
        setLevels(_: number): any;
    }
    interface CIComicEffect extends CIFilter {
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
    }
    interface CICompositeOperation extends CIFilter {
        backgroundImage: CIImage;
        setBackgroundImage(_: CIImage): any;
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
    }
    class CIContext extends NSObject {
        static offlineGPUCount(): number;
        workingColorSpace: any;
        workingFormat: number;
        HEIFRepresentationOfImageFormatColorSpaceOptions(of: CIImage, format: number, colorSpace: any, options: Map<string, any>): NSData;
        JPEGRepresentationOfImageColorSpaceOptions(of: CIImage, colorSpace: any, options: Map<string, any>): NSData;
        PNGRepresentationOfImageFormatColorSpaceOptions(of: CIImage, format: number, colorSpace: any, options: Map<string, any>): NSData;
        TIFFRepresentationOfImageFormatColorSpaceOptions(of: CIImage, format: number, colorSpace: any, options: Map<string, any>): NSData;
        clearCaches(): void;
        createCGImageFromRect(_: CIImage, from: CGRect): any;
        createCGImageFromRectFormatColorSpace(_: CIImage, from: CGRect, format: number, colorSpace?: any): any;
        createCGImageFromRectFormatColorSpaceDeferred(_: CIImage, from: CGRect, format: number, colorSpace?: any, deferred?: boolean): any;
        depthBlurEffectFilterForImageDisparityImagePortraitEffectsMatteHairSemanticSegmentationOrientationOptions(for_: CIImage, disparityImage: CIImage, portraitEffectsMatte?: CIImage, hairSemanticSegmentation?: CIImage, orientation?: CGImagePropertyOrientation, options?: Map<any, any>): CIFilter;
        depthBlurEffectFilterForImageDisparityImagePortraitEffectsMatteOrientationOptions(for_: CIImage, disparityImage: CIImage, portraitEffectsMatte?: CIImage, orientation?: CGImagePropertyOrientation, options?: Map<any, any>): CIFilter;
        depthBlurEffectFilterForImageDataOptions(forImageData: NSData, options?: Map<any, any>): CIFilter;
        depthBlurEffectFilterForImageURLOptions(forImageURL: NSURL, options?: Map<any, any>): CIFilter;
        drawImageInRectFromRect(_: CIImage, in_: CGRect, from: CGRect): void;
        static createWithOptions(options?: Map<string, any>): CIContext;
        prepareRenderFromRectToDestinationAtPointError(fromRect: CIImage, toDestination: CGRect, atPoint: CIRenderDestination, error: CGPoint): boolean;
        reclaimResources(): void;
        renderToBitmapRowBytesBoundsFormatColorSpace(_: CIImage, toBitmap: any, rowBytes: number, bounds: CGRect, format: number, colorSpace?: any): void;
        renderToCVPixelBuffer(_: CIImage, to: any): void;
        renderToCVPixelBufferBoundsColorSpace(_: CIImage, to: any, bounds: CGRect, colorSpace?: any): void;
        renderToIOSurfaceBoundsColorSpace(_: CIImage, to: any, bounds: CGRect, colorSpace?: any): void;
        startTaskToClearError(error: CIRenderDestination): CIRenderTask;
        startTaskToRenderFromRectToDestinationAtPointError(fromRect: CIImage, toDestination: CGRect, atPoint: CIRenderDestination, error: CGPoint): CIRenderTask;
        startTaskToRenderToDestinationError(toDestination: CIImage, error: CIRenderDestination): CIRenderTask;
        writeHEIFRepresentationOfImageToURLFormatColorSpaceOptionsError(toURL: CIImage, format: NSURL, colorSpace: number, options: any, error: Map<string, any>): boolean;
        writeJPEGRepresentationOfImageToURLColorSpaceOptionsError(toURL: CIImage, colorSpace: NSURL, options: any, error: Map<string, any>): boolean;
        writePNGRepresentationOfImageToURLFormatColorSpaceOptionsError(toURL: CIImage, format: NSURL, colorSpace: number, options: any, error: Map<string, any>): boolean;
        writeTIFFRepresentationOfImageToURLFormatColorSpaceOptionsError(toURL: CIImage, format: NSURL, colorSpace: number, options: any, error: Map<string, any>): boolean;
    }
    interface CIConvolution extends CIFilter {
        bias: number;
        setBias(_: number): any;
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        weights: CIVector;
        setWeights(_: CIVector): any;
    }
    interface CICopyMachineTransition extends CITransitionFilter {
        angle: number;
        setAngle(_: number): any;
        color: CIColor;
        setColor(_: CIColor): any;
        extent: CGRect;
        setExtent(_: CGRect): any;
        opacity: number;
        setOpacity(_: number): any;
        width: number;
        setWidth(_: number): any;
    }
    interface CICoreMLModel extends CIFilter {
        headIndex: number;
        setHeadIndex(_: number): any;
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        model: MLModel;
        setModel(_: MLModel): any;
        softmaxNormalization: boolean;
        setSoftmaxNormalization(_: boolean): any;
    }
    interface CICrystallize extends CIFilter {
        center: CGPoint;
        setCenter(_: CGPoint): any;
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        radius: number;
        setRadius(_: number): any;
    }
    class CIDataMatrixCodeDescriptor extends CIBarcodeDescriptor {
        static descriptorWithPayloadRowCountColumnCountEccVersion(payload: NSData, rowCount: number, columnCount: number, eccVersion: CIDataMatrixCodeECCVersion): CIDataMatrixCodeDescriptor;
        columnCount: number;
        eccVersion: CIDataMatrixCodeECCVersion;
        errorCorrectedPayload: NSData;
        rowCount: number;
        static createWithPayloadRowCountColumnCountEccVersion(payload: NSData, rowCount: number, columnCount: number, eccVersion: CIDataMatrixCodeECCVersion): CIDataMatrixCodeDescriptor;
    }
    interface CIDepthOfField extends CIFilter {
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        point0: CGPoint;
        setPoint0(_: CGPoint): any;
        point1: CGPoint;
        setPoint1(_: CGPoint): any;
        radius: number;
        setRadius(_: number): any;
        saturation: number;
        setSaturation(_: number): any;
        unsharpMaskIntensity: number;
        setUnsharpMaskIntensity(_: number): any;
        unsharpMaskRadius: number;
        setUnsharpMaskRadius(_: number): any;
    }
    interface CIDepthToDisparity extends CIFilter {
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
    }
    class CIDetector extends NSObject {
        featuresInImage(in_: CIImage): CIFeature[];
        featuresInImageOptions(in_: CIImage, options?: Map<string, any>): CIFeature[];
    }
    interface CIDiscBlur extends CIFilter {
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        radius: number;
        setRadius(_: number): any;
    }
    interface CIDisintegrateWithMaskTransition extends CITransitionFilter {
        maskImage: CIImage;
        setMaskImage(_: CIImage): any;
        shadowDensity: number;
        setShadowDensity(_: number): any;
        shadowOffset: CGPoint;
        setShadowOffset(_: CGPoint): any;
        shadowRadius: number;
        setShadowRadius(_: number): any;
    }
    interface CIDisparityToDepth extends CIFilter {
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
    }
    type CIDissolveTransition = CITransitionFilter;
    interface CIDither extends CIFilter {
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        intensity: number;
        setIntensity(_: number): any;
    }
    interface CIDocumentEnhancer extends CIFilter {
        amount: number;
        setAmount(_: number): any;
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
    }
    interface CIDotScreen extends CIFilter {
        angle: number;
        setAngle(_: number): any;
        center: CGPoint;
        setCenter(_: CGPoint): any;
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        sharpness: number;
        setSharpness(_: number): any;
        width: number;
        setWidth(_: number): any;
    }
    interface CIEdgePreserveUpsample extends CIFilter {
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        lumaSigma: number;
        setLumaSigma(_: number): any;
        smallImage: CIImage;
        setSmallImage(_: CIImage): any;
        spatialSigma: number;
        setSpatialSigma(_: number): any;
    }
    interface CIEdgeWork extends CIFilter {
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        radius: number;
        setRadius(_: number): any;
    }
    interface CIEdges extends CIFilter {
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        intensity: number;
        setIntensity(_: number): any;
    }
    interface CIEightfoldReflectedTile extends CIFilter {
        angle: number;
        setAngle(_: number): any;
        center: CGPoint;
        setCenter(_: CGPoint): any;
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        width: number;
        setWidth(_: number): any;
    }
    interface CIExposureAdjust extends CIFilter {
        EV: number;
        setEV(_: number): any;
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
    }
    class CIFaceFeature extends CIFeature {
        faceAngle: number;
        hasFaceAngle: boolean;
        hasLeftEyePosition: boolean;
        hasMouthPosition: boolean;
        hasRightEyePosition: boolean;
        hasSmile: boolean;
        hasTrackingFrameCount: boolean;
        hasTrackingID: boolean;
        leftEyeClosed: boolean;
        leftEyePosition: CGPoint;
        mouthPosition: CGPoint;
        rightEyeClosed: boolean;
        rightEyePosition: CGPoint;
        trackingFrameCount: number;
        trackingID: number;
    }
    interface CIFalseColor extends CIFilter {
        color0: CIColor;
        setColor0(_: CIColor): any;
        color1: CIColor;
        setColor1(_: CIColor): any;
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
    }
    class CIFeature extends NSObject {
        bounds: CGRect;
        type: string;
    }
    class CIFilter extends NSObject {
        static CMYKHalftone(): CIFilter;
        static LabDeltaE(): CIFilter;
        static PDF417BarcodeGenerator(): CIFilter;
        static QRCodeGenerator(): CIFilter;
        static accordionFoldTransitionFilter(): CIFilter;
        static additionCompositingFilter(): CIFilter;
        static affineClampFilter(): CIFilter;
        static affineTileFilter(): CIFilter;
        static attributedTextImageGeneratorFilter(): CIFilter;
        static aztecCodeGeneratorFilter(): CIFilter;
        static barcodeGeneratorFilter(): CIFilter;
        static barsSwipeTransitionFilter(): CIFilter;
        static bicubicScaleTransformFilter(): CIFilter;
        static blendWithAlphaMaskFilter(): CIFilter;
        static blendWithBlueMaskFilter(): CIFilter;
        static blendWithMaskFilter(): CIFilter;
        static blendWithRedMaskFilter(): CIFilter;
        static bloomFilter(): CIFilter;
        static bokehBlurFilter(): CIFilter;
        static boxBlurFilter(): CIFilter;
        static checkerboardGeneratorFilter(): CIFilter;
        static circularScreenFilter(): CIFilter;
        static code128BarcodeGeneratorFilter(): CIFilter;
        static colorBlendModeFilter(): CIFilter;
        static colorBurnBlendModeFilter(): CIFilter;
        static colorClampFilter(): CIFilter;
        static colorControlsFilter(): CIFilter;
        static colorCrossPolynomialFilter(): CIFilter;
        static colorCubeFilter(): CIFilter;
        static colorCubeWithColorSpaceFilter(): CIFilter;
        static colorCubesMixedWithMaskFilter(): CIFilter;
        static colorCurvesFilter(): CIFilter;
        static colorDodgeBlendModeFilter(): CIFilter;
        static colorInvertFilter(): CIFilter;
        static colorMapFilter(): CIFilter;
        static colorMatrixFilter(): CIFilter;
        static colorMonochromeFilter(): CIFilter;
        static colorPolynomialFilter(): CIFilter;
        static colorPosterizeFilter(): CIFilter;
        static comicEffectFilter(): CIFilter;
        static convolution3X3Filter(): CIFilter;
        static convolution5X5Filter(): CIFilter;
        static convolution7X7Filter(): CIFilter;
        static convolution9HorizontalFilter(): CIFilter;
        static convolution9VerticalFilter(): CIFilter;
        static copyMachineTransitionFilter(): CIFilter;
        static coreMLModelFilter(): CIFilter;
        static crystallizeFilter(): CIFilter;
        static darkenBlendModeFilter(): CIFilter;
        static depthOfFieldFilter(): CIFilter;
        static depthToDisparityFilter(): CIFilter;
        static differenceBlendModeFilter(): CIFilter;
        static discBlurFilter(): CIFilter;
        static disintegrateWithMaskTransitionFilter(): CIFilter;
        static disparityToDepthFilter(): CIFilter;
        static dissolveTransitionFilter(): CIFilter;
        static ditherFilter(): CIFilter;
        static divideBlendModeFilter(): CIFilter;
        static documentEnhancerFilter(): CIFilter;
        static dotScreenFilter(): CIFilter;
        static edgePreserveUpsampleFilter(): CIFilter;
        static edgeWorkFilter(): CIFilter;
        static edgesFilter(): CIFilter;
        static eightfoldReflectedTileFilter(): CIFilter;
        static exclusionBlendModeFilter(): CIFilter;
        static exposureAdjustFilter(): CIFilter;
        static falseColorFilter(): CIFilter;
        static filterArrayFromSerializedXMPInputImageExtentError(fromSerializedXMP: NSData, inputImageExtent: CGRect): CIFilter[];
        static filterNamesInCategories(inCategories?: string[]): string[];
        static filterNamesInCategory(inCategory?: string): string[];
        static flashTransitionFilter(): CIFilter;
        static fourfoldReflectedTileFilter(): CIFilter;
        static fourfoldRotatedTileFilter(): CIFilter;
        static fourfoldTranslatedTileFilter(): CIFilter;
        static gaborGradientsFilter(): CIFilter;
        static gammaAdjustFilter(): CIFilter;
        static gaussianBlurFilter(): CIFilter;
        static gaussianGradientFilter(): CIFilter;
        static glideReflectedTileFilter(): CIFilter;
        static gloomFilter(): CIFilter;
        static hardLightBlendModeFilter(): CIFilter;
        static hatchedScreenFilter(): CIFilter;
        static heightFieldFromMaskFilter(): CIFilter;
        static hexagonalPixellateFilter(): CIFilter;
        static highlightShadowAdjustFilter(): CIFilter;
        static hueAdjustFilter(): CIFilter;
        static hueBlendModeFilter(): CIFilter;
        static hueSaturationValueGradientFilter(): CIFilter;
        static kaleidoscopeFilter(): CIFilter;
        static keystoneCorrectionCombinedFilter(): CIFilter;
        static keystoneCorrectionHorizontalFilter(): CIFilter;
        static keystoneCorrectionVerticalFilter(): CIFilter;
        static lanczosScaleTransformFilter(): CIFilter;
        static lenticularHaloGeneratorFilter(): CIFilter;
        static lightenBlendModeFilter(): CIFilter;
        static lineOverlayFilter(): CIFilter;
        static lineScreenFilter(): CIFilter;
        static linearBurnBlendModeFilter(): CIFilter;
        static linearDodgeBlendModeFilter(): CIFilter;
        static linearGradientFilter(): CIFilter;
        static linearToSRGBToneCurveFilter(): CIFilter;
        static localizedDescriptionForFilterName(forFilterName: string): string;
        static localizedNameForCategory(forCategory: string): string;
        static localizedNameForFilterName(forFilterName: string): string;
        static localizedReferenceDocumentationForFilterName(forFilterName: string): NSURL;
        static luminosityBlendModeFilter(): CIFilter;
        static maskToAlphaFilter(): CIFilter;
        static maskedVariableBlurFilter(): CIFilter;
        static maximumComponentFilter(): CIFilter;
        static maximumCompositingFilter(): CIFilter;
        static medianFilter(): CIFilter;
        static meshGeneratorFilter(): CIFilter;
        static minimumComponentFilter(): CIFilter;
        static minimumCompositingFilter(): CIFilter;
        static mixFilter(): CIFilter;
        static modTransitionFilter(): CIFilter;
        static morphologyGradientFilter(): CIFilter;
        static morphologyMaximumFilter(): CIFilter;
        static morphologyMinimumFilter(): CIFilter;
        static morphologyRectangleMaximumFilter(): CIFilter;
        static morphologyRectangleMinimumFilter(): CIFilter;
        static motionBlurFilter(): CIFilter;
        static multiplyBlendModeFilter(): CIFilter;
        static multiplyCompositingFilter(): CIFilter;
        static noiseReductionFilter(): CIFilter;
        static opTileFilter(): CIFilter;
        static overlayBlendModeFilter(): CIFilter;
        static pageCurlTransitionFilter(): CIFilter;
        static pageCurlWithShadowTransitionFilter(): CIFilter;
        static paletteCentroidFilter(): CIFilter;
        static palettizeFilter(): CIFilter;
        static parallelogramTileFilter(): CIFilter;
        static perspectiveCorrectionFilter(): CIFilter;
        static perspectiveRotateFilter(): CIFilter;
        static perspectiveTileFilter(): CIFilter;
        static perspectiveTransformFilter(): CIFilter;
        static perspectiveTransformWithExtentFilter(): CIFilter;
        static photoEffectChromeFilter(): CIFilter;
        static photoEffectFadeFilter(): CIFilter;
        static photoEffectInstantFilter(): CIFilter;
        static photoEffectMonoFilter(): CIFilter;
        static photoEffectNoirFilter(): CIFilter;
        static photoEffectProcessFilter(): CIFilter;
        static photoEffectTonalFilter(): CIFilter;
        static photoEffectTransferFilter(): CIFilter;
        static pinLightBlendModeFilter(): CIFilter;
        static pixellateFilter(): CIFilter;
        static pointillizeFilter(): CIFilter;
        static radialGradientFilter(): CIFilter;
        static randomGeneratorFilter(): CIFilter;
        static registerFilterNameConstructorClassAttributes(_: string, constructor: CIFilterConstructor, classAttributes: Map<string, any>): void;
        static rippleTransitionFilter(): CIFilter;
        static roundedRectangleGeneratorFilter(): CIFilter;
        static sRGBToneCurveToLinearFilter(): CIFilter;
        static saliencyMapFilter(): CIFilter;
        static saturationBlendModeFilter(): CIFilter;
        static screenBlendModeFilter(): CIFilter;
        static sepiaToneFilter(): CIFilter;
        static serializedXMPFromFiltersInputImageExtent(from: CIFilter[], inputImageExtent: CGRect): NSData;
        static shadedMaterialFilter(): CIFilter;
        static sharpenLuminanceFilter(): CIFilter;
        static sixfoldReflectedTileFilter(): CIFilter;
        static sixfoldRotatedTileFilter(): CIFilter;
        static smoothLinearGradientFilter(): CIFilter;
        static softLightBlendModeFilter(): CIFilter;
        static sourceAtopCompositingFilter(): CIFilter;
        static sourceInCompositingFilter(): CIFilter;
        static sourceOutCompositingFilter(): CIFilter;
        static sourceOverCompositingFilter(): CIFilter;
        static spotColorFilter(): CIFilter;
        static spotLightFilter(): CIFilter;
        static starShineGeneratorFilter(): CIFilter;
        static straightenFilter(): CIFilter;
        static stripesGeneratorFilter(): CIFilter;
        static subtractBlendModeFilter(): CIFilter;
        static sunbeamsGeneratorFilter(): CIFilter;
        static supportedRawCameraModels(): string[];
        static swipeTransitionFilter(): CIFilter;
        static temperatureAndTintFilter(): CIFilter;
        static textImageGeneratorFilter(): CIFilter;
        static thermalFilter(): CIFilter;
        static toneCurveFilter(): CIFilter;
        static triangleKaleidoscopeFilter(): CIFilter;
        static triangleTileFilter(): CIFilter;
        static twelvefoldReflectedTileFilter(): CIFilter;
        static unsharpMaskFilter(): CIFilter;
        static vibranceFilter(): CIFilter;
        static vignetteEffectFilter(): CIFilter;
        static vignetteFilter(): CIFilter;
        static whitePointAdjustFilter(): CIFilter;
        static xRayFilter(): CIFilter;
        static zoomBlurFilter(): CIFilter;
        attributes: Map<string, any>;
        isEnabled: boolean;
        setEnabled(_: boolean): any;
        inputKeys: string[];
        name: string;
        setName(_: string): any;
        outputImage: CIImage;
        outputKeys: string[];
        applyArgumentsOptions(_: CIKernel, arguments_?: any[], options?: Map<string, any>): CIImage;
        setDefaults(): void;
        setName(_: string): void;
        viewForUIConfigurationExcludedKeys(_: Map<any, any>, excludedKeys: any[]): IKFilterUIView;
    }
    interface CIFilterConstructor {
        filterWithName(withName: string): CIFilter;
    }
    class CIFilterGenerator extends NSObject {
        classAttributes: Map<any, any>;
        setClassAttributes(_: Map<any, any>): any;
        exportedKeys: Map<any, any>;
        connectObjectWithKeyToObjectWithKey(_: any, withKey?: string, to?: any, withKey2?: string): void;
        disconnectObjectWithKeyToObjectWithKey(_: any, withKey: string, to: any, withKey2: string): void;
        exportKeyFromObjectWithName(_: string, from: any, withName?: string): void;
        filter(): CIFilter;
        static createWithContentsOfURL(contentsOfURL: NSURL): CIFilterGenerator;
        registerFilterName(_: string): void;
        removeExportedKey(_: string): void;
        setAttributesForExportedKey(_: Map<any, any>, forExportedKey: string): void;
        writeToURLAtomically(to: NSURL, atomically: boolean): boolean;
    }
    interface CIFilter {
        outputImage: CIImage;
    }
    class CIFilterShape extends NSObject {
        extent: CGRect;
        static createWithRect(rect: CGRect): CIFilterShape;
        insetByXY(x: number, y: number): CIFilterShape;
        intersectWith(with_: CIFilterShape): CIFilterShape;
        intersectWithRect(with_: CGRect): CIFilterShape;
        transformByInterior(by: CGAffineTransform, interior: boolean): CIFilterShape;
        unionWith(with_: CIFilterShape): CIFilterShape;
        unionWithRect(with_: CGRect): CIFilterShape;
    }
    interface CIFlashTransition extends CITransitionFilter {
        center: CGPoint;
        setCenter(_: CGPoint): any;
        color: CIColor;
        setColor(_: CIColor): any;
        extent: CGRect;
        setExtent(_: CGRect): any;
        fadeThreshold: number;
        setFadeThreshold(_: number): any;
        maxStriationRadius: number;
        setMaxStriationRadius(_: number): any;
        striationContrast: number;
        setStriationContrast(_: number): any;
        striationStrength: number;
        setStriationStrength(_: number): any;
    }
    interface CIFourCoordinateGeometryFilter extends CIFilter {
        bottomLeft: CGPoint;
        setBottomLeft(_: CGPoint): any;
        bottomRight: CGPoint;
        setBottomRight(_: CGPoint): any;
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        topLeft: CGPoint;
        setTopLeft(_: CGPoint): any;
        topRight: CGPoint;
        setTopRight(_: CGPoint): any;
    }
    interface CIFourfoldReflectedTile extends CIFilter {
        acuteAngle: number;
        setAcuteAngle(_: number): any;
        angle: number;
        setAngle(_: number): any;
        center: CGPoint;
        setCenter(_: CGPoint): any;
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        width: number;
        setWidth(_: number): any;
    }
    interface CIFourfoldRotatedTile extends CIFilter {
        angle: number;
        setAngle(_: number): any;
        center: CGPoint;
        setCenter(_: CGPoint): any;
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        width: number;
        setWidth(_: number): any;
    }
    interface CIFourfoldTranslatedTile extends CIFilter {
        acuteAngle: number;
        setAcuteAngle(_: number): any;
        angle: number;
        setAngle(_: number): any;
        center: CGPoint;
        setCenter(_: CGPoint): any;
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        width: number;
        setWidth(_: number): any;
    }
    interface CIGaborGradients extends CIFilter {
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
    }
    interface CIGammaAdjust extends CIFilter {
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
    }
    interface CIGaussianBlur extends CIFilter {
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        radius: number;
        setRadius(_: number): any;
    }
    interface CIGaussianGradient extends CIFilter {
        center: CGPoint;
        setCenter(_: CGPoint): any;
        color0: CIColor;
        setColor0(_: CIColor): any;
        color1: CIColor;
        setColor1(_: CIColor): any;
        radius: number;
        setRadius(_: number): any;
    }
    interface CIGlideReflectedTile extends CIFilter {
        angle: number;
        setAngle(_: number): any;
        center: CGPoint;
        setCenter(_: CGPoint): any;
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        width: number;
        setWidth(_: number): any;
    }
    interface CIGloom extends CIFilter {
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        intensity: number;
        setIntensity(_: number): any;
        radius: number;
        setRadius(_: number): any;
    }
    interface CIHatchedScreen extends CIFilter {
        angle: number;
        setAngle(_: number): any;
        center: CGPoint;
        setCenter(_: CGPoint): any;
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        sharpness: number;
        setSharpness(_: number): any;
        width: number;
        setWidth(_: number): any;
    }
    interface CIHeightFieldFromMask extends CIFilter {
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        radius: number;
        setRadius(_: number): any;
    }
    interface CIHexagonalPixellate extends CIFilter {
        center: CGPoint;
        setCenter(_: CGPoint): any;
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        scale: number;
        setScale(_: number): any;
    }
    interface CIHighlightShadowAdjust extends CIFilter {
        highlightAmount: number;
        setHighlightAmount(_: number): any;
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        radius: number;
        setRadius(_: number): any;
        shadowAmount: number;
        setShadowAmount(_: number): any;
    }
    interface CIHueAdjust extends CIFilter {
        angle: number;
        setAngle(_: number): any;
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
    }
    interface CIHueSaturationValueGradient extends CIFilter {
        colorSpace: any;
        setColorSpace(_: any): any;
        dither: number;
        setDither(_: number): any;
        radius: number;
        setRadius(_: number): any;
        softness: number;
        setSoftness(_: number): any;
        value: number;
        setValue(_: number): any;
    }
    class CIImage extends NSObject {
        static emptyImage(): CIImage;
        static imageWithDepthData(_: AVDepthData): CIImage;
        static imageWithDepthDataOptions(_: AVDepthData, options?: Map<string, any>): CIImage;
        static imageWithImageProviderSizeFormatColorSpaceOptions(_: any, _2: number, size: number, format: number, colorSpace?: any, options?: Map<string, any>): CIImage;
        static imageWithPortaitEffectsMatte(_: AVPortraitEffectsMatte): CIImage;
        static imageWithPortaitEffectsMatteOptions(_: AVPortraitEffectsMatte, options?: Map<string, any>): CIImage;
        static imageWithSemanticSegmentationMatte(_: AVSemanticSegmentationMatte): CIImage;
        static imageWithSemanticSegmentationMatteOptions(_: AVSemanticSegmentationMatte, options?: Map<string, any>): CIImage;
        CGImage: any;
        colorSpace: any;
        definition: CIFilterShape;
        depthData: AVDepthData;
        extent: CGRect;
        pixelBuffer: any;
        portraitEffectsMatte: AVPortraitEffectsMatte;
        properties: Map<string, any>;
        semanticSegmentationMatte: AVSemanticSegmentationMatte;
        url: NSURL;
        static blackImage: CIImage;
        static blueImage: CIImage;
        static clearImage: CIImage;
        static cyanImage: CIImage;
        static grayImage: CIImage;
        static greenImage: CIImage;
        static magentaImage: CIImage;
        static redImage: CIImage;
        static whiteImage: CIImage;
        static yellowImage: CIImage;
        autoAdjustmentFilters(): CIFilter[];
        autoAdjustmentFiltersWithOptions(options?: Map<string, any>): CIFilter[];
        drawAtPointFromRectOperationFraction(at: CGPoint, from: CGRect, operation: NSCompositingOperation, fraction: number): void;
        drawInRectFromRectOperationFraction(in_: CGRect, from: CGRect, operation: NSCompositingOperation, fraction: number): void;
        imageByApplyingCGOrientation(_: CGImagePropertyOrientation): CIImage;
        imageByApplyingFilter(_: string): CIImage;
        imageByApplyingFilterWithInputParameters(_: string, parameters?: Map<string, any>): CIImage;
        imageByApplyingGaussianBlurWithSigma(sigma: number): CIImage;
        imageByApplyingOrientation(forExifOrientation: number): CIImage;
        imageByApplyingTransform(by: CGAffineTransform): CIImage;
        imageByApplyingTransformHighQualityDownsample(by: CGAffineTransform, highQualityDownsample: boolean): CIImage;
        imageByClampingToExtent(): CIImage;
        imageByClampingToRect(to: CGRect): CIImage;
        imageByColorMatchingColorSpaceToWorkingSpace(from: any): CIImage;
        imageByColorMatchingWorkingSpaceToColorSpace(to: any): CIImage;
        imageByCompositingOverImage(over: CIImage): CIImage;
        imageByCroppingToRect(to: CGRect): CIImage;
        imageByInsertingIntermediate(): CIImage;
        imageByInsertingIntermediate(cache: boolean): CIImage;
        imageByPremultiplyingAlpha(): CIImage;
        imageBySamplingLinear(): CIImage;
        imageBySamplingNearest(): CIImage;
        imageBySettingAlphaOneInExtent(in_: CGRect): CIImage;
        imageBySettingProperties(_: Map<any, any>): CIImage;
        imageByUnpremultiplyingAlpha(): CIImage;
        imageTransformForCGOrientation(for_: CGImagePropertyOrientation): CGAffineTransform;
        imageTransformForOrientation(forExifOrientation: number): CGAffineTransform;
        static createWithBitmapDataBytesPerRowSizeFormatColorSpace(bitmapData: NSData, bytesPerRow: number, size: CGSize, format: number, colorSpace?: any): CIImage;
        static createWithBitmapImageRep(bitmapImageRep: NSBitmapImageRep): CIImage;
        static createWithCGImage(CGImage: any): CIImage;
        static createWithCGImageOptions(CGImage: any, options?: Map<string, any>): CIImage;
        static createWithCGImageSourceIndexOptions(CGImageSource: any, index: number, options?: Map<string, any>): CIImage;
        static createWithCVImageBuffer(CVImageBuffer: any): CIImage;
        static createWithCVImageBufferOptions(CVImageBuffer: any, options?: Map<string, any>): CIImage;
        static createWithCVPixelBuffer(CVPixelBuffer: any): CIImage;
        static createWithCVPixelBufferOptions(CVPixelBuffer: any, options?: Map<string, any>): CIImage;
        static createWithColor(color: CIColor): CIImage;
        static createWithContentsOfURL(contentsOfURL: NSURL): CIImage;
        static createWithContentsOfURLOptions(contentsOfURL: NSURL, options?: Map<string, any>): CIImage;
        static createWithData(data: NSData): CIImage;
        static createWithDataOptions(data: NSData, options?: Map<string, any>): CIImage;
        static createWithDepthData(depthData: AVDepthData): CIImage;
        static createWithDepthDataOptions(depthData: AVDepthData, options?: Map<string, any>): CIImage;
        static createWithIOSurface(IOSurface: any): CIImage;
        static createWithIOSurfaceOptions(IOSurface: any, options?: Map<string, any>): CIImage;
        static createWithImageProviderSizeFormatColorSpaceOptions(_: any, imageProvider: number, size: number, format: number, colorSpace?: any, options?: Map<string, any>): CIImage;
        static createWithPortaitEffectsMatte(portaitEffectsMatte: AVPortraitEffectsMatte): CIImage;
        static createWithPortaitEffectsMatteOptions(portaitEffectsMatte: AVPortraitEffectsMatte, options?: Map<string, any>): CIImage;
        static createWithSemanticSegmentationMatte(semanticSegmentationMatte: AVSemanticSegmentationMatte): CIImage;
        static createWithSemanticSegmentationMatteOptions(semanticSegmentationMatte: AVSemanticSegmentationMatte, options?: Map<string, any>): CIImage;
        regionOfInterestForImageInRect(for_: CIImage, in_: CGRect): CGRect;
    }
    class CIImageAccumulator extends NSObject {
        extent: CGRect;
        format: number;
        clear(): void;
        image(): CIImage;
        static createWithExtentFormat(extent: CGRect, format: number): CIImageAccumulator;
        static createWithExtentFormatColorSpace(extent: CGRect, format: number, colorSpace: any): CIImageAccumulator;
        setImage(_: CIImage): void;
        setImageDirtyRect(_: CIImage, dirtyRect: CGRect): void;
    }
    interface CIImageProcessorInput {
        baseAddress: any;
        bytesPerRow: number;
        format: number;
        pixelBuffer: any;
        region: CGRect;
        surface: any;
    }
    class CIImageProcessorKernel extends NSObject {
        static applyWithExtentInputsArgumentsError(inputs: CGRect, arguments_?: CIImage[], error?: Map<string, any>): CIImage;
        static formatForInputAtIndex(at: number): number;
        static processWithInputsWithArgumentsOutputError(arguments_?: CIImageProcessorInput[], output?: Map<string, any>, error?: CIImageProcessorOutput): boolean;
        static roiForInputArgumentsOutputRect(forInput: number, arguments_?: Map<string, any>, outputRect?: CGRect): CGRect;
        static outputFormat: number;
        static outputIsOpaque: boolean;
        static synchronizeInputs: boolean;
    }
    interface CIImageProcessorOutput {
        baseAddress: any;
        bytesPerRow: number;
        format: number;
        pixelBuffer: any;
        region: CGRect;
        surface: any;
    }
    interface CIKaleidoscope extends CIFilter {
        angle: number;
        setAngle(_: number): any;
        center: CGPoint;
        setCenter(_: CGPoint): any;
        count: number;
        setCount(_: number): any;
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
    }
    class CIKernel extends NSObject {
        static kernelWithFunctionNameFromMetalLibraryDataError(fromMetalLibraryData: string, error: NSData): CIKernel;
        static kernelWithFunctionNameFromMetalLibraryDataOutputPixelFormatError(fromMetalLibraryData: string, outputPixelFormat: NSData, error: number): CIKernel;
        name: string;
        applyWithExtentRoiCallbackArguments(extent: CGRect, roiCallback: (p1: number, p2: CGRect) => CGRect, arguments_?: any[]): CIImage;
        setROISelector(_: string): void;
    }
    interface CIKeystoneCorrectionCombined extends CIFourCoordinateGeometryFilter {
        focalLength: number;
        setFocalLength(_: number): any;
    }
    interface CIKeystoneCorrectionHorizontal extends CIFourCoordinateGeometryFilter {
        focalLength: number;
        setFocalLength(_: number): any;
    }
    interface CIKeystoneCorrectionVertical extends CIFourCoordinateGeometryFilter {
        focalLength: number;
        setFocalLength(_: number): any;
    }
    interface CILabDeltaE extends CIFilter {
        image2: CIImage;
        setImage2(_: CIImage): any;
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
    }
    interface CILanczosScaleTransform extends CIFilter {
        aspectRatio: number;
        setAspectRatio(_: number): any;
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        scale: number;
        setScale(_: number): any;
    }
    interface CILenticularHaloGenerator extends CIFilter {
        center: CGPoint;
        setCenter(_: CGPoint): any;
        color: CIColor;
        setColor(_: CIColor): any;
        haloOverlap: number;
        setHaloOverlap(_: number): any;
        haloRadius: number;
        setHaloRadius(_: number): any;
        haloWidth: number;
        setHaloWidth(_: number): any;
        striationContrast: number;
        setStriationContrast(_: number): any;
        striationStrength: number;
        setStriationStrength(_: number): any;
        time: number;
        setTime(_: number): any;
    }
    interface CILineOverlay extends CIFilter {
        contrast: number;
        setContrast(_: number): any;
        edgeIntensity: number;
        setEdgeIntensity(_: number): any;
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        NRNoiseLevel: number;
        setNRNoiseLevel(_: number): any;
        NRSharpness: number;
        setNRSharpness(_: number): any;
        threshold: number;
        setThreshold(_: number): any;
    }
    interface CILineScreen extends CIFilter {
        angle: number;
        setAngle(_: number): any;
        center: CGPoint;
        setCenter(_: CGPoint): any;
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        sharpness: number;
        setSharpness(_: number): any;
        width: number;
        setWidth(_: number): any;
    }
    interface CILinearGradient extends CIFilter {
        color0: CIColor;
        setColor0(_: CIColor): any;
        color1: CIColor;
        setColor1(_: CIColor): any;
        point0: CGPoint;
        setPoint0(_: CGPoint): any;
        point1: CGPoint;
        setPoint1(_: CGPoint): any;
    }
    interface CILinearToSRGBToneCurve extends CIFilter {
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
    }
    interface CIMaskToAlpha extends CIFilter {
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
    }
    interface CIMaskedVariableBlur extends CIFilter {
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        mask: CIImage;
        setMask(_: CIImage): any;
        radius: number;
        setRadius(_: number): any;
    }
    interface CIMaximumComponent extends CIFilter {
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
    }
    interface CIMedian extends CIFilter {
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
    }
    interface CIMeshGenerator extends CIFilter {
        color: CIColor;
        setColor(_: CIColor): any;
        mesh: any[];
        setMesh(_: any[]): any;
        width: number;
        setWidth(_: number): any;
    }
    interface CIMinimumComponent extends CIFilter {
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
    }
    interface CIMix extends CIFilter {
        amount: number;
        setAmount(_: number): any;
        backgroundImage: CIImage;
        setBackgroundImage(_: CIImage): any;
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
    }
    interface CIModTransition extends CITransitionFilter {
        angle: number;
        setAngle(_: number): any;
        center: CGPoint;
        setCenter(_: CGPoint): any;
        compression: number;
        setCompression(_: number): any;
        radius: number;
        setRadius(_: number): any;
    }
    interface CIMorphologyGradient extends CIFilter {
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        radius: number;
        setRadius(_: number): any;
    }
    interface CIMorphologyMaximum extends CIFilter {
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        radius: number;
        setRadius(_: number): any;
    }
    interface CIMorphologyMinimum extends CIFilter {
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        radius: number;
        setRadius(_: number): any;
    }
    interface CIMorphologyRectangleMaximum extends CIFilter {
        height: number;
        setHeight(_: number): any;
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        width: number;
        setWidth(_: number): any;
    }
    interface CIMorphologyRectangleMinimum extends CIFilter {
        height: number;
        setHeight(_: number): any;
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        width: number;
        setWidth(_: number): any;
    }
    interface CIMotionBlur extends CIFilter {
        angle: number;
        setAngle(_: number): any;
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        radius: number;
        setRadius(_: number): any;
    }
    interface CINoiseReduction extends CIFilter {
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        noiseLevel: number;
        setNoiseLevel(_: number): any;
        sharpness: number;
        setSharpness(_: number): any;
    }
    interface CIOpTile extends CIFilter {
        angle: number;
        setAngle(_: number): any;
        center: CGPoint;
        setCenter(_: CGPoint): any;
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        scale: number;
        setScale(_: number): any;
        width: number;
        setWidth(_: number): any;
    }
    interface CIPDF417BarcodeGenerator extends CIFilter {
        alwaysSpecifyCompaction: number;
        setAlwaysSpecifyCompaction(_: number): any;
        compactionMode: number;
        setCompactionMode(_: number): any;
        compactStyle: number;
        setCompactStyle(_: number): any;
        correctionLevel: number;
        setCorrectionLevel(_: number): any;
        dataColumns: number;
        setDataColumns(_: number): any;
        maxHeight: number;
        setMaxHeight(_: number): any;
        maxWidth: number;
        setMaxWidth(_: number): any;
        message: NSData;
        setMessage(_: NSData): any;
        minHeight: number;
        setMinHeight(_: number): any;
        minWidth: number;
        setMinWidth(_: number): any;
        preferredAspectRatio: number;
        setPreferredAspectRatio(_: number): any;
        rows: number;
        setRows(_: number): any;
    }
    class CIPDF417CodeDescriptor extends CIBarcodeDescriptor {
        static descriptorWithPayloadIsCompactRowCountColumnCount(payload: NSData, isCompact: boolean, rowCount: number, columnCount: number): CIPDF417CodeDescriptor;
        columnCount: number;
        errorCorrectedPayload: NSData;
        isCompact: boolean;
        rowCount: number;
        static createWithPayloadIsCompactRowCountColumnCount(payload: NSData, isCompact: boolean, rowCount: number, columnCount: number): CIPDF417CodeDescriptor;
    }
    interface CIPageCurlTransition extends CITransitionFilter {
        angle: number;
        setAngle(_: number): any;
        backsideImage: CIImage;
        setBacksideImage(_: CIImage): any;
        extent: CGRect;
        setExtent(_: CGRect): any;
        radius: number;
        setRadius(_: number): any;
        shadingImage: CIImage;
        setShadingImage(_: CIImage): any;
    }
    interface CIPageCurlWithShadowTransition extends CITransitionFilter {
        angle: number;
        setAngle(_: number): any;
        backsideImage: CIImage;
        setBacksideImage(_: CIImage): any;
        extent: CGRect;
        setExtent(_: CGRect): any;
        radius: number;
        setRadius(_: number): any;
        shadowAmount: number;
        setShadowAmount(_: number): any;
        shadowExtent: CGRect;
        setShadowExtent(_: CGRect): any;
        shadowSize: number;
        setShadowSize(_: number): any;
    }
    interface CIPaletteCentroid extends CIFilter {
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        paletteImage: CIImage;
        setPaletteImage(_: CIImage): any;
        perceptual: boolean;
        setPerceptual(_: boolean): any;
    }
    interface CIPalettize extends CIFilter {
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        paletteImage: CIImage;
        setPaletteImage(_: CIImage): any;
        perceptual: boolean;
        setPerceptual(_: boolean): any;
    }
    interface CIParallelogramTile extends CIFilter {
        acuteAngle: number;
        setAcuteAngle(_: number): any;
        angle: number;
        setAngle(_: number): any;
        center: CGPoint;
        setCenter(_: CGPoint): any;
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        width: number;
        setWidth(_: number): any;
    }
    interface CIPerspectiveCorrection extends CIFourCoordinateGeometryFilter {
        crop: boolean;
        setCrop(_: boolean): any;
    }
    interface CIPerspectiveRotate extends CIFilter {
        focalLength: number;
        setFocalLength(_: number): any;
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        pitch: number;
        setPitch(_: number): any;
        roll: number;
        setRoll(_: number): any;
        yaw: number;
        setYaw(_: number): any;
    }
    interface CIPerspectiveTile extends CIFilter {
        bottomLeft: CGPoint;
        setBottomLeft(_: CGPoint): any;
        bottomRight: CGPoint;
        setBottomRight(_: CGPoint): any;
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        topLeft: CGPoint;
        setTopLeft(_: CGPoint): any;
        topRight: CGPoint;
        setTopRight(_: CGPoint): any;
    }
    type CIPerspectiveTransform = CIFourCoordinateGeometryFilter;
    interface CIPerspectiveTransformWithExtent extends CIFourCoordinateGeometryFilter {
        extent: CGRect;
        setExtent(_: CGRect): any;
    }
    interface CIPhotoEffect extends CIFilter {
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
    }
    interface CIPixellate extends CIFilter {
        center: CGPoint;
        setCenter(_: CGPoint): any;
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        scale: number;
        setScale(_: number): any;
    }
    class CIPlugIn extends NSObject {
        static loadNonExecutablePlugIn(_: NSURL): void;
        static loadNonExecutablePlugIns(): void;
    }
    interface CIPlugInRegistration {
        load(_: any): boolean;
    }
    interface CIPointillize extends CIFilter {
        center: CGPoint;
        setCenter(_: CGPoint): any;
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        radius: number;
        setRadius(_: number): any;
    }
    class CIQRCodeDescriptor extends CIBarcodeDescriptor {
        static descriptorWithPayloadSymbolVersionMaskPatternErrorCorrectionLevel(payload: NSData, symbolVersion: number, maskPattern: number, errorCorrectionLevel: CIQRCodeErrorCorrectionLevel): CIQRCodeDescriptor;
        errorCorrectedPayload: NSData;
        errorCorrectionLevel: CIQRCodeErrorCorrectionLevel;
        maskPattern: number;
        symbolVersion: number;
        static createWithPayloadSymbolVersionMaskPatternErrorCorrectionLevel(payload: NSData, symbolVersion: number, maskPattern: number, errorCorrectionLevel: CIQRCodeErrorCorrectionLevel): CIQRCodeDescriptor;
    }
    class CIQRCodeFeature extends CIFeature {
        bottomLeft: CGPoint;
        bottomRight: CGPoint;
        messageString: string;
        symbolDescriptor: CIQRCodeDescriptor;
        topLeft: CGPoint;
        topRight: CGPoint;
    }
    interface CIQRCodeGenerator extends CIFilter {
        correctionLevel: string;
        setCorrectionLevel(_: string): any;
        message: NSData;
        setMessage(_: NSData): any;
    }
    interface CIRadialGradient extends CIFilter {
        center: CGPoint;
        setCenter(_: CGPoint): any;
        color0: CIColor;
        setColor0(_: CIColor): any;
        color1: CIColor;
        setColor1(_: CIColor): any;
        radius0: number;
        setRadius0(_: number): any;
        radius1: number;
        setRadius1(_: number): any;
    }
    type CIRandomGenerator = CIFilter;
    class CIRectangleFeature extends CIFeature {
        bottomLeft: CGPoint;
        bottomRight: CGPoint;
        topLeft: CGPoint;
        topRight: CGPoint;
    }
    class CIRenderDestination extends NSObject {
        alphaMode: CIRenderDestinationAlphaMode;
        setAlphaMode(_: CIRenderDestinationAlphaMode): any;
        blendKernel: CIBlendKernel;
        setBlendKernel(_: CIBlendKernel): any;
        blendsInDestinationColorSpace: boolean;
        setBlendsInDestinationColorSpace(_: boolean): any;
        isClamped: boolean;
        setClamped(_: boolean): any;
        colorSpace: any;
        setColorSpace(_: any): any;
        isDithered: boolean;
        setDithered(_: boolean): any;
        isFlipped: boolean;
        setFlipped(_: boolean): any;
        height: number;
        width: number;
        static createWithBitmapDataWidthHeightBytesPerRowFormat(bitmapData: any, width: number, height: number, bytesPerRow: number, format: number): CIRenderDestination;
        static createWithGLTextureTargetWidthHeight(GLTexture: number, target: number, width: number, height: number): CIRenderDestination;
        static createWithIOSurface(IOSurface: IOSurface): CIRenderDestination;
        static createWithPixelBuffer(pixelBuffer: any): CIRenderDestination;
    }
    class CIRenderInfo extends NSObject {
        kernelExecutionTime: number;
        passCount: number;
        pixelsProcessed: number;
    }
    class CIRenderTask extends NSObject {
        waitUntilCompletedAndReturnError(): CIRenderInfo;
    }
    interface CIRippleTransition extends CITransitionFilter {
        center: CGPoint;
        setCenter(_: CGPoint): any;
        extent: CGRect;
        setExtent(_: CGRect): any;
        scale: number;
        setScale(_: number): any;
        shadingImage: CIImage;
        setShadingImage(_: CIImage): any;
        width: number;
        setWidth(_: number): any;
    }
    interface CIRoundedRectangleGenerator extends CIFilter {
        color: CIColor;
        setColor(_: CIColor): any;
        extent: CGRect;
        setExtent(_: CGRect): any;
        radius: number;
        setRadius(_: number): any;
    }
    interface CISRGBToneCurveToLinear extends CIFilter {
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
    }
    interface CISaliencyMap extends CIFilter {
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
    }
    class CISampler extends NSObject {
        static samplerWithImageKeysAndValues(_: CIImage, keysAndValues: any): CISampler;
        definition: CIFilterShape;
        extent: CGRect;
        static createWithImage(image: CIImage): CISampler;
        static createWithImageOptions(image: CIImage, options?: Map<any, any>): CISampler;
    }
    interface CISepiaTone extends CIFilter {
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        intensity: number;
        setIntensity(_: number): any;
    }
    interface CIShadedMaterial extends CIFilter {
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        scale: number;
        setScale(_: number): any;
        shadingImage: CIImage;
        setShadingImage(_: CIImage): any;
    }
    interface CISharpenLuminance extends CIFilter {
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        radius: number;
        setRadius(_: number): any;
        sharpness: number;
        setSharpness(_: number): any;
    }
    interface CISixfoldReflectedTile extends CIFilter {
        angle: number;
        setAngle(_: number): any;
        center: CGPoint;
        setCenter(_: CGPoint): any;
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        width: number;
        setWidth(_: number): any;
    }
    interface CISixfoldRotatedTile extends CIFilter {
        angle: number;
        setAngle(_: number): any;
        center: CGPoint;
        setCenter(_: CGPoint): any;
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        width: number;
        setWidth(_: number): any;
    }
    interface CISmoothLinearGradient extends CIFilter {
        color0: CIColor;
        setColor0(_: CIColor): any;
        color1: CIColor;
        setColor1(_: CIColor): any;
        point0: CGPoint;
        setPoint0(_: CGPoint): any;
        point1: CGPoint;
        setPoint1(_: CGPoint): any;
    }
    interface CISpotColor extends CIFilter {
        centerColor1: CIColor;
        setCenterColor1(_: CIColor): any;
        centerColor2: CIColor;
        setCenterColor2(_: CIColor): any;
        centerColor3: CIColor;
        setCenterColor3(_: CIColor): any;
        closeness1: number;
        setCloseness1(_: number): any;
        closeness2: number;
        setCloseness2(_: number): any;
        closeness3: number;
        setCloseness3(_: number): any;
        contrast1: number;
        setContrast1(_: number): any;
        contrast2: number;
        setContrast2(_: number): any;
        contrast3: number;
        setContrast3(_: number): any;
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        replacementColor1: CIColor;
        setReplacementColor1(_: CIColor): any;
        replacementColor2: CIColor;
        setReplacementColor2(_: CIColor): any;
        replacementColor3: CIColor;
        setReplacementColor3(_: CIColor): any;
    }
    interface CISpotLight extends CIFilter {
        brightness: number;
        setBrightness(_: number): any;
        color: CIColor;
        setColor(_: CIColor): any;
        concentration: number;
        setConcentration(_: number): any;
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        lightPointsAt: CIVector;
        setLightPointsAt(_: CIVector): any;
        lightPosition: CIVector;
        setLightPosition(_: CIVector): any;
    }
    interface CIStarShineGenerator extends CIFilter {
        center: CGPoint;
        setCenter(_: CGPoint): any;
        color: CIColor;
        setColor(_: CIColor): any;
        crossAngle: number;
        setCrossAngle(_: number): any;
        crossOpacity: number;
        setCrossOpacity(_: number): any;
        crossScale: number;
        setCrossScale(_: number): any;
        crossWidth: number;
        setCrossWidth(_: number): any;
        epsilon: number;
        setEpsilon(_: number): any;
        radius: number;
        setRadius(_: number): any;
    }
    interface CIStraighten extends CIFilter {
        angle: number;
        setAngle(_: number): any;
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
    }
    interface CIStripesGenerator extends CIFilter {
        center: CGPoint;
        setCenter(_: CGPoint): any;
        color0: CIColor;
        setColor0(_: CIColor): any;
        color1: CIColor;
        setColor1(_: CIColor): any;
        sharpness: number;
        setSharpness(_: number): any;
        width: number;
        setWidth(_: number): any;
    }
    interface CISunbeamsGenerator extends CIFilter {
        center: CGPoint;
        setCenter(_: CGPoint): any;
        color: CIColor;
        setColor(_: CIColor): any;
        maxStriationRadius: number;
        setMaxStriationRadius(_: number): any;
        striationContrast: number;
        setStriationContrast(_: number): any;
        striationStrength: number;
        setStriationStrength(_: number): any;
        sunRadius: number;
        setSunRadius(_: number): any;
        time: number;
        setTime(_: number): any;
    }
    interface CISwipeTransition extends CITransitionFilter {
        angle: number;
        setAngle(_: number): any;
        color: CIColor;
        setColor(_: CIColor): any;
        extent: CGRect;
        setExtent(_: CGRect): any;
        opacity: number;
        setOpacity(_: number): any;
        width: number;
        setWidth(_: number): any;
    }
    interface CITemperatureAndTint extends CIFilter {
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        neutral: CIVector;
        setNeutral(_: CIVector): any;
        targetNeutral: CIVector;
        setTargetNeutral(_: CIVector): any;
    }
    class CITextFeature extends CIFeature {
        bottomLeft: CGPoint;
        bottomRight: CGPoint;
        subFeatures: any[];
        topLeft: CGPoint;
        topRight: CGPoint;
    }
    interface CITextImageGenerator extends CIFilter {
        fontName: string;
        setFontName(_: string): any;
        fontSize: number;
        setFontSize(_: number): any;
        scaleFactor: number;
        setScaleFactor(_: number): any;
        text: string;
        setText(_: string): any;
    }
    interface CIThermal extends CIFilter {
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
    }
    interface CIToneCurve extends CIFilter {
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        point0: CGPoint;
        setPoint0(_: CGPoint): any;
        point1: CGPoint;
        setPoint1(_: CGPoint): any;
        point2: CGPoint;
        setPoint2(_: CGPoint): any;
        point3: CGPoint;
        setPoint3(_: CGPoint): any;
        point4: CGPoint;
        setPoint4(_: CGPoint): any;
    }
    interface CITransitionFilter extends CIFilter {
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        targetImage: CIImage;
        setTargetImage(_: CIImage): any;
        time: number;
        setTime(_: number): any;
    }
    interface CITriangleKaleidoscope extends CIFilter {
        decay: number;
        setDecay(_: number): any;
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        point: CGPoint;
        setPoint(_: CGPoint): any;
        rotation: number;
        setRotation(_: number): any;
        size: number;
        setSize(_: number): any;
    }
    interface CITriangleTile extends CIFilter {
        angle: number;
        setAngle(_: number): any;
        center: CGPoint;
        setCenter(_: CGPoint): any;
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        width: number;
        setWidth(_: number): any;
    }
    interface CITwelvefoldReflectedTile extends CIFilter {
        angle: number;
        setAngle(_: number): any;
        center: CGPoint;
        setCenter(_: CGPoint): any;
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        width: number;
        setWidth(_: number): any;
    }
    interface CIUnsharpMask extends CIFilter {
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        intensity: number;
        setIntensity(_: number): any;
        radius: number;
        setRadius(_: number): any;
    }
    class CIVector extends NSObject {
        CGAffineTransformValue: CGAffineTransform;
        CGPointValue: CGPoint;
        CGRectValue: CGRect;
        W: number;
        X: number;
        Y: number;
        Z: number;
        count: number;
        stringRepresentation: string;
        static createWithCGAffineTransform(CGAffineTransform: CGAffineTransform): CIVector;
        static createWithCGPoint(CGPoint: CGPoint): CIVector;
        static createWithCGRect(CGRect: CGRect): CIVector;
        static createWithString(string: string): CIVector;
        static createWithValuesCount(values: number, count: number): CIVector;
        static createWithX(x: number): CIVector;
        static createWithXY(x: number, y: number): CIVector;
        static createWithXYZ(x: number, y: number, z: number): CIVector;
        static createWithXYZW(x: number, y: number, z: number, w: number): CIVector;
        valueAtIndex(at: number): number;
    }
    interface CIVibrance extends CIFilter {
        amount: number;
        setAmount(_: number): any;
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
    }
    interface CIVignette extends CIFilter {
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        intensity: number;
        setIntensity(_: number): any;
        radius: number;
        setRadius(_: number): any;
    }
    interface CIVignetteEffect extends CIFilter {
        center: CGPoint;
        setCenter(_: CGPoint): any;
        falloff: number;
        setFalloff(_: number): any;
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
        intensity: number;
        setIntensity(_: number): any;
        radius: number;
        setRadius(_: number): any;
    }
    class CIWarpKernel extends CIKernel {
        applyWithExtentRoiCallbackImageArguments(extent: CGRect, roiCallback: (p1: number, p2: CGRect) => CGRect, image: CIImage, arguments_?: any[]): CIImage;
    }
    interface CIWhitePointAdjust extends CIFilter {
        color: CIColor;
        setColor(_: CIColor): any;
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
    }
    interface CIXRay extends CIFilter {
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
    }
    interface CIZoomBlur extends CIFilter {
        amount: number;
        setAmount(_: number): any;
        center: CGPoint;
        setCenter(_: CGPoint): any;
        inputImage: CIImage;
        setInputImage(_: CIImage): any;
    }
    class NSAffineTransform extends NSObject {
        transformStruct: NSAffineTransformStruct;
        setTransformStruct(_: NSAffineTransformStruct): any;
        appendTransform(_: NSAffineTransform): void;
        concat(): void;
        static createWithTransform(transform: NSAffineTransform): NSAffineTransform;
        invert(): void;
        prependTransform(_: NSAffineTransform): void;
        rotateByDegrees(byDegrees: number): void;
        rotateByRadians(byRadians: number): void;
        scaleBy(by: number): void;
        scaleXByYBy(by: number, yBy: number): void;
        set(): void;
        transformBezierPath(_: NSBezierPath): NSBezierPath;
        transformPoint(_: CGPoint): CGPoint;
        transformSize(_: CGSize): CGSize;
        translateXByYBy(by: number, yBy: number): void;
    }
    class NSAppleEventDescriptor extends NSObject {
        static appleEventWithEventClassEventIDTargetDescriptorReturnIDTransactionID(withEventClass: number, eventID: number, targetDescriptor?: NSAppleEventDescriptor, returnID?: number, transactionID?: number): NSAppleEventDescriptor;
        static currentProcessDescriptor(): NSAppleEventDescriptor;
        static listDescriptor(): NSAppleEventDescriptor;
        static nullDescriptor(): NSAppleEventDescriptor;
        static recordDescriptor(): NSAppleEventDescriptor;
        aeDesc: AE.AEDataModel;
        booleanValue: boolean;
        data: NSData;
        dateValue: Date;
        descriptorType: number;
        doubleValue: number;
        enumCodeValue: number;
        eventClass: number;
        eventID: number;
        fileURLValue: NSURL;
        int32Value: number;
        isRecordDescriptor: boolean;
        numberOfItems: number;
        returnID: number;
        stringValue: string;
        transactionID: number;
        typeCodeValue: number;
        attributeDescriptorForKeyword(forKeyword: number): NSAppleEventDescriptor;
        coerceToDescriptorType(toDescriptorType: number): NSAppleEventDescriptor;
        descriptorAtIndex(_: number): NSAppleEventDescriptor;
        descriptorForKeyword(_: number): NSAppleEventDescriptor;
        static createWithListDescriptor(): NSAppleEventDescriptor;
        static createWithRecordDescriptor(): NSAppleEventDescriptor;
        static createWithAEDescNoCopy(AEDescNoCopy: AE.AEDataModel): NSAppleEventDescriptor;
        static createWithDescriptorTypeBytesLength(descriptorType: number, bytes?: any, length?: number): NSAppleEventDescriptor;
        static createWithDescriptorTypeData(descriptorType: number, data?: NSData): NSAppleEventDescriptor;
        static createWithEventClassEventIDTargetDescriptorReturnIDTransactionID(eventClass: number, eventID: number, targetDescriptor?: NSAppleEventDescriptor, returnID?: number, transactionID?: number): NSAppleEventDescriptor;
        insertDescriptorAtIndex(_: NSAppleEventDescriptor, at: number): void;
        keywordForDescriptorAtIndex(at: number): number;
        paramDescriptorForKeyword(forKeyword: number): NSAppleEventDescriptor;
        removeDescriptorAtIndex(at: number): void;
        removeDescriptorWithKeyword(withKeyword: number): void;
        removeParamDescriptorWithKeyword(withKeyword: number): void;
        sendEventWithOptionsTimeoutError(timeout: NSAppleEventDescriptor.SendOptions, error: number): NSAppleEventDescriptor;
        setAttributeDescriptorForKeyword(_: NSAppleEventDescriptor, forKeyword: number): void;
        setDescriptorForKeyword(_: NSAppleEventDescriptor, forKeyword: number): void;
        setParamDescriptorForKeyword(_: NSAppleEventDescriptor, forKeyword: number): void;
    }
    class NSAppleEventManager extends NSObject {
        static sharedAppleEventManager(): NSAppleEventManager;
        currentAppleEvent: NSAppleEventDescriptor;
        currentReplyAppleEvent: NSAppleEventDescriptor;
        appleEventForSuspensionID(forSuspensionID: any): NSAppleEventDescriptor;
        dispatchRawAppleEventWithRawReplyHandlerRefCon(_: AE.AEDataModel, withRawReply: AE.AEDataModel, handlerRefCon: any): number;
        removeEventHandlerForEventClassAndEventID(forEventClass: number, andEventID: number): void;
        replyAppleEventForSuspensionID(forSuspensionID: any): NSAppleEventDescriptor;
        resumeWithSuspensionID(withSuspensionID: any): void;
        setCurrentAppleEventAndReplyEventWithSuspensionID(_: any): void;
        setEventHandlerAndSelectorForEventClassAndEventID(_: any, andSelector: string, forEventClass: number, andEventID: number): void;
        suspendCurrentAppleEvent(): any;
    }
    class NSAppleScript extends NSObject {
        isCompiled: boolean;
        richTextSource: NSAttributedString;
        source: string;
        compileAndReturnError(_?: Map<string, any>): boolean;
        executeAndReturnError(_?: Map<string, any>): NSAppleEventDescriptor;
        executeAppleEventError(_: NSAppleEventDescriptor, error?: Map<string, any>): NSAppleEventDescriptor;
        static createWithContentsOfURLError(contentsOfURL: NSURL, error?: Map<string, any>): NSAppleScript;
        static createWithSource(source: string): NSAppleScript;
    }
    class NSArray<ObjectType> extends NSObject {
        static arrayWithObjects<ObjectType>(_: ObjectType): NSArray<ObjectType>;
        count: number;
        firstObject: ObjectType;
        lastObject: ObjectType;
        sortedArrayHint: NSData;
        addObserverToObjectsAtIndexesForKeyPathOptionsContext(_: NSObject, toObjectsAt: NSIndexSet, forKeyPath: string, options: NSKeyValueObservingOptions, context?: any): void;
        arrayByAddingObject(_: ObjectType): ObjectType[];
        arrayByAddingObjectsFromArray(from: ObjectType[]): ObjectType[];
        componentsJoinedByString(by: string): string;
        containsObject(_: ObjectType): boolean;
        descriptionWithLocale(withLocale?: any): string;
        descriptionWithLocaleIndent(withLocale?: any, indent?: number): string;
        enumerateObjectsWithAtOptionsUsing(at: NSIndexSet, options: NSEnumerationOptions, using: (p1: ObjectType, p2: number, p3: boolean) => void): void;
        enumerateObjects(_: (p1: ObjectType, p2: number, p3: boolean) => void): void;
        enumerateObjectsWithOptionsUsing(options: NSEnumerationOptions, using: (p1: ObjectType, p2: number, p3: boolean) => void): void;
        filteredArrayUsingPredicate(using: NSPredicate): ObjectType[];
        firstObjectCommonWithArray(with_: ObjectType[]): ObjectType;
        indexOfObject(of: ObjectType): number;
        indexOfObjectInRange(of: ObjectType, in_: NSRange): number;
        indexOfInSortedRangeOptionsUsingComparator(of: ObjectType, inSortedRange: NSRange, options: NSBinarySearchingOptions, usingComparator: (p1: any, p2: any) => ComparisonResult): number;
        indexOfObjectWithAtOptionsPassingTest(at: NSIndexSet, options: NSEnumerationOptions, passingTest: (p1: ObjectType, p2: number, p3: boolean) => boolean): number;
        indexOfObjectIdenticalTo(to: ObjectType): number;
        indexOfObjectIdenticalToInRange(to: ObjectType, in_: NSRange): number;
        indexOfObjectWithPassingTest(passingTest: (p1: ObjectType, p2: number, p3: boolean) => boolean): number;
        indexOfObjectWithOptionsPassingTest(options: NSEnumerationOptions, passingTest: (p1: ObjectType, p2: number, p3: boolean) => boolean): number;
        indexesOfObjectsWithAtOptionsPassingTest(at: NSIndexSet, options: NSEnumerationOptions, passingTest: (p1: ObjectType, p2: number, p3: boolean) => boolean): NSIndexSet;
        indexesOfObjectsWithPassingTest(passingTest: (p1: ObjectType, p2: number, p3: boolean) => boolean): NSIndexSet;
        indexesOfObjectsWithOptionsPassingTest(options: NSEnumerationOptions, passingTest: (p1: ObjectType, p2: number, p3: boolean) => boolean): NSIndexSet;
        isEqualToArray(to: ObjectType[]): boolean;
        objectAtIndex(at: number): ObjectType;
        objectEnumerator(): NSEnumerator<ObjectType>;
        objectsAtIndexes(at: NSIndexSet): ObjectType[];
        pathsMatchingExtensions(_: string[]): string[];
        removeObserverFromObjectsAtIndexesForKeyPath(_: NSObject, fromObjectsAt: NSIndexSet, forKeyPath: string): void;
        removeObserverFromObjectsAtIndexesForKeyPathContext(_: NSObject, fromObjectsAt: NSIndexSet, forKeyPath: string, context?: any): void;
        reverseObjectEnumerator(): NSEnumerator<ObjectType>;
        sortedArrayWithComparator(comparator: (p1: any, p2: any) => ComparisonResult): ObjectType[];
        sortedArrayUsingDescriptors(using: NSSortDescriptor[]): ObjectType[];
        sortedArrayContext(_?: (p1: ObjectType, p2: ObjectType, p3: any) => number, context?: any): ObjectType[];
        sortedArrayContextHint(_?: (p1: ObjectType, p2: ObjectType, p3: any) => number, context?: any, hint?: NSData): ObjectType[];
        sortedArrayUsingSelector(using: string): ObjectType[];
        sortedArrayWithOptionsUsingComparator(options: NSSortOptions, usingComparator: (p1: any, p2: any) => ComparisonResult): ObjectType[];
        subarrayWithRange(with_: NSRange): ObjectType[];
        writeToFileAtomically(toFile: string, atomically: boolean): boolean;
        writeToURLAtomically(to: NSURL, atomically: boolean): boolean;
        writeToURLError(error: NSURL): boolean;
    }
    class NSAssertionHandler extends NSObject {
        static currentHandler: NSAssertionHandler;
    }
    class NSAttributedString extends NSObject {
        containsAttachments: boolean;
        length: number;
        string: string;
        static textTypes: string[];
        static textUnfilteredTypes: string[];
        RTFDFileWrapperFromRangeDocumentAttributes(from: NSRange, documentAttributes: Map<string, any>): FileWrapper;
        RTFDFromRangeDocumentAttributes(from: NSRange, documentAttributes: Map<string, any>): NSData;
        RTFFromRangeDocumentAttributes(from: NSRange, documentAttributes: Map<string, any>): NSData;
        attributeAtIndexEffectiveRange(_: string, at: number, effectiveRange?: NSRange): any;
        attributeAtIndexLongestEffectiveRangeInRange(_: string, at: number, longestEffectiveRange?: NSRange, in_?: NSRange): any;
        attributedSubstringFromRange(from: NSRange): NSAttributedString;
        attributesAtIndexEffectiveRange(at: number, effectiveRange?: NSRange): Map<string, any>;
        attributesAtIndexLongestEffectiveRangeInRange(at: number, longestEffectiveRange?: NSRange, in_?: NSRange): Map<string, any>;
        boundingRectWithSizeOptions(with_: CGSize, options: NSString.DrawingOptions): CGRect;
        boundingRectWithSizeOptionsContext(with_: CGSize, options: NSString.DrawingOptions, context?: NSStringDrawingContext): CGRect;
        containsAttachmentsInRange(in_: NSRange): boolean;
        dataFromRangeDocumentAttributesError(documentAttributes: NSRange, error: Map<string, any>): NSData;
        docFormatFromRangeDocumentAttributes(from: NSRange, documentAttributes: Map<string, any>): NSData;
        doubleClickAtIndex(at: number): NSRange;
        drawAtPoint(at: CGPoint): void;
        drawInRect(in_: CGRect): void;
        drawWithRectOptions(with_: CGRect, options: NSString.DrawingOptions): void;
        drawWithRectOptionsContext(with_: CGRect, options: NSString.DrawingOptions, context?: NSStringDrawingContext): void;
        enumerateAttributeInOptionsUsing(_: string, in_: NSRange, options: NSAttributedString.EnumerationOptions, using?: (p1: any, p2: NSRange, p3: boolean) => void): void;
        enumerateAttributesWithInOptionsUsing(in_: NSRange, options: NSAttributedString.EnumerationOptions, using: (p1: Map<string, any>, p2: NSRange, p3: boolean) => void): void;
        fileWrapperFromRangeDocumentAttributesError(documentAttributes: NSRange, error: Map<string, any>): FileWrapper;
        fontAttributesInRange(in_: NSRange): Map<string, any>;
        static createWithAttributedString(attributedString: NSAttributedString): NSAttributedString;
        static createWithDataOptionsDocumentAttributes(data: NSData, options: Map<string, any>, documentAttributes?: Map<string, any>): NSAttributedString;
        static createWithDocFormatDocumentAttributes(docFormat: NSData, documentAttributes?: Map<string, any>): NSAttributedString;
        static createWithHtmlBaseURLDocumentAttributes(HTML: NSData, baseURL: NSURL, documentAttributes?: Map<string, any>): NSAttributedString;
        static createWithHtmlDocumentAttributes(HTML: NSData, documentAttributes?: Map<string, any>): NSAttributedString;
        static createWithHtmlOptionsDocumentAttributes(HTML: NSData, options: Map<string, any>, documentAttributes?: Map<string, any>): NSAttributedString;
        static createWithRtfDocumentAttributes(RTF: NSData, documentAttributes?: Map<string, any>): NSAttributedString;
        static createWithRtfdDocumentAttributes(RTFD: NSData, documentAttributes?: Map<string, any>): NSAttributedString;
        static createWithRTFDFileWrapperDocumentAttributes(RTFDFileWrapper: FileWrapper, documentAttributes?: Map<string, any>): NSAttributedString;
        static createWithString(string: string): NSAttributedString;
        static createWithStringAttributes(string: string, attributes?: Map<string, any>): NSAttributedString;
        static createWithUrlOptionsDocumentAttributes(URL: NSURL, options: Map<string, any>, documentAttributes?: Map<string, any>): NSAttributedString;
        isEqualToAttributedString(to: NSAttributedString): boolean;
        itemNumberInTextListAtIndex(in_: NSTextList, at: number): number;
        lineBreakBeforeIndexWithinRange(before: number, within: NSRange): number;
        lineBreakByHyphenatingBeforeIndexWithinRange(before: number, within: NSRange): number;
        nextWordFromIndexForward(from: number, forward: boolean): number;
        rangeOfTextBlockAtIndex(of: NSTextBlock, at: number): NSRange;
        rangeOfTextListAtIndex(of: NSTextList, at: number): NSRange;
        rangeOfTextTableAtIndex(of: NSTextTable, at: number): NSRange;
        rulerAttributesInRange(in_: NSRange): Map<string, any>;
        size(): CGSize;
    }
    class NSAutoreleasePool extends NSObject {
        static addObject(_: any): void;
        static showPools(): void;
        addObject(_: any): void;
        drain(): void;
    }
    class NSBackgroundActivityScheduler extends NSObject {
        identifier: string;
        interval: number;
        setInterval(_: number): any;
        qualityOfService: QualityOfService;
        setQualityOfService(_: QualityOfService): any;
        repeats: boolean;
        setRepeats(_: boolean): any;
        shouldDefer: boolean;
        tolerance: number;
        setTolerance(_: number): any;
        static createWithIdentifier(identifier: string): NSBackgroundActivityScheduler;
        invalidate(): void;
        schedule(_: (p1: (p1: NSBackgroundActivityScheduler.Result) => void) => void): void;
    }
    class BlockOperation extends Operation {
        static blockOperationWithBlock(_: () => void): BlockOperation;
        executionBlocks: () => void[];
        addExecutionBlock(_: () => void): void;
    }
    class Bundle extends NSObject {
        static URLForResourceWithExtensionSubdirectoryInBundleWithURL(forResource?: string, withExtension?: string, subdirectory?: string, in_?: NSURL): NSURL;
        static URLsForResourcesWithExtensionSubdirectoryInBundleWithURL(forResourcesWithExtension?: string, subdirectory?: string, in_?: NSURL): NSURL[];
        static pathForResourceOfTypeInDirectory(forResource?: string, ofType?: string, inDirectory?: string): string;
        static pathsForResourcesOfTypeInDirectory(forResourcesOfType?: string, inDirectory?: string): string[];
        static preferredLocalizationsFromArray(_: string[]): string[];
        static preferredLocalizationsFromArrayForPreferences(_: string[], forPreferences?: string[]): string[];
        appStoreReceiptURL: NSURL;
        builtInPlugInsPath: string;
        builtInPlugInsURL: NSURL;
        bundleIdentifier: string;
        bundlePath: string;
        bundleURL: NSURL;
        developmentLocalization: string;
        executableArchitectures: number[];
        executablePath: string;
        executableURL: NSURL;
        infoDictionary: Map<string, any>;
        isLoaded: boolean;
        localizations: string[];
        localizedInfoDictionary: Map<string, any>;
        preferredLocalizations: string[];
        principalClass: typeof NSObject;
        privateFrameworksPath: string;
        privateFrameworksURL: NSURL;
        resourcePath: string;
        resourceURL: NSURL;
        sharedFrameworksPath: string;
        sharedFrameworksURL: NSURL;
        sharedSupportPath: string;
        sharedSupportURL: NSURL;
        static allBundles: Bundle[];
        static allFrameworks: Bundle[];
        static mainBundle: Bundle;
        URLForAuxiliaryExecutable(forAuxiliaryExecutable: string): NSURL;
        URLForImageResource(_: string): NSURL;
        URLForResourceWithExtension(forResource?: string, withExtension?: string): NSURL;
        URLForResourceWithExtensionSubdirectory(forResource?: string, withExtension?: string, subdirectory?: string): NSURL;
        URLForResourceWithExtensionSubdirectoryLocalization(_?: string, withExtension?: string, subdirectory?: string, localization?: string): NSURL;
        URLsForResourcesWithExtensionSubdirectory(forResourcesWithExtension?: string, subdirectory?: string): NSURL[];
        URLsForResourcesWithExtensionSubdirectoryLocalization(forResourcesWithExtension?: string, subdirectory?: string, localization?: string): NSURL[];
        classNamed(_: string): typeof NSObject;
        contextHelpForKey(_: string): NSAttributedString;
        imageForResource(_: string): NSImage;
        static createWithPath(path: string): Bundle;
        static createWithUrl(URL: NSURL): Bundle;
        loadAndReturnError(): boolean;
        loadNibNamedOwnerTopLevelObjects(_: string, owner?: any, topLevelObjects?: any[]): boolean;
        localizedStringForKeyValueTable(_: string, value?: string, table?: string): string;
        objectForInfoDictionaryKey(forInfoDictionaryKey: string): any;
        pathForAuxiliaryExecutable(forAuxiliaryExecutable: string): string;
        pathForImageResource(_: string): string;
        pathForResourceOfType(forResource?: string, ofType?: string): string;
        pathForResourceOfTypeInDirectory(forResource?: string, ofType?: string, inDirectory?: string): string;
        pathForResourceOfTypeInDirectoryForLocalization(forResource?: string, ofType?: string, inDirectory?: string, forLocalization?: string): string;
        pathForSoundResource(_: string): string;
        pathsForResourcesOfTypeInDirectory(forResourcesOfType?: string, inDirectory?: string): string[];
        pathsForResourcesOfTypeInDirectoryForLocalization(forResourcesOfType?: string, inDirectory?: string, forLocalization?: string): string[];
        preflightAndReturnError(): boolean;
        unload(): boolean;
    }
    class ByteCountFormatter extends Formatter {
        static stringFromByteCountCountStyle(_: number, countStyle: ByteCountFormatter.CountStyle): string;
        static stringFromMeasurementWithCountStyle(_: NSMeasurement<NSUnitInformationStorage>, countStyle: ByteCountFormatter.CountStyle): string;
        isAdaptive: boolean;
        setAdaptive(_: boolean): any;
        allowedUnits: ByteCountFormatter.Units;
        setAllowedUnits(_: ByteCountFormatter.Units): any;
        allowsNonnumericFormatting: boolean;
        setAllowsNonnumericFormatting(_: boolean): any;
        countStyle: ByteCountFormatter.CountStyle;
        setCountStyle(_: ByteCountFormatter.CountStyle): any;
        formattingContext: Formatter.Context;
        setFormattingContext(_: Formatter.Context): any;
        includesActualByteCount: boolean;
        setIncludesActualByteCount(_: boolean): any;
        includesCount: boolean;
        setIncludesCount(_: boolean): any;
        includesUnit: boolean;
        setIncludesUnit(_: boolean): any;
        zeroPadsFractionDigits: boolean;
        setZeroPadsFractionDigits(_: boolean): any;
        stringFromByteCount(fromByteCount: number): string;
        stringFromMeasurement(_: NSMeasurement<NSUnitInformationStorage>): string;
    }
    class NSCache<KeyType, ObjectType> extends NSObject {
        countLimit: number;
        setCountLimit(_: number): any;
        delegate: NSCacheDelegate;
        setDelegate(_: NSCacheDelegate): any;
        evictsObjectsWithDiscardedContent: boolean;
        setEvictsObjectsWithDiscardedContent(_: boolean): any;
        name: string;
        setName(_: string): any;
        totalCostLimit: number;
        setTotalCostLimit(_: number): any;
        objectForKey(forKey: KeyType): ObjectType;
        removeAllObjects(): void;
        removeObjectForKey(forKey: KeyType): void;
        setObjectForKey(_: ObjectType, forKey: KeyType): void;
        setObjectForKeyCost(_: ObjectType, forKey: KeyType, cost: number): void;
    }
    interface NSCacheDelegate extends NSObject {
        cacheWillEvictObject?(_: NSCache<any, any>, willEvictObject: any): void;
    }
    class CachedURLResponse extends NSObject {
        data: NSData;
        response: URLResponse;
        storagePolicy: URLCache.StoragePolicy;
        userInfo: Map<any, any>;
        static createWithResponseData(response: URLResponse, data: NSData): CachedURLResponse;
        static createWithResponseDataUserInfoStoragePolicy(response: URLResponse, data: NSData, userInfo?: Map<any, any>, storagePolicy?: URLCache.StoragePolicy): CachedURLResponse;
    }
    class NSCalendar extends NSObject {
        AMSymbol: string;
        PMSymbol: string;
        calendarIdentifier: string;
        eraSymbols: string[];
        firstWeekday: number;
        setFirstWeekday(_: number): any;
        locale: NSLocale;
        setLocale(_: NSLocale): any;
        longEraSymbols: string[];
        minimumDaysInFirstWeek: number;
        setMinimumDaysInFirstWeek(_: number): any;
        monthSymbols: string[];
        quarterSymbols: string[];
        shortMonthSymbols: string[];
        shortQuarterSymbols: string[];
        shortStandaloneMonthSymbols: string[];
        shortStandaloneQuarterSymbols: string[];
        shortStandaloneWeekdaySymbols: string[];
        shortWeekdaySymbols: string[];
        standaloneMonthSymbols: string[];
        standaloneQuarterSymbols: string[];
        standaloneWeekdaySymbols: string[];
        timeZone: NSTimeZone;
        setTimeZone(_: NSTimeZone): any;
        veryShortMonthSymbols: string[];
        veryShortStandaloneMonthSymbols: string[];
        veryShortStandaloneWeekdaySymbols: string[];
        veryShortWeekdaySymbols: string[];
        weekdaySymbols: string[];
        static autoupdatingCurrentCalendar: NSCalendar;
        static currentCalendar: NSCalendar;
        compareDateToDateToUnitGranularity(_: Date, to: Date, toUnitGranularity: NSCalendar.Unit): ComparisonResult;
        componentFromDate(_: NSCalendar.Unit, from: Date): number;
        componentsFromDate(_: NSCalendar.Unit, from: Date): NSDateComponents;
        componentsFromDateToDateOptions(_: NSCalendar.Unit, from: Date, to: Date, options: NSCalendar.Options): NSDateComponents;
        componentsFromDateComponentsToDateComponentsOptions(_: NSCalendar.Unit, from: NSDateComponents, to: NSDateComponents, options: NSCalendar.Options): NSDateComponents;
        componentsInTimeZoneFromDate(in_: NSTimeZone, from: Date): NSDateComponents;
        dateMatchesComponents(_: Date, matchesComponents: NSDateComponents): boolean;
        dateByAddingComponentsToDateOptions(byAdding: NSDateComponents, to: Date, options: NSCalendar.Options): Date;
        dateByAddingUnitValueToDateOptions(byAdding: NSCalendar.Unit, value: number, to: Date, options: NSCalendar.Options): Date;
        dateBySettingHourMinuteSecondOfDateOptions(bySettingHour: number, minute: number, second: number, of: Date, options: NSCalendar.Options): Date;
        dateBySettingUnitValueOfDateOptions(bySettingUnit: NSCalendar.Unit, value: number, of: Date, options: NSCalendar.Options): Date;
        dateFromComponents(from: NSDateComponents): Date;
        dateWithEraYearMonthDayHourMinuteSecondNanosecond(era: number, year: number, month: number, day: number, hour: number, minute: number, second: number, nanosecond: number): Date;
        dateWithEraYearForWeekOfYearWeekOfYearWeekdayHourMinuteSecondNanosecond(era: number, yearForWeekOfYear: number, weekOfYear: number, weekday: number, hour: number, minute: number, second: number, nanosecond: number): Date;
        enumerateDatesWithStartingAfterMatchingOptionsUsing(startingAfter: Date, matching: NSDateComponents, options: NSCalendar.Options, using?: (p1: Date, p2: boolean, p3: boolean) => void): void;
        getEraYearMonthDayFromDate(_?: number, year?: number, month?: number, day?: number, from?: Date): void;
        getEraYearForWeekOfYearWeekOfYearWeekdayFromDate(_?: number, yearForWeekOfYear?: number, weekOfYear?: number, weekday?: number, from?: Date): void;
        getHourMinuteSecondNanosecondFromDate(_?: number, minute?: number, second?: number, nanosecond?: number, from?: Date): void;
        static createWithCalendarIdentifier(calendarIdentifier: string): NSCalendar;
        isDateEqualToDateToUnitGranularity(_: Date, equalTo: Date, toUnitGranularity: NSCalendar.Unit): boolean;
        isDateInSameDayAsDate(_: Date, inSameDayAs: Date): boolean;
        isDateInToday(_: Date): boolean;
        isDateInTomorrow(_: Date): boolean;
        isDateInWeekend(_: Date): boolean;
        isDateInYesterday(_: Date): boolean;
        maximumRangeOfUnit(of: NSCalendar.Unit): NSRange;
        minimumRangeOfUnit(of: NSCalendar.Unit): NSRange;
        nextDateAfterDateMatchingComponentsOptions(after: Date, matching: NSDateComponents, options: NSCalendar.Options): Date;
        nextDateAfterDateMatchingHourMinuteSecondOptions(after: Date, matchingHour: number, minute: number, second: number, options: NSCalendar.Options): Date;
        nextDateAfterDateMatchingUnitValueOptions(after: Date, matching: NSCalendar.Unit, value: number, options: NSCalendar.Options): Date;
        nextWeekendStartDateIntervalOptionsAfterDate(_?: Date, interval?: number, options?: NSCalendar.Options, after?: Date): boolean;
        ordinalityOfUnitInUnitForDate(of: NSCalendar.Unit, in_: NSCalendar.Unit, for_: Date): number;
        rangeOfUnitInUnitForDate(of: NSCalendar.Unit, in_: NSCalendar.Unit, for_: Date): NSRange;
        rangeOfUnitStartDateIntervalForDate(of: NSCalendar.Unit, start?: Date, interval?: number, for_?: Date): boolean;
        rangeOfWeekendStartDateIntervalContainingDate(ofWeekendStart?: Date, interval?: number, containing?: Date): boolean;
        startOfDayForDate(for_: Date): Date;
    }
    class NSCharacterSet extends NSObject {
        bitmapRepresentation: NSData;
        invertedSet: NSCharacterSet;
        static URLFragmentAllowedCharacterSet: NSCharacterSet;
        static URLHostAllowedCharacterSet: NSCharacterSet;
        static URLPasswordAllowedCharacterSet: NSCharacterSet;
        static URLPathAllowedCharacterSet: NSCharacterSet;
        static URLQueryAllowedCharacterSet: NSCharacterSet;
        static URLUserAllowedCharacterSet: NSCharacterSet;
        static alphanumericCharacterSet: NSCharacterSet;
        static capitalizedLetterCharacterSet: NSCharacterSet;
        static controlCharacterSet: NSCharacterSet;
        static decimalDigitCharacterSet: NSCharacterSet;
        static decomposableCharacterSet: NSCharacterSet;
        static illegalCharacterSet: NSCharacterSet;
        static letterCharacterSet: NSCharacterSet;
        static lowercaseLetterCharacterSet: NSCharacterSet;
        static newlineCharacterSet: NSCharacterSet;
        static nonBaseCharacterSet: NSCharacterSet;
        static punctuationCharacterSet: NSCharacterSet;
        static symbolCharacterSet: NSCharacterSet;
        static uppercaseLetterCharacterSet: NSCharacterSet;
        static whitespaceAndNewlineCharacterSet: NSCharacterSet;
        static whitespaceCharacterSet: NSCharacterSet;
        characterIsMember(_: string): boolean;
        hasMemberInPlane(_: number): boolean;
        isSupersetOfSet(of: NSCharacterSet): boolean;
        longCharacterIsMember(_: number): boolean;
    }
    class NSClassDescription extends NSObject {
        static invalidateClassDescriptionCache(): void;
        static registerClassDescriptionForClass(_: NSClassDescription, for_: typeof NSObject): void;
    }
    class NSCloneCommand extends NSScriptCommand {
        keySpecifier: NSScriptObjectSpecifier;
        setReceiversSpecifier(_?: NSScriptObjectSpecifier): void;
    }
    class NSCloseCommand extends NSScriptCommand {
        saveOptions: NSSaveOptions;
    }
    class NSCoder extends NSObject {
        allowedClasses: NSSet<typeof NSObject>;
        allowsKeyedCoding: boolean;
        decodingFailurePolicy: NSCoder.DecodingFailurePolicy;
        error: NSError;
        requiresSecureCoding: boolean;
        systemVersion: number;
        containsValueForKey(forKey: string): boolean;
        decodeArrayOfObjCTypeCountAt(ofObjCType: string, count: number, at: any): void;
        decodeBoolForKey(forKey: string): boolean;
        decodeBytesForKeyReturnedLength(forKey: string, returnedLength?: number): string;
        decodeBytesWithReturnedLength(withReturnedLength: number): any;
        decodeCMTimeForKey(forKey: string): CMTime;
        decodeCMTimeMappingForKey(forKey: string): CMTimeMapping;
        decodeCMTimeRangeForKey(forKey: string): CMTimeRange;
        decodeDataObject(): NSData;
        decodeDoubleForKey(forKey: string): number;
        decodeFloatForKey(forKey: string): number;
        decodeInt32ForKey(forKey: string): number;
        decodeInt64ForKey(forKey: string): number;
        decodeIntForKey(forKey: string): number;
        decodeIntegerForKey(forKey: string): number;
        decodeObject(): any;
        decodeObjectForKey(forKey: string): any;
        decodePoint(): CGPoint;
        decodePointForKey(forKey: string): CGPoint;
        decodePropertyList(): any;
        decodePropertyListForKey(forKey: string): any;
        decodeRect(): CGRect;
        decodeRectForKey(forKey: string): CGRect;
        decodeSize(): CGSize;
        decodeSizeForKey(forKey: string): CGSize;
        decodeValueOfObjCTypeAt(ofObjCType: string, at: any): void;
        decodeValueOfObjCTypeAtSize(ofObjCType: string, at: any, size: number): void;
        encodeArrayOfObjCTypeCountAt(ofObjCType: string, count: number, at: any): void;
        encodeBoolForKey(_: boolean, forKey: string): void;
        encodeBycopyObject(_?: any): void;
        encodeByrefObject(_?: any): void;
        encodeBytesLength(_?: any, length?: number): void;
        encodeBytesLengthForKey(_?: string, length?: number, forKey?: string): void;
        encodeCMTimeForKey(_: CMTime, forKey: string): void;
        encodeCMTimeMappingForKey(_: CMTimeMapping, forKey: string): void;
        encodeCMTimeRangeForKey(_: CMTimeRange, forKey: string): void;
        encodeConditionalObject(_?: any): void;
        encodeConditionalObjectForKey(_?: any, forKey?: string): void;
        encodeDataObject(_: NSData): void;
        encodeDoubleForKey(_: number, forKey: string): void;
        encodeFloatForKey(_: number, forKey: string): void;
        encodeInt32ForKey(_: number, forKey: string): void;
        encodeInt64ForKey(_: number, forKey: string): void;
        encodeIntForKey(_: number, forKey: string): void;
        encodeIntegerForKey(_: number, forKey: string): void;
        encodeObject(_?: any): void;
        encodeObjectForKey(_?: any, forKey?: string): void;
        encodePoint(_: CGPoint): void;
        encodePointForKey(_: CGPoint, forKey: string): void;
        encodePropertyList(_: any): void;
        encodeRect(_: CGRect): void;
        encodeRectForKey(_: CGRect, forKey: string): void;
        encodeRootObject(_: any): void;
        encodeSize(_: CGSize): void;
        encodeSizeForKey(_: CGSize, forKey: string): void;
        encodeValueOfObjCTypeAt(ofObjCType: string, at: any): void;
        failWithError(_: NSError): void;
        versionForClassName(forClassName: string): number;
    }
    interface NSCoding {
        encodeWithCoder(with_: NSCoder): void;
    }
    class NSComparisonPredicate extends NSPredicate {
        comparisonPredicateModifier: NSComparisonPredicate.Modifier;
        customSelector: string;
        leftExpression: NSExpression;
        options: NSComparisonPredicate.Options;
        predicateOperatorType: NSComparisonPredicate.Operator;
        rightExpression: NSExpression;
        static createWithLeftExpressionRightExpressionCustomSelector(leftExpression: NSExpression, rightExpression: NSExpression, customSelector: string): NSComparisonPredicate;
        static createWithLeftExpressionRightExpressionModifierTypeOptions(leftExpression: NSExpression, rightExpression: NSExpression, modifier: NSComparisonPredicate.Modifier, type: NSComparisonPredicate.Operator, options: NSComparisonPredicate.Options): NSComparisonPredicate;
    }
    class NSCompoundPredicate extends NSPredicate {
        compoundPredicateType: NSCompoundPredicate.LogicalType;
        subpredicates: any[];
        static createWithTypeSubpredicates(type: NSCompoundPredicate.LogicalType, subpredicates: NSPredicate[]): NSCompoundPredicate;
    }
    class NSCondition extends NSObject {
        name: string;
        setName(_: string): any;
        broadcast(): void;
        signal(): void;
        wait(): void;
        waitUntilDate(until: Date): boolean;
    }
    class NSConditionLock extends NSObject {
        condition: number;
        name: string;
        setName(_: string): any;
        static createWithCondition(condition: number): NSConditionLock;
        lockBeforeDate(before: Date): boolean;
        lockWhenCondition(whenCondition: number): void;
        lockWhenConditionBeforeDate(whenCondition: number, before: Date): boolean;
        tryLock(): boolean;
        tryLockWhenCondition(whenCondition: number): boolean;
        unlockWithCondition(withCondition: number): void;
    }
    interface NSCopying {
    }
    class NSCountCommand extends NSScriptCommand {
    }
    class NSCountedSet<ObjectType> extends NSMutableSet<ObjectType> {
        countForObject(for_: ObjectType): number;
    }
    class NSCreateCommand extends NSScriptCommand {
        createClassDescription: NSScriptClassDescription;
        resolvedKeyDictionary: Map<string, any>;
    }
    class NSData extends NSObject {
        static dataWithContentsOfFileOptionsError(options: string, error: NSData.ReadingOptions): NSData;
        static dataWithContentsOfURLOptionsError(options: NSURL, error: NSData.ReadingOptions): NSData;
        bytes: any;
        length: number;
        base64EncodedDataWithOptions(options: NSData.Base64EncodingOptions): NSData;
        base64EncodedStringWithOptions(options: NSData.Base64EncodingOptions): string;
        compressedDataUsingAlgorithmError(using: NSData.CompressionAlgorithm): NSData;
        decompressedDataUsingAlgorithmError(using: NSData.CompressionAlgorithm): NSData;
        enumerateBytes(_: (p1: any, p2: NSRange, p3: boolean) => void): void;
        getBytesLength(_: any, length: number): void;
        getBytesRange(_: any, range: NSRange): void;
        static createWithBase64EncodedDataOptions(base64EncodedData: NSData, options: NSData.Base64DecodingOptions): NSData;
        static createWithBase64EncodedStringOptions(base64EncodedString: string, options: NSData.Base64DecodingOptions): NSData;
        static createWithBytesLength(bytes?: any, length?: number): NSData;
        static createWithBytesNoCopyLength(bytesNoCopy: any, length: number): NSData;
        static createWithBytesNoCopyLengthDeallocator(bytesNoCopy: any, length: number, deallocator?: (p1: any, p2: number) => void): NSData;
        static createWithBytesNoCopyLengthFreeWhenDone(bytesNoCopy: any, length: number, freeWhenDone: boolean): NSData;
        static createWithContentsOfFile(contentsOfFile: string): NSData;
        static createWithContentsOfFileOptions(contentsOfFile: string, options: NSData.ReadingOptions): NSData;
        static createWithContentsOfURL(contentsOfURL: NSURL): NSData;
        static createWithContentsOfURLOptions(contentsOfURL: NSURL, options: NSData.ReadingOptions): NSData;
        static createWithData(data: NSData): NSData;
        isEqualToData(to: NSData): boolean;
        rangeOfDataOptionsRange(of: NSData, options: NSData.SearchOptions, in_: NSRange): NSRange;
        subdataWithRange(with_: NSRange): NSData;
        writeToFileAtomically(toFile: string, atomically: boolean): boolean;
        writeToFileOptionsError(options: string, error: NSData.WritingOptions): boolean;
        writeToURLAtomically(to: NSURL, atomically: boolean): boolean;
        writeToURLOptionsError(options: NSURL, error: NSData.WritingOptions): boolean;
    }
    class NSDataDetector extends NSRegularExpression {
        static dataDetectorWithTypesError(error: number): NSDataDetector;
        checkingTypes: number;
        static createWithTypes(types: number): NSDataDetector;
    }
    class NSDate extends NSObject {
        timeIntervalSince1970: number;
        timeIntervalSinceNow: number;
        static distantFuture: Date;
        static distantPast: Date;
        static now: Date;
        static timeIntervalSinceReferenceDate: number;
        compare(_: Date): ComparisonResult;
        dateByAddingTimeInterval(_: number): NSDate;
        descriptionWithLocale(with_?: any): string;
        earlierDate(_: Date): Date;
        static createWithTimeIntervalSinceDate(timeInterval: number, sinceDate: Date): NSDate;
        static createWithTimeIntervalSince1970(timeIntervalSince1970: number): NSDate;
        static createWithTimeIntervalSinceNow(timeIntervalSinceNow: number): NSDate;
        static createWithTimeIntervalSinceReferenceDate(timeIntervalSinceReferenceDate: number): NSDate;
        isEqualToDate(to: Date): boolean;
        laterDate(_: Date): Date;
        timeIntervalSinceDate(_: Date): number;
    }
    class NSDateComponents extends NSObject {
        calendar: NSCalendar;
        setCalendar(_: NSCalendar): any;
        date: Date;
        day: number;
        setDay(_: number): any;
        era: number;
        setEra(_: number): any;
        hour: number;
        setHour(_: number): any;
        isLeapMonth: boolean;
        setLeapMonth(_: boolean): any;
        minute: number;
        setMinute(_: number): any;
        month: number;
        setMonth(_: number): any;
        nanosecond: number;
        setNanosecond(_: number): any;
        quarter: number;
        setQuarter(_: number): any;
        second: number;
        setSecond(_: number): any;
        timeZone: NSTimeZone;
        setTimeZone(_: NSTimeZone): any;
        isValidDate: boolean;
        weekOfMonth: number;
        setWeekOfMonth(_: number): any;
        weekOfYear: number;
        setWeekOfYear(_: number): any;
        weekday: number;
        setWeekday(_: number): any;
        weekdayOrdinal: number;
        setWeekdayOrdinal(_: number): any;
        year: number;
        setYear(_: number): any;
        yearForWeekOfYear: number;
        setYearForWeekOfYear(_: number): any;
        isValidDateInCalendar(in_: NSCalendar): boolean;
        setValueForComponent(_: number, forComponent: NSCalendar.Unit): void;
        valueForComponent(forComponent: NSCalendar.Unit): number;
    }
    class DateComponentsFormatter extends Formatter {
        static localizedStringFromDateComponentsUnitsStyle(_: NSDateComponents, unitsStyle: DateComponentsFormatter.UnitsStyle): string;
        allowedUnits: NSCalendar.Unit;
        setAllowedUnits(_: NSCalendar.Unit): any;
        allowsFractionalUnits: boolean;
        setAllowsFractionalUnits(_: boolean): any;
        calendar: NSCalendar;
        setCalendar(_: NSCalendar): any;
        collapsesLargestUnit: boolean;
        setCollapsesLargestUnit(_: boolean): any;
        formattingContext: Formatter.Context;
        setFormattingContext(_: Formatter.Context): any;
        includesApproximationPhrase: boolean;
        setIncludesApproximationPhrase(_: boolean): any;
        includesTimeRemainingPhrase: boolean;
        setIncludesTimeRemainingPhrase(_: boolean): any;
        maximumUnitCount: number;
        setMaximumUnitCount(_: number): any;
        referenceDate: Date;
        setReferenceDate(_: Date): any;
        unitsStyle: DateComponentsFormatter.UnitsStyle;
        setUnitsStyle(_: DateComponentsFormatter.UnitsStyle): any;
        zeroFormattingBehavior: DateComponentsFormatter.ZeroFormattingBehavior;
        setZeroFormattingBehavior(_: DateComponentsFormatter.ZeroFormattingBehavior): any;
        stringFromDateToDate(_: Date, toDate: Date): string;
        stringFromDateComponents(_: NSDateComponents): string;
        stringFromTimeInterval(from: number): string;
    }
    class DateFormatter extends Formatter {
        static dateFormatFromTemplateOptionsLocale(_: string, options: number, locale?: NSLocale): string;
        static localizedStringFromDateDateStyleTimeStyle(from: Date, dateStyle: DateFormatter.Style, timeStyle: DateFormatter.Style): string;
        AMSymbol: string;
        setAMSymbol(_: string): any;
        PMSymbol: string;
        setPMSymbol(_: string): any;
        calendar: NSCalendar;
        setCalendar(_: NSCalendar): any;
        dateFormat: string;
        setDateFormat(_: string): any;
        dateStyle: DateFormatter.Style;
        setDateStyle(_: DateFormatter.Style): any;
        defaultDate: Date;
        setDefaultDate(_: Date): any;
        doesRelativeDateFormatting: boolean;
        setDoesRelativeDateFormatting(_: boolean): any;
        eraSymbols: string[];
        setEraSymbols(_: string[]): any;
        formatterBehavior: DateFormatter.Behavior;
        setFormatterBehavior(_: DateFormatter.Behavior): any;
        formattingContext: Formatter.Context;
        setFormattingContext(_: Formatter.Context): any;
        generatesCalendarDates: boolean;
        setGeneratesCalendarDates(_: boolean): any;
        gregorianStartDate: Date;
        setGregorianStartDate(_: Date): any;
        isLenient: boolean;
        setLenient(_: boolean): any;
        locale: NSLocale;
        setLocale(_: NSLocale): any;
        longEraSymbols: string[];
        setLongEraSymbols(_: string[]): any;
        monthSymbols: string[];
        setMonthSymbols(_: string[]): any;
        quarterSymbols: string[];
        setQuarterSymbols(_: string[]): any;
        shortMonthSymbols: string[];
        setShortMonthSymbols(_: string[]): any;
        shortQuarterSymbols: string[];
        setShortQuarterSymbols(_: string[]): any;
        shortStandaloneMonthSymbols: string[];
        setShortStandaloneMonthSymbols(_: string[]): any;
        shortStandaloneQuarterSymbols: string[];
        setShortStandaloneQuarterSymbols(_: string[]): any;
        shortStandaloneWeekdaySymbols: string[];
        setShortStandaloneWeekdaySymbols(_: string[]): any;
        shortWeekdaySymbols: string[];
        setShortWeekdaySymbols(_: string[]): any;
        standaloneMonthSymbols: string[];
        setStandaloneMonthSymbols(_: string[]): any;
        standaloneQuarterSymbols: string[];
        setStandaloneQuarterSymbols(_: string[]): any;
        standaloneWeekdaySymbols: string[];
        setStandaloneWeekdaySymbols(_: string[]): any;
        timeStyle: DateFormatter.Style;
        setTimeStyle(_: DateFormatter.Style): any;
        timeZone: NSTimeZone;
        setTimeZone(_: NSTimeZone): any;
        twoDigitStartDate: Date;
        setTwoDigitStartDate(_: Date): any;
        veryShortMonthSymbols: string[];
        setVeryShortMonthSymbols(_: string[]): any;
        veryShortStandaloneMonthSymbols: string[];
        setVeryShortStandaloneMonthSymbols(_: string[]): any;
        veryShortStandaloneWeekdaySymbols: string[];
        setVeryShortStandaloneWeekdaySymbols(_: string[]): any;
        veryShortWeekdaySymbols: string[];
        setVeryShortWeekdaySymbols(_: string[]): any;
        weekdaySymbols: string[];
        setWeekdaySymbols(_: string[]): any;
        static defaultFormatterBehavior: DateFormatter.Behavior;
        setDefaultFormatterBehavior(_: DateFormatter.Behavior): any;
        dateFromString(_: string): Date;
        getObjectValueForStringRangeError(forString?: any, range?: string, error?: NSRange): boolean;
        setLocalizedDateFormatFromTemplate(_: string): void;
        stringFromDate(_: Date): string;
    }
    class NSDateInterval extends NSObject {
        duration: number;
        endDate: Date;
        startDate: Date;
        compare(_: NSDateInterval): ComparisonResult;
        containsDate(_: Date): boolean;
        static createWithStartDateDuration(startDate: Date, duration: number): NSDateInterval;
        static createWithStartDateEndDate(startDate: Date, endDate: Date): NSDateInterval;
        intersectionWithDateInterval(with_: NSDateInterval): NSDateInterval;
        intersectsDateInterval(_: NSDateInterval): boolean;
        isEqualToDateInterval(to: NSDateInterval): boolean;
    }
    class DateIntervalFormatter extends Formatter {
        calendar: NSCalendar;
        setCalendar(_: NSCalendar): any;
        dateStyle: DateIntervalFormatter.Style;
        setDateStyle(_: DateIntervalFormatter.Style): any;
        dateTemplate: string;
        setDateTemplate(_: string): any;
        locale: NSLocale;
        setLocale(_: NSLocale): any;
        timeStyle: DateIntervalFormatter.Style;
        setTimeStyle(_: DateIntervalFormatter.Style): any;
        timeZone: NSTimeZone;
        setTimeZone(_: NSTimeZone): any;
        stringFromDateToDate(_: Date, toDate: Date): string;
        stringFromDateInterval(_: NSDateInterval): string;
    }
    class NSDecimalNumber extends NSNumber {
        static defaultBehavior: NSDecimalNumberBehaviors;
        setDefaultBehavior(_: NSDecimalNumberBehaviors): any;
        static maximumDecimalNumber: NSDecimalNumber;
        static minimumDecimalNumber: NSDecimalNumber;
        static notANumber: NSDecimalNumber;
        static one: NSDecimalNumber;
        static zero: NSDecimalNumber;
        decimalNumberByAdding(_: NSDecimalNumber): NSDecimalNumber;
        decimalNumberByAddingWithBehavior(_: NSDecimalNumber, withBehavior?: NSDecimalNumberBehaviors): NSDecimalNumber;
        decimalNumberByDividingBy(by: NSDecimalNumber): NSDecimalNumber;
        decimalNumberByDividingByWithBehavior(by: NSDecimalNumber, withBehavior?: NSDecimalNumberBehaviors): NSDecimalNumber;
        decimalNumberByMultiplyingBy(by: NSDecimalNumber): NSDecimalNumber;
        decimalNumberByMultiplyingByWithBehavior(by: NSDecimalNumber, withBehavior?: NSDecimalNumberBehaviors): NSDecimalNumber;
        decimalNumberByMultiplyingByPowerOf10(byPowerOf10: number): NSDecimalNumber;
        decimalNumberByMultiplyingByPowerOf10WithBehavior(byPowerOf10: number, withBehavior?: NSDecimalNumberBehaviors): NSDecimalNumber;
        decimalNumberByRaisingToPower(toPower: number): NSDecimalNumber;
        decimalNumberByRaisingToPowerWithBehavior(toPower: number, withBehavior?: NSDecimalNumberBehaviors): NSDecimalNumber;
        decimalNumberByRoundingAccordingToBehavior(accordingToBehavior?: NSDecimalNumberBehaviors): NSDecimalNumber;
        decimalNumberBySubtracting(_: NSDecimalNumber): NSDecimalNumber;
        decimalNumberBySubtractingWithBehavior(_: NSDecimalNumber, withBehavior?: NSDecimalNumberBehaviors): NSDecimalNumber;
        static createWithDecimal(decimal: number): NSDecimalNumber;
        static createWithMantissaExponentIsNegative(mantissa: number, exponent: number, isNegative: boolean): NSDecimalNumber;
        static createWithString(string?: string): NSDecimalNumber;
        static createWithStringLocale(string?: string, locale?: any): NSDecimalNumber;
    }
    interface NSDecimalNumberBehaviors {
        exceptionDuringOperationErrorLeftOperandRightOperand(_: string, error: NSDecimalNumber.CalculationError, leftOperand: NSDecimalNumber, rightOperand?: NSDecimalNumber): NSDecimalNumber;
        roundingMode(): NSDecimalNumber.RoundingMode;
        scale(): number;
    }
    class NSDecimalNumberHandler extends NSObject {
        static decimalNumberHandlerWithRoundingModeScaleRaiseOnExactnessRaiseOnOverflowRaiseOnUnderflowRaiseOnDivideByZero(roundingMode: NSDecimalNumber.RoundingMode, scale: number, raiseOnExactness: boolean, raiseOnOverflow: boolean, raiseOnUnderflow: boolean, raiseOnDivideByZero: boolean): NSDecimalNumberHandler;
        static defaultDecimalNumberHandler: NSDecimalNumberHandler;
        static createWithRoundingModeScaleRaiseOnExactnessRaiseOnOverflowRaiseOnUnderflowRaiseOnDivideByZero(roundingMode: NSDecimalNumber.RoundingMode, scale: number, raiseOnExactness: boolean, raiseOnOverflow: boolean, raiseOnUnderflow: boolean, raiseOnDivideByZero: boolean): NSDecimalNumberHandler;
    }
    class NSDeleteCommand extends NSScriptCommand {
        keySpecifier: NSScriptObjectSpecifier;
        setReceiversSpecifier(_?: NSScriptObjectSpecifier): void;
    }
    class NSDictionary<KeyType, ObjectType> extends NSObject {
        static sharedKeySetWithForKeys<KeyType>(forKeys: KeyType[]): any;
        allKeys: KeyType[];
        allValues: ObjectType[];
        count: number;
        descriptionInStringsFileFormat: string;
        allKeysForObject(for_: ObjectType): KeyType[];
        countByEnumeratingWithStateObjectsCount(with_: NSFastEnumerationState, objects?: K, count?: number): number;
        descriptionWithLocale(withLocale?: any): string;
        descriptionWithLocaleIndent(withLocale?: any, indent?: number): string;
        enumerateKeysAndObjects(_: (p1: KeyType, p2: ObjectType, p3: boolean) => void): void;
        enumerateKeysAndObjectsWithOptionsUsing(options: NSEnumerationOptions, using: (p1: KeyType, p2: ObjectType, p3: boolean) => void): void;
        fileCreationDate(): Date;
        fileExtensionHidden(): boolean;
        fileGroupOwnerAccountID(): number;
        fileGroupOwnerAccountName(): string;
        fileHFSCreatorCode(): number;
        fileHFSTypeCode(): number;
        fileIsAppendOnly(): boolean;
        fileIsImmutable(): boolean;
        fileModificationDate(): Date;
        fileOwnerAccountID(): number;
        fileOwnerAccountName(): string;
        filePosixPermissions(): number;
        fileSize(): number;
        fileSystemFileNumber(): number;
        fileSystemNumber(): number;
        fileType(): string;
        isEqualToDictionary(to: Map<KeyType, ObjectType>): boolean;
        keyEnumerator(): NSEnumerator<KeyType>;
        keysOfEntriesWithPassingTest(passingTest: (p1: KeyType, p2: ObjectType, p3: boolean) => boolean): NSSet<KeyType>;
        keysOfEntriesWithOptionsPassingTest(options: NSEnumerationOptions, passingTest: (p1: KeyType, p2: ObjectType, p3: boolean) => boolean): NSSet<KeyType>;
        keysSortedByValueWithComparator(comparator: (p1: any, p2: any) => ComparisonResult): KeyType[];
        keysSortedByValueUsingSelector(using: string): KeyType[];
        keysSortedByValueWithOptionsUsingComparator(options: NSSortOptions, usingComparator: (p1: any, p2: any) => ComparisonResult): KeyType[];
        objectEnumerator(): NSEnumerator<ObjectType>;
        objectForKey(forKey: KeyType): ObjectType;
        objectsForKeysNotFoundMarker(forKeys: KeyType[], notFoundMarker: ObjectType): ObjectType[];
        writeToFileAtomically(toFile: string, atomically: boolean): boolean;
        writeToURLAtomically(to: NSURL, atomically: boolean): boolean;
        writeToURLError(error: NSURL): boolean;
    }
    class Dimension extends Unit {
        static baseUnit(): Dimension;
        converter: UnitConverter;
        static createWithSymbolConverter(symbol: string, converter: UnitConverter): Dimension;
    }
    class DirectoryEnumerator<ObjectType> extends NSEnumerator<ObjectType> {
        directoryAttributes: Map<string, any>;
        fileAttributes: Map<string, any>;
        isEnumeratingDirectoryPostOrder: boolean;
        level: number;
        skipDescendants(): void;
        skipDescendents(): void;
    }
    interface NSDiscardableContent {
        beginContentAccess(): boolean;
        discardContentIfPossible(): void;
        endContentAccess(): void;
        isContentDiscarded(): boolean;
    }
    class NSDistributedLock extends NSObject {
        lockDate: Date;
        breakLock(): void;
        static createWithPath(path: string): NSDistributedLock;
        tryLock(): boolean;
        unlock(): void;
    }
    class DistributedNotificationCenter extends NotificationCenter {
        suspended: boolean;
        setSuspended(_: boolean): any;
        addObserverSelectorNameObjectSuspensionBehavior(_: any, selector: string, name?: string, object_?: string, suspensionBehavior?: DistributedNotificationCenter.SuspensionBehavior): void;
        postNotificationNameObjectUserInfoDeliverImmediately(_: string, object_?: string, userInfo?: Map<any, any>, deliverImmediately?: boolean): void;
        postNotificationNameObjectUserInfoOptions(_: string, object_?: string, userInfo?: Map<any, any>, options?: DistributedNotificationCenter.Options): void;
    }
    class EnergyFormatter extends Formatter {
        isForFoodEnergyUse: boolean;
        setForFoodEnergyUse(_: boolean): any;
        numberFormatter: NumberFormatter;
        setNumberFormatter(_: NumberFormatter): any;
        unitStyle: Formatter.UnitStyle;
        setUnitStyle(_: Formatter.UnitStyle): any;
        stringFromJoules(_: number): string;
        stringFromValueUnit(_: number, unit: EnergyFormatter.Unit): string;
        unitStringFromJoulesUsedUnit(_: number, usedUnit?: EnergyFormatter.Unit): string;
        unitStringFromValueUnit(_: number, unit: EnergyFormatter.Unit): string;
    }
    class NSEnumerator<ObjectType> extends NSObject {
        allObjects: ObjectType[];
        nextObject(): ObjectType;
    }
    class NSError extends NSObject {
        static setUserInfoValueProviderWithForDomainProvider(forDomain: string, provider?: (p1: NSError, p2: string) => any): void;
        static userInfoValueProviderForDomain(forDomain: string): (p1: NSError, p2: string) => any;
        code: number;
        domain: string;
        helpAnchor: string;
        localizedDescription: string;
        localizedFailureReason: string;
        localizedRecoveryOptions: string[];
        localizedRecoverySuggestion: string;
        recoveryAttempter: any;
        userInfo: Map<string, any>;
        static createWithDomainCodeUserInfo(domain: string, code: number, userInfo?: Map<string, any>): NSError;
    }
    class NSException extends NSObject {
        callStackReturnAddresses: number[];
        callStackSymbols: string[];
        name: string;
        reason: string;
        userInfo: Map<any, any>;
        static createWithNameReasonUserInfo(name: string, reason?: string, userInfo?: Map<any, any>): NSException;
        raise(): void;
    }
    class NSExistsCommand extends NSScriptCommand {
    }
    class NSExpression extends NSObject {
        static expressionForAnyKey(): NSExpression;
        static expressionForEvaluatedObject(): NSExpression;
        arguments: NSExpression[];
        collection: any;
        constantValue: any;
        expressionBlock: (p1: any, p2: NSExpression[], p3: NSMutableDictionary<any, any>) => any;
        expressionType: NSExpression.ExpressionType;
        falseExpression: NSExpression;
        function: string;
        keyPath: string;
        leftExpression: NSExpression;
        operand: NSExpression;
        predicate: NSPredicate;
        rightExpression: NSExpression;
        trueExpression: NSExpression;
        variable: string;
        allowEvaluation(): void;
        expressionValueWithObjectContext(with_?: any, context?: NSMutableDictionary<any, any>): any;
        static createWithExpressionType(expressionType: NSExpression.ExpressionType): NSExpression;
    }
    class NSExtensionContext extends NSObject {
        inputItems: any[];
        cancelRequestWithError(withError: NSError): void;
        completeRequestWithReturningItemsCompletionHandler(returningItems?: any[], completionHandler?: (p1: boolean) => void): void;
        openCompletionHandler(_: NSURL, completionHandler?: (p1: boolean) => void): void;
    }
    class NSExtensionItem extends NSObject {
        attachments: NSItemProvider[];
        setAttachments(_: NSItemProvider[]): any;
        attributedContentText: NSAttributedString;
        setAttributedContentText(_: NSAttributedString): any;
        attributedTitle: NSAttributedString;
        setAttributedTitle(_: NSAttributedString): any;
        userInfo: Map<any, any>;
        setUserInfo(_: Map<any, any>): any;
    }
    interface NSExtensionRequestHandling extends NSObject {
        beginRequestWithExtensionContext(with_: NSExtensionContext): void;
    }
    interface NSFastEnumeration {
        countByEnumeratingWithStateObjectsCount(with_: NSFastEnumerationState, objects?: any, count?: number): number;
    }
    class NSFileAccessIntent extends NSObject {
        static readingIntentWithURLOptions(with_: NSURL, options: NSFileCoordinator.ReadingOptions): NSFileAccessIntent;
        static writingIntentWithURLOptions(with_: NSURL, options: NSFileCoordinator.WritingOptions): NSFileAccessIntent;
        URL: NSURL;
    }
    class NSFileCoordinator extends NSObject {
        static addFilePresenter(_: NSFilePresenter): void;
        static removeFilePresenter(_: NSFilePresenter): void;
        purposeIdentifier: string;
        setPurposeIdentifier(_: string): any;
        static filePresenters: NSFilePresenter[];
        cancel(): void;
        coordinateWithWithQueueByAccessor(with_: NSFileAccessIntent[], queue: OperationQueue, byAccessor?: (p1: NSError) => void): void;
        coordinateWithReadingItemAtOptionsErrorByAccessor(readingItemAt: NSURL, options: NSFileCoordinator.ReadingOptions, error?: Error, byAccessor?: (p1: NSURL) => void): void;
        coordinateWithReadingItemAtOptionsWritingItemAtOptionsErrorByAccessor(readingItemAt: NSURL, options: NSFileCoordinator.ReadingOptions, writingItemAt: NSURL, options2: NSFileCoordinator.WritingOptions, error?: Error, byAccessor?: (p1: NSURL, p2: NSURL) => void): void;
        coordinateWithWritingItemAtOptionsErrorByAccessor(writingItemAt: NSURL, options: NSFileCoordinator.WritingOptions, error?: Error, byAccessor?: (p1: NSURL) => void): void;
        coordinateWithWritingItemAtOptionsWritingItemAtOptionsErrorByAccessor(writingItemAt: NSURL, options: NSFileCoordinator.WritingOptions, writingItemAt2: NSURL, options2: NSFileCoordinator.WritingOptions, error?: Error, byAccessor?: (p1: NSURL, p2: NSURL) => void): void;
        static createWithFilePresenter(filePresenter?: NSFilePresenter): NSFileCoordinator;
        itemWithAtDidChangeUbiquityAttributes(at: NSURL, didChangeUbiquityAttributes: NSSet<string>): void;
        itemAtURLDidMoveToURL(at: NSURL, didMoveTo: NSURL): void;
        itemAtURLWillMoveToURL(at: NSURL, willMoveTo: NSURL): void;
        prepareWithForReadingItemsAtOptionsWritingItemsAtOptionsErrorByAccessor(forReadingItemsAt: NSURL[], options: NSFileCoordinator.ReadingOptions, writingItemsAt: NSURL[], options2: NSFileCoordinator.WritingOptions, error?: Error, byAccessor?: (p1: () => void) => void): void;
    }
    class FileHandle extends NSObject {
        static fileHandleForReadingFromURLError(error: NSURL): FileHandle;
        static fileHandleForUpdatingURLError(error: NSURL): FileHandle;
        static fileHandleForWritingToURLError(error: NSURL): FileHandle;
        availableData: NSData;
        fileDescriptor: number;
        offsetInFile: number;
        readabilityHandler: (p1: FileHandle) => void;
        setReadabilityHandler(_: (p1: FileHandle) => void): any;
        writeabilityHandler: (p1: FileHandle) => void;
        setWriteabilityHandler(_: (p1: FileHandle) => void): any;
        static fileHandleWithNullDevice: FileHandle;
        static fileHandleWithStandardError: FileHandle;
        static fileHandleWithStandardInput: FileHandle;
        static fileHandleWithStandardOutput: FileHandle;
        acceptConnectionInBackgroundAndNotify(): void;
        acceptConnectionInBackgroundAndNotifyForModes(_?: string[]): void;
        closeAndReturnError(): boolean;
        closeFile(): void;
        getOffsetError(error: number): boolean;
        static createWithFileDescriptor(fileDescriptor: number): FileHandle;
        static createWithFileDescriptorCloseOnDealloc(fileDescriptor: number, closeOnDealloc: boolean): FileHandle;
        readDataOfLength(_: number): NSData;
        readDataToEndOfFile(): NSData;
        readDataToEndOfFileAndReturnError(): NSData;
        readDataUpToLengthError(error: number): NSData;
        readInBackgroundAndNotify(): void;
        readInBackgroundAndNotifyForModes(_?: string[]): void;
        readToEndOfFileInBackgroundAndNotify(): void;
        readToEndOfFileInBackgroundAndNotifyForModes(_?: string[]): void;
        seekToEndOfFile(): number;
        seekToEndReturningOffsetError(error?: number): boolean;
        seekToFileOffset(_: number): void;
        seekToOffsetError(error: number): boolean;
        synchronizeAndReturnError(): boolean;
        synchronizeFile(): void;
        truncateAtOffsetError(error: number): boolean;
        truncateFileAtOffset(_: number): void;
        waitForDataInBackgroundAndNotify(): void;
        waitForDataInBackgroundAndNotifyForModes(_?: string[]): void;
        writeData(_: NSData): void;
        writeDataError(error: NSData): boolean;
    }
    class FileManager extends NSObject {
        currentDirectoryPath: string;
        delegate: FileManagerDelegate;
        setDelegate(_: FileManagerDelegate): any;
        homeDirectoryForCurrentUser: NSURL;
        temporaryDirectory: NSURL;
        ubiquityIdentityToken: any;
        static defaultManager: FileManager;
        URLForDirectoryInDomainAppropriateForURLCreateError(for_: FileManager.SearchPathDirectory, in_: FileManager.SearchPathDomainMask, appropriateFor?: NSURL, create?: boolean): NSURL;
        URLForPublishingUbiquitousItemAtURLExpirationDateError(forPublishingUbiquitousItemAt: NSURL, expiration?: Date): NSURL;
        URLForUbiquityContainerIdentifier(forUbiquityContainerIdentifier?: string): NSURL;
        URLsForDirectoryInDomains(for_: FileManager.SearchPathDirectory, in_: FileManager.SearchPathDomainMask): NSURL[];
        attributesOfFileSystemForPathError(error: string): Map<string, any>;
        attributesOfItemAtPathError(error: string): Map<string, any>;
        changeCurrentDirectoryPath(_: string): boolean;
        componentsToDisplayForPath(_: string): string[];
        containerURLForSecurityApplicationGroupIdentifier(forSecurityApplicationGroupIdentifier: string): NSURL;
        contentsAtPath(_: string): NSData;
        contentsEqualAtPathAndPath(_: string, andPath: string): boolean;
        contentsOfDirectoryAtPathError(error: string): string[];
        contentsOfDirectoryAtURLIncludingPropertiesForKeysOptionsError(includingPropertiesForKeys: NSURL, options?: string[], error?: FileManager.DirectoryEnumerationOptions): NSURL[];
        copyItemAtPathToPathError(toPath: string, error: string): boolean;
        copyItemAtURLToURLError(toURL: NSURL, error: NSURL): boolean;
        createDirectoryAtPathWithIntermediateDirectoriesAttributesError(withIntermediateDirectories: string, attributes: boolean, error?: Map<string, any>): boolean;
        createDirectoryAtURLWithIntermediateDirectoriesAttributesError(withIntermediateDirectories: NSURL, attributes: boolean, error?: Map<string, any>): boolean;
        createFileAtPathContentsAttributes(_: string, contents?: NSData, attributes?: Map<string, any>): boolean;
        createSymbolicLinkAtPathWithDestinationPathError(withDestinationPath: string, error: string): boolean;
        createSymbolicLinkAtURLWithDestinationURLError(withDestinationURL: NSURL, error: NSURL): boolean;
        destinationOfSymbolicLinkAtPathError(error: string): string;
        displayNameAtPath(_: string): string;
        enumeratorAtPath(_: string): DirectoryEnumerator<string>;
        enumeratorAtURLWithIncludingPropertiesForKeysOptionsErrorHandler(_: NSURL, includingPropertiesForKeys?: string[], options?: FileManager.DirectoryEnumerationOptions, errorHandler?: (p1: NSURL, p2: NSError) => boolean): DirectoryEnumerator<NSURL>;
        evictUbiquitousItemAtURLError(error: NSURL): boolean;
        fileExistsAtPath(_: string): boolean;
        fileExistsAtPathIsDirectory(_: string, isDirectory?: boolean): boolean;
        fileSystemRepresentationWithPath(_: string): string;
        getFileProviderServicesForItemAtURLWithCompletionHandler(_: NSURL, completionHandler?: (p1: Map<string, NSFileProviderService>, p2: NSError) => void): void;
        getRelationshipOfDirectoryInDomainToItemAtURLError(ofDirectory: FileManager.URLRelationship, inDomain: FileManager.SearchPathDirectory, toItemAtURL: FileManager.SearchPathDomainMask, error: NSURL): boolean;
        getRelationshipOfDirectoryAtURLToItemAtURLError(ofDirectoryAtURL: FileManager.URLRelationship, toItemAtURL: NSURL, error: NSURL): boolean;
        homeDirectoryForUser(_: string): NSURL;
        isDeletableFileAtPath(_: string): boolean;
        isExecutableFileAtPath(_: string): boolean;
        isReadableFileAtPath(_: string): boolean;
        isUbiquitousItemAtURL(_: NSURL): boolean;
        isWritableFileAtPath(_: string): boolean;
        linkItemAtPathToPathError(toPath: string, error: string): boolean;
        linkItemAtURLToURLError(toURL: NSURL, error: NSURL): boolean;
        mountedVolumeURLsIncludingResourceValuesForKeysOptions(includingResourceValuesForKeys?: string[], options?: FileManager.VolumeEnumerationOptions): NSURL[];
        moveItemAtPathToPathError(toPath: string, error: string): boolean;
        moveItemAtURLToURLError(toURL: NSURL, error: NSURL): boolean;
        removeItemAtPathError(error: string): boolean;
        removeItemAtURLError(error: NSURL): boolean;
        replaceItemAtURLWithItemAtURLBackupItemNameOptionsResultingItemURLError(withItemAtURL: NSURL, backupItemName: NSURL, options?: string, resultingItemURL?: FileManager.ItemReplacementOptions, error?: NSURL): boolean;
        setAttributesOfItemAtPathError(ofItemAtPath: Map<string, any>, error: string): boolean;
        setUbiquitousItemAtURLDestinationURLError(itemAtURL: boolean, destinationURL: NSURL, error: NSURL): boolean;
        startDownloadingUbiquitousItemAtURLError(error: NSURL): boolean;
        stringWithFileSystemRepresentationLength(_: string, length: number): string;
        subpathsAtPath(_: string): string[];
        subpathsOfDirectoryAtPathError(error: string): string[];
        trashItemAtURLResultingItemURLError(resultingItemURL: NSURL, error?: NSURL): boolean;
        unmountVolumeAtURLWithOptionsCompletionHandler(_: NSURL, options: FileManager.UnmountOptions, completionHandler?: (p1: NSError) => void): void;
    }
    interface FileManagerDelegate extends NSObject {
        fileManagerShouldCopyItemAtPathToPath?(_: FileManager, shouldCopyItemAtPath: string, toPath: string): boolean;
        fileManagerShouldCopyItemAtURLToURL?(_: FileManager, shouldCopyItemAtURL: NSURL, toURL: NSURL): boolean;
        fileManagerShouldLinkItemAtPathToPath?(_: FileManager, shouldLinkItemAtPath: string, toPath: string): boolean;
        fileManagerShouldLinkItemAtURLToURL?(_: FileManager, shouldLinkItemAtURL: NSURL, toURL: NSURL): boolean;
        fileManagerShouldMoveItemAtPathToPath?(_: FileManager, shouldMoveItemAtPath: string, toPath: string): boolean;
        fileManagerShouldMoveItemAtURLToURL?(_: FileManager, shouldMoveItemAtURL: NSURL, toURL: NSURL): boolean;
        fileManagerShouldProceedAfterErrorCopyingItemAtPathToPath?(_: FileManager, shouldProceedAfterError: NSError, copyingItemAtPath: string, toPath: string): boolean;
        fileManagerShouldProceedAfterErrorCopyingItemAtURLToURL?(_: FileManager, shouldProceedAfterError: NSError, copyingItemAtURL: NSURL, toURL: NSURL): boolean;
        fileManagerShouldProceedAfterErrorLinkingItemAtPathToPath?(_: FileManager, shouldProceedAfterError: NSError, linkingItemAtPath: string, toPath: string): boolean;
        fileManagerShouldProceedAfterErrorLinkingItemAtURLToURL?(_: FileManager, shouldProceedAfterError: NSError, linkingItemAtURL: NSURL, toURL: NSURL): boolean;
        fileManagerShouldProceedAfterErrorMovingItemAtPathToPath?(_: FileManager, shouldProceedAfterError: NSError, movingItemAtPath: string, toPath: string): boolean;
        fileManagerShouldProceedAfterErrorMovingItemAtURLToURL?(_: FileManager, shouldProceedAfterError: NSError, movingItemAtURL: NSURL, toURL: NSURL): boolean;
        fileManagerShouldProceedAfterErrorRemovingItemAtPath?(_: FileManager, shouldProceedAfterError: NSError, removingItemAtPath: string): boolean;
        fileManagerShouldProceedAfterErrorRemovingItemAtURL?(_: FileManager, shouldProceedAfterError: NSError, removingItemAtURL: NSURL): boolean;
        fileManagerShouldRemoveItemAtPath?(_: FileManager, shouldRemoveItemAtPath: string): boolean;
        fileManagerShouldRemoveItemAtURL?(_: FileManager, shouldRemoveItemAtURL: NSURL): boolean;
    }
    interface NSFilePresenter extends NSObject {
        observedPresentedItemUbiquityAttributes?: NSSet<string>;
        presentedItemOperationQueue: OperationQueue;
        presentedItemURL: NSURL;
        primaryPresentedItemURL?: NSURL;
        accommodatePresentedItemDeletionWithCompletionHandler?(completionHandler?: (p1: NSError) => void): void;
        accommodatePresentedSubitemDeletionWithAtCompletionHandler?(at: NSURL, completionHandler?: (p1: NSError) => void): void;
        presentedItemDidChange?(): void;
        presentedItemDidChangeUbiquityAttributes?(_: NSSet<string>): void;
        presentedItemDidGainVersion?(_: NSFileVersion): void;
        presentedItemDidLoseVersion?(_: NSFileVersion): void;
        presentedItemDidMoveToURL?(to: NSURL): void;
        presentedItemDidResolveConflictVersion?(_: NSFileVersion): void;
        presentedSubitemAtURLDidMoveToURL?(at: NSURL, didMoveTo: NSURL): void;
        presentedSubitemAtURLDidGainVersion?(at: NSURL, didGain: NSFileVersion): void;
        presentedSubitemAtURLDidLoseVersion?(at: NSURL, didLose: NSFileVersion): void;
        presentedSubitemAtURLDidResolveConflictVersion?(at: NSURL, didResolve: NSFileVersion): void;
        presentedSubitemDidAppearAtURL?(at: NSURL): void;
        presentedSubitemDidChangeAtURL?(at: NSURL): void;
        relinquishPresentedItemWithToReader?(toReader?: (p1: () => void) => void): void;
        relinquishPresentedItemWithToWriter?(toWriter?: (p1: () => void) => void): void;
        savePresentedItemChangesWithCompletionHandler?(completionHandler?: (p1: NSError) => void): void;
    }
    class NSFileProviderService extends NSObject {
        name: string;
        getFileProviderConnectionWithCompletionHandler(completionHandler?: (p1: NSXPCConnection, p2: NSError) => void): void;
    }
    class NSFileSecurity extends NSObject {
    }
    class NSFileVersion extends NSObject {
        static addVersionOfItemAtURLWithContentsOfURLOptionsError(withContentsOfURL: NSURL, options: NSURL, error: NSFileVersion.AddingOptions): NSFileVersion;
        static currentVersionOfItemAtURL(at: NSURL): NSFileVersion;
        static getNonlocalVersionsOfItemWithAtCompletionHandler(at: NSURL, completionHandler?: (p1: NSFileVersion[], p2: NSError) => void): void;
        static otherVersionsOfItemAtURL(at: NSURL): NSFileVersion[];
        static removeOtherVersionsOfItemAtURLError(error: NSURL): boolean;
        static temporaryDirectoryURLForNewVersionOfItemAtURL(at: NSURL): NSURL;
        static unresolvedConflictVersionsOfItemAtURL(at: NSURL): NSFileVersion[];
        URL: NSURL;
        isConflict: boolean;
        isDiscardable: boolean;
        setDiscardable(_: boolean): any;
        hasLocalContents: boolean;
        hasThumbnail: boolean;
        localizedName: string;
        localizedNameOfSavingComputer: string;
        modificationDate: Date;
        originatorNameComponents: NSPersonNameComponents;
        persistentIdentifier: NSCoding;
        isResolved: boolean;
        setResolved(_: boolean): any;
        removeAndReturnError(): boolean;
        replaceItemAtURLOptionsError(options: NSURL, error: NSFileVersion.ReplacingOptions): NSURL;
    }
    class FileWrapper extends NSObject {
        isDirectory: boolean;
        fileAttributes: Map<string, any>;
        setFileAttributes(_: Map<string, any>): any;
        fileWrappers: Map<string, FileWrapper>;
        filename: string;
        setFilename(_: string): any;
        icon: NSImage;
        setIcon(_: NSImage): any;
        preferredFilename: string;
        setPreferredFilename(_: string): any;
        isRegularFile: boolean;
        regularFileContents: NSData;
        serializedRepresentation: NSData;
        isSymbolicLink: boolean;
        symbolicLinkDestinationURL: NSURL;
        addFileWrapper(_: FileWrapper): string;
        addRegularFileWithContentsPreferredFilename(_: NSData, preferredFilename: string): string;
        static createWithDirectoryWithFileWrappers(directoryWithFileWrappers: Map<string, FileWrapper>): FileWrapper;
        static createWithRegularFileWithContents(regularFileWithContents: NSData): FileWrapper;
        static createWithSymbolicLinkWithDestinationURL(symbolicLinkWithDestinationURL: NSURL): FileWrapper;
        static createWithSerializedRepresentation(serializedRepresentation: NSData): FileWrapper;
        static createWithUrlOptions(URL: NSURL, options: FileWrapper.ReadingOptions): FileWrapper;
        keyForFileWrapper(_: FileWrapper): string;
        matchesContentsOfURL(_: NSURL): boolean;
        readFromURLOptionsError(options: NSURL, error: FileWrapper.ReadingOptions): boolean;
        removeFileWrapper(_: FileWrapper): void;
        writeToURLOptionsOriginalContentsURLError(options: NSURL, originalContentsURL: FileWrapper.WritingOptions, error?: NSURL): boolean;
    }
    class Formatter extends NSObject {
        attributedStringForObjectValueWithDefaultAttributes(_: any, withDefaultAttributes?: Map<string, any>): NSAttributedString;
        editingStringForObjectValue(_: any): string;
        getObjectValueForStringErrorDescription(_?: any, forString?: string, errorDescription?: string): boolean;
        isPartialStringValidNewEditingStringErrorDescription(_: string, newEditingString?: string, errorDescription?: string): boolean;
        isPartialStringValidProposedSelectedRangeOriginalStringOriginalSelectedRangeErrorDescription(_: string, proposedSelectedRange?: NSRange, originalString?: string, originalSelectedRange?: NSRange, errorDescription?: string): boolean;
        stringForObjectValue(_?: any): string;
    }
    class NSGetCommand extends NSScriptCommand {
    }
    class HTTPCookie extends NSObject {
        static cookiesWithResponseHeaderFieldsForURL(_: Map<string, string>, forURL: NSURL): HTTPCookie[];
        static requestHeaderFieldsWithCookies(_: HTTPCookie[]): Map<string, string>;
        isHTTPOnly: boolean;
        comment: string;
        commentURL: NSURL;
        domain: string;
        expiresDate: Date;
        name: string;
        path: string;
        portList: number[];
        properties: Map<string, any>;
        sameSitePolicy: string;
        isSecure: boolean;
        isSessionOnly: boolean;
        value: string;
        static createWithProperties(properties: Map<string, any>): HTTPCookie;
    }
    class HTTPCookieStorage extends NSObject {
        static sharedCookieStorageForGroupContainerIdentifier(_: string): HTTPCookieStorage;
        cookieAcceptPolicy: HTTPCookie.AcceptPolicy;
        setCookieAcceptPolicy(_: HTTPCookie.AcceptPolicy): any;
        cookies: HTTPCookie[];
        static sharedHTTPCookieStorage: HTTPCookieStorage;
        cookiesForURL(_: NSURL): HTTPCookie[];
        deleteCookie(_: HTTPCookie): void;
        getCookiesForTaskWithCompletionHandler(_: URLSessionTask, completionHandler?: (p1: HTTPCookie[]) => void): void;
        removeCookiesSinceDate(_: Date): void;
        setCookie(_: HTTPCookie): void;
        setCookiesForURLMainDocumentURL(_: HTTPCookie[], forURL?: NSURL, mainDocumentURL?: NSURL): void;
        sortedCookiesUsingDescriptors(_: NSSortDescriptor[]): HTTPCookie[];
        storeCookiesForTask(_: HTTPCookie[], forTask: URLSessionTask): void;
    }
    class HTTPURLResponse extends URLResponse {
        static localizedStringForStatusCode(_: number): string;
        allHeaderFields: Map<any, any>;
        statusCode: number;
        static createWithUrlStatusCodeHTTPVersionHeaderFields(URL: NSURL, statusCode: number, HTTPVersion?: string, headerFields?: Map<string, string>): HTTPURLResponse;
        valueForHTTPHeaderField(_: string): string;
    }
    class NSHashTable<ObjectType> extends NSObject {
        static weakObjectsHashTable<ObjectType>(): NSHashTable<ObjectType>;
        allObjects: ObjectType[];
        anyObject: ObjectType;
        count: number;
        pointerFunctions: NSPointerFunctions;
        setRepresentation: NSSet<ObjectType>;
        addObject(_?: ObjectType): void;
        containsObject(_?: ObjectType): boolean;
        intersect(_: NSHashTable<ObjectType>): void;
        intersects(_: NSHashTable<ObjectType>): boolean;
        isEqualWithTo(to: NSHashTable<ObjectType>): boolean;
        isSubsetOf(of: NSHashTable<ObjectType>): boolean;
        member(_?: ObjectType): ObjectType;
        minus(_: NSHashTable<ObjectType>): void;
        objectEnumerator(): NSEnumerator<ObjectType>;
        removeAllObjects(): void;
        removeObject(_?: ObjectType): void;
        union(_: NSHashTable<ObjectType>): void;
    }
    class Host extends NSObject {
        static currentHost(): Host;
        address: string;
        addresses: string[];
        localizedName: string;
        name: string;
        names: string[];
        isEqualToHost(_: Host): boolean;
    }
    class ISO8601DateFormatter extends Formatter {
        static stringFromDateTimeZoneFormatOptions(_: Date, timeZone: NSTimeZone, formatOptions: ISO8601DateFormatter.Options): string;
        formatOptions: ISO8601DateFormatter.Options;
        setFormatOptions(_: ISO8601DateFormatter.Options): any;
        timeZone: NSTimeZone;
        setTimeZone(_: NSTimeZone): any;
        dateFromString(_: string): Date;
        stringFromDate(_: Date): string;
    }
    class NSIndexPath extends NSObject {
        item: number;
        length: number;
        section: number;
        compare(_: NSIndexPath): ComparisonResult;
        getIndexes(_: number): void;
        getIndexesRange(_: number, range: NSRange): void;
        indexAtPosition(atPosition: number): number;
        indexPathByAddingIndex(_: number): NSIndexPath;
        indexPathByRemovingLastIndex(): NSIndexPath;
        static createWithIndex(index: number): NSIndexPath;
        static createWithIndexesLength(indexes?: number, length?: number): NSIndexPath;
    }
    class NSIndexSet extends NSObject {
        count: number;
        firstIndex: number;
        lastIndex: number;
        containsIndex(_: number): boolean;
        containsIndexes(_: NSIndexSet): boolean;
        containsIndexesInRange(in_: NSRange): boolean;
        countOfIndexesInRange(in_: NSRange): number;
        enumerateWithInOptionsUsing(in_: NSRange, options: NSEnumerationOptions, using: (p1: number, p2: boolean) => void): void;
        enumerate(_: (p1: number, p2: boolean) => void): void;
        enumerateWithOptionsUsing(options: NSEnumerationOptions, using: (p1: number, p2: boolean) => void): void;
        enumerateRangesWithInOptionsUsing(in_: NSRange, options: NSEnumerationOptions, using: (p1: NSRange, p2: boolean) => void): void;
        enumerateRanges(_: (p1: NSRange, p2: boolean) => void): void;
        enumerateRangesWithOptionsUsing(options: NSEnumerationOptions, using: (p1: NSRange, p2: boolean) => void): void;
        getIndexesMaxCountInIndexRange(_: number, maxCount: number, inIndexRange?: NSRange): number;
        indexGreaterThanIndex(_: number): number;
        indexGreaterThanOrEqualToIndex(to: number): number;
        indexWithInOptionsPassingTest(in_: NSRange, options: NSEnumerationOptions, passingTest: (p1: number, p2: boolean) => boolean): number;
        indexLessThanIndex(_: number): number;
        indexLessThanOrEqualToIndex(to: number): number;
        indexWithPassingTest(passingTest: (p1: number, p2: boolean) => boolean): number;
        indexWithOptionsPassingTest(options: NSEnumerationOptions, passingTest: (p1: number, p2: boolean) => boolean): number;
        indexesWithInOptionsPassingTest(in_: NSRange, options: NSEnumerationOptions, passingTest: (p1: number, p2: boolean) => boolean): NSIndexSet;
        indexesWithPassingTest(passingTest: (p1: number, p2: boolean) => boolean): NSIndexSet;
        indexesWithOptionsPassingTest(options: NSEnumerationOptions, passingTest: (p1: number, p2: boolean) => boolean): NSIndexSet;
        static createWithIndex(index: number): NSIndexSet;
        static createWithIndexSet(indexSet: NSIndexSet): NSIndexSet;
        static createWithIndexesInRange(indexesInRange: NSRange): NSIndexSet;
        intersectsIndexesInRange(in_: NSRange): boolean;
        isEqualToIndexSet(to: NSIndexSet): boolean;
    }
    class NSIndexSpecifier extends NSScriptObjectSpecifier {
        index: number;
        setIndex(_: number): any;
        static createWithContainerClassDescriptionContainerSpecifierKeyIndex(containerClassDescription: NSScriptClassDescription, containerSpecifier?: NSScriptObjectSpecifier, key?: string, index?: number): NSIndexSpecifier;
    }
    class InputStream extends Stream {
        static inputStreamWithData(_: NSData): InputStream;
        static inputStreamWithFileAtPath(_: string): InputStream;
        static inputStreamWithURL(_: NSURL): InputStream;
        hasBytesAvailable: boolean;
        getBufferLength(_?: string, length?: number): boolean;
        static createWithData(data: NSData): InputStream;
        static createWithFileAtPath(fileAtPath: string): InputStream;
        static createWithUrl(URL: NSURL): InputStream;
        readMaxLength(_: string, maxLength: number): number;
    }
    class NSItemProvider extends NSObject {
        containerFrame: CGRect;
        preferredPresentationSize: CGSize;
        previewImageHandler: (p1: (p1: NSSecureCoding, p2: NSError) => void, p2: typeof NSObject, p3: Map<any, any>) => void;
        setPreviewImageHandler(_: (p1: (p1: NSSecureCoding, p2: NSError) => void, p2: typeof NSObject, p3: Map<any, any>) => void): any;
        registeredTypeIdentifiers: string[];
        sourceFrame: CGRect;
        suggestedName: string;
        setSuggestedName(_: string): any;
        canLoadObjectOfClass(ofClass: typeof NSObject): boolean;
        hasItemConformingToTypeIdentifier(_: string): boolean;
        hasRepresentationConformingToTypeIdentifierFileOptions(toTypeIdentifier: string, fileOptions: NSItemProviderFileOptions): boolean;
        static createWithContentsOfURL(contentsOfURL: NSURL): NSItemProvider;
        static createWithItemTypeIdentifier(item?: NSSecureCoding, typeIdentifier?: string): NSItemProvider;
        static createWithObject(object_: NSItemProviderWriting): NSItemProvider;
        loadDataRepresentationWithForTypeIdentifierCompletionHandler(forTypeIdentifier: string, completionHandler?: (p1: NSData, p2: NSError) => void): Progress;
        loadFileRepresentationWithForTypeIdentifierCompletionHandler(forTypeIdentifier: string, completionHandler?: (p1: NSURL, p2: NSError) => void): Progress;
        loadInPlaceFileRepresentationWithForTypeIdentifierCompletionHandler(forTypeIdentifier: string, completionHandler?: (p1: NSURL, p2: boolean, p3: NSError) => void): Progress;
        loadItemWithForTypeIdentifierOptionsCompletionHandler(forTypeIdentifier: string, options?: Map<any, any>, completionHandler?: (p1: NSSecureCoding, p2: NSError) => void): void;
        loadObjectWithOfClassCompletionHandler(ofClass: typeof NSObject, completionHandler?: (p1: NSItemProviderReading, p2: NSError) => void): Progress;
        loadPreviewImageWithOptionsCompletionHandler(options: Map<any, any>, completionHandler: (p1: NSSecureCoding, p2: NSError) => void): void;
        registerCloudKitShareContainer(_: CKShare, container: CKContainer): void;
        registerCloudKitShareWithPreparationHandler(preparationHandler?: (p1: (p1: CKShare, p2: CKContainer, p3: NSError) => void) => void): void;
        registerDataRepresentationWithForTypeIdentifierVisibilityLoadHandler(forTypeIdentifier: string, visibility: NSItemProviderRepresentationVisibility, loadHandler?: (p1: (p1: NSData, p2: NSError) => void) => Progress): void;
        registerFileRepresentationWithForTypeIdentifierFileOptionsVisibilityLoadHandler(forTypeIdentifier: string, fileOptions: NSItemProviderFileOptions, visibility: NSItemProviderRepresentationVisibility, loadHandler?: (p1: (p1: NSURL, p2: boolean, p3: NSError) => void) => Progress): void;
        registerItemWithForTypeIdentifierLoadHandler(forTypeIdentifier: string, loadHandler: (p1: (p1: NSSecureCoding, p2: NSError) => void, p2: typeof NSObject, p3: Map<any, any>) => void): void;
        registerObjectVisibility(_: NSItemProviderWriting, visibility: NSItemProviderRepresentationVisibility): void;
        registerObjectWithOfClassVisibilityLoadHandler(ofClass: typeof NSObject, visibility: NSItemProviderRepresentationVisibility, loadHandler?: (p1: (p1: NSItemProviderWriting, p2: NSError) => void) => Progress): void;
        registeredTypeIdentifiersWithFileOptions(fileOptions: NSItemProviderFileOptions): string[];
    }
    type NSItemProviderReading = NSObject;
    interface NSItemProviderWriting extends NSObject {
        writableTypeIdentifiersForItemProvider?: string[];
        itemProviderVisibilityForRepresentationWithTypeIdentifier?(withTypeIdentifier: string): NSItemProviderRepresentationVisibility;
        loadDataWithWithTypeIdentifierForItemProviderCompletionHandler(withTypeIdentifier: string, forItemProviderCompletionHandler?: (p1: NSData, p2: NSError) => void): Progress;
    }
    class JSONSerialization extends NSObject {
        static JSONObjectWithDataOptionsError(options: NSData, error: JSONSerialization.ReadingOptions): any;
        static JSONObjectWithStreamOptionsError(options: InputStream, error: JSONSerialization.ReadingOptions): any;
        static dataWithJSONObjectOptionsError(options: any, error: JSONSerialization.WritingOptions): NSData;
        static isValidJSONObject(_: any): boolean;
        static writeJSONObjectToStreamOptionsError(toStream: any, options: OutputStream, error: JSONSerialization.WritingOptions): number;
    }
    class NSKeyedArchiver extends NSCoder {
        static archivedDataWithRootObjectRequiringSecureCodingError(requiringSecureCoding: any, error: boolean): NSData;
        static classNameForClass(for_: typeof NSObject): string;
        static setClassNameForClass(_?: string, for_?: typeof NSObject): void;
        delegate: NSKeyedArchiverDelegate;
        setDelegate(_: NSKeyedArchiverDelegate): any;
        encodedData: NSData;
        outputFormat: PropertyListSerialization.PropertyListFormat;
        setOutputFormat(_: PropertyListSerialization.PropertyListFormat): any;
        classNameForClass(for_: typeof NSObject): string;
        finishEncoding(): void;
        static createWithRequiringSecureCoding(requiringSecureCoding: boolean): NSKeyedArchiver;
        setClassNameForClass(_?: string, for_?: typeof NSObject): void;
    }
    interface NSKeyedArchiverDelegate extends NSObject {
        archiverWillEncodeObject?(_: NSKeyedArchiver, willEncode: any): any;
        archiverDidEncodeObject?(_: NSKeyedArchiver, didEncode?: any): void;
        archiverWillReplaceObjectWithObject?(_: NSKeyedArchiver, willReplace?: any, with_?: any): void;
        archiverDidFinish?(_: NSKeyedArchiver): void;
        archiverWillFinish?(_: NSKeyedArchiver): void;
    }
    class NSKeyedUnarchiver extends NSCoder {
        static classForClassName(forClassName: string): typeof NSObject;
        static setClassForClassName(_?: typeof NSObject, forClassName?: string): void;
        static unarchivedObjectOfClassFromDataError(fromData: typeof NSObject, error: NSData): any;
        static unarchivedObjectOfClassesWithFromDataError(fromData: NSSet<typeof NSObject>, error: NSData): any;
        delegate: NSKeyedUnarchiverDelegate;
        setDelegate(_: NSKeyedUnarchiverDelegate): any;
        classForClassName(forClassName: string): typeof NSObject;
        finishDecoding(): void;
        static createWithForReadingFromData(forReadingFromData: NSData): NSKeyedUnarchiver;
        setClassForClassName(_?: typeof NSObject, forClassName?: string): void;
    }
    interface NSKeyedUnarchiverDelegate extends NSObject {
        unarchiverDidDecodeObject?(_: NSKeyedUnarchiver, didDecode?: any): any;
        unarchiverWillReplaceObjectWithObject?(_: NSKeyedUnarchiver, willReplace: any, with_: any): void;
        unarchiverCannotDecodeObjectOfClassNameOriginalClasses?(_: NSKeyedUnarchiver, cannotDecodeObjectOfClassName: string, originalClasses: string[]): typeof NSObject;
        unarchiverDidFinish?(_: NSKeyedUnarchiver): void;
        unarchiverWillFinish?(_: NSKeyedUnarchiver): void;
    }
    class LengthFormatter extends Formatter {
        isForPersonHeightUse: boolean;
        setForPersonHeightUse(_: boolean): any;
        numberFormatter: NumberFormatter;
        setNumberFormatter(_: NumberFormatter): any;
        unitStyle: Formatter.UnitStyle;
        setUnitStyle(_: Formatter.UnitStyle): any;
        stringFromMeters(_: number): string;
        stringFromValueUnit(_: number, unit: LengthFormatter.Unit): string;
        unitStringFromMetersUsedUnit(_: number, usedUnit?: LengthFormatter.Unit): string;
        unitStringFromValueUnit(_: number, unit: LengthFormatter.Unit): string;
    }
    class NSLinguisticTagger extends NSObject {
        static availableTagSchemesForLanguage(forLanguage: string): string[];
        static availableTagSchemesForUnitLanguage(for_: NSLinguisticTaggerUnit, language: string): string[];
        static dominantLanguageForString(for_: string): string;
        static enumerateTagsForRangeUnitSchemeOptionsOrthographyUsing(for_: string, range: NSRange, unit: NSLinguisticTaggerUnit, scheme: string, options: NSLinguisticTagger.Options, orthography?: NSOrthography, using?: (p1: string, p2: NSRange, p3: boolean) => void): void;
        static tagForStringAtIndexUnitSchemeOrthographyTokenRange(for_: string, at: number, unit: NSLinguisticTaggerUnit, scheme: string, orthography?: NSOrthography, tokenRange?: NSRange): string;
        static tagsForStringRangeUnitSchemeOptionsOrthographyTokenRanges(for_: string, range: NSRange, unit: NSLinguisticTaggerUnit, scheme: string, options: NSLinguisticTagger.Options, orthography?: NSOrthography, tokenRanges?: NSValue[]): string[];
        dominantLanguage: string;
        string: string;
        setString(_: string): any;
        tagSchemes: string[];
        enumerateTagsWithInSchemeOptionsUsing(in_: NSRange, scheme: string, options: NSLinguisticTagger.Options, using?: (p1: string, p2: NSRange, p3: NSRange, p4: boolean) => void): void;
        enumerateTagsWithInUnitSchemeOptionsUsing(in_: NSRange, unit: NSLinguisticTaggerUnit, scheme: string, options: NSLinguisticTagger.Options, using?: (p1: string, p2: NSRange, p3: boolean) => void): void;
        static createWithTagSchemesOptions(tagSchemes: string[], options: number): NSLinguisticTagger;
        orthographyAtIndexEffectiveRange(at: number, effectiveRange?: NSRange): NSOrthography;
        possibleTagsAtIndexSchemeTokenRangeSentenceRangeScores(at: number, scheme: string, tokenRange?: NSRange, sentenceRange?: NSRange, scores?: NSValue[]): string[];
        sentenceRangeForRange(for_: NSRange): NSRange;
        setOrthographyRange(_?: NSOrthography, range?: NSRange): void;
        stringEditedInRangeChangeInLength(in_: NSRange, changeInLength: number): void;
        tagAtIndexSchemeTokenRangeSentenceRange(at: number, scheme: string, tokenRange?: NSRange, sentenceRange?: NSRange): string;
        tagAtIndexUnitSchemeTokenRange(at: number, unit: NSLinguisticTaggerUnit, scheme: string, tokenRange?: NSRange): string;
        tagsInRangeSchemeOptionsTokenRanges(in_: NSRange, scheme: string, options: NSLinguisticTagger.Options, tokenRanges?: NSValue[]): string[];
        tagsInRangeUnitSchemeOptionsTokenRanges(in_: NSRange, unit: NSLinguisticTaggerUnit, scheme: string, options: NSLinguisticTagger.Options, tokenRanges?: NSValue[]): string[];
        tokenRangeAtIndexUnit(at: number, unit: NSLinguisticTaggerUnit): NSRange;
    }
    class ListFormatter extends Formatter {
        static localizedStringByJoiningStrings(_: string[]): string;
        itemFormatter: Formatter;
        setItemFormatter(_: Formatter): any;
        locale: NSLocale;
        setLocale(_: NSLocale): any;
        stringFromItems(from: any[]): string;
    }
    class NSLocale extends NSObject {
        static canonicalLanguageIdentifierFromString(from: string): string;
        static canonicalLocaleIdentifierFromString(from: string): string;
        static characterDirectionForLanguage(forLanguage: string): NSLocale.LanguageDirection;
        static componentsFromLocaleIdentifier(fromLocaleIdentifier: string): Map<string, string>;
        static lineDirectionForLanguage(forLanguage: string): NSLocale.LanguageDirection;
        static localeIdentifierFromComponents(fromComponents: Map<string, string>): string;
        static localeIdentifierFromWindowsLocaleCode(fromWindowsLocaleCode: number): string;
        static windowsLocaleCodeFromLocaleIdentifier(fromLocaleIdentifier: string): number;
        alternateQuotationBeginDelimiter: string;
        alternateQuotationEndDelimiter: string;
        calendarIdentifier: string;
        collationIdentifier: string;
        collatorIdentifier: string;
        countryCode: string;
        currencyCode: string;
        currencySymbol: string;
        decimalSeparator: string;
        exemplarCharacterSet: NSCharacterSet;
        groupingSeparator: string;
        languageCode: string;
        localeIdentifier: string;
        quotationBeginDelimiter: string;
        quotationEndDelimiter: string;
        scriptCode: string;
        usesMetricSystem: boolean;
        variantCode: string;
        static ISOCountryCodes: string[];
        static ISOCurrencyCodes: string[];
        static ISOLanguageCodes: string[];
        static autoupdatingCurrentLocale: NSLocale;
        static availableLocaleIdentifiers: string[];
        static commonISOCurrencyCodes: string[];
        static currentLocale: NSLocale;
        static preferredLanguages: string[];
        static systemLocale: NSLocale;
        displayNameForKeyValue(forKey: string, value: any): string;
        static createWithLocaleIdentifier(localeIdentifier: string): NSLocale;
        localizedStringForCalendarIdentifier(forCalendarIdentifier: string): string;
        localizedStringForCollationIdentifier(forCollationIdentifier: string): string;
        localizedStringForCollatorIdentifier(forCollatorIdentifier: string): string;
        localizedStringForCountryCode(forCountryCode: string): string;
        localizedStringForCurrencyCode(forCurrencyCode: string): string;
        localizedStringForLanguageCode(forLanguageCode: string): string;
        localizedStringForLocaleIdentifier(forLocaleIdentifier: string): string;
        localizedStringForScriptCode(forScriptCode: string): string;
        localizedStringForVariantCode(forVariantCode: string): string;
        objectForKey(forKey: string): any;
    }
    class NSLock extends NSObject {
        name: string;
        setName(_: string): any;
        lockBeforeDate(before: Date): boolean;
        tryLock(): boolean;
    }
    interface NSLocking {
        lock(): void;
        unlock(): void;
    }
    class NSLogicalTest extends NSScriptWhoseTest {
        static createWithAndTestWithTests(andTestWithTests: NSSpecifierTest[]): NSLogicalTest;
        static createWithNotTestWithTest(notTestWithTest: NSScriptWhoseTest): NSLogicalTest;
        static createWithOrTestWithTests(orTestWithTests: NSSpecifierTest[]): NSLogicalTest;
    }
    class NSMachPort extends Port {
        static portWithMachPort(withMachPort: number): Port;
        static portWithMachPortOptions(withMachPort: number, options: NSMachPort.Options): Port;
        machPort: number;
        static createWithMachPort(machPort: number): NSMachPort;
        static createWithMachPortOptions(machPort: number, options: NSMachPort.Options): NSMachPort;
    }
    interface NSMachPortDelegate extends PortDelegate {
        handleMachMessage?(_: any): void;
    }
    class NSMapTable<KeyType, ObjectType> extends NSObject {
        static strongToStrongObjectsMapTable<KeyType, ObjectType>(): NSMapTable<KeyType, ObjectType>;
        static strongToWeakObjectsMapTable<KeyType, ObjectType>(): NSMapTable<KeyType, ObjectType>;
        static weakToStrongObjectsMapTable<KeyType, ObjectType>(): NSMapTable<KeyType, ObjectType>;
        static weakToWeakObjectsMapTable<KeyType, ObjectType>(): NSMapTable<KeyType, ObjectType>;
        count: number;
        keyPointerFunctions: NSPointerFunctions;
        valuePointerFunctions: NSPointerFunctions;
        dictionaryRepresentation(): Map<KeyType, ObjectType>;
        keyEnumerator(): NSEnumerator<KeyType>;
        objectEnumerator(): NSEnumerator<ObjectType>;
        objectForKey(forKey?: KeyType): ObjectType;
        removeAllObjects(): void;
        removeObjectForKey(forKey?: KeyType): void;
        setObjectForKey(_?: ObjectType, forKey?: KeyType): void;
    }
    class MassFormatter extends Formatter {
        isForPersonMassUse: boolean;
        setForPersonMassUse(_: boolean): any;
        numberFormatter: NumberFormatter;
        setNumberFormatter(_: NumberFormatter): any;
        unitStyle: Formatter.UnitStyle;
        setUnitStyle(_: Formatter.UnitStyle): any;
        stringFromKilograms(_: number): string;
        stringFromValueUnit(_: number, unit: MassFormatter.Unit): string;
        unitStringFromKilogramsUsedUnit(_: number, usedUnit?: MassFormatter.Unit): string;
        unitStringFromValueUnit(_: number, unit: MassFormatter.Unit): string;
    }
    class NSMeasurement<UnitType> extends NSObject {
        doubleValue: number;
        unit: UnitType;
        canBeConvertedToUnit(to: Unit): boolean;
        adding(_: NSMeasurement<UnitType>): NSMeasurement<UnitType>;
        measurementByConvertingToUnit(to: Unit): NSMeasurement<any>;
        subtracting(_: NSMeasurement<UnitType>): NSMeasurement<UnitType>;
    }
    class MeasurementFormatter extends Formatter {
        locale: NSLocale;
        setLocale(_: NSLocale): any;
        numberFormatter: NumberFormatter;
        setNumberFormatter(_: NumberFormatter): any;
        unitOptions: MeasurementFormatter.UnitOptions;
        setUnitOptions(_: MeasurementFormatter.UnitOptions): any;
        unitStyle: Formatter.UnitStyle;
        setUnitStyle(_: Formatter.UnitStyle): any;
        stringFromMeasurement(_: NSMeasurement<any>): string;
        stringFromUnit(_: Unit): string;
    }
    class MessagePort extends Port {
    }
    class NSMetadataItem extends NSObject {
        attributes: string[];
        static createWithUrl(URL: NSURL): NSMetadataItem;
        valueForAttribute(forAttribute: string): any;
        valuesForAttributes(forAttributes: string[]): Map<string, any>;
    }
    class NSMetadataQuery extends NSObject {
        delegate: NSMetadataQueryDelegate;
        setDelegate(_: NSMetadataQueryDelegate): any;
        isGathering: boolean;
        groupedResults: NSMetadataQueryResultGroup[];
        groupingAttributes: string[];
        setGroupingAttributes(_: string[]): any;
        notificationBatchingInterval: number;
        setNotificationBatchingInterval(_: number): any;
        operationQueue: OperationQueue;
        setOperationQueue(_: OperationQueue): any;
        predicate: NSPredicate;
        setPredicate(_: NSPredicate): any;
        resultCount: number;
        results: any[];
        searchItems: any[];
        setSearchItems(_: any[]): any;
        searchScopes: any[];
        setSearchScopes(_: any[]): any;
        sortDescriptors: NSSortDescriptor[];
        setSortDescriptors(_: NSSortDescriptor[]): any;
        isStarted: boolean;
        isStopped: boolean;
        valueListAttributes: string[];
        setValueListAttributes(_: string[]): any;
        valueLists: Map<string, NSMetadataQueryAttributeValueTuple[]>;
        disableUpdates(): void;
        enableUpdates(): void;
        enumerateResults(_: (p1: any, p2: number, p3: boolean) => void): void;
        enumerateResultsWithOptionsUsing(options: NSEnumerationOptions, using: (p1: any, p2: number, p3: boolean) => void): void;
        indexOfResult(ofResult: any): number;
        resultAtIndex(at: number): any;
        startQuery(): boolean;
        stopQuery(): void;
        valueOfAttributeForResultAtIndex(ofAttribute: string, forResultAt: number): any;
    }
    class NSMetadataQueryAttributeValueTuple extends NSObject {
        attribute: string;
        count: number;
        value: any;
    }
    interface NSMetadataQueryDelegate extends NSObject {
        metadataQueryReplacementObjectForResultObject?(_: NSMetadataQuery, replacementObjectForResultObject: NSMetadataItem): any;
        metadataQueryReplacementValueForAttributeValue?(_: NSMetadataQuery, replacementValueForAttribute: string, value: any): any;
    }
    class NSMetadataQueryResultGroup extends NSObject {
        attribute: string;
        resultCount: number;
        results: any[];
        subgroups: NSMetadataQueryResultGroup[];
        value: any;
        resultAtIndex(at: number): any;
    }
    class NSMiddleSpecifier extends NSScriptObjectSpecifier {
    }
    class NSMoveCommand extends NSScriptCommand {
        keySpecifier: NSScriptObjectSpecifier;
        setReceiversSpecifier(_?: NSScriptObjectSpecifier): void;
    }
    class NSMutableArray<ObjectType> extends NSArray<ObjectType> {
        static arrayWithCapacity<ObjectType>(capacity: number): NSMutableArray<ObjectType>;
        addObject(_: ObjectType): void;
        addObjectsFromArray(from: ObjectType[]): void;
        exchangeObjectAtIndexWithObjectAtIndex(at: number, withObjectAt: number): void;
        filterUsingPredicate(using: NSPredicate): void;
        insertObjectAtIndex(_: ObjectType, at: number): void;
        insertObjectsAtIndexes(_: ObjectType[], at: NSIndexSet): void;
        removeAllObjects(): void;
        removeLastObject(): void;
        removeObject(_: ObjectType): void;
        removeObjectInRange(_: ObjectType, in_: NSRange): void;
        removeObjectAtIndex(at: number): void;
        removeObjectIdenticalTo(identicalTo: ObjectType): void;
        removeObjectIdenticalToInRange(identicalTo: ObjectType, in_: NSRange): void;
        removeObjectsAtIndexes(at: NSIndexSet): void;
        removeObjectsInArray(in_: ObjectType[]): void;
        removeObjectsInRange(in_: NSRange): void;
        replaceObjectAtIndexWithObject(at: number, with_: ObjectType): void;
        replaceObjectsAtIndexesWithObjects(at: NSIndexSet, with_: ObjectType[]): void;
        replaceObjectsInRangeWithObjectsFromArray(in_: NSRange, withObjectsFrom: ObjectType[]): void;
        replaceObjectsInRangeWithObjectsFromArrayRange(in_: NSRange, withObjectsFrom: ObjectType[], range: NSRange): void;
        setArray(_: ObjectType[]): void;
        setObjectAtIndexedSubscript(_: ObjectType, atIndexedSubscript: number): void;
        sortWithComparator(comparator: (p1: any, p2: any) => ComparisonResult): void;
        sortUsingDescriptors(using: NSSortDescriptor[]): void;
        sortContext(_?: (p1: ObjectType, p2: ObjectType, p3: any) => number, context?: any): void;
        sortUsingSelector(using: string): void;
        sortWithOptionsUsingComparator(options: NSSortOptions, usingComparator: (p1: any, p2: any) => ComparisonResult): void;
    }
    class NSMutableAttributedString extends NSAttributedString {
        mutableString: NSMutableString;
        addAttributeValueRange(_: string, value: any, range: NSRange): void;
        addAttributesRange(_: Map<string, any>, range: NSRange): void;
        appendAttributedString(_: NSAttributedString): void;
        applyFontTraitsRange(_: NSFontTraitMask, range: NSRange): void;
        beginEditing(): void;
        deleteCharactersInRange(in_: NSRange): void;
        endEditing(): void;
        fixAttachmentAttributeInRange(in_: NSRange): void;
        fixAttributesInRange(in_: NSRange): void;
        fixFontAttributeInRange(in_: NSRange): void;
        fixParagraphStyleAttributeInRange(in_: NSRange): void;
        insertAttributedStringAtIndex(_: NSAttributedString, at: number): void;
        readFromDataOptionsDocumentAttributesError(from: NSData, options: Map<string, any>, documentAttributes?: Map<string, any>): boolean;
        readFromURLOptionsDocumentAttributesError(from: NSURL, options: Map<string, any>, documentAttributes?: Map<string, any>): boolean;
        removeAttributeRange(_: string, range: NSRange): void;
        replaceCharactersInRangeWithAttributedString(in_: NSRange, with_: NSAttributedString): void;
        replaceCharactersInRangeWithString(in_: NSRange, with_: string): void;
        setAlignmentRange(_: NSTextAlignment, range: NSRange): void;
        setAttributedString(_: NSAttributedString): void;
        setAttributesRange(_?: Map<string, any>, range?: NSRange): void;
        setBaseWritingDirectionRange(_: NSWritingDirection, range: NSRange): void;
        subscriptRange(_: NSRange): void;
        superscriptRange(_: NSRange): void;
        unscriptRange(_: NSRange): void;
        updateAttachmentsFromPath(fromPath: string): void;
    }
    class NSMutableCharacterSet extends NSCharacterSet {
        addCharactersInRange(in_: NSRange): void;
        addCharactersInString(in_: string): void;
        formIntersectionWithCharacterSet(with_: NSCharacterSet): void;
        formUnionWithCharacterSet(with_: NSCharacterSet): void;
        invert(): void;
        removeCharactersInRange(in_: NSRange): void;
        removeCharactersInString(in_: string): void;
    }
    interface NSMutableCopying {
    }
    class NSMutableData extends NSData {
        static dataWithCapacity(capacity: number): NSMutableData;
        static dataWithLength(length: number): NSMutableData;
        mutableBytes: any;
        appendBytesLength(_: any, length: number): void;
        appendData(_: NSData): void;
        compressUsingAlgorithmError(error: NSData.CompressionAlgorithm): boolean;
        decompressUsingAlgorithmError(error: NSData.CompressionAlgorithm): boolean;
        increaseLengthBy(by: number): void;
        static createWithCapacity(capacity: number): NSMutableData;
        static createWithLength(length: number): NSMutableData;
        replaceBytesInRangeWithBytes(in_: NSRange, withBytes: any): void;
        replaceBytesInRangeWithBytesLength(in_: NSRange, withBytes?: any, length?: number): void;
        resetBytesInRange(in_: NSRange): void;
        setData(_: NSData): void;
    }
    class NSMutableDictionary<KeyType, ObjectType> extends NSDictionary<KeyType, ObjectType> {
        static dictionaryWithCapacity<KeyType, ObjectType>(capacity: number): NSMutableDictionary<KeyType, ObjectType>;
        static dictionaryWithSharedKeySet<KeyType, ObjectType>(sharedKeySet: any): NSMutableDictionary<KeyType, ObjectType>;
        addEntriesFromDictionary(from: Map<KeyType, ObjectType>): void;
        removeAllObjects(): void;
        removeObjectForKey(forKey: KeyType): void;
        removeObjectsForKeys(forKeys: KeyType[]): void;
        setDictionary(_: Map<KeyType, ObjectType>): void;
        setObjectForKey(_: ObjectType, forKey: KeyType): void;
        setObjectForKeyedSubscript(_?: ObjectType, forKeyedSubscript?: KeyType): void;
    }
    class NSMutableIndexSet extends NSIndexSet {
        addIndex(_: number): void;
        addIndexes(_: NSIndexSet): void;
        addIndexesInRange(in_: NSRange): void;
        removeAllIndexes(): void;
        removeIndex(_: number): void;
        removeIndexes(_: NSIndexSet): void;
        removeIndexesInRange(in_: NSRange): void;
        shiftIndexesStartingAtIndexBy(at: number, by: number): void;
    }
    class NSMutableOrderedSet<ObjectType> extends NSOrderedSet<ObjectType> {
        static orderedSetWithCapacity<ObjectType>(capacity: number): NSMutableOrderedSet<ObjectType>;
        addObject(_: ObjectType): void;
        addObjectsCount(_?: ObjectType, count?: number): void;
        addObjectsFromArray(from: ObjectType[]): void;
        exchangeObjectAtIndexWithObjectAtIndex(at: number, withObjectAt: number): void;
        filterUsingPredicate(using: NSPredicate): void;
        insertObjectAtIndex(_: ObjectType, at: number): void;
        insertObjectsAtIndexes(_: ObjectType[], at: NSIndexSet): void;
        intersect(_: NSOrderedSet<ObjectType>): void;
        intersectSet(_: NSSet<ObjectType>): void;
        minus(_: NSOrderedSet<ObjectType>): void;
        minusSet(_: NSSet<ObjectType>): void;
        moveObjectsAtIndexesToIndex(at: NSIndexSet, to: number): void;
        removeAllObjects(): void;
        removeObject(_: ObjectType): void;
        removeObjectAtIndex(at: number): void;
        removeObjectsAtIndexes(at: NSIndexSet): void;
        removeObjectsInArray(in_: ObjectType[]): void;
        removeObjectsInRange(in_: NSRange): void;
        replaceObjectAtIndexWithObject(at: number, with_: ObjectType): void;
        replaceObjectsAtIndexesWithObjects(at: NSIndexSet, with_: ObjectType[]): void;
        replaceObjectsInRangeWithObjectsCount(in_: NSRange, with_?: ObjectType, count?: number): void;
        setObjectAtIndex(_: ObjectType, at: number): void;
        setObjectAtIndexedSubscript(_: ObjectType, atIndexedSubscript: number): void;
        sortRangeWithOptionsUsingComparator(_: NSRange, options: NSSortOptions, usingComparator: (p1: any, p2: any) => ComparisonResult): void;
        sortWithComparator(comparator: (p1: any, p2: any) => ComparisonResult): void;
        sortUsingDescriptors(using: NSSortDescriptor[]): void;
        sortWithOptionsUsingComparator(options: NSSortOptions, usingComparator: (p1: any, p2: any) => ComparisonResult): void;
        union(_: NSOrderedSet<ObjectType>): void;
        unionSet(_: NSSet<ObjectType>): void;
    }
    class NSMutableSet<ObjectType> extends NSSet<ObjectType> {
        static setWithCapacity<ObjectType>(capacity: number): NSMutableSet<ObjectType>;
        addObject(_: ObjectType): void;
        addObjectsFromArray(from: ObjectType[]): void;
        filterUsingPredicate(using: NSPredicate): void;
        intersect(_: NSSet<ObjectType>): void;
        minus(_: NSSet<ObjectType>): void;
        removeAllObjects(): void;
        removeObject(_: ObjectType): void;
        setSet(_: NSSet<ObjectType>): void;
        union(_: NSSet<ObjectType>): void;
    }
    class NSMutableString extends NSString {
        static stringWithCapacity(capacity: number): NSMutableString;
        appendString(_: string): void;
        applyTransformReverseRangeUpdatedRange(_: string, reverse: boolean, range: NSRange, updatedRange?: NSRange): boolean;
        deleteCharactersInRange(in_: NSRange): void;
        static createWithCapacity(capacity: number): NSMutableString;
        insertStringAtIndex(_: string, at: number): void;
        replaceCharactersInRangeWithString(in_: NSRange, with_: string): void;
        replaceOccurrencesOfStringWithStringOptionsRange(of: string, with_: string, options: NSString.CompareOptions, range: NSRange): number;
        setString(_: string): void;
    }
    class NSMutableURLRequest extends NSURLRequest {
        addValueForHTTPHeaderField(_: string, forHTTPHeaderField: string): void;
        setValueForHTTPHeaderField(_?: string, forHTTPHeaderField?: string): void;
    }
    class NSNameSpecifier extends NSScriptObjectSpecifier {
        name: string;
        setName(_: string): any;
        static createWithContainerClassDescriptionContainerSpecifierKeyName(containerClassDescription: NSScriptClassDescription, containerSpecifier?: NSScriptObjectSpecifier, key?: string, name?: string): NSNameSpecifier;
    }
    class NetService extends NSObject {
        static dataFromTXTRecordDictionary(_: Map<string, Data>): NSData;
        static dictionaryFromTXTRecordData(_: NSData): Map<string, Data>;
        addresses: NSData[];
        delegate: NetServiceDelegate;
        setDelegate(_: NetServiceDelegate): any;
        domain: string;
        hostName: string;
        includesPeerToPeer: boolean;
        setIncludesPeerToPeer(_: boolean): any;
        name: string;
        port: number;
        type: string;
        TXTRecordData(): NSData;
        getInputStreamOutputStream(_?: InputStream, outputStream?: OutputStream): boolean;
        static createWithDomainTypeName(domain: string, type: string, name: string): NetService;
        static createWithDomainTypeNamePort(domain: string, type: string, name: string, port: number): NetService;
        publish(): void;
        publishWithOptions(_: NetService.Options): void;
        removeFromRunLoopForMode(_: RunLoop, forMode: string): void;
        resolveWithTimeout(_: number): void;
        scheduleInRunLoopForMode(_: RunLoop, forMode: string): void;
        setTXTRecordData(_?: NSData): boolean;
        startMonitoring(): void;
        stop(): void;
        stopMonitoring(): void;
    }
    class NetServiceBrowser extends NSObject {
        delegate: NetServiceBrowserDelegate;
        setDelegate(_: NetServiceBrowserDelegate): any;
        includesPeerToPeer: boolean;
        setIncludesPeerToPeer(_: boolean): any;
        removeFromRunLoopForMode(_: RunLoop, forMode: string): void;
        scheduleInRunLoopForMode(_: RunLoop, forMode: string): void;
        searchForBrowsableDomains(): void;
        searchForRegistrationDomains(): void;
        searchForServicesOfTypeInDomain(_: string, inDomain: string): void;
        stop(): void;
    }
    interface NetServiceBrowserDelegate extends NSObject {
        netServiceBrowserDidFindDomainMoreComing?(_: NetServiceBrowser, didFindDomain: string, moreComing: boolean): void;
        netServiceBrowserDidFindServiceMoreComing?(_: NetServiceBrowser, didFindService: NetService, moreComing: boolean): void;
        netServiceBrowserDidNotSearch?(_: NetServiceBrowser, didNotSearch: Map<string, number>): void;
        netServiceBrowserDidRemoveDomainMoreComing?(_: NetServiceBrowser, didRemoveDomain: string, moreComing: boolean): void;
        netServiceBrowserDidRemoveServiceMoreComing?(_: NetServiceBrowser, didRemoveService: NetService, moreComing: boolean): void;
        netServiceBrowserDidStopSearch?(_: NetServiceBrowser): void;
        netServiceBrowserWillSearch?(_: NetServiceBrowser): void;
    }
    interface NetServiceDelegate extends NSObject {
        netServiceDidAcceptConnectionWithInputStreamOutputStream?(_: NetService, didAcceptConnectionWithInputStream: InputStream, outputStream: OutputStream): void;
        netServiceDidNotPublish?(_: NetService, didNotPublish: Map<string, number>): void;
        netServiceDidNotResolve?(_: NetService, didNotResolve: Map<string, number>): void;
        netServiceDidUpdateTXTRecordData?(_: NetService, didUpdateTXTRecordData: NSData): void;
        netServiceDidPublish?(_: NetService): void;
        netServiceDidResolveAddress?(_: NetService): void;
        netServiceDidStop?(_: NetService): void;
        netServiceWillPublish?(_: NetService): void;
        netServiceWillResolve?(_: NetService): void;
    }
    class NSNotification extends NSObject {
        name: string;
        object: any;
        userInfo: Map<any, any>;
        static createWithNameObjectUserInfo(name: string, object_?: any, userInfo?: Map<any, any>): NSNotification;
    }
    class NotificationCenter extends NSObject {
        static defaultCenter: NotificationCenter;
        addObserverSelectorNameObject(_: any, selector: string, name?: string, object_?: any): void;
        addObserverForNameWithObjectQueueUsingBlock(_?: string, object_?: any, queue?: OperationQueue, usingBlock?: (p1: NSNotification) => void): NSObject;
        postNotification(_: NSNotification): void;
        postNotificationNameObject(name: string, object_?: any): void;
        postNotificationNameObjectUserInfo(name: string, object_?: any, userInfo?: Map<any, any>): void;
        removeObserver(_: any): void;
        removeObserverNameObject(_: any, name?: string, object_?: any): void;
    }
    class NotificationQueue extends NSObject {
        static defaultQueue: NotificationQueue;
        dequeueNotificationsMatchingCoalesceMask(_: NSNotification, coalesceMask: number): void;
        enqueueNotificationPostingStyle(_: NSNotification, postingStyle: NotificationQueue.PostingStyle): void;
        enqueueNotificationPostingStyleCoalesceMaskForModes(_: NSNotification, postingStyle: NotificationQueue.PostingStyle, coalesceMask: NotificationQueue.NotificationCoalescing, forModes?: string[]): void;
        static createWithNotificationCenter(notificationCenter: NotificationCenter): NotificationQueue;
    }
    class NSNull extends NSObject {
    }
    class NSNumber extends NSValue {
        static numberWithBool(bool: boolean): number;
        static numberWithChar(char: number): number;
        static numberWithDouble(double: number): number;
        static numberWithFloat(float: number): number;
        static numberWithInt(int: number): number;
        static numberWithInteger(integer: number): number;
        static numberWithLong(long: number): number;
        static numberWithLongLong(longLong: number): number;
        static numberWithShort(short: number): number;
        static numberWithUnsignedChar(unsignedChar: number): number;
        static numberWithUnsignedInt(unsignedInt: number): number;
        static numberWithUnsignedInteger(unsignedInteger: number): number;
        static numberWithUnsignedLong(unsignedLong: number): number;
        static numberWithUnsignedLongLong(unsignedLongLong: number): number;
        static numberWithUnsignedShort(unsignedShort: number): number;
        boolValue: boolean;
        charValue: number;
        decimalValue: number;
        doubleValue: number;
        floatValue: number;
        intValue: number;
        integerValue: number;
        longLongValue: number;
        longValue: number;
        shortValue: number;
        stringValue: string;
        unsignedCharValue: number;
        unsignedIntValue: number;
        unsignedIntegerValue: number;
        unsignedLongLongValue: number;
        unsignedLongValue: number;
        unsignedShortValue: number;
        compare(_: number): ComparisonResult;
        descriptionWithLocale(withLocale?: any): string;
        static createWithBool(bool: boolean): NSNumber;
        static createWithChar(char: number): NSNumber;
        static createWithDouble(double: number): NSNumber;
        static createWithFloat(float: number): NSNumber;
        static createWithInt(int: number): NSNumber;
        static createWithInteger(integer: number): NSNumber;
        static createWithLong(long: number): NSNumber;
        static createWithLongLong(longLong: number): NSNumber;
        static createWithShort(short: number): NSNumber;
        static createWithUnsignedChar(unsignedChar: number): NSNumber;
        static createWithUnsignedInt(unsignedInt: number): NSNumber;
        static createWithUnsignedInteger(unsignedInteger: number): NSNumber;
        static createWithUnsignedLong(unsignedLong: number): NSNumber;
        static createWithUnsignedLongLong(unsignedLongLong: number): NSNumber;
        static createWithUnsignedShort(unsignedShort: number): NSNumber;
        isEqualToNumber(to: number): boolean;
    }
    class NumberFormatter extends Formatter {
        static defaultFormatterBehavior(): NumberFormatter.Behavior;
        static localizedStringFromNumberNumberStyle(_: number, numberStyle: NumberFormatter.Style): string;
        static setDefaultFormatterBehavior(_: NumberFormatter.Behavior): void;
        allowsFloats: boolean;
        setAllowsFloats(_: boolean): any;
        alwaysShowsDecimalSeparator: boolean;
        setAlwaysShowsDecimalSeparator(_: boolean): any;
        attributedStringForNil: NSAttributedString;
        setAttributedStringForNil(_: NSAttributedString): any;
        attributedStringForNotANumber: NSAttributedString;
        setAttributedStringForNotANumber(_: NSAttributedString): any;
        attributedStringForZero: NSAttributedString;
        setAttributedStringForZero(_: NSAttributedString): any;
        currencyCode: string;
        setCurrencyCode(_: string): any;
        currencyDecimalSeparator: string;
        setCurrencyDecimalSeparator(_: string): any;
        currencyGroupingSeparator: string;
        setCurrencyGroupingSeparator(_: string): any;
        currencySymbol: string;
        setCurrencySymbol(_: string): any;
        decimalSeparator: string;
        setDecimalSeparator(_: string): any;
        exponentSymbol: string;
        setExponentSymbol(_: string): any;
        format: string;
        setFormat(_: string): any;
        formatWidth: number;
        setFormatWidth(_: number): any;
        formatterBehavior: NumberFormatter.Behavior;
        setFormatterBehavior(_: NumberFormatter.Behavior): any;
        formattingContext: Formatter.Context;
        setFormattingContext(_: Formatter.Context): any;
        generatesDecimalNumbers: boolean;
        setGeneratesDecimalNumbers(_: boolean): any;
        groupingSeparator: string;
        setGroupingSeparator(_: string): any;
        groupingSize: number;
        setGroupingSize(_: number): any;
        hasThousandSeparators: boolean;
        setHasThousandSeparators(_: boolean): any;
        internationalCurrencySymbol: string;
        setInternationalCurrencySymbol(_: string): any;
        isLenient: boolean;
        setLenient(_: boolean): any;
        locale: NSLocale;
        setLocale(_: NSLocale): any;
        localizesFormat: boolean;
        setLocalizesFormat(_: boolean): any;
        maximum: number;
        setMaximum(_: number): any;
        maximumFractionDigits: number;
        setMaximumFractionDigits(_: number): any;
        maximumIntegerDigits: number;
        setMaximumIntegerDigits(_: number): any;
        maximumSignificantDigits: number;
        setMaximumSignificantDigits(_: number): any;
        minimum: number;
        setMinimum(_: number): any;
        minimumFractionDigits: number;
        setMinimumFractionDigits(_: number): any;
        minimumIntegerDigits: number;
        setMinimumIntegerDigits(_: number): any;
        minimumSignificantDigits: number;
        setMinimumSignificantDigits(_: number): any;
        minusSign: string;
        setMinusSign(_: string): any;
        multiplier: number;
        setMultiplier(_: number): any;
        negativeFormat: string;
        setNegativeFormat(_: string): any;
        negativeInfinitySymbol: string;
        setNegativeInfinitySymbol(_: string): any;
        negativePrefix: string;
        setNegativePrefix(_: string): any;
        negativeSuffix: string;
        setNegativeSuffix(_: string): any;
        nilSymbol: string;
        setNilSymbol(_: string): any;
        notANumberSymbol: string;
        setNotANumberSymbol(_: string): any;
        numberStyle: NumberFormatter.Style;
        setNumberStyle(_: NumberFormatter.Style): any;
        paddingCharacter: string;
        setPaddingCharacter(_: string): any;
        paddingPosition: NumberFormatter.PadPosition;
        setPaddingPosition(_: NumberFormatter.PadPosition): any;
        isPartialStringValidationEnabled: boolean;
        setPartialStringValidationEnabled(_: boolean): any;
        perMillSymbol: string;
        setPerMillSymbol(_: string): any;
        percentSymbol: string;
        setPercentSymbol(_: string): any;
        plusSign: string;
        setPlusSign(_: string): any;
        positiveFormat: string;
        setPositiveFormat(_: string): any;
        positiveInfinitySymbol: string;
        setPositiveInfinitySymbol(_: string): any;
        positivePrefix: string;
        setPositivePrefix(_: string): any;
        positiveSuffix: string;
        setPositiveSuffix(_: string): any;
        roundingBehavior: NSDecimalNumberHandler;
        setRoundingBehavior(_: NSDecimalNumberHandler): any;
        roundingIncrement: number;
        setRoundingIncrement(_: number): any;
        roundingMode: NumberFormatter.RoundingMode;
        setRoundingMode(_: NumberFormatter.RoundingMode): any;
        secondaryGroupingSize: number;
        setSecondaryGroupingSize(_: number): any;
        textAttributesForNegativeInfinity: Map<string, any>;
        setTextAttributesForNegativeInfinity(_: Map<string, any>): any;
        textAttributesForNegativeValues: Map<string, any>;
        setTextAttributesForNegativeValues(_: Map<string, any>): any;
        textAttributesForNil: Map<string, any>;
        setTextAttributesForNil(_: Map<string, any>): any;
        textAttributesForNotANumber: Map<string, any>;
        setTextAttributesForNotANumber(_: Map<string, any>): any;
        textAttributesForPositiveInfinity: Map<string, any>;
        setTextAttributesForPositiveInfinity(_: Map<string, any>): any;
        textAttributesForPositiveValues: Map<string, any>;
        setTextAttributesForPositiveValues(_: Map<string, any>): any;
        textAttributesForZero: Map<string, any>;
        setTextAttributesForZero(_: Map<string, any>): any;
        thousandSeparator: string;
        setThousandSeparator(_: string): any;
        usesGroupingSeparator: boolean;
        setUsesGroupingSeparator(_: boolean): any;
        usesSignificantDigits: boolean;
        setUsesSignificantDigits(_: boolean): any;
        zeroSymbol: string;
        setZeroSymbol(_: string): any;
        getObjectValueForStringRangeError(forString?: any, range?: string, error?: NSRange): boolean;
        numberFromString(_: string): number;
        stringFromNumber(_: number): string;
    }
    class Operation extends NSObject {
        isAsynchronous: boolean;
        isCancelled: boolean;
        completionBlock: () => void;
        setCompletionBlock(_: () => void): any;
        isConcurrent: boolean;
        dependencies: Operation[];
        isExecuting: boolean;
        isFinished: boolean;
        name: string;
        setName(_: string): any;
        qualityOfService: QualityOfService;
        setQualityOfService(_: QualityOfService): any;
        queuePriority: Operation.QueuePriority;
        setQueuePriority(_: Operation.QueuePriority): any;
        isReady: boolean;
        addDependency(_: Operation): void;
        cancel(): void;
        main(): void;
        removeDependency(_: Operation): void;
        start(): void;
        waitUntilFinished(): void;
    }
    class OperationQueue extends NSObject {
        maxConcurrentOperationCount: number;
        setMaxConcurrentOperationCount(_: number): any;
        name: string;
        setName(_: string): any;
        operationCount: number;
        operations: Operation[];
        qualityOfService: QualityOfService;
        setQualityOfService(_: QualityOfService): any;
        isSuspended: boolean;
        setSuspended(_: boolean): any;
        underlyingQueue: NSObject;
        setUnderlyingQueue(_: NSObject): any;
        static currentQueue: OperationQueue;
        static mainQueue: OperationQueue;
        addBarrierBlock(_: () => void): void;
        addOperation(_: Operation): void;
        addOperationWithBlock(_: () => void): void;
        addOperationsWaitUntilFinished(_: Operation[], waitUntilFinished: boolean): void;
        cancelAllOperations(): void;
        waitUntilAllOperationsAreFinished(): void;
    }
    class NSOrderedCollectionChange<ObjectType> extends NSObject {
        associatedIndex: number;
        changeType: NSCollectionChangeType;
        index: number;
        object: ObjectType;
    }
    class NSOrderedCollectionDifference<ObjectType> extends NSObject {
        hasChanges: boolean;
        insertions: NSOrderedCollectionChange<ObjectType>[];
        removals: NSOrderedCollectionChange<ObjectType>[];
        transformingChanges(_: (p1: NSOrderedCollectionChange<ObjectType>) => NSOrderedCollectionChange<any>): NSOrderedCollectionDifference<any>;
        inverseDifference(): NSOrderedCollectionDifference<ObjectType>;
    }
    class NSOrderedSet<ObjectType> extends NSObject {
        static orderedSetWithObjects<ObjectType>(_: ObjectType): NSOrderedSet<ObjectType>;
        array: ObjectType[];
        count: number;
        firstObject: ObjectType;
        lastObject: ObjectType;
        reversedOrderedSet: NSOrderedSet<ObjectType>;
        set: NSSet<ObjectType>;
        containsObject(_: ObjectType): boolean;
        descriptionWithLocale(withLocale?: any): string;
        descriptionWithLocaleIndent(withLocale?: any, indent?: number): string;
        enumerateObjectsWithAtOptionsUsing(at: NSIndexSet, options: NSEnumerationOptions, using: (p1: ObjectType, p2: number, p3: boolean) => void): void;
        enumerateObjects(_: (p1: ObjectType, p2: number, p3: boolean) => void): void;
        enumerateObjectsWithOptionsUsing(options: NSEnumerationOptions, using: (p1: ObjectType, p2: number, p3: boolean) => void): void;
        filteredOrderedSetUsingPredicate(using: NSPredicate): NSOrderedSet<ObjectType>;
        indexOfObject(of: ObjectType): number;
        indexOfInSortedRangeOptionsUsingComparator(of: ObjectType, inSortedRange: NSRange, options: NSBinarySearchingOptions, usingComparator: (p1: any, p2: any) => ComparisonResult): number;
        indexWithOfObjectAtOptionsPassingTest(ofObjectAt: NSIndexSet, options: NSEnumerationOptions, passingTest: (p1: ObjectType, p2: number, p3: boolean) => boolean): number;
        indexWithOfObjectPassingTest(ofObjectPassingTest: (p1: ObjectType, p2: number, p3: boolean) => boolean): number;
        indexOfObjectPassingTest(_: NSEnumerationOptions, ofObjectPassingTest: (p1: ObjectType, p2: number, p3: boolean) => boolean): number;
        indexesWithOfObjectsAtOptionsPassingTest(ofObjectsAt: NSIndexSet, options: NSEnumerationOptions, passingTest: (p1: ObjectType, p2: number, p3: boolean) => boolean): NSIndexSet;
        indexesWithOfObjectsPassingTest(ofObjectsPassingTest: (p1: ObjectType, p2: number, p3: boolean) => boolean): NSIndexSet;
        indexesWithOptionsOfObjectsPassingTest(options: NSEnumerationOptions, ofObjectsPassingTest: (p1: ObjectType, p2: number, p3: boolean) => boolean): NSIndexSet;
        intersects(_: NSOrderedSet<ObjectType>): boolean;
        intersectsSet(_: NSSet<ObjectType>): boolean;
        isEqualWithTo(to: NSOrderedSet<ObjectType>): boolean;
        isSubsetOf(of: NSOrderedSet<ObjectType>): boolean;
        isSubsetOf(of: NSSet<ObjectType>): boolean;
        objectAtIndex(at: number): ObjectType;
        objectEnumerator(): NSEnumerator<ObjectType>;
        objectsAtIndexes(at: NSIndexSet): ObjectType[];
        reverseObjectEnumerator(): NSEnumerator<ObjectType>;
        sortedArrayWithComparator(comparator: (p1: any, p2: any) => ComparisonResult): ObjectType[];
        sortedArrayUsingDescriptors(using: NSSortDescriptor[]): ObjectType[];
        sortedArrayWithOptionsUsingComparator(options: NSSortOptions, usingComparator: (p1: any, p2: any) => ComparisonResult): ObjectType[];
    }
    class NSOrthography extends NSObject {
        static defaultOrthographyForLanguage(forLanguage: string): NSOrthography;
        allLanguages: string[];
        allScripts: string[];
        dominantLanguage: string;
        dominantScript: string;
        languageMap: Map<string, string[]>;
        dominantLanguageForScript(forScript: string): string;
        static createWithDominantScriptLanguageMap(dominantScript: string, languageMap: Map<string, string[]>): NSOrthography;
        languagesForScript(forScript: string): string[];
    }
    class OutputStream extends Stream {
        static outputStreamToBufferCapacity(_: string, capacity: number): OutputStream;
        static outputStreamToFileAtPathAppend(_: string, append: boolean): OutputStream;
        static outputStreamToMemory(): OutputStream;
        static outputStreamWithURLAppend(_: NSURL, append: boolean): OutputStream;
        hasSpaceAvailable: boolean;
        static createWithToBufferCapacity(toBuffer: string, capacity: number): OutputStream;
        static createWithToFileAtPathAppend(toFileAtPath: string, append: boolean): OutputStream;
        static createWithToMemory(): OutputStream;
        static createWithUrlAppend(URL: NSURL, append: boolean): OutputStream;
        writeMaxLength(_: string, maxLength: number): number;
    }
    class NSPersonNameComponents extends NSObject {
        familyName: string;
        setFamilyName(_: string): any;
        givenName: string;
        setGivenName(_: string): any;
        middleName: string;
        setMiddleName(_: string): any;
        namePrefix: string;
        setNamePrefix(_: string): any;
        nameSuffix: string;
        setNameSuffix(_: string): any;
        nickname: string;
        setNickname(_: string): any;
        phoneticRepresentation: NSPersonNameComponents;
        setPhoneticRepresentation(_: NSPersonNameComponents): any;
    }
    class PersonNameComponentsFormatter extends Formatter {
        static localizedStringFromPersonNameComponentsStyleOptions(_: NSPersonNameComponents, style: PersonNameComponentsFormatter.Style, options: PersonNameComponentsFormatter.Options): string;
        isPhonetic: boolean;
        setPhonetic(_: boolean): any;
        style: PersonNameComponentsFormatter.Style;
        setStyle(_: PersonNameComponentsFormatter.Style): any;
        annotatedStringFromPersonNameComponents(_: NSPersonNameComponents): NSAttributedString;
        personNameComponentsFromString(_: string): NSPersonNameComponents;
        stringFromPersonNameComponents(_: NSPersonNameComponents): string;
    }
    class Pipe extends NSObject {
        static pipe(): Pipe;
        fileHandleForReading: FileHandle;
        fileHandleForWriting: FileHandle;
    }
    class NSPointerArray extends NSObject {
        static strongObjectsPointerArray(): NSPointerArray;
        static weakObjectsPointerArray(): NSPointerArray;
        allObjects: any[];
        count: number;
        setCount(_: number): any;
        pointerFunctions: NSPointerFunctions;
        addPointer(_?: any): void;
        compact(): void;
        static createWithOptions(options: NSPointerFunctions.Options): NSPointerArray;
        static createWithPointerFunctions(pointerFunctions: NSPointerFunctions): NSPointerArray;
        insertPointerAtIndex(_?: any, at?: number): void;
        pointerAtIndex(at: number): any;
        removePointerAtIndex(at: number): void;
        replacePointerAtIndexWithPointer(at: number, withPointer?: any): void;
    }
    class NSPointerFunctions extends NSObject {
        acquireFunction: (p1: any, p2: (p1: any) => number, p3: boolean) => any;
        setAcquireFunction(_: (p1: any, p2: (p1: any) => number, p3: boolean) => any): any;
        descriptionFunction: (p1: any) => string;
        setDescriptionFunction(_: (p1: any) => string): any;
        hashFunction: (p1: any, p2: (p1: any) => number) => number;
        setHashFunction(_: (p1: any, p2: (p1: any) => number) => number): any;
        isEqualFunction: (p1: any, p2: any, p3: (p1: any) => number) => boolean;
        setIsEqualFunction(_: (p1: any, p2: any, p3: (p1: any) => number) => boolean): any;
        relinquishFunction: (p1: any, p2: (p1: any) => number) => void;
        setRelinquishFunction(_: (p1: any, p2: (p1: any) => number) => void): any;
        sizeFunction: (p1: any) => number;
        setSizeFunction(_: (p1: any) => number): any;
        static createWithOptions(options: NSPointerFunctions.Options): NSPointerFunctions;
    }
    class Port extends NSObject {
        reservedSpaceLength: number;
        isValid: boolean;
        delegate(): PortDelegate;
        invalidate(): void;
        removeFromRunLoopForMode(_: RunLoop, forMode: string): void;
        scheduleInRunLoopForMode(_: RunLoop, forMode: string): void;
        sendBeforeDateComponentsFromReserved(_: Date, components?: NSMutableArray<any>, from?: Port, reserved?: number): boolean;
        sendBeforeDateMsgidComponentsFromReserved(_: Date, msgid: number, components?: NSMutableArray<any>, from?: Port, reserved?: number): boolean;
        setDelegate(_?: PortDelegate): void;
    }
    interface PortDelegate extends NSObject {
        handlePortMessage?(_: PortMessage): void;
    }
    class PortMessage extends NSObject {
        components: any[];
        msgid: number;
        setMsgid(_: number): any;
        receivePort: Port;
        sendPort: Port;
        static createWithSendPortReceivePortComponents(sendPort?: Port, receivePort?: Port, components?: any[]): PortMessage;
        sendBeforeDate(_: Date): boolean;
    }
    class NSPositionalSpecifier extends NSObject {
        insertionContainer: any;
        insertionIndex: number;
        insertionKey: string;
        insertionReplaces: boolean;
        position: NSPositionalSpecifier.InsertionPosition;
        evaluate(): void;
        static createWithPositionObjectSpecifier(position: NSPositionalSpecifier.InsertionPosition, objectSpecifier: NSScriptObjectSpecifier): NSPositionalSpecifier;
        setInsertionClassDescription(_: NSScriptClassDescription): void;
    }
    class NSPredicate extends NSObject {
        predicateFormat: string;
        allowEvaluation(): void;
        evaluateWithObject(with_?: any): boolean;
        evaluateWithObjectSubstitutionVariables(with_?: any, substitutionVariables?: Map<string, any>): boolean;
        predicateWithSubstitutionVariables(_: Map<string, any>): NSPredicate;
    }
    class ProcessInfo extends NSObject {
        activeProcessorCount: number;
        arguments: string[];
        automaticTerminationSupportEnabled: boolean;
        setAutomaticTerminationSupportEnabled(_: boolean): any;
        environment: Map<string, string>;
        fullUserName: string;
        globallyUniqueString: string;
        hostName: string;
        isMacCatalystApp: boolean;
        operatingSystemVersion: OperatingSystemVersion;
        operatingSystemVersionString: string;
        physicalMemory: number;
        processIdentifier: number;
        processName: string;
        setProcessName(_: string): any;
        processorCount: number;
        systemUptime: number;
        thermalState: ProcessInfo.ThermalState;
        userName: string;
        static processInfo: ProcessInfo;
        beginActivityWithOptionsReason(_: ProcessInfo.ActivityOptions, reason: string): NSObject;
        disableAutomaticTermination(_: string): void;
        disableSuddenTermination(): void;
        enableAutomaticTermination(_: string): void;
        enableSuddenTermination(): void;
        endActivity(_: NSObject): void;
        isOperatingSystemAtLeastVersion(_: OperatingSystemVersion): boolean;
        performActivityWithOptionsWithReasonUsingBlock(_: ProcessInfo.ActivityOptions, reason: string, usingBlock: () => void): void;
    }
    class Progress extends NSObject {
        static addSubscriberForFileURLWithWithPublishingHandler(_: NSURL, withPublishingHandler: (p1: Progress) => () => void): any;
        static currentProgress(): Progress;
        static discreteProgressWithTotalUnitCount(totalUnitCount: number): Progress;
        static removeSubscriber(_: any): void;
        isCancellable: boolean;
        setCancellable(_: boolean): any;
        cancellationHandler: () => void;
        setCancellationHandler(_: () => void): any;
        isCancelled: boolean;
        completedUnitCount: number;
        setCompletedUnitCount(_: number): any;
        estimatedTimeRemaining: number;
        setEstimatedTimeRemaining(_: number): any;
        fileCompletedCount: number;
        setFileCompletedCount(_: number): any;
        fileOperationKind: string;
        setFileOperationKind(_: string): any;
        fileTotalCount: number;
        setFileTotalCount(_: number): any;
        fileURL: NSURL;
        setFileURL(_: NSURL): any;
        isFinished: boolean;
        fractionCompleted: number;
        isIndeterminate: boolean;
        kind: string;
        setKind(_: string): any;
        localizedAdditionalDescription: string;
        setLocalizedAdditionalDescription(_: string): any;
        localizedDescription: string;
        setLocalizedDescription(_: string): any;
        isOld: boolean;
        isPausable: boolean;
        setPausable(_: boolean): any;
        isPaused: boolean;
        pausingHandler: () => void;
        setPausingHandler(_: () => void): any;
        resumingHandler: () => void;
        setResumingHandler(_: () => void): any;
        throughput: number;
        setThroughput(_: number): any;
        totalUnitCount: number;
        setTotalUnitCount(_: number): any;
        userInfo: Map<string, any>;
        addChildWithPendingUnitCount(_: Progress, withPendingUnitCount: number): void;
        becomeCurrentWithPendingUnitCount(_: number): void;
        cancel(): void;
        static createWithParentUserInfo(parent?: Progress, userInfo?: Map<string, any>): Progress;
        pause(): void;
        performAsCurrentWithPendingUnitCountWithUsingBlock(_: number, usingBlock: () => void): void;
        publish(): void;
        resignCurrent(): void;
        resume(): void;
        setUserInfoObjectForKey(_?: any, forKey?: string): void;
        unpublish(): void;
    }
    interface ProgressReporting extends NSObject {
        progress: Progress;
    }
    class PropertyListSerialization extends NSObject {
        static dataWithPropertyListFormatOptionsError(fromPropertyList: any, format: PropertyListSerialization.PropertyListFormat, options: number): NSData;
        static propertyListIsValidForFormat(_: any, isValidForFormat: PropertyListSerialization.PropertyListFormat): boolean;
        static propertyListWithDataOptionsFormatError(from: NSData, options: PropertyListSerialization.MutabilityOptions, format?: PropertyListSerialization.PropertyListFormat): any;
        static propertyListWithStreamOptionsFormatError(options: InputStream, format: PropertyListSerialization.MutabilityOptions, error?: PropertyListSerialization.PropertyListFormat): any;
        static writePropertyListToStreamFormatOptionsError(toStream: any, format: OutputStream, options: PropertyListSerialization.PropertyListFormat, error: number): number;
    }
    class NSPropertySpecifier extends NSScriptObjectSpecifier {
    }
    class NSProtocolChecker extends NSProxy {
        protocol: any;
        target: NSObject;
        static createWithTargetProtocol(target: NSObject, protocol: any): NSProtocolChecker;
    }
    class NSProxy {
        static alloc(): NSProxy;
        static class(): typeof NSObject;
        static respondsToSelector(to: string): boolean;
        dealloc(): void;
        finalize(): void;
    }
    class NSPurgeableData extends NSMutableData {
    }
    class NSQuitCommand extends NSScriptCommand {
        saveOptions: NSSaveOptions;
    }
    class NSRandomSpecifier extends NSScriptObjectSpecifier {
    }
    class NSRangeSpecifier extends NSScriptObjectSpecifier {
        endSpecifier: NSScriptObjectSpecifier;
        setEndSpecifier(_: NSScriptObjectSpecifier): any;
        startSpecifier: NSScriptObjectSpecifier;
        setStartSpecifier(_: NSScriptObjectSpecifier): any;
        static createWithContainerClassDescriptionContainerSpecifierKeyStartSpecifierEndSpecifier(containerClassDescription: NSScriptClassDescription, containerSpecifier?: NSScriptObjectSpecifier, key?: string, startSpecifier?: NSScriptObjectSpecifier, endSpecifier?: NSScriptObjectSpecifier): NSRangeSpecifier;
    }
    class NSRecursiveLock extends NSObject {
        name: string;
        setName(_: string): any;
        lockBeforeDate(before: Date): boolean;
        tryLock(): boolean;
    }
    class NSRegularExpression extends NSObject {
        static escapedPatternForString(for_: string): string;
        static escapedTemplateForString(for_: string): string;
        static regularExpressionWithPatternOptionsError(options: string, error: NSRegularExpression.Options): NSRegularExpression;
        numberOfCaptureGroups: number;
        options: NSRegularExpression.Options;
        pattern: string;
        enumerateMatchesWithInOptionsRangeUsing(in_: string, options: NSRegularExpression.MatchingOptions, range: NSRange, using?: (p1: NSTextCheckingResult, p2: NSRegularExpression.MatchingFlags, p3: boolean) => void): void;
        firstMatchInStringOptionsRange(in_: string, options: NSRegularExpression.MatchingOptions, range: NSRange): NSTextCheckingResult;
        static createWithPatternOptions(pattern: string, options: NSRegularExpression.Options): NSRegularExpression;
        matchesInStringOptionsRange(in_: string, options: NSRegularExpression.MatchingOptions, range: NSRange): NSTextCheckingResult[];
        numberOfMatchesInStringOptionsRange(in_: string, options: NSRegularExpression.MatchingOptions, range: NSRange): number;
        rangeOfFirstMatchInStringOptionsRange(in_: string, options: NSRegularExpression.MatchingOptions, range: NSRange): NSRange;
        replaceMatchesInStringOptionsRangeWithTemplate(in_: NSMutableString, options: NSRegularExpression.MatchingOptions, range: NSRange, withTemplate: string): number;
        replacementStringForResultInStringOffsetTemplate(for_: NSTextCheckingResult, in_: string, offset: number, template: string): string;
        stringByReplacingMatchesInStringOptionsRangeWithTemplate(in_: string, options: NSRegularExpression.MatchingOptions, range: NSRange, withTemplate: string): string;
    }
    class RelativeDateTimeFormatter extends Formatter {
        calendar: NSCalendar;
        setCalendar(_: NSCalendar): any;
        dateTimeStyle: RelativeDateTimeFormatter.DateTimeStyle;
        setDateTimeStyle(_: RelativeDateTimeFormatter.DateTimeStyle): any;
        formattingContext: Formatter.Context;
        setFormattingContext(_: Formatter.Context): any;
        locale: NSLocale;
        setLocale(_: NSLocale): any;
        unitsStyle: RelativeDateTimeFormatter.UnitsStyle;
        setUnitsStyle(_: RelativeDateTimeFormatter.UnitsStyle): any;
        localizedStringForDateRelativeToDate(_: Date, relativeToDate: Date): string;
        localizedStringFromDateComponents(_: NSDateComponents): string;
        localizedStringFromTimeInterval(_: number): string;
    }
    class NSRelativeSpecifier extends NSScriptObjectSpecifier {
        baseSpecifier: NSScriptObjectSpecifier;
        setBaseSpecifier(_: NSScriptObjectSpecifier): any;
        relativePosition: NSRelativeSpecifier.RelativePosition;
        setRelativePosition(_: NSRelativeSpecifier.RelativePosition): any;
        static createWithContainerClassDescriptionContainerSpecifierKeyRelativePositionBaseSpecifier(containerClassDescription: NSScriptClassDescription, containerSpecifier?: NSScriptObjectSpecifier, key?: string, relativePosition?: NSRelativeSpecifier.RelativePosition, baseSpecifier?: NSScriptObjectSpecifier): NSRelativeSpecifier;
    }
    class RunLoop extends NSObject {
        currentMode: string;
        static currentRunLoop: RunLoop;
        static mainRunLoop: RunLoop;
        acceptInputForModeBeforeDate(_: string, beforeDate: Date): void;
        addPortForMode(_: Port, forMode: string): void;
        addTimerForMode(_: Timer, forMode: string): void;
        cancelPerformSelectorTargetArgument(_: string, target: any, argument?: any): void;
        cancelPerformSelectorsWithTarget(_: any): void;
        getCFRunLoop(): any;
        limitDateForMode(_: string): Date;
        performBlock(_: () => void): void;
        performInModesWithBlock(_: string[], block: () => void): void;
        performSelectorTargetArgumentOrderModes(_: string, target: any, argument?: any, order?: number, modes?: string[]): void;
        removePortForMode(_: Port, forMode: string): void;
        run(): void;
        runModeBeforeDate(mode: string, before: Date): boolean;
        runUntilDate(_: Date): void;
    }
    class Scanner extends NSObject {
        static localizedScannerWithString(_: string): any;
        isAtEnd: boolean;
        caseSensitive: boolean;
        setCaseSensitive(_: boolean): any;
        charactersToBeSkipped: NSCharacterSet;
        setCharactersToBeSkipped(_: NSCharacterSet): any;
        locale: any;
        setLocale(_: any): any;
        string: string;
        static createWithString(string: string): Scanner;
        scanHexDouble(_?: number): boolean;
        scanHexFloat(_?: number): boolean;
        scanHexLongLong(_?: number): boolean;
        scanInt(_?: number): boolean;
        scanInteger(_?: number): boolean;
        scanLongLong(_?: number): boolean;
        scanUnsignedLongLong(_?: number): boolean;
    }
    class NSScriptClassDescription extends NSClassDescription {
        appleEventCode: number;
        defaultSubcontainerAttributeKey: string;
        implementationClassName: string;
        suiteName: string;
        superclassDescription: NSScriptClassDescription;
        appleEventCodeForKey(forKey: string): number;
        classDescriptionForKey(_: string): NSScriptClassDescription;
        hasOrderedToManyRelationshipForKey(forKey: string): boolean;
        hasPropertyForKey(forKey: string): boolean;
        hasReadablePropertyForKey(forKey: string): boolean;
        hasWritablePropertyForKey(forKey: string): boolean;
        static createWithSuiteNameClassNameDictionary(suiteName: string, className: string, dictionary?: Map<any, any>): NSScriptClassDescription;
        isLocationRequiredToCreateForKey(forKey: string): boolean;
        keyWithAppleEventCode(withAppleEventCode: number): string;
        matchesAppleEventCode(_: number): boolean;
        selectorForCommand(forCommand: NSScriptCommandDescription): string;
        supportsCommand(_: NSScriptCommandDescription): boolean;
        typeForKey(forKey: string): string;
    }
    class NSScriptCoercionHandler extends NSObject {
        static sharedCoercionHandler(): NSScriptCoercionHandler;
        coerceValueToClass(_: any, to: typeof NSObject): any;
        registerCoercerSelectorToConvertFromClassToClass(_: any, selector: string, toConvertFrom: typeof NSObject, to: typeof NSObject): void;
    }
    class NSScriptCommand extends NSObject {
        static currentCommand(): NSScriptCommand;
        appleEvent: NSAppleEventDescriptor;
        arguments: Map<string, any>;
        setArguments(_: Map<string, any>): any;
        commandDescription: NSScriptCommandDescription;
        directParameter: any;
        setDirectParameter(_: any): any;
        evaluatedArguments: Map<string, any>;
        evaluatedReceivers: any;
        receiversSpecifier: NSScriptObjectSpecifier;
        setReceiversSpecifier(_: NSScriptObjectSpecifier): any;
        scriptErrorExpectedTypeDescriptor: NSAppleEventDescriptor;
        setScriptErrorExpectedTypeDescriptor(_: NSAppleEventDescriptor): any;
        scriptErrorNumber: number;
        setScriptErrorNumber(_: number): any;
        scriptErrorOffendingObjectDescriptor: NSAppleEventDescriptor;
        setScriptErrorOffendingObjectDescriptor(_: NSAppleEventDescriptor): any;
        scriptErrorString: string;
        setScriptErrorString(_: string): any;
        isWellFormed: boolean;
        executeCommand(): any;
        static createWithCommandDescription(commandDescription: NSScriptCommandDescription): NSScriptCommand;
        performDefaultImplementation(): any;
        resumeExecutionWithResult(withResult?: any): void;
        suspendExecution(): void;
    }
    class NSScriptCommandDescription extends NSObject {
        appleEventClassCode: number;
        appleEventCode: number;
        appleEventCodeForReturnType: number;
        argumentNames: string[];
        commandClassName: string;
        commandName: string;
        returnType: string;
        suiteName: string;
        appleEventCodeForArgumentWithName(withName: string): number;
        createCommandInstance(): NSScriptCommand;
        createCommandInstanceWithZone(with_?: any): NSScriptCommand;
        static createWithSuiteNameCommandNameDictionary(suiteName: string, commandName: string, dictionary?: Map<any, any>): NSScriptCommandDescription;
        isOptionalArgumentWithName(withName: string): boolean;
        typeForArgumentWithName(withName: string): string;
    }
    class NSScriptExecutionContext extends NSObject {
        static sharedScriptExecutionContext(): NSScriptExecutionContext;
        objectBeingTested: any;
        setObjectBeingTested(_: any): any;
        rangeContainerObject: any;
        setRangeContainerObject(_: any): any;
        topLevelObject: any;
        setTopLevelObject(_: any): any;
    }
    class NSScriptObjectSpecifier extends NSObject {
        static objectSpecifierWithDescriptor(descriptor: NSAppleEventDescriptor): NSScriptObjectSpecifier;
        childSpecifier: NSScriptObjectSpecifier;
        setChildSpecifier(_: NSScriptObjectSpecifier): any;
        containerClassDescription: NSScriptClassDescription;
        setContainerClassDescription(_: NSScriptClassDescription): any;
        containerIsObjectBeingTested: boolean;
        setContainerIsObjectBeingTested(_: boolean): any;
        containerIsRangeContainerObject: boolean;
        setContainerIsRangeContainerObject(_: boolean): any;
        containerSpecifier: NSScriptObjectSpecifier;
        setContainerSpecifier(_: NSScriptObjectSpecifier): any;
        descriptor: NSAppleEventDescriptor;
        evaluationErrorNumber: number;
        setEvaluationErrorNumber(_: number): any;
        evaluationErrorSpecifier: NSScriptObjectSpecifier;
        key: string;
        setKey(_: string): any;
        keyClassDescription: NSScriptClassDescription;
        objectsByEvaluatingSpecifier: any;
        indicesOfObjectsByEvaluatingWithContainerCount(withContainer: any, count: number): number;
        static createWithContainerClassDescriptionContainerSpecifierKey(containerClassDescription: NSScriptClassDescription, containerSpecifier?: NSScriptObjectSpecifier, key?: string): NSScriptObjectSpecifier;
        static createWithContainerSpecifierKey(containerSpecifier: NSScriptObjectSpecifier, key: string): NSScriptObjectSpecifier;
        objectsByEvaluatingWithContainers(withContainers: any): any;
    }
    class NSScriptSuiteRegistry extends NSObject {
        static setSharedScriptSuiteRegistry(_: NSScriptSuiteRegistry): void;
        static sharedScriptSuiteRegistry(): NSScriptSuiteRegistry;
        suiteNames: string[];
        aeteResource(_: string): NSData;
        appleEventCodeForSuite(forSuite: string): number;
        bundleForSuite(forSuite: string): Bundle;
        classDescriptionWithAppleEventCode(withAppleEventCode: number): NSScriptClassDescription;
        classDescriptionsInSuite(inSuite: string): Map<string, NSScriptClassDescription>;
        commandDescriptionWithAppleEventClassAndAppleEventCode(withAppleEventClass: number, andAppleEventCode: number): NSScriptCommandDescription;
        commandDescriptionsInSuite(inSuite: string): Map<string, NSScriptCommandDescription>;
        loadSuiteWithDictionaryFromBundle(with_: Map<any, any>, from: Bundle): void;
        loadSuitesFromBundle(from: Bundle): void;
        registerClassDescription(_: NSScriptClassDescription): void;
        registerCommandDescription(_: NSScriptCommandDescription): void;
        suiteForAppleEventCode(forAppleEventCode: number): string;
    }
    class NSScriptWhoseTest extends NSObject {
        isTrue(): boolean;
    }
    type NSSecureCoding = NSCoding;
    class NSSecureUnarchiveFromDataTransformer extends ValueTransformer {
        static allowedTopLevelClasses: typeof NSObject[];
    }
    class NSSet<ObjectType> extends NSObject {
        static setWithObjects<ObjectType>(_: ObjectType): NSSet<ObjectType>;
        allObjects: ObjectType[];
        count: number;
        anyObject(): ObjectType;
        containsObject(_: ObjectType): boolean;
        descriptionWithLocale(withLocale?: any): string;
        enumerateIndexPathsWithOptionsUsing(options: NSEnumerationOptions, using: (p1: NSIndexPath, p2: boolean) => void): void;
        enumerateObjects(_: (p1: ObjectType, p2: boolean) => void): void;
        enumerateObjectsWithOptionsUsing(options: NSEnumerationOptions, using: (p1: ObjectType, p2: boolean) => void): void;
        filteredSetUsingPredicate(using: NSPredicate): NSSet<ObjectType>;
        intersects(_: NSSet<ObjectType>): boolean;
        isEqualWithTo(to: NSSet<ObjectType>): boolean;
        isSubsetOf(of: NSSet<ObjectType>): boolean;
        member(_: ObjectType): ObjectType;
        objectEnumerator(): NSEnumerator<ObjectType>;
        objectsWithPassingTest(passingTest: (p1: ObjectType, p2: boolean) => boolean): NSSet<ObjectType>;
        objectsWithOptionsPassingTest(options: NSEnumerationOptions, passingTest: (p1: ObjectType, p2: boolean) => boolean): NSSet<ObjectType>;
        setByAddingObject(_: ObjectType): NSSet<ObjectType>;
        setByAddingObjectsFromArray(from: ObjectType[]): NSSet<ObjectType>;
        addingObjectsWithFrom(from: NSSet<ObjectType>): NSSet<ObjectType>;
        sortedArrayUsingDescriptors(using: NSSortDescriptor[]): ObjectType[];
    }
    class NSSetCommand extends NSScriptCommand {
        keySpecifier: NSScriptObjectSpecifier;
        setReceiversSpecifier(_?: NSScriptObjectSpecifier): void;
    }
    class SocketPort extends Port {
        address: NSData;
        protocol: number;
        protocolFamily: number;
        socket: number;
        socketType: number;
        static createWithRemoteWithProtocolFamilySocketTypeProtocolAddress(remoteWithProtocolFamily: number, socketType: number, protocol: number, address: NSData): SocketPort;
        static createWithRemoteWithTCPPortHost(remoteWithTCPPort: number, host?: string): SocketPort;
        static createWithProtocolFamilySocketTypeProtocolAddress(protocolFamily: number, socketType: number, protocol: number, address: NSData): SocketPort;
        static createWithProtocolFamilySocketTypeProtocolSocket(protocolFamily: number, socketType: number, protocol: number, socket: number): SocketPort;
        static createWithTCPPort(TCPPort: number): SocketPort;
    }
    class NSSortDescriptor extends NSObject {
        ascending: boolean;
        comparator: (p1: any, p2: any) => ComparisonResult;
        key: string;
        reversedSortDescriptor: any;
        selector: string;
        allowEvaluation(): void;
        compareObjectToObject(_: any, to: any): ComparisonResult;
        static createWithKeyAscending(key?: string, ascending?: boolean): NSSortDescriptor;
        static createWithKeyAscendingComparator(key?: string, ascending?: boolean, comparator?: (p1: any, p2: any) => ComparisonResult): NSSortDescriptor;
        static createWithKeyAscendingSelector(key?: string, ascending?: boolean, selector?: string): NSSortDescriptor;
    }
    class NSSpecifierTest extends NSScriptWhoseTest {
        static createWithObjectSpecifierComparisonOperatorTestObject(objectSpecifier?: NSScriptObjectSpecifier, comparisonOperator?: NSSpecifierTest.TestComparisonOperation, testObject?: any): NSSpecifierTest;
    }
    class NSSpellServer extends NSObject {
        delegate: NSSpellServerDelegate;
        setDelegate(_: NSSpellServerDelegate): any;
        isWordInUserDictionariesCaseSensitive(inUserDictionaries: string, caseSensitive: boolean): boolean;
        registerLanguageByVendor(_?: string, byVendor?: string): boolean;
        run(): void;
    }
    interface NSSpellServerDelegate extends NSObject {
        spellServerFindMisspelledWordInStringLanguageWordCountCountOnly?(_: NSSpellServer, findMisspelledWordIn: string, language: string, wordCount: number, countOnly: boolean): NSRange;
        spellServerSuggestCompletionsForPartialWordRangeInStringLanguage?(_: NSSpellServer, suggestCompletionsForPartialWordRange: NSRange, in_: string, language: string): string[];
        spellServerCheckGrammarInStringLanguageDetails?(_: NSSpellServer, checkGrammarIn: string, language?: string, details?: Map<string, any>[]): NSRange;
        spellServerCheckStringOffsetTypesOptionsOrthographyWordCount?(_: NSSpellServer, check: string, offset: number, types: number, options?: Map<string, any>, orthography?: NSOrthography, wordCount?: number): NSTextCheckingResult[];
        spellServerDidForgetWordInLanguage?(_: NSSpellServer, didForgetWord: string, inLanguage: string): void;
        spellServerDidLearnWordInLanguage?(_: NSSpellServer, didLearnWord: string, inLanguage: string): void;
        spellServerRecordResponseToCorrectionForWordLanguage?(_: NSSpellServer, recordResponse: number, toCorrection: string, forWord: string, language: string): void;
        spellServerSuggestGuessesForWordInLanguage?(_: NSSpellServer, suggestGuessesForWord: string, inLanguage: string): string[];
    }
    class Stream extends NSObject {
        static getBoundStreamsWithBufferSizeInputStreamOutputStream(_: number, inputStream?: InputStream, outputStream?: OutputStream): void;
        static getStreamsToHostWithNamePortInputStreamOutputStream(_: string, port: number, inputStream?: InputStream, outputStream?: OutputStream): void;
        delegate: StreamDelegate;
        setDelegate(_: StreamDelegate): any;
        streamError: NSError;
        streamStatus: Stream.Status;
        close(): void;
        open(): void;
        propertyForKey(_: string): any;
        removeFromRunLoopForMode(_: RunLoop, forMode: string): void;
        scheduleInRunLoopForMode(_: RunLoop, forMode: string): void;
        setPropertyForKey(_?: any, forKey?: string): boolean;
    }
    interface StreamDelegate extends NSObject {
        streamHandleEvent?(_: Stream, handleEvent: Stream.Event): void;
    }
    class NSString extends NSObject {
        static localizedNameOfStringEncoding(of: number): string;
        static pathWithComponents(withComponents: string[]): string;
        static stringEncodingForDataEncodingOptionsConvertedStringUsedLossyConversion(for_: NSData, encodingOptions?: Map<string, any>, convertedString?: string, usedLossyConversion?: boolean): number;
        static stringWithContentsOfFileEncodingError(encoding: string, error: number): NSString;
        static stringWithContentsOfFileUsedEncodingError(usedEncoding: string, error?: number): NSString;
        static stringWithContentsOfURLEncodingError(encoding: NSURL, error: number): NSString;
        static stringWithContentsOfURLUsedEncodingError(usedEncoding: NSURL, error?: number): NSString;
        UTF8String: string;
        isAbsolutePath: boolean;
        boolValue: boolean;
        capitalizedString: string;
        decomposedStringWithCanonicalMapping: string;
        decomposedStringWithCompatibilityMapping: string;
        doubleValue: number;
        fastestEncoding: number;
        fileSystemRepresentation: string;
        floatValue: number;
        intValue: number;
        integerValue: number;
        lastPathComponent: string;
        length: number;
        localizedCapitalizedString: string;
        localizedLowercaseString: string;
        localizedUppercaseString: string;
        longLongValue: number;
        lowercaseString: string;
        pathComponents: string[];
        pathExtension: string;
        precomposedStringWithCanonicalMapping: string;
        precomposedStringWithCompatibilityMapping: string;
        smallestEncoding: number;
        stringByAbbreviatingWithTildeInPath: string;
        stringByDeletingLastPathComponent: string;
        stringByDeletingPathExtension: string;
        stringByExpandingTildeInPath: string;
        stringByRemovingPercentEncoding: string;
        stringByResolvingSymlinksInPath: string;
        stringByStandardizingPath: string;
        uppercaseString: string;
        static availableStringEncodings: number;
        static defaultCStringEncoding: number;
        boundingRectWithSizeOptionsAttributes(with_: CGSize, options: NSString.DrawingOptions, attributes?: Map<string, any>): CGRect;
        boundingRectWithSizeOptionsAttributesContext(with_: CGSize, options: NSString.DrawingOptions, attributes?: Map<string, any>, context?: NSStringDrawingContext): CGRect;
        cStringUsingEncoding(using: number): string;
        canBeConvertedToEncoding(to: number): boolean;
        capitalizedStringWithLocale(with_?: NSLocale): string;
        caseInsensitiveCompare(_: string): ComparisonResult;
        characterAtIndex(at: number): string;
        commonPrefixWithStringOptions(with_: string, options: NSString.CompareOptions): string;
        compare(_: string): ComparisonResult;
        compareOptions(_: string, options: NSString.CompareOptions): ComparisonResult;
        compareOptionsRange(_: string, options: NSString.CompareOptions, range: NSRange): ComparisonResult;
        compareOptionsRangeLocale(_: string, options: NSString.CompareOptions, range: NSRange, locale?: any): ComparisonResult;
        completePathIntoStringCaseSensitiveMatchesIntoArrayFilterTypes(into?: string, caseSensitive?: boolean, matchesInto?: string[], filterTypes?: string[]): number;
        componentsSeparatedByCharactersInSet(separatedBy: NSCharacterSet): string[];
        componentsSeparatedByString(separatedBy: string): string[];
        containsString(_: string): boolean;
        dataUsingEncoding(using: number): NSData;
        dataUsingEncodingAllowLossyConversion(using: number, allowLossyConversion: boolean): NSData;
        drawAtPointWithAttributes(at: CGPoint, withAttributes?: Map<string, any>): void;
        drawInRectWithAttributes(in_: CGRect, withAttributes?: Map<string, any>): void;
        drawWithRectOptionsAttributes(with_: CGRect, options: NSString.DrawingOptions, attributes?: Map<string, any>): void;
        drawWithRectOptionsAttributesContext(with_: CGRect, options: NSString.DrawingOptions, attributes?: Map<string, any>, context?: NSStringDrawingContext): void;
        enumerateLines(_: (p1: string, p2: boolean) => void): void;
        enumerateLinguisticTagsWithInSchemeOptionsOrthographyUsing(in_: NSRange, scheme: string, options: NSLinguisticTagger.Options, orthography?: NSOrthography, using?: (p1: string, p2: NSRange, p3: NSRange, p4: boolean) => void): void;
        enumerateSubstringsWithInOptionsUsing(in_: NSRange, options: NSString.EnumerationOptions, using?: (p1: string, p2: NSRange, p3: NSRange, p4: boolean) => void): void;
        getBytesMaxLengthUsedLengthEncodingOptionsRangeRemainingRange(_?: any, maxLength?: number, usedLength?: number, encoding?: number, options?: NSString.EncodingConversionOptions, range?: NSRange, remaining?: NSRange): boolean;
        getCStringMaxLengthEncoding(_: string, maxLength: number, encoding: number): boolean;
        getCharacters(_: string): void;
        getCharactersRange(_: string, range: NSRange): void;
        getFileSystemRepresentationMaxLength(_: string, maxLength: number): boolean;
        getLineStartEndContentsEndForRange(_?: number, end?: number, contentsEnd?: number, for_?: NSRange): void;
        getParagraphStartEndContentsEndForRange(_?: number, end?: number, contentsEnd?: number, for_?: NSRange): void;
        hasPrefix(_: string): boolean;
        hasSuffix(_: string): boolean;
        static createWithBytesLengthEncoding(bytes: any, length: number, encoding: number): NSString;
        static createWithBytesNoCopyLengthEncodingFreeWhenDone(bytesNoCopy: any, length: number, encoding: number, freeWhenDone: boolean): NSString;
        static createWithCStringEncoding(CString: string, encoding: number): NSString;
        static createWithCharactersLength(characters: string, length: number): NSString;
        static createWithCharactersNoCopyLengthFreeWhenDone(charactersNoCopy: string, length: number, freeWhenDone: boolean): NSString;
        static createWithContentsOfFileEncoding(contentsOfFile: string, encoding: number): NSString;
        static createWithContentsOfFileUsedEncoding(contentsOfFile: string, usedEncoding?: number): NSString;
        static createWithContentsOfURLEncoding(contentsOfURL: NSURL, encoding: number): NSString;
        static createWithContentsOfURLUsedEncoding(contentsOfURL: NSURL, usedEncoding?: number): NSString;
        static createWithDataEncoding(data: NSData, encoding: number): NSString;
        static createWithString(string: string): NSString;
        static createWithUTF8String(UTF8String: string): NSString;
        isEqualToString(to: string): boolean;
        lengthOfBytesUsingEncoding(using: number): number;
        lineRangeForRange(for_: NSRange): NSRange;
        linguisticTagsInRangeSchemeOptionsOrthographyTokenRanges(in_: NSRange, scheme: string, options: NSLinguisticTagger.Options, orthography?: NSOrthography, tokenRanges?: NSValue[]): string[];
        localizedCaseInsensitiveCompare(_: string): ComparisonResult;
        localizedCaseInsensitiveContainsString(_: string): boolean;
        localizedCompare(_: string): ComparisonResult;
        localizedStandardCompare(_: string): ComparisonResult;
        localizedStandardContainsString(_: string): boolean;
        localizedStandardRangeOfString(of: string): NSRange;
        lowercaseStringWithLocale(with_?: NSLocale): string;
        maximumLengthOfBytesUsingEncoding(using: number): number;
        paragraphRangeForRange(for_: NSRange): NSRange;
        propertyList(): any;
        propertyListFromStringsFileFormat(): Map<any, any>;
        rangeOfCharacterFromSet(from: NSCharacterSet): NSRange;
        rangeOfCharacterFromSetOptions(from: NSCharacterSet, options: NSString.CompareOptions): NSRange;
        rangeOfCharacterFromSetOptionsRange(from: NSCharacterSet, options: NSString.CompareOptions, range: NSRange): NSRange;
        rangeOfComposedCharacterSequenceAtIndex(at: number): NSRange;
        rangeOfComposedCharacterSequencesForRange(for_: NSRange): NSRange;
        rangeOfString(of: string): NSRange;
        rangeOfStringOptions(of: string, options: NSString.CompareOptions): NSRange;
        rangeOfStringOptionsRange(of: string, options: NSString.CompareOptions, range: NSRange): NSRange;
        rangeOfStringOptionsRangeLocale(of: string, options: NSString.CompareOptions, range: NSRange, locale?: NSLocale): NSRange;
        sizeWithAttributes(withAttributes?: Map<string, any>): CGSize;
        stringByAddingPercentEncodingWithAllowedCharacters(withAllowedCharacters: NSCharacterSet): string;
        stringByAppendingPathComponent(_: string): string;
        stringByAppendingPathExtension(_: string): string;
        stringByAppendingString(_: string): string;
        stringByApplyingTransformReverse(_: string, reverse: boolean): string;
        stringByFoldingWithOptionsLocale(options: NSString.CompareOptions, locale?: NSLocale): string;
        stringByPaddingToLengthWithStringStartingAtIndex(toLength: number, withPad: string, startingAt: number): string;
        stringByReplacingCharactersInRangeWithString(in_: NSRange, with_: string): string;
        stringByReplacingOccurrencesOfStringWithString(of: string, with_: string): string;
        stringByReplacingOccurrencesOfStringWithStringOptionsRange(of: string, with_: string, options: NSString.CompareOptions, range: NSRange): string;
        stringByTrimmingCharactersInSet(in_: NSCharacterSet): string;
        stringsByAppendingPaths(byAppendingPaths: string[]): string[];
        substringFromIndex(from: number): string;
        substringToIndex(to: number): string;
        substringWithRange(with_: NSRange): string;
        uppercaseStringWithLocale(with_?: NSLocale): string;
        variantFittingPresentationWidth(_: number): string;
        writeToFileAtomicallyEncodingError(atomically: string, encoding: boolean, error: number): boolean;
        writeToURLAtomicallyEncodingError(atomically: NSURL, encoding: boolean, error: number): boolean;
    }
    class Process extends NSObject {
        static runArgumentsTerminationHandler(_: NSURL, _2: string[], arguments_?: Error, terminationHandler?: (p1: Process) => void): Process;
        static launchedTaskWithLaunchPathArguments(launchPath: string, arguments_: string[]): Process;
        arguments: string[];
        setArguments(_: string[]): any;
        currentDirectoryPath: string;
        setCurrentDirectoryPath(_: string): any;
        currentDirectoryURL: NSURL;
        setCurrentDirectoryURL(_: NSURL): any;
        environment: Map<string, string>;
        setEnvironment(_: Map<string, string>): any;
        executableURL: NSURL;
        setExecutableURL(_: NSURL): any;
        launchPath: string;
        setLaunchPath(_: string): any;
        processIdentifier: number;
        qualityOfService: QualityOfService;
        setQualityOfService(_: QualityOfService): any;
        isRunning: boolean;
        standardError: any;
        setStandardError(_: any): any;
        standardInput: any;
        setStandardInput(_: any): any;
        standardOutput: any;
        setStandardOutput(_: any): any;
        terminationHandler: (p1: Process) => void;
        setTerminationHandler(_: (p1: Process) => void): any;
        terminationReason: Process.TerminationReason;
        terminationStatus: number;
        interrupt(): void;
        launch(): void;
        launchAndReturnError(): boolean;
        resume(): boolean;
        suspend(): boolean;
        terminate(): void;
        waitUntilExit(): void;
    }
    class NSTextCheckingResult extends NSObject {
        static addressCheckingResultWithRangeComponents(range: NSRange, components: Map<string, string>): NSTextCheckingResult;
        static correctionCheckingResultWithRangeReplacementString(range: NSRange, replacementString: string): NSTextCheckingResult;
        static correctionCheckingResultWithRangeReplacementStringAlternativeStrings(range: NSRange, replacementString: string, alternativeStrings: string[]): NSTextCheckingResult;
        static dashCheckingResultWithRangeReplacementString(range: NSRange, replacementString: string): NSTextCheckingResult;
        static dateCheckingResultWithRangeDate(range: NSRange, date: Date): NSTextCheckingResult;
        static dateCheckingResultWithRangeDateTimeZoneDuration(range: NSRange, date: Date, timeZone: NSTimeZone, duration: number): NSTextCheckingResult;
        static grammarCheckingResultWithRangeDetails(range: NSRange, details: Map<string, any>[]): NSTextCheckingResult;
        static linkCheckingResultWithRangeUrl(range: NSRange, url: NSURL): NSTextCheckingResult;
        static orthographyCheckingResultWithRangeOrthography(range: NSRange, orthography: NSOrthography): NSTextCheckingResult;
        static phoneNumberCheckingResultWithRangePhoneNumber(range: NSRange, phoneNumber: string): NSTextCheckingResult;
        static quoteCheckingResultWithRangeReplacementString(range: NSRange, replacementString: string): NSTextCheckingResult;
        static regularExpressionCheckingResultWithRangesCountRegularExpression(ranges: NSRange, count: number, regularExpression: NSRegularExpression): NSTextCheckingResult;
        static replacementCheckingResultWithRangeReplacementString(range: NSRange, replacementString: string): NSTextCheckingResult;
        static spellCheckingResultWithRange(range: NSRange): NSTextCheckingResult;
        static transitInformationCheckingResultWithRangeComponents(range: NSRange, components: Map<string, string>): NSTextCheckingResult;
        URL: NSURL;
        addressComponents: Map<string, string>;
        alternativeStrings: string[];
        components: Map<string, string>;
        date: Date;
        duration: number;
        grammarDetails: Map<string, any>[];
        numberOfRanges: number;
        orthography: NSOrthography;
        phoneNumber: string;
        range: NSRange;
        regularExpression: NSRegularExpression;
        replacementString: string;
        resultType: NSTextCheckingResult.CheckingType;
        timeZone: NSTimeZone;
        rangeAtIndex(at: number): NSRange;
        rangeWithName(withName: string): NSRange;
        resultByAdjustingRangesWithOffset(offset: number): NSTextCheckingResult;
    }
    class Thread extends NSObject {
        static detachNewThreadSelectorToTargetWithObject(_: string, toTarget: any, withObject?: any): void;
        static detachNewThreadWithBlock(_: () => void): void;
        static exit(): void;
        static isMultiThreaded(): boolean;
        static setThreadPriority(_: number): boolean;
        static sleepForTimeInterval(_: number): void;
        static sleepUntilDate(_: Date): void;
        static threadPriority(): number;
        isCancelled: boolean;
        isExecuting: boolean;
        isFinished: boolean;
        name: string;
        setName(_: string): any;
        qualityOfService: QualityOfService;
        setQualityOfService(_: QualityOfService): any;
        stackSize: number;
        setStackSize(_: number): any;
        threadDictionary: NSMutableDictionary<any, any>;
        threadPriority: number;
        setThreadPriority(_: number): any;
        static callStackReturnAddresses: number[];
        static callStackSymbols: string[];
        static currentThread: Thread;
        static isMainThread: boolean;
        static mainThread: Thread;
        cancel(): void;
        static createWithBlock(block: () => void): Thread;
        static createWithTargetSelectorObject(target: any, selector: string, object_?: any): Thread;
        main(): void;
        start(): void;
    }
    class NSTimeZone extends NSObject {
        static resetSystemTimeZone(): void;
        abbreviation: string;
        data: NSData;
        isDaylightSavingTime: boolean;
        daylightSavingTimeOffset: number;
        name: string;
        nextDaylightSavingTimeTransition: Date;
        secondsFromGMT: number;
        static abbreviationDictionary: Map<string, string>;
        setAbbreviationDictionary(_: Map<string, string>): any;
        static defaultTimeZone: NSTimeZone;
        setDefaultTimeZone(_: NSTimeZone): any;
        static knownTimeZoneNames: string[];
        static localTimeZone: NSTimeZone;
        static systemTimeZone: NSTimeZone;
        static timeZoneDataVersion: string;
        abbreviationForDate(for_: Date): string;
        daylightSavingTimeOffsetForDate(for_: Date): number;
        static createWithName(name: string): NSTimeZone;
        static createWithNameData(name: string, data?: NSData): NSTimeZone;
        isDaylightSavingTimeForDate(for_: Date): boolean;
        isEqualToTimeZone(to: NSTimeZone): boolean;
        localizedNameLocale(_: NSTimeZone.NameStyle, locale?: NSLocale): string;
        nextDaylightSavingTimeTransitionAfterDate(after: Date): Date;
        secondsFromGMTForDate(for_: Date): number;
    }
    class Timer extends NSObject {
        static scheduledTimerWithTimeIntervalWithRepeatsBlock(_: number, repeats: boolean, block: (p1: Timer) => void): Timer;
        static scheduledTimerWithTimeIntervalTargetSelectorUserInfoRepeats(timeInterval: number, target: any, selector: string, userInfo?: any, repeats?: boolean): Timer;
        fireDate: Date;
        setFireDate(_: Date): any;
        timeInterval: number;
        tolerance: number;
        setTolerance(_: number): any;
        userInfo: any;
        isValid: boolean;
        fire(): void;
        static createWithFireDateIntervalRepeatsBlock(fireDate: Date, interval: number, repeats: boolean, block: (p1: Timer) => void): Timer;
        static createWithFireDateIntervalTargetSelectorUserInfoRepeats(fireDate: Date, interval: number, target: any, selector: string, userInfo?: any, repeats?: boolean): Timer;
        invalidate(): void;
    }
    class NSURL extends NSObject {
        static URLByResolvingAliasFileAtURLOptionsError(resolvingAliasFileAt: NSURL, options: NSURL.BookmarkResolutionOptions): NSURL;
        static URLByResolvingBookmarkDataOptionsRelativeToURLBookmarkDataIsStaleError(options: NSData, relativeToURL: NSURL.BookmarkResolutionOptions, bookmarkDataIsStale?: NSURL, error?: boolean): NSURL;
        static absoluteURLWithDataRepresentationRelativeToURL(withDataRepresentation: NSData, relativeTo?: NSURL): NSURL;
        static bookmarkDataWithContentsOfURLError(error: NSURL): NSData;
        static fileURLWithFileSystemRepresentationIsDirectoryRelativeToURL(withFileSystemRepresentation: string, isDirectory: boolean, relativeTo?: NSURL): NSURL;
        static fileURLWithPath(withPath: string): NSURL;
        static fileURLWithPathIsDirectory(withPath: string, isDirectory: boolean): NSURL;
        static fileURLWithPathIsDirectoryRelativeToURL(withPath: string, isDirectory: boolean, relativeTo?: NSURL): NSURL;
        static fileURLWithPathRelativeToURL(withPath: string, relativeTo?: NSURL): NSURL;
        static fileURLWithPathComponents(withPathComponents: string[]): NSURL;
        static resourceValuesForKeysFromBookmarkData(forKeys: string[], fromBookmarkData: NSData): Map<string, any>;
        static writeBookmarkDataToURLOptionsError(toURL: NSData, options: NSURL, error: number): boolean;
        URLByDeletingLastPathComponent: NSURL;
        URLByDeletingPathExtension: NSURL;
        URLByResolvingSymlinksInPath: NSURL;
        URLByStandardizingPath: NSURL;
        absoluteString: string;
        absoluteURL: NSURL;
        baseURL: NSURL;
        dataRepresentation: NSData;
        filePathURL: NSURL;
        fileSystemRepresentation: string;
        isFileURL: boolean;
        fragment: string;
        hasDirectoryPath: boolean;
        host: string;
        lastPathComponent: string;
        password: string;
        path: string;
        pathComponents: string[];
        pathExtension: string;
        port: number;
        query: string;
        relativePath: string;
        relativeString: string;
        resourceSpecifier: string;
        scheme: string;
        standardizedURL: NSURL;
        user: string;
        URLByAppendingPathComponent(_: string): NSURL;
        URLByAppendingPathComponentIsDirectory(_: string, isDirectory: boolean): NSURL;
        URLByAppendingPathExtension(_: string): NSURL;
        bookmarkDataWithOptionsIncludingResourceValuesForKeysRelativeToURLError(includingResourceValuesForKeys: NSURL.BookmarkCreationOptions, relativeToURL?: string[], error?: NSURL): NSData;
        checkPromisedItemIsReachableAndReturnError(): boolean;
        checkResourceIsReachableAndReturnError(): boolean;
        fileReferenceURL(): NSURL;
        getFileSystemRepresentationMaxLength(_: string, maxLength: number): boolean;
        getPromisedItemResourceValueForKeyError(forKey?: any, error?: string): boolean;
        getResourceValueForKeyError(forKey?: any, error?: string): boolean;
        static createWithAbsoluteURLWithDataRepresentationRelativeToURL(absoluteURLWithDataRepresentation: NSData, relativeToURL?: NSURL): NSURL;
        static createWithByResolvingBookmarkDataOptionsRelativeToURLBookmarkDataIsStale(byResolvingBookmarkData: NSData, options: NSURL.BookmarkResolutionOptions, relativeToURL?: NSURL, bookmarkDataIsStale?: boolean): NSURL;
        static createWithFileURLWithFileSystemRepresentationIsDirectoryRelativeToURL(fileURLWithFileSystemRepresentation: string, isDirectory: boolean, relativeToURL?: NSURL): NSURL;
        static createWithFileURLWithPath(fileURLWithPath: string): NSURL;
        static createWithFileURLWithPathIsDirectory(fileURLWithPath: string, isDirectory: boolean): NSURL;
        static createWithFileURLWithPathIsDirectoryRelativeToURL(fileURLWithPath: string, isDirectory: boolean, relativeToURL?: NSURL): NSURL;
        static createWithFileURLWithPathRelativeToURL(fileURLWithPath: string, relativeToURL?: NSURL): NSURL;
        static createWithDataRepresentationRelativeToURL(dataRepresentation: NSData, relativeToURL?: NSURL): NSURL;
        static createWithString(string: string): NSURL;
        static createWithStringRelativeToURL(string: string, relativeToURL?: NSURL): NSURL;
        isFileReferenceURL(): boolean;
        promisedItemResourceValuesForKeysError(error: string[]): Map<string, any>;
        removeAllCachedResourceValues(): void;
        removeCachedResourceValueForKey(forKey: string): void;
        resourceValuesForKeysError(error: string[]): Map<string, any>;
        setResourceValueForKeyError(forKey?: any, error?: string): boolean;
        setResourceValuesError(error: Map<string, any>): boolean;
        setTemporaryResourceValueForKey(_?: any, forKey?: string): void;
        startAccessingSecurityScopedResource(): boolean;
        stopAccessingSecurityScopedResource(): void;
        writeToPasteboard(to: NSPasteboard): void;
    }
    class URLAuthenticationChallenge extends NSObject {
        error: NSError;
        failureResponse: URLResponse;
        previousFailureCount: number;
        proposedCredential: URLCredential;
        protectionSpace: URLProtectionSpace;
        sender: URLAuthenticationChallengeSender;
        static createWithAuthenticationChallengeSender(authenticationChallenge: URLAuthenticationChallenge, sender: URLAuthenticationChallengeSender): URLAuthenticationChallenge;
        static createWithProtectionSpaceProposedCredentialPreviousFailureCountFailureResponseErrorSender(protectionSpace: URLProtectionSpace, proposedCredential?: URLCredential, previousFailureCount?: number, failureResponse?: URLResponse, error?: NSError, sender?: URLAuthenticationChallengeSender): URLAuthenticationChallenge;
    }
    interface URLAuthenticationChallengeSender extends NSObject {
        cancelAuthenticationChallenge(_: URLAuthenticationChallenge): void;
        continueWithoutCredentialForAuthenticationChallenge(_: URLAuthenticationChallenge): void;
        performDefaultHandlingForAuthenticationChallenge?(_: URLAuthenticationChallenge): void;
        rejectProtectionSpaceAndContinueWithChallenge?(_: URLAuthenticationChallenge): void;
        useCredentialForAuthenticationChallenge(_: URLCredential, forAuthenticationChallenge: URLAuthenticationChallenge): void;
    }
    class URLCache extends NSObject {
        currentDiskUsage: number;
        currentMemoryUsage: number;
        diskCapacity: number;
        setDiskCapacity(_: number): any;
        memoryCapacity: number;
        setMemoryCapacity(_: number): any;
        static sharedURLCache: URLCache;
        setSharedURLCache(_: URLCache): any;
        cachedResponseForRequest(_: NSURLRequest): CachedURLResponse;
        getCachedResponseForDataTaskWithCompletionHandler(_: URLSessionDataTask, completionHandler?: (p1: CachedURLResponse) => void): void;
        static createWithMemoryCapacityDiskCapacityDirectoryURL(memoryCapacity: number, diskCapacity: number, directoryURL?: NSURL): URLCache;
        static createWithMemoryCapacityDiskCapacityDiskPath(memoryCapacity: number, diskCapacity: number, diskPath?: string): URLCache;
        removeAllCachedResponses(): void;
        removeCachedResponseForDataTask(_: URLSessionDataTask): void;
        removeCachedResponseForRequest(_: NSURLRequest): void;
        removeCachedResponsesSinceDate(_: Date): void;
        storeCachedResponseForDataTask(_: CachedURLResponse, forDataTask: URLSessionDataTask): void;
        storeCachedResponseForRequest(_: CachedURLResponse, forRequest: NSURLRequest): void;
    }
    class NSURLComponents extends NSObject {
        static componentsWithString(string: string): NSURLComponents;
        static componentsWithURLResolvingAgainstBaseURL(url: NSURL, resolvingAgainstBaseURL: boolean): NSURLComponents;
        URL: NSURL;
        fragment: string;
        setFragment(_: string): any;
        host: string;
        setHost(_: string): any;
        password: string;
        setPassword(_: string): any;
        path: string;
        setPath(_: string): any;
        percentEncodedFragment: string;
        setPercentEncodedFragment(_: string): any;
        percentEncodedHost: string;
        setPercentEncodedHost(_: string): any;
        percentEncodedPassword: string;
        setPercentEncodedPassword(_: string): any;
        percentEncodedPath: string;
        setPercentEncodedPath(_: string): any;
        percentEncodedQuery: string;
        setPercentEncodedQuery(_: string): any;
        percentEncodedQueryItems: NSURLQueryItem[];
        setPercentEncodedQueryItems(_: NSURLQueryItem[]): any;
        percentEncodedUser: string;
        setPercentEncodedUser(_: string): any;
        port: number;
        setPort(_: number): any;
        query: string;
        setQuery(_: string): any;
        queryItems: NSURLQueryItem[];
        setQueryItems(_: NSURLQueryItem[]): any;
        rangeOfFragment: NSRange;
        rangeOfHost: NSRange;
        rangeOfPassword: NSRange;
        rangeOfPath: NSRange;
        rangeOfPort: NSRange;
        rangeOfQuery: NSRange;
        rangeOfScheme: NSRange;
        rangeOfUser: NSRange;
        scheme: string;
        setScheme(_: string): any;
        string: string;
        user: string;
        setUser(_: string): any;
        URLRelativeToURL(relativeTo?: NSURL): NSURL;
        static createWithString(string: string): NSURLComponents;
        static createWithUrlResolvingAgainstBaseURL(URL: NSURL, resolvingAgainstBaseURL: boolean): NSURLComponents;
    }
    class NSURLConnection extends NSObject {
        static canHandleRequest(_: NSURLRequest): boolean;
        currentRequest: NSURLRequest;
        originalRequest: NSURLRequest;
        cancel(): void;
        scheduleInRunLoopForMode(in_: RunLoop, forMode: string): void;
        setDelegateQueue(_?: OperationQueue): void;
        start(): void;
        unscheduleFromRunLoopForMode(from: RunLoop, forMode: string): void;
    }
    interface NSURLConnectionDataDelegate extends NSURLConnectionDelegate {
        connectionWillSendRequestRedirectResponse?(_: NSURLConnection, willSend: NSURLRequest, redirectResponse?: URLResponse): NSURLRequest;
        connectionDidReceiveResponse?(_: NSURLConnection, didReceive: URLResponse): void;
        connectionDidReceiveData?(_: NSURLConnection, didReceive: NSData): void;
        connectionDidSendBodyDataTotalBytesWrittenTotalBytesExpectedToWrite?(_: NSURLConnection, didSendBodyData: number, totalBytesWritten: number, totalBytesExpectedToWrite: number): void;
        connectionNeedNewBodyStream?(_: NSURLConnection, needNewBodyStream: NSURLRequest): InputStream;
        connectionWillCacheResponse?(_: NSURLConnection, willCacheResponse: CachedURLResponse): CachedURLResponse;
        connectionDidFinishLoading?(_: NSURLConnection): void;
    }
    interface NSURLConnectionDelegate extends NSObject {
        connectionWillSendRequestForAuthenticationChallenge?(_: NSURLConnection, willSendRequestFor: URLAuthenticationChallenge): void;
        connectionDidFailWithError?(_: NSURLConnection, didFailWithError: NSError): void;
        connectionShouldUseCredentialStorage?(_: NSURLConnection): boolean;
    }
    interface NSURLConnectionDownloadDelegate extends NSURLConnectionDelegate {
        connectionDidWriteDataTotalBytesWrittenExpectedTotalBytes?(_: NSURLConnection, didWriteData: number, totalBytesWritten: number, expectedTotalBytes: number): void;
        connectionDidFinishDownloadingDestinationURL(_: NSURLConnection, destinationURL: NSURL): void;
        connectionDidResumeDownloadingTotalBytesWrittenExpectedTotalBytes?(_: NSURLConnection, totalBytesWritten: number, expectedTotalBytes: number): void;
    }
    class URLCredential extends NSObject {
        certificates: any[];
        hasPassword: boolean;
        identity: any;
        password: string;
        persistence: URLCredential.Persistence;
        user: string;
        static createWithIdentityCertificatesPersistence(identity: any, certificates?: any[], persistence?: URLCredential.Persistence): URLCredential;
        static createWithTrust(trust: any): URLCredential;
        static createWithUserPasswordPersistence(user: string, password: string, persistence: URLCredential.Persistence): URLCredential;
    }
    class URLCredentialStorage extends NSObject {
        allCredentials: Map<URLProtectionSpace, Map<string, URLCredential>>;
        static sharedCredentialStorage: URLCredentialStorage;
        credentialsForProtectionSpace(_: URLProtectionSpace): Map<string, URLCredential>;
        defaultCredentialForProtectionSpace(_: URLProtectionSpace): URLCredential;
        getCredentialsForTaskCompletionHandler(for_: URLProtectionSpace, task: URLSessionTask, completionHandler?: (p1: Map<string, URLCredential>) => void): void;
        getDefaultCredentialForProtectionSpaceWithTaskCompletionHandler(_: URLProtectionSpace, task: URLSessionTask, completionHandler?: (p1: URLCredential) => void): void;
        removeCredentialForProtectionSpace(_: URLCredential, forProtectionSpace: URLProtectionSpace): void;
        removeCredentialForProtectionSpaceOptions(_: URLCredential, forProtectionSpace: URLProtectionSpace, options?: Map<string, any>): void;
        removeCredentialForProtectionSpaceOptionsTask(_: URLCredential, forProtectionSpace: URLProtectionSpace, options?: Map<string, any>, task?: URLSessionTask): void;
        setCredentialForProtectionSpace(_: URLCredential, for_: URLProtectionSpace): void;
        setCredentialForProtectionSpaceTask(_: URLCredential, for_: URLProtectionSpace, task: URLSessionTask): void;
        setDefaultCredentialForProtectionSpace(_: URLCredential, forProtectionSpace: URLProtectionSpace): void;
        setDefaultCredentialForProtectionSpaceTask(_: URLCredential, forProtectionSpace: URLProtectionSpace, task: URLSessionTask): void;
    }
    class NSURLDownload extends NSObject {
        static canResumeDownloadDecodedWithEncodingMIMEType(withEncodingMIMEType: string): boolean;
        deletesFileUponFailure: boolean;
        setDeletesFileUponFailure(_: boolean): any;
        request: NSURLRequest;
        resumeData: NSData;
        cancel(): void;
        setDestinationAllowOverwrite(_: string, allowOverwrite: boolean): void;
    }
    interface NSURLDownloadDelegate extends NSObject {
        downloadWillSendRequestRedirectResponse?(_: NSURLDownload, willSend: NSURLRequest, redirectResponse?: URLResponse): NSURLRequest;
        downloadDidReceiveAuthenticationChallenge?(_: NSURLDownload, didReceive: URLAuthenticationChallenge): void;
        downloadDidCancelAuthenticationChallenge?(_: NSURLDownload, didCancel: URLAuthenticationChallenge): void;
        downloadDidReceiveResponse?(_: NSURLDownload, didReceive: URLResponse): void;
        downloadWillResumeWithResponseFromByte?(_: NSURLDownload, willResumeWith: URLResponse, fromByte: number): void;
        downloadCanAuthenticateAgainstProtectionSpace?(_: NSURLDownload, canAuthenticateAgainstProtectionSpace: URLProtectionSpace): boolean;
        downloadDecideDestinationWithSuggestedFilename?(_: NSURLDownload, decideDestinationWithSuggestedFilename: string): void;
        downloadDidCreateDestination?(_: NSURLDownload, didCreateDestination: string): void;
        downloadDidFailWithError?(_: NSURLDownload, didFailWithError: NSError): void;
        downloadDidReceiveDataOfLength?(_: NSURLDownload, didReceiveDataOfLength: number): void;
        downloadShouldDecodeSourceDataOfMIMEType?(_: NSURLDownload, shouldDecodeSourceDataOfMIMEType: string): boolean;
        downloadDidBegin?(_: NSURLDownload): void;
        downloadDidFinish?(_: NSURLDownload): void;
        downloadShouldUseCredentialStorage?(_: NSURLDownload): boolean;
    }
    class NSURLHandle extends NSObject {
    }
    class URLProtectionSpace extends NSObject {
        authenticationMethod: string;
        distinguishedNames: NSData[];
        host: string;
        isProxy: boolean;
        port: number;
        protocol: string;
        proxyType: string;
        realm: string;
        receivesCredentialSecurely: boolean;
        serverTrust: any;
        static createWithHostPortProtocolRealmAuthenticationMethod(host: string, port: number, protocol?: string, realm?: string, authenticationMethod?: string): URLProtectionSpace;
        static createWithProxyHostPortTypeRealmAuthenticationMethod(proxyHost: string, port: number, type?: string, realm?: string, authenticationMethod?: string): URLProtectionSpace;
    }
    class URLProtocol extends NSObject {
        static canInitWithRequest(_: NSURLRequest): boolean;
        static canInitWithTask(_: URLSessionTask): boolean;
        static canonicalRequestForRequest(_: NSURLRequest): NSURLRequest;
        static propertyForKeyInRequest(_: string, inRequest: NSURLRequest): any;
        static registerClass(_: typeof NSObject): boolean;
        static removePropertyForKeyInRequest(_: string, inRequest: NSMutableURLRequest): void;
        static requestIsCacheEquivalentToRequest(_: NSURLRequest, toRequest: NSURLRequest): boolean;
        static setPropertyForKeyInRequest(_: any, forKey: string, inRequest: NSMutableURLRequest): void;
        static unregisterClass(_: typeof NSObject): void;
        cachedResponse: CachedURLResponse;
        client: URLProtocolClient;
        request: NSURLRequest;
        task: URLSessionTask;
        static createWithRequestCachedResponseClient(request: NSURLRequest, cachedResponse?: CachedURLResponse, client?: URLProtocolClient): URLProtocol;
        static createWithTaskCachedResponseClient(task: URLSessionTask, cachedResponse?: CachedURLResponse, client?: URLProtocolClient): URLProtocol;
        startLoading(): void;
        stopLoading(): void;
    }
    interface URLProtocolClient extends NSObject {
        URLProtocolCachedResponseIsValid(_: URLProtocol, cachedResponseIsValid: CachedURLResponse): void;
        URLProtocolDidCancelAuthenticationChallenge(_: URLProtocol, didCancelAuthenticationChallenge: URLAuthenticationChallenge): void;
        URLProtocolDidFailWithError(_: URLProtocol, didFailWithError: NSError): void;
        URLProtocolDidLoadData(_: URLProtocol, didLoadData: NSData): void;
        URLProtocolDidReceiveAuthenticationChallenge(_: URLProtocol, didReceiveAuthenticationChallenge: URLAuthenticationChallenge): void;
        URLProtocolDidReceiveResponseCacheStoragePolicy(_: URLProtocol, didReceiveResponse: URLResponse, cacheStoragePolicy: URLCache.StoragePolicy): void;
        URLProtocolWasRedirectedToRequestRedirectResponse(_: URLProtocol, wasRedirectedToRequest: NSURLRequest, redirectResponse: URLResponse): void;
        URLProtocolDidFinishLoading(_: URLProtocol): void;
    }
    class NSURLQueryItem extends NSObject {
        static queryItemWithNameValue(name: string, value?: string): NSURLQueryItem;
        name: string;
        value: string;
        static createWithNameValue(name: string, value?: string): NSURLQueryItem;
    }
    class NSURLRequest extends NSObject {
        HTTPBody: NSData;
        HTTPBodyStream: InputStream;
        HTTPMethod: string;
        HTTPShouldHandleCookies: boolean;
        HTTPShouldUsePipelining: boolean;
        URL: NSURL;
        allHTTPHeaderFields: Map<string, string>;
        allowsCellularAccess: boolean;
        allowsConstrainedNetworkAccess: boolean;
        allowsExpensiveNetworkAccess: boolean;
        cachePolicy: NSURLRequest.CachePolicy;
        mainDocumentURL: NSURL;
        networkServiceType: NSURLRequest.NetworkServiceType;
        timeoutInterval: number;
        static createWithUrl(URL: NSURL): NSURLRequest;
        static createWithUrlCachePolicyTimeoutInterval(URL: NSURL, cachePolicy: NSURLRequest.CachePolicy, timeoutInterval: number): NSURLRequest;
        valueForHTTPHeaderField(forHTTPHeaderField: string): string;
    }
    class URLResponse extends NSObject {
        MIMEType: string;
        URL: NSURL;
        expectedContentLength: number;
        suggestedFilename: string;
        textEncodingName: string;
        static createWithUrlMIMETypeExpectedContentLengthTextEncodingName(URL: NSURL, MIMEType?: string, expectedContentLength?: number, textEncodingName?: string): URLResponse;
    }
    class URLSession extends NSObject {
        configuration: URLSessionConfiguration;
        delegate: URLSessionDelegate;
        delegateQueue: OperationQueue;
        sessionDescription: string;
        setSessionDescription(_: string): any;
        static sharedSession: URLSession;
        dataTaskWithRequest(_: NSURLRequest): URLSessionDataTask;
        dataTaskWithRequestWithCompletionHandler(_: NSURLRequest, completionHandler?: (p1: NSData, p2: URLResponse, p3: NSError) => void): URLSessionDataTask;
        dataTaskWithURL(_: NSURL): URLSessionDataTask;
        dataTaskWithURLWithCompletionHandler(_: NSURL, completionHandler?: (p1: NSData, p2: URLResponse, p3: NSError) => void): URLSessionDataTask;
        downloadTaskWithRequest(_: NSURLRequest): URLSessionDownloadTask;
        downloadTaskWithRequestWithCompletionHandler(_: NSURLRequest, completionHandler?: (p1: NSURL, p2: URLResponse, p3: NSError) => void): URLSessionDownloadTask;
        downloadTaskWithResumeData(_: NSData): URLSessionDownloadTask;
        downloadTaskWithResumeDataWithCompletionHandler(_: NSData, completionHandler?: (p1: NSURL, p2: URLResponse, p3: NSError) => void): URLSessionDownloadTask;
        downloadTaskWithURL(_: NSURL): URLSessionDownloadTask;
        downloadTaskWithURLWithCompletionHandler(_: NSURL, completionHandler?: (p1: NSURL, p2: URLResponse, p3: NSError) => void): URLSessionDownloadTask;
        finishTasksAndInvalidate(): void;
        flushWithCompletionHandler(_: () => void): void;
        getAllTasksWithCompletionHandler(_: (p1: URLSessionTask[]) => void): void;
        getTasksWithCompletionHandler(_: (p1: URLSessionDataTask[], p2: URLSessionUploadTask[], p3: URLSessionDownloadTask[]) => void): void;
        invalidateAndCancel(): void;
        resetWithCompletionHandler(_: () => void): void;
        streamTaskWithHostNamePort(_: string, port: number): URLSessionStreamTask;
        streamTaskWithNetService(_: NetService): URLSessionStreamTask;
        uploadTaskWithRequestFromData(_: NSURLRequest, fromData: NSData): URLSessionUploadTask;
        uploadTaskWithRequestWithFromDataCompletionHandler(_: NSURLRequest, fromData?: NSData, completionHandler?: (p1: NSData, p2: URLResponse, p3: NSError) => void): URLSessionUploadTask;
        uploadTaskWithRequestFromFile(_: NSURLRequest, fromFile: NSURL): URLSessionUploadTask;
        uploadTaskWithRequestWithFromFileCompletionHandler(_: NSURLRequest, fromFile: NSURL, completionHandler?: (p1: NSData, p2: URLResponse, p3: NSError) => void): URLSessionUploadTask;
        uploadTaskWithStreamedRequest(_: NSURLRequest): URLSessionUploadTask;
        webSocketTaskWithRequest(_: NSURLRequest): URLSessionWebSocketTask;
        webSocketTaskWithURL(_: NSURL): URLSessionWebSocketTask;
        webSocketTaskWithURLProtocols(_: NSURL, protocols: string[]): URLSessionWebSocketTask;
    }
    class URLSessionConfiguration extends NSObject {
        static backgroundSessionConfigurationWithIdentifier(withIdentifier: string): URLSessionConfiguration;
        HTTPAdditionalHeaders: Map<any, any>;
        setHTTPAdditionalHeaders(_: Map<any, any>): any;
        HTTPCookieAcceptPolicy: HTTPCookie.AcceptPolicy;
        setHTTPCookieAcceptPolicy(_: HTTPCookie.AcceptPolicy): any;
        HTTPCookieStorage: HTTPCookieStorage;
        setHTTPCookieStorage(_: HTTPCookieStorage): any;
        HTTPMaximumConnectionsPerHost: number;
        setHTTPMaximumConnectionsPerHost(_: number): any;
        HTTPShouldSetCookies: boolean;
        setHTTPShouldSetCookies(_: boolean): any;
        HTTPShouldUsePipelining: boolean;
        setHTTPShouldUsePipelining(_: boolean): any;
        TLSMaximumSupportedProtocol: SSLProtocol;
        setTLSMaximumSupportedProtocol(_: SSLProtocol): any;
        TLSMaximumSupportedProtocolVersion: tls_protocol_version_t;
        setTLSMaximumSupportedProtocolVersion(_: tls_protocol_version_t): any;
        TLSMinimumSupportedProtocol: SSLProtocol;
        setTLSMinimumSupportedProtocol(_: SSLProtocol): any;
        TLSMinimumSupportedProtocolVersion: tls_protocol_version_t;
        setTLSMinimumSupportedProtocolVersion(_: tls_protocol_version_t): any;
        URLCache: URLCache;
        setURLCache(_: URLCache): any;
        URLCredentialStorage: URLCredentialStorage;
        setURLCredentialStorage(_: URLCredentialStorage): any;
        allowsCellularAccess: boolean;
        setAllowsCellularAccess(_: boolean): any;
        allowsConstrainedNetworkAccess: boolean;
        setAllowsConstrainedNetworkAccess(_: boolean): any;
        allowsExpensiveNetworkAccess: boolean;
        setAllowsExpensiveNetworkAccess(_: boolean): any;
        connectionProxyDictionary: Map<any, any>;
        setConnectionProxyDictionary(_: Map<any, any>): any;
        isDiscretionary: boolean;
        setDiscretionary(_: boolean): any;
        identifier: string;
        networkServiceType: NSURLRequest.NetworkServiceType;
        setNetworkServiceType(_: NSURLRequest.NetworkServiceType): any;
        protocolClasses: typeof NSObject[];
        setProtocolClasses(_: typeof NSObject[]): any;
        requestCachePolicy: NSURLRequest.CachePolicy;
        setRequestCachePolicy(_: NSURLRequest.CachePolicy): any;
        sharedContainerIdentifier: string;
        setSharedContainerIdentifier(_: string): any;
        shouldUseExtendedBackgroundIdleMode: boolean;
        setShouldUseExtendedBackgroundIdleMode(_: boolean): any;
        timeoutIntervalForRequest: number;
        setTimeoutIntervalForRequest(_: number): any;
        timeoutIntervalForResource: number;
        setTimeoutIntervalForResource(_: number): any;
        waitsForConnectivity: boolean;
        setWaitsForConnectivity(_: boolean): any;
        static defaultSessionConfiguration: URLSessionConfiguration;
        static ephemeralSessionConfiguration: URLSessionConfiguration;
    }
    interface URLSessionDataDelegate extends URLSessionTaskDelegate {
        URLSessionDataTaskDidBecomeDownloadTask?(_: URLSession, dataTask: URLSessionDataTask, didBecomeDownloadTask: URLSessionDownloadTask): void;
        URLSessionDataTaskDidBecomeStreamTask?(_: URLSession, dataTask: URLSessionDataTask, didBecomeStreamTask: URLSessionStreamTask): void;
        URLSessionDataTaskDidReceiveData?(_: URLSession, dataTask: URLSessionDataTask, didReceiveData: NSData): void;
        URLSessionWithDataTaskDidReceiveResponseCompletionHandler?(_: URLSession, dataTask: URLSessionDataTask, didReceiveResponse: URLResponse, completionHandler: (p1: URLSession.ResponseDisposition) => void): void;
        URLSessionWithDataTaskWillCacheResponseCompletionHandler?(_: URLSession, dataTask: URLSessionDataTask, willCacheResponse: CachedURLResponse, completionHandler?: (p1: CachedURLResponse) => void): void;
    }
    class URLSessionDataTask extends URLSessionTask {
    }
    interface URLSessionDelegate extends NSObject {
        URLSessionDidBecomeInvalidWithError?(_: URLSession, didBecomeInvalidWithError?: NSError): void;
        URLSessionWithDidReceiveChallengeCompletionHandler?(_: URLSession, didReceiveChallenge: URLAuthenticationChallenge, completionHandler?: (p1: URLSession.AuthChallengeDisposition, p2: URLCredential) => void): void;
    }
    interface URLSessionDownloadDelegate extends URLSessionTaskDelegate {
        URLSessionDownloadTaskDidFinishDownloadingToURL(_: URLSession, downloadTask: URLSessionDownloadTask, didFinishDownloadingToURL: NSURL): void;
        URLSessionDownloadTaskDidResumeAtOffsetExpectedTotalBytes?(_: URLSession, downloadTask: URLSessionDownloadTask, didResumeAtOffset: number, expectedTotalBytes: number): void;
        URLSessionDownloadTaskDidWriteDataTotalBytesWrittenTotalBytesExpectedToWrite?(_: URLSession, downloadTask: URLSessionDownloadTask, didWriteData: number, totalBytesWritten: number, totalBytesExpectedToWrite: number): void;
    }
    class URLSessionDownloadTask extends URLSessionTask {
        cancelByProducingResumeData(_?: (p1: NSData) => void): void;
    }
    interface URLSessionStreamDelegate extends URLSessionTaskDelegate {
        URLSessionBetterRouteDiscoveredForStreamTask?(_: URLSession, betterRouteDiscoveredForStreamTask: URLSessionStreamTask): void;
        URLSessionReadClosedForStreamTask?(_: URLSession, readClosedForStreamTask: URLSessionStreamTask): void;
        URLSessionStreamTaskDidBecomeInputStreamOutputStream?(_: URLSession, streamTask: URLSessionStreamTask, didBecomeInputStream: InputStream, outputStream: OutputStream): void;
        URLSessionWriteClosedForStreamTask?(_: URLSession, writeClosedForStreamTask: URLSessionStreamTask): void;
    }
    class URLSessionStreamTask extends URLSessionTask {
        captureStreams(): void;
        closeRead(): void;
        closeWrite(): void;
        readDataOfMinLengthWithMaxLengthTimeoutCompletionHandler(_: number, maxLength: number, timeout: number, completionHandler?: (p1: NSData, p2: boolean, p3: NSError) => void): void;
        startSecureConnection(): void;
        writeDataWithTimeoutCompletionHandler(_: NSData, timeout: number, completionHandler?: (p1: NSError) => void): void;
    }
    class URLSessionTask extends NSObject {
        countOfBytesClientExpectsToReceive: number;
        setCountOfBytesClientExpectsToReceive(_: number): any;
        countOfBytesClientExpectsToSend: number;
        setCountOfBytesClientExpectsToSend(_: number): any;
        countOfBytesExpectedToReceive: number;
        countOfBytesExpectedToSend: number;
        countOfBytesReceived: number;
        countOfBytesSent: number;
        currentRequest: NSURLRequest;
        earliestBeginDate: Date;
        setEarliestBeginDate(_: Date): any;
        error: NSError;
        originalRequest: NSURLRequest;
        priority: number;
        setPriority(_: number): any;
        response: URLResponse;
        state: URLSessionTask.State;
        taskDescription: string;
        setTaskDescription(_: string): any;
        taskIdentifier: number;
        cancel(): void;
        resume(): void;
        suspend(): void;
    }
    interface URLSessionTaskDelegate extends URLSessionDelegate {
        URLSessionTaskDidCompleteWithError?(_: URLSession, task: URLSessionTask, didCompleteWithError?: NSError): void;
        URLSessionTaskDidFinishCollectingMetrics?(_: URLSession, task: URLSessionTask, didFinishCollectingMetrics: URLSessionTaskMetrics): void;
        URLSessionWithTaskDidReceiveChallengeCompletionHandler?(_: URLSession, task: URLSessionTask, didReceiveChallenge: URLAuthenticationChallenge, completionHandler?: (p1: URLSession.AuthChallengeDisposition, p2: URLCredential) => void): void;
        URLSessionTaskDidSendBodyDataTotalBytesSentTotalBytesExpectedToSend?(_: URLSession, task: URLSessionTask, didSendBodyData: number, totalBytesSent: number, totalBytesExpectedToSend: number): void;
        URLSessionWithTaskNeedNewBodyStream?(_: URLSession, task: URLSessionTask, needNewBodyStream?: (p1: InputStream) => void): void;
        URLSessionWithTaskWillBeginDelayedRequestCompletionHandler?(_: URLSession, task: URLSessionTask, willBeginDelayedRequest: NSURLRequest, completionHandler?: (p1: NSURLSessionDelayedRequestDisposition, p2: NSURLRequest) => void): void;
        URLSessionWithTaskWillPerformHTTPRedirectionNewRequestCompletionHandler?(_: URLSession, task: URLSessionTask, willPerformHTTPRedirection: HTTPURLResponse, newRequest: NSURLRequest, completionHandler?: (p1: NSURLRequest) => void): void;
        URLSessionTaskIsWaitingForConnectivity?(_: URLSession, taskIsWaitingForConnectivity: URLSessionTask): void;
    }
    class URLSessionTaskMetrics extends NSObject {
        redirectCount: number;
        taskInterval: NSDateInterval;
        transactionMetrics: URLSessionTaskTransactionMetrics[];
    }
    class URLSessionTaskTransactionMetrics extends NSObject {
        isCellular: boolean;
        connectEndDate: Date;
        connectStartDate: Date;
        isConstrained: boolean;
        countOfRequestBodyBytesBeforeEncoding: number;
        countOfRequestBodyBytesSent: number;
        countOfRequestHeaderBytesSent: number;
        countOfResponseBodyBytesAfterDecoding: number;
        countOfResponseBodyBytesReceived: number;
        countOfResponseHeaderBytesReceived: number;
        domainLookupEndDate: Date;
        domainLookupStartDate: Date;
        isExpensive: boolean;
        fetchStartDate: Date;
        localAddress: string;
        localPort: number;
        isMultipath: boolean;
        negotiatedTLSCipherSuite: number;
        negotiatedTLSProtocolVersion: number;
        networkProtocolName: string;
        isProxyConnection: boolean;
        remoteAddress: string;
        remotePort: number;
        request: NSURLRequest;
        requestEndDate: Date;
        requestStartDate: Date;
        resourceFetchType: URLSessionTaskMetrics.ResourceFetchType;
        response: URLResponse;
        responseEndDate: Date;
        responseStartDate: Date;
        isReusedConnection: boolean;
        secureConnectionEndDate: Date;
        secureConnectionStartDate: Date;
    }
    class URLSessionUploadTask extends URLSessionDataTask {
    }
    interface URLSessionWebSocketDelegate extends URLSessionTaskDelegate {
        URLSessionWebSocketTaskDidCloseWithCodeReason?(_: URLSession, webSocketTask: URLSessionWebSocketTask, didCloseWithCode: URLSessionWebSocketTask.CloseCode, reason?: NSData): void;
        URLSessionWebSocketTaskDidOpenWithProtocol?(_: URLSession, webSocketTask: URLSessionWebSocketTask, didOpenWithProtocol?: string): void;
    }
    class NSURLSessionWebSocketMessage extends NSObject {
        data: NSData;
        string: string;
        type: NSURLSessionWebSocketMessageType;
        static createWithData(data: NSData): NSURLSessionWebSocketMessage;
        static createWithString(string: string): NSURLSessionWebSocketMessage;
    }
    class URLSessionWebSocketTask extends URLSessionTask {
        closeCode: URLSessionWebSocketTask.CloseCode;
        closeReason: NSData;
        maximumMessageSize: number;
        setMaximumMessageSize(_: number): any;
        cancelWithCloseCodeReason(_: URLSessionWebSocketTask.CloseCode, reason?: NSData): void;
        receiveMessageWithCompletionHandler(_?: (p1: NSURLSessionWebSocketMessage, p2: NSError) => void): void;
        sendMessageWithCompletionHandler(_: NSURLSessionWebSocketMessage, completionHandler?: (p1: NSError) => void): void;
        sendPingWithPongReceiveHandler(_?: (p1: NSError) => void): void;
    }
    class NSUUID extends NSObject {
        UUIDString: string;
        getUUIDBytes(_: number): void;
        static createWithUUIDBytes(UUIDBytes?: number): NSUUID;
        static createWithUUIDString(UUIDString: string): NSUUID;
    }
    class NSUbiquitousKeyValueStore extends NSObject {
        dictionaryRepresentation: Map<string, any>;
        static defaultStore: NSUbiquitousKeyValueStore;
        arrayForKey(forKey: string): any[];
        boolForKey(forKey: string): boolean;
        dataForKey(forKey: string): NSData;
        dictionaryForKey(forKey: string): Map<string, any>;
        doubleForKey(forKey: string): number;
        longLongForKey(forKey: string): number;
        objectForKey(forKey: string): any;
        removeObjectForKey(forKey: string): void;
        setArrayForKey(_?: any[], forKey?: string): void;
        setBoolForKey(_: boolean, forKey: string): void;
        setDataForKey(_?: NSData, forKey?: string): void;
        setDictionaryForKey(_?: Map<string, any>, forKey?: string): void;
        setDoubleForKey(_: number, forKey: string): void;
        setLongLongForKey(_: number, forKey: string): void;
        setObjectForKey(_?: any, forKey?: string): void;
        setStringForKey(_?: string, forKey?: string): void;
        stringForKey(forKey: string): string;
        synchronize(): boolean;
    }
    class UndoManager extends NSObject {
        canRedo: boolean;
        canUndo: boolean;
        groupingLevel: number;
        groupsByEvent: boolean;
        setGroupsByEvent(_: boolean): any;
        levelsOfUndo: number;
        setLevelsOfUndo(_: number): any;
        redoActionIsDiscardable: boolean;
        redoActionName: string;
        redoMenuItemTitle: string;
        isRedoing: boolean;
        runLoopModes: string[];
        setRunLoopModes(_: string[]): any;
        undoActionIsDiscardable: boolean;
        undoActionName: string;
        undoMenuItemTitle: string;
        isUndoRegistrationEnabled: boolean;
        isUndoing: boolean;
        beginUndoGrouping(): void;
        disableUndoRegistration(): void;
        enableUndoRegistration(): void;
        endUndoGrouping(): void;
        prepareWithInvocationTarget(_: any): any;
        redo(): void;
        redoMenuTitleForUndoActionName(_: string): string;
        registerUndoWithTargetSelectorObject(_: any, selector: string, object_?: any): void;
        removeAllActions(): void;
        removeAllActionsWithTarget(_: any): void;
        setActionIsDiscardable(_: boolean): void;
        setActionName(_: string): void;
        undo(): void;
        undoMenuTitleForUndoActionName(_: string): string;
        undoNestedGroup(): void;
    }
    class NSUniqueIDSpecifier extends NSScriptObjectSpecifier {
        uniqueID: any;
        setUniqueID(_: any): any;
        static createWithContainerClassDescriptionContainerSpecifierKeyUniqueID(containerClassDescription: NSScriptClassDescription, containerSpecifier?: NSScriptObjectSpecifier, key?: string, uniqueID?: any): NSUniqueIDSpecifier;
    }
    class Unit extends NSObject {
        symbol: string;
        static createWithSymbol(symbol: string): Unit;
    }
    class UnitAcceleration extends Dimension {
        static gravity: UnitAcceleration;
        static metersPerSecondSquared: UnitAcceleration;
    }
    class UnitAngle extends Dimension {
        static arcMinutes: UnitAngle;
        static arcSeconds: UnitAngle;
        static degrees: UnitAngle;
        static gradians: UnitAngle;
        static radians: UnitAngle;
        static revolutions: UnitAngle;
    }
    class UnitArea extends Dimension {
        static acres: UnitArea;
        static ares: UnitArea;
        static hectares: UnitArea;
        static squareCentimeters: UnitArea;
        static squareFeet: UnitArea;
        static squareInches: UnitArea;
        static squareKilometers: UnitArea;
        static squareMegameters: UnitArea;
        static squareMeters: UnitArea;
        static squareMicrometers: UnitArea;
        static squareMiles: UnitArea;
        static squareMillimeters: UnitArea;
        static squareNanometers: UnitArea;
        static squareYards: UnitArea;
    }
    class UnitConcentrationMass extends Dimension {
        static millimolesPerLiterWithGramsPerMole(_: number): UnitConcentrationMass;
        static gramsPerLiter: UnitConcentrationMass;
        static milligramsPerDeciliter: UnitConcentrationMass;
    }
    class UnitConverter extends NSObject {
        baseUnitValueFromValue(_: number): number;
        valueFromBaseUnitValue(_: number): number;
    }
    class UnitConverterLinear extends UnitConverter {
        coefficient: number;
        constant: number;
        static createWithCoefficient(coefficient: number): UnitConverterLinear;
        static createWithCoefficientConstant(coefficient: number, constant: number): UnitConverterLinear;
    }
    class UnitDispersion extends Dimension {
        static partsPerMillion: UnitDispersion;
    }
    class UnitDuration extends Dimension {
        static hours: UnitDuration;
        static microseconds: UnitDuration;
        static milliseconds: UnitDuration;
        static minutes: UnitDuration;
        static nanoseconds: UnitDuration;
        static picoseconds: UnitDuration;
        static seconds: UnitDuration;
    }
    class UnitElectricCharge extends Dimension {
        static ampereHours: UnitElectricCharge;
        static coulombs: UnitElectricCharge;
        static kiloampereHours: UnitElectricCharge;
        static megaampereHours: UnitElectricCharge;
        static microampereHours: UnitElectricCharge;
        static milliampereHours: UnitElectricCharge;
    }
    class UnitElectricCurrent extends Dimension {
        static amperes: UnitElectricCurrent;
        static kiloamperes: UnitElectricCurrent;
        static megaamperes: UnitElectricCurrent;
        static microamperes: UnitElectricCurrent;
        static milliamperes: UnitElectricCurrent;
    }
    class UnitElectricPotentialDifference extends Dimension {
        static kilovolts: UnitElectricPotentialDifference;
        static megavolts: UnitElectricPotentialDifference;
        static microvolts: UnitElectricPotentialDifference;
        static millivolts: UnitElectricPotentialDifference;
        static volts: UnitElectricPotentialDifference;
    }
    class UnitElectricResistance extends Dimension {
        static kiloohms: UnitElectricResistance;
        static megaohms: UnitElectricResistance;
        static microohms: UnitElectricResistance;
        static milliohms: UnitElectricResistance;
        static ohms: UnitElectricResistance;
    }
    class UnitEnergy extends Dimension {
        static calories: UnitEnergy;
        static joules: UnitEnergy;
        static kilocalories: UnitEnergy;
        static kilojoules: UnitEnergy;
        static kilowattHours: UnitEnergy;
    }
    class UnitFrequency extends Dimension {
        static framesPerSecond: UnitFrequency;
        static gigahertz: UnitFrequency;
        static hertz: UnitFrequency;
        static kilohertz: UnitFrequency;
        static megahertz: UnitFrequency;
        static microhertz: UnitFrequency;
        static millihertz: UnitFrequency;
        static nanohertz: UnitFrequency;
        static terahertz: UnitFrequency;
    }
    class UnitFuelEfficiency extends Dimension {
        static litersPer100Kilometers: UnitFuelEfficiency;
        static milesPerGallon: UnitFuelEfficiency;
        static milesPerImperialGallon: UnitFuelEfficiency;
    }
    class UnitIlluminance extends Dimension {
        static lux: UnitIlluminance;
    }
    class NSUnitInformationStorage extends Dimension {
        static bits: NSUnitInformationStorage;
        static bytes: NSUnitInformationStorage;
        static exabits: NSUnitInformationStorage;
        static exabytes: NSUnitInformationStorage;
        static exbibits: NSUnitInformationStorage;
        static exbibytes: NSUnitInformationStorage;
        static gibibits: NSUnitInformationStorage;
        static gibibytes: NSUnitInformationStorage;
        static gigabits: NSUnitInformationStorage;
        static gigabytes: NSUnitInformationStorage;
        static kibibits: NSUnitInformationStorage;
        static kibibytes: NSUnitInformationStorage;
        static kilobits: NSUnitInformationStorage;
        static kilobytes: NSUnitInformationStorage;
        static mebibits: NSUnitInformationStorage;
        static mebibytes: NSUnitInformationStorage;
        static megabits: NSUnitInformationStorage;
        static megabytes: NSUnitInformationStorage;
        static nibbles: NSUnitInformationStorage;
        static pebibits: NSUnitInformationStorage;
        static pebibytes: NSUnitInformationStorage;
        static petabits: NSUnitInformationStorage;
        static petabytes: NSUnitInformationStorage;
        static tebibits: NSUnitInformationStorage;
        static tebibytes: NSUnitInformationStorage;
        static terabits: NSUnitInformationStorage;
        static terabytes: NSUnitInformationStorage;
        static yobibits: NSUnitInformationStorage;
        static yobibytes: NSUnitInformationStorage;
        static yottabits: NSUnitInformationStorage;
        static yottabytes: NSUnitInformationStorage;
        static zebibits: NSUnitInformationStorage;
        static zebibytes: NSUnitInformationStorage;
        static zettabits: NSUnitInformationStorage;
        static zettabytes: NSUnitInformationStorage;
    }
    class UnitLength extends Dimension {
        static astronomicalUnits: UnitLength;
        static centimeters: UnitLength;
        static decameters: UnitLength;
        static decimeters: UnitLength;
        static fathoms: UnitLength;
        static feet: UnitLength;
        static furlongs: UnitLength;
        static hectometers: UnitLength;
        static inches: UnitLength;
        static kilometers: UnitLength;
        static lightyears: UnitLength;
        static megameters: UnitLength;
        static meters: UnitLength;
        static micrometers: UnitLength;
        static miles: UnitLength;
        static millimeters: UnitLength;
        static nanometers: UnitLength;
        static nauticalMiles: UnitLength;
        static parsecs: UnitLength;
        static picometers: UnitLength;
        static scandinavianMiles: UnitLength;
        static yards: UnitLength;
    }
    class UnitMass extends Dimension {
        static carats: UnitMass;
        static centigrams: UnitMass;
        static decigrams: UnitMass;
        static grams: UnitMass;
        static kilograms: UnitMass;
        static metricTons: UnitMass;
        static micrograms: UnitMass;
        static milligrams: UnitMass;
        static nanograms: UnitMass;
        static ounces: UnitMass;
        static ouncesTroy: UnitMass;
        static picograms: UnitMass;
        static poundsMass: UnitMass;
        static shortTons: UnitMass;
        static slugs: UnitMass;
        static stones: UnitMass;
    }
    class UnitPower extends Dimension {
        static femtowatts: UnitPower;
        static gigawatts: UnitPower;
        static horsepower: UnitPower;
        static kilowatts: UnitPower;
        static megawatts: UnitPower;
        static microwatts: UnitPower;
        static milliwatts: UnitPower;
        static nanowatts: UnitPower;
        static picowatts: UnitPower;
        static terawatts: UnitPower;
        static watts: UnitPower;
    }
    class UnitPressure extends Dimension {
        static bars: UnitPressure;
        static gigapascals: UnitPressure;
        static hectopascals: UnitPressure;
        static inchesOfMercury: UnitPressure;
        static kilopascals: UnitPressure;
        static megapascals: UnitPressure;
        static millibars: UnitPressure;
        static millimetersOfMercury: UnitPressure;
        static newtonsPerMetersSquared: UnitPressure;
        static poundsForcePerSquareInch: UnitPressure;
    }
    class UnitSpeed extends Dimension {
        static kilometersPerHour: UnitSpeed;
        static knots: UnitSpeed;
        static metersPerSecond: UnitSpeed;
        static milesPerHour: UnitSpeed;
    }
    class UnitTemperature extends Dimension {
        static celsius: UnitTemperature;
        static fahrenheit: UnitTemperature;
        static kelvin: UnitTemperature;
    }
    class UnitVolume extends Dimension {
        static acreFeet: UnitVolume;
        static bushels: UnitVolume;
        static centiliters: UnitVolume;
        static cubicCentimeters: UnitVolume;
        static cubicDecimeters: UnitVolume;
        static cubicFeet: UnitVolume;
        static cubicInches: UnitVolume;
        static cubicKilometers: UnitVolume;
        static cubicMeters: UnitVolume;
        static cubicMiles: UnitVolume;
        static cubicMillimeters: UnitVolume;
        static cubicYards: UnitVolume;
        static cups: UnitVolume;
        static deciliters: UnitVolume;
        static fluidOunces: UnitVolume;
        static gallons: UnitVolume;
        static imperialFluidOunces: UnitVolume;
        static imperialGallons: UnitVolume;
        static imperialPints: UnitVolume;
        static imperialQuarts: UnitVolume;
        static imperialTablespoons: UnitVolume;
        static imperialTeaspoons: UnitVolume;
        static kiloliters: UnitVolume;
        static liters: UnitVolume;
        static megaliters: UnitVolume;
        static metricCups: UnitVolume;
        static milliliters: UnitVolume;
        static pints: UnitVolume;
        static quarts: UnitVolume;
        static tablespoons: UnitVolume;
        static teaspoons: UnitVolume;
    }
    class NSUserActivity extends NSObject {
        activityType: string;
        delegate: NSUserActivityDelegate;
        setDelegate(_: NSUserActivityDelegate): any;
        detectedBarcodeDescriptor: CIBarcodeDescriptor;
        isEligibleForHandoff: boolean;
        setEligibleForHandoff(_: boolean): any;
        isEligibleForPublicIndexing: boolean;
        setEligibleForPublicIndexing(_: boolean): any;
        isEligibleForSearch: boolean;
        setEligibleForSearch(_: boolean): any;
        expirationDate: Date;
        setExpirationDate(_: Date): any;
        keywords: NSSet<string>;
        setKeywords(_: NSSet<string>): any;
        needsSave: boolean;
        setNeedsSave(_: boolean): any;
        referrerURL: NSURL;
        setReferrerURL(_: NSURL): any;
        requiredUserInfoKeys: NSSet<string>;
        setRequiredUserInfoKeys(_: NSSet<string>): any;
        supportsContinuationStreams: boolean;
        setSupportsContinuationStreams(_: boolean): any;
        targetContentIdentifier: string;
        setTargetContentIdentifier(_: string): any;
        title: string;
        setTitle(_: string): any;
        userInfo: Map<any, any>;
        setUserInfo(_: Map<any, any>): any;
        webpageURL: NSURL;
        setWebpageURL(_: NSURL): any;
        addUserInfoEntriesFromDictionary(from: Map<any, any>): void;
        becomeCurrent(): void;
        getContinuationStreamsWithCompletionHandler(completionHandler?: (p1: InputStream, p2: OutputStream, p3: NSError) => void): void;
        static createWithActivityType(activityType: string): NSUserActivity;
        invalidate(): void;
        resignCurrent(): void;
    }
    interface NSUserActivityDelegate extends NSObject {
        userActivityDidReceiveInputStreamOutputStream?(_: NSUserActivity, didReceive: InputStream, outputStream: OutputStream): void;
        userActivityWasContinued?(_: NSUserActivity): void;
        userActivityWillSave?(_: NSUserActivity): void;
    }
    class NSUserAppleScriptTask extends NSUserScriptTask {
        executeWithWithAppleEventCompletionHandler(withAppleEvent?: NSAppleEventDescriptor, completionHandler?: (p1: NSAppleEventDescriptor, p2: NSError) => void): void;
    }
    class NSUserAutomatorTask extends NSUserScriptTask {
        variables: Map<string, any>;
        setVariables(_: Map<string, any>): any;
        executeWithWithInputCompletionHandler(withInput?: NSSecureCoding, completionHandler?: (p1: any, p2: NSError) => void): void;
    }
    class UserDefaults extends NSObject {
        static resetStandardUserDefaults(): void;
        volatileDomainNames: string[];
        static standardUserDefaults: UserDefaults;
        URLForKey(_: string): NSURL;
        addSuiteNamed(named: string): void;
        arrayForKey(_: string): any[];
        boolForKey(_: string): boolean;
        dataForKey(_: string): NSData;
        dictionaryForKey(_: string): Map<string, any>;
        dictionaryRepresentation(): Map<string, any>;
        doubleForKey(_: string): number;
        floatForKey(_: string): number;
        static createWithSuiteName(suiteName?: string): UserDefaults;
        integerForKey(_: string): number;
        objectForKey(_: string): any;
        objectIsForcedForKey(_: string): boolean;
        objectIsForcedForKeyInDomain(_: string, inDomain: string): boolean;
        persistentDomainForName(_: string): Map<string, any>;
        registerDefaults(defaults: Map<string, any>): void;
        removeObjectForKey(_: string): void;
        removePersistentDomainForName(_: string): void;
        removeSuiteNamed(named: string): void;
        removeVolatileDomainForName(_: string): void;
        setBoolForKey(_: boolean, forKey: string): void;
        setDoubleForKey(_: number, forKey: string): void;
        setFloatForKey(_: number, forKey: string): void;
        setIntegerForKey(_: number, forKey: string): void;
        setObjectForKey(_?: any, forKey?: string): void;
        setPersistentDomainForName(_: Map<string, any>, forName: string): void;
        setURLForKey(_?: NSURL, forKey?: string): void;
        setVolatileDomainForName(_: Map<string, any>, forName: string): void;
        stringArrayForKey(_: string): string[];
        stringForKey(_: string): string;
        synchronize(): boolean;
        volatileDomainForName(_: string): Map<string, any>;
    }
    class NSUserNotification extends NSObject {
        actionButtonTitle: string;
        setActionButtonTitle(_: string): any;
        activationType: NSUserNotification.ActivationType;
        actualDeliveryDate: Date;
        additionalActions: NSUserNotificationAction[];
        setAdditionalActions(_: NSUserNotificationAction[]): any;
        additionalActivationAction: NSUserNotificationAction;
        contentImage: NSImage;
        setContentImage(_: NSImage): any;
        deliveryDate: Date;
        setDeliveryDate(_: Date): any;
        deliveryRepeatInterval: NSDateComponents;
        setDeliveryRepeatInterval(_: NSDateComponents): any;
        deliveryTimeZone: NSTimeZone;
        setDeliveryTimeZone(_: NSTimeZone): any;
        hasActionButton: boolean;
        setHasActionButton(_: boolean): any;
        hasReplyButton: boolean;
        setHasReplyButton(_: boolean): any;
        identifier: string;
        setIdentifier(_: string): any;
        informativeText: string;
        setInformativeText(_: string): any;
        otherButtonTitle: string;
        setOtherButtonTitle(_: string): any;
        isPresented: boolean;
        isRemote: boolean;
        response: NSAttributedString;
        responsePlaceholder: string;
        setResponsePlaceholder(_: string): any;
        soundName: string;
        setSoundName(_: string): any;
        subtitle: string;
        setSubtitle(_: string): any;
        title: string;
        setTitle(_: string): any;
        userInfo: Map<string, any>;
        setUserInfo(_: Map<string, any>): any;
    }
    class NSUserNotificationAction extends NSObject {
        static actionWithIdentifierTitle(identifier?: string, title?: string): NSUserNotificationAction;
        identifier: string;
        title: string;
    }
    class NSUserNotificationCenter extends NSObject {
        delegate: NSUserNotificationCenterDelegate;
        setDelegate(_: NSUserNotificationCenterDelegate): any;
        deliveredNotifications: NSUserNotification[];
        scheduledNotifications: NSUserNotification[];
        setScheduledNotifications(_: NSUserNotification[]): any;
        static defaultUserNotificationCenter: NSUserNotificationCenter;
        deliverNotification(_: NSUserNotification): void;
        removeAllDeliveredNotifications(): void;
        removeDeliveredNotification(_: NSUserNotification): void;
        removeScheduledNotification(_: NSUserNotification): void;
        scheduleNotification(_: NSUserNotification): void;
    }
    interface NSUserNotificationCenterDelegate extends NSObject {
        userNotificationCenterDidDeliverNotification?(_: NSUserNotificationCenter, didDeliver: NSUserNotification): void;
        userNotificationCenterDidActivateNotification?(_: NSUserNotificationCenter, didActivate: NSUserNotification): void;
        userNotificationCenterShouldPresentNotification?(_: NSUserNotificationCenter, shouldPresent: NSUserNotification): boolean;
    }
    class NSUserScriptTask extends NSObject {
        scriptURL: NSURL;
        executeWithCompletionHandler(completionHandler?: (p1: NSError) => void): void;
        static createWithUrl(URL: NSURL): NSUserScriptTask;
    }
    class NSUserUnixTask extends NSUserScriptTask {
        standardError: FileHandle;
        setStandardError(_: FileHandle): any;
        standardInput: FileHandle;
        setStandardInput(_: FileHandle): any;
        standardOutput: FileHandle;
        setStandardOutput(_: FileHandle): any;
        executeWithWithArgumentsCompletionHandler(withArguments?: string[], completionHandler?: (p1: NSError) => void): void;
    }
    class NSValue extends NSObject {
        static valueWithCMTime(time: CMTime): NSValue;
        static valueWithCMTimeMapping(timeMapping: CMTimeMapping): NSValue;
        static valueWithCMTimeRange(timeRange: CMTimeRange): NSValue;
        CATransform3DValue: CATransform3D;
        CMTimeMappingValue: CMTimeMapping;
        CMTimeRangeValue: CMTimeRange;
        CMTimeValue: CMTime;
        edgeInsetsValue: NSEdgeInsets;
        nonretainedObjectValue: any;
        objCType: string;
        pointValue: CGPoint;
        pointerValue: any;
        rangeValue: NSRange;
        rectValue: CGRect;
        sizeValue: CGSize;
        getValue(_: any): void;
        getValueSize(_: any, size: number): void;
        static createWithBytesObjCType(bytes: any, objCType: string): NSValue;
        isEqualToValue(to: NSValue): boolean;
    }
    class ValueTransformer extends NSObject {
        static allowsReverseTransformation(): boolean;
        static setValueTransformerForName(_?: ValueTransformer, forName?: string): void;
        static transformedValueClass(): typeof NSObject;
        static valueTransformerNames(): string[];
        reverseTransformedValue(_?: any): any;
        transformedValue(_?: any): any;
    }
    class NSWhoseSpecifier extends NSScriptObjectSpecifier {
        endSubelementIdentifier: NSWhoseSpecifier.SubelementIdentifier;
        setEndSubelementIdentifier(_: NSWhoseSpecifier.SubelementIdentifier): any;
        endSubelementIndex: number;
        setEndSubelementIndex(_: number): any;
        startSubelementIdentifier: NSWhoseSpecifier.SubelementIdentifier;
        setStartSubelementIdentifier(_: NSWhoseSpecifier.SubelementIdentifier): any;
        startSubelementIndex: number;
        setStartSubelementIndex(_: number): any;
        test: NSScriptWhoseTest;
        setTest(_: NSScriptWhoseTest): any;
        static createWithContainerClassDescriptionContainerSpecifierKeyTest(containerClassDescription: NSScriptClassDescription, containerSpecifier?: NSScriptObjectSpecifier, key?: string, test?: NSScriptWhoseTest): NSWhoseSpecifier;
    }
    class XMLDTD extends XMLNode {
        static predefinedEntityDeclarationForName(_: string): XMLDTDNode;
        publicID: string;
        setPublicID(_: string): any;
        systemID: string;
        setSystemID(_: string): any;
        addChild(_: XMLNode): void;
        attributeDeclarationForNameElementName(_: string, elementName: string): XMLDTDNode;
        elementDeclarationForName(_: string): XMLDTDNode;
        entityDeclarationForName(_: string): XMLDTDNode;
        static createWithContentsOfURLOptions(contentsOfURL: NSURL, options: XMLNode.Options): XMLDTD;
        static createWithDataOptions(data: NSData, options: XMLNode.Options): XMLDTD;
        insertChildAtIndex(_: XMLNode, atIndex: number): void;
        insertChildrenAtIndex(_: XMLNode[], atIndex: number): void;
        notationDeclarationForName(_: string): XMLDTDNode;
        removeChildAtIndex(_: number): void;
        replaceChildAtIndexWithNode(_: number, withNode: XMLNode): void;
        setChildren(_?: XMLNode[]): void;
    }
    class XMLDTDNode extends XMLNode {
        DTDKind: XMLDTDNode.DTDKind;
        setDTDKind(_: XMLDTDNode.DTDKind): any;
        isExternal: boolean;
        notationName: string;
        setNotationName(_: string): any;
        publicID: string;
        setPublicID(_: string): any;
        systemID: string;
        setSystemID(_: string): any;
        static createWithXMLString(XMLString: string): XMLDTDNode;
    }
    class XMLDocument extends XMLNode {
        static replacementClassForClass(_: typeof NSObject): typeof NSObject;
        DTD: XMLDTD;
        setDTD(_: XMLDTD): any;
        MIMEType: string;
        setMIMEType(_: string): any;
        XMLData: NSData;
        characterEncoding: string;
        setCharacterEncoding(_: string): any;
        documentContentKind: XMLDocument.ContentKind;
        setDocumentContentKind(_: XMLDocument.ContentKind): any;
        isStandalone: boolean;
        setStandalone(_: boolean): any;
        XMLDataWithOptions(_: XMLNode.Options): NSData;
        addChild(_: XMLNode): void;
        static createWithContentsOfURLOptions(contentsOfURL: NSURL, options: XMLNode.Options): XMLDocument;
        static createWithDataOptions(data: NSData, options: XMLNode.Options): XMLDocument;
        static createWithRootElement(rootElement?: XMLElement): XMLDocument;
        static createWithXMLStringOptions(XMLString: string, options: XMLNode.Options): XMLDocument;
        insertChildAtIndex(_: XMLNode, atIndex: number): void;
        insertChildrenAtIndex(_: XMLNode[], atIndex: number): void;
        objectByApplyingXSLTArgumentsError(arguments_: NSData, error?: Map<string, string>): any;
        objectByApplyingXSLTAtURLArgumentsError(arguments_: NSURL, error?: Map<string, string>): any;
        objectByApplyingXSLTStringArgumentsError(arguments_: string, error?: Map<string, string>): any;
        removeChildAtIndex(_: number): void;
        replaceChildAtIndexWithNode(_: number, withNode: XMLNode): void;
        rootElement(): XMLElement;
        setChildren(_?: XMLNode[]): void;
        setRootElement(_: XMLElement): void;
        validateAndReturnError(): boolean;
    }
    class XMLElement extends XMLNode {
        attributes: XMLNode[];
        setAttributes(_: XMLNode[]): any;
        namespaces: XMLNode[];
        setNamespaces(_: XMLNode[]): any;
        addAttribute(_: XMLNode): void;
        addChild(_: XMLNode): void;
        addNamespace(_: XMLNode): void;
        attributeForLocalNameUri(_: string, URI?: string): XMLNode;
        attributeForName(_: string): XMLNode;
        elementsForLocalNameUri(_: string, URI?: string): XMLElement[];
        elementsForName(_: string): XMLElement[];
        static createWithName(name: string): XMLElement;
        static createWithNameUri(name: string, URI?: string): XMLElement;
        static createWithNameStringValue(name: string, stringValue?: string): XMLElement;
        static createWithXMLString(XMLString: string): XMLElement;
        insertChildAtIndex(_: XMLNode, atIndex: number): void;
        insertChildrenAtIndex(_: XMLNode[], atIndex: number): void;
        namespaceForPrefix(_: string): XMLNode;
        normalizeAdjacentTextNodesPreservingCDATA(_: boolean): void;
        removeAttributeForName(_: string): void;
        removeChildAtIndex(_: number): void;
        removeNamespaceForPrefix(_: string): void;
        replaceChildAtIndexWithNode(_: number, withNode: XMLNode): void;
        resolveNamespaceForName(_: string): XMLNode;
        resolvePrefixForNamespaceURI(_: string): string;
        setAttributesAsDictionary(_: Map<any, any>): void;
        setAttributesWithDictionary(_: Map<string, string>): void;
        setChildren(_?: XMLNode[]): void;
    }
    class XMLNode extends NSObject {
        static DTDNodeWithXMLString(_: string): any;
        static attributeWithNameUriStringValue(_: string, URI: string, stringValue: string): any;
        static attributeWithNameStringValue(_: string, stringValue: string): any;
        static commentWithStringValue(_: string): any;
        static document(): any;
        static documentWithRootElement(_: XMLElement): any;
        static elementWithName(_: string): any;
        static elementWithNameUri(_: string, URI: string): any;
        static elementWithNameChildrenAttributes(_: string, children?: XMLNode[], attributes?: XMLNode[]): any;
        static elementWithNameStringValue(_: string, stringValue: string): any;
        static localNameForName(_: string): string;
        static namespaceWithNameStringValue(_: string, stringValue: string): any;
        static predefinedNamespaceForPrefix(_: string): XMLNode;
        static prefixForName(_: string): string;
        static processingInstructionWithNameStringValue(_: string, stringValue: string): any;
        static textWithStringValue(_: string): any;
        URI: string;
        setURI(_: string): any;
        XMLString: string;
        XPath: string;
        childCount: number;
        children: XMLNode[];
        index: number;
        kind: XMLNode.Kind;
        level: number;
        localName: string;
        name: string;
        setName(_: string): any;
        nextNode: XMLNode;
        nextSibling: XMLNode;
        objectValue: any;
        setObjectValue(_: any): any;
        parent: XMLNode;
        prefix: string;
        previousNode: XMLNode;
        previousSibling: XMLNode;
        rootDocument: XMLDocument;
        stringValue: string;
        setStringValue(_: string): any;
        XMLStringWithOptions(_: XMLNode.Options): string;
        canonicalXMLStringPreservingComments(_: boolean): string;
        childAtIndex(_: number): XMLNode;
        detach(): void;
        static createWithKind(kind: XMLNode.Kind): XMLNode;
        static createWithKindOptions(kind: XMLNode.Kind, options: XMLNode.Options): XMLNode;
        nodesForXPathError(error: string): XMLNode[];
        objectsForXQueryConstantsError(constants: string, error?: Map<string, any>): any[];
        objectsForXQueryError(error: string): any[];
        setStringValueResolvingEntities(_: string, resolvingEntities: boolean): void;
    }
    class XMLParser extends NSObject {
        allowedExternalEntityURLs: NSSet<NSURL>;
        setAllowedExternalEntityURLs(_: NSSet<NSURL>): any;
        columnNumber: number;
        delegate: XMLParserDelegate;
        setDelegate(_: XMLParserDelegate): any;
        externalEntityResolvingPolicy: XMLParser.ExternalEntityResolvingPolicy;
        setExternalEntityResolvingPolicy(_: XMLParser.ExternalEntityResolvingPolicy): any;
        lineNumber: number;
        parserError: NSError;
        publicID: string;
        shouldProcessNamespaces: boolean;
        setShouldProcessNamespaces(_: boolean): any;
        shouldReportNamespacePrefixes: boolean;
        setShouldReportNamespacePrefixes(_: boolean): any;
        shouldResolveExternalEntities: boolean;
        setShouldResolveExternalEntities(_: boolean): any;
        systemID: string;
        abortParsing(): void;
        static createWithContentsOfURL(contentsOfURL: NSURL): XMLParser;
        static createWithData(data: NSData): XMLParser;
        static createWithStream(stream: InputStream): XMLParser;
        parse(): boolean;
    }
    interface XMLParserDelegate extends NSObject {
        parserDidEndElementNamespaceURIQualifiedName?(_: XMLParser, didEndElement: string, namespaceURI?: string, qualifiedName?: string): void;
        parserDidEndMappingPrefix?(_: XMLParser, didEndMappingPrefix: string): void;
        parserDidStartElementNamespaceURIQualifiedNameAttributes?(_: XMLParser, didStartElement: string, namespaceURI?: string, qualifiedName?: string, attributes?: Map<string, string>): void;
        parserDidStartMappingPrefixToURI?(_: XMLParser, didStartMappingPrefix: string, toURI: string): void;
        parserFoundAttributeDeclarationWithNameForElementTypeDefaultValue?(_: XMLParser, foundAttributeDeclarationWithName: string, forElement: string, type?: string, defaultValue?: string): void;
        parserFoundCDATA?(_: XMLParser, foundCDATA: NSData): void;
        parserFoundCharacters?(_: XMLParser, foundCharacters: string): void;
        parserFoundComment?(_: XMLParser, foundComment: string): void;
        parserFoundElementDeclarationWithNameModel?(_: XMLParser, foundElementDeclarationWithName: string, model: string): void;
        parserFoundExternalEntityDeclarationWithNamePublicIDSystemID?(_: XMLParser, foundExternalEntityDeclarationWithName: string, publicID?: string, systemID?: string): void;
        parserFoundIgnorableWhitespace?(_: XMLParser, foundIgnorableWhitespace: string): void;
        parserFoundInternalEntityDeclarationWithNameValue?(_: XMLParser, foundInternalEntityDeclarationWithName: string, value?: string): void;
        parserFoundNotationDeclarationWithNamePublicIDSystemID?(_: XMLParser, foundNotationDeclarationWithName: string, publicID?: string, systemID?: string): void;
        parserFoundProcessingInstructionWithTargetData?(_: XMLParser, foundProcessingInstructionWithTarget: string, data?: string): void;
        parserFoundUnparsedEntityDeclarationWithNamePublicIDSystemIDNotationName?(_: XMLParser, foundUnparsedEntityDeclarationWithName: string, publicID?: string, systemID?: string, notationName?: string): void;
        parserParseErrorOccurred?(_: XMLParser, parseErrorOccurred: NSError): void;
        parserResolveExternalEntityNameSystemID?(_: XMLParser, resolveExternalEntityName: string, systemID?: string): NSData;
        parserValidationErrorOccurred?(_: XMLParser, validationErrorOccurred: NSError): void;
        parserDidEndDocument?(_: XMLParser): void;
        parserDidStartDocument?(_: XMLParser): void;
    }
    class NSXPCCoder extends NSCoder {
        connection: NSXPCConnection;
        userInfo: NSObject;
        setUserInfo(_: NSObject): any;
        decodeXPCObjectOfTypeForKey(ofType: any, forKey: string): NSObject;
        encodeXPCObjectForKey(_: NSObject, forKey: string): void;
    }
    class NSXPCConnection extends NSObject {
        static currentConnection(): NSXPCConnection;
        auditSessionIdentifier: number;
        effectiveGroupIdentifier: number;
        effectiveUserIdentifier: number;
        endpoint: NSXPCListenerEndpoint;
        exportedInterface: NSXPCInterface;
        setExportedInterface(_: NSXPCInterface): any;
        exportedObject: any;
        setExportedObject(_: any): any;
        interruptionHandler: () => void;
        setInterruptionHandler(_: () => void): any;
        invalidationHandler: () => void;
        setInvalidationHandler(_: () => void): any;
        processIdentifier: number;
        remoteObjectInterface: NSXPCInterface;
        setRemoteObjectInterface(_: NSXPCInterface): any;
        remoteObjectProxy: any;
        serviceName: string;
        static createWithListenerEndpoint(listenerEndpoint: NSXPCListenerEndpoint): NSXPCConnection;
        static createWithMachServiceNameOptions(machServiceName: string, options: NSXPCConnection.Options): NSXPCConnection;
        static createWithServiceName(serviceName: string): NSXPCConnection;
        invalidate(): void;
        resume(): void;
        scheduleSendBarrierBlock(_: () => void): void;
        suspend(): void;
    }
    class NSXPCInterface extends NSObject {
        static interfaceWithProtocol(with_: any): NSXPCInterface;
        protocol: any;
        setProtocol(_: any): any;
        XPCTypeForSelectorArgumentIndexOfReply(for_: string, argumentIndex: number, ofReply: boolean): any;
        classesForSelectorArgumentIndexOfReply(for_: string, argumentIndex: number, ofReply: boolean): NSSet<typeof NSObject>;
        interfaceForSelectorArgumentIndexOfReply(_: string, argumentIndex: number, ofReply: boolean): NSXPCInterface;
        setClassesForArgumentIndexOfReply(_: NSSet<typeof NSObject>, for_: string, argumentIndex: number, ofReply: boolean): void;
        setInterfaceForSelectorArgumentIndexOfReply(_: NSXPCInterface, for_: string, argumentIndex: number, ofReply: boolean): void;
        setXPCTypeForSelectorArgumentIndexOfReply(_: any, for_: string, argumentIndex: number, ofReply: boolean): void;
    }
    class NSXPCListener extends NSObject {
        static anonymousListener(): NSXPCListener;
        static serviceListener(): NSXPCListener;
        delegate: NSXPCListenerDelegate;
        setDelegate(_: NSXPCListenerDelegate): any;
        endpoint: NSXPCListenerEndpoint;
        static createWithMachServiceName(machServiceName: string): NSXPCListener;
        invalidate(): void;
        resume(): void;
        suspend(): void;
    }
    interface NSXPCListenerDelegate extends NSObject {
        listenerShouldAcceptNewConnection?(_: NSXPCListener, shouldAcceptNewConnection: NSXPCConnection): boolean;
    }
    class NSXPCListenerEndpoint extends NSObject {
    }
    interface NSXPCProxyCreating {
        remoteObjectProxy: any;
        remoteObjectProxyWithErrorHandler(_: (p1: NSError) => void): any;
        synchronousRemoteObjectProxyWithErrorHandler?(_: (p1: NSError) => void): any;
    }
    class IKCameraDeviceView extends NSView {
        cameraDevice: ICCameraDevice;
        setCameraDevice(_: ICCameraDevice): any;
        canDeleteSelectedItems: boolean;
        canDownloadSelectedItems: boolean;
        canRotateSelectedItemsLeft: boolean;
        canRotateSelectedItemsRight: boolean;
        delegate: IKCameraDeviceViewDelegate;
        setDelegate(_: IKCameraDeviceViewDelegate): any;
        displaysDownloadsDirectoryControl: boolean;
        setDisplaysDownloadsDirectoryControl(_: boolean): any;
        displaysPostProcessApplicationControl: boolean;
        setDisplaysPostProcessApplicationControl(_: boolean): any;
        downloadAllControlLabel: string;
        setDownloadAllControlLabel(_: string): any;
        downloadSelectedControlLabel: string;
        setDownloadSelectedControlLabel(_: string): any;
        downloadsDirectory: NSURL;
        setDownloadsDirectory(_: NSURL): any;
        hasDisplayModeIcon: boolean;
        setHasDisplayModeIcon(_: boolean): any;
        hasDisplayModeTable: boolean;
        setHasDisplayModeTable(_: boolean): any;
        iconSize: number;
        setIconSize(_: number): any;
        mode: IKCameraDeviceViewDisplayMode;
        setMode(_: IKCameraDeviceViewDisplayMode): any;
        postProcessApplication: NSURL;
        setPostProcessApplication(_: NSURL): any;
        transferMode: IKCameraDeviceViewTransferMode;
        setTransferMode(_: IKCameraDeviceViewTransferMode): any;
        deleteSelectedItems(_: any): void;
        downloadAllItems(_: any): void;
        downloadSelectedItems(_: any): void;
        rotateLeft(_: any): void;
        rotateRight(_: any): void;
        selectIndexesByExtendingSelection(_: NSIndexSet, byExtendingSelection: boolean): void;
        selectedIndexes(): NSIndexSet;
    }
    interface IKCameraDeviceViewDelegate {
        cameraDeviceViewDidDownloadFileLocationFileDataError?(_: IKCameraDeviceView, didDownloadFile: ICCameraFile, location: NSURL, fileData: NSData, error: NSError): void;
        cameraDeviceViewDidEncounterError?(_: IKCameraDeviceView, didEncounterError: NSError): void;
        cameraDeviceViewSelectionDidChange?(_: IKCameraDeviceView): void;
    }
    class IKDeviceBrowserView extends NSView {
        delegate: IKDeviceBrowserViewDelegate;
        setDelegate(_: IKDeviceBrowserViewDelegate): any;
        displaysLocalCameras: boolean;
        setDisplaysLocalCameras(_: boolean): any;
        displaysLocalScanners: boolean;
        setDisplaysLocalScanners(_: boolean): any;
        displaysNetworkCameras: boolean;
        setDisplaysNetworkCameras(_: boolean): any;
        displaysNetworkScanners: boolean;
        setDisplaysNetworkScanners(_: boolean): any;
        mode: IKDeviceBrowserViewDisplayMode;
        setMode(_: IKDeviceBrowserViewDisplayMode): any;
        selectedDevice: ICDevice;
    }
    interface IKDeviceBrowserViewDelegate {
        deviceBrowserViewDidEncounterError?(_: IKDeviceBrowserView, didEncounterError: NSError): void;
        deviceBrowserViewSelectionDidChange(_: IKDeviceBrowserView, selectionDidChange: ICDevice): void;
    }
    class IKFilterBrowserPanel extends NSPanel {
        static filterBrowserPanelWithStyleMask(withStyleMask: number): any;
        beginSheetWithOptionsModalForWindowModalDelegateDidEndSelectorContextInfo(options: Map<any, any>, modalFor: NSWindow, modalDelegate: any, didEnd: string, contextInfo: any): void;
        beginWithOptionsModelessDelegateDidEndSelectorContextInfo(options: Map<any, any>, modelessDelegate: any, didEnd: string, contextInfo: any): void;
        filterBrowserViewWithOptions(options: Map<any, any>): IKFilterBrowserView;
        filterName(): string;
        finish(_: any): void;
        runModalWithOptions(options: Map<any, any>): number;
    }
    class IKFilterBrowserView extends NSView {
        filterName(): string;
        setPreviewState(_: boolean): void;
    }
    interface IKFilterCustomUIProvider {
        provideViewForUIConfigurationExcludedKeys(forUIConfiguration: Map<any, any>, excludedKeys: any[]): IKFilterUIView;
    }
    class IKFilterUIView extends NSView {
        static viewWithFrameFilter(withFrame: CGRect, filter: CIFilter): any;
        filter(): CIFilter;
        static createWithFrameFilter(frame: CGRect, filter: CIFilter): IKFilterUIView;
        objectController(): NSObjectController;
    }
    class IKImageBrowserCell extends NSObject {
        cellState(): IKImageBrowserCellState;
        frame(): CGRect;
        imageAlignment(): NSImageAlignment;
        imageContainerFrame(): CGRect;
        imageFrame(): CGRect;
        indexOfRepresentedItem(): number;
        isSelected(): boolean;
        layerForType(forType: string): CALayer;
        opacity(): number;
        representedItem(): any;
        selectionFrame(): CGRect;
        subtitleFrame(): CGRect;
        titleFrame(): CGRect;
    }
    class IKImageEditPanel extends NSPanel {
        static sharedImageEditPanel(): IKImageEditPanel;
        dataSource: IKImageEditPanelDataSource;
        setDataSource(_: IKImageEditPanelDataSource): any;
        filterArray: any[];
        reloadData(): void;
    }
    interface IKImageEditPanelDataSource {
        hasAdjustMode?(): boolean;
        hasDetailsMode?(): boolean;
        hasEffectsMode?(): boolean;
        image(): any;
        imageProperties?(): Map<any, any>;
        setImageImageProperties(_: any, imageProperties: Map<any, any>): void;
        thumbnailWithMaximumSize?(withMaximumSize: CGSize): any;
    }
    class IKImageView extends NSView {
        autohidesScrollers: boolean;
        setAutohidesScrollers(_: boolean): any;
        autoresizes: boolean;
        setAutoresizes(_: boolean): any;
        backgroundColor: NSColor;
        setBackgroundColor(_: NSColor): any;
        currentToolMode: string;
        setCurrentToolMode(_: string): any;
        delegate: any;
        setDelegate(_: any): any;
        doubleClickOpensImageEditPanel: boolean;
        setDoubleClickOpensImageEditPanel(_: boolean): any;
        editable: boolean;
        setEditable(_: boolean): any;
        hasHorizontalScroller: boolean;
        setHasHorizontalScroller(_: boolean): any;
        hasVerticalScroller: boolean;
        setHasVerticalScroller(_: boolean): any;
        imageCorrection: CIFilter;
        setImageCorrection(_: CIFilter): any;
        rotationAngle: number;
        setRotationAngle(_: number): any;
        supportsDragAndDrop: boolean;
        setSupportsDragAndDrop(_: boolean): any;
        zoomFactor: number;
        setZoomFactor(_: number): any;
        convertImagePointToViewPoint(toViewPoint: CGPoint): CGPoint;
        convertImageRectToViewRect(toViewRect: CGRect): CGRect;
        convertViewPointToImagePoint(toImagePoint: CGPoint): CGPoint;
        convertViewRectToImageRect(toImageRect: CGRect): CGRect;
        crop(_: any): void;
        flipImageHorizontal(_: any): void;
        flipImageVertical(_: any): void;
        image(): any;
        imageProperties(): Map<any, any>;
        imageSize(): CGSize;
        overlayForType(forType: string): CALayer;
        rotateImageLeft(_: any): void;
        rotateImageRight(_: any): void;
        scrollToPoint(to: CGPoint): void;
        scrollToRect(to: CGRect): void;
        setImageImageProperties(_: any, imageProperties: Map<any, any>): void;
        setImageWithURL(_: NSURL): void;
        setImageZoomFactorCenterPoint(_: number, center: CGPoint): void;
        setOverlayForType(_: CALayer, forType: string): void;
        setRotationAngleCenterPoint(_: number, center: CGPoint): void;
        zoomImageToActualSize(_: any): void;
        zoomImageToFit(_: any): void;
        zoomImageToRect(to: CGRect): void;
        zoomIn(_: any): void;
        zoomOut(_: any): void;
    }
    class IKPictureTaker extends NSPanel {
        static pictureTaker(): IKPictureTaker;
        beginPictureTakerSheetForWindowWithDelegateDidEndSelectorContextInfo(for_: NSWindow, withDelegate: any, didEnd: string, contextInfo: any): void;
        beginPictureTakerWithDelegateDidEndSelectorContextInfo(withDelegate: any, didEnd: string, contextInfo: any): void;
        inputImage(): NSImage;
        mirroring(): boolean;
        outputImage(): NSImage;
        popUpRecentsMenuForViewWithDelegateDidEndSelectorContextInfo(for_: NSView, withDelegate: any, didEnd: string, contextInfo: any): void;
        runModal(): number;
        setInputImage(_: NSImage): void;
        setMirroring(_: boolean): void;
    }
    class IKSaveOptions extends NSObject {
        delegate: any;
        setDelegate(_: any): any;
        imageProperties: Map<any, any>;
        imageUTType: string;
        userSelection: Map<any, any>;
        addSaveOptionsAccessoryViewToSavePanel(to: NSSavePanel): void;
        addSaveOptionsToView(to: NSView): void;
        static createWithImagePropertiesImageUTType(imageProperties: Map<any, any>, imageUTType: string): IKSaveOptions;
    }
    class IKScannerDeviceView extends NSView {
        delegate: IKScannerDeviceViewDelegate;
        setDelegate(_: IKScannerDeviceViewDelegate): any;
        displaysDownloadsDirectoryControl: boolean;
        setDisplaysDownloadsDirectoryControl(_: boolean): any;
        displaysPostProcessApplicationControl: boolean;
        setDisplaysPostProcessApplicationControl(_: boolean): any;
        documentName: string;
        setDocumentName(_: string): any;
        downloadsDirectory: NSURL;
        setDownloadsDirectory(_: NSURL): any;
        hasDisplayModeAdvanced: boolean;
        setHasDisplayModeAdvanced(_: boolean): any;
        hasDisplayModeSimple: boolean;
        setHasDisplayModeSimple(_: boolean): any;
        mode: IKScannerDeviceViewDisplayMode;
        setMode(_: IKScannerDeviceViewDisplayMode): any;
        overviewControlLabel: string;
        setOverviewControlLabel(_: string): any;
        postProcessApplication: NSURL;
        setPostProcessApplication(_: NSURL): any;
        scanControlLabel: string;
        setScanControlLabel(_: string): any;
        scannerDevice: ICScannerDevice;
        setScannerDevice(_: ICScannerDevice): any;
        transferMode: IKScannerDeviceViewTransferMode;
        setTransferMode(_: IKScannerDeviceViewTransferMode): any;
    }
    interface IKScannerDeviceViewDelegate {
        scannerDeviceViewDidScanToURLFileDataError?(_: IKScannerDeviceView, didScanTo: NSURL, fileData: NSData, error: NSError): void;
        scannerDeviceViewDidScanToURLError?(_: IKScannerDeviceView, didScanTo: NSURL, error: NSError): void;
        scannerDeviceViewDidScanToBandDataScanInfoError?(_: IKScannerDeviceView, didScanTo: ICScannerBandData, scanInfo: Map<any, any>, error: NSError): void;
        scannerDeviceViewDidEncounterError?(_: IKScannerDeviceView, didEncounterError: NSError): void;
    }
    class IKSlideshow extends NSObject {
        static canExportToApplication(toApplication: string): boolean;
        static exportSlideshowItemToApplication(_: any, toApplication: string): void;
        static sharedSlideshow(): IKSlideshow;
        autoPlayDelay: number;
        setAutoPlayDelay(_: number): any;
        indexOfCurrentSlideshowItem(): number;
        reloadData(): void;
        reloadSlideshowItemAtIndex(at: number): void;
        runSlideshowWithDataSourceInModeOptions(with_: IKSlideshowDataSource, inMode: string, options: Map<any, any>): void;
        stopSlideshow(_: any): void;
    }
    interface IKSlideshowDataSource {
        canExportSlideshowItemAtIndexToApplication?(at: number, toApplication: string): boolean;
        nameOfSlideshowItemAtIndex?(at: number): string;
        numberOfSlideshowItems(): number;
        slideshowDidChangeCurrentIndex?(_: number): void;
        slideshowDidStop?(): void;
        slideshowItemAtIndex(at: number): any;
        slideshowWillStart?(): void;
    }
    interface QLPreviewItem extends NSObject {
        previewItemDisplayState?: any;
        previewItemTitle?: string;
        previewItemURL: NSURL;
    }
    class QLPreviewPanel extends NSPanel {
        static sharedPreviewPanel(): QLPreviewPanel;
        static sharedPreviewPanelExists(): boolean;
        currentController: any;
        currentPreviewItem: QLPreviewItem;
        currentPreviewItemIndex: number;
        setCurrentPreviewItemIndex(_: number): any;
        dataSource: QLPreviewPanelDataSource;
        setDataSource(_: QLPreviewPanelDataSource): any;
        displayState: any;
        setDisplayState(_: any): any;
        isInFullScreenMode: boolean;
        enterFullScreenModeWithOptions(_: NSScreen, withOptions: Map<any, any>): boolean;
        exitFullScreenModeWithOptions(options: Map<any, any>): void;
        refreshCurrentPreviewItem(): void;
        reloadData(): void;
        updateController(): void;
    }
    interface QLPreviewPanelDataSource {
        numberOfPreviewItemsInPreviewPanel(in_: QLPreviewPanel): number;
        previewPanelPreviewItemAtIndex(_: QLPreviewPanel, previewItemAt: number): QLPreviewItem;
    }
    interface QLPreviewPanelDelegate extends NSWindowDelegate {
        previewPanelHandleEvent?(_: QLPreviewPanel, handle: NSEvent): boolean;
        previewPanelSourceFrameOnScreenForPreviewItem?(_: QLPreviewPanel, sourceFrameOnScreenFor: QLPreviewItem): CGRect;
        previewPanelTransitionImageForPreviewItemContentRect?(_: QLPreviewPanel, transitionImageFor: QLPreviewItem, contentRect: NSRect): any;
    }
    class QLPreviewView extends NSView {
        autostarts: boolean;
        setAutostarts(_: boolean): any;
        displayState: any;
        setDisplayState(_: any): any;
        previewItem: QLPreviewItem;
        setPreviewItem(_: QLPreviewItem): any;
        shouldCloseWithWindow: boolean;
        setShouldCloseWithWindow(_: boolean): any;
        close(): void;
        static createWithFrameStyle(frame: CGRect, style: QLPreviewViewStyle): QLPreviewView;
        refreshPreviewItem(): void;
    }
    interface QLPreviewingController extends NSObject {
        preparePreviewOfFileWithAtCompletionHandler?(at: NSURL, completionHandler?: (p1: NSError) => void): void;
        preparePreviewOfSearchableItemWithIdentifierQueryStringCompletionHandler?(identifier: string, queryString?: string, completionHandler?: (p1: NSError) => void): void;
    }
    class QuartzFilter extends NSObject {
        applyToContext(to: any): boolean;
        localizedName(): string;
        properties(): Map<any, any>;
        removeFromContext(from: any): void;
        url(): NSURL;
    }
    class QuartzFilterManager extends NSObject {
        static filtersInDomains(inDomains: any[]): any[];
        delegate(): any;
        filterPanel(): NSPanel;
        filterView(): QuartzFilterView;
        importFilter(_: Map<any, any>): QuartzFilter;
        selectFilter(_: QuartzFilter): boolean;
        selectedFilter(): QuartzFilter;
        setDelegate(_: any): void;
    }
    class QuartzFilterView extends NSView {
        sizeToFit(): void;
    }
    interface CAAction {
        runActionForKeyObjectArguments(forKey: string, object_: any, arguments_?: Map<any, any>): void;
    }
    class CAAnimation extends NSObject {
        static defaultValueForKey(forKey: string): any;
        delegate: CAAnimationDelegate;
        setDelegate(_: CAAnimationDelegate): any;
        isRemovedOnCompletion: boolean;
        setRemovedOnCompletion(_: boolean): any;
        timingFunction: CAMediaTimingFunction;
        setTimingFunction(_: CAMediaTimingFunction): any;
        shouldArchiveValueForKey(forKey: string): boolean;
    }
    interface CAAnimationDelegate extends NSObject {
        animationDidStart?(_: CAAnimation): void;
        animationDidStopFinished?(_: CAAnimation, finished: boolean): void;
    }
    class CAAnimationGroup extends CAAnimation {
        animations: CAAnimation[];
        setAnimations(_: CAAnimation[]): any;
    }
    class CABasicAnimation extends CAPropertyAnimation {
        byValue: any;
        setByValue(_: any): any;
        fromValue: any;
        setFromValue(_: any): any;
        toValue: any;
        setToValue(_: any): any;
    }
    class CAConstraint extends NSObject {
        static constraintWithAttributeRelativeToAttribute(attribute: CAConstraintAttribute, relativeTo: string, attribute2: CAConstraintAttribute): CAConstraint;
        static constraintWithAttributeRelativeToAttributeOffset(attribute: CAConstraintAttribute, relativeTo: string, attribute2: CAConstraintAttribute, offset: number): CAConstraint;
        static constraintWithAttributeRelativeToAttributeScaleOffset(attribute: CAConstraintAttribute, relativeTo: string, attribute2: CAConstraintAttribute, scale: number, offset: number): CAConstraint;
        attribute: CAConstraintAttribute;
        offset: number;
        scale: number;
        sourceAttribute: CAConstraintAttribute;
        sourceName: string;
        static createWithAttributeRelativeToAttribute2ScaleOffset(attribute: CAConstraintAttribute, relativeTo: string, attribute2: CAConstraintAttribute, scale: number, offset: number): CAConstraint;
    }
    class CAConstraintLayoutManager extends NSObject {
    }
    class CAEDRMetadata extends NSObject {
        static HDR10MetadataWithDisplayInfoContentInfoOpticalOutputScale(displayInfo?: NSData, contentInfo?: NSData, opticalOutputScale?: number): CAEDRMetadata;
        static HDR10MetadataWithMinLuminanceMaxLuminanceOpticalOutputScale(minLuminance: number, maxLuminance: number, opticalOutputScale: number): CAEDRMetadata;
        static HLGMetadata: CAEDRMetadata;
    }
    class CAEmitterCell extends NSObject {
        static defaultValueForKey(forKey: string): any;
        alphaRange: number;
        setAlphaRange(_: number): any;
        alphaSpeed: number;
        setAlphaSpeed(_: number): any;
        birthRate: number;
        setBirthRate(_: number): any;
        blueRange: number;
        setBlueRange(_: number): any;
        blueSpeed: number;
        setBlueSpeed(_: number): any;
        color: any;
        setColor(_: any): any;
        contents: any;
        setContents(_: any): any;
        contentsRect: CGRect;
        setContentsRect(_: CGRect): any;
        contentsScale: number;
        setContentsScale(_: number): any;
        emissionLatitude: number;
        setEmissionLatitude(_: number): any;
        emissionLongitude: number;
        setEmissionLongitude(_: number): any;
        emissionRange: number;
        setEmissionRange(_: number): any;
        emitterCells: CAEmitterCell[];
        setEmitterCells(_: CAEmitterCell[]): any;
        isEnabled: boolean;
        setEnabled(_: boolean): any;
        greenRange: number;
        setGreenRange(_: number): any;
        greenSpeed: number;
        setGreenSpeed(_: number): any;
        lifetime: number;
        setLifetime(_: number): any;
        lifetimeRange: number;
        setLifetimeRange(_: number): any;
        magnificationFilter: string;
        setMagnificationFilter(_: string): any;
        minificationFilter: string;
        setMinificationFilter(_: string): any;
        minificationFilterBias: number;
        setMinificationFilterBias(_: number): any;
        name: string;
        setName(_: string): any;
        redRange: number;
        setRedRange(_: number): any;
        redSpeed: number;
        setRedSpeed(_: number): any;
        scale: number;
        setScale(_: number): any;
        scaleRange: number;
        setScaleRange(_: number): any;
        scaleSpeed: number;
        setScaleSpeed(_: number): any;
        spin: number;
        setSpin(_: number): any;
        spinRange: number;
        setSpinRange(_: number): any;
        style: Map<any, any>;
        setStyle(_: Map<any, any>): any;
        velocity: number;
        setVelocity(_: number): any;
        velocityRange: number;
        setVelocityRange(_: number): any;
        xAcceleration: number;
        setXAcceleration(_: number): any;
        yAcceleration: number;
        setYAcceleration(_: number): any;
        zAcceleration: number;
        setZAcceleration(_: number): any;
        shouldArchiveValueForKey(forKey: string): boolean;
    }
    class CAEmitterLayer extends CALayer {
        birthRate: number;
        setBirthRate(_: number): any;
        emitterCells: CAEmitterCell[];
        setEmitterCells(_: CAEmitterCell[]): any;
        emitterDepth: number;
        setEmitterDepth(_: number): any;
        emitterMode: string;
        setEmitterMode(_: string): any;
        emitterPosition: CGPoint;
        setEmitterPosition(_: CGPoint): any;
        emitterShape: string;
        setEmitterShape(_: string): any;
        emitterSize: CGSize;
        setEmitterSize(_: CGSize): any;
        emitterZPosition: number;
        setEmitterZPosition(_: number): any;
        lifetime: number;
        setLifetime(_: number): any;
        preservesDepth: boolean;
        setPreservesDepth(_: boolean): any;
        renderMode: string;
        setRenderMode(_: string): any;
        scale: number;
        setScale(_: number): any;
        seed: number;
        setSeed(_: number): any;
        spin: number;
        setSpin(_: number): any;
        velocity: number;
        setVelocity(_: number): any;
    }
    class CAGradientLayer extends CALayer {
        colors: any[];
        setColors(_: any[]): any;
        endPoint: CGPoint;
        setEndPoint(_: CGPoint): any;
        locations: number[];
        setLocations(_: number[]): any;
        startPoint: CGPoint;
        setStartPoint(_: CGPoint): any;
        type: string;
        setType(_: string): any;
    }
    class CAKeyframeAnimation extends CAPropertyAnimation {
        biasValues: number[];
        setBiasValues(_: number[]): any;
        calculationMode: string;
        setCalculationMode(_: string): any;
        continuityValues: number[];
        setContinuityValues(_: number[]): any;
        keyTimes: number[];
        setKeyTimes(_: number[]): any;
        path: any;
        setPath(_: any): any;
        rotationMode: string;
        setRotationMode(_: string): any;
        tensionValues: number[];
        setTensionValues(_: number[]): any;
        timingFunctions: CAMediaTimingFunction[];
        setTimingFunctions(_: CAMediaTimingFunction[]): any;
        values: any[];
        setValues(_: any[]): any;
    }
    class CALayer extends NSObject {
        static cornerCurveExpansionFactor(_: string): number;
        static defaultActionForKey(forKey: string): CAAction;
        static defaultValueForKey(forKey: string): any;
        static needsDisplayForKey(forKey: string): boolean;
        actions: Map<string, CAAction>;
        setActions(_: Map<string, CAAction>): any;
        allowsEdgeAntialiasing: boolean;
        setAllowsEdgeAntialiasing(_: boolean): any;
        allowsGroupOpacity: boolean;
        setAllowsGroupOpacity(_: boolean): any;
        anchorPoint: CGPoint;
        setAnchorPoint(_: CGPoint): any;
        anchorPointZ: number;
        setAnchorPointZ(_: number): any;
        autoresizingMask: CAAutoresizingMask;
        setAutoresizingMask(_: CAAutoresizingMask): any;
        backgroundColor: any;
        setBackgroundColor(_: any): any;
        backgroundFilters: any[];
        setBackgroundFilters(_: any[]): any;
        borderColor: any;
        setBorderColor(_: any): any;
        borderWidth: number;
        setBorderWidth(_: number): any;
        bounds: CGRect;
        setBounds(_: CGRect): any;
        compositingFilter: any;
        setCompositingFilter(_: any): any;
        constraints: CAConstraint[];
        setConstraints(_: CAConstraint[]): any;
        contents: any;
        setContents(_: any): any;
        contentsCenter: CGRect;
        setContentsCenter(_: CGRect): any;
        contentsFormat: string;
        setContentsFormat(_: string): any;
        contentsGravity: string;
        setContentsGravity(_: string): any;
        contentsRect: CGRect;
        setContentsRect(_: CGRect): any;
        contentsScale: number;
        setContentsScale(_: number): any;
        cornerCurve: string;
        setCornerCurve(_: string): any;
        cornerRadius: number;
        setCornerRadius(_: number): any;
        delegate: CALayerDelegate;
        setDelegate(_: CALayerDelegate): any;
        isDoubleSided: boolean;
        setDoubleSided(_: boolean): any;
        drawsAsynchronously: boolean;
        setDrawsAsynchronously(_: boolean): any;
        edgeAntialiasingMask: CAEdgeAntialiasingMask;
        setEdgeAntialiasingMask(_: CAEdgeAntialiasingMask): any;
        filters: any[];
        setFilters(_: any[]): any;
        frame: CGRect;
        setFrame(_: CGRect): any;
        isGeometryFlipped: boolean;
        setGeometryFlipped(_: boolean): any;
        isHidden: boolean;
        setHidden(_: boolean): any;
        layoutManager: CALayoutManager;
        setLayoutManager(_: CALayoutManager): any;
        magnificationFilter: string;
        setMagnificationFilter(_: string): any;
        mask: CALayer;
        setMask(_: CALayer): any;
        maskedCorners: CACornerMask;
        setMaskedCorners(_: CACornerMask): any;
        masksToBounds: boolean;
        setMasksToBounds(_: boolean): any;
        minificationFilter: string;
        setMinificationFilter(_: string): any;
        minificationFilterBias: number;
        setMinificationFilterBias(_: number): any;
        name: string;
        setName(_: string): any;
        needsDisplayOnBoundsChange: boolean;
        setNeedsDisplayOnBoundsChange(_: boolean): any;
        opacity: number;
        setOpacity(_: number): any;
        isOpaque: boolean;
        setOpaque(_: boolean): any;
        position: CGPoint;
        setPosition(_: CGPoint): any;
        rasterizationScale: number;
        setRasterizationScale(_: number): any;
        shadowColor: any;
        setShadowColor(_: any): any;
        shadowOffset: CGSize;
        setShadowOffset(_: CGSize): any;
        shadowOpacity: number;
        setShadowOpacity(_: number): any;
        shadowPath: any;
        setShadowPath(_: any): any;
        shadowRadius: number;
        setShadowRadius(_: number): any;
        shouldRasterize: boolean;
        setShouldRasterize(_: boolean): any;
        style: Map<any, any>;
        setStyle(_: Map<any, any>): any;
        sublayerTransform: CATransform3D;
        setSublayerTransform(_: CATransform3D): any;
        sublayers: CALayer[];
        setSublayers(_: CALayer[]): any;
        superlayer: CALayer;
        transform: CATransform3D;
        setTransform(_: CATransform3D): any;
        visibleRect: CGRect;
        zPosition: number;
        setZPosition(_: number): any;
        actionForKey(forKey: string): CAAction;
        addAnimationForKey(_: CAAnimation, forKey?: string): void;
        addConstraint(_: CAConstraint): void;
        addSublayer(_: CALayer): void;
        affineTransform(): CGAffineTransform;
        animationForKey(forKey: string): CAAnimation;
        animationKeys(): string[];
        containsPoint(_: CGPoint): boolean;
        contentsAreFlipped(): boolean;
        convertPointFromLayer(_: CGPoint, from?: CALayer): CGPoint;
        convertPointToLayer(_: CGPoint, to?: CALayer): CGPoint;
        convertRectFromLayer(_: CGRect, from?: CALayer): CGRect;
        convertRectToLayer(_: CGRect, to?: CALayer): CGRect;
        convertTimeFromLayer(_: number, from?: CALayer): number;
        convertTimeToLayer(_: number, to?: CALayer): number;
        display(): void;
        displayIfNeeded(): void;
        drawInContext(in_: any): void;
        hitTest(_: CGPoint): CALayer;
        static createWithLayer(layer: any): CALayer;
        insertSublayerAbove(_: CALayer, above?: CALayer): void;
        insertSublayerAtIndex(_: CALayer, at: number): void;
        insertSublayerBelow(_: CALayer, below?: CALayer): void;
        layoutIfNeeded(): void;
        layoutSublayers(): void;
        modelLayer(): CALayer;
        needsDisplay(): boolean;
        needsLayout(): boolean;
        preferredFrameSize(): CGSize;
        presentationLayer(): CALayer;
        removeAllAnimations(): void;
        removeAnimationForKey(forKey: string): void;
        removeFromSuperlayer(): void;
        renderInContext(in_: any): void;
        replaceSublayerWith(_: CALayer, with_: CALayer): void;
        resizeSublayersWithOldSize(withOldSize: CGSize): void;
        resizeWithOldSuperlayerSize(withOldSuperlayerSize: CGSize): void;
        scrollPoint(_: CGPoint): void;
        scrollRectToVisible(_: CGRect): void;
        setAffineTransform(_: CGAffineTransform): void;
        setNeedsDisplay(): void;
        setNeedsDisplayInRect(_: CGRect): void;
        setNeedsLayout(): void;
        shouldArchiveValueForKey(forKey: string): boolean;
    }
    interface CALayerDelegate extends NSObject {
        actionForLayerForKey?(for_: CALayer, forKey: string): CAAction;
        displayLayer?(_: CALayer): void;
        drawLayerInContext?(_: CALayer, in_: any): void;
        layerWillDraw?(_: CALayer): void;
        layoutSublayersOfLayer?(of: CALayer): void;
    }
    interface CALayoutManager extends NSObject {
        invalidateLayoutOfLayer?(of: CALayer): void;
        layoutSublayersOfLayer?(of: CALayer): void;
        preferredSizeOfLayer?(of: CALayer): CGSize;
    }
    interface CAMediaTiming {
        autoreverses: boolean;
        setAutoreverses(_: boolean): any;
        beginTime: number;
        setBeginTime(_: number): any;
        duration: number;
        setDuration(_: number): any;
        fillMode: string;
        setFillMode(_: string): any;
        repeatCount: number;
        setRepeatCount(_: number): any;
        repeatDuration: number;
        setRepeatDuration(_: number): any;
        speed: number;
        setSpeed(_: number): any;
        timeOffset: number;
        setTimeOffset(_: number): any;
    }
    class CAMediaTimingFunction extends NSObject {
        static functionWithControlPoints(_: number, _2: number, _3: number, _4: number): CAMediaTimingFunction;
        getControlPointAtIndexValues(at: number, values: number): void;
        static createWithControlPoints(_: number, _2: number, _3: number, controlPoints: number): CAMediaTimingFunction;
    }
    interface CAMetalDrawable extends MTLDrawable {
        layer: CAMetalLayer;
    }
    class CAMetalLayer extends CALayer {
        EDRMetadata: CAEDRMetadata;
        setEDRMetadata(_: CAEDRMetadata): any;
        allowsNextDrawableTimeout: boolean;
        setAllowsNextDrawableTimeout(_: boolean): any;
        colorspace: any;
        setColorspace(_: any): any;
        displaySyncEnabled: boolean;
        setDisplaySyncEnabled(_: boolean): any;
        drawableSize: CGSize;
        setDrawableSize(_: CGSize): any;
        framebufferOnly: boolean;
        setFramebufferOnly(_: boolean): any;
        maximumDrawableCount: number;
        setMaximumDrawableCount(_: number): any;
        presentsWithTransaction: boolean;
        setPresentsWithTransaction(_: boolean): any;
        wantsExtendedDynamicRangeContent: boolean;
        setWantsExtendedDynamicRangeContent(_: boolean): any;
        nextDrawable(): CAMetalDrawable;
    }
    class CAPropertyAnimation extends CAAnimation {
        static animationWithKeyPath(keyPath?: string): CAPropertyAnimation;
        isAdditive: boolean;
        setAdditive(_: boolean): any;
        isCumulative: boolean;
        setCumulative(_: boolean): any;
        keyPath: string;
        setKeyPath(_: string): any;
        valueFunction: CAValueFunction;
        setValueFunction(_: CAValueFunction): any;
    }
    class CARemoteLayerClient extends NSObject {
        clientId: number;
        layer: CALayer;
        setLayer(_: CALayer): any;
        static createWithServerPort(serverPort: number): CARemoteLayerClient;
        invalidate(): void;
    }
    class CARemoteLayerServer extends NSObject {
        static sharedServer(): CARemoteLayerServer;
        serverPort: number;
    }
    class CARenderer extends NSObject {
        bounds: CGRect;
        setBounds(_: CGRect): any;
        layer: CALayer;
        setLayer(_: CALayer): any;
        addUpdateRect(_: CGRect): void;
        beginFrameAtTimeTimeStamp(atTime: number, timeStamp?: CVTimeStamp): void;
        endFrame(): void;
        nextFrameTime(): number;
        render(): void;
        updateBounds(): CGRect;
    }
    class CAReplicatorLayer extends CALayer {
        instanceAlphaOffset: number;
        setInstanceAlphaOffset(_: number): any;
        instanceBlueOffset: number;
        setInstanceBlueOffset(_: number): any;
        instanceColor: any;
        setInstanceColor(_: any): any;
        instanceCount: number;
        setInstanceCount(_: number): any;
        instanceDelay: number;
        setInstanceDelay(_: number): any;
        instanceGreenOffset: number;
        setInstanceGreenOffset(_: number): any;
        instanceRedOffset: number;
        setInstanceRedOffset(_: number): any;
        instanceTransform: CATransform3D;
        setInstanceTransform(_: CATransform3D): any;
        preservesDepth: boolean;
        setPreservesDepth(_: boolean): any;
    }
    class CAScrollLayer extends CALayer {
        scrollMode: string;
        setScrollMode(_: string): any;
        scrollToPoint(to: CGPoint): void;
        scrollToRect(to: CGRect): void;
    }
    class CAShapeLayer extends CALayer {
        fillColor: any;
        setFillColor(_: any): any;
        fillRule: string;
        setFillRule(_: string): any;
        lineCap: string;
        setLineCap(_: string): any;
        lineDashPattern: number[];
        setLineDashPattern(_: number[]): any;
        lineDashPhase: number;
        setLineDashPhase(_: number): any;
        lineJoin: string;
        setLineJoin(_: string): any;
        lineWidth: number;
        setLineWidth(_: number): any;
        miterLimit: number;
        setMiterLimit(_: number): any;
        path: any;
        setPath(_: any): any;
        strokeColor: any;
        setStrokeColor(_: any): any;
        strokeEnd: number;
        setStrokeEnd(_: number): any;
        strokeStart: number;
        setStrokeStart(_: number): any;
    }
    class CASpringAnimation extends CABasicAnimation {
        damping: number;
        setDamping(_: number): any;
        initialVelocity: number;
        setInitialVelocity(_: number): any;
        mass: number;
        setMass(_: number): any;
        settlingDuration: number;
        stiffness: number;
        setStiffness(_: number): any;
    }
    class CATextLayer extends CALayer {
        alignmentMode: string;
        setAlignmentMode(_: string): any;
        allowsFontSubpixelQuantization: boolean;
        setAllowsFontSubpixelQuantization(_: boolean): any;
        font: any;
        setFont(_: any): any;
        fontSize: number;
        setFontSize(_: number): any;
        foregroundColor: any;
        setForegroundColor(_: any): any;
        string: any;
        setString(_: any): any;
        truncationMode: string;
        setTruncationMode(_: string): any;
        isWrapped: boolean;
        setWrapped(_: boolean): any;
    }
    class CATiledLayer extends CALayer {
        static fadeDuration(): number;
        levelsOfDetail: number;
        setLevelsOfDetail(_: number): any;
        levelsOfDetailBias: number;
        setLevelsOfDetailBias(_: number): any;
        tileSize: CGSize;
        setTileSize(_: CGSize): any;
    }
    class CATransaction extends NSObject {
        static animationDuration(): number;
        static animationTimingFunction(): CAMediaTimingFunction;
        static begin(): void;
        static commit(): void;
        static completionBlock(): () => void;
        static disableActions(): boolean;
        static flush(): void;
        static lock(): void;
        static setAnimationDuration(_: number): void;
        static setAnimationTimingFunction(_?: CAMediaTimingFunction): void;
        static setCompletionBlock(_?: () => void): void;
        static setDisableActions(_: boolean): void;
        static setValueForKey(_?: any, forKey?: string): void;
        static unlock(): void;
        static valueForKey(forKey: string): any;
    }
    class CATransformLayer extends CALayer {
    }
    class CATransition extends CAAnimation {
        endProgress: number;
        setEndProgress(_: number): any;
        filter: any;
        setFilter(_: any): any;
        startProgress: number;
        setStartProgress(_: number): any;
        subtype: string;
        setSubtype(_: string): any;
        type: string;
        setType(_: string): any;
    }
    class CAValueFunction extends NSObject {
        name: string;
    }
    namespace AE {
        enum AEDataModel {
        }
    }
    namespace AVAssetExportSession {
        enum Status {
            Unknown = 0,
            Waiting = 1,
            Exporting = 2,
            Completed = 3,
            Failed = 4,
            Cancelled = 5
        }
    }
    namespace AVAssetImageGenerator {
        enum Result {
            Succeeded = 0,
            Failed = 1,
            Cancelled = 2
        }
        let cleanAperture: string;
        let encodedPixels: string;
        let productionAperture: string;
    }
    namespace AVAssetReader {
        enum Status {
            Unknown = 0,
            Reading = 1,
            Completed = 2,
            Failed = 3,
            Cancelled = 4
        }
    }
    namespace AVAssetTrack {
        let audioFallback: string;
        let chapterList: string;
        let forcedSubtitlesOnly: string;
        let metadataReferent: string;
        let selectionFollower: string;
        let timecode: string;
    }
    namespace AVAssetWriter {
        enum Status {
            Unknown = 0,
            Writing = 1,
            Completed = 2,
            Failed = 3,
            Cancelled = 4
        }
    }
    namespace AVAssetWriterInput {
        let beforeMainMediaDataNotInterleaved: string;
        let interleavedWithMainMediaData: string;
    }
    namespace AVAudioSession {
        enum CategoryOptions {
            MixWithOthers = 1,
            DuckOthers = 2,
            AllowBluetooth = 4,
            DefaultToSpeaker = 8,
            InterruptSpokenAudioAndMixWithOthers = 17,
            AllowBluetoothA2DP = 32,
            AllowAirPlay = 64
        }
        enum IOType {
            NotSpecified = 0,
            Aggregated = 1
        }
        enum InterruptionOptions {
            ShouldResume = 1
        }
        enum InterruptionType {
            Began = 1,
            Ended = 0
        }
        enum PortOverride {
            None = 0,
            Speaker = 1936747378
        }
        enum PromptStyle {
            None = 1852796517,
            Short = 1936224884,
            Normal = 1852992876
        }
        enum RecordPermission {
            Undetermined = 1970168948,
            Denied = 1684369017,
            Granted = 1735552628
        }
        enum RouteChangeReason {
            Unknown = 0,
            NewDeviceAvailable = 1,
            OldDeviceUnavailable = 2,
            CategoryChange = 3,
            Override = 4,
            WakeFromSleep = 6,
            NoSuitableRouteForCategory = 7,
            RouteConfigurationChange = 8
        }
        enum RouteSharingPolicy {
            Default = 0,
            LongFormAudio = 1,
            LongForm = 1,
            Independent = 2,
            LongFormVideo = 3
        }
        enum SetActiveOptions {
            NotifyOthersOnDeactivation = 1
        }
        enum SilenceSecondaryAudioHintType {
            Begin = 1,
            End = 0
        }
        let ambient: string;
        let audioProcessing: string;
        let multiRoute: string;
        let playAndRecord: string;
        let playback: string;
        let record: string;
        let soloAmbient: string;
        let interruptionNotification: string;
        let lower: string;
        let upper: string;
        let mediaServicesWereLostNotification: string;
        let mediaServicesWereResetNotification: string;
        let default_: string;
        let gameChat: string;
        let measurement: string;
        let moviePlayback: string;
        let spokenAudio: string;
        let videoChat: string;
        let videoRecording: string;
        let voiceChat: string;
        let voicePrompt: string;
        let back: string;
        let bottom: string;
        let front: string;
        let left: string;
        let right: string;
        let top: string;
        let cardioid: string;
        let omnidirectional: string;
        let subcardioid: string;
        let airPlay: string;
        let bluetoothA2DP: string;
        let bluetoothHFP: string;
        let bluetoothLE: string;
        let builtInMic: string;
        let builtInReceiver: string;
        let builtInSpeaker: string;
        let carAudio: string;
        let HDMI: string;
        let headphones: string;
        let headsetMic: string;
        let lineIn: string;
        let lineOut: string;
        let usbAudio: string;
        let routeChangeNotification: string;
        let silenceSecondaryAudioHintNotification: string;
    }
    namespace AVAudioTimePitchAlgorithm {
        let lowQualityZeroLatency: string;
        let spectral: string;
        let timeDomain: string;
        let varispeed: string;
    }
    namespace AVAudioUnitComponentManager {
        let registrationsChangedNotification: string;
    }
    namespace AVCaptureDevice {
        enum AutoFocusRangeRestriction {
            None = 0,
            Near = 1,
            Far = 2
        }
        enum Position {
            Unspecified = 0,
            Back = 1,
            Front = 2
        }
        enum TransportControlsPlaybackMode {
            NotPlayingMode = 0,
            PlayingMode = 1
        }
        enum ExposureMode {
            Locked = 0,
            AutoExpose = 1,
            ContinuousAutoExposure = 2,
            Custom = 3
        }
        enum FlashMode {
            Off = 0,
            On = 1,
            Auto = 2
        }
        enum FocusMode {
            Locked = 0,
            AutoFocus = 1,
            ContinuousAutoFocus = 2
        }
        enum LensStabilizationStatus {
            Unsupported = 0,
            Off = 1,
            Active = 2,
            OutOfRange = 3,
            Unavailable = 4
        }
        enum TorchMode {
            Off = 0,
            On = 1,
            Auto = 2
        }
        enum WhiteBalanceMode {
            Locked = 0,
            AutoWhiteBalance = 1,
            ContinuousAutoWhiteBalance = 2
        }
        let builtInDualCamera: string;
        let builtInDualWideCamera: string;
        let builtInDuoCamera: string;
        let builtInMicrophone: string;
        let builtInTelephotoCamera: string;
        let builtInTripleCamera: string;
        let builtInTrueDepthCamera: string;
        let builtInUltraWideCamera: string;
        let builtInWideAngleCamera: string;
        let externalUnknown: string;
        let currentExposureDuration: CMTime;
        let currentExposureTargetBias: number;
        let currentISO: number;
        let currentLensPosition: number;
        let maxAvailableTorchLevel: number;
    }
    namespace AVCaptureOutput {
        enum DataDroppedReason {
            None = 0,
            LateData = 1,
            OutOfBuffers = 2,
            Discontinuity = 3
        }
    }
    namespace AVCapturePhotoOutput {
        enum QualityPrioritization {
            Speed = 1,
            Balanced = 2,
            Quality = 3
        }
    }
    namespace AVCaptureSession {
        enum InterruptionReason {
            VideoDeviceNotAvailableInBackground = 1,
            AudioDeviceInUseByAnotherClient = 2,
            VideoDeviceInUseByAnotherClient = 3,
            VideoDeviceNotAvailableWithMultipleForegroundApps = 4,
            VideoDeviceNotAvailableDueToSystemPressure = 5
        }
        let hd1280x720: string;
        let hd1920x1080: string;
        let qvga320x240: string;
        let cif352x288: string;
        let hd4K3840x2160: string;
        let vga640x480: string;
        let qHD960x540: string;
        let high: string;
        let inputPriority: string;
        let low: string;
        let medium: string;
        let photo: string;
        let iFrame1280x720: string;
        let iFrame960x540: string;
    }
    namespace AVContentKeyRequest {
        enum Status {
            RequestingResponse = 0,
            ReceivedResponse = 1,
            Renewed = 2,
            Retried = 3,
            Cancelled = 4,
            Failed = 5
        }
        let receivedObsoleteContentKey: string;
        let receivedResponseWithExpiredLease: string;
        let timedOut: string;
    }
    namespace AVContentKeySessionServerPlaybackContextOption {
        let protocolVersions: string;
        let serverChallenge: string;
    }
    namespace AVContentKeySystem {
        let authorizationToken: string;
        let clearKey: string;
        let fairPlayStreaming: string;
    }
    namespace AVDepthData {
        enum Accuracy {
            Relative = 0,
            Absolute = 1
        }
        enum Quality {
            Low = 0,
            High = 1
        }
    }
    namespace AVFileType {
        let mobile3GPP: string;
        let mobile3GPP2: string;
        let ac3: string;
        let aifc: string;
        let aiff: string;
        let amr: string;
        let avci: string;
        let m4a: string;
        let m4v: string;
        let caf: string;
        let dng: string;
        let eac3: string;
        let heic: string;
        let heif: string;
        let jpg: string;
        let mp4: string;
        let mp3: string;
        let mov: string;
        let au: string;
        let tif: string;
        let wav: string;
    }
    namespace AVLayerVideoGravity {
        let resize: string;
        let resizeAspect: string;
        let resizeAspectFill: string;
    }
    namespace AVMediaCharacteristic {
        let audible: string;
        let containsAlphaChannel: string;
        let containsOnlyForcedSubtitles: string;
        let describesMusicAndSoundForAccessibility: string;
        let describesVideoForAccessibility: string;
        let dubbedTranslation: string;
        let easyToRead: string;
        let frameBased: string;
        let isAuxiliaryContent: string;
        let isMainProgramContent: string;
        let isOriginalContent: string;
        let languageTranslation: string;
        let legible: string;
        let transcribesSpokenDialogForAccessibility: string;
        let usesWideGamutColorSpace: string;
        let visual: string;
        let voiceOverTranslation: string;
    }
    namespace AVMediaType {
        let audio: string;
        let closedCaption: string;
        let depthData: string;
        let metadata: string;
        let metadataObject: string;
        let muxed: string;
        let subtitle: string;
        let text: string;
        let timecode: string;
        let video: string;
    }
    namespace AVMetadataExtraAttributeKey {
        let baseURI: string;
        let info: string;
        let valueURI: string;
    }
    namespace AVMetadataFormat {
        let hlsMetadata: string;
        let id3Metadata: string;
        let isoUserData: string;
        let quickTimeMetadata: string;
        let quickTimeUserData: string;
        let unknown: string;
        let iTunesMetadata: string;
    }
    namespace AVMetadataIdentifier {
        let commonIdentifierAlbumName: string;
        let commonIdentifierArtist: string;
        let commonIdentifierArtwork: string;
        let commonIdentifierAssetIdentifier: string;
        let commonIdentifierAuthor: string;
        let commonIdentifierContributor: string;
        let commonIdentifierCopyrights: string;
        let commonIdentifierCreationDate: string;
        let commonIdentifierCreator: string;
        let commonIdentifierDescription: string;
        let commonIdentifierFormat: string;
        let commonIdentifierLanguage: string;
        let commonIdentifierLastModifiedDate: string;
        let commonIdentifierLocation: string;
        let commonIdentifierMake: string;
        let commonIdentifierModel: string;
        let commonIdentifierPublisher: string;
        let commonIdentifierRelation: string;
        let commonIdentifierSoftware: string;
        let commonIdentifierSource: string;
        let commonIdentifierSubject: string;
        let commonIdentifierTitle: string;
        let commonIdentifierType: string;
        let identifier3GPUserDataAlbumAndTrack: string;
        let identifier3GPUserDataAuthor: string;
        let identifier3GPUserDataCollection: string;
        let identifier3GPUserDataCopyright: string;
        let identifier3GPUserDataDescription: string;
        let identifier3GPUserDataGenre: string;
        let identifier3GPUserDataKeywordList: string;
        let identifier3GPUserDataLocation: string;
        let identifier3GPUserDataMediaClassification: string;
        let identifier3GPUserDataMediaRating: string;
        let identifier3GPUserDataPerformer: string;
        let identifier3GPUserDataRecordingYear: string;
        let identifier3GPUserDataThumbnail: string;
        let identifier3GPUserDataTitle: string;
        let identifier3GPUserDataUserRating: string;
        let id3MetadataAlbumSortOrder: string;
        let id3MetadataAlbumTitle: string;
        let id3MetadataAttachedPicture: string;
        let id3MetadataAudioEncryption: string;
        let id3MetadataAudioSeekPointIndex: string;
        let id3MetadataBand: string;
        let id3MetadataBeatsPerMinute: string;
        let id3MetadataComments: string;
        let id3MetadataCommercial: string;
        let id3MetadataCommercialInformation: string;
        let id3MetadataComposer: string;
        let id3MetadataConductor: string;
        let id3MetadataContentGroupDescription: string;
        let id3MetadataContentType: string;
        let id3MetadataCopyright: string;
        let id3MetadataCopyrightInformation: string;
        let id3MetadataDate: string;
        let id3MetadataEncodedBy: string;
        let id3MetadataEncodedWith: string;
        let id3MetadataEncodingTime: string;
        let id3MetadataEncryption: string;
        let id3MetadataEqualization: string;
        let id3MetadataEqualization2: string;
        let id3MetadataEventTimingCodes: string;
        let id3MetadataFileOwner: string;
        let id3MetadataFileType: string;
        let id3MetadataGeneralEncapsulatedObject: string;
        let id3MetadataGroupIdentifier: string;
        let id3MetadataInitialKey: string;
        let id3MetadataInternationalStandardRecordingCode: string;
        let id3MetadataInternetRadioStationName: string;
        let id3MetadataInternetRadioStationOwner: string;
        let id3MetadataInvolvedPeopleList_v23: string;
        let id3MetadataInvolvedPeopleList_v24: string;
        let id3MetadataLanguage: string;
        let id3MetadataLeadPerformer: string;
        let id3MetadataLength: string;
        let id3MetadataLink: string;
        let id3MetadataLyricist: string;
        let id3MetadataMPEGLocationLookupTable: string;
        let id3MetadataMediaType: string;
        let id3MetadataModifiedBy: string;
        let id3MetadataMood: string;
        let id3MetadataMusicCDIdentifier: string;
        let id3MetadataMusicianCreditsList: string;
        let id3MetadataOfficialArtistWebpage: string;
        let id3MetadataOfficialAudioFileWebpage: string;
        let id3MetadataOfficialAudioSourceWebpage: string;
        let id3MetadataOfficialInternetRadioStationHomepage: string;
        let id3MetadataOfficialPublisherWebpage: string;
        let id3MetadataOriginalAlbumTitle: string;
        let id3MetadataOriginalArtist: string;
        let id3MetadataOriginalFilename: string;
        let id3MetadataOriginalLyricist: string;
        let id3MetadataOriginalReleaseTime: string;
        let id3MetadataOriginalReleaseYear: string;
        let id3MetadataOwnership: string;
        let id3MetadataPartOfASet: string;
        let id3MetadataPayment: string;
        let id3MetadataPerformerSortOrder: string;
        let id3MetadataPlayCounter: string;
        let id3MetadataPlaylistDelay: string;
        let id3MetadataPopularimeter: string;
        let id3MetadataPositionSynchronization: string;
        let id3MetadataPrivate: string;
        let id3MetadataProducedNotice: string;
        let id3MetadataPublisher: string;
        let id3MetadataRecommendedBufferSize: string;
        let id3MetadataRecordingDates: string;
        let id3MetadataRecordingTime: string;
        let id3MetadataRelativeVolumeAdjustment: string;
        let id3MetadataRelativeVolumeAdjustment2: string;
        let id3MetadataReleaseTime: string;
        let id3MetadataReverb: string;
        let id3MetadataSeek: string;
        let id3MetadataSetSubtitle: string;
        let id3MetadataSignature: string;
        let id3MetadataSize: string;
        let id3MetadataSubTitle: string;
        let id3MetadataSynchronizedLyric: string;
        let id3MetadataSynchronizedTempoCodes: string;
        let id3MetadataTaggingTime: string;
        let id3MetadataTermsOfUse: string;
        let id3MetadataTime: string;
        let id3MetadataTitleDescription: string;
        let id3MetadataTitleSortOrder: string;
        let id3MetadataTrackNumber: string;
        let id3MetadataUniqueFileIdentifier: string;
        let id3MetadataUnsynchronizedLyric: string;
        let id3MetadataUserText: string;
        let id3MetadataUserURL: string;
        let id3MetadataYear: string;
        let isoUserDataCopyright: string;
        let isoUserDataDate: string;
        let isoUserDataTaggedCharacteristic: string;
        let icyMetadataStreamTitle: string;
        let icyMetadataStreamURL: string;
        let quickTimeMetadataAlbum: string;
        let quickTimeMetadataArranger: string;
        let quickTimeMetadataArtist: string;
        let quickTimeMetadataArtwork: string;
        let quickTimeMetadataAuthor: string;
        let quickTimeMetadataAutoLivePhoto: string;
        let quickTimeMetadataCameraFrameReadoutTime: string;
        let quickTimeMetadataCameraIdentifier: string;
        let quickTimeMetadataCollectionUser: string;
        let quickTimeMetadataComment: string;
        let quickTimeMetadataComposer: string;
        let quickTimeMetadataContentIdentifier: string;
        let quickTimeMetadataCopyright: string;
        let quickTimeMetadataCreationDate: string;
        let quickTimeMetadataCredits: string;
        let quickTimeMetadataDescription: string;
        let quickTimeMetadataDetectedCatBody: string;
        let quickTimeMetadataDetectedDogBody: string;
        let quickTimeMetadataDetectedFace: string;
        let quickTimeMetadataDetectedHumanBody: string;
        let quickTimeMetadataDetectedSalientObject: string;
        let quickTimeMetadataDirectionFacing: string;
        let quickTimeMetadataDirectionMotion: string;
        let quickTimeMetadataDirector: string;
        let quickTimeMetadataDisplayName: string;
        let quickTimeMetadataEncodedBy: string;
        let quickTimeMetadataGenre: string;
        let quickTimeMetadataInformation: string;
        let quickTimeMetadataKeywords: string;
        let quickTimeMetadataLivePhotoVitalityScore: string;
        let quickTimeMetadataLivePhotoVitalityScoringVersion: string;
        let quickTimeMetadataLocationBody: string;
        let quickTimeMetadataLocationDate: string;
        let quickTimeMetadataLocationISO6709: string;
        let quickTimeMetadataLocationName: string;
        let quickTimeMetadataLocationNote: string;
        let quickTimeMetadataLocationRole: string;
        let quickTimeMetadataMake: string;
        let quickTimeMetadataModel: string;
        let quickTimeMetadataOriginalArtist: string;
        let quickTimeMetadataPerformer: string;
        let quickTimeMetadataPhonogramRights: string;
        let quickTimeMetadataPreferredAffineTransform: string;
        let quickTimeMetadataProducer: string;
        let quickTimeMetadataPublisher: string;
        let quickTimeMetadataRatingUser: string;
        let quickTimeMetadataSoftware: string;
        let quickTimeMetadataSpatialOverCaptureQualityScore: string;
        let quickTimeMetadataSpatialOverCaptureQualityScoringVersion: string;
        let quickTimeMetadataTitle: string;
        let quickTimeMetadataVideoOrientation: string;
        let quickTimeMetadataYear: string;
        let quickTimeMetadataiXML: string;
        let quickTimeUserDataAlbum: string;
        let quickTimeUserDataArranger: string;
        let quickTimeUserDataArtist: string;
        let quickTimeUserDataAuthor: string;
        let quickTimeUserDataChapter: string;
        let quickTimeUserDataComment: string;
        let quickTimeUserDataComposer: string;
        let quickTimeUserDataCopyright: string;
        let quickTimeUserDataCreationDate: string;
        let quickTimeUserDataCredits: string;
        let quickTimeUserDataDescription: string;
        let quickTimeUserDataDirector: string;
        let quickTimeUserDataDisclaimer: string;
        let quickTimeUserDataEncodedBy: string;
        let quickTimeUserDataFullName: string;
        let quickTimeUserDataGenre: string;
        let quickTimeUserDataHostComputer: string;
        let quickTimeUserDataInformation: string;
        let quickTimeUserDataKeywords: string;
        let quickTimeUserDataLocationISO6709: string;
        let quickTimeUserDataMake: string;
        let quickTimeUserDataModel: string;
        let quickTimeUserDataOriginalArtist: string;
        let quickTimeUserDataOriginalFormat: string;
        let quickTimeUserDataOriginalSource: string;
        let quickTimeUserDataPerformers: string;
        let quickTimeUserDataPhonogramRights: string;
        let quickTimeUserDataProducer: string;
        let quickTimeUserDataProduct: string;
        let quickTimeUserDataPublisher: string;
        let quickTimeUserDataSoftware: string;
        let quickTimeUserDataSpecialPlaybackRequirements: string;
        let quickTimeUserDataTaggedCharacteristic: string;
        let quickTimeUserDataTrack: string;
        let quickTimeUserDataTrackName: string;
        let quickTimeUserDataURLLink: string;
        let quickTimeUserDataWarning: string;
        let quickTimeUserDataWriter: string;
        let iTunesMetadataAccountKind: string;
        let iTunesMetadataAcknowledgement: string;
        let iTunesMetadataAlbum: string;
        let iTunesMetadataAlbumArtist: string;
        let iTunesMetadataAppleID: string;
        let iTunesMetadataArranger: string;
        let iTunesMetadataArtDirector: string;
        let iTunesMetadataArtist: string;
        let iTunesMetadataArtistID: string;
        let iTunesMetadataAuthor: string;
        let iTunesMetadataBeatsPerMin: string;
        let iTunesMetadataComposer: string;
        let iTunesMetadataConductor: string;
        let iTunesMetadataContentRating: string;
        let iTunesMetadataCopyright: string;
        let iTunesMetadataCoverArt: string;
        let iTunesMetadataCredits: string;
        let iTunesMetadataDescription: string;
        let iTunesMetadataDirector: string;
        let iTunesMetadataDiscCompilation: string;
        let iTunesMetadataDiscNumber: string;
        let iTunesMetadataEQ: string;
        let iTunesMetadataEncodedBy: string;
        let iTunesMetadataEncodingTool: string;
        let iTunesMetadataExecProducer: string;
        let iTunesMetadataGenreID: string;
        let iTunesMetadataGrouping: string;
        let iTunesMetadataLinerNotes: string;
        let iTunesMetadataLyrics: string;
        let iTunesMetadataOnlineExtras: string;
        let iTunesMetadataOriginalArtist: string;
        let iTunesMetadataPerformer: string;
        let iTunesMetadataPhonogramRights: string;
        let iTunesMetadataPlaylistID: string;
        let iTunesMetadataPredefinedGenre: string;
        let iTunesMetadataProducer: string;
        let iTunesMetadataPublisher: string;
        let iTunesMetadataRecordCompany: string;
        let iTunesMetadataReleaseDate: string;
        let iTunesMetadataSoloist: string;
        let iTunesMetadataSongID: string;
        let iTunesMetadataSongName: string;
        let iTunesMetadataSoundEngineer: string;
        let iTunesMetadataThanks: string;
        let iTunesMetadataTrackNumber: string;
        let iTunesMetadataTrackSubTitle: string;
        let iTunesMetadataUserComment: string;
        let iTunesMetadataUserGenre: string;
    }
    namespace AVMetadataKey {
        let metadata3GPUserDataKeyAlbumAndTrack: string;
        let metadata3GPUserDataKeyAuthor: string;
        let metadata3GPUserDataKeyCollection: string;
        let metadata3GPUserDataKeyCopyright: string;
        let metadata3GPUserDataKeyDescription: string;
        let metadata3GPUserDataKeyGenre: string;
        let metadata3GPUserDataKeyKeywordList: string;
        let metadata3GPUserDataKeyLocation: string;
        let metadata3GPUserDataKeyMediaClassification: string;
        let metadata3GPUserDataKeyMediaRating: string;
        let metadata3GPUserDataKeyPerformer: string;
        let metadata3GPUserDataKeyRecordingYear: string;
        let metadata3GPUserDataKeyThumbnail: string;
        let metadata3GPUserDataKeyTitle: string;
        let metadata3GPUserDataKeyUserRating: string;
        let commonKeyAlbumName: string;
        let commonKeyArtist: string;
        let commonKeyArtwork: string;
        let commonKeyAuthor: string;
        let commonKeyContributor: string;
        let commonKeyCopyrights: string;
        let commonKeyCreationDate: string;
        let commonKeyCreator: string;
        let commonKeyDescription: string;
        let commonKeyFormat: string;
        let commonKeyIdentifier: string;
        let commonKeyLanguage: string;
        let commonKeyLastModifiedDate: string;
        let commonKeyLocation: string;
        let commonKeyMake: string;
        let commonKeyModel: string;
        let commonKeyPublisher: string;
        let commonKeyRelation: string;
        let commonKeySoftware: string;
        let commonKeySource: string;
        let commonKeySubject: string;
        let commonKeyTitle: string;
        let commonKeyType: string;
        let id3MetadataKeyAlbumSortOrder: string;
        let id3MetadataKeyAlbumTitle: string;
        let id3MetadataKeyAttachedPicture: string;
        let id3MetadataKeyAudioEncryption: string;
        let id3MetadataKeyAudioSeekPointIndex: string;
        let id3MetadataKeyBand: string;
        let id3MetadataKeyBeatsPerMinute: string;
        let id3MetadataKeyComments: string;
        let id3MetadataKeyCommercial: string;
        let id3MetadataKeyCommercialInformation: string;
        let id3MetadataKeyComposer: string;
        let id3MetadataKeyConductor: string;
        let id3MetadataKeyContentGroupDescription: string;
        let id3MetadataKeyContentType: string;
        let id3MetadataKeyCopyright: string;
        let id3MetadataKeyCopyrightInformation: string;
        let id3MetadataKeyDate: string;
        let id3MetadataKeyEncodedBy: string;
        let id3MetadataKeyEncodedWith: string;
        let id3MetadataKeyEncodingTime: string;
        let id3MetadataKeyEncryption: string;
        let id3MetadataKeyEqualization: string;
        let id3MetadataKeyEqualization2: string;
        let id3MetadataKeyEventTimingCodes: string;
        let id3MetadataKeyFileOwner: string;
        let id3MetadataKeyFileType: string;
        let id3MetadataKeyGeneralEncapsulatedObject: string;
        let id3MetadataKeyGroupIdentifier: string;
        let id3MetadataKeyInitialKey: string;
        let id3MetadataKeyInternationalStandardRecordingCode: string;
        let id3MetadataKeyInternetRadioStationName: string;
        let id3MetadataKeyInternetRadioStationOwner: string;
        let id3MetadataKeyInvolvedPeopleList_v23: string;
        let id3MetadataKeyInvolvedPeopleList_v24: string;
        let id3MetadataKeyLanguage: string;
        let id3MetadataKeyLeadPerformer: string;
        let id3MetadataKeyLength: string;
        let id3MetadataKeyLink: string;
        let id3MetadataKeyLyricist: string;
        let id3MetadataKeyMPEGLocationLookupTable: string;
        let id3MetadataKeyMediaType: string;
        let id3MetadataKeyModifiedBy: string;
        let id3MetadataKeyMood: string;
        let id3MetadataKeyMusicCDIdentifier: string;
        let id3MetadataKeyMusicianCreditsList: string;
        let id3MetadataKeyOfficialArtistWebpage: string;
        let id3MetadataKeyOfficialAudioFileWebpage: string;
        let id3MetadataKeyOfficialAudioSourceWebpage: string;
        let id3MetadataKeyOfficialInternetRadioStationHomepage: string;
        let id3MetadataKeyOfficialPublisherWebpage: string;
        let id3MetadataKeyOriginalAlbumTitle: string;
        let id3MetadataKeyOriginalArtist: string;
        let id3MetadataKeyOriginalFilename: string;
        let id3MetadataKeyOriginalLyricist: string;
        let id3MetadataKeyOriginalReleaseTime: string;
        let id3MetadataKeyOriginalReleaseYear: string;
        let id3MetadataKeyOwnership: string;
        let id3MetadataKeyPartOfASet: string;
        let id3MetadataKeyPayment: string;
        let id3MetadataKeyPerformerSortOrder: string;
        let id3MetadataKeyPlayCounter: string;
        let id3MetadataKeyPlaylistDelay: string;
        let id3MetadataKeyPopularimeter: string;
        let id3MetadataKeyPositionSynchronization: string;
        let id3MetadataKeyPrivate: string;
        let id3MetadataKeyProducedNotice: string;
        let id3MetadataKeyPublisher: string;
        let id3MetadataKeyRecommendedBufferSize: string;
        let id3MetadataKeyRecordingDates: string;
        let id3MetadataKeyRecordingTime: string;
        let id3MetadataKeyRelativeVolumeAdjustment: string;
        let id3MetadataKeyRelativeVolumeAdjustment2: string;
        let id3MetadataKeyReleaseTime: string;
        let id3MetadataKeyReverb: string;
        let id3MetadataKeySeek: string;
        let id3MetadataKeySetSubtitle: string;
        let id3MetadataKeySignature: string;
        let id3MetadataKeySize: string;
        let id3MetadataKeySubTitle: string;
        let id3MetadataKeySynchronizedLyric: string;
        let id3MetadataKeySynchronizedTempoCodes: string;
        let id3MetadataKeyTaggingTime: string;
        let id3MetadataKeyTermsOfUse: string;
        let id3MetadataKeyTime: string;
        let id3MetadataKeyTitleDescription: string;
        let id3MetadataKeyTitleSortOrder: string;
        let id3MetadataKeyTrackNumber: string;
        let id3MetadataKeyUniqueFileIdentifier: string;
        let id3MetadataKeyUnsynchronizedLyric: string;
        let id3MetadataKeyUserText: string;
        let id3MetadataKeyUserURL: string;
        let id3MetadataKeyYear: string;
        let isoUserDataKeyCopyright: string;
        let isoUserDataKeyDate: string;
        let isoUserDataKeyTaggedCharacteristic: string;
        let icyMetadataKeyStreamTitle: string;
        let icyMetadataKeyStreamURL: string;
        let quickTimeMetadataKeyAlbum: string;
        let quickTimeMetadataKeyArranger: string;
        let quickTimeMetadataKeyArtist: string;
        let quickTimeMetadataKeyArtwork: string;
        let quickTimeMetadataKeyAuthor: string;
        let quickTimeMetadataKeyCameraFrameReadoutTime: string;
        let quickTimeMetadataKeyCameraIdentifier: string;
        let quickTimeMetadataKeyCollectionUser: string;
        let quickTimeMetadataKeyComment: string;
        let quickTimeMetadataKeyComposer: string;
        let quickTimeMetadataKeyContentIdentifier: string;
        let quickTimeMetadataKeyCopyright: string;
        let quickTimeMetadataKeyCreationDate: string;
        let quickTimeMetadataKeyCredits: string;
        let quickTimeMetadataKeyDescription: string;
        let quickTimeMetadataKeyDirectionFacing: string;
        let quickTimeMetadataKeyDirectionMotion: string;
        let quickTimeMetadataKeyDirector: string;
        let quickTimeMetadataKeyDisplayName: string;
        let quickTimeMetadataKeyEncodedBy: string;
        let quickTimeMetadataKeyGenre: string;
        let quickTimeMetadataKeyInformation: string;
        let quickTimeMetadataKeyKeywords: string;
        let quickTimeMetadataKeyLocationBody: string;
        let quickTimeMetadataKeyLocationDate: string;
        let quickTimeMetadataKeyLocationISO6709: string;
        let quickTimeMetadataKeyLocationName: string;
        let quickTimeMetadataKeyLocationNote: string;
        let quickTimeMetadataKeyLocationRole: string;
        let quickTimeMetadataKeyMake: string;
        let quickTimeMetadataKeyModel: string;
        let quickTimeMetadataKeyOriginalArtist: string;
        let quickTimeMetadataKeyPerformer: string;
        let quickTimeMetadataKeyPhonogramRights: string;
        let quickTimeMetadataKeyProducer: string;
        let quickTimeMetadataKeyPublisher: string;
        let quickTimeMetadataKeyRatingUser: string;
        let quickTimeMetadataKeySoftware: string;
        let quickTimeMetadataKeyTitle: string;
        let quickTimeMetadataKeyYear: string;
        let quickTimeMetadataKeyiXML: string;
        let quickTimeUserDataKeyAlbum: string;
        let quickTimeUserDataKeyArranger: string;
        let quickTimeUserDataKeyArtist: string;
        let quickTimeUserDataKeyAuthor: string;
        let quickTimeUserDataKeyChapter: string;
        let quickTimeUserDataKeyComment: string;
        let quickTimeUserDataKeyComposer: string;
        let quickTimeUserDataKeyCopyright: string;
        let quickTimeUserDataKeyCreationDate: string;
        let quickTimeUserDataKeyCredits: string;
        let quickTimeUserDataKeyDescription: string;
        let quickTimeUserDataKeyDirector: string;
        let quickTimeUserDataKeyDisclaimer: string;
        let quickTimeUserDataKeyEncodedBy: string;
        let quickTimeUserDataKeyFullName: string;
        let quickTimeUserDataKeyGenre: string;
        let quickTimeUserDataKeyHostComputer: string;
        let quickTimeUserDataKeyInformation: string;
        let quickTimeUserDataKeyKeywords: string;
        let quickTimeUserDataKeyLocationISO6709: string;
        let quickTimeUserDataKeyMake: string;
        let quickTimeUserDataKeyModel: string;
        let quickTimeUserDataKeyOriginalArtist: string;
        let quickTimeUserDataKeyOriginalFormat: string;
        let quickTimeUserDataKeyOriginalSource: string;
        let quickTimeUserDataKeyPerformers: string;
        let quickTimeUserDataKeyPhonogramRights: string;
        let quickTimeUserDataKeyProducer: string;
        let quickTimeUserDataKeyProduct: string;
        let quickTimeUserDataKeyPublisher: string;
        let quickTimeUserDataKeySoftware: string;
        let quickTimeUserDataKeySpecialPlaybackRequirements: string;
        let quickTimeUserDataKeyTaggedCharacteristic: string;
        let quickTimeUserDataKeyTrack: string;
        let quickTimeUserDataKeyTrackName: string;
        let quickTimeUserDataKeyURLLink: string;
        let quickTimeUserDataKeyWarning: string;
        let quickTimeUserDataKeyWriter: string;
        let iTunesMetadataKeyAccountKind: string;
        let iTunesMetadataKeyAcknowledgement: string;
        let iTunesMetadataKeyAlbum: string;
        let iTunesMetadataKeyAlbumArtist: string;
        let iTunesMetadataKeyAppleID: string;
        let iTunesMetadataKeyArranger: string;
        let iTunesMetadataKeyArtDirector: string;
        let iTunesMetadataKeyArtist: string;
        let iTunesMetadataKeyArtistID: string;
        let iTunesMetadataKeyAuthor: string;
        let iTunesMetadataKeyBeatsPerMin: string;
        let iTunesMetadataKeyComposer: string;
        let iTunesMetadataKeyConductor: string;
        let iTunesMetadataKeyContentRating: string;
        let iTunesMetadataKeyCopyright: string;
        let iTunesMetadataKeyCoverArt: string;
        let iTunesMetadataKeyCredits: string;
        let iTunesMetadataKeyDescription: string;
        let iTunesMetadataKeyDirector: string;
        let iTunesMetadataKeyDiscCompilation: string;
        let iTunesMetadataKeyDiscNumber: string;
        let iTunesMetadataKeyEQ: string;
        let iTunesMetadataKeyEncodedBy: string;
        let iTunesMetadataKeyEncodingTool: string;
        let iTunesMetadataKeyExecProducer: string;
        let iTunesMetadataKeyGenreID: string;
        let iTunesMetadataKeyGrouping: string;
        let iTunesMetadataKeyLinerNotes: string;
        let iTunesMetadataKeyLyrics: string;
        let iTunesMetadataKeyOnlineExtras: string;
        let iTunesMetadataKeyOriginalArtist: string;
        let iTunesMetadataKeyPerformer: string;
        let iTunesMetadataKeyPhonogramRights: string;
        let iTunesMetadataKeyPlaylistID: string;
        let iTunesMetadataKeyPredefinedGenre: string;
        let iTunesMetadataKeyProducer: string;
        let iTunesMetadataKeyPublisher: string;
        let iTunesMetadataKeyRecordCompany: string;
        let iTunesMetadataKeyReleaseDate: string;
        let iTunesMetadataKeySoloist: string;
        let iTunesMetadataKeySongID: string;
        let iTunesMetadataKeySongName: string;
        let iTunesMetadataKeySoundEngineer: string;
        let iTunesMetadataKeyThanks: string;
        let iTunesMetadataKeyTrackNumber: string;
        let iTunesMetadataKeyTrackSubTitle: string;
        let iTunesMetadataKeyUserComment: string;
        let iTunesMetadataKeyUserGenre: string;
    }
    namespace AVMetadataKeySpace {
        let audioFile: string;
        let common: string;
        let hlsDateRange: string;
        let id3: string;
        let isoUserData: string;
        let icy: string;
        let quickTimeMetadata: string;
        let quickTimeUserData: string;
        let iTunes: string;
    }
    namespace AVMetadataObject {
        let aztec: string;
        let catBody: string;
        let code128: string;
        let code39: string;
        let code39Mod43: string;
        let code93: string;
        let dataMatrix: string;
        let dogBody: string;
        let ean13: string;
        let ean8: string;
        let face: string;
        let humanBody: string;
        let itf14: string;
        let interleaved2of5: string;
        let pdf417: string;
        let qr: string;
        let salientObject: string;
        let upce: string;
    }
    namespace AVOutputSettingsPreset {
        let preset1280x720: string;
        let preset1920x1080: string;
        let preset3840x2160: string;
        let preset640x480: string;
        let preset960x540: string;
        let hevc1920x1080: string;
        let hevc1920x1080WithAlpha: string;
        let hevc3840x2160: string;
        let hevc3840x2160WithAlpha: string;
    }
    namespace AVPlayer {
        enum ActionAtItemEnd {
            Advance = 0,
            Pause = 1,
            None = 2
        }
        enum HDRMode {
            HLG = 1,
            HDR10 = 2,
            DolbyVision = 4
        }
        enum Status {
            Unknown = 0,
            ReadyToPlay = 1,
            Failed = 2
        }
        enum TimeControlStatus {
            Paused = 0,
            WaitingToPlayAtSpecifiedRate = 1,
            Playing = 2
        }
        let eligibleForHDRPlaybackDidChangeNotification: string;
        let toMinimizeStalls: string;
        let evaluatingBufferingRate: string;
        let noItemToPlay: string;
    }
    namespace AVPlayerItem {
        enum Status {
            Unknown = 0,
            ReadyToPlay = 1,
            Failed = 2
        }
        let mediaSelectionDidChangeNotification: string;
        let recommendedTimeOffsetFromLiveDidChangeNotification: string;
    }
    namespace AVPlayerItemLegibleOutput {
        let default_: string;
        let sourceAndRulesOnly: string;
    }
    namespace AVPlayerLooper {
        enum Status {
            Unknown = 0,
            Ready = 1,
            Failed = 2,
            Cancelled = 3
        }
    }
    namespace AVSampleBufferRenderSynchronizer {
        let rateDidChangeNotification: string;
    }
    namespace AVSampleBufferRequest {
        enum Direction {
            Forward = 1,
            None = 0,
            Reverse = -1
        }
        enum Mode {
            Immediate = 0,
            Scheduled = 1,
            Opportunistic = 2
        }
    }
    namespace AVSemanticSegmentationMatte {
        let hair: string;
        let skin: string;
        let teeth: string;
    }
    namespace AVVideoApertureMode {
        let cleanAperture: string;
        let encodedPixels: string;
        let productionAperture: string;
    }
    namespace AVVideoCodecType {
        let proRes422: string;
        let proRes422HQ: string;
        let proRes422LT: string;
        let proRes422Proxy: string;
        let proRes4444: string;
        let h264: string;
        let hevc: string;
        let hevcWithAlpha: string;
        let jpeg: string;
    }
    namespace Bundle {
        let didLoadNotification: string;
    }
    namespace ByteCountFormatter {
        enum CountStyle {
            File = 0,
            Memory = 1,
            Decimal = 2,
            Binary = 3
        }
        enum Units {
            UseDefault = 0,
            UseBytes = 1,
            UseKB = 2,
            UseMB = 4,
            UseGB = 8,
            UseTB = 16,
            UsePB = 32,
            UseEB = 64,
            UseZB = 128,
            UseYBOrHigher = 65280,
            UseAll = 65535
        }
    }
    namespace CAAnimationCalculationMode {
        let cubic: string;
        let cubicPaced: string;
        let discrete: string;
        let linear: string;
        let paced: string;
    }
    namespace CAAnimationRotationMode {
        let rotateAuto: string;
        let rotateAutoReverse: string;
    }
    namespace CAEmitterLayerEmitterMode {
        let outline: string;
        let points: string;
        let surface: string;
        let volume: string;
    }
    namespace CAEmitterLayerEmitterShape {
        let circle: string;
        let cuboid: string;
        let line: string;
        let point: string;
        let rectangle: string;
        let sphere: string;
    }
    namespace CAEmitterLayerRenderMode {
        let additive: string;
        let backToFront: string;
        let oldestFirst: string;
        let oldestLast: string;
        let unordered: string;
    }
    namespace CAGradientLayerType {
        let axial: string;
        let conic: string;
        let radial: string;
    }
    namespace CALayerContentsFilter {
        let linear: string;
        let nearest: string;
        let trilinear: string;
    }
    namespace CALayerContentsFormat {
        let gray8Uint: string;
        let RGBA16Float: string;
        let RGBA8Uint: string;
    }
    namespace CALayerContentsGravity {
        let bottom: string;
        let bottomLeft: string;
        let bottomRight: string;
        let center: string;
        let left: string;
        let resize: string;
        let resizeAspect: string;
        let resizeAspectFill: string;
        let right: string;
        let top: string;
        let topLeft: string;
        let topRight: string;
    }
    namespace CALayerCornerCurve {
        let circular: string;
        let continuous: string;
    }
    namespace CAMediaTimingFillMode {
        let backwards: string;
        let both: string;
        let forwards: string;
        let removed: string;
    }
    namespace CAMediaTimingFunctionName {
        let default_: string;
        let easeIn: string;
        let easeInEaseOut: string;
        let easeOut: string;
        let linear: string;
    }
    namespace CAScrollLayerScrollMode {
        let both: string;
        let horizontally: string;
        let none: string;
        let vertically: string;
    }
    namespace CAShapeLayerFillRule {
        let evenOdd: string;
        let nonZero: string;
    }
    namespace CAShapeLayerLineCap {
        let butt: string;
        let round: string;
        let square: string;
    }
    namespace CAShapeLayerLineJoin {
        let bevel: string;
        let miter: string;
        let round: string;
    }
    namespace CATextLayerAlignmentMode {
        let center: string;
        let justified: string;
        let left: string;
        let natural: string;
        let right: string;
    }
    namespace CATextLayerTruncationMode {
        let end: string;
        let middle: string;
        let none: string;
        let start: string;
    }
    namespace CATransitionSubtype {
        let fromBottom: string;
        let fromLeft: string;
        let fromRight: string;
        let fromTop: string;
    }
    namespace CATransitionType {
        let fade: string;
        let moveIn: string;
        let push: string;
        let reveal: string;
    }
    namespace CAValueFunctionName {
        let rotateX: string;
        let rotateY: string;
        let rotateZ: string;
        let scale: string;
        let scaleX: string;
        let scaleY: string;
        let scaleZ: string;
        let translate: string;
        let translateX: string;
        let translateY: string;
        let translateZ: string;
    }
    namespace CFCalendarIdentifier {
        let buddhistCalendar: any;
        let chineseCalendar: any;
        let gregorianCalendar: any;
        let hebrewCalendar: any;
        let cfiso8601Calendar: any;
        let indianCalendar: any;
        let islamicCalendar: any;
        let islamicCivilCalendar: any;
        let islamicTabularCalendar: any;
        let islamicUmmAlQuraCalendar: any;
        let japaneseCalendar: any;
        let persianCalendar: any;
        let republicOfChinaCalendar: any;
    }
    namespace CFDateFormatterKey {
        let amSymbol: any;
        let calendar: any;
        let calendarName: any;
        let defaultDate: any;
        let defaultFormat: any;
        let doesRelativeDateFormattingKey: any;
        let eraSymbols: any;
        let gregorianStartDate: any;
        let isLenient: any;
        let longEraSymbols: any;
        let monthSymbols: any;
        let pmSymbol: any;
        let quarterSymbols: any;
        let shortMonthSymbols: any;
        let shortQuarterSymbols: any;
        let shortStandaloneMonthSymbols: any;
        let shortStandaloneQuarterSymbols: any;
        let shortStandaloneWeekdaySymbols: any;
        let shortWeekdaySymbols: any;
        let standaloneMonthSymbols: any;
        let standaloneQuarterSymbols: any;
        let standaloneWeekdaySymbols: any;
        let timeZone: any;
        let twoDigitStartDate: any;
        let veryShortMonthSymbols: any;
        let veryShortStandaloneMonthSymbols: any;
        let veryShortStandaloneWeekdaySymbols: any;
        let veryShortWeekdaySymbols: any;
        let weekdaySymbols: any;
    }
    namespace CFLocaleKey {
        let alternateQuotationBeginDelimiterKey: any;
        let alternateQuotationEndDelimiterKey: any;
        let calendar: any;
        let calendarIdentifier: any;
        let collationIdentifier: any;
        let collatorIdentifier: any;
        let countryCode: any;
        let currencyCode: any;
        let currencySymbol: any;
        let decimalSeparator: any;
        let exemplarCharacterSet: any;
        let groupingSeparator: any;
        let identifier: any;
        let languageCode: any;
        let measurementSystem: any;
        let quotationBeginDelimiterKey: any;
        let quotationEndDelimiterKey: any;
        let scriptCode: any;
        let usesMetricSystem: any;
        let variantCode: any;
    }
    namespace CFNotificationName {
        let cfLocaleCurrentLocaleDidChange: any;
        let cfTimeZoneSystemTimeZoneDidChange: any;
    }
    namespace CFNumberFormatterKey {
        let alwaysShowDecimalSeparator: any;
        let currencyCode: any;
        let currencyDecimalSeparator: any;
        let currencyGroupingSeparator: any;
        let currencySymbol: any;
        let decimalSeparator: any;
        let defaultFormat: any;
        let exponentSymbol: any;
        let formatWidth: any;
        let groupingSeparator: any;
        let groupingSize: any;
        let infinitySymbol: any;
        let internationalCurrencySymbol: any;
        let isLenient: any;
        let maxFractionDigits: any;
        let maxIntegerDigits: any;
        let maxSignificantDigits: any;
        let minFractionDigits: any;
        let minIntegerDigits: any;
        let minSignificantDigits: any;
        let minusSign: any;
        let multiplier: any;
        let naNSymbol: any;
        let negativePrefix: any;
        let negativeSuffix: any;
        let paddingCharacter: any;
        let paddingPosition: any;
        let perMillSymbol: any;
        let percentSymbol: any;
        let plusSign: any;
        let positivePrefix: any;
        let positiveSuffix: any;
        let roundingIncrement: any;
        let roundingMode: any;
        let secondaryGroupingSize: any;
        let useGroupingSeparator: any;
        let useSignificantDigits: any;
        let zeroSymbol: any;
    }
    namespace CFRunLoopMode {
        let commonModes: any;
        let defaultMode: any;
    }
    namespace CFStreamPropertyKey {
        let appendToFile: any;
        let dataWritten: any;
        let fileCurrentOffset: any;
        let socketNativeHandle: any;
        let socketRemoteHostName: any;
        let socketRemotePortNumber: any;
    }
    namespace CGAffineTransform {
        let identity: CGAffineTransform;
    }
    namespace CGColor {
        let __blackColorName: string;
        let __clearColorName: string;
        let conversionBlackPointCompensation: string;
        let conversionTRCSize: string;
        let __whiteColorName: string;
    }
    namespace CGColorSpace {
        let acescgLinear: string;
        let adobeRGB1998: string;
        let dcip3: string;
        let displayP3: string;
        let displayP3_HLG: string;
        let displayP3_PQ_EOTF: string;
        let extendedGray: string;
        let extendedLinearDisplayP3: string;
        let extendedLinearGray: string;
        let extendedLinearITUR_2020: string;
        let extendedLinearSRGB: string;
        let extendedSRGB: string;
        let genericCMYK: string;
        let genericGray: string;
        let genericGrayGamma2_2: string;
        let genericLab: string;
        let genericRGB: string;
        let genericRGBLinear: string;
        let genericXYZ: string;
        let itur_2020: string;
        let itur_2020_HLG: string;
        let itur_2020_PQ_EOTF: string;
        let itur_709: string;
        let linearGray: string;
        let linearSRGB: string;
        let rommrgb: string;
        let sRGB: string;
    }
    namespace CGDisplayStream {
        let colorSpace: string;
        let destinationRect: string;
        let minimumFrameTime: string;
        let preserveAspectRatio: string;
        let queueDepth: string;
        let showCursor: string;
        let sourceRect: string;
        let yCbCrMatrix: string;
        let yCbCrMatrix_ITU_R_601_4: string;
        let yCbCrMatrix_ITU_R_709_2: string;
        let yCbCrMatrix_SMPTE_240M_1995: string;
    }
    namespace CGFont {
        let variationAxisDefaultValue: string;
        let variationAxisMaxValue: string;
        let variationAxisMinValue: string;
        let variationAxisName: string;
    }
    namespace CGPDFTagProperty {
        let actualText: any;
        let alternativeText: any;
        let languageText: any;
        let titleText: any;
    }
    namespace CGPoint {
        let zero: CGPoint;
    }
    namespace CGRect {
        let infinite: CGRect;
        let null_: CGRect;
        let zero: CGRect;
    }
    namespace CGSize {
        let zero: CGSize;
    }
    namespace CIContextOption {
        let allowLowPower: string;
        let cacheIntermediates: string;
        let highQualityDownsample: string;
        let outputColorSpace: string;
        let outputPremultiplied: string;
        let priorityRequestLow: string;
        let useSoftwareRenderer: string;
        let workingColorSpace: string;
        let workingFormat: string;
    }
    namespace CIFormat {
        let A16: number;
        let A8: number;
        let ABGR8: number;
        let ARGB8: number;
        let Af: number;
        let Ah: number;
        let BGRA8: number;
        let L16: number;
        let L8: number;
        let LA16: number;
        let LA8: number;
        let LAf: number;
        let LAh: number;
        let Lf: number;
        let Lh: number;
        let R16: number;
        let R8: number;
        let RG16: number;
        let RG8: number;
        let RGBA16: number;
        let RGBA8: number;
        let RGBAf: number;
        let RGBAh: number;
        let RGf: number;
        let RGh: number;
        let Rf: number;
        let Rh: number;
    }
    namespace CIImageAutoAdjustmentOption {
        let crop: string;
        let enhance: string;
        let features: string;
        let level: string;
        let redEye: string;
    }
    namespace CIImageOption {
        let applyOrientationProperty: string;
        let auxiliaryDepth: string;
        let auxiliaryDisparity: string;
        let auxiliaryPortraitEffectsMatte: string;
        let auxiliarySemanticSegmentationHairMatte: string;
        let auxiliarySemanticSegmentationSkinMatte: string;
        let auxiliarySemanticSegmentationTeethMatte: string;
        let colorSpace: string;
        let nearestSampling: string;
        let properties: string;
        let providerTileSize: string;
        let providerUserInfo: string;
    }
    namespace CIImageRepresentationOption {
        let avDepthData: string;
        let avPortraitEffectsMatte: string;
        let avSemanticSegmentationMattes: string;
        let depthImage: string;
        let disparityImage: string;
        let portraitEffectsMatteImage: string;
        let semanticSegmentationHairMatteImage: string;
        let semanticSegmentationSkinMatteImage: string;
        let semanticSegmentationTeethMatteImage: string;
    }
    namespace CIRAWFilterOption {
        let activeKeys: string;
        let allowDraftMode: string;
        let baselineExposure: string;
        let boostAmount: string;
        let boostShadowAmount: string;
        let colorNoiseReductionAmount: string;
        let decoderVersion: string;
        let disableGamutMap: string;
        let enableChromaticNoiseTracking: string;
        let enableSharpening: string;
        let enableVendorLensCorrection: string;
        let ignoreImageOrientation: string;
        let imageOrientation: string;
        let linearSpaceFilter: string;
        let luminanceNoiseReductionAmount: string;
        let moireAmount: string;
        let neutralChromaticityX: string;
        let neutralChromaticityY: string;
        let neutralLocation: string;
        let neutralTemperature: string;
        let neutralTint: string;
        let noiseReductionAmount: string;
        let noiseReductionContrastAmount: string;
        let noiseReductionDetailAmount: string;
        let noiseReductionSharpnessAmount: string;
        let scaleFactor: string;
        let outputNativeSize: string;
        let supportedDecoderVersions: string;
    }
    namespace CMImageDescriptionFlavor {
        let mobile3GPFamily: any;
        let isoFamily: any;
        let quickTimeMovie: any;
    }
    namespace CMSampleTimingInfo {
        let invalid: CMSampleTimingInfo;
    }
    namespace CMSoundDescriptionFlavor {
        let mobile3GPFamily: any;
        let isoFamily: any;
        let quickTimeMovie: any;
        let quickTimeMovieV2: any;
    }
    namespace CMTime {
        let indefinite: CMTime;
        let invalid: CMTime;
        let negativeInfinity: CMTime;
        let positiveInfinity: CMTime;
        let zero: CMTime;
    }
    namespace CMTimeMapping {
        let invalid: CMTimeMapping;
    }
    namespace CMTimeRange {
        let invalid: CMTimeRange;
        let zero: CMTimeRange;
    }
    namespace DateComponentsFormatter {
        enum UnitsStyle {
            Positional = 0,
            Abbreviated = 1,
            Short = 2,
            Full = 3,
            SpellOut = 4,
            Brief = 5
        }
        enum ZeroFormattingBehavior {
            None = 0,
            Default = 1,
            DropLeading = 2,
            DropMiddle = 4,
            DropTrailing = 8,
            DropAll = 14,
            Pad = 65536
        }
    }
    namespace DateFormatter {
        enum Behavior {
            BehaviorDefault = 0,
            Behavior10_0 = 1000,
            Behavior10_4 = 1040
        }
        enum Style {
            NoStyle = 0,
            ShortStyle = 1,
            MediumStyle = 2,
            LongStyle = 3,
            FullStyle = 4
        }
    }
    namespace DateIntervalFormatter {
        enum Style {
            NoStyle = 0,
            ShortStyle = 1,
            MediumStyle = 2,
            LongStyle = 3,
            FullStyle = 4
        }
    }
    namespace Decimal {
        type RoundingMode = NSDecimalNumber;
        type CalculationError = NSDecimalNumber;
        type FloatLiteralType = number;
        type IntegerLiteralType = number;
        type Magnitude = number;
        type Stride = number;
    }
    namespace DistributedNotificationCenter {
        enum Options {
            DeliverImmediately = 1,
            PostToAllSessions = 2
        }
        enum SuspensionBehavior {
            Drop = 1,
            Coalesce = 2,
            Hold = 3,
            DeliverImmediately = 4
        }
        let localNotificationCenterType: string;
    }
    namespace EnergyFormatter {
        enum Unit {
            Joule = 11,
            Kilojoule = 14,
            Calorie = 1793,
            Kilocalorie = 1794
        }
    }
    namespace FileAttributeKey {
        let appendOnly: string;
        let busy: string;
        let creationDate: string;
        let deviceIdentifier: string;
        let extensionHidden: string;
        let groupOwnerAccountID: string;
        let groupOwnerAccountName: string;
        let hfsCreatorCode: string;
        let hfsTypeCode: string;
        let immutable: string;
        let modificationDate: string;
        let ownerAccountID: string;
        let ownerAccountName: string;
        let posixPermissions: string;
        let protectionKey: string;
        let referenceCount: string;
        let size: string;
        let systemFileNumber: string;
        let systemFreeNodes: string;
        let systemFreeSize: string;
        let systemNodes: string;
        let systemNumber: string;
        let systemSize: string;
        let type: string;
    }
    namespace FileAttributeType {
        let typeBlockSpecial: string;
        let typeCharacterSpecial: string;
        let typeDirectory: string;
        let typeRegular: string;
        let typeSocket: string;
        let typeSymbolicLink: string;
        let typeUnknown: string;
    }
    namespace FileHandle {
        let readCompletionNotification: string;
    }
    namespace FileManager {
        enum DirectoryEnumerationOptions {
            SkipsSubdirectoryDescendants = 1,
            SkipsPackageDescendants = 2,
            SkipsHiddenFiles = 4,
            IncludesDirectoriesPostOrder = 8,
            ProducesRelativePathURLs = 16
        }
        enum ItemReplacementOptions {
            UsingNewMetadataOnly = 1,
            WithoutDeletingBackupItem = 2
        }
        enum UnmountOptions {
            AllPartitionsAndEjectDisk = 1,
            WithoutUI = 2
        }
        enum SearchPathDirectory {
            ApplicationDirectory = 1,
            DemoApplicationDirectory = 2,
            DeveloperApplicationDirectory = 3,
            AdminApplicationDirectory = 4,
            LibraryDirectory = 5,
            DeveloperDirectory = 6,
            UserDirectory = 7,
            DocumentationDirectory = 8,
            DocumentDirectory = 9,
            CoreServiceDirectory = 10,
            AutosavedInformationDirectory = 11,
            DesktopDirectory = 12,
            CachesDirectory = 13,
            ApplicationSupportDirectory = 14,
            DownloadsDirectory = 15,
            InputMethodsDirectory = 16,
            MoviesDirectory = 17,
            MusicDirectory = 18,
            PicturesDirectory = 19,
            PrinterDescriptionDirectory = 20,
            SharedPublicDirectory = 21,
            PreferencePanesDirectory = 22,
            ApplicationScriptsDirectory = 23,
            ItemReplacementDirectory = 99,
            AllApplicationsDirectory = 100,
            AllLibrariesDirectory = 101,
            TrashDirectory = 102
        }
        enum SearchPathDomainMask {
            UserDomainMask = 1,
            LocalDomainMask = 2,
            NetworkDomainMask = 4,
            SystemDomainMask = 8,
            AllDomainsMask = 65535
        }
        enum URLRelationship {
            Contains = 0,
            Same = 1,
            Other = 2
        }
        enum VolumeEnumerationOptions {
            SkipHiddenVolumes = 2,
            ProduceFileReferenceURLs = 4
        }
    }
    namespace FileProtectionType {
        let complete: string;
        let completeUnlessOpen: string;
        let completeUntilFirstUserAuthentication: string;
        let none: string;
    }
    namespace FileWrapper {
        enum ReadingOptions {
            Immediate = 1,
            WithoutMapping = 2
        }
        enum WritingOptions {
            Atomic = 1,
            WithNameUpdating = 2
        }
    }
    namespace Formatter {
        enum Context {
            Unknown = 0,
            Dynamic = 1,
            Standalone = 2,
            ListItem = 3,
            BeginningOfSentence = 4,
            MiddleOfSentence = 5
        }
        enum UnitStyle {
            Short = 1,
            Medium = 2,
            Long = 3
        }
    }
    namespace HTTPCookie {
        enum AcceptPolicy {
            Always = 0,
            Never = 1,
            OnlyFromMainDocumentDomain = 2
        }
    }
    namespace HTTPCookiePropertyKey {
        let comment: string;
        let commentURL: string;
        let discard: string;
        let domain: string;
        let expires: string;
        let maximumAge: string;
        let name: string;
        let originURL: string;
        let path: string;
        let port: string;
        let sameSitePolicy: string;
        let secure: string;
        let value: string;
        let version: string;
    }
    namespace HTTPCookieStringPolicy {
        let sameSiteLax: string;
        let sameSiteStrict: string;
    }
    namespace ISO8601DateFormatter {
        enum Options {
            WithYear = 1,
            WithMonth = 2,
            WithWeekOfYear = 4,
            WithDay = 16,
            WithTime = 32,
            WithTimeZone = 64,
            WithSpaceBetweenDateAndTime = 128,
            WithDashSeparatorInDate = 256,
            WithColonSeparatorInTime = 512,
            WithColonSeparatorInTimeZone = 1024,
            WithFractionalSeconds = 2048,
            WithFullDate = 275,
            WithFullTime = 1632,
            WithInternetDateTime = 1907
        }
    }
    namespace JSONSerialization {
        enum ReadingOptions {
            MutableContainers = 1,
            MutableLeaves = 2,
            FragmentsAllowed = 4,
            AllowFragments = 4
        }
        enum WritingOptions {
            PrettyPrinted = 1,
            SortedKeys = 2,
            FragmentsAllowed = 4,
            WithoutEscapingSlashes = 8
        }
    }
    namespace LengthFormatter {
        enum Unit {
            Millimeter = 8,
            Centimeter = 9,
            Meter = 11,
            Kilometer = 14,
            Inch = 1281,
            Foot = 1282,
            Yard = 1283,
            Mile = 1284
        }
    }
    namespace MassFormatter {
        enum Unit {
            Gram = 11,
            Kilogram = 14,
            Ounce = 1537,
            Pound = 1538,
            Stone = 1539
        }
    }
    namespace MeasurementFormatter {
        enum UnitOptions {
            ProvidedUnit = 1,
            NaturalScale = 2,
            TemperatureWithoutUnit = 4
        }
    }
    namespace NSAccessibility {
        enum AnnotationPosition {
            FullRange = 0,
            Start = 1,
            End = 2
        }
        enum Orientation {
            Unknown = 0,
            Vertical = 1,
            Horizontal = 2
        }
        enum RulerMarkerType {
            Unknown = 0,
            TabStopLeft = 1,
            TabStopRight = 2,
            TabStopCenter = 3,
            TabStopDecimal = 4,
            IndentHead = 5,
            IndentTail = 6,
            IndentFirstLine = 7
        }
        enum SortDirection {
            Unknown = 0,
            Ascending = 1,
            Descending = 2
        }
        enum Units {
            Unknown = 0,
            Inches = 1,
            Centimeters = 2,
            Points = 3,
            Picas = 4
        }
        let activationPoint: string;
        let allowedValues: string;
        let alternateUIVisible: string;
        let element: string;
        let label: string;
        let location: string;
        let announcement: string;
        let announcementRequested: string;
        let applicationActivated: string;
        let applicationDeactivated: string;
        let applicationHidden: string;
        let application: string;
        let applicationShown: string;
        let ascending: string;
        let attributedStringForRange: string;
        let boundsForRange: string;
        let browser: string;
        let busyIndicator: string;
        let button: string;
        let cancel: string;
        let cancelButton: string;
        let cellForColumnAndRow: string;
        let cell: string;
        let centerTabStop: string;
        let centimeters: string;
        let checkBox: string;
        let children: string;
        let clearButton: string;
        let closeButton: string;
        let collectionListSubrole: string;
        let colorWell: string;
        let columnCount: string;
        let columnHeaderUIElements: string;
        let columnIndexRange: string;
        let column: string;
        let columnTitles: string;
        let columns: string;
        let comboBox: string;
        let confirm: string;
        let containsProtectedContent: string;
        let contentList: string;
        let contents: string;
        let created: string;
        let criticalValue: string;
        let decimalTabStop: string;
        let decrement: string;
        let decrementArrow: string;
        let decrementButton: string;
        let decrementPage: string;
        let defaultButton: string;
        let definitionList: string;
        let delete_: string;
        let descending: string;
        let description: string;
        let descriptionList: string;
        let dialog: string;
        let disclosedByRow: string;
        let disclosedRows: string;
        let disclosing: string;
        let disclosureLevel: string;
        let disclosureTriangle: string;
        let document: string;
        let drawerCreated: string;
        let drawer: string;
        let edited: string;
        let enabled: string;
        let ErrorCodeExceptionInfo: string;
        let expanded: string;
        let extrasMenuBar: string;
        let filename: string;
        let firstLineIndent: string;
        let floatingWindow: string;
        let focused: string;
        let focusedUIElement: string;
        let focusedUIElementChanged: string;
        let focusedWindow: string;
        let focusedWindowChanged: string;
        let fontFamily: string;
        let fontName: string;
        let fontSize: string;
        let frontmost: string;
        let fullScreenButton: string;
        let grid: string;
        let group: string;
        let growArea: string;
        let handle: string;
        let handles: string;
        let headIndent: string;
        let header: string;
        let help: string;
        let helpTagCreated: string;
        let helpTag: string;
        let hidden: string;
        let horizontal: string;
        let horizontalScrollBar: string;
        let horizontalUnitDescription: string;
        let horizontalUnits: string;
        let identifier: string;
        let image: string;
        let inches: string;
        let increment: string;
        let incrementArrow: string;
        let incrementButton: string;
        let incrementPage: string;
        let incrementor: string;
        let index: string;
        let insertionPointLineNumber: string;
        let labelUIElements: string;
        let labelValue: string;
        let layoutArea: string;
        let layoutChanged: string;
        let layoutItem: string;
        let layoutPointForScreenPoint: string;
        let layoutSizeForScreenSize: string;
        let leftTabStop: string;
        let levelIndicator: string;
        let lineForIndex: string;
        let link: string;
        let linkedUIElements: string;
        let list: string;
        let main: string;
        let mainWindow: string;
        let mainWindowChanged: string;
        let markerGroupUIElement: string;
        let markerType: string;
        let markerTypeDescription: string;
        let markerUIElements: string;
        let markerValues: string;
        let matte: string;
        let maxValue: string;
        let menuBar: string;
        let menuBarItem: string;
        let menuButton: string;
        let menuItem: string;
        let menu: string;
        let minValue: string;
        let minimizeButton: string;
        let minimized: string;
        let modal: string;
        let moved: string;
        let nextContents: string;
        let numberOfCharacters: string;
        let orderedByRow: string;
        let orientation: string;
        let outline: string;
        let outlineRow: string;
        let overflowButton: string;
        let pageRole: string;
        let parent: string;
        let picas: string;
        let pick: string;
        let placeholderValue: string;
        let points: string;
        let popUpButton: string;
        let popover: string;
        let position: string;
        let press: string;
        let previousContents: string;
        let priority: string;
        let progressIndicator: string;
        let proxy: string;
        let rtfForRange: string;
        let radioButton: string;
        let radioGroup: string;
        let raise: string;
        let rangeForIndex: string;
        let rangeForLine: string;
        let rangeForPosition: string;
        let ratingIndicator: string;
        let relevanceIndicator: string;
        let required: string;
        let resized: string;
        let rightTabStop: string;
        let role: string;
        let roleDescription: string;
        let rowCollapsed: string;
        let rowCount: string;
        let rowCountChanged: string;
        let rowExpanded: string;
        let rowHeaderUIElements: string;
        let rowIndexRange: string;
        let row: string;
        let rows: string;
        let rulerMarker: string;
        let ruler: string;
        let screenPointForLayoutPoint: string;
        let screenSizeForLayoutSize: string;
        let scrollArea: string;
        let scrollBar: string;
        let searchButton: string;
        let searchField: string;
        let searchMenu: string;
        let sectionListSubrole: string;
        let secureTextField: string;
        let selected: string;
        let selectedCells: string;
        let selectedCellsChanged: string;
        let selectedChildren: string;
        let selectedChildrenChanged: string;
        let selectedChildrenMoved: string;
        let selectedColumns: string;
        let selectedColumnsChanged: string;
        let selectedRows: string;
        let selectedRowsChanged: string;
        let selectedText: string;
        let selectedTextChanged: string;
        let selectedTextRange: string;
        let selectedTextRanges: string;
        let servesAsTitleForUIElements: string;
        let sharedCharacterRange: string;
        let sharedFocusElements: string;
        let sharedTextUIElements: string;
        let sheetCreated: string;
        let sheet: string;
        let showAlternateUI: string;
        let showDefaultUI: string;
        let showMenu: string;
        let shownMenu: string;
        let size: string;
        let slider: string;
        let sortButton: string;
        let sortDirection: string;
        let splitGroup: string;
        let splitter: string;
        let splitters: string;
        let standardWindow: string;
        let staticText: string;
        let stringForRange: string;
        let styleRangeForIndex: string;
        let subrole: string;
        let switch_: string;
        let systemDialog: string;
        let systemFloatingWindow: string;
        let systemWide: string;
        let tabButtonSubrole: string;
        let tabGroup: string;
        let table: string;
        let tableRow: string;
        let tabs: string;
        let tailIndent: string;
        let textArea: string;
        let textAttachment: string;
        let textField: string;
        let textLink: string;
        let timeline: string;
        let title: string;
        let titleChanged: string;
        let titleUIElement: string;
        let toggle: string;
        let toolbarButton: string;
        let toolbar: string;
        let topLevelUIElement: string;
        let uiElementDestroyed: string;
        let uiElements: string;
        let url: string;
        let unitDescription: string;
        let units: string;
        let unitsChanged: string;
        let unknown: string;
        let value: string;
        let valueChanged: string;
        let valueDescription: string;
        let valueIndicator: string;
        let vertical: string;
        let verticalScrollBar: string;
        let verticalUnitDescription: string;
        let verticalUnits: string;
        let visibleCells: string;
        let visibleCharacterRange: string;
        let visibleChildren: string;
        let visibleColumns: string;
        let visibleName: string;
        let visibleRows: string;
        let warningValue: string;
        let window: string;
        let windowCreated: string;
        let windowDeminiaturized: string;
        let windowMiniaturized: string;
        let windowMoved: string;
        let windowResized: string;
        let windows: string;
        let zoomButton: string;
    }
    namespace NSAccessibilityCustomRotor {
        enum SearchDirection {
            Previous = 0,
            Next = 1
        }
        enum RotorType {
            Custom = 0,
            Any = 1,
            Annotation = 2,
            BoldText = 3,
            Heading = 4,
            HeadingLevel1 = 5,
            HeadingLevel2 = 6,
            HeadingLevel3 = 7,
            HeadingLevel4 = 8,
            HeadingLevel5 = 9,
            HeadingLevel6 = 10,
            Image = 11,
            ItalicText = 12,
            Landmark = 13,
            Link = 14,
            List = 15,
            MisspelledWord = 16,
            Table = 17,
            TextField = 18,
            UnderlinedText = 19,
            VisitedLink = 20
        }
    }
    namespace NSAlert {
        enum Style {
            Warning = 0,
            Informational = 1,
            Critical = 2
        }
    }
    namespace NSAnimation {
        enum BlockingMode {
            Blocking = 0,
            Nonblocking = 1,
            NonblockingThreaded = 2
        }
        enum Curve {
            EaseInOut = 0,
            EaseIn = 1,
            EaseOut = 2,
            Linear = 3
        }
        let progressMarkUserInfoKey: string;
        let progressMarkNotification: string;
        type Progress = number;
    }
    namespace NSAppKitVersion {
        let current: number;
        let macOS10_0: number;
        let macOS10_1: number;
        let macOS10_10: number;
        let macOS10_10_2: number;
        let macOS10_10_3: number;
        let macOS10_10_4: number;
        let macOS10_10_5: number;
        let macOS10_10_Max: number;
        let macOS10_11: number;
        let macOS10_11_1: number;
        let macOS10_11_2: number;
        let macOS10_11_3: number;
        let macOS10_12: number;
        let macOS10_12_1: number;
        let macOS10_12_2: number;
        let macOS10_13: number;
        let macOS10_13_1: number;
        let macOS10_13_2: number;
        let macOS10_13_4: number;
        let number10_14: number;
        let number10_14_1: number;
        let number10_14_2: number;
        let number10_14_3: number;
        let number10_14_4: number;
        let number10_14_5: number;
        let macOS10_2: number;
        let macOS10_2_3: number;
        let macOS10_3: number;
        let macOS10_3_2: number;
        let macOS10_3_3: number;
        let macOS10_3_5: number;
        let macOS10_3_7: number;
        let macOS10_3_9: number;
        let macOS10_4: number;
        let macOS10_4_1: number;
        let macOS10_4_3: number;
        let macOS10_4_4: number;
        let macOS10_4_7: number;
        let macOS10_5: number;
        let macOS10_5_2: number;
        let macOS10_5_3: number;
        let macOS10_6: number;
        let macOS10_7: number;
        let macOS10_7_2: number;
        let macOS10_7_3: number;
        let macOS10_7_4: number;
        let macOS10_8: number;
        let macOS10_9: number;
        let numberWithColumnResizingBrowser: number;
        let numberWithContinuousScrollingBrowser: number;
        let numberWithCursorSizeSupport: number;
        let numberWithCustomSheetPosition: number;
        let numberWithDeferredWindowDisplaySupport: number;
        let numberWithDirectionalTabs: number;
        let numberWithDockTilePlugInSupport: number;
        let numberWithPatternColorLeakFix: number;
    }
    namespace NSAppearance {
        let accessibilityHighContrastAqua: string;
        let accessibilityHighContrastDarkAqua: string;
        let accessibilityHighContrastVibrantDark: string;
        let accessibilityHighContrastVibrantLight: string;
        let aqua: string;
        let darkAqua: string;
        let vibrantDark: string;
        let vibrantLight: string;
    }
    namespace NSAppleEventDescriptor {
        enum SendOptions {
            NoReply = 1,
            QueueReply = 2,
            WaitForReply = 3,
            NeverInteract = 16,
            CanInteract = 32,
            AlwaysInteract = 48,
            CanSwitchLayer = 64,
            DontRecord = 4096,
            DontExecute = 8192,
            DontAnnotate = 65536,
            DefaultOptions = 35
        }
    }
    namespace NSAppleEventManager {
        type SuspensionID = OpaquePointer;
    }
    namespace NSAppleScript {
        let errorAppName: string;
        let errorBriefMessage: string;
        let errorMessage: string;
        let errorNumber: string;
        let errorRange: string;
    }
    namespace NSApplication {
        enum ActivationOptions {
            ActivateAllWindows = 1,
            ActivateIgnoringOtherApps = 2
        }
        enum ActivationPolicy {
            Regular = 0,
            Accessory = 1,
            Prohibited = 2
        }
        enum DelegateReply {
            Success = 0,
            Cancel = 1,
            Failure = 2
        }
        enum OcclusionState {
            Visible = 2
        }
        enum PresentationOptions {
            Default = 0,
            AutoHideDock = 1,
            HideDock = 2,
            AutoHideMenuBar = 4,
            HideMenuBar = 8,
            DisableAppleMenu = 16,
            DisableProcessSwitching = 32,
            DisableForceQuit = 64,
            DisableSessionTermination = 128,
            DisableHideApplication = 256,
            DisableMenuBarTransparency = 512,
            FullScreen = 1024,
            AutoHideToolbar = 2048,
            DisableCursorLocationAssistance = 4096
        }
        enum PrintReply {
            PrintingCancelled = 0,
            PrintingSuccess = 1,
            PrintingFailure = 3,
            PrintingReplyLater = 2
        }
        enum TerminateReply {
            TerminateCancel = 0,
            TerminateNow = 1,
            TerminateLater = 2
        }
        enum RemoteNotificationType {
            None = 0,
            Badge = 1,
            Sound = 2,
            Alert = 4
        }
        enum RequestUserAttentionType {
            CriticalRequest = 0,
            InformationalRequest = 10
        }
        enum WindowListOptions {
            OrderedFrontToBack = 1
        }
        let applicationIcon: string;
        let applicationName: string;
        let applicationVersion: string;
        let credits: string;
        let version: string;
        let alertFirstButtonReturn: number;
        let alertSecondButtonReturn: number;
        let alertThirdButtonReturn: number;
        let didBecomeActiveNotification: string;
        let didChangeOcclusionStateNotification: string;
        let didChangeScreenParametersNotification: string;
        let didFinishLaunchingNotification: string;
        let didFinishRestoringWindowsNotification: string;
        let didHideNotification: string;
        let didResignActiveNotification: string;
        let didUnhideNotification: string;
        let didUpdateNotification: string;
        let launchIsDefaultUserInfoKey: string;
        let launchUserNotificationUserInfoKey: string;
        let willBecomeActiveNotification: string;
        let willFinishLaunchingNotification: string;
        let willHideNotification: string;
        let willResignActiveNotification: string;
        let willTerminateNotification: string;
        let willUnhideNotification: string;
        let willUpdateNotification: string;
        let abort: number;
        let cancel: number;
        let continue_: number;
        let OK: number;
        let stop: number;
        type ModalSession = OpaquePointer;
    }
    namespace NSArray {
        type Iterator = NSFastEnumerationIterator;
    }
    namespace NSAttributedString {
        enum SpellingState {
            SpellingFlag = 1,
            GrammarFlag = 2
        }
        enum EnumerationOptions {
            Reverse = 2,
            LongestEffectiveRangeNotRequired = 1048576
        }
        let accessibilityAnnotationTextAttribute: string;
        let accessibilityAttachment: string;
        let accessibilityAutocorrected: string;
        let accessibilityBackgroundColor: string;
        let accessibilityCustomText: string;
        let accessibilityFont: string;
        let accessibilityForegroundColor: string;
        let accessibilityLanguage: string;
        let accessibilityLink: string;
        let accessibilityListItemIndex: string;
        let accessibilityListItemLevel: string;
        let accessibilityListItemPrefix: string;
        let accessibilityMarkedMisspelled: string;
        let accessibilityMisspelled: string;
        let accessibilityShadow: string;
        let accessibilityStrikethroughColor: string;
        let accessibilityStrikethrough: string;
        let accessibilitySuperscript: string;
        let accessibilityAlignment: string;
        let accessibilityUnderlineColor: string;
        let accessibilityUnderline: string;
        let appearance: string;
        let attachment: string;
        let author: string;
        let backgroundColor: string;
        let baseURL: string;
        let baselineOffset: string;
        let bottomMargin: string;
        let category: string;
        let characterEncoding: string;
        let cocoaVersion: string;
        let comment: string;
        let company: string;
        let converted: string;
        let copyright: string;
        let creationTime: string;
        let cursor: string;
        let defaultAttributes: string;
        let defaultTabInterval: string;
        let docFormat: string;
        let documentType: string;
        let editor: string;
        let excludedElements: string;
        let expansion: string;
        let fileType: string;
        let font: string;
        let foregroundColor: string;
        let glyphInfo: string;
        let html: string;
        let hyphenationFactor: string;
        let kern: string;
        let keywords: string;
        let leftMargin: string;
        let ligature: string;
        let link: string;
        let macSimpleText: string;
        let manager: string;
        let markedClauseSegment: string;
        let modificationTime: string;
        let obliqueness: string;
        let officeOpenXML: string;
        let openDocument: string;
        let paperSize: string;
        let paragraphStyle: string;
        let plain: string;
        let prefixSpaces: string;
        let rtfd: string;
        let rtf: string;
        let readOnly: string;
        let rightMargin: string;
        let shadow: string;
        let sourceTextScaling: string;
        let spellingState: string;
        let strikethroughColor: string;
        let strikethroughStyle: string;
        let strokeColor: string;
        let strokeWidth: string;
        let subject: string;
        let superscript: string;
        let targetTextScaling: string;
        let textAlternatives: string;
        let textEffect: string;
        let letterpressStyle: string;
        let textEncodingName: string;
        let orientation: string;
        let range: string;
        let textLayoutSections: string;
        let textScaling: string;
        let textSizeMultiplier: string;
        let timeout: string;
        let title: string;
        let toolTip: string;
        let topMargin: string;
        let underlineColor: string;
        let underlineStyle: string;
        let verticalGlyphForm: string;
        let viewMode: string;
        let viewSize: string;
        let viewZoom: string;
        let webArchive: string;
        let webPreferences: string;
        let webResourceLoadDelegate: string;
        let wordML: string;
        let writingDirection: string;
    }
    namespace NSBackgroundActivityScheduler {
        enum Result {
            Finished = 1,
            Deferred = 2
        }
    }
    namespace NSBezierPath {
        enum ElementType {
            MoveTo = 0,
            LineTo = 1,
            CurveTo = 2,
            ClosePath = 3
        }
        enum LineCapStyle {
            Butt = 0,
            Round = 1,
            Square = 2
        }
        enum LineJoinStyle {
            Miter = 0,
            Round = 1,
            Bevel = 2
        }
        enum WindingRule {
            NonZero = 0,
            EvenOdd = 1
        }
        let bevel: NSBezierPath.LineJoinStyle;
        let butt: NSBezierPath.LineCapStyle;
        let closePath: NSBezierPath.ElementType;
        let curveTo: NSBezierPath.ElementType;
        let evenOdd: NSBezierPath.WindingRule;
        let lineTo: NSBezierPath.ElementType;
        let miter: NSBezierPath.LineJoinStyle;
        let moveTo: NSBezierPath.ElementType;
        let nonZero: NSBezierPath.WindingRule;
        let round: NSBezierPath.LineCapStyle;
        let square: NSBezierPath.LineCapStyle;
    }
    namespace NSBindingInfoKey {
        let observedKeyPath: string;
        let observedObject: string;
        let options: string;
    }
    namespace NSBindingName {
        let alignment: string;
        let alternateImage: string;
        let alternateTitle: string;
        let animate: string;
        let animationDelay: string;
        let argument: string;
        let attributedString: string;
        let contentArray: string;
        let contentArrayForMultipleSelection: string;
        let content: string;
        let contentDictionary: string;
        let contentHeight: string;
        let contentObject: string;
        let contentObjects: string;
        let contentSet: string;
        let contentValues: string;
        let contentWidth: string;
        let criticalValue: string;
        let data: string;
        let displayPatternTitle: string;
        let displayPatternValue: string;
        let documentEdited: string;
        let doubleClickArgument: string;
        let doubleClickTarget: string;
        let editable: string;
        let enabled: string;
        let excludedKeys: string;
        let filterPredicate: string;
        let font: string;
        let fontBold: string;
        let fontFamilyName: string;
        let fontItalic: string;
        let fontName: string;
        let fontSize: string;
        let headerTitle: string;
        let hidden: string;
        let image: string;
        let includedKeys: string;
        let initialKey: string;
        let initialValue: string;
        let isIndeterminate: string;
        let label: string;
        let localizedKeyDictionary: string;
        let managedObjectContext: string;
        let maxValue: string;
        let maxWidth: string;
        let maximumRecents: string;
        let minValue: string;
        let minWidth: string;
        let mixedStateImage: string;
        let offStateImage: string;
        let onStateImage: string;
        let positioningRect: string;
        let predicate: string;
        let recentSearches: string;
        let representedFilename: string;
        let rowHeight: string;
        let selectedIdentifier: string;
        let selectedIndex: string;
        let selectedLabel: string;
        let selectedObject: string;
        let selectedObjects: string;
        let selectedTag: string;
        let selectedValue: string;
        let selectedValues: string;
        let selectionIndexPaths: string;
        let selectionIndexes: string;
        let sortDescriptors: string;
        let target: string;
        let textColor: string;
        let title: string;
        let toolTip: string;
        let transparent: string;
        let value: string;
        let valuePath: string;
        let valueURL: string;
        let visible: string;
        let warningValue: string;
        let width: string;
    }
    namespace NSBindingOption {
        let allowsEditingMultipleValuesSelection: string;
        let allowsNullArgument: string;
        let alwaysPresentsApplicationModalAlerts: string;
        let conditionallySetsEditable: string;
        let conditionallySetsEnabled: string;
        let conditionallySetsHidden: string;
        let contentPlacementTag: string;
        let continuouslyUpdatesValue: string;
        let createsSortDescriptor: string;
        let deletesObjectsOnRemove: string;
        let displayName: string;
        let displayPattern: string;
        let handlesContentAsCompoundValue: string;
        let insertsNullPlaceholder: string;
        let invokesSeparatelyWithArrayObjects: string;
        let multipleValuesPlaceholder: string;
        let noSelectionPlaceholder: string;
        let notApplicablePlaceholder: string;
        let nullPlaceholder: string;
        let predicateFormat: string;
        let raisesForNotApplicableKeys: string;
        let selectorName: string;
        let selectsAllWhenSettingContent: string;
        let validatesImmediately: string;
        let valueTransformer: string;
        let valueTransformerName: string;
    }
    namespace NSBitmapImageRep {
        enum Format {
            AlphaFirst = 1,
            AlphaNonpremultiplied = 2,
            FloatingPointSamples = 4,
            SixteenBitLittleEndian = 256,
            ThirtyTwoBitLittleEndian = 512,
            SixteenBitBigEndian = 1024,
            ThirtyTwoBitBigEndian = 2048
        }
        enum FileType {
            TIFF = 0,
            BMP = 1,
            GIF = 2,
            JPEG = 3,
            PNG = 4,
            JPEG2000 = 5
        }
        enum LoadStatus {
            UnknownType = -1,
            ReadingHeader = -2,
            WillNeedAllData = -3,
            InvalidData = -4,
            UnexpectedEOF = -5,
            Completed = -6
        }
        enum TIFFCompression {
            None = 1,
            CCITTFAX3 = 3,
            CCITTFAX4 = 4,
            LZW = 5,
            JPEG = 6,
            NEXT = 32766,
            PackBits = 32773,
            OldJPEG = 32865
        }
        let colorSyncProfileData: string;
        let compressionFactor: string;
        let compressionMethod: string;
        let currentFrame: string;
        let currentFrameDuration: string;
        let ditherTransparency: string;
        let exifData: string;
        let fallbackBackgroundColor: string;
        let frameCount: string;
        let gamma: string;
        let interlaced: string;
        let loopCount: string;
        let progressive: string;
        let rgbColorTable: string;
    }
    namespace NSBox {
        enum BoxType {
            Primary = 0,
            Separator = 2,
            Custom = 4
        }
        enum TitlePosition {
            NoTitle = 0,
            AboveTop = 1,
            AtTop = 2,
            BelowTop = 3,
            AboveBottom = 4,
            AtBottom = 5,
            BelowBottom = 6
        }
        let primary: NSBox.BoxType;
    }
    namespace NSBrowser {
        enum ColumnResizingType {
            NoColumnResizing = 0,
            AutoColumnResizing = 1,
            UserColumnResizing = 2
        }
        enum DropOperation {
            On = 0,
            Above = 1
        }
        let columnConfigurationDidChangeNotification: string;
        type ColumnsAutosaveName = String;
    }
    namespace NSButton {
        enum BezelStyle {
            Rounded = 1,
            RegularSquare = 2,
            Disclosure = 5,
            ShadowlessSquare = 6,
            Circular = 7,
            TexturedSquare = 8,
            HelpButton = 9,
            SmallSquare = 10,
            TexturedRounded = 11,
            RoundRect = 12,
            Recessed = 13,
            RoundedDisclosure = 14,
            Inline = 15
        }
        enum ButtonType {
            MomentaryLight = 0,
            PushOnPushOff = 1,
            Toggle = 2,
            Switch = 3,
            Radio = 4,
            MomentaryChange = 5,
            OnOff = 6,
            MomentaryPushIn = 7,
            Accelerator = 8,
            MultiLevelAccelerator = 9
        }
    }
    namespace NSCalendar {
        enum Options {
            WrapComponents = 1,
            MatchStrictly = 2,
            SearchBackwards = 4,
            MatchPreviousTimePreservingSmallerUnits = 256,
            MatchNextTimePreservingSmallerUnits = 512,
            MatchNextTime = 1024,
            MatchFirst = 4096,
            MatchLast = 8192
        }
        enum Unit {
            CalendarUnitEra = 2,
            CalendarUnitYear = 4,
            CalendarUnitMonth = 8,
            CalendarUnitDay = 16,
            CalendarUnitHour = 32,
            CalendarUnitMinute = 64,
            CalendarUnitSecond = 128,
            CalendarUnitWeekday = 512,
            CalendarUnitWeekdayOrdinal = 1024,
            CalendarUnitQuarter = 2048,
            CalendarUnitWeekOfMonth = 4096,
            CalendarUnitWeekOfYear = 8192,
            CalendarUnitYearForWeekOfYear = 16384,
            CalendarUnitNanosecond = 32768,
            CalendarUnitCalendar = 1048576,
            CalendarUnitTimeZone = 2097152,
            EraCalendarUnit = 2,
            YearCalendarUnit = 4,
            MonthCalendarUnit = 8,
            DayCalendarUnit = 16,
            HourCalendarUnit = 32,
            MinuteCalendarUnit = 64,
            SecondCalendarUnit = 128,
            WeekCalendarUnit = 256,
            WeekdayCalendarUnit = 512,
            WeekdayOrdinalCalendarUnit = 1024,
            QuarterCalendarUnit = 2048,
            WeekOfMonthCalendarUnit = 4096,
            WeekOfYearCalendarUnit = 8192,
            YearForWeekOfYearCalendarUnit = 16384,
            CalendarCalendarUnit = 1048576,
            TimeZoneCalendarUnit = 2097152
        }
        let buddhist: string;
        let chinese: string;
        let coptic: string;
        let ethiopicAmeteAlem: string;
        let ethiopicAmeteMihret: string;
        let gregorian: string;
        let hebrew: string;
        let ISO8601: string;
        let indian: string;
        let islamic: string;
        let islamicCivil: string;
        let islamicTabular: string;
        let islamicUmmAlQura: string;
        let japanese: string;
        let persian: string;
        let republicOfChina: string;
    }
    namespace NSCell {
        enum Attribute {
            CellDisabled = 0,
            CellState = 1,
            PushInCell = 2,
            CellEditable = 3,
            ChangeGrayCell = 4,
            CellHighlighted = 5,
            CellLightsByContents = 6,
            CellLightsByGray = 7,
            ChangeBackgroundCell = 8,
            CellLightsByBackground = 9,
            CellIsBordered = 10,
            CellHasOverlappingImage = 11,
            CellHasImageHorizontal = 12,
            CellHasImageOnLeftOrBottom = 13,
            CellChangesContents = 14,
            CellIsInsetButton = 15,
            CellAllowsMixedState = 16
        }
        enum HitResult {
            None = 0,
            ContentArea = 1,
            EditableTextArea = 2,
            TrackableArea = 4
        }
        enum StyleMask {
            NoCellMask = 0,
            ContentsCellMask = 1,
            PushInCellMask = 2,
            ChangeGrayCellMask = 4,
            ChangeBackgroundCellMask = 8
        }
        enum CellType {
            NullCellType = 0,
            TextCellType = 1,
            ImageCellType = 2
        }
    }
    namespace NSCoder {
        enum DecodingFailurePolicy {
            RaiseException = 0,
            SetErrorAndReturn = 1
        }
    }
    namespace NSCollectionView {
        enum UpdateAction {
            Insert = 0,
            Delete = 1,
            Reload = 2,
            Move = 3,
            None = 4
        }
        enum DropOperation {
            On = 0,
            Before = 1
        }
        enum ScrollDirection {
            Vertical = 0,
            Horizontal = 1
        }
        enum ScrollPosition {
            None = 0,
            Top = 1,
            CenteredVertically = 2,
            Bottom = 4,
            NearestHorizontalEdge = 512,
            Left = 8,
            CenteredHorizontally = 16,
            Right = 32,
            LeadingEdge = 64,
            TrailingEdge = 128,
            NearestVerticalEdge = 256
        }
        let elementKindInterItemGapIndicator: string;
        let elementKindSectionFooter: string;
        let elementKindSectionHeader: string;
        type DecorationElementKind = String;
        type SupplementaryElementKind = String;
    }
    namespace NSCollectionViewItem {
        enum HighlightState {
            None = 0,
            ForSelection = 1,
            ForDeselection = 2,
            AsDropTarget = 3
        }
    }
    namespace NSCollectionViewTransitionLayout {
        type AnimatedKey = String;
    }
    namespace NSColor {
        enum SystemEffect {
            None = 0,
            Pressed = 1,
            DeepPressed = 2,
            Disabled = 3,
            Rollover = 4
        }
        enum ColorType {
            ComponentBased = 0,
            Pattern = 1,
            Catalog = 2
        }
        let currentControlTintDidChangeNotification: string;
        let systemColorsDidChangeNotification: string;
        type Name = String;
    }
    namespace NSColorList {
        let didChangeNotification: string;
        type Name = String;
    }
    namespace NSColorPanel {
        enum Mode {
            None = -1,
            Gray = 0,
            RGB = 1,
            CMYK = 2,
            HSB = 3,
            CustomPalette = 4,
            ColorList = 5,
            Wheel = 6,
            Crayon = 7
        }
        enum Options {
            GrayModeMask = 1,
            RGBModeMask = 2,
            CMYKModeMask = 4,
            HSBModeMask = 8,
            CustomPaletteModeMask = 16,
            ColorListModeMask = 32,
            WheelModeMask = 64,
            CrayonModeMask = 128,
            AllModesMask = 65535
        }
        let colorDidChangeNotification: string;
    }
    namespace NSColorSpace {
        enum Model {
            Unknown = -1,
            Gray = 0,
            RGB = 1,
            CMYK = 2,
            LAB = 3,
            DeviceN = 4,
            Indexed = 5,
            Patterned = 6
        }
    }
    namespace NSColorSpaceName {
        let calibratedRGB: string;
        let calibratedWhite: string;
        let custom: string;
        let deviceCMYK: string;
        let deviceRGB: string;
        let deviceWhite: string;
        let named: string;
        let pattern: string;
    }
    namespace NSComboBox {
        let selectionDidChangeNotification: string;
        let selectionIsChangingNotification: string;
        let willDismissNotification: string;
        let willPopUpNotification: string;
    }
    namespace NSComparisonPredicate {
        enum Modifier {
            DirectPredicateModifier = 0,
            AllPredicateModifier = 1,
            AnyPredicateModifier = 2
        }
        enum Options {
            CaseInsensitivePredicateOption = 1,
            DiacriticInsensitivePredicateOption = 2,
            NormalizedPredicateOption = 4
        }
        enum Operator {
            LessThanPredicateOperatorType = 0,
            LessThanOrEqualToPredicateOperatorType = 1,
            GreaterThanPredicateOperatorType = 2,
            GreaterThanOrEqualToPredicateOperatorType = 3,
            EqualToPredicateOperatorType = 4,
            NotEqualToPredicateOperatorType = 5,
            MatchesPredicateOperatorType = 6,
            LikePredicateOperatorType = 7,
            BeginsWithPredicateOperatorType = 8,
            EndsWithPredicateOperatorType = 9,
            InPredicateOperatorType = 10,
            CustomSelectorPredicateOperatorType = 11,
            ContainsPredicateOperatorType = 99,
            BetweenPredicateOperatorType = 100
        }
    }
    namespace NSCompoundPredicate {
        enum LogicalType {
            NotPredicateType = 0,
            AndPredicateType = 1,
            OrPredicateType = 2
        }
    }
    namespace NSControl {
        enum ImagePosition {
            NoImage = 0,
            ImageOnly = 1,
            ImageLeft = 2,
            ImageRight = 3,
            ImageBelow = 4,
            ImageAbove = 5,
            ImageOverlaps = 6,
            ImageLeading = 7,
            ImageTrailing = 8
        }
        enum ControlSize {
            Regular = 0,
            Small = 1,
            Mini = 2
        }
        let mixed: number;
        let off: number;
        let on: number;
        let textDidBeginEditingNotification: string;
        let textDidChangeNotification: string;
        let textDidEndEditingNotification: string;
    }
    namespace NSData {
        enum Base64DecodingOptions {
            IgnoreUnknownCharacters = 1
        }
        enum Base64EncodingOptions {
            Encoding64CharacterLineLength = 1,
            Encoding76CharacterLineLength = 2,
            EncodingEndLineWithCarriageReturn = 16,
            EncodingEndLineWithLineFeed = 32
        }
        enum CompressionAlgorithm {
            LZFSE = 0,
            LZ4 = 1,
            LZMA = 2,
            Zlib = 3
        }
        enum ReadingOptions {
            DataReadingMappedIfSafe = 1,
            DataReadingUncached = 2,
            DataReadingMappedAlways = 8,
            DataReadingMapped = 1,
            MappedRead = 1,
            UncachedRead = 2
        }
        enum SearchOptions {
            Backwards = 1,
            Anchored = 2
        }
        enum WritingOptions {
            DataWritingAtomic = 1,
            DataWritingWithoutOverwriting = 2,
            DataWritingFileProtectionNone = 268435456,
            DataWritingFileProtectionComplete = 536870912,
            DataWritingFileProtectionCompleteUnlessOpen = 805306368,
            DataWritingFileProtectionCompleteUntilFirstUserAuthentication = 1073741824,
            DataWritingFileProtectionMask = 4026531840,
            AtomicWrite = 1
        }
        type Element = number;
        type Index = number;
        type Iterator = IndexingIterator;
        type SubSequence = Slice;
        type Indices = Range;
    }
    namespace NSDatePicker {
        enum ElementFlags {
            HourMinute = 12,
            HourMinuteSecond = 14,
            TimeZone = 16,
            YearMonth = 192,
            YearMonthDay = 224,
            Era = 256
        }
        enum Mode {
            Single = 0,
            Range = 1
        }
        enum Style {
            TextFieldAndStepper = 0,
            ClockAndCalendar = 1,
            TextField = 2
        }
        let clockAndCalendar: NSDatePicker.Style;
        let era: NSDatePicker.ElementFlags;
        let hourMinute: NSDatePicker.ElementFlags;
        let hourMinuteSecond: NSDatePicker.ElementFlags;
        let range: NSDatePicker.Mode;
        let single: NSDatePicker.Mode;
        let textFieldAndStepper: NSDatePicker.Style;
        let textField: NSDatePicker.Style;
        let timeZone: NSDatePicker.ElementFlags;
        let yearMonth: NSDatePicker.ElementFlags;
        let yearMonthDay: NSDatePicker.ElementFlags;
    }
    namespace NSDecimalNumber {
        enum CalculationError {
            NoError = 0,
            LossOfPrecision = 1,
            Underflow = 2,
            Overflow = 3,
            DivideByZero = 4
        }
        enum RoundingMode {
            Plain = 0,
            Down = 1,
            Up = 2,
            Bankers = 3
        }
    }
    namespace NSDeviceDescriptionKey {
        let bitsPerSample: string;
        let colorSpaceName: string;
        let isPrinter: string;
        let isScreen: string;
        let resolution: string;
        let size: string;
    }
    namespace NSDocument {
        enum ChangeType {
            ChangeDone = 0,
            ChangeUndone = 1,
            ChangeRedone = 5,
            ChangeCleared = 2,
            ChangeReadOtherContents = 3,
            ChangeAutosaved = 4,
            ChangeDiscardable = 256
        }
        enum SaveOperationType {
            SaveOperation = 0,
            SaveAsOperation = 1,
            SaveToOperation = 2,
            AutosaveInPlaceOperation = 4,
            AutosaveElsewhereOperation = 3,
            AutosaveAsOperation = 5,
            AutosaveOperation = 3
        }
    }
    namespace NSDraggingItem {
        let icon: string;
        let label: string;
    }
    namespace NSDrawer {
        enum State {
            ClosedState = 0,
            OpeningState = 1,
            OpenState = 2,
            ClosingState = 3
        }
    }
    namespace NSEnumerator {
        type Iterator = NSFastEnumerationIterator;
    }
    namespace NSError {
        type UserInfoKey = string;
    }
    namespace NSEvent {
        enum ButtonMask {
            PenTip = 1,
            PenLowerSide = 2,
            PenUpperSide = 4
        }
        enum GestureAxis {
            None = 0,
            Horizontal = 1,
            Vertical = 2
        }
        enum EventTypeMask {
            LeftMouseDown = 2,
            LeftMouseUp = 4,
            RightMouseDown = 8,
            RightMouseUp = 16,
            MouseMoved = 32,
            LeftMouseDragged = 64,
            RightMouseDragged = 128,
            MouseEntered = 256,
            MouseExited = 512,
            KeyDown = 1024,
            KeyUp = 2048,
            FlagsChanged = 4096,
            AppKitDefined = 8192,
            SystemDefined = 16384,
            ApplicationDefined = 32768,
            Periodic = 65536,
            CursorUpdate = 131072,
            ScrollWheel = 4194304,
            TabletPoint = 8388608,
            TabletProximity = 16777216,
            OtherMouseDown = 33554432,
            OtherMouseUp = 67108864,
            OtherMouseDragged = 134217728,
            Gesture = 536870912,
            Magnify = 1073741824,
            Swipe = 2147483648,
            Rotate = 262144,
            BeginGesture = 524288,
            EndGesture = 1048576,
            SmartMagnify = 4294967296,
            Pressure = 17179869184,
            DirectTouch = 137438953472,
            ChangeMode = 274877906944,
            Any = -1
        }
        enum ModifierFlags {
            CapsLock = 65536,
            Shift = 131072,
            Control = 262144,
            Option = 524288,
            Command = 1048576,
            NumericPad = 2097152,
            Help = 4194304,
            Function = 8388608,
            DeviceIndependentFlagsMask = 4294901760
        }
        enum Phase {
            None = 0,
            Began = 1,
            Stationary = 2,
            Changed = 4,
            Ended = 8,
            Cancelled = 16,
            MayBegin = 32
        }
        enum EventSubtype {
            WindowExposed = 0,
            ApplicationActivated = 1,
            ApplicationDeactivated = 2,
            WindowMoved = 4,
            ScreenChanged = 8,
            PowerOff = 1,
            MouseEvent = 0,
            TabletPoint = 1,
            TabletProximity = 2,
            Touch = 3
        }
        enum SwipeTrackingOptions {
            LockDirection = 1,
            ClampGestureAmount = 2
        }
        enum EventType {
            LeftMouseDown = 1,
            LeftMouseUp = 2,
            RightMouseDown = 3,
            RightMouseUp = 4,
            MouseMoved = 5,
            LeftMouseDragged = 6,
            RightMouseDragged = 7,
            MouseEntered = 8,
            MouseExited = 9,
            KeyDown = 10,
            KeyUp = 11,
            FlagsChanged = 12,
            AppKitDefined = 13,
            SystemDefined = 14,
            ApplicationDefined = 15,
            Periodic = 16,
            CursorUpdate = 17,
            ScrollWheel = 22,
            TabletPoint = 23,
            TabletProximity = 24,
            OtherMouseDown = 25,
            OtherMouseUp = 26,
            OtherMouseDragged = 27,
            Gesture = 29,
            Magnify = 30,
            Swipe = 31,
            Rotate = 18,
            BeginGesture = 19,
            EndGesture = 20,
            SmartMagnify = 32,
            QuickLook = 33,
            Pressure = 34,
            DirectTouch = 37,
            ChangeMode = 38
        }
        enum PointingDeviceType {
            Unknown = 0,
            Pen = 1,
            Cursor = 2,
            Eraser = 3
        }
        enum PressureBehavior {
            Unknown = -1,
            PrimaryDefault = 0,
            PrimaryClick = 1,
            PrimaryGeneric = 2,
            PrimaryAccelerator = 3,
            PrimaryDeepClick = 5,
            PrimaryDeepDrag = 6
        }
        let foreverDuration: number;
    }
    namespace NSExceptionName {
        let abortModalException: string;
        let abortPrintingException: string;
        let appKitIgnoredException: string;
        let appKitVirtualMemoryException: string;
        let badBitmapParametersException: string;
        let badComparisonException: string;
        let badRTFColorTableException: string;
        let badRTFDirectiveException: string;
        let badRTFFontTableException: string;
        let badRTFStyleSheetException: string;
        let browserIllegalDelegateException: string;
        let colorListIOException: string;
        let colorListNotEditableException: string;
        let draggingException: string;
        let fontUnavailableException: string;
        let illegalSelectorException: string;
        let imageCacheException: string;
        let nibLoadingException: string;
        let NSPPDIncludeNotFoundException: string;
        let NSPPDIncludeStackOverflowException: string;
        let NSPPDIncludeStackUnderflowException: string;
        let NSPPDParseException: string;
        let pasteboardCommunicationException: string;
        let printOperationExistsException: string;
        let printPackageException: string;
        let printingCommunicationException: string;
        let NSRTFPropertyStackOverflowException: string;
        let NSTIFFException: string;
        let textLineTooLongException: string;
        let textNoSelectionException: string;
        let textReadException: string;
        let textWriteException: string;
        let typedStreamVersionException: string;
        let windowServerCommunicationException: string;
        let wordTablesReadException: string;
        let wordTablesWriteException: string;
        let characterConversionException: string;
        let decimalNumberDivideByZeroException: string;
        let decimalNumberExactnessException: string;
        let decimalNumberOverflowException: string;
        let decimalNumberUnderflowException: string;
        let destinationInvalidException: string;
        let fileHandleOperationException: string;
        let genericException: string;
        let inconsistentArchiveException: string;
        let internalInconsistencyException: string;
        let invalidArchiveOperationException: string;
        let invalidArgumentException: string;
        let invalidReceivePortException: string;
        let invalidSendPortException: string;
        let invalidUnarchiveOperationException: string;
        let invocationOperationCancelledException: string;
        let invocationOperationVoidResultException: string;
        let mallocException: string;
        let objectInaccessibleException: string;
        let objectNotAvailableException: string;
        let oldStyleException: string;
        let parseErrorException: string;
        let portReceiveException: string;
        let portSendException: string;
        let portTimeoutException: string;
        let rangeException: string;
        let undefinedKeyException: string;
    }
    namespace NSExpression {
        enum ExpressionType {
            ConstantValueExpressionType = 0,
            EvaluatedObjectExpressionType = 1,
            VariableExpressionType = 2,
            KeyPathExpressionType = 3,
            FunctionExpressionType = 4,
            UnionSetExpressionType = 5,
            IntersectSetExpressionType = 6,
            MinusSetExpressionType = 7,
            SubqueryExpressionType = 13,
            AggregateExpressionType = 14,
            AnyKeyExpressionType = 15,
            BlockExpressionType = 19,
            ConditionalExpressionType = 20
        }
    }
    namespace NSFileCoordinator {
        enum ReadingOptions {
            WithoutChanges = 1,
            ResolvesSymbolicLink = 2,
            ImmediatelyAvailableMetadataOnly = 4,
            ForUploading = 8
        }
        enum WritingOptions {
            ForDeleting = 1,
            ForMoving = 2,
            ForMerging = 4,
            ForReplacing = 8,
            ContentIndependentMetadataOnly = 16
        }
    }
    namespace NSFileVersion {
        enum AddingOptions {
            ByMoving = 1
        }
        enum ReplacingOptions {
            ByMoving = 1
        }
    }
    namespace NSFont {
        let antialiasThresholdChangedNotification: string;
        let identityMatrix: number;
        let fontSetChangedNotification: string;
        let black: number;
        let bold: number;
        let heavy: number;
        let light: number;
        let medium: number;
        let regular: number;
        let semibold: number;
        let thin: number;
        let ultraLight: number;
    }
    namespace NSFontAssetRequest {
        enum Options {
            UsesStandardUI = 1
        }
    }
    namespace NSFontCollection {
        enum Visibility {
            Process = 1,
            User = 2,
            Computer = 4
        }
        let actionUserInfoKey: string;
        let allFonts: string;
        let didChangeNotification: string;
        let favorites: string;
        let nameUserInfoKey: string;
        let oldNameUserInfoKey: string;
        let recentlyUsed: string;
        let user: string;
        let visibilityUserInfoKey: string;
        let hidden: string;
        let renamed: string;
        let shown: string;
    }
    namespace NSFontDescriptor {
        enum SymbolicTraits {
            TraitItalic = 1,
            TraitBold = 2,
            TraitExpanded = 32,
            TraitCondensed = 64,
            TraitMonoSpace = 1024,
            TraitVertical = 2048,
            TraitUIOptimized = 4096,
            TraitTightLeading = 32768,
            TraitLooseLeading = 65536,
            ClassMask = 4026531840,
            ClassUnknown = 0,
            ClassOldStyleSerifs = 268435456,
            ClassTransitionalSerifs = 536870912,
            ClassModernSerifs = 805306368,
            ClassClarendonSerifs = 1073741824,
            ClassSlabSerifs = 1342177280,
            ClassFreeformSerifs = 1879048192,
            ClassSansSerif = 2147483648,
            ClassOrnamentals = 2415919104,
            ClassScripts = 2684354560,
            ClassSymbolic = 3221225472
        }
        let cascadeList: string;
        let characterSet: string;
        let default_: string;
        let monospaced: string;
        let rounded: string;
        let serif: string;
        let face: string;
        let family: string;
        let selectorIdentifier: string;
        let featureSettings: string;
        let typeIdentifier: string;
        let fixedAdvance: string;
        let matrix: string;
        let name: string;
        let size: string;
        let slant: string;
        let symbolic: string;
        let traits: string;
        let variation: string;
        let defaultValue: string;
        let identifier: string;
        let maximumValue: string;
        let minimumValue: string;
        let visibleName: string;
        let weight: string;
        let width: string;
    }
    namespace NSFontPanel {
        enum ModeMask {
            ModeMaskFace = 1,
            ModeMaskSize = 2,
            ModeMaskCollection = 4,
            ModeMaskUnderlineEffect = 256,
            ModeMaskStrikethroughEffect = 512,
            ModeMaskTextColorEffect = 1024,
            ModeMaskDocumentColorEffect = 2048,
            ModeMaskShadowEffect = 4096,
            ModeMaskAllEffects = 1048320,
            ModesMaskStandardModes = 65535,
            ModesMaskAllModes = 4294967295
        }
    }
    namespace NSGestureRecognizer {
        enum State {
            Possible = 0,
            Began = 1,
            Changed = 2,
            Ended = 3,
            Cancelled = 4,
            Failed = 5,
            Recognized = 3
        }
    }
    namespace NSGradient {
        enum DrawingOptions {
            DrawsBeforeStartingLocation = 1,
            DrawsAfterEndingLocation = 2
        }
    }
    namespace NSGraphicsContext {
        let destination: string;
        let pdf: string;
        let postScript: string;
        let representationFormat: string;
    }
    namespace NSGridCell {
        enum Placement {
            Inherited = 0,
            None = 1,
            Leading = 2,
            Top = 2,
            Trailing = 3,
            Bottom = 3,
            Center = 4,
            Fill = 5
        }
    }
    namespace NSGridRow {
        enum Alignment {
            Inherited = 0,
            None = 1,
            FirstBaseline = 2,
            LastBaseline = 3
        }
    }
    namespace NSGridView {
        let sizedForContent: number;
    }
    namespace NSHapticFeedbackManager {
        enum FeedbackPattern {
            Generic = 0,
            Alignment = 1,
            LevelChange = 2
        }
        enum PerformanceTime {
            Default = 0,
            Now = 1,
            DrawCompleted = 2
        }
    }
    namespace NSHelpManager {
        let contextHelpModeDidActivateNotification: string;
        let contextHelpModeDidDeactivateNotification: string;
        type BookName = String;
        type AnchorName = String;
        type ContextHelpKey = String;
    }
    namespace NSImage {
        enum CacheMode {
            Default = 0,
            Always = 1,
            BySize = 2,
            Never = 3
        }
        enum LayoutDirection {
            Unspecified = -1,
            LeftToRight = 2,
            RightToLeft = 3
        }
        enum LoadStatus {
            Completed = 0,
            Cancelled = 1,
            InvalidData = 2,
            UnexpectedEOF = 3,
            ReadError = 4
        }
        enum ResizingMode {
            Stretch = 0,
            Tile = 1
        }
        let actionTemplateName: string;
        let addTemplateName: string;
        let advancedName: string;
        let applicationIconName: string;
        let bluetoothTemplateName: string;
        let bonjourName: string;
        let bookmarksTemplateName: string;
        let cautionName: string;
        let colorPanelName: string;
        let columnViewTemplateName: string;
        let computerName: string;
        let enterFullScreenTemplateName: string;
        let everyoneName: string;
        let exitFullScreenTemplateName: string;
        let flowViewTemplateName: string;
        let folderName: string;
        let folderBurnableName: string;
        let folderSmartName: string;
        let followLinkFreestandingTemplateName: string;
        let fontPanelName: string;
        let goBackTemplateName: string;
        let goForwardTemplateName: string;
        let goLeftTemplateName: string;
        let goRightTemplateName: string;
        let homeTemplateName: string;
        let iChatTheaterTemplateName: string;
        let iconViewTemplateName: string;
        let infoName: string;
        let invalidDataFreestandingTemplateName: string;
        let leftFacingTriangleTemplateName: string;
        let listViewTemplateName: string;
        let lockLockedTemplateName: string;
        let lockUnlockedTemplateName: string;
        let menuMixedStateTemplateName: string;
        let menuOnStateTemplateName: string;
        let mobileMeName: string;
        let multipleDocumentsName: string;
        let networkName: string;
        let pathTemplateName: string;
        let preferencesGeneralName: string;
        let quickLookTemplateName: string;
        let refreshFreestandingTemplateName: string;
        let refreshTemplateName: string;
        let removeTemplateName: string;
        let revealFreestandingTemplateName: string;
        let rightFacingTriangleTemplateName: string;
        let shareTemplateName: string;
        let slideshowTemplateName: string;
        let smartBadgeTemplateName: string;
        let statusAvailableName: string;
        let statusNoneName: string;
        let statusPartiallyAvailableName: string;
        let statusUnavailableName: string;
        let stopProgressFreestandingTemplateName: string;
        let stopProgressTemplateName: string;
        let touchBarAddDetailTemplateName: string;
        let touchBarAddTemplateName: string;
        let touchBarAlarmTemplateName: string;
        let touchBarAudioInputMuteTemplateName: string;
        let touchBarAudioInputTemplateName: string;
        let touchBarAudioOutputMuteTemplateName: string;
        let touchBarAudioOutputVolumeHighTemplateName: string;
        let touchBarAudioOutputVolumeLowTemplateName: string;
        let touchBarAudioOutputVolumeMediumTemplateName: string;
        let touchBarAudioOutputVolumeOffTemplateName: string;
        let touchBarBookmarksTemplateName: string;
        let touchBarColorPickerFillName: string;
        let touchBarColorPickerFontName: string;
        let touchBarColorPickerStrokeName: string;
        let touchBarCommunicationAudioTemplateName: string;
        let touchBarCommunicationVideoTemplateName: string;
        let touchBarComposeTemplateName: string;
        let touchBarDeleteTemplateName: string;
        let touchBarDownloadTemplateName: string;
        let touchBarEnterFullScreenTemplateName: string;
        let touchBarExitFullScreenTemplateName: string;
        let touchBarFastForwardTemplateName: string;
        let touchBarFolderCopyToTemplateName: string;
        let touchBarFolderMoveToTemplateName: string;
        let touchBarFolderTemplateName: string;
        let touchBarGetInfoTemplateName: string;
        let touchBarGoBackTemplateName: string;
        let touchBarGoDownTemplateName: string;
        let touchBarGoForwardTemplateName: string;
        let touchBarGoUpTemplateName: string;
        let touchBarHistoryTemplateName: string;
        let touchBarIconViewTemplateName: string;
        let touchBarListViewTemplateName: string;
        let touchBarMailTemplateName: string;
        let touchBarNewFolderTemplateName: string;
        let touchBarNewMessageTemplateName: string;
        let touchBarOpenInBrowserTemplateName: string;
        let touchBarPauseTemplateName: string;
        let touchBarPlayPauseTemplateName: string;
        let touchBarPlayTemplateName: string;
        let touchBarPlayheadTemplateName: string;
        let touchBarQuickLookTemplateName: string;
        let touchBarRecordStartTemplateName: string;
        let touchBarRecordStopTemplateName: string;
        let touchBarRefreshTemplateName: string;
        let touchBarRemoveTemplateName: string;
        let touchBarRewindTemplateName: string;
        let touchBarRotateLeftTemplateName: string;
        let touchBarRotateRightTemplateName: string;
        let touchBarSearchTemplateName: string;
        let touchBarShareTemplateName: string;
        let touchBarSidebarTemplateName: string;
        let touchBarSkipAhead15SecondsTemplateName: string;
        let touchBarSkipAhead30SecondsTemplateName: string;
        let touchBarSkipAheadTemplateName: string;
        let touchBarSkipBack15SecondsTemplateName: string;
        let touchBarSkipBack30SecondsTemplateName: string;
        let touchBarSkipBackTemplateName: string;
        let touchBarSkipToEndTemplateName: string;
        let touchBarSkipToStartTemplateName: string;
        let touchBarSlideshowTemplateName: string;
        let touchBarTagIconTemplateName: string;
        let touchBarTextBoldTemplateName: string;
        let touchBarTextBoxTemplateName: string;
        let touchBarTextCenterAlignTemplateName: string;
        let touchBarTextItalicTemplateName: string;
        let touchBarTextJustifiedAlignTemplateName: string;
        let touchBarTextLeftAlignTemplateName: string;
        let touchBarTextListTemplateName: string;
        let touchBarTextRightAlignTemplateName: string;
        let touchBarTextStrikethroughTemplateName: string;
        let touchBarTextUnderlineTemplateName: string;
        let touchBarUserAddTemplateName: string;
        let touchBarUserGroupTemplateName: string;
        let touchBarUserTemplateName: string;
        let touchBarVolumeDownTemplateName: string;
        let touchBarVolumeUpTemplateName: string;
        let trashEmptyName: string;
        let trashFullName: string;
        let userName: string;
        let userAccountsName: string;
        let userGroupName: string;
        let userGuestName: string;
        type Name = String;
    }
    namespace NSImageRep {
        let ctm: string;
        let interpolation: string;
        let userInterfaceLayoutDirection: string;
        let registryDidChangeNotification: string;
    }
    namespace NSImageView {
        enum FrameStyle {
            None = 0,
            Photo = 1,
            GrayBezel = 2,
            Groove = 3,
            Button = 4
        }
    }
    namespace NSIndexSet {
        type Element = NSIndexSetIterator;
        type Iterator = NSIndexSetIterator;
    }
    namespace NSItemProvider {
        enum ErrorCode {
            UnknownError = -1,
            ItemUnavailableError = -1000,
            UnexpectedValueClassError = -1100,
            UnavailableCoercionError = -1200
        }
        let errorDomain: string;
    }
    namespace NSKeyValueChangeKey {
        let indexesKey: string;
        let kindKey: string;
        let newKey: string;
        let notificationIsPriorKey: string;
        let oldKey: string;
    }
    namespace NSKeyValueOperator {
        let averageKeyValueOperator: string;
        let countKeyValueOperator: string;
        let distinctUnionOfArraysKeyValueOperator: string;
        let distinctUnionOfObjectsKeyValueOperator: string;
        let distinctUnionOfSetsKeyValueOperator: string;
        let maximumKeyValueOperator: string;
        let minimumKeyValueOperator: string;
        let sumKeyValueOperator: string;
        let unionOfArraysKeyValueOperator: string;
        let unionOfObjectsKeyValueOperator: string;
        let unionOfSetsKeyValueOperator: string;
    }
    namespace NSLayoutConstraint {
        enum Attribute {
            Left = 1,
            Right = 2,
            Top = 3,
            Bottom = 4,
            Leading = 5,
            Trailing = 6,
            Width = 7,
            Height = 8,
            CenterX = 9,
            CenterY = 10,
            LastBaseline = 11,
            Baseline = 11,
            FirstBaseline = 12,
            NotAnAttribute = 0
        }
        enum Orientation {
            Horizontal = 0,
            Vertical = 1
        }
        enum FormatOptions {
            AlignAllLeft = 2,
            AlignAllRight = 4,
            AlignAllTop = 8,
            AlignAllBottom = 16,
            AlignAllLeading = 32,
            AlignAllTrailing = 64,
            AlignAllCenterX = 512,
            AlignAllCenterY = 1024,
            AlignAllLastBaseline = 2048,
            AlignAllFirstBaseline = 4096,
            AlignAllBaseline = 2048,
            AlignmentMask = 65535,
            DirectionLeadingToTrailing = 0,
            DirectionLeftToRight = 65536,
            DirectionRightToLeft = 131072,
            DirectionMask = 196608
        }
        enum Relation {
            LessThanOrEqual = -1,
            Equal = 0,
            GreaterThanOrEqual = 1
        }
        let defaultHigh: number;
        let defaultLow: number;
        let dragThatCanResizeWindow: number;
        let dragThatCannotResizeWindow: number;
        let fittingSizeCompression: number;
        let required: number;
        let windowSizeStayPut: number;
    }
    namespace NSLayoutManager {
        enum ControlCharacterAction {
            ZeroAdvancement = 1,
            Whitespace = 2,
            HorizontalTab = 4,
            LineBreak = 8,
            ParagraphBreak = 16,
            ContainerBreak = 32
        }
        enum GlyphProperty {
            Null = 1,
            ControlCharacter = 2,
            Elastic = 4,
            NonBaseCharacter = 8
        }
        enum TextLayoutOrientation {
            Horizontal = 0,
            Vertical = 1
        }
        enum TypesetterBehavior {
            LatestBehavior = -1,
            OriginalBehavior = 0,
            Behavior_10_2_WithCompatibility = 1,
            Behavior_10_2 = 2,
            Behavior_10_3 = 3,
            Behavior_10_4 = 4
        }
    }
    namespace NSLevelIndicator {
        enum PlaceholderVisibility {
            Automatic = 0,
            Always = 1,
            WhileEditing = 2
        }
        enum Style {
            Relevancy = 0,
            ContinuousCapacity = 1,
            DiscreteCapacity = 2,
            Rating = 3
        }
    }
    namespace NSLinguisticTag {
        let adjective: string;
        let adverb: string;
        let classifier: string;
        let closeParenthesis: string;
        let closeQuote: string;
        let conjunction: string;
        let dash: string;
        let determiner: string;
        let idiom: string;
        let interjection: string;
        let noun: string;
        let number: string;
        let openParenthesis: string;
        let openQuote: string;
        let organizationName: string;
        let other: string;
        let otherPunctuation: string;
        let otherWhitespace: string;
        let otherWord: string;
        let paragraphBreak: string;
        let particle: string;
        let personalName: string;
        let placeName: string;
        let preposition: string;
        let pronoun: string;
        let punctuation: string;
        let sentenceTerminator: string;
        let verb: string;
        let whitespace: string;
        let word: string;
        let wordJoiner: string;
    }
    namespace NSLinguisticTagScheme {
        let language: string;
        let lemma: string;
        let lexicalClass: string;
        let nameType: string;
        let nameTypeOrLexicalClass: string;
        let script: string;
        let tokenType: string;
    }
    namespace NSLinguisticTagger {
        enum Options {
            OmitWords = 1,
            OmitPunctuation = 2,
            OmitWhitespace = 4,
            OmitOther = 8,
            JoinNames = 16
        }
    }
    namespace NSLocale {
        enum LanguageDirection {
            Unknown = 0,
            LeftToRight = 1,
            RightToLeft = 2,
            TopToBottom = 3,
            BottomToTop = 4
        }
        let currentLocaleDidChangeNotification: string;
        let alternateQuotationBeginDelimiterKey: string;
        let alternateQuotationEndDelimiterKey: string;
        let calendar: string;
        let collationIdentifier: string;
        let collatorIdentifier: string;
        let countryCode: string;
        let currencyCode: string;
        let currencySymbol: string;
        let decimalSeparator: string;
        let exemplarCharacterSet: string;
        let groupingSeparator: string;
        let identifier: string;
        let languageCode: string;
        let measurementSystem: string;
        let quotationBeginDelimiterKey: string;
        let quotationEndDelimiterKey: string;
        let scriptCode: string;
        let usesMetricSystem: string;
        let variantCode: string;
    }
    namespace NSMachPort {
        enum Options {
            DeallocateNone = 0,
            DeallocateSendRight = 1,
            DeallocateReceiveRight = 2
        }
    }
    namespace NSManagedObject {
        type ObjectWillChangePublisher = ObservableObjectPublisher;
    }
    namespace NSMatrix {
        enum Mode {
            RadioModeMatrix = 0,
            HighlightModeMatrix = 1,
            ListModeMatrix = 2,
            TrackModeMatrix = 3
        }
    }
    namespace NSMediaLibraryBrowserController {
        enum Library {
            Audio = 1,
            Image = 2,
            Movie = 4
        }
    }
    namespace NSMenu {
        enum Properties {
            PropertyItemTitle = 1,
            PropertyItemAttributedTitle = 2,
            PropertyItemKeyEquivalent = 4,
            PropertyItemImage = 8,
            PropertyItemEnabled = 16,
            PropertyItemAccessibilityDescription = 32
        }
        let didAddItemNotification: string;
        let didBeginTrackingNotification: string;
        let didChangeItemNotification: string;
        let didEndTrackingNotification: string;
        let didRemoveItemNotification: string;
        let didSendActionNotification: string;
        let willSendActionNotification: string;
    }
    namespace NSMenuItem {
        let importFromDeviceIdentifier: string;
    }
    namespace NSNib {
        type Name = String;
    }
    namespace NSNotification {
        let AVAssetChapterMetadataGroupsDidChange: string;
        let AVAssetContainsFragmentsDidChange: string;
        let AVAssetDurationDidChange: string;
        let AVAssetMediaSelectionGroupsDidChange: string;
        let AVAssetTrackSegmentsDidChange: string;
        let AVAssetTrackTimeRangeDidChange: string;
        let AVAssetTrackTrackAssociationsDidChange: string;
        let AVAssetWasDefragmented: string;
        let AVAudioEngineConfigurationChange: string;
        let AVAudioUnitComponentTagsDidChange: string;
        let AVCaptureDeviceSubjectAreaDidChange: string;
        let AVCaptureDeviceWasConnected: string;
        let AVCaptureDeviceWasDisconnected: string;
        let AVCaptureInputPortFormatDescriptionDidChange: string;
        let AVCaptureSessionDidStartRunning: string;
        let AVCaptureSessionDidStopRunning: string;
        let AVCaptureSessionInterruptionEnded: string;
        let AVCaptureSessionRuntimeError: string;
        let AVCaptureSessionWasInterrupted: string;
        let AVFragmentedMovieContainsMovieFragmentsDidChange: string;
        let AVFragmentedMovieDurationDidChange: string;
        let AVFragmentedMovieTrackSegmentsDidChange: string;
        let AVFragmentedMovieTrackTimeRangeDidChange: string;
        let AVFragmentedMovieWasDefragmented: string;
        let AVPlayerAvailableHDRModesDidChange: string;
        let AVPlayerItemDidPlayToEndTime: string;
        let AVPlayerItemFailedToPlayToEndTime: string;
        let AVPlayerItemNewAccessLogEntry: string;
        let AVPlayerItemNewErrorLogEntry: string;
        let AVPlayerItemPlaybackStalled: string;
        let AVPlayerItemTimeJumped: string;
        let AVRouteDetectorMultipleRoutesDetectedDidChange: string;
        let AVSampleBufferAudioRendererWasFlushedAutomatically: string;
        let AVSampleBufferDisplayLayerFailedToDecode: string;
        let NSAppleEventManagerWillProcessFirstEvent: string;
        let NSBundleResourceRequestLowDiskSpace: string;
        let NSCalendarDayChanged: string;
        let NSClassDescriptionNeededForClass: string;
        let NSDidBecomeSingleThreaded: string;
        let NSExtensionHostDidBecomeActive: string;
        let NSExtensionHostDidEnterBackground: string;
        let NSExtensionHostWillEnterForeground: string;
        let NSExtensionHostWillResignActive: string;
        let NSFileHandleConnectionAccepted: string;
        let NSFileHandleDataAvailable: string;
        let NSFileHandleReadToEndOfFileCompletion: string;
        let NSHTTPCookieManagerAcceptPolicyChanged: string;
        let NSHTTPCookieManagerCookiesChanged: string;
        let NSMetadataQueryDidFinishGathering: string;
        let NSMetadataQueryDidStartGathering: string;
        let NSMetadataQueryDidUpdate: string;
        let NSMetadataQueryGatheringProgress: string;
        let NSProcessInfoPowerStateDidChange: string;
        let NSSystemClockDidChange: string;
        let NSSystemTimeZoneDidChange: string;
        let NSThreadWillExit: string;
        let NSURLCredentialStorageChanged: string;
        let NSUbiquityIdentityDidChange: string;
        let NSUndoManagerCheckpoint: string;
        let NSUndoManagerDidCloseUndoGroup: string;
        let NSUndoManagerDidOpenUndoGroup: string;
        let NSUndoManagerDidRedoChange: string;
        let NSUndoManagerDidUndoChange: string;
        let NSUndoManagerWillCloseUndoGroup: string;
        let NSUndoManagerWillRedoChange: string;
        let NSUndoManagerWillUndoChange: string;
        let NSWillBecomeMultiThreaded: string;
        let IKFilterBrowserFilterDoubleClick: string;
        let IKFilterBrowserFilterSelected: string;
        let IKFilterBrowserWillPreviewFilter: string;
        let quartzFilterManagerDidAddFilter: string;
        let quartzFilterManagerDidModifyFilter: string;
        let quartzFilterManagerDidRemoveFilter: string;
        let quartzFilterManagerDidSelectFilter: string;
    }
    namespace NSNumber {
        type BooleanLiteralType = boolean;
        type IntegerLiteralType = number;
        type FloatLiteralType = number;
    }
    namespace NSOrderedSet {
        type Iterator = NSFastEnumerationIterator;
    }
    namespace NSOutlineView {
        let columnDidMoveNotification: string;
        let columnDidResizeNotification: string;
        let disclosureButtonIdentifier: string;
        let itemDidCollapseNotification: string;
        let itemDidExpandNotification: string;
        let itemWillCollapseNotification: string;
        let itemWillExpandNotification: string;
        let selectionDidChangeNotification: string;
        let selectionIsChangingNotification: string;
        let showHideButtonIdentifier: string;
    }
    namespace NSPDFPanel {
        enum Options {
            ShowsPaperSize = 4,
            ShowsOrientation = 8,
            RequestsParentDirectory = 16777216
        }
    }
    namespace NSPageController {
        enum TransitionStyle {
            StackHistory = 0,
            StackBook = 1,
            HorizontalStrip = 2
        }
        type ObjectIdentifier = String;
    }
    namespace NSParagraphStyle {
        enum TextTabType {
            LeftTabStopType = 0,
            RightTabStopType = 1,
            CenterTabStopType = 2,
            DecimalTabStopType = 3
        }
        enum LineBreakStrategy {
            pushOut,
            hangulWordPriority,
            standard
        }
    }
    namespace NSPasteboard {
        enum ContentsOptions {
            CurrentHostOnly = 1
        }
        enum ReadingOptions {
            AsData = 0,
            AsString = 1,
            AsPropertyList = 2,
            AsKeyedArchive = 4
        }
        enum WritingOptions {
            Promised = 512
        }
        let fileContents: string;
        let findPanelSearchOptions: string;
        let drag: string;
        let find: string;
        let font: string;
        let general: string;
        let ruler: string;
        let color: string;
        let fileURL: string;
        let html: string;
        let multipleTextSelection: string;
        let pdf: string;
        let png: string;
        let rtf: string;
        let rtfd: string;
        let sound: string;
        let string: string;
        let tiff: string;
        let tabularText: string;
        let textFinderOptions: string;
        let URL: string;
        let urlReadingContentsConformToTypes: string;
        let urlReadingFileURLsOnly: string;
        let soundPboardType: string;
    }
    namespace NSPathControl {
        enum Style {
            Standard = 0,
            PopUp = 2,
            NavigationBar = 1
        }
    }
    namespace NSPickerTouchBarItem {
        enum ControlRepresentation {
            Automatic = 0,
            Expanded = 1,
            Collapsed = 2
        }
        enum SelectionMode {
            SelectOne = 0,
            SelectAny = 1,
            Momentary = 2
        }
    }
    namespace NSPointerFunctions {
        enum Options {
            StrongMemory = 0,
            ZeroingWeakMemory = 1,
            OpaqueMemory = 2,
            MallocMemory = 3,
            MachVirtualMemory = 4,
            WeakMemory = 5,
            ObjectPersonality = 0,
            OpaquePersonality = 256,
            ObjectPointerPersonality = 512,
            CStringPersonality = 768,
            StructPersonality = 1024,
            IntegerPersonality = 1280,
            CopyIn = 65536
        }
    }
    namespace NSPopUpButton {
        enum ArrowPosition {
            NoArrow = 0,
            ArrowAtCenter = 1,
            ArrowAtBottom = 2
        }
        let willPopUpNotification: string;
    }
    namespace NSPopUpButtonCell {
        let willPopUpNotification: string;
    }
    namespace NSPopover {
        enum Behavior {
            ApplicationDefined = 0,
            Transient = 1,
            Semitransient = 2
        }
        let detachToWindow: string;
        let closeReasonUserInfoKey: string;
        let standard: string;
        let didCloseNotification: string;
        let didShowNotification: string;
        let willCloseNotification: string;
        let willShowNotification: string;
    }
    namespace NSPositionalSpecifier {
        enum InsertionPosition {
            PositionAfter = 0,
            PositionBefore = 1,
            PositionBeginning = 2,
            PositionEnd = 3,
            PositionReplace = 4
        }
    }
    namespace NSPrintInfo {
        enum PaperOrientation {
            Portrait = 0,
            Landscape = 1
        }
        enum PaginationMode {
            Automatic = 0,
            Fit = 1,
            Clip = 2
        }
        let automatic: NSPrintInfo.PaginationMode;
        let clip: NSPrintInfo.PaginationMode;
        let fit: NSPrintInfo.PaginationMode;
        let allPages: string;
        let bottomMargin: string;
        let cancel: string;
        let copies: string;
        let detailedErrorReporting: string;
        let faxNumber: string;
        let firstPage: string;
        let headerAndFooter: string;
        let horizontalPagination: string;
        let horizontallyCentered: string;
        let jobDisposition: string;
        let jobSavingFileNameExtensionHidden: string;
        let jobSavingURL: string;
        let lastPage: string;
        let leftMargin: string;
        let mustCollate: string;
        let orientation: string;
        let pagesAcross: string;
        let pagesDown: string;
        let paperName: string;
        let paperSize: string;
        let preview: string;
        let printer: string;
        let printerName: string;
        let reversePageOrder: string;
        let rightMargin: string;
        let save: string;
        let scalingFactor: string;
        let selectionOnly: string;
        let spool: string;
        let time: string;
        let topMargin: string;
        let verticalPagination: string;
        let verticallyCentered: string;
        type SettingKey = String;
    }
    namespace NSPrintOperation {
        enum RenderingQuality {
            Best = 0,
            Responsive = 1
        }
        enum PageOrder {
            DescendingPageOrder = -1,
            SpecialPageOrder = 0,
            AscendingPageOrder = 1,
            UnknownPageOrder = 2
        }
    }
    namespace NSPrintPanel {
        enum Options {
            ShowsCopies = 1,
            ShowsPageRange = 2,
            ShowsPaperSize = 4,
            ShowsOrientation = 8,
            ShowsScaling = 16,
            ShowsPrintSelection = 32,
            ShowsPageSetupAccessory = 256,
            ShowsPreview = 131072
        }
        let allPresets: string;
        let noPresets: string;
        let itemDescription: string;
        let itemName: string;
        let photo: string;
    }
    namespace NSPrinter {
        enum TableStatus {
            OK = 0,
            NotFound = 1,
            Error = 2
        }
    }
    namespace NSProgressIndicator {
        enum Style {
            Bar = 0,
            Spinning = 1
        }
    }
    namespace NSRegularExpression {
        enum MatchingFlags {
            Progress = 1,
            Completed = 2,
            HitEnd = 4,
            RequiredEnd = 8,
            InternalError = 16
        }
        enum MatchingOptions {
            ReportProgress = 1,
            ReportCompletion = 2,
            Anchored = 4,
            WithTransparentBounds = 8,
            WithoutAnchoringBounds = 16
        }
        enum Options {
            CaseInsensitive = 1,
            AllowCommentsAndWhitespace = 2,
            IgnoreMetacharacters = 4,
            DotMatchesLineSeparators = 8,
            AnchorsMatchLines = 16,
            UseUnixLineSeparators = 32,
            UseUnicodeWordBoundaries = 64
        }
    }
    namespace NSRelativeSpecifier {
        enum RelativePosition {
            After = 0,
            Before = 1
        }
    }
    namespace NSRuleEditor {
        enum NestingMode {
            Single = 0,
            List = 1,
            Compound = 2,
            Simple = 3
        }
        enum RowType {
            Simple = 0,
            Compound = 1
        }
        let comparisonModifier: string;
        let compoundType: string;
        let customSelector: string;
        let leftExpression: string;
        let operatorType: string;
        let options: string;
        let rightExpression: string;
        let rowsDidChangeNotification: string;
    }
    namespace NSRulerView {
        enum Orientation {
            HorizontalRuler = 0,
            VerticalRuler = 1
        }
        let centimeters: string;
        let inches: string;
        let picas: string;
        let points: string;
    }
    namespace NSScreen {
        let colorSpaceDidChangeNotification: string;
    }
    namespace NSScrollView {
        enum Elasticity {
            Automatic = 0,
            None = 1,
            Allowed = 2
        }
        enum FindBarPosition {
            AboveHorizontalRuler = 0,
            AboveContent = 1,
            BelowContent = 2
        }
        let didEndLiveMagnifyNotification: string;
        let didEndLiveScrollNotification: string;
        let didLiveScrollNotification: string;
        let willStartLiveMagnifyNotification: string;
        let willStartLiveScrollNotification: string;
    }
    namespace NSScroller {
        enum KnobStyle {
            Default = 0,
            Dark = 1,
            Light = 2
        }
        enum Part {
            NoPart = 0,
            DecrementPage = 1,
            Knob = 2,
            IncrementPage = 3,
            DecrementLine = 4,
            IncrementLine = 5,
            KnobSlot = 6
        }
        enum Style {
            Legacy = 0,
            Overlay = 1
        }
        enum UsableParts {
            NoScrollerParts = 0,
            OnlyScrollerArrows = 1,
            AllScrollerParts = 2
        }
        let preferredScrollerStyleDidChangeNotification: string;
    }
    namespace NSScrubber {
        enum Alignment {
            None = 0,
            Leading = 1,
            Trailing = 2,
            Center = 3
        }
        enum Mode {
            Fixed = 0,
            Free = 1
        }
    }
    namespace NSSearchField {
        let clearRecentsMenuItemTag: number;
        let noRecentsMenuItemTag: number;
        let recentsMenuItemTag: number;
        let recentsTitleMenuItemTag: number;
        type RecentsAutosaveName = String;
    }
    namespace NSSegmentedControl {
        enum Distribution {
            Fit = 0,
            Fill = 1,
            FillEqually = 2,
            FillProportionally = 3
        }
        enum Style {
            Automatic = 0,
            Rounded = 1,
            RoundRect = 3,
            TexturedSquare = 4,
            SmallSquare = 6,
            Separated = 8,
            TexturedRounded = 2,
            Capsule = 5
        }
        enum SwitchTracking {
            SelectOne = 0,
            SelectAny = 1,
            Momentary = 2,
            MomentaryAccelerator = 3
        }
    }
    namespace NSSet {
        type Iterator = NSFastEnumerationIterator;
    }
    namespace NSSharingService {
        enum CloudKitOptions {
            Standard = 0,
            AllowPublic = 1,
            AllowPrivate = 2,
            AllowReadOnly = 16,
            AllowReadWrite = 32
        }
        enum SharingContentScope {
            Item = 0,
            Partial = 1,
            Full = 2
        }
        let addToAperture: string;
        let addToIPhoto: string;
        let addToSafariReadingList: string;
        let cloudSharing: string;
        let composeEmail: string;
        let composeMessage: string;
        let sendViaAirDrop: string;
        let useAsDesktopPicture: string;
    }
    namespace NSSlider {
        enum SliderType {
            Linear = 0,
            Circular = 1
        }
        enum TickMarkPosition {
            Below = 0,
            Above = 1,
            Leading = 1,
            Trailing = 0
        }
    }
    namespace NSSliderAccessory {
        let default_: number;
        let wide: number;
    }
    namespace NSSound {
        type Name = String;
        type PlaybackDeviceIdentifier = String;
    }
    namespace NSSpecifierTest {
        enum TestComparisonOperation {
            EqualToComparison = 0,
            LessThanOrEqualToComparison = 1,
            LessThanComparison = 2,
            GreaterThanOrEqualToComparison = 3,
            GreaterThanComparison = 4,
            BeginsWithComparison = 5,
            EndsWithComparison = 6,
            ContainsComparison = 7
        }
    }
    namespace NSSpeechSynthesizer {
        enum Boundary {
            ImmediateBoundary = 0,
            WordBoundary = 1,
            SentenceBoundary = 2
        }
        let characterMode: string;
        let commandDelimiter: string;
        let currentVoice: string;
        let abbreviations: string;
        let entryPhonemes: string;
        let entrySpelling: string;
        let localeIdentifier: string;
        let modificationDate: string;
        let pronunciations: string;
        let errors: string;
        let inputMode: string;
        let numberMode: string;
        let outputToFileURL: string;
        let phonemeSymbols: string;
        let pitchBase: string;
        let pitchMod: string;
        let rate: string;
        let recentSync: string;
        let reset: string;
        let status: string;
        let synthesizerInfo: string;
        let volume: string;
        let age: string;
        let demoText: string;
        let gender: string;
        let female: string;
        let male: string;
        let neuter: string;
        let identifier: string;
        let individuallySpokenCharacters: string;
        let name: string;
        let supportedCharacters: string;
    }
    namespace NSSpellChecker {
        enum CorrectionIndicatorType {
            Default = 0,
            Reversion = 1,
            Guesses = 2
        }
        enum CorrectionResponse {
            None = 0,
            Accepted = 1,
            Rejected = 2,
            Ignored = 3,
            Edited = 4,
            Reverted = 5
        }
        let didChangeAutomaticCapitalizationNotification: string;
        let didChangeAutomaticDashSubstitutionNotification: string;
        let didChangeAutomaticPeriodSubstitutionNotification: string;
        let didChangeAutomaticQuoteSubstitutionNotification: string;
        let didChangeAutomaticSpellingCorrectionNotification: string;
        let didChangeAutomaticTextCompletionNotification: string;
        let didChangeAutomaticTextReplacementNotification: string;
        let documentAuthor: string;
        let documentTitle: string;
        let documentURL: string;
        let orthography: string;
        let quotes: string;
        let referenceDate: string;
        let referenceTimeZone: string;
        let regularExpressions: string;
        let replacements: string;
        let selectedRange: string;
    }
    namespace NSSplitView {
        enum DividerStyle {
            Thick = 1,
            Thin = 2,
            PaneSplitter = 3
        }
        let didResizeSubviewsNotification: string;
        let willResizeSubviewsNotification: string;
        type AutosaveName = String;
    }
    namespace NSSplitViewController {
        let automaticDimension: number;
    }
    namespace NSSplitViewItem {
        enum Behavior {
            Default = 0,
            Sidebar = 1,
            ContentList = 2
        }
        enum CollapseBehavior {
            Default = 0,
            PreferResizingSplitViewWithFixedSiblings = 1,
            PreferResizingSiblingsWithFixedSplitView = 2,
            UseConstraints = 3
        }
        let unspecifiedDimension: number;
    }
    namespace NSStackView {
        enum Distribution {
            GravityAreas = -1,
            Fill = 0,
            FillEqually = 1,
            FillProportionally = 2,
            EqualSpacing = 3,
            EqualCentering = 4
        }
        enum Gravity {
            Top = 1,
            Leading = 1,
            Center = 2,
            Bottom = 3,
            Trailing = 3
        }
        let useDefaultSpacing: number;
        let detachOnlyIfNecessary: number;
        let mustHold: number;
        let notVisible: number;
    }
    namespace NSStatusItem {
        enum Behavior {
            RemovalAllowed = 2,
            TerminationOnRemoval = 4
        }
        let squareLength: number;
        let variableLength: number;
        type AutosaveName = String;
    }
    namespace NSStoryboard {
        type Name = String;
        type SceneIdentifier = String;
    }
    namespace NSStoryboardSegue {
        type Identifier = String;
    }
    namespace NSString {
        enum DrawingOptions {
            UsesLineFragmentOrigin = 1,
            UsesFontLeading = 2,
            UsesDeviceMetrics = 8,
            TruncatesLastVisibleLine = 32,
            DisableScreenFontSubstitution = 4,
            OneShot = 16
        }
        enum CompareOptions {
            CaseInsensitiveSearch = 1,
            LiteralSearch = 2,
            BackwardsSearch = 4,
            AnchoredSearch = 8,
            NumericSearch = 64,
            DiacriticInsensitiveSearch = 128,
            WidthInsensitiveSearch = 256,
            ForcedOrderingSearch = 512,
            RegularExpressionSearch = 1024
        }
        enum EncodingConversionOptions {
            AllowLossy = 1,
            ExternalRepresentation = 2
        }
        enum EnumerationOptions {
            ByLines = 0,
            ByParagraphs = 1,
            ByComposedCharacterSequences = 2,
            ByWords = 3,
            BySentences = 4,
            Reverse = 256,
            SubstringNotRequired = 512,
            Localized = 1024
        }
        type StringLiteralType = string;
        type ExtendedGraphemeClusterLiteralType = string;
        type UnicodeScalarLiteralType = string;
    }
    namespace NSTabView {
        enum TabPosition {
            None = 0,
            Top = 1,
            Left = 2,
            Bottom = 3,
            Right = 4
        }
        enum TabViewBorderType {
            None = 0,
            Line = 1,
            Bezel = 2
        }
        enum TabType {
            TopTabsBezelBorder = 0,
            LeftTabsBezelBorder = 1,
            BottomTabsBezelBorder = 2,
            RightTabsBezelBorder = 3,
            NoTabsBezelBorder = 4,
            NoTabsLineBorder = 5,
            NoTabsNoBorder = 6
        }
    }
    namespace NSTabViewController {
        enum TabStyle {
            SegmentedControlOnTop = 0,
            SegmentedControlOnBottom = 1,
            Toolbar = 2,
            Unspecified = -1
        }
    }
    namespace NSTabViewItem {
        enum State {
            SelectedTab = 0,
            BackgroundTab = 1,
            PressedTab = 2
        }
    }
    namespace NSTableColumn {
        enum ResizingOptions {
            NoResizing = 0,
            AutoresizingMask = 1,
            UserResizingMask = 2
        }
    }
    namespace NSTableView {
        enum RowActionEdge {
            Leading = 0,
            Trailing = 1
        }
        enum AnimationOptions {
            EffectNone = 0,
            EffectFade = 1,
            EffectGap = 2,
            SlideUp = 16,
            SlideDown = 32,
            SlideLeft = 48,
            SlideRight = 64
        }
        enum ColumnAutoresizingStyle {
            NoColumnAutoresizing = 0,
            UniformColumnAutoresizingStyle = 1,
            SequentialColumnAutoresizingStyle = 2,
            ReverseSequentialColumnAutoresizingStyle = 3,
            LastColumnOnlyAutoresizingStyle = 4,
            FirstColumnOnlyAutoresizingStyle = 5
        }
        enum DraggingDestinationFeedbackStyle {
            None = -1,
            Regular = 0,
            SourceList = 1,
            Gap = 2
        }
        enum DropOperation {
            On = 0,
            Above = 1
        }
        enum GridLineStyle {
            GridNone = 0,
            SolidVerticalGridLineMask = 1,
            SolidHorizontalGridLineMask = 2,
            DashedHorizontalGridLineMask = 8
        }
        enum RowSizeStyle {
            Default = -1,
            Custom = 0,
            Small = 1,
            Medium = 2,
            Large = 3
        }
        enum SelectionHighlightStyle {
            None = -1,
            Regular = 0,
            SourceList = 1
        }
        let columnDidMoveNotification: string;
        let columnDidResizeNotification: string;
        let rowViewIdentifier: string;
        let selectionDidChangeNotification: string;
        let selectionIsChangingNotification: string;
        type AutosaveName = String;
    }
    namespace NSTableViewRowAction {
        enum Style {
            Regular = 0,
            Destructive = 1
        }
    }
    namespace NSText {
        let didBeginEditingNotification: string;
        let didChangeNotification: string;
        let didEndEditingNotification: string;
        let movementUserInfoKey: string;
    }
    namespace NSTextAlternatives {
        let selectedAlternativeStringNotification: string;
    }
    namespace NSTextBlock {
        enum Dimension {
            Width = 0,
            MinimumWidth = 1,
            MaximumWidth = 2,
            Height = 4,
            MinimumHeight = 5,
            MaximumHeight = 6
        }
        enum Layer {
            Padding = -1,
            Border = 0,
            Margin = 1
        }
        enum ValueType {
            AbsoluteValueType = 0,
            PercentageValueType = 1
        }
        enum VerticalAlignment {
            TopAlignment = 0,
            MiddleAlignment = 1,
            BottomAlignment = 2,
            BaselineAlignment = 3
        }
    }
    namespace NSTextCheckingKey {
        let airline: string;
        let city: string;
        let country: string;
        let flight: string;
        let jobTitle: string;
        let name: string;
        let organization: string;
        let phone: string;
        let state: string;
        let street: string;
        let zip: string;
    }
    namespace NSTextCheckingResult {
        enum CheckingType {
            Orthography = 1,
            Spelling = 2,
            Grammar = 4,
            Date = 8,
            Address = 16,
            Link = 32,
            Quote = 64,
            Dash = 128,
            Replacement = 256,
            Correction = 512,
            RegularExpression = 1024,
            PhoneNumber = 2048,
            TransitInformation = 4096
        }
    }
    namespace NSTextField {
        enum BezelStyle {
            SquareBezel = 0,
            RoundedBezel = 1
        }
    }
    namespace NSTextFinder {
        enum Action {
            ShowFindInterface = 1,
            NextMatch = 2,
            PreviousMatch = 3,
            ReplaceAll = 4,
            Replace = 5,
            ReplaceAndFind = 6,
            SetSearchString = 7,
            ReplaceAllInSelection = 8,
            SelectAll = 9,
            SelectAllInSelection = 10,
            HideFindInterface = 11,
            ShowReplaceInterface = 12,
            HideReplaceInterface = 13
        }
        enum MatchingType {
            Contains = 0,
            StartsWith = 1,
            FullWord = 2,
            EndsWith = 3
        }
    }
    namespace NSTextInputContext {
        let keyboardSelectionDidChangeNotification: string;
    }
    namespace NSTextList {
        enum Options {
            PrependEnclosingMarker = 1
        }
        let box: string;
        let check: string;
        let circle: string;
        let decimal: string;
        let diamond: string;
        let disc: string;
        let hyphen: string;
        let lowercaseAlpha: string;
        let lowercaseHexadecimal: string;
        let lowercaseLatin: string;
        let lowercaseRoman: string;
        let octal: string;
        let square: string;
        let uppercaseAlpha: string;
        let uppercaseHexadecimal: string;
        let uppercaseLatin: string;
        let uppercaseRoman: string;
    }
    namespace NSTextStorage {
        let didProcessEditingNotification: string;
        let willProcessEditingNotification: string;
    }
    namespace NSTextTab {
        let columnTerminators: string;
    }
    namespace NSTextTable {
        enum LayoutAlgorithm {
            AutomaticLayoutAlgorithm = 0,
            FixedLayoutAlgorithm = 1
        }
    }
    namespace NSTextView {
        let didChangeSelectionNotification: string;
        let didChangeTypingAttributesNotification: string;
        let willChangeNotifyingTextViewNotification: string;
    }
    namespace NSTimeZone {
        enum NameStyle {
            Standard = 0,
            ShortStandard = 1,
            DaylightSaving = 2,
            ShortDaylightSaving = 3,
            Generic = 4,
            ShortGeneric = 5
        }
    }
    namespace NSTokenField {
        enum TokenStyle {
            Default = 0,
            None = 1,
            Rounded = 2,
            Squared = 3,
            PlainSquared = 4
        }
    }
    namespace NSToolbar {
        enum DisplayMode {
            Default = 0,
            IconAndLabel = 1,
            IconOnly = 2,
            LabelOnly = 3
        }
        enum SizeMode {
            Default = 0,
            Regular = 1,
            Small = 2
        }
        let didRemoveItemNotification: string;
        let willAddItemNotification: string;
        type Identifier = String;
    }
    namespace NSToolbarItem {
        let cloudSharing: string;
        let customizeToolbar: string;
        let flexibleSpace: string;
        let high: number;
        let low: number;
        let standard: number;
        let user: number;
        let print: string;
        let separator: string;
        let showColors: string;
        let showFonts: string;
        let space: string;
        let toggleSidebar: string;
    }
    namespace NSToolbarItemGroup {
        enum ControlRepresentation {
            Automatic = 0,
            Expanded = 1,
            Collapsed = 2
        }
        enum SelectionMode {
            SelectOne = 0,
            SelectAny = 1,
            Momentary = 2
        }
    }
    namespace NSTouch {
        enum Phase {
            Began = 1,
            Moved = 2,
            Stationary = 4,
            Ended = 8,
            Cancelled = 16,
            Touching = 7,
            Any = -1
        }
        enum TouchType {
            Direct = 0,
            Indirect = 1
        }
        enum TouchTypeMask {
            Direct = 1,
            Indirect = 2
        }
    }
    namespace NSTouchBar {
        type CustomizationIdentifier = String;
    }
    namespace NSTouchBarItem {
        let candidateList: string;
        let characterPicker: string;
        let fixedSpaceLarge: string;
        let fixedSpaceSmall: string;
        let flexibleSpace: string;
        let otherItemsProxy: string;
        let textAlignment: string;
        let textColorPicker: string;
        let textFormat: string;
        let textList: string;
        let textStyle: string;
        let high: number;
        let low: number;
        let normal: number;
    }
    namespace NSTrackingArea {
        enum Options {
            MouseEnteredAndExited = 1,
            MouseMoved = 2,
            CursorUpdate = 4,
            ActiveWhenFirstResponder = 16,
            ActiveInKeyWindow = 32,
            ActiveInActiveApp = 64,
            ActiveAlways = 128,
            AssumeInside = 256,
            InVisibleRect = 512,
            EnabledDuringMouseDrag = 1024
        }
    }
    namespace NSURL {
        enum BookmarkCreationOptions {
            PreferFileIDResolution = 256,
            MinimalBookmark = 512,
            SuitableForBookmarkFile = 1024,
            WithSecurityScope = 2048,
            SecurityScopeAllowOnlyReadAccess = 4096
        }
        enum BookmarkResolutionOptions {
            WithoutUI = 256,
            WithoutMounting = 512,
            WithSecurityScope = 1024
        }
        type BookmarkFileCreationOptions = number;
    }
    namespace NSURLHandle {
        enum Status {
            NotLoaded = 0,
            LoadSucceeded = 1,
            LoadInProgress = 2,
            LoadFailed = 3
        }
    }
    namespace NSURLRequest {
        enum CachePolicy {
            UseProtocolCachePolicy = 0,
            ReloadIgnoringLocalCacheData = 1,
            ReloadIgnoringLocalAndRemoteCacheData = 4,
            ReloadIgnoringCacheData = 1,
            ReturnCacheDataElseLoad = 2,
            ReturnCacheDataDontLoad = 3,
            ReloadRevalidatingCacheData = 5
        }
        enum NetworkServiceType {
            NetworkServiceTypeDefault = 0,
            NetworkServiceTypeVoIP = 1,
            NetworkServiceTypeVideo = 2,
            NetworkServiceTypeBackground = 3,
            NetworkServiceTypeVoice = 4,
            NetworkServiceTypeResponsiveData = 6,
            NetworkServiceTypeAVStreaming = 8,
            NetworkServiceTypeResponsiveAV = 9,
            NetworkServiceTypeCallSignaling = 11
        }
    }
    namespace NSUbiquitousKeyValueStore {
        let didChangeExternallyNotification: string;
    }
    namespace NSUserNotification {
        enum ActivationType {
            None = 0,
            ContentsClicked = 1,
            ActionButtonClicked = 2,
            Replied = 3,
            AdditionalActionClicked = 4
        }
    }
    namespace NSValueTransformerName {
        let isNilTransformerName: string;
        let isNotNilTransformerName: string;
        let negateBooleanTransformerName: string;
        let secureUnarchiveFromDataTransformerName: string;
    }
    namespace NSView {
        enum AutoresizingMask {
            ViewNotSizable = 0,
            ViewMinXMargin = 1,
            ViewWidthSizable = 2,
            ViewMaxXMargin = 4,
            ViewMinYMargin = 8,
            ViewHeightSizable = 16,
            ViewMaxYMargin = 32
        }
        enum BackgroundStyle {
            Normal = 0,
            Emphasized = 1,
            Raised = 2,
            Lowered = 3
        }
        enum LayerContentsPlacement {
            ScaleAxesIndependently = 0,
            ScaleProportionallyToFit = 1,
            ScaleProportionallyToFill = 2,
            Center = 3,
            Top = 4,
            TopRight = 5,
            Right = 6,
            BottomRight = 7,
            Bottom = 8,
            BottomLeft = 9,
            Left = 10,
            TopLeft = 11
        }
        enum LayerContentsRedrawPolicy {
            Never = 0,
            OnSetNeedsDisplay = 1,
            DuringViewResize = 2,
            BeforeViewResize = 3,
            Crossfade = 4
        }
        let emphasized: NSView.BackgroundStyle;
        let normal: NSView.BackgroundStyle;
        let dictionaryApplication: string;
        let presentationType: string;
        let overlay: string;
        let fullScreenModeAllScreens: string;
        let fullScreenModeApplicationPresentationOptions: string;
        let fullScreenModeSetting: string;
        let fullScreenModeWindowLevel: string;
        let boundsDidChangeNotification: string;
        let didUpdateTrackingAreasNotification: string;
        let frameDidChangeNotification: string;
        let noIntrinsicMetric: number;
        type TrackingRectTag = number;
        type ToolTipTag = number;
    }
    namespace NSViewAnimation {
        let effect: string;
        let endFrame: string;
        let fadeIn: string;
        let fadeOut: string;
        let startFrame: string;
        let target: string;
    }
    namespace NSViewController {
        enum TransitionOptions {
            None = 0,
            Crossfade = 1,
            SlideUp = 16,
            SlideDown = 32,
            SlideLeft = 64,
            SlideRight = 128,
            SlideForward = 320,
            SlideBackward = 384,
            AllowUserInteraction = 4096
        }
    }
    namespace NSVisualEffectView {
        enum BlendingMode {
            BehindWindow = 0,
            WithinWindow = 1
        }
        enum Material {
            Titlebar = 3,
            Selection = 4,
            Menu = 5,
            Popover = 6,
            Sidebar = 7,
            HeaderView = 10,
            Sheet = 11,
            WindowBackground = 12,
            HUDWindow = 13,
            FullScreenUI = 15,
            ToolTip = 17,
            ContentBackground = 18,
            UnderWindowBackground = 21,
            UnderPageBackground = 22,
            AppearanceBased = 0,
            Light = 1,
            Dark = 2,
            MediumLight = 8,
            UltraDark = 9
        }
        enum State {
            FollowsWindowActiveState = 0,
            Active = 1,
            Inactive = 2
        }
    }
    namespace NSWhoseSpecifier {
        enum SubelementIdentifier {
            IndexSubelement = 0,
            EverySubelement = 1,
            MiddleSubelement = 2,
            RandomSubelement = 3,
            NoSubelement = 4
        }
    }
    namespace NSWindow {
        enum BackingStoreType {
            Retained = 0,
            Nonretained = 1,
            Buffered = 2
        }
        enum SelectionDirection {
            DirectSelection = 0,
            SelectingNext = 1,
            SelectingPrevious = 2
        }
        enum AnimationBehavior {
            Default = 0,
            None = 2,
            DocumentWindow = 3,
            UtilityWindow = 4,
            AlertPanel = 5
        }
        enum ButtonType {
            CloseButton = 0,
            MiniaturizeButton = 1,
            ZoomButton = 2,
            ToolbarButton = 3,
            DocumentIconButton = 4,
            DocumentVersionsButton = 6
        }
        enum CollectionBehavior {
            Default = 0,
            CanJoinAllSpaces = 1,
            MoveToActiveSpace = 2,
            Managed = 4,
            Transient = 8,
            Stationary = 16,
            ParticipatesInCycle = 32,
            IgnoresCycle = 64,
            FullScreenPrimary = 128,
            FullScreenAuxiliary = 256,
            FullScreenNone = 512,
            FullScreenAllowsTiling = 2048,
            FullScreenDisallowsTiling = 4096
        }
        enum Depth {
            TwentyfourBitRGB = 520,
            SixtyfourBitRGB = 528,
            OnehundredtwentyeightBitRGB = 544
        }
        enum NumberListOptions {
            AllApplications = 1,
            AllSpaces = 16
        }
        enum OcclusionState {
            Visible = 2
        }
        enum OrderingMode {
            Above = 1,
            Below = -1,
            Out = 0
        }
        enum SharingType {
            None = 0,
            ReadOnly = 1,
            ReadWrite = 2
        }
        enum StyleMask {
            Borderless = 0,
            Titled = 1,
            Closable = 2,
            Miniaturizable = 4,
            Resizable = 8,
            TexturedBackground = 256,
            UnifiedTitleAndToolbar = 4096,
            FullScreen = 16384,
            FullSizeContentView = 32768,
            UtilityWindow = 16,
            DocModalWindow = 64,
            NonactivatingPanel = 128,
            HUDWindow = 8192
        }
        enum TabbingMode {
            Automatic = 0,
            Preferred = 1,
            Disallowed = 2
        }
        enum TitleVisibility {
            Visible = 0,
            Hidden = 1
        }
        enum UserTabbingPreference {
            Manual = 0,
            Always = 1,
            InFullScreen = 2
        }
        let oldColorSpaceUserInfoKey: string;
        let oldScaleFactorUserInfoKey: string;
        let floating: number;
        let mainMenu: number;
        let modalPanel: number;
        let normal: number;
        let popUpMenu: number;
        let screenSaver: number;
        let statusBar: number;
        let submenu: number;
        let tornOffMenu: number;
        let didBecomeKeyNotification: string;
        let didBecomeMainNotification: string;
        let didChangeBackingPropertiesNotification: string;
        let didChangeOcclusionStateNotification: string;
        let didChangeScreenNotification: string;
        let didChangeScreenProfileNotification: string;
        let didDeminiaturizeNotification: string;
        let didEndLiveResizeNotification: string;
        let didEndSheetNotification: string;
        let didEnterFullScreenNotification: string;
        let didEnterVersionBrowserNotification: string;
        let didExitFullScreenNotification: string;
        let didExitVersionBrowserNotification: string;
        let didExposeNotification: string;
        let didMiniaturizeNotification: string;
        let didMoveNotification: string;
        let didResignKeyNotification: string;
        let didResignMainNotification: string;
        let didResizeNotification: string;
        let didUpdateNotification: string;
        let willBeginSheetNotification: string;
        let willCloseNotification: string;
        let willEnterFullScreenNotification: string;
        let willEnterVersionBrowserNotification: string;
        let willExitFullScreenNotification: string;
        let willExitVersionBrowserNotification: string;
        let willMiniaturizeNotification: string;
        let willMoveNotification: string;
        let willStartLiveResizeNotification: string;
        type FrameAutosaveName = String;
        type PersistableFrameDescriptor = String;
        type TabbingIdentifier = String;
    }
    namespace NSWorkspace {
        enum AuthorizationType {
            CreateSymbolicLink = 0,
            SetAttributes = 1,
            ReplaceFile = 2
        }
        enum IconCreationOptions {
            ExcludeQuickDrawElementsIconCreationOption = 2,
            Exclude10_4ElementsIconCreationOption = 4
        }
        enum LaunchOptions {
            AndPrint = 2,
            WithErrorPresentation = 64,
            InhibitingBackgroundOnly = 128,
            WithoutAddingToRecents = 256,
            WithoutActivation = 512,
            Async = 65536,
            NewInstance = 524288,
            AndHide = 1048576,
            AndHideOthers = 2097152,
            Default = 65536,
            AllowingClassicStartup = 131072,
            PreferringClassic = 262144
        }
        let accessibilityDisplayOptionsDidChangeNotification: string;
        let activeSpaceDidChangeNotification: string;
        let applicationUserInfoKey: string;
        let allowClipping: string;
        let fillColor: string;
        let imageScaling: string;
        let didActivateApplicationNotification: string;
        let didChangeFileLabelsNotification: string;
        let didDeactivateApplicationNotification: string;
        let didHideApplicationNotification: string;
        let didLaunchApplicationNotification: string;
        let didMountNotification: string;
        let didRenameVolumeNotification: string;
        let didTerminateApplicationNotification: string;
        let didUnhideApplicationNotification: string;
        let didUnmountNotification: string;
        let didWakeNotification: string;
        let appleEvent: string;
        let architecture: string;
        let arguments_: string;
        let environment: string;
        let screensDidSleepNotification: string;
        let screensDidWakeNotification: string;
        let sessionDidBecomeActiveNotification: string;
        let sessionDidResignActiveNotification: string;
        let localizedVolumeNameUserInfoKey: string;
        let oldLocalizedVolumeNameUserInfoKey: string;
        let oldVolumeURLUserInfoKey: string;
        let volumeURLUserInfoKey: string;
        let willLaunchApplicationNotification: string;
        let willPowerOffNotification: string;
        let willSleepNotification: string;
        let willUnmountNotification: string;
    }
    namespace NSXPCConnection {
        enum Options {
            Privileged = 4096
        }
    }
    namespace NetService {
        enum Options {
            noAutoRename,
            listenForConnections,
            center,
            name,
            object
        }
    }
    namespace NotificationQueue {
        enum NotificationCoalescing {
            NoCoalescing = 0,
            CoalescingOnName = 1,
            CoalescingOnSender = 2
        }
        enum PostingStyle {
            WhenIdle = 1,
            ASAP = 2,
            Now = 3
        }
    }
    namespace NumberFormatter {
        enum Behavior {
            BehaviorDefault = 0,
            Behavior10_0 = 1000,
            Behavior10_4 = 1040
        }
        enum PadPosition {
            BeforePrefix = 0,
            AfterPrefix = 1,
            BeforeSuffix = 2,
            AfterSuffix = 3
        }
        enum RoundingMode {
            Ceiling = 0,
            Floor = 1,
            Down = 2,
            Up = 3,
            HalfEven = 4,
            HalfDown = 5,
            HalfUp = 6
        }
        enum Style {
            NoStyle = 0,
            DecimalStyle = 1,
            CurrencyStyle = 2,
            PercentStyle = 3,
            ScientificStyle = 4,
            SpellOutStyle = 5,
            OrdinalStyle = 6,
            CurrencyISOCodeStyle = 8,
            CurrencyPluralStyle = 9,
            CurrencyAccountingStyle = 10
        }
    }
    namespace Operation {
        enum QueuePriority {
            VeryLow = -8,
            Low = -4,
            Normal = 0,
            High = 4,
            VeryHigh = 8
        }
    }
    namespace OperationQueue {
        let defaultMaxConcurrentOperationCount: number;
    }
    namespace PersonNameComponentsFormatter {
        enum Options {
            Phonetic = 2
        }
        enum Style {
            Default = 0,
            Short = 1,
            Medium = 2,
            Long = 3,
            Abbreviated = 4
        }
    }
    namespace Port {
        let didBecomeInvalidNotification: string;
    }
    namespace Process {
        enum TerminationReason {
            Exit = 1,
            UncaughtSignal = 2
        }
        let didTerminateNotification: string;
    }
    namespace ProcessInfo {
        enum ActivityOptions {
            IdleDisplaySleepDisabled = 1099511627776,
            IdleSystemSleepDisabled = 1048576,
            SuddenTerminationDisabled = 16384,
            AutomaticTerminationDisabled = 32768,
            UserInitiated = 16777215,
            UserInitiatedAllowingIdleSystemSleep = 15728639,
            Background = 255,
            LatencyCritical = 1095216660480
        }
        enum ThermalState {
            Nominal = 0,
            Fair = 1,
            Serious = 2,
            Critical = 3
        }
        let thermalStateDidChangeNotification: string;
    }
    namespace Progress {
        let copying: string;
        let decompressingAfterDownloading: string;
        let downloading: string;
        let receiving: string;
    }
    namespace ProgressKind {
        let file: string;
    }
    namespace ProgressUserInfoKey {
        let estimatedTimeRemainingKey: string;
        let fileAnimationImageKey: string;
        let fileAnimationImageOriginalRectKey: string;
        let fileCompletedCountKey: string;
        let fileIconKey: string;
        let fileOperationKindKey: string;
        let fileTotalCountKey: string;
        let fileURLKey: string;
        let throughputKey: string;
    }
    namespace PropertyListSerialization {
        enum PropertyListFormat {
            OpenStepFormat = 1,
            XMLFormat_v1_0 = 100,
            BinaryFormat_v1_0 = 200
        }
        enum MutabilityOptions {
            Immutable = 0,
            MutableContainers = 1,
            MutableContainersAndLeaves = 2
        }
        type ReadOptions = PropertyListSerialization;
        type WriteOptions = number;
    }
    namespace RelativeDateTimeFormatter {
        enum DateTimeStyle {
            Numeric = 0,
            Named = 1
        }
        enum UnitsStyle {
            Full = 0,
            SpellOut = 1,
            Short = 2,
            Abbreviated = 3
        }
    }
    namespace RunLoop {
        let eventTracking: string;
        let modalPanel: string;
        let default_: string;
        let common: string;
    }
    namespace Stream {
        enum Event {
            None = 0,
            OpenCompleted = 1,
            HasBytesAvailable = 2,
            HasSpaceAvailable = 4,
            ErrorOccurred = 8,
            EndEncountered = 16
        }
        enum Status {
            NotOpen = 0,
            Opening = 1,
            Open = 2,
            Reading = 3,
            Writing = 4,
            AtEnd = 5,
            Closed = 6,
            Error = 7
        }
        let dataWrittenToMemoryStreamKey: string;
        let fileCurrentOffsetKey: string;
        let networkServiceType: string;
        let socksProxyConfigurationKey: string;
        let socketSecurityLevelKey: string;
    }
    namespace StreamNetworkServiceTypeValue {
        let background: string;
        let callSignaling: string;
        let video: string;
        let voIP: string;
        let voice: string;
    }
    namespace StreamSOCKSProxyConfiguration {
        let hostKey: string;
        let passwordKey: string;
        let portKey: string;
        let userKey: string;
        let versionKey: string;
    }
    namespace StreamSOCKSProxyVersion {
        let version4: string;
        let version5: string;
    }
    namespace StreamSocketSecurityLevel {
        let negotiatedSSL: string;
        let none: string;
        let ssLv2: string;
        let ssLv3: string;
        let tlSv1: string;
    }
    namespace StringEncodingDetectionOptionsKey {
        let allowLossyKey: string;
        let disallowedEncodingsKey: string;
        let fromWindowsKey: string;
        let likelyLanguageKey: string;
        let lossySubstitutionKey: string;
        let suggestedEncodingsKey: string;
        let useOnlySuggestedEncodingsKey: string;
    }
    namespace StringTransform {
        let fullwidthToHalfwidth: string;
        let hiraganaToKatakana: string;
        let latinToArabic: string;
        let latinToCyrillic: string;
        let latinToGreek: string;
        let latinToHangul: string;
        let latinToHebrew: string;
        let latinToHiragana: string;
        let latinToKatakana: string;
        let latinToThai: string;
        let mandarinToLatin: string;
        let stripCombiningMarks: string;
        let stripDiacritics: string;
        let toLatin: string;
        let toUnicodeName: string;
        let toXMLHex: string;
    }
    namespace SystemPressureState {
        enum Factors {
            systemTemperature,
            peakPower,
            depthModuleTemperature
        }
    }
    namespace URLCache {
        enum StoragePolicy {
            Allowed = 0,
            AllowedInMemoryOnly = 1,
            NotAllowed = 2
        }
    }
    namespace URLCredential {
        enum Persistence {
            None = 0,
            ForSession = 1,
            Permanent = 2,
            Synchronizable = 3
        }
    }
    namespace URLFileProtection {
        let complete: string;
        let completeUnlessOpen: string;
        let completeUntilFirstUserAuthentication: string;
        let none: string;
    }
    namespace URLFileResourceType {
        let blockSpecial: string;
        let characterSpecial: string;
        let directory: string;
        let namedPipe: string;
        let regular: string;
        let socket: string;
        let symbolicLink: string;
        let unknown: string;
    }
    namespace URLResourceKey {
        let addedToDirectoryDateKey: string;
        let applicationIsScriptableKey: string;
        let attributeModificationDateKey: string;
        let canonicalPathKey: string;
        let contentAccessDateKey: string;
        let contentModificationDateKey: string;
        let creationDateKey: string;
        let customIconKey: string;
        let documentIdentifierKey: string;
        let effectiveIconKey: string;
        let fileAllocatedSizeKey: string;
        let fileProtectionKey: string;
        let fileResourceIdentifierKey: string;
        let fileResourceTypeKey: string;
        let fileSecurityKey: string;
        let fileSizeKey: string;
        let generationIdentifierKey: string;
        let hasHiddenExtensionKey: string;
        let isAliasFileKey: string;
        let isApplicationKey: string;
        let isDirectoryKey: string;
        let isExcludedFromBackupKey: string;
        let isExecutableKey: string;
        let isHiddenKey: string;
        let isMountTriggerKey: string;
        let isPackageKey: string;
        let isReadableKey: string;
        let isRegularFileKey: string;
        let isSymbolicLinkKey: string;
        let isSystemImmutableKey: string;
        let isUbiquitousItemKey: string;
        let isUserImmutableKey: string;
        let isVolumeKey: string;
        let isWritableKey: string;
        let keysOfUnsetValuesKey: string;
        let labelColorKey: string;
        let labelNumberKey: string;
        let linkCountKey: string;
        let localizedLabelKey: string;
        let localizedNameKey: string;
        let localizedTypeDescriptionKey: string;
        let nameKey: string;
        let parentDirectoryURLKey: string;
        let pathKey: string;
        let preferredIOBlockSizeKey: string;
        let quarantinePropertiesKey: string;
        let tagNamesKey: string;
        let thumbnailDictionaryKey: string;
        let thumbnailKey: string;
        let totalFileAllocatedSizeKey: string;
        let totalFileSizeKey: string;
        let typeIdentifierKey: string;
        let ubiquitousItemContainerDisplayNameKey: string;
        let ubiquitousItemDownloadRequestedKey: string;
        let ubiquitousItemDownloadingErrorKey: string;
        let ubiquitousItemDownloadingStatusKey: string;
        let ubiquitousItemHasUnresolvedConflictsKey: string;
        let ubiquitousItemIsDownloadingKey: string;
        let ubiquitousItemIsSharedKey: string;
        let ubiquitousItemIsUploadedKey: string;
        let ubiquitousItemIsUploadingKey: string;
        let ubiquitousItemUploadingErrorKey: string;
        let ubiquitousSharedItemCurrentUserPermissionsKey: string;
        let ubiquitousSharedItemCurrentUserRoleKey: string;
        let ubiquitousSharedItemMostRecentEditorNameComponentsKey: string;
        let ubiquitousSharedItemOwnerNameComponentsKey: string;
        let volumeAvailableCapacityForImportantUsageKey: string;
        let volumeAvailableCapacityForOpportunisticUsageKey: string;
        let volumeAvailableCapacityKey: string;
        let volumeCreationDateKey: string;
        let volumeIdentifierKey: string;
        let volumeIsAutomountedKey: string;
        let volumeIsBrowsableKey: string;
        let volumeIsEjectableKey: string;
        let volumeIsEncryptedKey: string;
        let volumeIsInternalKey: string;
        let volumeIsJournalingKey: string;
        let volumeIsLocalKey: string;
        let volumeIsReadOnlyKey: string;
        let volumeIsRemovableKey: string;
        let volumeIsRootFileSystemKey: string;
        let volumeLocalizedFormatDescriptionKey: string;
        let volumeLocalizedNameKey: string;
        let volumeMaximumFileSizeKey: string;
        let volumeNameKey: string;
        let volumeResourceCountKey: string;
        let volumeSupportsAccessPermissionsKey: string;
        let volumeSupportsAdvisoryFileLockingKey: string;
        let volumeSupportsCasePreservedNamesKey: string;
        let volumeSupportsCaseSensitiveNamesKey: string;
        let volumeSupportsCompressionKey: string;
        let volumeSupportsExclusiveRenamingKey: string;
        let volumeSupportsExtendedSecurityKey: string;
        let volumeSupportsFileCloningKey: string;
        let volumeSupportsHardLinksKey: string;
        let volumeSupportsImmutableFilesKey: string;
        let volumeSupportsJournalingKey: string;
        let volumeSupportsPersistentIDsKey: string;
        let volumeSupportsRenamingKey: string;
        let volumeSupportsRootDirectoryDatesKey: string;
        let volumeSupportsSparseFilesKey: string;
        let volumeSupportsSwapRenamingKey: string;
        let volumeSupportsSymbolicLinksKey: string;
        let volumeSupportsVolumeSizesKey: string;
        let volumeSupportsZeroRunsKey: string;
        let volumeTotalCapacityKey: string;
        let volumeURLForRemountingKey: string;
        let volumeURLKey: string;
        let volumeUUIDStringKey: string;
    }
    namespace URLSession {
        enum AuthChallengeDisposition {
            UseCredential = 0,
            PerformDefaultHandling = 1,
            CancelAuthenticationChallenge = 2,
            RejectProtectionSpace = 3
        }
        enum ResponseDisposition {
            Cancel = 0,
            Allow = 1,
            BecomeDownload = 2,
            BecomeStream = 3
        }
    }
    namespace URLSessionTask {
        enum State {
            Running = 0,
            Suspended = 1,
            Canceling = 2,
            Completed = 3
        }
        let defaultPriority: number;
        let highPriority: number;
        let lowPriority: number;
    }
    namespace URLSessionTaskMetrics {
        enum ResourceFetchType {
            Unknown = 0,
            NetworkLoad = 1,
            ServerPush = 2,
            LocalCache = 3
        }
    }
    namespace URLSessionWebSocketTask {
        enum CloseCode {
            Invalid = 0,
            NormalClosure = 1000,
            GoingAway = 1001,
            ProtocolError = 1002,
            UnsupportedData = 1003,
            NoStatusReceived = 1005,
            AbnormalClosure = 1006,
            InvalidFramePayloadData = 1007,
            PolicyViolation = 1008,
            MessageTooBig = 1009,
            MandatoryExtensionMissing = 1010,
            InternalServerError = 1011,
            TLSHandshakeFailure = 1015
        }
    }
    namespace URLThumbnailDictionaryItem {
        let NSThumbnail1024x1024SizeKey: string;
    }
    namespace URLUbiquitousItemDownloadingStatus {
        let current: string;
        let downloaded: string;
        let notDownloaded: string;
    }
    namespace URLUbiquitousSharedItemPermissions {
        let readOnly: string;
        let readWrite: string;
    }
    namespace URLUbiquitousSharedItemRole {
        let owner: string;
        let participant: string;
    }
    namespace UserDefaults {
        let argumentDomain: string;
        let globalDomain: string;
        let registrationDomain: string;
        let completedInitialCloudSyncNotification: string;
        let didChangeCloudAccountsNotification: string;
        let noCloudAccountNotification: string;
        let didChangeNotification: string;
        let sizeLimitExceededNotification: string;
    }
    namespace XMLDTDNode {
        enum DTDKind {
            EntityGeneralKind = 1,
            EntityParsedKind = 2,
            EntityUnparsedKind = 3,
            EntityParameterKind = 4,
            EntityPredefined = 5,
            AttributeCDATAKind = 6,
            AttributeIDKind = 7,
            AttributeIDRefKind = 8,
            AttributeIDRefsKind = 9,
            AttributeEntityKind = 10,
            AttributeEntitiesKind = 11,
            AttributeNMTokenKind = 12,
            AttributeNMTokensKind = 13,
            AttributeEnumerationKind = 14,
            AttributeNotationKind = 15,
            ElementDeclarationUndefinedKind = 16,
            ElementDeclarationEmptyKind = 17,
            ElementDeclarationAnyKind = 18,
            ElementDeclarationMixedKind = 19,
            ElementDeclarationElementKind = 20
        }
    }
    namespace XMLDocument {
        enum ContentKind {
            XMLKind = 0,
            XHTMLKind = 1,
            HTMLKind = 2,
            TextKind = 3
        }
    }
    namespace XMLNode {
        enum Kind {
            InvalidKind = 0,
            DocumentKind = 1,
            ElementKind = 2,
            AttributeKind = 3,
            NamespaceKind = 4,
            ProcessingInstructionKind = 5,
            CommentKind = 6,
            TextKind = 7,
            DTDKind = 8,
            EntityDeclarationKind = 9,
            AttributeDeclarationKind = 10,
            ElementDeclarationKind = 11,
            NotationDeclarationKind = 12
        }
        enum Options {
            NodeOptionsNone = 0,
            NodeIsCDATA = 1,
            NodeExpandEmptyElement = 2,
            NodeCompactEmptyElement = 4,
            NodeUseSingleQuotes = 8,
            NodeUseDoubleQuotes = 16,
            NodeNeverEscapeContents = 32,
            DocumentTidyHTML = 512,
            DocumentTidyXML = 1024,
            DocumentValidate = 8192,
            NodeLoadExternalEntitiesAlways = 16384,
            NodeLoadExternalEntitiesSameOriginOnly = 32768,
            NodeLoadExternalEntitiesNever = 524288,
            DocumentXInclude = 65536,
            NodePrettyPrint = 131072,
            DocumentIncludeContentTypeDeclaration = 262144,
            NodePreserveNamespaceOrder = 1048576,
            NodePreserveAttributeOrder = 2097152,
            NodePreserveEntities = 4194304,
            NodePreservePrefixes = 8388608,
            NodePreserveCDATA = 16777216,
            NodePreserveWhitespace = 33554432,
            NodePreserveDTD = 67108864,
            NodePreserveCharacterReferences = 134217728,
            NodePromoteSignificantWhitespace = 268435456,
            NodePreserveEmptyElements = 6,
            NodePreserveQuotes = 24,
            NodePreserveAll = 4293918750
        }
    }
    namespace XMLParser {
        enum ErrorCode {
            InternalError = 1,
            OutOfMemoryError = 2,
            DocumentStartError = 3,
            EmptyDocumentError = 4,
            PrematureDocumentEndError = 5,
            InvalidHexCharacterRefError = 6,
            InvalidDecimalCharacterRefError = 7,
            InvalidCharacterRefError = 8,
            InvalidCharacterError = 9,
            CharacterRefAtEOFError = 10,
            CharacterRefInPrologError = 11,
            CharacterRefInEpilogError = 12,
            CharacterRefInDTDError = 13,
            EntityRefAtEOFError = 14,
            EntityRefInPrologError = 15,
            EntityRefInEpilogError = 16,
            EntityRefInDTDError = 17,
            ParsedEntityRefAtEOFError = 18,
            ParsedEntityRefInPrologError = 19,
            ParsedEntityRefInEpilogError = 20,
            ParsedEntityRefInInternalSubsetError = 21,
            EntityReferenceWithoutNameError = 22,
            EntityReferenceMissingSemiError = 23,
            ParsedEntityRefNoNameError = 24,
            ParsedEntityRefMissingSemiError = 25,
            UndeclaredEntityError = 26,
            UnparsedEntityError = 28,
            EntityIsExternalError = 29,
            EntityIsParameterError = 30,
            UnknownEncodingError = 31,
            EncodingNotSupportedError = 32,
            StringNotStartedError = 33,
            StringNotClosedError = 34,
            NamespaceDeclarationError = 35,
            EntityNotStartedError = 36,
            EntityNotFinishedError = 37,
            LessThanSymbolInAttributeError = 38,
            AttributeNotStartedError = 39,
            AttributeNotFinishedError = 40,
            AttributeHasNoValueError = 41,
            AttributeRedefinedError = 42,
            LiteralNotStartedError = 43,
            LiteralNotFinishedError = 44,
            CommentNotFinishedError = 45,
            ProcessingInstructionNotStartedError = 46,
            ProcessingInstructionNotFinishedError = 47,
            NotationNotStartedError = 48,
            NotationNotFinishedError = 49,
            AttributeListNotStartedError = 50,
            AttributeListNotFinishedError = 51,
            MixedContentDeclNotStartedError = 52,
            MixedContentDeclNotFinishedError = 53,
            ElementContentDeclNotStartedError = 54,
            ElementContentDeclNotFinishedError = 55,
            XMLDeclNotStartedError = 56,
            XMLDeclNotFinishedError = 57,
            ConditionalSectionNotStartedError = 58,
            ConditionalSectionNotFinishedError = 59,
            ExternalSubsetNotFinishedError = 60,
            DOCTYPEDeclNotFinishedError = 61,
            MisplacedCDATAEndStringError = 62,
            CDATANotFinishedError = 63,
            MisplacedXMLDeclarationError = 64,
            SpaceRequiredError = 65,
            SeparatorRequiredError = 66,
            NMTOKENRequiredError = 67,
            NAMERequiredError = 68,
            PCDATARequiredError = 69,
            URIRequiredError = 70,
            PublicIdentifierRequiredError = 71,
            LTRequiredError = 72,
            GTRequiredError = 73,
            LTSlashRequiredError = 74,
            EqualExpectedError = 75,
            TagNameMismatchError = 76,
            UnfinishedTagError = 77,
            StandaloneValueError = 78,
            InvalidEncodingNameError = 79,
            CommentContainsDoubleHyphenError = 80,
            InvalidEncodingError = 81,
            ExternalStandaloneEntityError = 82,
            InvalidConditionalSectionError = 83,
            EntityValueRequiredError = 84,
            NotWellBalancedError = 85,
            ExtraContentError = 86,
            InvalidCharacterInEntityError = 87,
            ParsedEntityRefInInternalError = 88,
            EntityRefLoopError = 89,
            EntityBoundaryError = 90,
            InvalidURIError = 91,
            URIFragmentError = 92,
            NoDTDError = 94,
            DelegateAbortedParseError = 512
        }
        enum ExternalEntityResolvingPolicy {
            ResolveExternalEntitiesNever = 0,
            ResolveExternalEntitiesNoNetwork = 1,
            ResolveExternalEntitiesSameOriginOnly = 2,
            ResolveExternalEntitiesAlways = 3
        }
        let errorDomain: string;
    }
    export enum AVAssetReferenceRestrictions {
        forbidRemoteReferenceToLocal,
        forbidLocalReferenceToRemote,
        forbidCrossSiteReference,
        forbidLocalReferenceToLocal,
        forbidAll,
        defaultPolicy
    }
    export enum AVAudioPlayerNodeBufferOptions {
        byteSwapped,
        scalarCount,
        loops,
        interrupts,
        interruptsAtLoop
    }
    export enum AVAudioSpatializationFormats {
        monoAndStereo,
        multichannel,
        monoStereoAndMultichannel
    }
    export enum AVMovieWritingOptions {
        errorDomain,
        unknown,
        outOfMemory,
        sessionNotRunning,
        deviceAlreadyUsedByAnotherSession,
        noDataCaptured,
        sessionConfigurationChanged,
        diskFull,
        deviceWasDisconnected,
        mediaChanged,
        maximumDurationReached,
        maximumFileSizeReached,
        mediaDiscontinuity,
        maximumNumberOfSamplesForFileFormatReached,
        deviceNotConnected,
        deviceInUseByAnotherApplication,
        deviceLockedForConfigurationByAnotherProcess,
        exportFailed,
        decodeFailed,
        invalidSourceMedia,
        fileAlreadyExists,
        compositionTrackSegmentsNotContiguous,
        invalidCompositionTrackSegmentDuration,
        invalidCompositionTrackSegmentSourceStartTime,
        invalidCompositionTrackSegmentSourceDuration,
        fileFormatNotRecognized,
        fileFailedToParse,
        maximumStillImageCaptureRequestsExceeded,
        contentIsProtected,
        noImageAtTime,
        decoderNotFound,
        encoderNotFound,
        contentIsNotAuthorized,
        applicationIsNotAuthorized,
        operationNotSupportedForAsset,
        decoderTemporarilyUnavailable,
        encoderTemporarilyUnavailable,
        invalidVideoComposition,
        referenceForbiddenByReferencePolicy,
        invalidOutputURLPathExtension,
        screenCaptureFailed,
        displayWasDisabled,
        torchLevelUnavailable,
        incompatibleAsset,
        failedToLoadMediaData,
        serverIncorrectlyConfigured,
        applicationIsNotAuthorizedToUseDevice,
        failedToParse,
        fileTypeDoesNotSupportSampleReferences,
        undecodableMediaData,
        airPlayControllerRequiresInternet,
        airPlayReceiverRequiresInternet,
        videoCompositorFailed,
        createContentKeyRequestFailed,
        unsupportedOutputSettings,
        operationNotAllowed,
        contentIsUnavailable,
        formatUnsupported,
        malformedDepth,
        contentNotUpdated,
        noLongerPlayable,
        noCompatibleAlternatesForExternalDisplay,
        noSourceTrack,
        externalPlaybackNotSupportedForAsset,
        operationNotSupportedForPreset,
        incorrectlyConfigured,
        segmentStartedWithNonSyncSample,
        rosettaNotInstalled,
        addMovieHeaderToDestination,
        truncateDestinationToMovieHeaderOnly
    }
    export enum AVMusicSequenceLoadOptions {
        smfChannelsToTracks,
        scalarCount
    }
    export enum AlignmentOptions {
        alignMinXInward,
        alignMinYInward,
        alignMaxXInward,
        alignMaxYInward,
        alignWidthInward,
        alignHeightInward,
        alignMinXOutward,
        alignMinYOutward,
        alignMaxXOutward,
        alignMaxYOutward,
        alignWidthOutward,
        alignHeightOutward,
        alignMinXNearest,
        alignMinYNearest,
        alignMaxXNearest,
        alignMaxYNearest,
        alignWidthNearest,
        alignHeightNearest,
        alignRectFlipped,
        alignAllEdgesInward,
        alignAllEdgesOutward,
        alignAllEdgesNearest
    }
    export enum AnyObject {
        byteSwapped,
        scalarCount,
        assureMemoryNow,
        alwaysCopyData,
        dontOptimizeDepth,
        permitEmptyReference
    }
    export enum CAAutoresizingMask {
        layerMinXMargin,
        layerWidthSizable,
        layerMaxXMargin,
        layerMinYMargin,
        layerHeightSizable,
        layerMaxYMargin
    }
    export enum CACornerMask {
        layerMinXMinYCorner,
        layerMaxXMinYCorner,
        layerMinXMaxYCorner,
        layerMaxXMaxYCorner
    }
    export enum CAEdgeAntialiasingMask {
        layerLeftEdge,
        layerRightEdge,
        layerBottomEdge,
        layerTopEdge
    }
    export enum CFCalendarUnit {
        magnitude,
        byteSwapped,
        scalarCount,
        era,
        year,
        month,
        day,
        hour,
        minute,
        second,
        week,
        weekday,
        weekdayOrdinal,
        quarter,
        weekOfMonth,
        weekOfYear,
        yearForWeekOfYear
    }
    export enum CFDataSearchFlags {
        backwards,
        anchored
    }
    export enum CFFileSecurityClearOptions {
        magnitude,
        byteSwapped,
        scalarCount,
        owner,
        group,
        mode,
        ownerUUID,
        groupUUID,
        accessControlList
    }
    export enum CFGregorianUnitFlags {
        unitsYears,
        unitsMonths,
        unitsDays,
        unitsHours,
        unitsMinutes,
        unitsSeconds,
        allUnits
    }
    export enum CFISO8601DateFormatOptions {
        byteSwapped,
        scalarCount,
        withYear,
        withMonth,
        withWeekOfYear,
        withDay,
        withTime,
        withTimeZone,
        withSpaceBetweenDateAndTime,
        withDashSeparatorInDate,
        withColonSeparatorInTime,
        withColonSeparatorInTimeZone,
        withFractionalSeconds,
        withFullDate,
        withFullTime,
        withInternetDateTime
    }
    export enum CFNumberFormatterOptionFlags {
        magnitude,
        byteSwapped,
        scalarCount,
        parseIntegersOnly
    }
    export enum CFPropertyListMutabilityOptions {
        byteSwapped,
        scalarCount,
        mutableContainers,
        mutableContainersAndLeaves
    }
    export enum CFRunLoopActivity {
        entry,
        beforeTimers,
        beforeSources,
        beforeWaiting,
        afterWaiting,
        exit,
        allActivities
    }
    export enum CFSocketCallBackType {
        readCallBack,
        acceptCallBack,
        dataCallBack,
        connectCallBack,
        writeCallBack
    }
    export enum CFStreamEventType {
        magnitude,
        byteSwapped,
        scalarCount,
        openCompleted,
        hasBytesAvailable,
        canAcceptBytes,
        errorOccurred,
        endEncountered
    }
    export enum CFStringCompareFlags {
        compareCaseInsensitive,
        compareBackwards,
        compareAnchored,
        compareNonliteral,
        compareLocalized,
        compareNumerically,
        compareDiacriticInsensitive,
        compareWidthInsensitive,
        compareForcedOrdering
    }
    export enum CFStringTokenizerTokenType {
        byteSwapped,
        scalarCount,
        normal,
        hasSubTokensMask,
        hasDerivedSubTokensMask,
        hasHasNumbersMask,
        hasNonLettersMask,
        isCJWordMask
    }
    export enum CFURLBookmarkCreationOptions {
        byteSwapped,
        scalarCount,
        minimalBookmarkMask,
        suitableForBookmarkFile,
        withSecurityScope,
        securityScopeAllowOnlyReadAccess
    }
    export enum CFURLBookmarkResolutionOptions {
        byteSwapped,
        scalarCount,
        cfurlBookmarkResolutionWithoutUIMask,
        cfurlBookmarkResolutionWithoutMountingMask,
        cfurlBookmarkResolutionWithSecurityScope,
        cfBookmarkResolutionWithoutUIMask,
        cfBookmarkResolutionWithoutMountingMask
    }
    export enum CFURLEnumeratorOptions {
        descendRecursively,
        skipInvisibles,
        generateFileReferenceURLs,
        skipPackageContents,
        includeDirectoriesPreOrder,
        includeDirectoriesPostOrder,
        generateRelativePathURLs
    }
    export enum CFXMLParserOptions {
        validateDocument,
        skipMetaData,
        replacePhysicalEntities,
        skipWhitespace,
        resolveExternalEntities,
        addImpliedAttributes,
        allOptions
    }
    export enum CFXMLParserStatusCode {
        statusParseNotBegun,
        statusParseInProgress,
        errorUnexpectedEOF,
        errorUnknownEncoding,
        errorEncodingConversionFailure,
        errorMalformedProcessingInstruction,
        errorMalformedDTD,
        errorMalformedName,
        errorMalformedCDSect,
        errorMalformedCloseTag,
        errorMalformedStartTag,
        errorMalformedDocument,
        errorElementlessDocument,
        errorMalformedComment,
        errorMalformedCharacterReference,
        errorMalformedParsedCharacterData,
        errorNoData
    }
    export enum CGBitmapInfo {
        alphaInfoMask,
        floatInfoMask,
        floatComponents,
        byteOrderMask,
        byteOrder16Little,
        byteOrder32Little,
        byteOrder16Big,
        byteOrder32Big
    }
    export enum CGCaptureOptions {
        byteSwapped,
        scalarCount,
        noFill
    }
    export enum CGConfigureOption {
        byteSwapped,
        scalarCount,
        forAppOnly,
        forSession,
        permanently
    }
    export enum CGDisplayChangeSummaryFlags {
        byteSwapped,
        scalarCount,
        beginConfigurationFlag,
        movedFlag,
        setMainFlag,
        setModeFlag,
        addFlag,
        removeFlag,
        enabledFlag,
        disabledFlag,
        mirrorFlag,
        unMirrorFlag,
        desktopShapeChangedFlag
    }
    export enum CGEventFilterMask {
        byteSwapped,
        scalarCount,
        permitLocalMouseEvents,
        permitLocalKeyboardEvents,
        permitSystemDefinedEvents
    }
    export enum CGEventFlags {
        maskAlphaShift,
        maskShift,
        maskControl,
        maskAlternate,
        maskCommand,
        maskHelp,
        maskSecondaryFn,
        maskNumericPad,
        maskNonCoalesced
    }
    export enum CGGradientDrawingOptions {
        byteSwapped,
        scalarCount,
        drawsBeforeStartLocation,
        drawsAfterEndLocation
    }
    export enum CGPDFAccessPermissions {
        byteSwapped,
        scalarCount,
        allowsLowQualityPrinting,
        allowsHighQualityPrinting,
        allowsDocumentChanges,
        allowsDocumentAssembly,
        allowsContentCopying,
        allowsContentAccessibility,
        allowsCommenting,
        allowsFormFieldEntry
    }
    export enum CGScreenUpdateOperation {
        byteSwapped,
        scalarCount,
        refresh,
        move,
        reducedDirtyRectangleCount
    }
    export enum CGWindowImageOption {
        byteSwapped,
        scalarCount,
        boundsIgnoreFraming,
        shouldBeOpaque,
        onlyShadows,
        bestResolution,
        nominalResolution
    }
    export enum CGWindowListOption {
        magnitude,
        byteSwapped,
        scalarCount,
        optionAll,
        optionOnScreenOnly,
        optionOnScreenAboveWindow,
        optionOnScreenBelowWindow,
        optionIncludingWindow,
        excludeDesktopElements
    }
    export enum CKContainer_Application_Permissions {
        userDiscoverability
    }
    export enum CMSampleBuffer {
        audioBufferListAssure16ByteAlignment
    }
    export enum CMTimeFlags {
        magnitude,
        byteSwapped,
        scalarCount,
        valid,
        hasBeenRounded,
        positiveInfinity,
        negativeInfinity,
        indefinite,
        impliedValueFlagsMask
    }
    export enum Character {
        request,
        session,
        ascii,
        nextstep,
        japaneseEUC,
        utf8,
        isoLatin1,
        symbol,
        nonLossyASCII,
        shiftJIS,
        isoLatin2,
        unicode,
        windowsCP1251,
        windowsCP1252,
        windowsCP1253,
        windowsCP1254,
        windowsCP1250,
        iso2022JP,
        macOSRoman,
        utf16,
        utf16BigEndian,
        utf16LittleEndian,
        utf32,
        utf32BigEndian,
        utf32LittleEndian
    }
    export enum Data {
        video,
        audio,
        muxed,
        text,
        closedCaption,
        subtitle,
        timeCode,
        metadata,
        linearPCM,
        ac3,
        iec60958AC3,
        appleIMA4,
        mpeg4AAC,
        mpeg4CELP,
        mpeg4HVXC,
        mpeg4TwinVQ,
        mace3,
        mace6,
        uLaw,
        aLaw,
        qDesign,
        qDesign2,
        qualcomm,
        mpegLayer1,
        mpegLayer2,
        mpegLayer3,
        midiStream,
        parameterValueStream,
        appleLossless,
        mpeg4AAC_HE,
        mpeg4AAC_LD,
        mpeg4AAC_ELD,
        mpeg4AAC_ELD_SBR,
        mpeg4AAC_ELD_V2,
        mpeg4AAC_HE_V2,
        mpeg4AAC_Spatial,
        mpegD_USAC,
        amr,
        amr_WB,
        audible,
        iLBC,
        dviIntelIMA,
        microsoftGSM,
        aes3,
        enhancedAC3,
        flac,
        opus,
        aacLCProtected,
        aacAudibleProtected,
        pixelFormat_32ARGB,
        pixelFormat_32BGRA,
        pixelFormat_24RGB,
        pixelFormat_16BE555,
        pixelFormat_16BE565,
        pixelFormat_16LE555,
        pixelFormat_16LE565,
        pixelFormat_16LE5551,
        pixelFormat_422YpCbCr8,
        pixelFormat_422YpCbCr8_yuvs,
        pixelFormat_444YpCbCr8,
        pixelFormat_4444YpCbCrA8,
        pixelFormat_422YpCbCr16,
        pixelFormat_422YpCbCr10,
        pixelFormat_444YpCbCr10,
        pixelFormat_8IndexedGray_WhiteIsZero,
        animation,
        cinepak,
        jpeg,
        jpeg_OpenDML,
        sorensonVideo,
        sorensonVideo3,
        h263,
        h264,
        hevc,
        hevcWithAlpha,
        mpeg4Video,
        mpeg2Video,
        mpeg1Video,
        dvcNTSC,
        dvcPAL,
        dvcProPAL,
        dvcPro50NTSC,
        dvcPro50PAL,
        dvcPROHD720p60,
        dvcPROHD720p50,
        dvcPROHD1080i60,
        dvcPROHD1080i50,
        dvcPROHD1080p30,
        dvcPROHD1080p25,
        proRes4444XQ,
        proRes4444,
        proRes422HQ,
        proRes422,
        proRes422LT,
        proRes422Proxy,
        proResRAW,
        proResRAWHQ,
        mpeg1System,
        mpeg2Transport,
        mpeg2Program,
        dv,
        cea608,
        cea708,
        atsc,
        qt,
        mobile3GPP,
        webVTT,
        timeCode32,
        timeCode64,
        counter32,
        counter64,
        icy,
        id3,
        boxed,
        emsg,
        streamBasicDescription,
        magicCookie,
        channelLayout,
        extensions,
        all,
        startIndex,
        endIndex
    }
    export enum Int {
        byteSwapped,
        scalarCount
    }
    export enum NSBinarySearchingOptions {
        firstEqual,
        lastEqual,
        insertionIndex
    }
    export enum NSDirectionalRectEdge {
        top,
        leading,
        bottom,
        trailing,
        all
    }
    export enum NSDragOperation {
        copy,
        link,
        generic,
        private,
        move,
        delete,
        every,
        all_Obsolete,
        all
    }
    export enum NSDraggingItemEnumerationOptions {
        concurrent,
        clearNonenumeratedImages
    }
    export enum NSEnumerationOptions {
        concurrent,
        reverse
    }
    export enum NSFetchRequestResultType {
        managedObjectResultType,
        managedObjectIDResultType,
        dictionaryResultType,
        countResultType
    }
    export enum NSFontCollectionOptions {
        applicationOnlyMask
    }
    export enum NSFontTraitMask {
        byteSwapped,
        scalarCount,
        italicFontMask,
        boldFontMask,
        unboldFontMask,
        nonStandardCharacterSetFontMask,
        narrowFontMask,
        expandedFontMask,
        condensedFontMask,
        smallCapsFontMask,
        posterFontMask,
        compressedFontMask,
        fixedPitchFontMask,
        unitalicFontMask
    }
    export enum NSItemProviderFileOptions {
        openInPlace
    }
    export enum NSKeyValueObservingOptions {
        new,
        old,
        initial,
        prior
    }
    export enum NSOrderedCollectionDifferenceCalculationOptions {
        magnitude,
        timeInterval,
        hashValue,
        omitInsertedObjects,
        omitRemovedObjects,
        inferMoves
    }
    export enum NSPersistentCloudKitContainerSchemaInitializationOptions {
        dryRun,
        printSchema
    }
    export enum NSSnapshotEventType {
        undoInsertion,
        undoDeletion,
        undoUpdate,
        rollback,
        refresh,
        mergePolicy
    }
    export enum NSSortOptions {
        magnitude,
        byteSwapped,
        scalarCount,
        concurrent,
        stable
    }
    export enum NSSpringLoadingOptions {
        disabled,
        enabled,
        continuousActivation,
        noHover
    }
    export enum NSTextStorageEditActions {
        editedAttributes,
        editedCharacters
    }
    export enum NSTypesetterControlCharacterAction {
        magnitude,
        byteSwapped,
        scalarCount,
        zeroAdvancementAction,
        whitespaceAction,
        horizontalTabAction,
        lineBreakAction,
        paragraphBreakAction,
        containerBreakAction
    }
    export enum NSUnderlineStyle {
        single,
        thick,
        double,
        patternDot,
        patternDash,
        patternDashDot,
        patternDashDotDot,
        byWord
    }
    export enum UInt {
        magnitude,
        byteSwapped,
        scalarCount,
        hashValue,
        boolValue,
        ptr,
        bitWidth,
        leadingZeroBitCount,
        trailingZeroBitCount,
        nonzeroBitCount,
        count,
        startIndex,
        endIndex,
        indices,
        words
    }
    export enum UInt8 {
        regions,
        startIndex,
        endIndex,
        indices,
        hashValue,
        autoupdatingCurrent,
        current
    }
    export enum AVAssetReferenceRestrictions {
        ForbidNone = 0,
        ForbidRemoteReferenceToLocal = 1,
        ForbidLocalReferenceToRemote = 2,
        ForbidCrossSiteReference = 4,
        ForbidLocalReferenceToLocal = 8,
        ForbidAll = 65535,
        DefaultPolicy = 2
    }
    export enum AVAudio3DMixingPointSourceInHeadMode {
        Mono = 0,
        Bypass = 1
    }
    export enum AVAudio3DMixingRenderingAlgorithm {
        EqualPowerPanning = 0,
        SphericalHead = 1,
        HRTF = 2,
        SoundField = 3,
        StereoPassThrough = 5,
        HRTFHQ = 6,
        Auto = 7
    }
    export enum AVAudio3DMixingSourceMode {
        SpatializeIfMono = 0,
        Bypass = 1,
        PointSource = 2,
        AmbienceBed = 3
    }
    export enum AVAudioCommonFormat {
        OtherFormat = 0,
        PCMFormatFloat32 = 1,
        PCMFormatFloat64 = 2,
        PCMFormatInt16 = 3,
        PCMFormatInt32 = 4
    }
    export enum AVAudioConverterInputStatus {
        HaveData = 0,
        NoDataNow = 1,
        EndOfStream = 2
    }
    export enum AVAudioConverterOutputStatus {
        HaveData = 0,
        InputRanDry = 1,
        EndOfStream = 2,
        Error = 3
    }
    export enum AVAudioConverterPrimeMethod {
        Pre = 0,
        Normal = 1,
        None = 2
    }
    export enum AVAudioEngineManualRenderingError {
        InvalidMode = -80800,
        Initialized = -80801,
        NotRunning = -80802
    }
    export enum AVAudioEngineManualRenderingMode {
        Offline = 0,
        Realtime = 1
    }
    export enum AVAudioEngineManualRenderingStatus {
        Error = -1,
        Success = 0,
        InsufficientDataFromInputNode = 1,
        CannotDoInCurrentContext = 2
    }
    export enum AVAudioEnvironmentDistanceAttenuationModel {
        Exponential = 1,
        Inverse = 2,
        Linear = 3
    }
    export enum AVAudioEnvironmentOutputType {
        Auto = 0,
        Headphones = 1,
        BuiltInSpeakers = 2,
        ExternalSpeakers = 3
    }
    export enum AVAudioPlayerNodeBufferOptions {
        Loops = 1,
        Interrupts = 2,
        InterruptsAtLoop = 4
    }
    export enum AVAudioPlayerNodeCompletionCallbackType {
        DataConsumed = 0,
        DataRendered = 1,
        DataPlayedBack = 2
    }
    export enum AVAudioQuality {
        Min = 0,
        Low = 32,
        Medium = 64,
        High = 96,
        Max = 127
    }
    export enum AVAudioSessionActivationOptions {
        None = 0
    }
    export enum AVAudioUnitDistortionPreset {
        DrumsBitBrush = 0,
        DrumsBufferBeats = 1,
        DrumsLoFi = 2,
        MultiBrokenSpeaker = 3,
        MultiCellphoneConcert = 4,
        MultiDecimated1 = 5,
        MultiDecimated2 = 6,
        MultiDecimated3 = 7,
        MultiDecimated4 = 8,
        MultiDistortedFunk = 9,
        MultiDistortedCubed = 10,
        MultiDistortedSquared = 11,
        MultiEcho1 = 12,
        MultiEcho2 = 13,
        MultiEchoTight1 = 14,
        MultiEchoTight2 = 15,
        MultiEverythingIsBroken = 16,
        SpeechAlienChatter = 17,
        SpeechCosmicInterference = 18,
        SpeechGoldenPi = 19,
        SpeechRadioTower = 20,
        SpeechWaves = 21
    }
    export enum AVAudioUnitEQFilterType {
        Parametric = 0,
        LowPass = 1,
        HighPass = 2,
        ResonantLowPass = 3,
        ResonantHighPass = 4,
        BandPass = 5,
        BandStop = 6,
        LowShelf = 7,
        HighShelf = 8,
        ResonantLowShelf = 9,
        ResonantHighShelf = 10
    }
    export enum AVAudioUnitReverbPreset {
        SmallRoom = 0,
        MediumRoom = 1,
        LargeRoom = 2,
        MediumHall = 3,
        LargeHall = 4,
        Plate = 5,
        MediumChamber = 6,
        LargeChamber = 7,
        Cathedral = 8,
        LargeRoom2 = 9,
        MediumHall2 = 10,
        MediumHall3 = 11,
        LargeHall2 = 12
    }
    export enum AVAuthorizationStatus {
        NotDetermined = 0,
        Restricted = 1,
        Denied = 2,
        Authorized = 3
    }
    export enum AVCaptureColorSpace {
        sRGB = 0,
        P3_D65 = 1
    }
    export enum AVCaptureVideoOrientation {
        Portrait = 1,
        PortraitUpsideDown = 2,
        LandscapeRight = 3,
        LandscapeLeft = 4
    }
    export enum AVContentAuthorizationStatus {
        Unknown = 0,
        Completed = 1,
        Cancelled = 2,
        TimedOut = 3,
        Busy = 4,
        NotAvailable = 5,
        NotPossible = 6
    }
    export enum AVError {
        Unknown = -11800,
        OutOfMemory = -11801,
        SessionNotRunning = -11803,
        DeviceAlreadyUsedByAnotherSession = -11804,
        NoDataCaptured = -11805,
        SessionConfigurationChanged = -11806,
        DiskFull = -11807,
        DeviceWasDisconnected = -11808,
        MediaChanged = -11809,
        MaximumDurationReached = -11810,
        MaximumFileSizeReached = -11811,
        MediaDiscontinuity = -11812,
        MaximumNumberOfSamplesForFileFormatReached = -11813,
        DeviceNotConnected = -11814,
        DeviceInUseByAnotherApplication = -11815,
        DeviceLockedForConfigurationByAnotherProcess = -11817,
        ExportFailed = -11820,
        DecodeFailed = -11821,
        InvalidSourceMedia = -11822,
        FileAlreadyExists = -11823,
        CompositionTrackSegmentsNotContiguous = -11824,
        InvalidCompositionTrackSegmentDuration = -11825,
        InvalidCompositionTrackSegmentSourceStartTime = -11826,
        InvalidCompositionTrackSegmentSourceDuration = -11827,
        FileFormatNotRecognized = -11828,
        FileFailedToParse = -11829,
        MaximumStillImageCaptureRequestsExceeded = -11830,
        ContentIsProtected = -11831,
        NoImageAtTime = -11832,
        DecoderNotFound = -11833,
        EncoderNotFound = -11834,
        ContentIsNotAuthorized = -11835,
        ApplicationIsNotAuthorized = -11836,
        OperationNotSupportedForAsset = -11838,
        DecoderTemporarilyUnavailable = -11839,
        EncoderTemporarilyUnavailable = -11840,
        InvalidVideoComposition = -11841,
        ReferenceForbiddenByReferencePolicy = -11842,
        InvalidOutputURLPathExtension = -11843,
        ScreenCaptureFailed = -11844,
        DisplayWasDisabled = -11845,
        TorchLevelUnavailable = -11846,
        IncompatibleAsset = -11848,
        FailedToLoadMediaData = -11849,
        ServerIncorrectlyConfigured = -11850,
        ApplicationIsNotAuthorizedToUseDevice = -11852,
        FailedToParse = -11853,
        FileTypeDoesNotSupportSampleReferences = -11854,
        UndecodableMediaData = -11855,
        AirPlayControllerRequiresInternet = -11856,
        AirPlayReceiverRequiresInternet = -11857,
        VideoCompositorFailed = -11858,
        CreateContentKeyRequestFailed = -11860,
        UnsupportedOutputSettings = -11861,
        OperationNotAllowed = -11862,
        ContentIsUnavailable = -11863,
        FormatUnsupported = -11864,
        MalformedDepth = -11865,
        ContentNotUpdated = -11866,
        NoLongerPlayable = -11867,
        NoCompatibleAlternatesForExternalDisplay = -11868,
        NoSourceTrack = -11869,
        ExternalPlaybackNotSupportedForAsset = -11870,
        OperationNotSupportedForPreset = -11871,
        SessionHardwareCostOverage = -11872,
        UnsupportedDeviceActiveFormat = -11873
    }
    export enum AVKeyValueStatus {
        Unknown = 0,
        Loading = 1,
        Loaded = 2,
        Failed = 3,
        Cancelled = 4
    }
    export enum AVMovieWritingOptions {
        AddMovieHeaderToDestination = 0,
        TruncateDestinationToMovieHeaderOnly = 1
    }
    export enum AVMusicSequenceLoadOptions {
        SMF_PreserveTracks = 0,
        SMF_ChannelsToTracks = 1
    }
    export enum AVMusicTrackLoopCount {
        Forever = -1
    }
    export enum AVQueuedSampleBufferRenderingStatus {
        Unknown = 0,
        Rendering = 1,
        Failed = 2
    }
    export enum AVSpeechBoundary {
        Immediate = 0,
        Word = 1
    }
    export enum AVSpeechSynthesisVoiceGender {
        Unspecified = 0,
        Male = 1,
        Female = 2
    }
    export enum AVSpeechSynthesisVoiceQuality {
        Default = 1,
        Enhanced = 2
    }
    export enum AVVideoFieldMode {
        Both = 0,
        TopOnly = 1,
        BottomOnly = 2,
        Deinterlace = 3
    }
    export enum AVCaptureViewControlsStyle {
        Inline = 0,
        Floating = 1,
        InlineDeviceSelection = 2,
        Default = 0
    }
    export enum AVPlayerViewControlsStyle {
        None = 0,
        Inline = 1,
        Floating = 2,
        Minimal = 3,
        Default = 1
    }
    export enum AVPlayerViewTrimResult {
        OKButton = 0,
        CancelButton = 1
    }
    export enum AVRoutePickerViewButtonState {
        Normal = 0,
        NormalHighlighted = 1,
        Active = 2,
        ActiveHighlighted = 3
    }
    export enum NSAccessibilityPriorityLevel {
        Low = 10,
        Medium = 50,
        High = 90
    }
    export enum NSAnimationEffect {
        DisappearingItemDefault = 0,
        Poof = 10
    }
    export enum NSBorderType {
        NoBorder = 0,
        LineBorder = 1,
        BezelBorder = 2,
        GrooveBorder = 3
    }
    export enum NSCharacterCollection {
        IdentityMappingCharacterCollection = 0,
        AdobeCNS1CharacterCollection = 1,
        AdobeGB1CharacterCollection = 2,
        AdobeJapan1CharacterCollection = 3,
        AdobeJapan2CharacterCollection = 4,
        AdobeKorea1CharacterCollection = 5
    }
    export enum NSCollectionElementCategory {
        Item = 0,
        SupplementaryView = 1,
        DecorationView = 2,
        InterItemGap = 3
    }
    export enum NSCollectionLayoutSectionOrthogonalScrollingBehavior {
        None = 0,
        Continuous = 1,
        ContinuousGroupLeadingBoundary = 2,
        Paging = 3,
        GroupPaging = 4,
        GroupPagingCentered = 5
    }
    export enum NSColorRenderingIntent {
        Default = 0,
        AbsoluteColorimetric = 1,
        RelativeColorimetric = 2,
        Perceptual = 3,
        Saturation = 4
    }
    export enum NSCompositingOperation {
        Clear = 0,
        Copy = 1,
        SourceOver = 2,
        SourceIn = 3,
        SourceOut = 4,
        SourceAtop = 5,
        DestinationOver = 6,
        DestinationIn = 7,
        DestinationOut = 8,
        DestinationAtop = 9,
        XOR = 10,
        PlusDarker = 11,
        Highlight = 12,
        PlusLighter = 13,
        Multiply = 14,
        Screen = 15,
        Overlay = 16,
        Darken = 17,
        Lighten = 18,
        ColorDodge = 19,
        ColorBurn = 20,
        SoftLight = 21,
        HardLight = 22,
        Difference = 23,
        Exclusion = 24,
        Hue = 25,
        Saturation = 26,
        Color = 27,
        Luminosity = 28
    }
    export enum NSControlTint {
        DefaultControlTint = 0,
        BlueControlTint = 1,
        GraphiteControlTint = 6,
        ClearControlTint = 7
    }
    export enum NSDirectionalRectEdge {
        None = 0,
        Top = 1,
        Leading = 2,
        Bottom = 4,
        Trailing = 8,
        All = 15
    }
    export enum NSDisplayGamut {
        SRGB = 1,
        P3 = 2
    }
    export enum NSDragOperation {
        None = 0,
        Copy = 1,
        Link = 2,
        Generic = 4,
        Private = 8,
        Move = 16,
        Delete = 32,
        Every = -1,
        All_Obsolete = 15,
        All = 15
    }
    export enum NSDraggingContext {
        OutsideApplication = 0,
        WithinApplication = 1
    }
    export enum NSDraggingFormation {
        Default = 0,
        None = 1,
        Pile = 2,
        List = 3,
        Stack = 4
    }
    export enum NSDraggingItemEnumerationOptions {
        Concurrent = 1,
        ClearNonenumeratedImages = 65536
    }
    export enum NSFindPanelAction {
        ShowFindPanel = 1,
        Next = 2,
        Previous = 3,
        ReplaceAll = 4,
        Replace = 5,
        ReplaceAndFind = 6,
        SetFindString = 7,
        ReplaceAllInSelection = 8,
        SelectAll = 9,
        SelectAllInSelection = 10
    }
    export enum NSFindPanelSubstringMatchType {
        Contains = 0,
        StartsWith = 1,
        FullWord = 2,
        EndsWith = 3
    }
    export enum NSFocusRingPlacement {
        Only = 0,
        Below = 1,
        Above = 2
    }
    export enum NSFocusRingType {
        Default = 0,
        None = 1,
        Exterior = 2
    }
    export enum NSFontAction {
        NoFontChangeAction = 0,
        ViaPanelFontAction = 1,
        AddTraitFontAction = 2,
        SizeUpFontAction = 3,
        SizeDownFontAction = 4,
        HeavierFontAction = 5,
        LighterFontAction = 6,
        RemoveTraitFontAction = 7
    }
    export enum NSFontCollectionOptions {
        ApplicationOnlyMask = 1
    }
    export enum NSFontRenderingMode {
        DefaultRenderingMode = 0,
        AntialiasedRenderingMode = 1,
        IntegerAdvancementsRenderingMode = 2,
        AntialiasedIntegerAdvancementsRenderingMode = 3
    }
    export enum NSFontTraitMask {
        ItalicFontMask = 1,
        BoldFontMask = 2,
        UnboldFontMask = 4,
        NonStandardCharacterSetFontMask = 8,
        NarrowFontMask = 16,
        ExpandedFontMask = 32,
        CondensedFontMask = 64,
        SmallCapsFontMask = 128,
        PosterFontMask = 256,
        CompressedFontMask = 512,
        FixedPitchFontMask = 1024,
        UnitalicFontMask = 16777216
    }
    export enum NSImageAlignment {
        Center = 0,
        Top = 1,
        TopLeft = 2,
        TopRight = 3,
        Left = 4,
        Bottom = 5,
        BottomLeft = 6,
        BottomRight = 7,
        Right = 8
    }
    export enum NSImageInterpolation {
        Default = 0,
        None = 1,
        Low = 2,
        Medium = 4,
        High = 3
    }
    export enum NSImageScaling {
        ImageScaleProportionallyDown = 0,
        ImageScaleAxesIndependently = 1,
        ImageScaleNone = 2,
        ImageScaleProportionallyUpOrDown = 3,
        ScaleProportionally = 0,
        ScaleToFit = 1,
        ScaleNone = 2
    }
    export enum NSLineBreakMode {
        ByWordWrapping = 0,
        ByCharWrapping = 1,
        ByClipping = 2,
        ByTruncatingHead = 3,
        ByTruncatingTail = 4,
        ByTruncatingMiddle = 5
    }
    export enum NSLineMovementDirection {
        DoesntMove = 0,
        MovesLeft = 1,
        MovesRight = 2,
        MovesDown = 3,
        MovesUp = 4
    }
    export enum NSLineSweepDirection {
        Left = 0,
        Right = 1,
        Down = 2,
        Up = 3
    }
    export enum NSRectAlignment {
        None = 0,
        Top = 1,
        TopLeading = 2,
        Leading = 3,
        BottomLeading = 4,
        Bottom = 5,
        BottomTrailing = 6,
        Trailing = 7,
        TopTrailing = 8
    }
    export enum NSSelectionAffinity {
        Upstream = 0,
        Downstream = 1
    }
    export enum NSSelectionGranularity {
        ByCharacter = 0,
        ByWord = 1,
        ByParagraph = 2
    }
    export enum NSSpringLoadingHighlight {
        None = 0,
        Standard = 1,
        Emphasized = 2
    }
    export enum NSSpringLoadingOptions {
        Disabled = 0,
        Enabled = 1,
        ContinuousActivation = 2,
        NoHover = 8
    }
    export enum NSTextAlignment {
        Left = 0,
        Right = 1,
        Center = 2,
        Justified = 3,
        Natural = 4
    }
    export enum NSTextInputTraitType {
        Default = 0,
        No = 1,
        Yes = 2
    }
    export enum NSTextMovement {
        Return = 16,
        Tab = 17,
        Backtab = 18,
        Left = 19,
        Right = 20,
        Up = 21,
        Down = 22,
        Cancel = 23,
        Other = 0
    }
    export enum NSTextScalingType {
        Standard = 0,
        iOS = 1
    }
    export enum NSTextStorageEditActions {
        EditedAttributes = 1,
        EditedCharacters = 2
    }
    export enum NSTypesetterControlCharacterAction {
        ZeroAdvancementAction = 1,
        WhitespaceAction = 2,
        HorizontalTabAction = 4,
        LineBreakAction = 8,
        ParagraphBreakAction = 16,
        ContainerBreakAction = 32
    }
    export enum NSUnderlineStyle {
        None = 0,
        Single = 1,
        Thick = 2,
        Double = 9,
        PatternSolid = 0,
        PatternDot = 256,
        PatternDash = 512,
        PatternDashDot = 768,
        PatternDashDotDot = 1024,
        ByWord = 32768
    }
    export enum NSUserInterfaceLayoutDirection {
        LeftToRight = 0,
        RightToLeft = 1
    }
    export enum NSUserInterfaceLayoutOrientation {
        Horizontal = 0,
        Vertical = 1
    }
    export enum NSWritingDirection {
        Natural = -1,
        LeftToRight = 0,
        RightToLeft = 1
    }
    export enum NSWritingDirectionFormatType {
        Embedding = 0,
        Override = 2
    }
    export enum NSAttributeType {
        UndefinedAttributeType = 0,
        Integer16AttributeType = 100,
        Integer32AttributeType = 200,
        Integer64AttributeType = 300,
        DecimalAttributeType = 400,
        DoubleAttributeType = 500,
        FloatAttributeType = 600,
        StringAttributeType = 700,
        BooleanAttributeType = 800,
        DateAttributeType = 900,
        BinaryDataAttributeType = 1000,
        UUIDAttributeType = 1100,
        URIAttributeType = 1200,
        TransformableAttributeType = 1800,
        ObjectIDAttributeType = 2000
    }
    export enum NSBatchDeleteRequestResultType {
        ResultTypeStatusOnly = 0,
        ResultTypeObjectIDs = 1,
        ResultTypeCount = 2
    }
    export enum NSBatchInsertRequestResultType {
        StatusOnly = 0,
        ObjectIDs = 1,
        Count = 2
    }
    export enum NSBatchUpdateRequestResultType {
        StatusOnlyResultType = 0,
        UpdatedObjectIDsResultType = 1,
        UpdatedObjectsCountResultType = 2
    }
    export enum NSDeleteRule {
        NoActionDeleteRule = 0,
        NullifyDeleteRule = 1,
        CascadeDeleteRule = 2,
        DenyDeleteRule = 3
    }
    export enum NSEntityMappingType {
        UndefinedEntityMappingType = 0,
        CustomEntityMappingType = 1,
        AddEntityMappingType = 2,
        RemoveEntityMappingType = 3,
        CopyEntityMappingType = 4,
        TransformEntityMappingType = 5
    }
    export enum NSFetchIndexElementType {
        Binary = 0,
        RTree = 1
    }
    export enum NSFetchRequestResultType {
        ManagedObjectResultType = 0,
        ManagedObjectIDResultType = 1,
        DictionaryResultType = 2,
        CountResultType = 4
    }
    export enum NSFetchedResultsChangeType {
        Insert = 1,
        Delete = 2,
        Move = 3,
        Update = 4
    }
    export enum NSManagedObjectContextConcurrencyType {
        ConfinementConcurrencyType = 0,
        PrivateQueueConcurrencyType = 1,
        MainQueueConcurrencyType = 2
    }
    export enum NSMergePolicyType {
        ErrorMergePolicyType = 0,
        MergeByPropertyStoreTrumpMergePolicyType = 1,
        MergeByPropertyObjectTrumpMergePolicyType = 2,
        OverwriteMergePolicyType = 3,
        RollbackMergePolicyType = 4
    }
    export enum NSPersistentCloudKitContainerSchemaInitializationOptions {
        None = 0,
        DryRun = 2,
        PrintSchema = 4
    }
    export enum NSPersistentHistoryChangeType {
        Insert = 0,
        Update = 1,
        Delete = 2
    }
    export enum NSPersistentHistoryResultType {
        StatusOnly = 0,
        ObjectIDs = 1,
        Count = 2,
        TransactionsOnly = 3,
        ChangesOnly = 4,
        TransactionsAndChanges = 5
    }
    export enum NSPersistentStoreRequestType {
        FetchRequestType = 1,
        SaveRequestType = 2,
        BatchInsertRequestType = 5,
        BatchUpdateRequestType = 6,
        BatchDeleteRequestType = 7
    }
    export enum NSSnapshotEventType {
        UndoInsertion = 2,
        UndoDeletion = 4,
        UndoUpdate = 8,
        Rollback = 16,
        Refresh = 32,
        MergePolicy = 64
    }
    export enum CFCalendarUnit {
        kCFCalendarUnitEra = 2,
        kCFCalendarUnitYear = 4,
        kCFCalendarUnitMonth = 8,
        kCFCalendarUnitDay = 16,
        kCFCalendarUnitHour = 32,
        kCFCalendarUnitMinute = 64,
        kCFCalendarUnitSecond = 128,
        kCFCalendarUnitWeek = 256,
        kCFCalendarUnitWeekday = 512,
        kCFCalendarUnitWeekdayOrdinal = 1024,
        kCFCalendarUnitQuarter = 2048,
        kCFCalendarUnitWeekOfMonth = 4096,
        kCFCalendarUnitWeekOfYear = 8192,
        kCFCalendarUnitYearForWeekOfYear = 16384
    }
    export enum CFCharacterSetPredefinedSet {
        kCFCharacterSetControl = 1,
        kCFCharacterSetWhitespace = 2,
        kCFCharacterSetWhitespaceAndNewline = 3,
        kCFCharacterSetDecimalDigit = 4,
        kCFCharacterSetLetter = 5,
        kCFCharacterSetLowercaseLetter = 6,
        kCFCharacterSetUppercaseLetter = 7,
        kCFCharacterSetNonBase = 8,
        kCFCharacterSetDecomposable = 9,
        kCFCharacterSetAlphaNumeric = 10,
        kCFCharacterSetPunctuation = 11,
        kCFCharacterSetCapitalizedLetter = 13,
        kCFCharacterSetSymbol = 14,
        kCFCharacterSetNewline = 15,
        kCFCharacterSetIllegal = 12
    }
    export enum CFComparisonResult {
        kCFCompareLessThan = -1,
        kCFCompareEqualTo = 0,
        kCFCompareGreaterThan = 1
    }
    export enum CFDataSearchFlags {
        kCFDataSearchBackwards = 1,
        kCFDataSearchAnchored = 2
    }
    export enum CFDateFormatterStyle {
        kCFDateFormatterNoStyle = 0,
        kCFDateFormatterShortStyle = 1,
        kCFDateFormatterMediumStyle = 2,
        kCFDateFormatterLongStyle = 3,
        kCFDateFormatterFullStyle = 4
    }
    export enum CFFileSecurityClearOptions {
        kCFFileSecurityClearOwner = 1,
        kCFFileSecurityClearGroup = 2,
        kCFFileSecurityClearMode = 4,
        kCFFileSecurityClearOwnerUUID = 8,
        kCFFileSecurityClearGroupUUID = 16,
        kCFFileSecurityClearAccessControlList = 32
    }
    export enum CFGregorianUnitFlags {
        kCFGregorianUnitsYears = 1,
        kCFGregorianUnitsMonths = 2,
        kCFGregorianUnitsDays = 4,
        kCFGregorianUnitsHours = 8,
        kCFGregorianUnitsMinutes = 16,
        kCFGregorianUnitsSeconds = 32,
        kCFGregorianAllUnits = 16777215
    }
    export enum CFISO8601DateFormatOptions {
        kCFISO8601DateFormatWithYear = 1,
        kCFISO8601DateFormatWithMonth = 2,
        kCFISO8601DateFormatWithWeekOfYear = 4,
        kCFISO8601DateFormatWithDay = 16,
        kCFISO8601DateFormatWithTime = 32,
        kCFISO8601DateFormatWithTimeZone = 64,
        kCFISO8601DateFormatWithSpaceBetweenDateAndTime = 128,
        kCFISO8601DateFormatWithDashSeparatorInDate = 256,
        kCFISO8601DateFormatWithColonSeparatorInTime = 512,
        kCFISO8601DateFormatWithColonSeparatorInTimeZone = 1024,
        kCFISO8601DateFormatWithFractionalSeconds = 2048,
        kCFISO8601DateFormatWithFullDate = 275,
        kCFISO8601DateFormatWithFullTime = 1632,
        kCFISO8601DateFormatWithInternetDateTime = 1907
    }
    export enum CFLocaleLanguageDirection {
        kCFLocaleLanguageDirectionUnknown = 0,
        kCFLocaleLanguageDirectionLeftToRight = 1,
        kCFLocaleLanguageDirectionRightToLeft = 2,
        kCFLocaleLanguageDirectionTopToBottom = 3,
        kCFLocaleLanguageDirectionBottomToTop = 4
    }
    export enum CFNotificationSuspensionBehavior {
        Drop = 1,
        Coalesce = 2,
        Hold = 3,
        DeliverImmediately = 4
    }
    export enum CFNumberFormatterOptionFlags {
        kCFNumberFormatterParseIntegersOnly = 1
    }
    export enum CFNumberFormatterPadPosition {
        kCFNumberFormatterPadBeforePrefix = 0,
        kCFNumberFormatterPadAfterPrefix = 1,
        kCFNumberFormatterPadBeforeSuffix = 2,
        kCFNumberFormatterPadAfterSuffix = 3
    }
    export enum CFNumberFormatterRoundingMode {
        kCFNumberFormatterRoundCeiling = 0,
        kCFNumberFormatterRoundFloor = 1,
        kCFNumberFormatterRoundDown = 2,
        kCFNumberFormatterRoundUp = 3,
        kCFNumberFormatterRoundHalfEven = 4,
        kCFNumberFormatterRoundHalfDown = 5,
        kCFNumberFormatterRoundHalfUp = 6
    }
    export enum CFNumberFormatterStyle {
        kCFNumberFormatterNoStyle = 0,
        kCFNumberFormatterDecimalStyle = 1,
        kCFNumberFormatterCurrencyStyle = 2,
        kCFNumberFormatterPercentStyle = 3,
        kCFNumberFormatterScientificStyle = 4,
        kCFNumberFormatterSpellOutStyle = 5,
        kCFNumberFormatterOrdinalStyle = 6,
        kCFNumberFormatterCurrencyISOCodeStyle = 8,
        kCFNumberFormatterCurrencyPluralStyle = 9,
        kCFNumberFormatterCurrencyAccountingStyle = 10
    }
    export enum CFNumberType {
        kCFNumberSInt8Type = 1,
        kCFNumberSInt16Type = 2,
        kCFNumberSInt32Type = 3,
        kCFNumberSInt64Type = 4,
        kCFNumberFloat32Type = 5,
        kCFNumberFloat64Type = 6,
        kCFNumberCharType = 7,
        kCFNumberShortType = 8,
        kCFNumberIntType = 9,
        kCFNumberLongType = 10,
        kCFNumberLongLongType = 11,
        kCFNumberFloatType = 12,
        kCFNumberDoubleType = 13,
        kCFNumberCFIndexType = 14,
        kCFNumberNSIntegerType = 15,
        kCFNumberCGFloatType = 16,
        kCFNumberMaxType = 16
    }
    export enum CFPropertyListFormat {
        kCFPropertyListOpenStepFormat = 1,
        kCFPropertyListXMLFormat_v1_0 = 100,
        kCFPropertyListBinaryFormat_v1_0 = 200
    }
    export enum CFPropertyListMutabilityOptions {
        kCFPropertyListImmutable = 0,
        kCFPropertyListMutableContainers = 1,
        kCFPropertyListMutableContainersAndLeaves = 2
    }
    export enum CFRunLoopActivity {
        kCFRunLoopEntry = 1,
        kCFRunLoopBeforeTimers = 2,
        kCFRunLoopBeforeSources = 4,
        kCFRunLoopBeforeWaiting = 32,
        kCFRunLoopAfterWaiting = 64,
        kCFRunLoopExit = 128,
        kCFRunLoopAllActivities = 268435455
    }
    export enum CFRunLoopRunResult {
        kCFRunLoopRunFinished = 1,
        kCFRunLoopRunStopped = 2,
        kCFRunLoopRunTimedOut = 3,
        kCFRunLoopRunHandledSource = 4
    }
    export enum CFSocketCallBackType {
        kCFSocketNoCallBack = 0,
        kCFSocketReadCallBack = 1,
        kCFSocketAcceptCallBack = 2,
        kCFSocketDataCallBack = 3,
        kCFSocketConnectCallBack = 4,
        kCFSocketWriteCallBack = 8
    }
    export enum CFSocketError {
        kCFSocketSuccess = 0,
        kCFSocketError = -1,
        kCFSocketTimeout = -2
    }
    export enum CFStreamErrorDomain {
        kCFStreamErrorDomainCustom = -1,
        kCFStreamErrorDomainPOSIX = 1,
        kCFStreamErrorDomainMacOSStatus = 2
    }
    export enum CFStreamEventType {
        kCFStreamEventNone = 0,
        kCFStreamEventOpenCompleted = 1,
        kCFStreamEventHasBytesAvailable = 2,
        kCFStreamEventCanAcceptBytes = 4,
        kCFStreamEventErrorOccurred = 8,
        kCFStreamEventEndEncountered = 16
    }
    export enum CFStreamStatus {
        kCFStreamStatusNotOpen = 0,
        kCFStreamStatusOpening = 1,
        kCFStreamStatusOpen = 2,
        kCFStreamStatusReading = 3,
        kCFStreamStatusWriting = 4,
        kCFStreamStatusAtEnd = 5,
        kCFStreamStatusClosed = 6,
        kCFStreamStatusError = 7
    }
    export enum CFStringBuiltInEncodings {
        kCFStringEncodingMacRoman = 0,
        kCFStringEncodingWindowsLatin1 = 1280,
        kCFStringEncodingISOLatin1 = 513,
        kCFStringEncodingNextStepLatin = 2817,
        kCFStringEncodingASCII = 1536,
        kCFStringEncodingUnicode = 256,
        kCFStringEncodingUTF8 = 134217984,
        kCFStringEncodingNonLossyASCII = 3071,
        kCFStringEncodingUTF16 = 256,
        kCFStringEncodingUTF16BE = 268435712,
        kCFStringEncodingUTF16LE = 335544576,
        kCFStringEncodingUTF32 = 201326848,
        kCFStringEncodingUTF32BE = 402653440,
        kCFStringEncodingUTF32LE = 469762304
    }
    export enum CFStringCompareFlags {
        kCFCompareCaseInsensitive = 1,
        kCFCompareBackwards = 4,
        kCFCompareAnchored = 8,
        kCFCompareNonliteral = 16,
        kCFCompareLocalized = 32,
        kCFCompareNumerically = 64,
        kCFCompareDiacriticInsensitive = 128,
        kCFCompareWidthInsensitive = 256,
        kCFCompareForcedOrdering = 512
    }
    export enum CFStringEncodings {
        kCFStringEncodingMacJapanese = 1,
        kCFStringEncodingMacChineseTrad = 2,
        kCFStringEncodingMacKorean = 3,
        kCFStringEncodingMacArabic = 4,
        kCFStringEncodingMacHebrew = 5,
        kCFStringEncodingMacGreek = 6,
        kCFStringEncodingMacCyrillic = 7,
        kCFStringEncodingMacDevanagari = 9,
        kCFStringEncodingMacGurmukhi = 10,
        kCFStringEncodingMacGujarati = 11,
        kCFStringEncodingMacOriya = 12,
        kCFStringEncodingMacBengali = 13,
        kCFStringEncodingMacTamil = 14,
        kCFStringEncodingMacTelugu = 15,
        kCFStringEncodingMacKannada = 16,
        kCFStringEncodingMacMalayalam = 17,
        kCFStringEncodingMacSinhalese = 18,
        kCFStringEncodingMacBurmese = 19,
        kCFStringEncodingMacKhmer = 20,
        kCFStringEncodingMacThai = 21,
        kCFStringEncodingMacLaotian = 22,
        kCFStringEncodingMacGeorgian = 23,
        kCFStringEncodingMacArmenian = 24,
        kCFStringEncodingMacChineseSimp = 25,
        kCFStringEncodingMacTibetan = 26,
        kCFStringEncodingMacMongolian = 27,
        kCFStringEncodingMacEthiopic = 28,
        kCFStringEncodingMacCentralEurRoman = 29,
        kCFStringEncodingMacVietnamese = 30,
        kCFStringEncodingMacExtArabic = 31,
        kCFStringEncodingMacSymbol = 33,
        kCFStringEncodingMacDingbats = 34,
        kCFStringEncodingMacTurkish = 35,
        kCFStringEncodingMacCroatian = 36,
        kCFStringEncodingMacIcelandic = 37,
        kCFStringEncodingMacRomanian = 38,
        kCFStringEncodingMacCeltic = 39,
        kCFStringEncodingMacGaelic = 40,
        kCFStringEncodingMacFarsi = 140,
        kCFStringEncodingMacUkrainian = 152,
        kCFStringEncodingMacInuit = 236,
        kCFStringEncodingMacVT100 = 252,
        kCFStringEncodingMacHFS = 255,
        kCFStringEncodingISOLatin2 = 514,
        kCFStringEncodingISOLatin3 = 515,
        kCFStringEncodingISOLatin4 = 516,
        kCFStringEncodingISOLatinCyrillic = 517,
        kCFStringEncodingISOLatinArabic = 518,
        kCFStringEncodingISOLatinGreek = 519,
        kCFStringEncodingISOLatinHebrew = 520,
        kCFStringEncodingISOLatin5 = 521,
        kCFStringEncodingISOLatin6 = 522,
        kCFStringEncodingISOLatinThai = 523,
        kCFStringEncodingISOLatin7 = 525,
        kCFStringEncodingISOLatin8 = 526,
        kCFStringEncodingISOLatin9 = 527,
        kCFStringEncodingISOLatin10 = 528,
        kCFStringEncodingDOSLatinUS = 1024,
        kCFStringEncodingDOSGreek = 1029,
        kCFStringEncodingDOSBalticRim = 1030,
        kCFStringEncodingDOSLatin1 = 1040,
        kCFStringEncodingDOSGreek1 = 1041,
        kCFStringEncodingDOSLatin2 = 1042,
        kCFStringEncodingDOSCyrillic = 1043,
        kCFStringEncodingDOSTurkish = 1044,
        kCFStringEncodingDOSPortuguese = 1045,
        kCFStringEncodingDOSIcelandic = 1046,
        kCFStringEncodingDOSHebrew = 1047,
        kCFStringEncodingDOSCanadianFrench = 1048,
        kCFStringEncodingDOSArabic = 1049,
        kCFStringEncodingDOSNordic = 1050,
        kCFStringEncodingDOSRussian = 1051,
        kCFStringEncodingDOSGreek2 = 1052,
        kCFStringEncodingDOSThai = 1053,
        kCFStringEncodingDOSJapanese = 1056,
        kCFStringEncodingDOSChineseSimplif = 1057,
        kCFStringEncodingDOSKorean = 1058,
        kCFStringEncodingDOSChineseTrad = 1059,
        kCFStringEncodingWindowsLatin2 = 1281,
        kCFStringEncodingWindowsCyrillic = 1282,
        kCFStringEncodingWindowsGreek = 1283,
        kCFStringEncodingWindowsLatin5 = 1284,
        kCFStringEncodingWindowsHebrew = 1285,
        kCFStringEncodingWindowsArabic = 1286,
        kCFStringEncodingWindowsBalticRim = 1287,
        kCFStringEncodingWindowsVietnamese = 1288,
        kCFStringEncodingWindowsKoreanJohab = 1296,
        kCFStringEncodingANSEL = 1537,
        kCFStringEncodingJIS_X0201_76 = 1568,
        kCFStringEncodingJIS_X0208_83 = 1569,
        kCFStringEncodingJIS_X0208_90 = 1570,
        kCFStringEncodingJIS_X0212_90 = 1571,
        kCFStringEncodingJIS_C6226_78 = 1572,
        kCFStringEncodingShiftJIS_X0213 = 1576,
        kCFStringEncodingShiftJIS_X0213_MenKuTen = 1577,
        kCFStringEncodingGB_2312_80 = 1584,
        kCFStringEncodingGBK_95 = 1585,
        kCFStringEncodingGB_18030_2000 = 1586,
        kCFStringEncodingKSC_5601_87 = 1600,
        kCFStringEncodingKSC_5601_92_Johab = 1601,
        kCFStringEncodingCNS_11643_92_P1 = 1617,
        kCFStringEncodingCNS_11643_92_P2 = 1618,
        kCFStringEncodingCNS_11643_92_P3 = 1619,
        kCFStringEncodingISO_2022_JP = 2080,
        kCFStringEncodingISO_2022_JP_2 = 2081,
        kCFStringEncodingISO_2022_JP_1 = 2082,
        kCFStringEncodingISO_2022_JP_3 = 2083,
        kCFStringEncodingISO_2022_CN = 2096,
        kCFStringEncodingISO_2022_CN_EXT = 2097,
        kCFStringEncodingISO_2022_KR = 2112,
        kCFStringEncodingEUC_JP = 2336,
        kCFStringEncodingEUC_CN = 2352,
        kCFStringEncodingEUC_TW = 2353,
        kCFStringEncodingEUC_KR = 2368,
        kCFStringEncodingShiftJIS = 2561,
        kCFStringEncodingKOI8_R = 2562,
        kCFStringEncodingBig5 = 2563,
        kCFStringEncodingMacRomanLatin1 = 2564,
        kCFStringEncodingHZ_GB_2312 = 2565,
        kCFStringEncodingBig5_HKSCS_1999 = 2566,
        kCFStringEncodingVISCII = 2567,
        kCFStringEncodingKOI8_U = 2568,
        kCFStringEncodingBig5_E = 2569,
        kCFStringEncodingNextStepJapanese = 2818,
        kCFStringEncodingEBCDIC_US = 3073,
        kCFStringEncodingEBCDIC_CP037 = 3074,
        kCFStringEncodingUTF7 = 67109120,
        kCFStringEncodingUTF7_IMAP = 2576,
        kCFStringEncodingShiftJIS_X0213_00 = 1576
    }
    export enum CFStringNormalizationForm {
        kCFStringNormalizationFormD = 0,
        kCFStringNormalizationFormKD = 1,
        kCFStringNormalizationFormC = 2,
        kCFStringNormalizationFormKC = 3
    }
    export enum CFStringTokenizerTokenType {
        kCFStringTokenizerTokenNone = 0,
        kCFStringTokenizerTokenNormal = 1,
        kCFStringTokenizerTokenHasSubTokensMask = 2,
        kCFStringTokenizerTokenHasDerivedSubTokensMask = 4,
        kCFStringTokenizerTokenHasHasNumbersMask = 8,
        kCFStringTokenizerTokenHasNonLettersMask = 16,
        kCFStringTokenizerTokenIsCJWordMask = 32
    }
    export enum CFTimeZoneNameStyle {
        kCFTimeZoneNameStyleStandard = 0,
        kCFTimeZoneNameStyleShortStandard = 1,
        kCFTimeZoneNameStyleDaylightSaving = 2,
        kCFTimeZoneNameStyleShortDaylightSaving = 3,
        kCFTimeZoneNameStyleGeneric = 4,
        kCFTimeZoneNameStyleShortGeneric = 5
    }
    export enum CFURLBookmarkCreationOptions {
        kCFURLBookmarkCreationMinimalBookmarkMask = 512,
        kCFURLBookmarkCreationSuitableForBookmarkFile = 1024,
        kCFURLBookmarkCreationWithSecurityScope = 2048,
        kCFURLBookmarkCreationSecurityScopeAllowOnlyReadAccess = 4096,
        kCFURLBookmarkCreationPreferFileIDResolutionMask = 256
    }
    export enum CFURLBookmarkResolutionOptions {
        kCFURLBookmarkResolutionWithoutUIMask = 256,
        kCFURLBookmarkResolutionWithoutMountingMask = 512,
        kCFURLBookmarkResolutionWithSecurityScope = 1024,
        kCFBookmarkResolutionWithoutUIMask = 256,
        kCFBookmarkResolutionWithoutMountingMask = 512
    }
    export enum CFURLComponentType {
        kCFURLComponentScheme = 1,
        kCFURLComponentNetLocation = 2,
        kCFURLComponentPath = 3,
        kCFURLComponentResourceSpecifier = 4,
        kCFURLComponentUser = 5,
        kCFURLComponentPassword = 6,
        kCFURLComponentUserInfo = 7,
        kCFURLComponentHost = 8,
        kCFURLComponentPort = 9,
        kCFURLComponentParameterString = 10,
        kCFURLComponentQuery = 11,
        kCFURLComponentFragment = 12
    }
    export enum CFURLEnumeratorOptions {
        kCFURLEnumeratorDefaultBehavior = 0,
        kCFURLEnumeratorDescendRecursively = 1,
        kCFURLEnumeratorSkipInvisibles = 2,
        kCFURLEnumeratorGenerateFileReferenceURLs = 4,
        kCFURLEnumeratorSkipPackageContents = 8,
        kCFURLEnumeratorIncludeDirectoriesPreOrder = 16,
        kCFURLEnumeratorIncludeDirectoriesPostOrder = 32,
        kCFURLEnumeratorGenerateRelativePathURLs = 64
    }
    export enum CFURLEnumeratorResult {
        kCFURLEnumeratorSuccess = 1,
        kCFURLEnumeratorEnd = 2,
        kCFURLEnumeratorError = 3,
        kCFURLEnumeratorDirectoryPostOrderSuccess = 4
    }
    export enum CFURLPathStyle {
        kCFURLPOSIXPathStyle = 0,
        kCFURLHFSPathStyle = 1,
        kCFURLWindowsPathStyle = 2
    }
    export enum CFXMLEntityTypeCode {
        kCFXMLEntityTypeParameter = 0,
        kCFXMLEntityTypeParsedInternal = 1,
        kCFXMLEntityTypeParsedExternal = 2,
        kCFXMLEntityTypeUnparsed = 3,
        kCFXMLEntityTypeCharacter = 4
    }
    export enum CFXMLNodeTypeCode {
        kCFXMLNodeTypeDocument = 1,
        kCFXMLNodeTypeElement = 2,
        kCFXMLNodeTypeAttribute = 3,
        kCFXMLNodeTypeProcessingInstruction = 4,
        kCFXMLNodeTypeComment = 5,
        kCFXMLNodeTypeText = 6,
        kCFXMLNodeTypeCDATASection = 7,
        kCFXMLNodeTypeDocumentFragment = 8,
        kCFXMLNodeTypeEntity = 9,
        kCFXMLNodeTypeEntityReference = 10,
        kCFXMLNodeTypeDocumentType = 11,
        kCFXMLNodeTypeWhitespace = 12,
        kCFXMLNodeTypeNotation = 13,
        kCFXMLNodeTypeElementTypeDeclaration = 14,
        kCFXMLNodeTypeAttributeListDeclaration = 15
    }
    export enum CFXMLParserOptions {
        kCFXMLParserValidateDocument = 1,
        kCFXMLParserSkipMetaData = 2,
        kCFXMLParserReplacePhysicalEntities = 4,
        kCFXMLParserSkipWhitespace = 8,
        kCFXMLParserResolveExternalEntities = 16,
        kCFXMLParserAddImpliedAttributes = 32,
        kCFXMLParserAllOptions = 16777215,
        kCFXMLParserNoOptions = 0
    }
    export enum CFXMLParserStatusCode {
        kCFXMLStatusParseNotBegun = -2,
        kCFXMLStatusParseInProgress = -1,
        kCFXMLStatusParseSuccessful = 0,
        kCFXMLErrorUnexpectedEOF = 1,
        kCFXMLErrorUnknownEncoding = 2,
        kCFXMLErrorEncodingConversionFailure = 3,
        kCFXMLErrorMalformedProcessingInstruction = 4,
        kCFXMLErrorMalformedDTD = 5,
        kCFXMLErrorMalformedName = 6,
        kCFXMLErrorMalformedCDSect = 7,
        kCFXMLErrorMalformedCloseTag = 8,
        kCFXMLErrorMalformedStartTag = 9,
        kCFXMLErrorMalformedDocument = 10,
        kCFXMLErrorElementlessDocument = 11,
        kCFXMLErrorMalformedComment = 12,
        kCFXMLErrorMalformedCharacterReference = 13,
        kCFXMLErrorMalformedParsedCharacterData = 14,
        kCFXMLErrorNoData = 15
    }
    export enum __CFByteOrder {
        CFByteOrderUnknown = 0,
        CFByteOrderLittleEndian = 1,
        CFByteOrderBigEndian = 2
    }
    export enum CGBitmapInfo {
        kCGBitmapAlphaInfoMask = 31,
        kCGBitmapFloatInfoMask = 3840,
        kCGBitmapFloatComponents = 256,
        kCGBitmapByteOrderMask = 28672,
        kCGBitmapByteOrderDefault = 0,
        kCGBitmapByteOrder16Little = 4096,
        kCGBitmapByteOrder32Little = 8192,
        kCGBitmapByteOrder16Big = 12288,
        kCGBitmapByteOrder32Big = 16384
    }
    export enum CGBlendMode {
        kCGBlendModeNormal = 0,
        kCGBlendModeMultiply = 1,
        kCGBlendModeScreen = 2,
        kCGBlendModeOverlay = 3,
        kCGBlendModeDarken = 4,
        kCGBlendModeLighten = 5,
        kCGBlendModeColorDodge = 6,
        kCGBlendModeColorBurn = 7,
        kCGBlendModeSoftLight = 8,
        kCGBlendModeHardLight = 9,
        kCGBlendModeDifference = 10,
        kCGBlendModeExclusion = 11,
        kCGBlendModeHue = 12,
        kCGBlendModeSaturation = 13,
        kCGBlendModeColor = 14,
        kCGBlendModeLuminosity = 15,
        kCGBlendModeClear = 16,
        kCGBlendModeCopy = 17,
        kCGBlendModeSourceIn = 18,
        kCGBlendModeSourceOut = 19,
        kCGBlendModeSourceAtop = 20,
        kCGBlendModeDestinationOver = 21,
        kCGBlendModeDestinationIn = 22,
        kCGBlendModeDestinationOut = 23,
        kCGBlendModeDestinationAtop = 24,
        kCGBlendModeXOR = 25,
        kCGBlendModePlusDarker = 26,
        kCGBlendModePlusLighter = 27
    }
    export enum CGCaptureOptions {
        kCGCaptureNoOptions = 0,
        kCGCaptureNoFill = 1
    }
    export enum CGColorConversionInfoTransformType {
        kCGColorConversionTransformFromSpace = 0,
        kCGColorConversionTransformToSpace = 1,
        kCGColorConversionTransformApplySpace = 2
    }
    export enum CGColorRenderingIntent {
        kCGRenderingIntentDefault = 0,
        kCGRenderingIntentAbsoluteColorimetric = 1,
        kCGRenderingIntentRelativeColorimetric = 2,
        kCGRenderingIntentPerceptual = 3,
        kCGRenderingIntentSaturation = 4
    }
    export enum CGColorSpaceModel {
        kCGColorSpaceModelUnknown = -1,
        kCGColorSpaceModelMonochrome = 0,
        kCGColorSpaceModelRGB = 1,
        kCGColorSpaceModelCMYK = 2,
        kCGColorSpaceModelLab = 3,
        kCGColorSpaceModelDeviceN = 4,
        kCGColorSpaceModelIndexed = 5,
        kCGColorSpaceModelPattern = 6,
        kCGColorSpaceModelXYZ = 7
    }
    export enum CGConfigureOption {
        kCGConfigureForAppOnly = 0,
        kCGConfigureForSession = 1,
        kCGConfigurePermanently = 2
    }
    export enum CGDisplayChangeSummaryFlags {
        kCGDisplayBeginConfigurationFlag = 1,
        kCGDisplayMovedFlag = 2,
        kCGDisplaySetMainFlag = 4,
        kCGDisplaySetModeFlag = 8,
        kCGDisplayAddFlag = 16,
        kCGDisplayRemoveFlag = 32,
        kCGDisplayEnabledFlag = 256,
        kCGDisplayDisabledFlag = 512,
        kCGDisplayMirrorFlag = 1024,
        kCGDisplayUnMirrorFlag = 2048,
        kCGDisplayDesktopShapeChangedFlag = 4096
    }
    export enum CGDisplayStreamFrameStatus {
        kCGDisplayStreamFrameStatusFrameComplete = 0,
        kCGDisplayStreamFrameStatusFrameIdle = 1,
        kCGDisplayStreamFrameStatusFrameBlank = 2,
        kCGDisplayStreamFrameStatusStopped = 3
    }
    export enum CGDisplayStreamUpdateRectType {
        kCGDisplayStreamUpdateRefreshedRects = 0,
        kCGDisplayStreamUpdateMovedRects = 1,
        kCGDisplayStreamUpdateDirtyRects = 2,
        kCGDisplayStreamUpdateReducedDirtyRects = 3
    }
    export enum CGError {
        kCGErrorSuccess = 0,
        kCGErrorFailure = 1000,
        kCGErrorIllegalArgument = 1001,
        kCGErrorInvalidConnection = 1002,
        kCGErrorInvalidContext = 1003,
        kCGErrorCannotComplete = 1004,
        kCGErrorNotImplemented = 1006,
        kCGErrorRangeCheck = 1007,
        kCGErrorTypeCheck = 1008,
        kCGErrorInvalidOperation = 1010,
        kCGErrorNoneAvailable = 1011
    }
    export enum CGEventField {
        kCGMouseEventNumber = 0,
        kCGMouseEventClickState = 1,
        kCGMouseEventPressure = 2,
        kCGMouseEventButtonNumber = 3,
        kCGMouseEventDeltaX = 4,
        kCGMouseEventDeltaY = 5,
        kCGMouseEventInstantMouser = 6,
        kCGMouseEventSubtype = 7,
        kCGKeyboardEventAutorepeat = 8,
        kCGKeyboardEventKeycode = 9,
        kCGKeyboardEventKeyboardType = 10,
        kCGScrollWheelEventDeltaAxis1 = 11,
        kCGScrollWheelEventDeltaAxis2 = 12,
        kCGScrollWheelEventDeltaAxis3 = 13,
        kCGScrollWheelEventFixedPtDeltaAxis1 = 93,
        kCGScrollWheelEventFixedPtDeltaAxis2 = 94,
        kCGScrollWheelEventFixedPtDeltaAxis3 = 95,
        kCGScrollWheelEventPointDeltaAxis1 = 96,
        kCGScrollWheelEventPointDeltaAxis2 = 97,
        kCGScrollWheelEventPointDeltaAxis3 = 98,
        kCGScrollWheelEventScrollPhase = 99,
        kCGScrollWheelEventScrollCount = 100,
        kCGScrollWheelEventMomentumPhase = 123,
        kCGScrollWheelEventInstantMouser = 14,
        kCGTabletEventPointX = 15,
        kCGTabletEventPointY = 16,
        kCGTabletEventPointZ = 17,
        kCGTabletEventPointButtons = 18,
        kCGTabletEventPointPressure = 19,
        kCGTabletEventTiltX = 20,
        kCGTabletEventTiltY = 21,
        kCGTabletEventRotation = 22,
        kCGTabletEventTangentialPressure = 23,
        kCGTabletEventDeviceID = 24,
        kCGTabletEventVendor1 = 25,
        kCGTabletEventVendor2 = 26,
        kCGTabletEventVendor3 = 27,
        kCGTabletProximityEventVendorID = 28,
        kCGTabletProximityEventTabletID = 29,
        kCGTabletProximityEventPointerID = 30,
        kCGTabletProximityEventDeviceID = 31,
        kCGTabletProximityEventSystemTabletID = 32,
        kCGTabletProximityEventVendorPointerType = 33,
        kCGTabletProximityEventVendorPointerSerialNumber = 34,
        kCGTabletProximityEventVendorUniqueID = 35,
        kCGTabletProximityEventCapabilityMask = 36,
        kCGTabletProximityEventPointerType = 37,
        kCGTabletProximityEventEnterProximity = 38,
        kCGEventTargetProcessSerialNumber = 39,
        kCGEventTargetUnixProcessID = 40,
        kCGEventSourceUnixProcessID = 41,
        kCGEventSourceUserData = 42,
        kCGEventSourceUserID = 43,
        kCGEventSourceGroupID = 44,
        kCGEventSourceStateID = 45,
        kCGScrollWheelEventIsContinuous = 88,
        kCGMouseEventWindowUnderMousePointer = 91,
        kCGMouseEventWindowUnderMousePointerThatCanHandleThisEvent = 92,
        kCGEventUnacceleratedPointerMovementX = 170,
        kCGEventUnacceleratedPointerMovementY = 171
    }
    export enum CGEventFilterMask {
        kCGEventFilterMaskPermitLocalMouseEvents = 1,
        kCGEventFilterMaskPermitLocalKeyboardEvents = 2,
        kCGEventFilterMaskPermitSystemDefinedEvents = 4
    }
    export enum CGEventFlags {
        kCGEventFlagMaskAlphaShift = 65536,
        kCGEventFlagMaskShift = 131072,
        kCGEventFlagMaskControl = 262144,
        kCGEventFlagMaskAlternate = 524288,
        kCGEventFlagMaskCommand = 1048576,
        kCGEventFlagMaskHelp = 4194304,
        kCGEventFlagMaskSecondaryFn = 8388608,
        kCGEventFlagMaskNumericPad = 2097152,
        kCGEventFlagMaskNonCoalesced = 256
    }
    export enum CGEventMouseSubtype {
        kCGEventMouseSubtypeDefault = 0,
        kCGEventMouseSubtypeTabletPoint = 1,
        kCGEventMouseSubtypeTabletProximity = 2
    }
    export enum CGEventSourceStateID {
        kCGEventSourceStatePrivate = -1,
        kCGEventSourceStateCombinedSessionState = 0,
        kCGEventSourceStateHIDSystemState = 1
    }
    export enum CGEventSuppressionState {
        kCGEventSuppressionStateSuppressionInterval = 0,
        kCGEventSuppressionStateRemoteMouseDrag = 1,
        kCGNumberOfEventSuppressionStates = 2
    }
    export enum CGEventTapLocation {
        kCGHIDEventTap = 0,
        kCGSessionEventTap = 1,
        kCGAnnotatedSessionEventTap = 2
    }
    export enum CGEventTapOptions {
        kCGEventTapOptionDefault = 0,
        kCGEventTapOptionListenOnly = 1
    }
    export enum CGEventTapPlacement {
        kCGHeadInsertEventTap = 0,
        kCGTailAppendEventTap = 1
    }
    export enum CGEventType {
        kCGEventNull = 0,
        kCGEventLeftMouseDown = 1,
        kCGEventLeftMouseUp = 2,
        kCGEventRightMouseDown = 3,
        kCGEventRightMouseUp = 4,
        kCGEventMouseMoved = 5,
        kCGEventLeftMouseDragged = 6,
        kCGEventRightMouseDragged = 7,
        kCGEventKeyDown = 10,
        kCGEventKeyUp = 11,
        kCGEventFlagsChanged = 12,
        kCGEventScrollWheel = 22,
        kCGEventTabletPointer = 23,
        kCGEventTabletProximity = 24,
        kCGEventOtherMouseDown = 25,
        kCGEventOtherMouseUp = 26,
        kCGEventOtherMouseDragged = 27,
        kCGEventTapDisabledByTimeout = 4294967294,
        kCGEventTapDisabledByUserInput = 4294967295
    }
    export enum CGFontPostScriptFormat {
        kCGFontPostScriptFormatType1 = 1,
        kCGFontPostScriptFormatType3 = 3,
        kCGFontPostScriptFormatType42 = 42
    }
    export enum CGGesturePhase {
        kCGGesturePhaseNone = 0,
        kCGGesturePhaseBegan = 1,
        kCGGesturePhaseChanged = 2,
        kCGGesturePhaseEnded = 4,
        kCGGesturePhaseCancelled = 8,
        kCGGesturePhaseMayBegin = 128
    }
    export enum CGGlyphDeprecatedEnum {
        Min = 0,
        Max = 1
    }
    export enum CGGradientDrawingOptions {
        kCGGradientDrawsBeforeStartLocation = 1,
        kCGGradientDrawsAfterEndLocation = 2
    }
    export enum CGImageAlphaInfo {
        kCGImageAlphaNone = 0,
        kCGImageAlphaPremultipliedLast = 1,
        kCGImageAlphaPremultipliedFirst = 2,
        kCGImageAlphaLast = 3,
        kCGImageAlphaFirst = 4,
        kCGImageAlphaNoneSkipLast = 5,
        kCGImageAlphaNoneSkipFirst = 6,
        kCGImageAlphaOnly = 7
    }
    export enum CGImageByteOrderInfo {
        kCGImageByteOrderMask = 28672,
        kCGImageByteOrderDefault = 0,
        kCGImageByteOrder16Little = 4096,
        kCGImageByteOrder32Little = 8192,
        kCGImageByteOrder16Big = 12288,
        kCGImageByteOrder32Big = 16384
    }
    export enum CGImagePixelFormatInfo {
        kCGImagePixelFormatMask = 983040,
        kCGImagePixelFormatPacked = 0,
        kCGImagePixelFormatRGB555 = 65536,
        kCGImagePixelFormatRGB565 = 131072,
        kCGImagePixelFormatRGB101010 = 196608,
        kCGImagePixelFormatRGBCIF10 = 262144
    }
    export enum CGInterpolationQuality {
        kCGInterpolationDefault = 0,
        kCGInterpolationNone = 1,
        kCGInterpolationLow = 2,
        kCGInterpolationMedium = 4,
        kCGInterpolationHigh = 3
    }
    export enum CGLineCap {
        kCGLineCapButt = 0,
        kCGLineCapRound = 1,
        kCGLineCapSquare = 2
    }
    export enum CGLineJoin {
        kCGLineJoinMiter = 0,
        kCGLineJoinRound = 1,
        kCGLineJoinBevel = 2
    }
    export enum CGMomentumScrollPhase {
        kCGMomentumScrollPhaseNone = 0,
        kCGMomentumScrollPhaseBegin = 1,
        kCGMomentumScrollPhaseContinue = 2,
        kCGMomentumScrollPhaseEnd = 3
    }
    export enum CGMouseButton {
        kCGMouseButtonLeft = 0,
        kCGMouseButtonRight = 1,
        kCGMouseButtonCenter = 2
    }
    export enum CGPDFAccessPermissions {
        kCGPDFAllowsLowQualityPrinting = 1,
        kCGPDFAllowsHighQualityPrinting = 2,
        kCGPDFAllowsDocumentChanges = 4,
        kCGPDFAllowsDocumentAssembly = 8,
        kCGPDFAllowsContentCopying = 16,
        kCGPDFAllowsContentAccessibility = 32,
        kCGPDFAllowsCommenting = 64,
        kCGPDFAllowsFormFieldEntry = 128
    }
    export enum CGPDFBox {
        kCGPDFMediaBox = 0,
        kCGPDFCropBox = 1,
        kCGPDFBleedBox = 2,
        kCGPDFTrimBox = 3,
        kCGPDFArtBox = 4
    }
    export enum CGPDFDataFormat {
        Raw = 0,
        JPEGEncoded = 1,
        JPEG2000 = 2
    }
    export enum CGPDFObjectType {
        kCGPDFObjectTypeNull = 1,
        kCGPDFObjectTypeBoolean = 2,
        kCGPDFObjectTypeInteger = 3,
        kCGPDFObjectTypeReal = 4,
        kCGPDFObjectTypeName = 5,
        kCGPDFObjectTypeString = 6,
        kCGPDFObjectTypeArray = 7,
        kCGPDFObjectTypeDictionary = 8,
        kCGPDFObjectTypeStream = 9
    }
    export enum CGPDFTagType {
        Document = 100,
        Part = 101,
        Art = 102,
        Section = 103,
        Div = 104,
        BlockQuote = 105,
        Caption = 106,
        TOC = 107,
        TOCI = 108,
        Index = 109,
        NonStructure = 110,
        Private = 111,
        Paragraph = 200,
        Header = 201,
        Header1 = 202,
        Header2 = 203,
        Header3 = 204,
        Header4 = 205,
        Header5 = 206,
        Header6 = 207,
        List = 300,
        ListItem = 301,
        Label = 302,
        ListBody = 303,
        Table = 400,
        TableRow = 401,
        TableHeaderCell = 402,
        TableDataCell = 403,
        TableHeader = 404,
        TableBody = 405,
        TableFooter = 406,
        Span = 500,
        Quote = 501,
        Note = 502,
        Reference = 503,
        Bibliography = 504,
        Code = 505,
        Link = 506,
        Annotation = 507,
        Ruby = 600,
        RubyBaseText = 601,
        RubyAnnotationText = 602,
        RubyPunctuation = 603,
        Warichu = 604,
        WarichuText = 605,
        WarichuPunctiation = 606,
        Figure = 700,
        Formula = 701,
        Form = 702
    }
    export enum CGPathDrawingMode {
        kCGPathFill = 0,
        kCGPathEOFill = 1,
        kCGPathStroke = 2,
        kCGPathFillStroke = 3,
        kCGPathEOFillStroke = 4
    }
    export enum CGPathElementType {
        kCGPathElementMoveToPoint = 0,
        kCGPathElementAddLineToPoint = 1,
        kCGPathElementAddQuadCurveToPoint = 2,
        kCGPathElementAddCurveToPoint = 3,
        kCGPathElementCloseSubpath = 4
    }
    export enum CGPatternTiling {
        kCGPatternTilingNoDistortion = 0,
        kCGPatternTilingConstantSpacingMinimalDistortion = 1,
        kCGPatternTilingConstantSpacing = 2
    }
    export enum CGRectEdge {
        MinXEdge = 0,
        MinYEdge = 1,
        MaxXEdge = 2,
        MaxYEdge = 3
    }
    export enum CGScreenUpdateOperation {
        kCGScreenUpdateOperationRefresh = 0,
        kCGScreenUpdateOperationMove = 1,
        kCGScreenUpdateOperationReducedDirtyRectangleCount = 2147483648
    }
    export enum CGScrollEventUnit {
        kCGScrollEventUnitPixel = 0,
        kCGScrollEventUnitLine = 1
    }
    export enum CGScrollPhase {
        kCGScrollPhaseBegan = 1,
        kCGScrollPhaseChanged = 2,
        kCGScrollPhaseEnded = 4,
        kCGScrollPhaseCancelled = 8,
        kCGScrollPhaseMayBegin = 128
    }
    export enum CGTextDrawingMode {
        kCGTextFill = 0,
        kCGTextStroke = 1,
        kCGTextFillStroke = 2,
        kCGTextInvisible = 3,
        kCGTextFillClip = 4,
        kCGTextStrokeClip = 5,
        kCGTextFillStrokeClip = 6,
        kCGTextClip = 7
    }
    export enum CGWindowBackingType {
        kCGBackingStoreRetained = 0,
        kCGBackingStoreNonretained = 1,
        kCGBackingStoreBuffered = 2
    }
    export enum CGWindowImageOption {
        kCGWindowImageDefault = 0,
        kCGWindowImageBoundsIgnoreFraming = 1,
        kCGWindowImageShouldBeOpaque = 2,
        kCGWindowImageOnlyShadows = 4,
        kCGWindowImageBestResolution = 8,
        kCGWindowImageNominalResolution = 16
    }
    export enum CGWindowLevelKey {
        kCGBaseWindowLevelKey = 0,
        kCGMinimumWindowLevelKey = 1,
        kCGDesktopWindowLevelKey = 2,
        kCGBackstopMenuLevelKey = 3,
        kCGNormalWindowLevelKey = 4,
        kCGFloatingWindowLevelKey = 5,
        kCGTornOffMenuWindowLevelKey = 6,
        kCGDockWindowLevelKey = 7,
        kCGMainMenuWindowLevelKey = 8,
        kCGStatusWindowLevelKey = 9,
        kCGModalPanelWindowLevelKey = 10,
        kCGPopUpMenuWindowLevelKey = 11,
        kCGDraggingWindowLevelKey = 12,
        kCGScreenSaverWindowLevelKey = 13,
        kCGMaximumWindowLevelKey = 14,
        kCGOverlayWindowLevelKey = 15,
        kCGHelpWindowLevelKey = 16,
        kCGUtilityWindowLevelKey = 17,
        kCGDesktopIconWindowLevelKey = 18,
        kCGCursorWindowLevelKey = 19,
        kCGAssistiveTechHighWindowLevelKey = 20,
        kCGNumberOfWindowLevelKeys = 21
    }
    export enum CGWindowListOption {
        kCGWindowListOptionAll = 0,
        kCGWindowListOptionOnScreenOnly = 1,
        kCGWindowListOptionOnScreenAboveWindow = 2,
        kCGWindowListOptionOnScreenBelowWindow = 4,
        kCGWindowListOptionIncludingWindow = 8,
        kCGWindowListExcludeDesktopElements = 16
    }
    export enum CGWindowSharingType {
        kCGWindowSharingNone = 0,
        kCGWindowSharingReadOnly = 1,
        kCGWindowSharingReadWrite = 2
    }
    export enum CIDataMatrixCodeECCVersion {
        Version000 = 0,
        Version050 = 50,
        Version080 = 80,
        Version100 = 100,
        Version140 = 140,
        Version200 = 200
    }
    export enum CIQRCodeErrorCorrectionLevel {
        L = 76,
        M = 77,
        Q = 81,
        H = 72
    }
    export enum CIRenderDestinationAlphaMode {
        None = 0,
        Premultiplied = 1,
        Unpremultiplied = 2
    }
    export enum CMTimeFlags {
        kCMTimeFlags_Valid = 1,
        kCMTimeFlags_HasBeenRounded = 2,
        kCMTimeFlags_PositiveInfinity = 4,
        kCMTimeFlags_NegativeInfinity = 8,
        kCMTimeFlags_Indefinite = 16,
        kCMTimeFlags_ImpliedValueFlagsMask = 28
    }
    export enum CMTimeRoundingMethod {
        kCMTimeRoundingMethod_RoundHalfAwayFromZero = 1,
        kCMTimeRoundingMethod_RoundTowardZero = 2,
        kCMTimeRoundingMethod_RoundAwayFromZero = 3,
        kCMTimeRoundingMethod_QuickTime = 4,
        kCMTimeRoundingMethod_RoundTowardPositiveInfinity = 5,
        kCMTimeRoundingMethod_RoundTowardNegativeInfinity = 6,
        kCMTimeRoundingMethod_Default = 1
    }
    export enum AlignmentOptions {
        MinXInward = 1,
        MinYInward = 2,
        MaxXInward = 4,
        MaxYInward = 8,
        WidthInward = 16,
        HeightInward = 32,
        MinXOutward = 256,
        MinYOutward = 512,
        MaxXOutward = 1024,
        MaxYOutward = 2048,
        WidthOutward = 4096,
        HeightOutward = 8192,
        MinXNearest = 65536,
        MinYNearest = 131072,
        MaxXNearest = 262144,
        MaxYNearest = 524288,
        WidthNearest = 1048576,
        HeightNearest = 2097152,
        RectFlipped = -9223372036854776000,
        AllEdgesInward = 15,
        AllEdgesOutward = 3840,
        AllEdgesNearest = 983040
    }
    export enum NSBinarySearchingOptions {
        FirstEqual = 256,
        LastEqual = 512,
        InsertionIndex = 1024
    }
    export enum NSCollectionChangeType {
        Insert = 0,
        Remove = 1
    }
    export enum ComparisonResult {
        OrderedAscending = -1,
        OrderedSame = 0,
        OrderedDescending = 1
    }
    export enum NSEnumerationOptions {
        Concurrent = 1,
        Reverse = 2
    }
    export enum NSItemProviderFileOptions {
        OpenInPlace = 1
    }
    export enum NSItemProviderRepresentationVisibility {
        All = 0,
        Team = 1,
        Group = 2,
        OwnProcess = 3
    }
    export enum NSKeyValueChange {
        Setting = 1,
        Insertion = 2,
        Removal = 3,
        Replacement = 4
    }
    export enum NSKeyValueObservingOptions {
        New = 1,
        Old = 2,
        Initial = 4,
        Prior = 8
    }
    export enum NSKeyValueSetMutationKind {
        UnionSetMutation = 1,
        MinusSetMutation = 2,
        IntersectSetMutation = 3,
        SetSetMutation = 4
    }
    export enum NSLinguisticTaggerUnit {
        Word = 0,
        Sentence = 1,
        Paragraph = 2,
        Document = 3
    }
    export enum NSOrderedCollectionDifferenceCalculationOptions {
        OmitInsertedObjects = 1,
        OmitRemovedObjects = 2,
        InferMoves = 4
    }
    export enum QualityOfService {
        UserInteractive = 33,
        UserInitiated = 25,
        Utility = 17,
        Background = 9,
        Default = -1
    }
    export enum NSRectEdge {
        RectEdgeMinX = 0,
        RectEdgeMinY = 1,
        RectEdgeMaxX = 2,
        RectEdgeMaxY = 3,
        MinXEdge = 0,
        MinYEdge = 1,
        MaxXEdge = 2,
        MaxYEdge = 3
    }
    export enum NSSaveOptions {
        Yes = 0,
        No = 1,
        Ask = 2
    }
    export enum NSSortOptions {
        Concurrent = 1,
        Stable = 16
    }
    export enum NSURLErrorNetworkUnavailableReason {
        Cellular = 0,
        Expensive = 1,
        Constrained = 2
    }
    export enum NSURLSessionDelayedRequestDisposition {
        ContinueLoading = 0,
        UseNewRequest = 1,
        Cancel = 2
    }
    export enum NSURLSessionWebSocketMessageType {
        Data = 0,
        String = 1
    }
    export enum IKCameraDeviceViewDisplayMode {
        None = -1,
        Table = 0,
        Icon = 1
    }
    export enum IKCameraDeviceViewTransferMode {
        FileBased = 0,
        MemoryBased = 1
    }
    export enum IKDeviceBrowserViewDisplayMode {
        Table = 0,
        Outline = 1,
        Icon = 2
    }
    export enum IKImageBrowserCellState {
        StateNoImage = 0,
        StateInvalid = 1,
        StateReady = 2
    }
    export enum IKImageBrowserDropOperation {
        On = 0,
        Before = 1
    }
    export enum IKScannerDeviceViewDisplayMode {
        None = -1,
        Simple = 0,
        Advanced = 1
    }
    export enum IKScannerDeviceViewTransferMode {
        FileBased = 0,
        MemoryBased = 1
    }
    export enum QCPlugInExecutionMode {
        kQCPlugInExecutionModeProvider = 1,
        kQCPlugInExecutionModeProcessor = 2,
        kQCPlugInExecutionModeConsumer = 3
    }
    export enum QCPlugInTimeMode {
        kQCPlugInTimeModeNone = 0,
        kQCPlugInTimeModeIdle = 1,
        kQCPlugInTimeModeTimeBase = 2
    }
    export enum QLPreviewViewStyle {
        Normal = 0,
        Compact = 1
    }
    export enum CAAutoresizingMask {
        kCALayerNotSizable = 0,
        kCALayerMinXMargin = 1,
        kCALayerWidthSizable = 2,
        kCALayerMaxXMargin = 4,
        kCALayerMinYMargin = 8,
        kCALayerHeightSizable = 16,
        kCALayerMaxYMargin = 32
    }
    export enum CAConstraintAttribute {
        kCAConstraintMinX = 0,
        kCAConstraintMidX = 1,
        kCAConstraintMaxX = 2,
        kCAConstraintWidth = 3,
        kCAConstraintMinY = 4,
        kCAConstraintMidY = 5,
        kCAConstraintMaxY = 6,
        kCAConstraintHeight = 7
    }
    export enum CACornerMask {
        kCALayerMinXMinYCorner = 1,
        kCALayerMaxXMinYCorner = 2,
        kCALayerMinXMaxYCorner = 4,
        kCALayerMaxXMaxYCorner = 8
    }
    export enum CAEdgeAntialiasingMask {
        kCALayerLeftEdge = 1,
        kCALayerRightEdge = 2,
        kCALayerBottomEdge = 4,
        kCALayerTopEdge = 8
    }
}
declare namespace AVAssetExportSession {
    enum Status {
        Unknown = 0,
        Waiting = 1,
        Exporting = 2,
        Completed = 3,
        Failed = 4,
        Cancelled = 5
    }
}
declare namespace AVAssetImageGenerator {
    enum Result {
        Succeeded = 0,
        Failed = 1,
        Cancelled = 2
    }
    let cleanAperture: string;
    let encodedPixels: string;
    let productionAperture: string;
}
declare namespace AVAssetReader {
    enum Status {
        Unknown = 0,
        Reading = 1,
        Completed = 2,
        Failed = 3,
        Cancelled = 4
    }
}
declare namespace AVAssetTrack {
    let audioFallback: string;
    let chapterList: string;
    let forcedSubtitlesOnly: string;
    let metadataReferent: string;
    let selectionFollower: string;
    let timecode: string;
}
declare namespace AVAssetWriter {
    enum Status {
        Unknown = 0,
        Writing = 1,
        Completed = 2,
        Failed = 3,
        Cancelled = 4
    }
}
declare namespace AVAssetWriterInput {
    let beforeMainMediaDataNotInterleaved: string;
    let interleavedWithMainMediaData: string;
}
declare namespace AVAudioSession {
    enum CategoryOptions {
        MixWithOthers = 1,
        DuckOthers = 2,
        AllowBluetooth = 4,
        DefaultToSpeaker = 8,
        InterruptSpokenAudioAndMixWithOthers = 17,
        AllowBluetoothA2DP = 32,
        AllowAirPlay = 64
    }
    enum IOType {
        NotSpecified = 0,
        Aggregated = 1
    }
    enum InterruptionOptions {
        ShouldResume = 1
    }
    enum InterruptionType {
        Began = 1,
        Ended = 0
    }
    enum PortOverride {
        None = 0,
        Speaker = 1936747378
    }
    enum PromptStyle {
        None = 1852796517,
        Short = 1936224884,
        Normal = 1852992876
    }
    enum RecordPermission {
        Undetermined = 1970168948,
        Denied = 1684369017,
        Granted = 1735552628
    }
    enum RouteChangeReason {
        Unknown = 0,
        NewDeviceAvailable = 1,
        OldDeviceUnavailable = 2,
        CategoryChange = 3,
        Override = 4,
        WakeFromSleep = 6,
        NoSuitableRouteForCategory = 7,
        RouteConfigurationChange = 8
    }
    enum RouteSharingPolicy {
        Default = 0,
        LongFormAudio = 1,
        LongForm = 1,
        Independent = 2,
        LongFormVideo = 3
    }
    enum SetActiveOptions {
        NotifyOthersOnDeactivation = 1
    }
    enum SilenceSecondaryAudioHintType {
        Begin = 1,
        End = 0
    }
    let ambient: string;
    let audioProcessing: string;
    let multiRoute: string;
    let playAndRecord: string;
    let playback: string;
    let record: string;
    let soloAmbient: string;
    let interruptionNotification: string;
    let lower: string;
    let upper: string;
    let mediaServicesWereLostNotification: string;
    let mediaServicesWereResetNotification: string;
    let default_: string;
    let gameChat: string;
    let measurement: string;
    let moviePlayback: string;
    let spokenAudio: string;
    let videoChat: string;
    let videoRecording: string;
    let voiceChat: string;
    let voicePrompt: string;
    let back: string;
    let bottom: string;
    let front: string;
    let left: string;
    let right: string;
    let top: string;
    let cardioid: string;
    let omnidirectional: string;
    let subcardioid: string;
    let airPlay: string;
    let bluetoothA2DP: string;
    let bluetoothHFP: string;
    let bluetoothLE: string;
    let builtInMic: string;
    let builtInReceiver: string;
    let builtInSpeaker: string;
    let carAudio: string;
    let HDMI: string;
    let headphones: string;
    let headsetMic: string;
    let lineIn: string;
    let lineOut: string;
    let usbAudio: string;
    let routeChangeNotification: string;
    let silenceSecondaryAudioHintNotification: string;
}
declare namespace AVAudioTimePitchAlgorithm {
    let lowQualityZeroLatency: string;
    let spectral: string;
    let timeDomain: string;
    let varispeed: string;
}
declare namespace AVAudioUnitComponentManager {
    let registrationsChangedNotification: string;
}
declare namespace AVCaptureDevice {
    enum AutoFocusRangeRestriction {
        None = 0,
        Near = 1,
        Far = 2
    }
    enum Position {
        Unspecified = 0,
        Back = 1,
        Front = 2
    }
    enum TransportControlsPlaybackMode {
        NotPlayingMode = 0,
        PlayingMode = 1
    }
    enum ExposureMode {
        Locked = 0,
        AutoExpose = 1,
        ContinuousAutoExposure = 2,
        Custom = 3
    }
    enum FlashMode {
        Off = 0,
        On = 1,
        Auto = 2
    }
    enum FocusMode {
        Locked = 0,
        AutoFocus = 1,
        ContinuousAutoFocus = 2
    }
    enum LensStabilizationStatus {
        Unsupported = 0,
        Off = 1,
        Active = 2,
        OutOfRange = 3,
        Unavailable = 4
    }
    enum TorchMode {
        Off = 0,
        On = 1,
        Auto = 2
    }
    enum WhiteBalanceMode {
        Locked = 0,
        AutoWhiteBalance = 1,
        ContinuousAutoWhiteBalance = 2
    }
    let builtInDualCamera: string;
    let builtInDualWideCamera: string;
    let builtInDuoCamera: string;
    let builtInMicrophone: string;
    let builtInTelephotoCamera: string;
    let builtInTripleCamera: string;
    let builtInTrueDepthCamera: string;
    let builtInUltraWideCamera: string;
    let builtInWideAngleCamera: string;
    let externalUnknown: string;
    let currentExposureDuration: CMTime;
    let currentExposureTargetBias: number;
    let currentISO: number;
    let currentLensPosition: number;
    let maxAvailableTorchLevel: number;
}
declare namespace AVCaptureOutput {
    enum DataDroppedReason {
        None = 0,
        LateData = 1,
        OutOfBuffers = 2,
        Discontinuity = 3
    }
}
declare namespace AVCapturePhotoOutput {
    enum QualityPrioritization {
        Speed = 1,
        Balanced = 2,
        Quality = 3
    }
}
declare namespace AVCaptureSession {
    enum InterruptionReason {
        VideoDeviceNotAvailableInBackground = 1,
        AudioDeviceInUseByAnotherClient = 2,
        VideoDeviceInUseByAnotherClient = 3,
        VideoDeviceNotAvailableWithMultipleForegroundApps = 4,
        VideoDeviceNotAvailableDueToSystemPressure = 5
    }
    let hd1280x720: string;
    let hd1920x1080: string;
    let qvga320x240: string;
    let cif352x288: string;
    let hd4K3840x2160: string;
    let vga640x480: string;
    let qHD960x540: string;
    let high: string;
    let inputPriority: string;
    let low: string;
    let medium: string;
    let photo: string;
    let iFrame1280x720: string;
    let iFrame960x540: string;
}
declare namespace AVContentKeyRequest {
    enum Status {
        RequestingResponse = 0,
        ReceivedResponse = 1,
        Renewed = 2,
        Retried = 3,
        Cancelled = 4,
        Failed = 5
    }
    let receivedObsoleteContentKey: string;
    let receivedResponseWithExpiredLease: string;
    let timedOut: string;
}
declare namespace AVContentKeySessionServerPlaybackContextOption {
    let protocolVersions: string;
    let serverChallenge: string;
}
declare namespace AVContentKeySystem {
    let authorizationToken: string;
    let clearKey: string;
    let fairPlayStreaming: string;
}
declare namespace AVDepthData {
    enum Accuracy {
        Relative = 0,
        Absolute = 1
    }
    enum Quality {
        Low = 0,
        High = 1
    }
}
declare namespace AVFileType {
    let mobile3GPP: string;
    let mobile3GPP2: string;
    let ac3: string;
    let aifc: string;
    let aiff: string;
    let amr: string;
    let avci: string;
    let m4a: string;
    let m4v: string;
    let caf: string;
    let dng: string;
    let eac3: string;
    let heic: string;
    let heif: string;
    let jpg: string;
    let mp4: string;
    let mp3: string;
    let mov: string;
    let au: string;
    let tif: string;
    let wav: string;
}
declare namespace AVLayerVideoGravity {
    let resize: string;
    let resizeAspect: string;
    let resizeAspectFill: string;
}
declare namespace AVMediaCharacteristic {
    let audible: string;
    let containsAlphaChannel: string;
    let containsOnlyForcedSubtitles: string;
    let describesMusicAndSoundForAccessibility: string;
    let describesVideoForAccessibility: string;
    let dubbedTranslation: string;
    let easyToRead: string;
    let frameBased: string;
    let isAuxiliaryContent: string;
    let isMainProgramContent: string;
    let isOriginalContent: string;
    let languageTranslation: string;
    let legible: string;
    let transcribesSpokenDialogForAccessibility: string;
    let usesWideGamutColorSpace: string;
    let visual: string;
    let voiceOverTranslation: string;
}
declare namespace AVMediaType {
    let audio: string;
    let closedCaption: string;
    let depthData: string;
    let metadata: string;
    let metadataObject: string;
    let muxed: string;
    let subtitle: string;
    let text: string;
    let timecode: string;
    let video: string;
}
declare namespace AVMetadataExtraAttributeKey {
    let baseURI: string;
    let info: string;
    let valueURI: string;
}
declare namespace AVMetadataFormat {
    let hlsMetadata: string;
    let id3Metadata: string;
    let isoUserData: string;
    let quickTimeMetadata: string;
    let quickTimeUserData: string;
    let unknown: string;
    let iTunesMetadata: string;
}
declare namespace AVMetadataIdentifier {
    let commonIdentifierAlbumName: string;
    let commonIdentifierArtist: string;
    let commonIdentifierArtwork: string;
    let commonIdentifierAssetIdentifier: string;
    let commonIdentifierAuthor: string;
    let commonIdentifierContributor: string;
    let commonIdentifierCopyrights: string;
    let commonIdentifierCreationDate: string;
    let commonIdentifierCreator: string;
    let commonIdentifierDescription: string;
    let commonIdentifierFormat: string;
    let commonIdentifierLanguage: string;
    let commonIdentifierLastModifiedDate: string;
    let commonIdentifierLocation: string;
    let commonIdentifierMake: string;
    let commonIdentifierModel: string;
    let commonIdentifierPublisher: string;
    let commonIdentifierRelation: string;
    let commonIdentifierSoftware: string;
    let commonIdentifierSource: string;
    let commonIdentifierSubject: string;
    let commonIdentifierTitle: string;
    let commonIdentifierType: string;
    let identifier3GPUserDataAlbumAndTrack: string;
    let identifier3GPUserDataAuthor: string;
    let identifier3GPUserDataCollection: string;
    let identifier3GPUserDataCopyright: string;
    let identifier3GPUserDataDescription: string;
    let identifier3GPUserDataGenre: string;
    let identifier3GPUserDataKeywordList: string;
    let identifier3GPUserDataLocation: string;
    let identifier3GPUserDataMediaClassification: string;
    let identifier3GPUserDataMediaRating: string;
    let identifier3GPUserDataPerformer: string;
    let identifier3GPUserDataRecordingYear: string;
    let identifier3GPUserDataThumbnail: string;
    let identifier3GPUserDataTitle: string;
    let identifier3GPUserDataUserRating: string;
    let id3MetadataAlbumSortOrder: string;
    let id3MetadataAlbumTitle: string;
    let id3MetadataAttachedPicture: string;
    let id3MetadataAudioEncryption: string;
    let id3MetadataAudioSeekPointIndex: string;
    let id3MetadataBand: string;
    let id3MetadataBeatsPerMinute: string;
    let id3MetadataComments: string;
    let id3MetadataCommercial: string;
    let id3MetadataCommercialInformation: string;
    let id3MetadataComposer: string;
    let id3MetadataConductor: string;
    let id3MetadataContentGroupDescription: string;
    let id3MetadataContentType: string;
    let id3MetadataCopyright: string;
    let id3MetadataCopyrightInformation: string;
    let id3MetadataDate: string;
    let id3MetadataEncodedBy: string;
    let id3MetadataEncodedWith: string;
    let id3MetadataEncodingTime: string;
    let id3MetadataEncryption: string;
    let id3MetadataEqualization: string;
    let id3MetadataEqualization2: string;
    let id3MetadataEventTimingCodes: string;
    let id3MetadataFileOwner: string;
    let id3MetadataFileType: string;
    let id3MetadataGeneralEncapsulatedObject: string;
    let id3MetadataGroupIdentifier: string;
    let id3MetadataInitialKey: string;
    let id3MetadataInternationalStandardRecordingCode: string;
    let id3MetadataInternetRadioStationName: string;
    let id3MetadataInternetRadioStationOwner: string;
    let id3MetadataInvolvedPeopleList_v23: string;
    let id3MetadataInvolvedPeopleList_v24: string;
    let id3MetadataLanguage: string;
    let id3MetadataLeadPerformer: string;
    let id3MetadataLength: string;
    let id3MetadataLink: string;
    let id3MetadataLyricist: string;
    let id3MetadataMPEGLocationLookupTable: string;
    let id3MetadataMediaType: string;
    let id3MetadataModifiedBy: string;
    let id3MetadataMood: string;
    let id3MetadataMusicCDIdentifier: string;
    let id3MetadataMusicianCreditsList: string;
    let id3MetadataOfficialArtistWebpage: string;
    let id3MetadataOfficialAudioFileWebpage: string;
    let id3MetadataOfficialAudioSourceWebpage: string;
    let id3MetadataOfficialInternetRadioStationHomepage: string;
    let id3MetadataOfficialPublisherWebpage: string;
    let id3MetadataOriginalAlbumTitle: string;
    let id3MetadataOriginalArtist: string;
    let id3MetadataOriginalFilename: string;
    let id3MetadataOriginalLyricist: string;
    let id3MetadataOriginalReleaseTime: string;
    let id3MetadataOriginalReleaseYear: string;
    let id3MetadataOwnership: string;
    let id3MetadataPartOfASet: string;
    let id3MetadataPayment: string;
    let id3MetadataPerformerSortOrder: string;
    let id3MetadataPlayCounter: string;
    let id3MetadataPlaylistDelay: string;
    let id3MetadataPopularimeter: string;
    let id3MetadataPositionSynchronization: string;
    let id3MetadataPrivate: string;
    let id3MetadataProducedNotice: string;
    let id3MetadataPublisher: string;
    let id3MetadataRecommendedBufferSize: string;
    let id3MetadataRecordingDates: string;
    let id3MetadataRecordingTime: string;
    let id3MetadataRelativeVolumeAdjustment: string;
    let id3MetadataRelativeVolumeAdjustment2: string;
    let id3MetadataReleaseTime: string;
    let id3MetadataReverb: string;
    let id3MetadataSeek: string;
    let id3MetadataSetSubtitle: string;
    let id3MetadataSignature: string;
    let id3MetadataSize: string;
    let id3MetadataSubTitle: string;
    let id3MetadataSynchronizedLyric: string;
    let id3MetadataSynchronizedTempoCodes: string;
    let id3MetadataTaggingTime: string;
    let id3MetadataTermsOfUse: string;
    let id3MetadataTime: string;
    let id3MetadataTitleDescription: string;
    let id3MetadataTitleSortOrder: string;
    let id3MetadataTrackNumber: string;
    let id3MetadataUniqueFileIdentifier: string;
    let id3MetadataUnsynchronizedLyric: string;
    let id3MetadataUserText: string;
    let id3MetadataUserURL: string;
    let id3MetadataYear: string;
    let isoUserDataCopyright: string;
    let isoUserDataDate: string;
    let isoUserDataTaggedCharacteristic: string;
    let icyMetadataStreamTitle: string;
    let icyMetadataStreamURL: string;
    let quickTimeMetadataAlbum: string;
    let quickTimeMetadataArranger: string;
    let quickTimeMetadataArtist: string;
    let quickTimeMetadataArtwork: string;
    let quickTimeMetadataAuthor: string;
    let quickTimeMetadataAutoLivePhoto: string;
    let quickTimeMetadataCameraFrameReadoutTime: string;
    let quickTimeMetadataCameraIdentifier: string;
    let quickTimeMetadataCollectionUser: string;
    let quickTimeMetadataComment: string;
    let quickTimeMetadataComposer: string;
    let quickTimeMetadataContentIdentifier: string;
    let quickTimeMetadataCopyright: string;
    let quickTimeMetadataCreationDate: string;
    let quickTimeMetadataCredits: string;
    let quickTimeMetadataDescription: string;
    let quickTimeMetadataDetectedCatBody: string;
    let quickTimeMetadataDetectedDogBody: string;
    let quickTimeMetadataDetectedFace: string;
    let quickTimeMetadataDetectedHumanBody: string;
    let quickTimeMetadataDetectedSalientObject: string;
    let quickTimeMetadataDirectionFacing: string;
    let quickTimeMetadataDirectionMotion: string;
    let quickTimeMetadataDirector: string;
    let quickTimeMetadataDisplayName: string;
    let quickTimeMetadataEncodedBy: string;
    let quickTimeMetadataGenre: string;
    let quickTimeMetadataInformation: string;
    let quickTimeMetadataKeywords: string;
    let quickTimeMetadataLivePhotoVitalityScore: string;
    let quickTimeMetadataLivePhotoVitalityScoringVersion: string;
    let quickTimeMetadataLocationBody: string;
    let quickTimeMetadataLocationDate: string;
    let quickTimeMetadataLocationISO6709: string;
    let quickTimeMetadataLocationName: string;
    let quickTimeMetadataLocationNote: string;
    let quickTimeMetadataLocationRole: string;
    let quickTimeMetadataMake: string;
    let quickTimeMetadataModel: string;
    let quickTimeMetadataOriginalArtist: string;
    let quickTimeMetadataPerformer: string;
    let quickTimeMetadataPhonogramRights: string;
    let quickTimeMetadataPreferredAffineTransform: string;
    let quickTimeMetadataProducer: string;
    let quickTimeMetadataPublisher: string;
    let quickTimeMetadataRatingUser: string;
    let quickTimeMetadataSoftware: string;
    let quickTimeMetadataSpatialOverCaptureQualityScore: string;
    let quickTimeMetadataSpatialOverCaptureQualityScoringVersion: string;
    let quickTimeMetadataTitle: string;
    let quickTimeMetadataVideoOrientation: string;
    let quickTimeMetadataYear: string;
    let quickTimeMetadataiXML: string;
    let quickTimeUserDataAlbum: string;
    let quickTimeUserDataArranger: string;
    let quickTimeUserDataArtist: string;
    let quickTimeUserDataAuthor: string;
    let quickTimeUserDataChapter: string;
    let quickTimeUserDataComment: string;
    let quickTimeUserDataComposer: string;
    let quickTimeUserDataCopyright: string;
    let quickTimeUserDataCreationDate: string;
    let quickTimeUserDataCredits: string;
    let quickTimeUserDataDescription: string;
    let quickTimeUserDataDirector: string;
    let quickTimeUserDataDisclaimer: string;
    let quickTimeUserDataEncodedBy: string;
    let quickTimeUserDataFullName: string;
    let quickTimeUserDataGenre: string;
    let quickTimeUserDataHostComputer: string;
    let quickTimeUserDataInformation: string;
    let quickTimeUserDataKeywords: string;
    let quickTimeUserDataLocationISO6709: string;
    let quickTimeUserDataMake: string;
    let quickTimeUserDataModel: string;
    let quickTimeUserDataOriginalArtist: string;
    let quickTimeUserDataOriginalFormat: string;
    let quickTimeUserDataOriginalSource: string;
    let quickTimeUserDataPerformers: string;
    let quickTimeUserDataPhonogramRights: string;
    let quickTimeUserDataProducer: string;
    let quickTimeUserDataProduct: string;
    let quickTimeUserDataPublisher: string;
    let quickTimeUserDataSoftware: string;
    let quickTimeUserDataSpecialPlaybackRequirements: string;
    let quickTimeUserDataTaggedCharacteristic: string;
    let quickTimeUserDataTrack: string;
    let quickTimeUserDataTrackName: string;
    let quickTimeUserDataURLLink: string;
    let quickTimeUserDataWarning: string;
    let quickTimeUserDataWriter: string;
    let iTunesMetadataAccountKind: string;
    let iTunesMetadataAcknowledgement: string;
    let iTunesMetadataAlbum: string;
    let iTunesMetadataAlbumArtist: string;
    let iTunesMetadataAppleID: string;
    let iTunesMetadataArranger: string;
    let iTunesMetadataArtDirector: string;
    let iTunesMetadataArtist: string;
    let iTunesMetadataArtistID: string;
    let iTunesMetadataAuthor: string;
    let iTunesMetadataBeatsPerMin: string;
    let iTunesMetadataComposer: string;
    let iTunesMetadataConductor: string;
    let iTunesMetadataContentRating: string;
    let iTunesMetadataCopyright: string;
    let iTunesMetadataCoverArt: string;
    let iTunesMetadataCredits: string;
    let iTunesMetadataDescription: string;
    let iTunesMetadataDirector: string;
    let iTunesMetadataDiscCompilation: string;
    let iTunesMetadataDiscNumber: string;
    let iTunesMetadataEQ: string;
    let iTunesMetadataEncodedBy: string;
    let iTunesMetadataEncodingTool: string;
    let iTunesMetadataExecProducer: string;
    let iTunesMetadataGenreID: string;
    let iTunesMetadataGrouping: string;
    let iTunesMetadataLinerNotes: string;
    let iTunesMetadataLyrics: string;
    let iTunesMetadataOnlineExtras: string;
    let iTunesMetadataOriginalArtist: string;
    let iTunesMetadataPerformer: string;
    let iTunesMetadataPhonogramRights: string;
    let iTunesMetadataPlaylistID: string;
    let iTunesMetadataPredefinedGenre: string;
    let iTunesMetadataProducer: string;
    let iTunesMetadataPublisher: string;
    let iTunesMetadataRecordCompany: string;
    let iTunesMetadataReleaseDate: string;
    let iTunesMetadataSoloist: string;
    let iTunesMetadataSongID: string;
    let iTunesMetadataSongName: string;
    let iTunesMetadataSoundEngineer: string;
    let iTunesMetadataThanks: string;
    let iTunesMetadataTrackNumber: string;
    let iTunesMetadataTrackSubTitle: string;
    let iTunesMetadataUserComment: string;
    let iTunesMetadataUserGenre: string;
}
declare namespace AVMetadataKey {
    let metadata3GPUserDataKeyAlbumAndTrack: string;
    let metadata3GPUserDataKeyAuthor: string;
    let metadata3GPUserDataKeyCollection: string;
    let metadata3GPUserDataKeyCopyright: string;
    let metadata3GPUserDataKeyDescription: string;
    let metadata3GPUserDataKeyGenre: string;
    let metadata3GPUserDataKeyKeywordList: string;
    let metadata3GPUserDataKeyLocation: string;
    let metadata3GPUserDataKeyMediaClassification: string;
    let metadata3GPUserDataKeyMediaRating: string;
    let metadata3GPUserDataKeyPerformer: string;
    let metadata3GPUserDataKeyRecordingYear: string;
    let metadata3GPUserDataKeyThumbnail: string;
    let metadata3GPUserDataKeyTitle: string;
    let metadata3GPUserDataKeyUserRating: string;
    let commonKeyAlbumName: string;
    let commonKeyArtist: string;
    let commonKeyArtwork: string;
    let commonKeyAuthor: string;
    let commonKeyContributor: string;
    let commonKeyCopyrights: string;
    let commonKeyCreationDate: string;
    let commonKeyCreator: string;
    let commonKeyDescription: string;
    let commonKeyFormat: string;
    let commonKeyIdentifier: string;
    let commonKeyLanguage: string;
    let commonKeyLastModifiedDate: string;
    let commonKeyLocation: string;
    let commonKeyMake: string;
    let commonKeyModel: string;
    let commonKeyPublisher: string;
    let commonKeyRelation: string;
    let commonKeySoftware: string;
    let commonKeySource: string;
    let commonKeySubject: string;
    let commonKeyTitle: string;
    let commonKeyType: string;
    let id3MetadataKeyAlbumSortOrder: string;
    let id3MetadataKeyAlbumTitle: string;
    let id3MetadataKeyAttachedPicture: string;
    let id3MetadataKeyAudioEncryption: string;
    let id3MetadataKeyAudioSeekPointIndex: string;
    let id3MetadataKeyBand: string;
    let id3MetadataKeyBeatsPerMinute: string;
    let id3MetadataKeyComments: string;
    let id3MetadataKeyCommercial: string;
    let id3MetadataKeyCommercialInformation: string;
    let id3MetadataKeyComposer: string;
    let id3MetadataKeyConductor: string;
    let id3MetadataKeyContentGroupDescription: string;
    let id3MetadataKeyContentType: string;
    let id3MetadataKeyCopyright: string;
    let id3MetadataKeyCopyrightInformation: string;
    let id3MetadataKeyDate: string;
    let id3MetadataKeyEncodedBy: string;
    let id3MetadataKeyEncodedWith: string;
    let id3MetadataKeyEncodingTime: string;
    let id3MetadataKeyEncryption: string;
    let id3MetadataKeyEqualization: string;
    let id3MetadataKeyEqualization2: string;
    let id3MetadataKeyEventTimingCodes: string;
    let id3MetadataKeyFileOwner: string;
    let id3MetadataKeyFileType: string;
    let id3MetadataKeyGeneralEncapsulatedObject: string;
    let id3MetadataKeyGroupIdentifier: string;
    let id3MetadataKeyInitialKey: string;
    let id3MetadataKeyInternationalStandardRecordingCode: string;
    let id3MetadataKeyInternetRadioStationName: string;
    let id3MetadataKeyInternetRadioStationOwner: string;
    let id3MetadataKeyInvolvedPeopleList_v23: string;
    let id3MetadataKeyInvolvedPeopleList_v24: string;
    let id3MetadataKeyLanguage: string;
    let id3MetadataKeyLeadPerformer: string;
    let id3MetadataKeyLength: string;
    let id3MetadataKeyLink: string;
    let id3MetadataKeyLyricist: string;
    let id3MetadataKeyMPEGLocationLookupTable: string;
    let id3MetadataKeyMediaType: string;
    let id3MetadataKeyModifiedBy: string;
    let id3MetadataKeyMood: string;
    let id3MetadataKeyMusicCDIdentifier: string;
    let id3MetadataKeyMusicianCreditsList: string;
    let id3MetadataKeyOfficialArtistWebpage: string;
    let id3MetadataKeyOfficialAudioFileWebpage: string;
    let id3MetadataKeyOfficialAudioSourceWebpage: string;
    let id3MetadataKeyOfficialInternetRadioStationHomepage: string;
    let id3MetadataKeyOfficialPublisherWebpage: string;
    let id3MetadataKeyOriginalAlbumTitle: string;
    let id3MetadataKeyOriginalArtist: string;
    let id3MetadataKeyOriginalFilename: string;
    let id3MetadataKeyOriginalLyricist: string;
    let id3MetadataKeyOriginalReleaseTime: string;
    let id3MetadataKeyOriginalReleaseYear: string;
    let id3MetadataKeyOwnership: string;
    let id3MetadataKeyPartOfASet: string;
    let id3MetadataKeyPayment: string;
    let id3MetadataKeyPerformerSortOrder: string;
    let id3MetadataKeyPlayCounter: string;
    let id3MetadataKeyPlaylistDelay: string;
    let id3MetadataKeyPopularimeter: string;
    let id3MetadataKeyPositionSynchronization: string;
    let id3MetadataKeyPrivate: string;
    let id3MetadataKeyProducedNotice: string;
    let id3MetadataKeyPublisher: string;
    let id3MetadataKeyRecommendedBufferSize: string;
    let id3MetadataKeyRecordingDates: string;
    let id3MetadataKeyRecordingTime: string;
    let id3MetadataKeyRelativeVolumeAdjustment: string;
    let id3MetadataKeyRelativeVolumeAdjustment2: string;
    let id3MetadataKeyReleaseTime: string;
    let id3MetadataKeyReverb: string;
    let id3MetadataKeySeek: string;
    let id3MetadataKeySetSubtitle: string;
    let id3MetadataKeySignature: string;
    let id3MetadataKeySize: string;
    let id3MetadataKeySubTitle: string;
    let id3MetadataKeySynchronizedLyric: string;
    let id3MetadataKeySynchronizedTempoCodes: string;
    let id3MetadataKeyTaggingTime: string;
    let id3MetadataKeyTermsOfUse: string;
    let id3MetadataKeyTime: string;
    let id3MetadataKeyTitleDescription: string;
    let id3MetadataKeyTitleSortOrder: string;
    let id3MetadataKeyTrackNumber: string;
    let id3MetadataKeyUniqueFileIdentifier: string;
    let id3MetadataKeyUnsynchronizedLyric: string;
    let id3MetadataKeyUserText: string;
    let id3MetadataKeyUserURL: string;
    let id3MetadataKeyYear: string;
    let isoUserDataKeyCopyright: string;
    let isoUserDataKeyDate: string;
    let isoUserDataKeyTaggedCharacteristic: string;
    let icyMetadataKeyStreamTitle: string;
    let icyMetadataKeyStreamURL: string;
    let quickTimeMetadataKeyAlbum: string;
    let quickTimeMetadataKeyArranger: string;
    let quickTimeMetadataKeyArtist: string;
    let quickTimeMetadataKeyArtwork: string;
    let quickTimeMetadataKeyAuthor: string;
    let quickTimeMetadataKeyCameraFrameReadoutTime: string;
    let quickTimeMetadataKeyCameraIdentifier: string;
    let quickTimeMetadataKeyCollectionUser: string;
    let quickTimeMetadataKeyComment: string;
    let quickTimeMetadataKeyComposer: string;
    let quickTimeMetadataKeyContentIdentifier: string;
    let quickTimeMetadataKeyCopyright: string;
    let quickTimeMetadataKeyCreationDate: string;
    let quickTimeMetadataKeyCredits: string;
    let quickTimeMetadataKeyDescription: string;
    let quickTimeMetadataKeyDirectionFacing: string;
    let quickTimeMetadataKeyDirectionMotion: string;
    let quickTimeMetadataKeyDirector: string;
    let quickTimeMetadataKeyDisplayName: string;
    let quickTimeMetadataKeyEncodedBy: string;
    let quickTimeMetadataKeyGenre: string;
    let quickTimeMetadataKeyInformation: string;
    let quickTimeMetadataKeyKeywords: string;
    let quickTimeMetadataKeyLocationBody: string;
    let quickTimeMetadataKeyLocationDate: string;
    let quickTimeMetadataKeyLocationISO6709: string;
    let quickTimeMetadataKeyLocationName: string;
    let quickTimeMetadataKeyLocationNote: string;
    let quickTimeMetadataKeyLocationRole: string;
    let quickTimeMetadataKeyMake: string;
    let quickTimeMetadataKeyModel: string;
    let quickTimeMetadataKeyOriginalArtist: string;
    let quickTimeMetadataKeyPerformer: string;
    let quickTimeMetadataKeyPhonogramRights: string;
    let quickTimeMetadataKeyProducer: string;
    let quickTimeMetadataKeyPublisher: string;
    let quickTimeMetadataKeyRatingUser: string;
    let quickTimeMetadataKeySoftware: string;
    let quickTimeMetadataKeyTitle: string;
    let quickTimeMetadataKeyYear: string;
    let quickTimeMetadataKeyiXML: string;
    let quickTimeUserDataKeyAlbum: string;
    let quickTimeUserDataKeyArranger: string;
    let quickTimeUserDataKeyArtist: string;
    let quickTimeUserDataKeyAuthor: string;
    let quickTimeUserDataKeyChapter: string;
    let quickTimeUserDataKeyComment: string;
    let quickTimeUserDataKeyComposer: string;
    let quickTimeUserDataKeyCopyright: string;
    let quickTimeUserDataKeyCreationDate: string;
    let quickTimeUserDataKeyCredits: string;
    let quickTimeUserDataKeyDescription: string;
    let quickTimeUserDataKeyDirector: string;
    let quickTimeUserDataKeyDisclaimer: string;
    let quickTimeUserDataKeyEncodedBy: string;
    let quickTimeUserDataKeyFullName: string;
    let quickTimeUserDataKeyGenre: string;
    let quickTimeUserDataKeyHostComputer: string;
    let quickTimeUserDataKeyInformation: string;
    let quickTimeUserDataKeyKeywords: string;
    let quickTimeUserDataKeyLocationISO6709: string;
    let quickTimeUserDataKeyMake: string;
    let quickTimeUserDataKeyModel: string;
    let quickTimeUserDataKeyOriginalArtist: string;
    let quickTimeUserDataKeyOriginalFormat: string;
    let quickTimeUserDataKeyOriginalSource: string;
    let quickTimeUserDataKeyPerformers: string;
    let quickTimeUserDataKeyPhonogramRights: string;
    let quickTimeUserDataKeyProducer: string;
    let quickTimeUserDataKeyProduct: string;
    let quickTimeUserDataKeyPublisher: string;
    let quickTimeUserDataKeySoftware: string;
    let quickTimeUserDataKeySpecialPlaybackRequirements: string;
    let quickTimeUserDataKeyTaggedCharacteristic: string;
    let quickTimeUserDataKeyTrack: string;
    let quickTimeUserDataKeyTrackName: string;
    let quickTimeUserDataKeyURLLink: string;
    let quickTimeUserDataKeyWarning: string;
    let quickTimeUserDataKeyWriter: string;
    let iTunesMetadataKeyAccountKind: string;
    let iTunesMetadataKeyAcknowledgement: string;
    let iTunesMetadataKeyAlbum: string;
    let iTunesMetadataKeyAlbumArtist: string;
    let iTunesMetadataKeyAppleID: string;
    let iTunesMetadataKeyArranger: string;
    let iTunesMetadataKeyArtDirector: string;
    let iTunesMetadataKeyArtist: string;
    let iTunesMetadataKeyArtistID: string;
    let iTunesMetadataKeyAuthor: string;
    let iTunesMetadataKeyBeatsPerMin: string;
    let iTunesMetadataKeyComposer: string;
    let iTunesMetadataKeyConductor: string;
    let iTunesMetadataKeyContentRating: string;
    let iTunesMetadataKeyCopyright: string;
    let iTunesMetadataKeyCoverArt: string;
    let iTunesMetadataKeyCredits: string;
    let iTunesMetadataKeyDescription: string;
    let iTunesMetadataKeyDirector: string;
    let iTunesMetadataKeyDiscCompilation: string;
    let iTunesMetadataKeyDiscNumber: string;
    let iTunesMetadataKeyEQ: string;
    let iTunesMetadataKeyEncodedBy: string;
    let iTunesMetadataKeyEncodingTool: string;
    let iTunesMetadataKeyExecProducer: string;
    let iTunesMetadataKeyGenreID: string;
    let iTunesMetadataKeyGrouping: string;
    let iTunesMetadataKeyLinerNotes: string;
    let iTunesMetadataKeyLyrics: string;
    let iTunesMetadataKeyOnlineExtras: string;
    let iTunesMetadataKeyOriginalArtist: string;
    let iTunesMetadataKeyPerformer: string;
    let iTunesMetadataKeyPhonogramRights: string;
    let iTunesMetadataKeyPlaylistID: string;
    let iTunesMetadataKeyPredefinedGenre: string;
    let iTunesMetadataKeyProducer: string;
    let iTunesMetadataKeyPublisher: string;
    let iTunesMetadataKeyRecordCompany: string;
    let iTunesMetadataKeyReleaseDate: string;
    let iTunesMetadataKeySoloist: string;
    let iTunesMetadataKeySongID: string;
    let iTunesMetadataKeySongName: string;
    let iTunesMetadataKeySoundEngineer: string;
    let iTunesMetadataKeyThanks: string;
    let iTunesMetadataKeyTrackNumber: string;
    let iTunesMetadataKeyTrackSubTitle: string;
    let iTunesMetadataKeyUserComment: string;
    let iTunesMetadataKeyUserGenre: string;
}
declare namespace AVMetadataKeySpace {
    let audioFile: string;
    let common: string;
    let hlsDateRange: string;
    let id3: string;
    let isoUserData: string;
    let icy: string;
    let quickTimeMetadata: string;
    let quickTimeUserData: string;
    let iTunes: string;
}
declare namespace AVMetadataObject {
    let aztec: string;
    let catBody: string;
    let code128: string;
    let code39: string;
    let code39Mod43: string;
    let code93: string;
    let dataMatrix: string;
    let dogBody: string;
    let ean13: string;
    let ean8: string;
    let face: string;
    let humanBody: string;
    let itf14: string;
    let interleaved2of5: string;
    let pdf417: string;
    let qr: string;
    let salientObject: string;
    let upce: string;
}
declare namespace AVOutputSettingsPreset {
    let preset1280x720: string;
    let preset1920x1080: string;
    let preset3840x2160: string;
    let preset640x480: string;
    let preset960x540: string;
    let hevc1920x1080: string;
    let hevc1920x1080WithAlpha: string;
    let hevc3840x2160: string;
    let hevc3840x2160WithAlpha: string;
}
declare namespace AVPlayer {
    enum ActionAtItemEnd {
        Advance = 0,
        Pause = 1,
        None = 2
    }
    enum HDRMode {
        HLG = 1,
        HDR10 = 2,
        DolbyVision = 4
    }
    enum Status {
        Unknown = 0,
        ReadyToPlay = 1,
        Failed = 2
    }
    enum TimeControlStatus {
        Paused = 0,
        WaitingToPlayAtSpecifiedRate = 1,
        Playing = 2
    }
    let eligibleForHDRPlaybackDidChangeNotification: string;
    let toMinimizeStalls: string;
    let evaluatingBufferingRate: string;
    let noItemToPlay: string;
}
declare namespace AVPlayerItem {
    enum Status {
        Unknown = 0,
        ReadyToPlay = 1,
        Failed = 2
    }
    let mediaSelectionDidChangeNotification: string;
    let recommendedTimeOffsetFromLiveDidChangeNotification: string;
}
declare namespace AVPlayerItemLegibleOutput {
    let default_: string;
    let sourceAndRulesOnly: string;
}
declare namespace AVPlayerLooper {
    enum Status {
        Unknown = 0,
        Ready = 1,
        Failed = 2,
        Cancelled = 3
    }
}
declare namespace AVSampleBufferRenderSynchronizer {
    let rateDidChangeNotification: string;
}
declare namespace AVSampleBufferRequest {
    enum Direction {
        Forward = 1,
        None = 0,
        Reverse = -1
    }
    enum Mode {
        Immediate = 0,
        Scheduled = 1,
        Opportunistic = 2
    }
}
declare namespace AVSemanticSegmentationMatte {
    let hair: string;
    let skin: string;
    let teeth: string;
}
declare namespace AVVideoApertureMode {
    let cleanAperture: string;
    let encodedPixels: string;
    let productionAperture: string;
}
declare namespace AVVideoCodecType {
    let proRes422: string;
    let proRes422HQ: string;
    let proRes422LT: string;
    let proRes422Proxy: string;
    let proRes4444: string;
    let h264: string;
    let hevc: string;
    let hevcWithAlpha: string;
    let jpeg: string;
}
declare namespace Bundle {
    let didLoadNotification: string;
}
declare namespace ByteCountFormatter {
    enum CountStyle {
        File = 0,
        Memory = 1,
        Decimal = 2,
        Binary = 3
    }
    enum Units {
        UseDefault = 0,
        UseBytes = 1,
        UseKB = 2,
        UseMB = 4,
        UseGB = 8,
        UseTB = 16,
        UsePB = 32,
        UseEB = 64,
        UseZB = 128,
        UseYBOrHigher = 65280,
        UseAll = 65535
    }
}
declare namespace CAAnimationCalculationMode {
    let cubic: string;
    let cubicPaced: string;
    let discrete: string;
    let linear: string;
    let paced: string;
}
declare namespace CAAnimationRotationMode {
    let rotateAuto: string;
    let rotateAutoReverse: string;
}
declare namespace CAEmitterLayerEmitterMode {
    let outline: string;
    let points: string;
    let surface: string;
    let volume: string;
}
declare namespace CAEmitterLayerEmitterShape {
    let circle: string;
    let cuboid: string;
    let line: string;
    let point: string;
    let rectangle: string;
    let sphere: string;
}
declare namespace CAEmitterLayerRenderMode {
    let additive: string;
    let backToFront: string;
    let oldestFirst: string;
    let oldestLast: string;
    let unordered: string;
}
declare namespace CAGradientLayerType {
    let axial: string;
    let conic: string;
    let radial: string;
}
declare namespace CALayerContentsFilter {
    let linear: string;
    let nearest: string;
    let trilinear: string;
}
declare namespace CALayerContentsFormat {
    let gray8Uint: string;
    let RGBA16Float: string;
    let RGBA8Uint: string;
}
declare namespace CALayerContentsGravity {
    let bottom: string;
    let bottomLeft: string;
    let bottomRight: string;
    let center: string;
    let left: string;
    let resize: string;
    let resizeAspect: string;
    let resizeAspectFill: string;
    let right: string;
    let top: string;
    let topLeft: string;
    let topRight: string;
}
declare namespace CALayerCornerCurve {
    let circular: string;
    let continuous: string;
}
declare namespace CAMediaTimingFillMode {
    let backwards: string;
    let both: string;
    let forwards: string;
    let removed: string;
}
declare namespace CAMediaTimingFunctionName {
    let default_: string;
    let easeIn: string;
    let easeInEaseOut: string;
    let easeOut: string;
    let linear: string;
}
declare namespace CAScrollLayerScrollMode {
    let both: string;
    let horizontally: string;
    let none: string;
    let vertically: string;
}
declare namespace CAShapeLayerFillRule {
    let evenOdd: string;
    let nonZero: string;
}
declare namespace CAShapeLayerLineCap {
    let butt: string;
    let round: string;
    let square: string;
}
declare namespace CAShapeLayerLineJoin {
    let bevel: string;
    let miter: string;
    let round: string;
}
declare namespace CATextLayerAlignmentMode {
    let center: string;
    let justified: string;
    let left: string;
    let natural: string;
    let right: string;
}
declare namespace CATextLayerTruncationMode {
    let end: string;
    let middle: string;
    let none: string;
    let start: string;
}
declare namespace CATransitionSubtype {
    let fromBottom: string;
    let fromLeft: string;
    let fromRight: string;
    let fromTop: string;
}
declare namespace CATransitionType {
    let fade: string;
    let moveIn: string;
    let push: string;
    let reveal: string;
}
declare namespace CAValueFunctionName {
    let rotateX: string;
    let rotateY: string;
    let rotateZ: string;
    let scale: string;
    let scaleX: string;
    let scaleY: string;
    let scaleZ: string;
    let translate: string;
    let translateX: string;
    let translateY: string;
    let translateZ: string;
}
declare namespace CFCalendarIdentifier {
    let buddhistCalendar: any;
    let chineseCalendar: any;
    let gregorianCalendar: any;
    let hebrewCalendar: any;
    let cfiso8601Calendar: any;
    let indianCalendar: any;
    let islamicCalendar: any;
    let islamicCivilCalendar: any;
    let islamicTabularCalendar: any;
    let islamicUmmAlQuraCalendar: any;
    let japaneseCalendar: any;
    let persianCalendar: any;
    let republicOfChinaCalendar: any;
}
declare namespace CFDateFormatterKey {
    let amSymbol: any;
    let calendar: any;
    let calendarName: any;
    let defaultDate: any;
    let defaultFormat: any;
    let doesRelativeDateFormattingKey: any;
    let eraSymbols: any;
    let gregorianStartDate: any;
    let isLenient: any;
    let longEraSymbols: any;
    let monthSymbols: any;
    let pmSymbol: any;
    let quarterSymbols: any;
    let shortMonthSymbols: any;
    let shortQuarterSymbols: any;
    let shortStandaloneMonthSymbols: any;
    let shortStandaloneQuarterSymbols: any;
    let shortStandaloneWeekdaySymbols: any;
    let shortWeekdaySymbols: any;
    let standaloneMonthSymbols: any;
    let standaloneQuarterSymbols: any;
    let standaloneWeekdaySymbols: any;
    let timeZone: any;
    let twoDigitStartDate: any;
    let veryShortMonthSymbols: any;
    let veryShortStandaloneMonthSymbols: any;
    let veryShortStandaloneWeekdaySymbols: any;
    let veryShortWeekdaySymbols: any;
    let weekdaySymbols: any;
}
declare namespace CFLocaleKey {
    let alternateQuotationBeginDelimiterKey: any;
    let alternateQuotationEndDelimiterKey: any;
    let calendar: any;
    let calendarIdentifier: any;
    let collationIdentifier: any;
    let collatorIdentifier: any;
    let countryCode: any;
    let currencyCode: any;
    let currencySymbol: any;
    let decimalSeparator: any;
    let exemplarCharacterSet: any;
    let groupingSeparator: any;
    let identifier: any;
    let languageCode: any;
    let measurementSystem: any;
    let quotationBeginDelimiterKey: any;
    let quotationEndDelimiterKey: any;
    let scriptCode: any;
    let usesMetricSystem: any;
    let variantCode: any;
}
declare namespace CFNotificationName {
    let cfLocaleCurrentLocaleDidChange: any;
    let cfTimeZoneSystemTimeZoneDidChange: any;
}
declare namespace CFNumberFormatterKey {
    let alwaysShowDecimalSeparator: any;
    let currencyCode: any;
    let currencyDecimalSeparator: any;
    let currencyGroupingSeparator: any;
    let currencySymbol: any;
    let decimalSeparator: any;
    let defaultFormat: any;
    let exponentSymbol: any;
    let formatWidth: any;
    let groupingSeparator: any;
    let groupingSize: any;
    let infinitySymbol: any;
    let internationalCurrencySymbol: any;
    let isLenient: any;
    let maxFractionDigits: any;
    let maxIntegerDigits: any;
    let maxSignificantDigits: any;
    let minFractionDigits: any;
    let minIntegerDigits: any;
    let minSignificantDigits: any;
    let minusSign: any;
    let multiplier: any;
    let naNSymbol: any;
    let negativePrefix: any;
    let negativeSuffix: any;
    let paddingCharacter: any;
    let paddingPosition: any;
    let perMillSymbol: any;
    let percentSymbol: any;
    let plusSign: any;
    let positivePrefix: any;
    let positiveSuffix: any;
    let roundingIncrement: any;
    let roundingMode: any;
    let secondaryGroupingSize: any;
    let useGroupingSeparator: any;
    let useSignificantDigits: any;
    let zeroSymbol: any;
}
declare namespace CFRunLoopMode {
    let commonModes: any;
    let defaultMode: any;
}
declare namespace CFStreamPropertyKey {
    let appendToFile: any;
    let dataWritten: any;
    let fileCurrentOffset: any;
    let socketNativeHandle: any;
    let socketRemoteHostName: any;
    let socketRemotePortNumber: any;
}
declare namespace CGAffineTransform {
    let identity: CGAffineTransform;
}
declare namespace CGColor {
    let __blackColorName: string;
    let __clearColorName: string;
    let conversionBlackPointCompensation: string;
    let conversionTRCSize: string;
    let __whiteColorName: string;
}
declare namespace CGColorSpace {
    let acescgLinear: string;
    let adobeRGB1998: string;
    let dcip3: string;
    let displayP3: string;
    let displayP3_HLG: string;
    let displayP3_PQ_EOTF: string;
    let extendedGray: string;
    let extendedLinearDisplayP3: string;
    let extendedLinearGray: string;
    let extendedLinearITUR_2020: string;
    let extendedLinearSRGB: string;
    let extendedSRGB: string;
    let genericCMYK: string;
    let genericGray: string;
    let genericGrayGamma2_2: string;
    let genericLab: string;
    let genericRGB: string;
    let genericRGBLinear: string;
    let genericXYZ: string;
    let itur_2020: string;
    let itur_2020_HLG: string;
    let itur_2020_PQ_EOTF: string;
    let itur_709: string;
    let linearGray: string;
    let linearSRGB: string;
    let rommrgb: string;
    let sRGB: string;
}
declare namespace CGDisplayStream {
    let colorSpace: string;
    let destinationRect: string;
    let minimumFrameTime: string;
    let preserveAspectRatio: string;
    let queueDepth: string;
    let showCursor: string;
    let sourceRect: string;
    let yCbCrMatrix: string;
    let yCbCrMatrix_ITU_R_601_4: string;
    let yCbCrMatrix_ITU_R_709_2: string;
    let yCbCrMatrix_SMPTE_240M_1995: string;
}
declare namespace CGFont {
    let variationAxisDefaultValue: string;
    let variationAxisMaxValue: string;
    let variationAxisMinValue: string;
    let variationAxisName: string;
}
declare namespace CGPDFTagProperty {
    let actualText: any;
    let alternativeText: any;
    let languageText: any;
    let titleText: any;
}
declare namespace CGPoint {
    let zero: CGPoint;
}
declare namespace CGRect {
    let infinite: CGRect;
    let null_: CGRect;
    let zero: CGRect;
}
declare namespace CGSize {
    let zero: CGSize;
}
declare namespace CIContextOption {
    let allowLowPower: string;
    let cacheIntermediates: string;
    let highQualityDownsample: string;
    let outputColorSpace: string;
    let outputPremultiplied: string;
    let priorityRequestLow: string;
    let useSoftwareRenderer: string;
    let workingColorSpace: string;
    let workingFormat: string;
}
declare namespace CIFormat {
    let A16: number;
    let A8: number;
    let ABGR8: number;
    let ARGB8: number;
    let Af: number;
    let Ah: number;
    let BGRA8: number;
    let L16: number;
    let L8: number;
    let LA16: number;
    let LA8: number;
    let LAf: number;
    let LAh: number;
    let Lf: number;
    let Lh: number;
    let R16: number;
    let R8: number;
    let RG16: number;
    let RG8: number;
    let RGBA16: number;
    let RGBA8: number;
    let RGBAf: number;
    let RGBAh: number;
    let RGf: number;
    let RGh: number;
    let Rf: number;
    let Rh: number;
}
declare namespace CIImageAutoAdjustmentOption {
    let crop: string;
    let enhance: string;
    let features: string;
    let level: string;
    let redEye: string;
}
declare namespace CIImageOption {
    let applyOrientationProperty: string;
    let auxiliaryDepth: string;
    let auxiliaryDisparity: string;
    let auxiliaryPortraitEffectsMatte: string;
    let auxiliarySemanticSegmentationHairMatte: string;
    let auxiliarySemanticSegmentationSkinMatte: string;
    let auxiliarySemanticSegmentationTeethMatte: string;
    let colorSpace: string;
    let nearestSampling: string;
    let properties: string;
    let providerTileSize: string;
    let providerUserInfo: string;
}
declare namespace CIImageRepresentationOption {
    let avDepthData: string;
    let avPortraitEffectsMatte: string;
    let avSemanticSegmentationMattes: string;
    let depthImage: string;
    let disparityImage: string;
    let portraitEffectsMatteImage: string;
    let semanticSegmentationHairMatteImage: string;
    let semanticSegmentationSkinMatteImage: string;
    let semanticSegmentationTeethMatteImage: string;
}
declare namespace CIRAWFilterOption {
    let activeKeys: string;
    let allowDraftMode: string;
    let baselineExposure: string;
    let boostAmount: string;
    let boostShadowAmount: string;
    let colorNoiseReductionAmount: string;
    let decoderVersion: string;
    let disableGamutMap: string;
    let enableChromaticNoiseTracking: string;
    let enableSharpening: string;
    let enableVendorLensCorrection: string;
    let ignoreImageOrientation: string;
    let imageOrientation: string;
    let linearSpaceFilter: string;
    let luminanceNoiseReductionAmount: string;
    let moireAmount: string;
    let neutralChromaticityX: string;
    let neutralChromaticityY: string;
    let neutralLocation: string;
    let neutralTemperature: string;
    let neutralTint: string;
    let noiseReductionAmount: string;
    let noiseReductionContrastAmount: string;
    let noiseReductionDetailAmount: string;
    let noiseReductionSharpnessAmount: string;
    let scaleFactor: string;
    let outputNativeSize: string;
    let supportedDecoderVersions: string;
}
declare namespace CMImageDescriptionFlavor {
    let mobile3GPFamily: any;
    let isoFamily: any;
    let quickTimeMovie: any;
}
declare namespace CMSampleTimingInfo {
    let invalid: CMSampleTimingInfo;
}
declare namespace CMSoundDescriptionFlavor {
    let mobile3GPFamily: any;
    let isoFamily: any;
    let quickTimeMovie: any;
    let quickTimeMovieV2: any;
}
declare namespace CMTime {
    let indefinite: CMTime;
    let invalid: CMTime;
    let negativeInfinity: CMTime;
    let positiveInfinity: CMTime;
    let zero: CMTime;
}
declare namespace CMTimeMapping {
    let invalid: CMTimeMapping;
}
declare namespace CMTimeRange {
    let invalid: CMTimeRange;
    let zero: CMTimeRange;
}
declare namespace DateComponentsFormatter {
    enum UnitsStyle {
        Positional = 0,
        Abbreviated = 1,
        Short = 2,
        Full = 3,
        SpellOut = 4,
        Brief = 5
    }
    enum ZeroFormattingBehavior {
        None = 0,
        Default = 1,
        DropLeading = 2,
        DropMiddle = 4,
        DropTrailing = 8,
        DropAll = 14,
        Pad = 65536
    }
}
declare namespace DateFormatter {
    enum Behavior {
        BehaviorDefault = 0,
        Behavior10_0 = 1000,
        Behavior10_4 = 1040
    }
    enum Style {
        NoStyle = 0,
        ShortStyle = 1,
        MediumStyle = 2,
        LongStyle = 3,
        FullStyle = 4
    }
}
declare namespace DateIntervalFormatter {
    enum Style {
        NoStyle = 0,
        ShortStyle = 1,
        MediumStyle = 2,
        LongStyle = 3,
        FullStyle = 4
    }
}
declare namespace Decimal {
    type RoundingMode = NSDecimalNumber;
    type CalculationError = NSDecimalNumber;
    type FloatLiteralType = number;
    type IntegerLiteralType = number;
    type Magnitude = number;
    type Stride = number;
}
declare namespace DistributedNotificationCenter {
    enum Options {
        DeliverImmediately = 1,
        PostToAllSessions = 2
    }
    enum SuspensionBehavior {
        Drop = 1,
        Coalesce = 2,
        Hold = 3,
        DeliverImmediately = 4
    }
    let localNotificationCenterType: string;
}
declare namespace EnergyFormatter {
    enum Unit {
        Joule = 11,
        Kilojoule = 14,
        Calorie = 1793,
        Kilocalorie = 1794
    }
}
declare namespace FileAttributeKey {
    let appendOnly: string;
    let busy: string;
    let creationDate: string;
    let deviceIdentifier: string;
    let extensionHidden: string;
    let groupOwnerAccountID: string;
    let groupOwnerAccountName: string;
    let hfsCreatorCode: string;
    let hfsTypeCode: string;
    let immutable: string;
    let modificationDate: string;
    let ownerAccountID: string;
    let ownerAccountName: string;
    let posixPermissions: string;
    let protectionKey: string;
    let referenceCount: string;
    let size: string;
    let systemFileNumber: string;
    let systemFreeNodes: string;
    let systemFreeSize: string;
    let systemNodes: string;
    let systemNumber: string;
    let systemSize: string;
    let type: string;
}
declare namespace FileAttributeType {
    let typeBlockSpecial: string;
    let typeCharacterSpecial: string;
    let typeDirectory: string;
    let typeRegular: string;
    let typeSocket: string;
    let typeSymbolicLink: string;
    let typeUnknown: string;
}
declare namespace FileHandle {
    let readCompletionNotification: string;
}
declare namespace FileManager {
    enum DirectoryEnumerationOptions {
        SkipsSubdirectoryDescendants = 1,
        SkipsPackageDescendants = 2,
        SkipsHiddenFiles = 4,
        IncludesDirectoriesPostOrder = 8,
        ProducesRelativePathURLs = 16
    }
    enum ItemReplacementOptions {
        UsingNewMetadataOnly = 1,
        WithoutDeletingBackupItem = 2
    }
    enum UnmountOptions {
        AllPartitionsAndEjectDisk = 1,
        WithoutUI = 2
    }
    enum SearchPathDirectory {
        ApplicationDirectory = 1,
        DemoApplicationDirectory = 2,
        DeveloperApplicationDirectory = 3,
        AdminApplicationDirectory = 4,
        LibraryDirectory = 5,
        DeveloperDirectory = 6,
        UserDirectory = 7,
        DocumentationDirectory = 8,
        DocumentDirectory = 9,
        CoreServiceDirectory = 10,
        AutosavedInformationDirectory = 11,
        DesktopDirectory = 12,
        CachesDirectory = 13,
        ApplicationSupportDirectory = 14,
        DownloadsDirectory = 15,
        InputMethodsDirectory = 16,
        MoviesDirectory = 17,
        MusicDirectory = 18,
        PicturesDirectory = 19,
        PrinterDescriptionDirectory = 20,
        SharedPublicDirectory = 21,
        PreferencePanesDirectory = 22,
        ApplicationScriptsDirectory = 23,
        ItemReplacementDirectory = 99,
        AllApplicationsDirectory = 100,
        AllLibrariesDirectory = 101,
        TrashDirectory = 102
    }
    enum SearchPathDomainMask {
        UserDomainMask = 1,
        LocalDomainMask = 2,
        NetworkDomainMask = 4,
        SystemDomainMask = 8,
        AllDomainsMask = 65535
    }
    enum URLRelationship {
        Contains = 0,
        Same = 1,
        Other = 2
    }
    enum VolumeEnumerationOptions {
        SkipHiddenVolumes = 2,
        ProduceFileReferenceURLs = 4
    }
}
declare namespace FileProtectionType {
    let complete: string;
    let completeUnlessOpen: string;
    let completeUntilFirstUserAuthentication: string;
    let none: string;
}
declare namespace FileWrapper {
    enum ReadingOptions {
        Immediate = 1,
        WithoutMapping = 2
    }
    enum WritingOptions {
        Atomic = 1,
        WithNameUpdating = 2
    }
}
declare namespace Formatter {
    enum Context {
        Unknown = 0,
        Dynamic = 1,
        Standalone = 2,
        ListItem = 3,
        BeginningOfSentence = 4,
        MiddleOfSentence = 5
    }
    enum UnitStyle {
        Short = 1,
        Medium = 2,
        Long = 3
    }
}
declare namespace HTTPCookie {
    enum AcceptPolicy {
        Always = 0,
        Never = 1,
        OnlyFromMainDocumentDomain = 2
    }
}
declare namespace HTTPCookiePropertyKey {
    let comment: string;
    let commentURL: string;
    let discard: string;
    let domain: string;
    let expires: string;
    let maximumAge: string;
    let name: string;
    let originURL: string;
    let path: string;
    let port: string;
    let sameSitePolicy: string;
    let secure: string;
    let value: string;
    let version: string;
}
declare namespace HTTPCookieStringPolicy {
    let sameSiteLax: string;
    let sameSiteStrict: string;
}
declare namespace ISO8601DateFormatter {
    enum Options {
        WithYear = 1,
        WithMonth = 2,
        WithWeekOfYear = 4,
        WithDay = 16,
        WithTime = 32,
        WithTimeZone = 64,
        WithSpaceBetweenDateAndTime = 128,
        WithDashSeparatorInDate = 256,
        WithColonSeparatorInTime = 512,
        WithColonSeparatorInTimeZone = 1024,
        WithFractionalSeconds = 2048,
        WithFullDate = 275,
        WithFullTime = 1632,
        WithInternetDateTime = 1907
    }
}
declare namespace JSONSerialization {
    enum ReadingOptions {
        MutableContainers = 1,
        MutableLeaves = 2,
        FragmentsAllowed = 4,
        AllowFragments = 4
    }
    enum WritingOptions {
        PrettyPrinted = 1,
        SortedKeys = 2,
        FragmentsAllowed = 4,
        WithoutEscapingSlashes = 8
    }
}
declare namespace LengthFormatter {
    enum Unit {
        Millimeter = 8,
        Centimeter = 9,
        Meter = 11,
        Kilometer = 14,
        Inch = 1281,
        Foot = 1282,
        Yard = 1283,
        Mile = 1284
    }
}
declare namespace MassFormatter {
    enum Unit {
        Gram = 11,
        Kilogram = 14,
        Ounce = 1537,
        Pound = 1538,
        Stone = 1539
    }
}
declare namespace MeasurementFormatter {
    enum UnitOptions {
        ProvidedUnit = 1,
        NaturalScale = 2,
        TemperatureWithoutUnit = 4
    }
}
declare namespace NSAccessibility {
    enum AnnotationPosition {
        FullRange = 0,
        Start = 1,
        End = 2
    }
    enum Orientation {
        Unknown = 0,
        Vertical = 1,
        Horizontal = 2
    }
    enum RulerMarkerType {
        Unknown = 0,
        TabStopLeft = 1,
        TabStopRight = 2,
        TabStopCenter = 3,
        TabStopDecimal = 4,
        IndentHead = 5,
        IndentTail = 6,
        IndentFirstLine = 7
    }
    enum SortDirection {
        Unknown = 0,
        Ascending = 1,
        Descending = 2
    }
    enum Units {
        Unknown = 0,
        Inches = 1,
        Centimeters = 2,
        Points = 3,
        Picas = 4
    }
    let activationPoint: string;
    let allowedValues: string;
    let alternateUIVisible: string;
    let element: string;
    let label: string;
    let location: string;
    let announcement: string;
    let announcementRequested: string;
    let applicationActivated: string;
    let applicationDeactivated: string;
    let applicationHidden: string;
    let application: string;
    let applicationShown: string;
    let ascending: string;
    let attributedStringForRange: string;
    let boundsForRange: string;
    let browser: string;
    let busyIndicator: string;
    let button: string;
    let cancel: string;
    let cancelButton: string;
    let cellForColumnAndRow: string;
    let cell: string;
    let centerTabStop: string;
    let centimeters: string;
    let checkBox: string;
    let children: string;
    let clearButton: string;
    let closeButton: string;
    let collectionListSubrole: string;
    let colorWell: string;
    let columnCount: string;
    let columnHeaderUIElements: string;
    let columnIndexRange: string;
    let column: string;
    let columnTitles: string;
    let columns: string;
    let comboBox: string;
    let confirm: string;
    let containsProtectedContent: string;
    let contentList: string;
    let contents: string;
    let created: string;
    let criticalValue: string;
    let decimalTabStop: string;
    let decrement: string;
    let decrementArrow: string;
    let decrementButton: string;
    let decrementPage: string;
    let defaultButton: string;
    let definitionList: string;
    let delete_: string;
    let descending: string;
    let description: string;
    let descriptionList: string;
    let dialog: string;
    let disclosedByRow: string;
    let disclosedRows: string;
    let disclosing: string;
    let disclosureLevel: string;
    let disclosureTriangle: string;
    let document: string;
    let drawerCreated: string;
    let drawer: string;
    let edited: string;
    let enabled: string;
    let ErrorCodeExceptionInfo: string;
    let expanded: string;
    let extrasMenuBar: string;
    let filename: string;
    let firstLineIndent: string;
    let floatingWindow: string;
    let focused: string;
    let focusedUIElement: string;
    let focusedUIElementChanged: string;
    let focusedWindow: string;
    let focusedWindowChanged: string;
    let fontFamily: string;
    let fontName: string;
    let fontSize: string;
    let frontmost: string;
    let fullScreenButton: string;
    let grid: string;
    let group: string;
    let growArea: string;
    let handle: string;
    let handles: string;
    let headIndent: string;
    let header: string;
    let help: string;
    let helpTagCreated: string;
    let helpTag: string;
    let hidden: string;
    let horizontal: string;
    let horizontalScrollBar: string;
    let horizontalUnitDescription: string;
    let horizontalUnits: string;
    let identifier: string;
    let image: string;
    let inches: string;
    let increment: string;
    let incrementArrow: string;
    let incrementButton: string;
    let incrementPage: string;
    let incrementor: string;
    let index: string;
    let insertionPointLineNumber: string;
    let labelUIElements: string;
    let labelValue: string;
    let layoutArea: string;
    let layoutChanged: string;
    let layoutItem: string;
    let layoutPointForScreenPoint: string;
    let layoutSizeForScreenSize: string;
    let leftTabStop: string;
    let levelIndicator: string;
    let lineForIndex: string;
    let link: string;
    let linkedUIElements: string;
    let list: string;
    let main: string;
    let mainWindow: string;
    let mainWindowChanged: string;
    let markerGroupUIElement: string;
    let markerType: string;
    let markerTypeDescription: string;
    let markerUIElements: string;
    let markerValues: string;
    let matte: string;
    let maxValue: string;
    let menuBar: string;
    let menuBarItem: string;
    let menuButton: string;
    let menuItem: string;
    let menu: string;
    let minValue: string;
    let minimizeButton: string;
    let minimized: string;
    let modal: string;
    let moved: string;
    let nextContents: string;
    let numberOfCharacters: string;
    let orderedByRow: string;
    let orientation: string;
    let outline: string;
    let outlineRow: string;
    let overflowButton: string;
    let pageRole: string;
    let parent: string;
    let picas: string;
    let pick: string;
    let placeholderValue: string;
    let points: string;
    let popUpButton: string;
    let popover: string;
    let position: string;
    let press: string;
    let previousContents: string;
    let priority: string;
    let progressIndicator: string;
    let proxy: string;
    let rtfForRange: string;
    let radioButton: string;
    let radioGroup: string;
    let raise: string;
    let rangeForIndex: string;
    let rangeForLine: string;
    let rangeForPosition: string;
    let ratingIndicator: string;
    let relevanceIndicator: string;
    let required: string;
    let resized: string;
    let rightTabStop: string;
    let role: string;
    let roleDescription: string;
    let rowCollapsed: string;
    let rowCount: string;
    let rowCountChanged: string;
    let rowExpanded: string;
    let rowHeaderUIElements: string;
    let rowIndexRange: string;
    let row: string;
    let rows: string;
    let rulerMarker: string;
    let ruler: string;
    let screenPointForLayoutPoint: string;
    let screenSizeForLayoutSize: string;
    let scrollArea: string;
    let scrollBar: string;
    let searchButton: string;
    let searchField: string;
    let searchMenu: string;
    let sectionListSubrole: string;
    let secureTextField: string;
    let selected: string;
    let selectedCells: string;
    let selectedCellsChanged: string;
    let selectedChildren: string;
    let selectedChildrenChanged: string;
    let selectedChildrenMoved: string;
    let selectedColumns: string;
    let selectedColumnsChanged: string;
    let selectedRows: string;
    let selectedRowsChanged: string;
    let selectedText: string;
    let selectedTextChanged: string;
    let selectedTextRange: string;
    let selectedTextRanges: string;
    let servesAsTitleForUIElements: string;
    let sharedCharacterRange: string;
    let sharedFocusElements: string;
    let sharedTextUIElements: string;
    let sheetCreated: string;
    let sheet: string;
    let showAlternateUI: string;
    let showDefaultUI: string;
    let showMenu: string;
    let shownMenu: string;
    let size: string;
    let slider: string;
    let sortButton: string;
    let sortDirection: string;
    let splitGroup: string;
    let splitter: string;
    let splitters: string;
    let standardWindow: string;
    let staticText: string;
    let stringForRange: string;
    let styleRangeForIndex: string;
    let subrole: string;
    let switch_: string;
    let systemDialog: string;
    let systemFloatingWindow: string;
    let systemWide: string;
    let tabButtonSubrole: string;
    let tabGroup: string;
    let table: string;
    let tableRow: string;
    let tabs: string;
    let tailIndent: string;
    let textArea: string;
    let textAttachment: string;
    let textField: string;
    let textLink: string;
    let timeline: string;
    let title: string;
    let titleChanged: string;
    let titleUIElement: string;
    let toggle: string;
    let toolbarButton: string;
    let toolbar: string;
    let topLevelUIElement: string;
    let uiElementDestroyed: string;
    let uiElements: string;
    let url: string;
    let unitDescription: string;
    let units: string;
    let unitsChanged: string;
    let unknown: string;
    let value: string;
    let valueChanged: string;
    let valueDescription: string;
    let valueIndicator: string;
    let vertical: string;
    let verticalScrollBar: string;
    let verticalUnitDescription: string;
    let verticalUnits: string;
    let visibleCells: string;
    let visibleCharacterRange: string;
    let visibleChildren: string;
    let visibleColumns: string;
    let visibleName: string;
    let visibleRows: string;
    let warningValue: string;
    let window: string;
    let windowCreated: string;
    let windowDeminiaturized: string;
    let windowMiniaturized: string;
    let windowMoved: string;
    let windowResized: string;
    let windows: string;
    let zoomButton: string;
}
declare namespace NSAccessibilityCustomRotor {
    enum SearchDirection {
        Previous = 0,
        Next = 1
    }
    enum RotorType {
        Custom = 0,
        Any = 1,
        Annotation = 2,
        BoldText = 3,
        Heading = 4,
        HeadingLevel1 = 5,
        HeadingLevel2 = 6,
        HeadingLevel3 = 7,
        HeadingLevel4 = 8,
        HeadingLevel5 = 9,
        HeadingLevel6 = 10,
        Image = 11,
        ItalicText = 12,
        Landmark = 13,
        Link = 14,
        List = 15,
        MisspelledWord = 16,
        Table = 17,
        TextField = 18,
        UnderlinedText = 19,
        VisitedLink = 20
    }
}
declare namespace NSAlert {
    enum Style {
        Warning = 0,
        Informational = 1,
        Critical = 2
    }
}
declare namespace NSAnimation {
    enum BlockingMode {
        Blocking = 0,
        Nonblocking = 1,
        NonblockingThreaded = 2
    }
    enum Curve {
        EaseInOut = 0,
        EaseIn = 1,
        EaseOut = 2,
        Linear = 3
    }
    let progressMarkUserInfoKey: string;
    let progressMarkNotification: string;
    type Progress = number;
}
declare namespace NSAppKitVersion {
    let current: number;
    let macOS10_0: number;
    let macOS10_1: number;
    let macOS10_10: number;
    let macOS10_10_2: number;
    let macOS10_10_3: number;
    let macOS10_10_4: number;
    let macOS10_10_5: number;
    let macOS10_10_Max: number;
    let macOS10_11: number;
    let macOS10_11_1: number;
    let macOS10_11_2: number;
    let macOS10_11_3: number;
    let macOS10_12: number;
    let macOS10_12_1: number;
    let macOS10_12_2: number;
    let macOS10_13: number;
    let macOS10_13_1: number;
    let macOS10_13_2: number;
    let macOS10_13_4: number;
    let number10_14: number;
    let number10_14_1: number;
    let number10_14_2: number;
    let number10_14_3: number;
    let number10_14_4: number;
    let number10_14_5: number;
    let macOS10_2: number;
    let macOS10_2_3: number;
    let macOS10_3: number;
    let macOS10_3_2: number;
    let macOS10_3_3: number;
    let macOS10_3_5: number;
    let macOS10_3_7: number;
    let macOS10_3_9: number;
    let macOS10_4: number;
    let macOS10_4_1: number;
    let macOS10_4_3: number;
    let macOS10_4_4: number;
    let macOS10_4_7: number;
    let macOS10_5: number;
    let macOS10_5_2: number;
    let macOS10_5_3: number;
    let macOS10_6: number;
    let macOS10_7: number;
    let macOS10_7_2: number;
    let macOS10_7_3: number;
    let macOS10_7_4: number;
    let macOS10_8: number;
    let macOS10_9: number;
    let numberWithColumnResizingBrowser: number;
    let numberWithContinuousScrollingBrowser: number;
    let numberWithCursorSizeSupport: number;
    let numberWithCustomSheetPosition: number;
    let numberWithDeferredWindowDisplaySupport: number;
    let numberWithDirectionalTabs: number;
    let numberWithDockTilePlugInSupport: number;
    let numberWithPatternColorLeakFix: number;
}
declare namespace NSAppearance {
    let accessibilityHighContrastAqua: string;
    let accessibilityHighContrastDarkAqua: string;
    let accessibilityHighContrastVibrantDark: string;
    let accessibilityHighContrastVibrantLight: string;
    let aqua: string;
    let darkAqua: string;
    let vibrantDark: string;
    let vibrantLight: string;
}
declare namespace NSAppleEventDescriptor {
    enum SendOptions {
        NoReply = 1,
        QueueReply = 2,
        WaitForReply = 3,
        NeverInteract = 16,
        CanInteract = 32,
        AlwaysInteract = 48,
        CanSwitchLayer = 64,
        DontRecord = 4096,
        DontExecute = 8192,
        DontAnnotate = 65536,
        DefaultOptions = 35
    }
}
declare namespace NSAppleEventManager {
    type SuspensionID = OpaquePointer;
}
declare namespace NSAppleScript {
    let errorAppName: string;
    let errorBriefMessage: string;
    let errorMessage: string;
    let errorNumber: string;
    let errorRange: string;
}
declare namespace NSApplication {
    enum ActivationOptions {
        ActivateAllWindows = 1,
        ActivateIgnoringOtherApps = 2
    }
    enum ActivationPolicy {
        Regular = 0,
        Accessory = 1,
        Prohibited = 2
    }
    enum DelegateReply {
        Success = 0,
        Cancel = 1,
        Failure = 2
    }
    enum OcclusionState {
        Visible = 2
    }
    enum PresentationOptions {
        Default = 0,
        AutoHideDock = 1,
        HideDock = 2,
        AutoHideMenuBar = 4,
        HideMenuBar = 8,
        DisableAppleMenu = 16,
        DisableProcessSwitching = 32,
        DisableForceQuit = 64,
        DisableSessionTermination = 128,
        DisableHideApplication = 256,
        DisableMenuBarTransparency = 512,
        FullScreen = 1024,
        AutoHideToolbar = 2048,
        DisableCursorLocationAssistance = 4096
    }
    enum PrintReply {
        PrintingCancelled = 0,
        PrintingSuccess = 1,
        PrintingFailure = 3,
        PrintingReplyLater = 2
    }
    enum TerminateReply {
        TerminateCancel = 0,
        TerminateNow = 1,
        TerminateLater = 2
    }
    enum RemoteNotificationType {
        None = 0,
        Badge = 1,
        Sound = 2,
        Alert = 4
    }
    enum RequestUserAttentionType {
        CriticalRequest = 0,
        InformationalRequest = 10
    }
    enum WindowListOptions {
        OrderedFrontToBack = 1
    }
    let applicationIcon: string;
    let applicationName: string;
    let applicationVersion: string;
    let credits: string;
    let version: string;
    let alertFirstButtonReturn: number;
    let alertSecondButtonReturn: number;
    let alertThirdButtonReturn: number;
    let didBecomeActiveNotification: string;
    let didChangeOcclusionStateNotification: string;
    let didChangeScreenParametersNotification: string;
    let didFinishLaunchingNotification: string;
    let didFinishRestoringWindowsNotification: string;
    let didHideNotification: string;
    let didResignActiveNotification: string;
    let didUnhideNotification: string;
    let didUpdateNotification: string;
    let launchIsDefaultUserInfoKey: string;
    let launchUserNotificationUserInfoKey: string;
    let willBecomeActiveNotification: string;
    let willFinishLaunchingNotification: string;
    let willHideNotification: string;
    let willResignActiveNotification: string;
    let willTerminateNotification: string;
    let willUnhideNotification: string;
    let willUpdateNotification: string;
    let abort: number;
    let cancel: number;
    let continue_: number;
    let OK: number;
    let stop: number;
    type ModalSession = OpaquePointer;
}
declare namespace NSArray {
    type Iterator = NSFastEnumerationIterator;
}
declare namespace NSAttributedString {
    enum SpellingState {
        SpellingFlag = 1,
        GrammarFlag = 2
    }
    enum EnumerationOptions {
        Reverse = 2,
        LongestEffectiveRangeNotRequired = 1048576
    }
    let accessibilityAnnotationTextAttribute: string;
    let accessibilityAttachment: string;
    let accessibilityAutocorrected: string;
    let accessibilityBackgroundColor: string;
    let accessibilityCustomText: string;
    let accessibilityFont: string;
    let accessibilityForegroundColor: string;
    let accessibilityLanguage: string;
    let accessibilityLink: string;
    let accessibilityListItemIndex: string;
    let accessibilityListItemLevel: string;
    let accessibilityListItemPrefix: string;
    let accessibilityMarkedMisspelled: string;
    let accessibilityMisspelled: string;
    let accessibilityShadow: string;
    let accessibilityStrikethroughColor: string;
    let accessibilityStrikethrough: string;
    let accessibilitySuperscript: string;
    let accessibilityAlignment: string;
    let accessibilityUnderlineColor: string;
    let accessibilityUnderline: string;
    let appearance: string;
    let attachment: string;
    let author: string;
    let backgroundColor: string;
    let baseURL: string;
    let baselineOffset: string;
    let bottomMargin: string;
    let category: string;
    let characterEncoding: string;
    let cocoaVersion: string;
    let comment: string;
    let company: string;
    let converted: string;
    let copyright: string;
    let creationTime: string;
    let cursor: string;
    let defaultAttributes: string;
    let defaultTabInterval: string;
    let docFormat: string;
    let documentType: string;
    let editor: string;
    let excludedElements: string;
    let expansion: string;
    let fileType: string;
    let font: string;
    let foregroundColor: string;
    let glyphInfo: string;
    let html: string;
    let hyphenationFactor: string;
    let kern: string;
    let keywords: string;
    let leftMargin: string;
    let ligature: string;
    let link: string;
    let macSimpleText: string;
    let manager: string;
    let markedClauseSegment: string;
    let modificationTime: string;
    let obliqueness: string;
    let officeOpenXML: string;
    let openDocument: string;
    let paperSize: string;
    let paragraphStyle: string;
    let plain: string;
    let prefixSpaces: string;
    let rtfd: string;
    let rtf: string;
    let readOnly: string;
    let rightMargin: string;
    let shadow: string;
    let sourceTextScaling: string;
    let spellingState: string;
    let strikethroughColor: string;
    let strikethroughStyle: string;
    let strokeColor: string;
    let strokeWidth: string;
    let subject: string;
    let superscript: string;
    let targetTextScaling: string;
    let textAlternatives: string;
    let textEffect: string;
    let letterpressStyle: string;
    let textEncodingName: string;
    let orientation: string;
    let range: string;
    let textLayoutSections: string;
    let textScaling: string;
    let textSizeMultiplier: string;
    let timeout: string;
    let title: string;
    let toolTip: string;
    let topMargin: string;
    let underlineColor: string;
    let underlineStyle: string;
    let verticalGlyphForm: string;
    let viewMode: string;
    let viewSize: string;
    let viewZoom: string;
    let webArchive: string;
    let webPreferences: string;
    let webResourceLoadDelegate: string;
    let wordML: string;
    let writingDirection: string;
}
declare namespace NSBackgroundActivityScheduler {
    enum Result {
        Finished = 1,
        Deferred = 2
    }
}
declare namespace NSBezierPath {
    enum ElementType {
        MoveTo = 0,
        LineTo = 1,
        CurveTo = 2,
        ClosePath = 3
    }
    enum LineCapStyle {
        Butt = 0,
        Round = 1,
        Square = 2
    }
    enum LineJoinStyle {
        Miter = 0,
        Round = 1,
        Bevel = 2
    }
    enum WindingRule {
        NonZero = 0,
        EvenOdd = 1
    }
    let bevel: NSBezierPath.LineJoinStyle;
    let butt: NSBezierPath.LineCapStyle;
    let closePath: NSBezierPath.ElementType;
    let curveTo: NSBezierPath.ElementType;
    let evenOdd: NSBezierPath.WindingRule;
    let lineTo: NSBezierPath.ElementType;
    let miter: NSBezierPath.LineJoinStyle;
    let moveTo: NSBezierPath.ElementType;
    let nonZero: NSBezierPath.WindingRule;
    let round: NSBezierPath.LineCapStyle;
    let square: NSBezierPath.LineCapStyle;
}
declare namespace NSBindingInfoKey {
    let observedKeyPath: string;
    let observedObject: string;
    let options: string;
}
declare namespace NSBindingName {
    let alignment: string;
    let alternateImage: string;
    let alternateTitle: string;
    let animate: string;
    let animationDelay: string;
    let argument: string;
    let attributedString: string;
    let contentArray: string;
    let contentArrayForMultipleSelection: string;
    let content: string;
    let contentDictionary: string;
    let contentHeight: string;
    let contentObject: string;
    let contentObjects: string;
    let contentSet: string;
    let contentValues: string;
    let contentWidth: string;
    let criticalValue: string;
    let data: string;
    let displayPatternTitle: string;
    let displayPatternValue: string;
    let documentEdited: string;
    let doubleClickArgument: string;
    let doubleClickTarget: string;
    let editable: string;
    let enabled: string;
    let excludedKeys: string;
    let filterPredicate: string;
    let font: string;
    let fontBold: string;
    let fontFamilyName: string;
    let fontItalic: string;
    let fontName: string;
    let fontSize: string;
    let headerTitle: string;
    let hidden: string;
    let image: string;
    let includedKeys: string;
    let initialKey: string;
    let initialValue: string;
    let isIndeterminate: string;
    let label: string;
    let localizedKeyDictionary: string;
    let managedObjectContext: string;
    let maxValue: string;
    let maxWidth: string;
    let maximumRecents: string;
    let minValue: string;
    let minWidth: string;
    let mixedStateImage: string;
    let offStateImage: string;
    let onStateImage: string;
    let positioningRect: string;
    let predicate: string;
    let recentSearches: string;
    let representedFilename: string;
    let rowHeight: string;
    let selectedIdentifier: string;
    let selectedIndex: string;
    let selectedLabel: string;
    let selectedObject: string;
    let selectedObjects: string;
    let selectedTag: string;
    let selectedValue: string;
    let selectedValues: string;
    let selectionIndexPaths: string;
    let selectionIndexes: string;
    let sortDescriptors: string;
    let target: string;
    let textColor: string;
    let title: string;
    let toolTip: string;
    let transparent: string;
    let value: string;
    let valuePath: string;
    let valueURL: string;
    let visible: string;
    let warningValue: string;
    let width: string;
}
declare namespace NSBindingOption {
    let allowsEditingMultipleValuesSelection: string;
    let allowsNullArgument: string;
    let alwaysPresentsApplicationModalAlerts: string;
    let conditionallySetsEditable: string;
    let conditionallySetsEnabled: string;
    let conditionallySetsHidden: string;
    let contentPlacementTag: string;
    let continuouslyUpdatesValue: string;
    let createsSortDescriptor: string;
    let deletesObjectsOnRemove: string;
    let displayName: string;
    let displayPattern: string;
    let handlesContentAsCompoundValue: string;
    let insertsNullPlaceholder: string;
    let invokesSeparatelyWithArrayObjects: string;
    let multipleValuesPlaceholder: string;
    let noSelectionPlaceholder: string;
    let notApplicablePlaceholder: string;
    let nullPlaceholder: string;
    let predicateFormat: string;
    let raisesForNotApplicableKeys: string;
    let selectorName: string;
    let selectsAllWhenSettingContent: string;
    let validatesImmediately: string;
    let valueTransformer: string;
    let valueTransformerName: string;
}
declare namespace NSBitmapImageRep {
    enum Format {
        AlphaFirst = 1,
        AlphaNonpremultiplied = 2,
        FloatingPointSamples = 4,
        SixteenBitLittleEndian = 256,
        ThirtyTwoBitLittleEndian = 512,
        SixteenBitBigEndian = 1024,
        ThirtyTwoBitBigEndian = 2048
    }
    enum FileType {
        TIFF = 0,
        BMP = 1,
        GIF = 2,
        JPEG = 3,
        PNG = 4,
        JPEG2000 = 5
    }
    enum LoadStatus {
        UnknownType = -1,
        ReadingHeader = -2,
        WillNeedAllData = -3,
        InvalidData = -4,
        UnexpectedEOF = -5,
        Completed = -6
    }
    enum TIFFCompression {
        None = 1,
        CCITTFAX3 = 3,
        CCITTFAX4 = 4,
        LZW = 5,
        JPEG = 6,
        NEXT = 32766,
        PackBits = 32773,
        OldJPEG = 32865
    }
    let colorSyncProfileData: string;
    let compressionFactor: string;
    let compressionMethod: string;
    let currentFrame: string;
    let currentFrameDuration: string;
    let ditherTransparency: string;
    let exifData: string;
    let fallbackBackgroundColor: string;
    let frameCount: string;
    let gamma: string;
    let interlaced: string;
    let loopCount: string;
    let progressive: string;
    let rgbColorTable: string;
}
declare namespace NSBox {
    enum BoxType {
        Primary = 0,
        Separator = 2,
        Custom = 4
    }
    enum TitlePosition {
        NoTitle = 0,
        AboveTop = 1,
        AtTop = 2,
        BelowTop = 3,
        AboveBottom = 4,
        AtBottom = 5,
        BelowBottom = 6
    }
    let primary: NSBox.BoxType;
}
declare namespace NSBrowser {
    enum ColumnResizingType {
        NoColumnResizing = 0,
        AutoColumnResizing = 1,
        UserColumnResizing = 2
    }
    enum DropOperation {
        On = 0,
        Above = 1
    }
    let columnConfigurationDidChangeNotification: string;
    type ColumnsAutosaveName = String;
}
declare namespace NSButton {
    enum BezelStyle {
        Rounded = 1,
        RegularSquare = 2,
        Disclosure = 5,
        ShadowlessSquare = 6,
        Circular = 7,
        TexturedSquare = 8,
        HelpButton = 9,
        SmallSquare = 10,
        TexturedRounded = 11,
        RoundRect = 12,
        Recessed = 13,
        RoundedDisclosure = 14,
        Inline = 15
    }
    enum ButtonType {
        MomentaryLight = 0,
        PushOnPushOff = 1,
        Toggle = 2,
        Switch = 3,
        Radio = 4,
        MomentaryChange = 5,
        OnOff = 6,
        MomentaryPushIn = 7,
        Accelerator = 8,
        MultiLevelAccelerator = 9
    }
}
declare namespace NSCalendar {
    enum Options {
        WrapComponents = 1,
        MatchStrictly = 2,
        SearchBackwards = 4,
        MatchPreviousTimePreservingSmallerUnits = 256,
        MatchNextTimePreservingSmallerUnits = 512,
        MatchNextTime = 1024,
        MatchFirst = 4096,
        MatchLast = 8192
    }
    enum Unit {
        CalendarUnitEra = 2,
        CalendarUnitYear = 4,
        CalendarUnitMonth = 8,
        CalendarUnitDay = 16,
        CalendarUnitHour = 32,
        CalendarUnitMinute = 64,
        CalendarUnitSecond = 128,
        CalendarUnitWeekday = 512,
        CalendarUnitWeekdayOrdinal = 1024,
        CalendarUnitQuarter = 2048,
        CalendarUnitWeekOfMonth = 4096,
        CalendarUnitWeekOfYear = 8192,
        CalendarUnitYearForWeekOfYear = 16384,
        CalendarUnitNanosecond = 32768,
        CalendarUnitCalendar = 1048576,
        CalendarUnitTimeZone = 2097152,
        EraCalendarUnit = 2,
        YearCalendarUnit = 4,
        MonthCalendarUnit = 8,
        DayCalendarUnit = 16,
        HourCalendarUnit = 32,
        MinuteCalendarUnit = 64,
        SecondCalendarUnit = 128,
        WeekCalendarUnit = 256,
        WeekdayCalendarUnit = 512,
        WeekdayOrdinalCalendarUnit = 1024,
        QuarterCalendarUnit = 2048,
        WeekOfMonthCalendarUnit = 4096,
        WeekOfYearCalendarUnit = 8192,
        YearForWeekOfYearCalendarUnit = 16384,
        CalendarCalendarUnit = 1048576,
        TimeZoneCalendarUnit = 2097152
    }
    let buddhist: string;
    let chinese: string;
    let coptic: string;
    let ethiopicAmeteAlem: string;
    let ethiopicAmeteMihret: string;
    let gregorian: string;
    let hebrew: string;
    let ISO8601: string;
    let indian: string;
    let islamic: string;
    let islamicCivil: string;
    let islamicTabular: string;
    let islamicUmmAlQura: string;
    let japanese: string;
    let persian: string;
    let republicOfChina: string;
}
declare namespace NSCell {
    enum Attribute {
        CellDisabled = 0,
        CellState = 1,
        PushInCell = 2,
        CellEditable = 3,
        ChangeGrayCell = 4,
        CellHighlighted = 5,
        CellLightsByContents = 6,
        CellLightsByGray = 7,
        ChangeBackgroundCell = 8,
        CellLightsByBackground = 9,
        CellIsBordered = 10,
        CellHasOverlappingImage = 11,
        CellHasImageHorizontal = 12,
        CellHasImageOnLeftOrBottom = 13,
        CellChangesContents = 14,
        CellIsInsetButton = 15,
        CellAllowsMixedState = 16
    }
    enum HitResult {
        None = 0,
        ContentArea = 1,
        EditableTextArea = 2,
        TrackableArea = 4
    }
    enum StyleMask {
        NoCellMask = 0,
        ContentsCellMask = 1,
        PushInCellMask = 2,
        ChangeGrayCellMask = 4,
        ChangeBackgroundCellMask = 8
    }
    enum CellType {
        NullCellType = 0,
        TextCellType = 1,
        ImageCellType = 2
    }
}
declare namespace NSCoder {
    enum DecodingFailurePolicy {
        RaiseException = 0,
        SetErrorAndReturn = 1
    }
}
declare namespace NSCollectionView {
    enum UpdateAction {
        Insert = 0,
        Delete = 1,
        Reload = 2,
        Move = 3,
        None = 4
    }
    enum DropOperation {
        On = 0,
        Before = 1
    }
    enum ScrollDirection {
        Vertical = 0,
        Horizontal = 1
    }
    enum ScrollPosition {
        None = 0,
        Top = 1,
        CenteredVertically = 2,
        Bottom = 4,
        NearestHorizontalEdge = 512,
        Left = 8,
        CenteredHorizontally = 16,
        Right = 32,
        LeadingEdge = 64,
        TrailingEdge = 128,
        NearestVerticalEdge = 256
    }
    let elementKindInterItemGapIndicator: string;
    let elementKindSectionFooter: string;
    let elementKindSectionHeader: string;
    type DecorationElementKind = String;
    type SupplementaryElementKind = String;
}
declare namespace NSCollectionViewItem {
    enum HighlightState {
        None = 0,
        ForSelection = 1,
        ForDeselection = 2,
        AsDropTarget = 3
    }
}
declare namespace NSCollectionViewTransitionLayout {
    type AnimatedKey = String;
}
declare namespace NSColor {
    enum SystemEffect {
        None = 0,
        Pressed = 1,
        DeepPressed = 2,
        Disabled = 3,
        Rollover = 4
    }
    enum ColorType {
        ComponentBased = 0,
        Pattern = 1,
        Catalog = 2
    }
    let currentControlTintDidChangeNotification: string;
    let systemColorsDidChangeNotification: string;
    type Name = String;
}
declare namespace NSColorList {
    let didChangeNotification: string;
    type Name = String;
}
declare namespace NSColorPanel {
    enum Mode {
        None = -1,
        Gray = 0,
        RGB = 1,
        CMYK = 2,
        HSB = 3,
        CustomPalette = 4,
        ColorList = 5,
        Wheel = 6,
        Crayon = 7
    }
    enum Options {
        GrayModeMask = 1,
        RGBModeMask = 2,
        CMYKModeMask = 4,
        HSBModeMask = 8,
        CustomPaletteModeMask = 16,
        ColorListModeMask = 32,
        WheelModeMask = 64,
        CrayonModeMask = 128,
        AllModesMask = 65535
    }
    let colorDidChangeNotification: string;
}
declare namespace NSColorSpace {
    enum Model {
        Unknown = -1,
        Gray = 0,
        RGB = 1,
        CMYK = 2,
        LAB = 3,
        DeviceN = 4,
        Indexed = 5,
        Patterned = 6
    }
}
declare namespace NSColorSpaceName {
    let calibratedRGB: string;
    let calibratedWhite: string;
    let custom: string;
    let deviceCMYK: string;
    let deviceRGB: string;
    let deviceWhite: string;
    let named: string;
    let pattern: string;
}
declare namespace NSComboBox {
    let selectionDidChangeNotification: string;
    let selectionIsChangingNotification: string;
    let willDismissNotification: string;
    let willPopUpNotification: string;
}
declare namespace NSComparisonPredicate {
    enum Modifier {
        DirectPredicateModifier = 0,
        AllPredicateModifier = 1,
        AnyPredicateModifier = 2
    }
    enum Options {
        CaseInsensitivePredicateOption = 1,
        DiacriticInsensitivePredicateOption = 2,
        NormalizedPredicateOption = 4
    }
    enum Operator {
        LessThanPredicateOperatorType = 0,
        LessThanOrEqualToPredicateOperatorType = 1,
        GreaterThanPredicateOperatorType = 2,
        GreaterThanOrEqualToPredicateOperatorType = 3,
        EqualToPredicateOperatorType = 4,
        NotEqualToPredicateOperatorType = 5,
        MatchesPredicateOperatorType = 6,
        LikePredicateOperatorType = 7,
        BeginsWithPredicateOperatorType = 8,
        EndsWithPredicateOperatorType = 9,
        InPredicateOperatorType = 10,
        CustomSelectorPredicateOperatorType = 11,
        ContainsPredicateOperatorType = 99,
        BetweenPredicateOperatorType = 100
    }
}
declare namespace NSCompoundPredicate {
    enum LogicalType {
        NotPredicateType = 0,
        AndPredicateType = 1,
        OrPredicateType = 2
    }
}
declare namespace NSControl {
    enum ImagePosition {
        NoImage = 0,
        ImageOnly = 1,
        ImageLeft = 2,
        ImageRight = 3,
        ImageBelow = 4,
        ImageAbove = 5,
        ImageOverlaps = 6,
        ImageLeading = 7,
        ImageTrailing = 8
    }
    enum ControlSize {
        Regular = 0,
        Small = 1,
        Mini = 2
    }
    let mixed: number;
    let off: number;
    let on: number;
    let textDidBeginEditingNotification: string;
    let textDidChangeNotification: string;
    let textDidEndEditingNotification: string;
}
declare namespace NSData {
    enum Base64DecodingOptions {
        IgnoreUnknownCharacters = 1
    }
    enum Base64EncodingOptions {
        Encoding64CharacterLineLength = 1,
        Encoding76CharacterLineLength = 2,
        EncodingEndLineWithCarriageReturn = 16,
        EncodingEndLineWithLineFeed = 32
    }
    enum CompressionAlgorithm {
        LZFSE = 0,
        LZ4 = 1,
        LZMA = 2,
        Zlib = 3
    }
    enum ReadingOptions {
        DataReadingMappedIfSafe = 1,
        DataReadingUncached = 2,
        DataReadingMappedAlways = 8,
        DataReadingMapped = 1,
        MappedRead = 1,
        UncachedRead = 2
    }
    enum SearchOptions {
        Backwards = 1,
        Anchored = 2
    }
    enum WritingOptions {
        DataWritingAtomic = 1,
        DataWritingWithoutOverwriting = 2,
        DataWritingFileProtectionNone = 268435456,
        DataWritingFileProtectionComplete = 536870912,
        DataWritingFileProtectionCompleteUnlessOpen = 805306368,
        DataWritingFileProtectionCompleteUntilFirstUserAuthentication = 1073741824,
        DataWritingFileProtectionMask = 4026531840,
        AtomicWrite = 1
    }
    type Element = number;
    type Index = number;
    type Iterator = IndexingIterator;
    type SubSequence = Slice;
    type Indices = Range;
}
declare namespace NSDatePicker {
    enum ElementFlags {
        HourMinute = 12,
        HourMinuteSecond = 14,
        TimeZone = 16,
        YearMonth = 192,
        YearMonthDay = 224,
        Era = 256
    }
    enum Mode {
        Single = 0,
        Range = 1
    }
    enum Style {
        TextFieldAndStepper = 0,
        ClockAndCalendar = 1,
        TextField = 2
    }
    let clockAndCalendar: NSDatePicker.Style;
    let era: NSDatePicker.ElementFlags;
    let hourMinute: NSDatePicker.ElementFlags;
    let hourMinuteSecond: NSDatePicker.ElementFlags;
    let range: NSDatePicker.Mode;
    let single: NSDatePicker.Mode;
    let textFieldAndStepper: NSDatePicker.Style;
    let textField: NSDatePicker.Style;
    let timeZone: NSDatePicker.ElementFlags;
    let yearMonth: NSDatePicker.ElementFlags;
    let yearMonthDay: NSDatePicker.ElementFlags;
}
declare namespace NSDecimalNumber {
    enum CalculationError {
        NoError = 0,
        LossOfPrecision = 1,
        Underflow = 2,
        Overflow = 3,
        DivideByZero = 4
    }
    enum RoundingMode {
        Plain = 0,
        Down = 1,
        Up = 2,
        Bankers = 3
    }
}
declare namespace NSDeviceDescriptionKey {
    let bitsPerSample: string;
    let colorSpaceName: string;
    let isPrinter: string;
    let isScreen: string;
    let resolution: string;
    let size: string;
}
declare namespace NSDocument {
    enum ChangeType {
        ChangeDone = 0,
        ChangeUndone = 1,
        ChangeRedone = 5,
        ChangeCleared = 2,
        ChangeReadOtherContents = 3,
        ChangeAutosaved = 4,
        ChangeDiscardable = 256
    }
    enum SaveOperationType {
        SaveOperation = 0,
        SaveAsOperation = 1,
        SaveToOperation = 2,
        AutosaveInPlaceOperation = 4,
        AutosaveElsewhereOperation = 3,
        AutosaveAsOperation = 5,
        AutosaveOperation = 3
    }
}
declare namespace NSDraggingItem {
    let icon: string;
    let label: string;
}
declare namespace NSDrawer {
    enum State {
        ClosedState = 0,
        OpeningState = 1,
        OpenState = 2,
        ClosingState = 3
    }
}
declare namespace NSEnumerator {
    type Iterator = NSFastEnumerationIterator;
}
declare namespace NSError {
    type UserInfoKey = string;
}
declare namespace NSEvent {
    enum ButtonMask {
        PenTip = 1,
        PenLowerSide = 2,
        PenUpperSide = 4
    }
    enum GestureAxis {
        None = 0,
        Horizontal = 1,
        Vertical = 2
    }
    enum EventTypeMask {
        LeftMouseDown = 2,
        LeftMouseUp = 4,
        RightMouseDown = 8,
        RightMouseUp = 16,
        MouseMoved = 32,
        LeftMouseDragged = 64,
        RightMouseDragged = 128,
        MouseEntered = 256,
        MouseExited = 512,
        KeyDown = 1024,
        KeyUp = 2048,
        FlagsChanged = 4096,
        AppKitDefined = 8192,
        SystemDefined = 16384,
        ApplicationDefined = 32768,
        Periodic = 65536,
        CursorUpdate = 131072,
        ScrollWheel = 4194304,
        TabletPoint = 8388608,
        TabletProximity = 16777216,
        OtherMouseDown = 33554432,
        OtherMouseUp = 67108864,
        OtherMouseDragged = 134217728,
        Gesture = 536870912,
        Magnify = 1073741824,
        Swipe = 2147483648,
        Rotate = 262144,
        BeginGesture = 524288,
        EndGesture = 1048576,
        SmartMagnify = 4294967296,
        Pressure = 17179869184,
        DirectTouch = 137438953472,
        ChangeMode = 274877906944,
        Any = -1
    }
    enum ModifierFlags {
        CapsLock = 65536,
        Shift = 131072,
        Control = 262144,
        Option = 524288,
        Command = 1048576,
        NumericPad = 2097152,
        Help = 4194304,
        Function = 8388608,
        DeviceIndependentFlagsMask = 4294901760
    }
    enum Phase {
        None = 0,
        Began = 1,
        Stationary = 2,
        Changed = 4,
        Ended = 8,
        Cancelled = 16,
        MayBegin = 32
    }
    enum EventSubtype {
        WindowExposed = 0,
        ApplicationActivated = 1,
        ApplicationDeactivated = 2,
        WindowMoved = 4,
        ScreenChanged = 8,
        PowerOff = 1,
        MouseEvent = 0,
        TabletPoint = 1,
        TabletProximity = 2,
        Touch = 3
    }
    enum SwipeTrackingOptions {
        LockDirection = 1,
        ClampGestureAmount = 2
    }
    enum EventType {
        LeftMouseDown = 1,
        LeftMouseUp = 2,
        RightMouseDown = 3,
        RightMouseUp = 4,
        MouseMoved = 5,
        LeftMouseDragged = 6,
        RightMouseDragged = 7,
        MouseEntered = 8,
        MouseExited = 9,
        KeyDown = 10,
        KeyUp = 11,
        FlagsChanged = 12,
        AppKitDefined = 13,
        SystemDefined = 14,
        ApplicationDefined = 15,
        Periodic = 16,
        CursorUpdate = 17,
        ScrollWheel = 22,
        TabletPoint = 23,
        TabletProximity = 24,
        OtherMouseDown = 25,
        OtherMouseUp = 26,
        OtherMouseDragged = 27,
        Gesture = 29,
        Magnify = 30,
        Swipe = 31,
        Rotate = 18,
        BeginGesture = 19,
        EndGesture = 20,
        SmartMagnify = 32,
        QuickLook = 33,
        Pressure = 34,
        DirectTouch = 37,
        ChangeMode = 38
    }
    enum PointingDeviceType {
        Unknown = 0,
        Pen = 1,
        Cursor = 2,
        Eraser = 3
    }
    enum PressureBehavior {
        Unknown = -1,
        PrimaryDefault = 0,
        PrimaryClick = 1,
        PrimaryGeneric = 2,
        PrimaryAccelerator = 3,
        PrimaryDeepClick = 5,
        PrimaryDeepDrag = 6
    }
    let foreverDuration: number;
}
declare namespace NSExceptionName {
    let abortModalException: string;
    let abortPrintingException: string;
    let appKitIgnoredException: string;
    let appKitVirtualMemoryException: string;
    let badBitmapParametersException: string;
    let badComparisonException: string;
    let badRTFColorTableException: string;
    let badRTFDirectiveException: string;
    let badRTFFontTableException: string;
    let badRTFStyleSheetException: string;
    let browserIllegalDelegateException: string;
    let colorListIOException: string;
    let colorListNotEditableException: string;
    let draggingException: string;
    let fontUnavailableException: string;
    let illegalSelectorException: string;
    let imageCacheException: string;
    let nibLoadingException: string;
    let NSPPDIncludeNotFoundException: string;
    let NSPPDIncludeStackOverflowException: string;
    let NSPPDIncludeStackUnderflowException: string;
    let NSPPDParseException: string;
    let pasteboardCommunicationException: string;
    let printOperationExistsException: string;
    let printPackageException: string;
    let printingCommunicationException: string;
    let NSRTFPropertyStackOverflowException: string;
    let NSTIFFException: string;
    let textLineTooLongException: string;
    let textNoSelectionException: string;
    let textReadException: string;
    let textWriteException: string;
    let typedStreamVersionException: string;
    let windowServerCommunicationException: string;
    let wordTablesReadException: string;
    let wordTablesWriteException: string;
    let characterConversionException: string;
    let decimalNumberDivideByZeroException: string;
    let decimalNumberExactnessException: string;
    let decimalNumberOverflowException: string;
    let decimalNumberUnderflowException: string;
    let destinationInvalidException: string;
    let fileHandleOperationException: string;
    let genericException: string;
    let inconsistentArchiveException: string;
    let internalInconsistencyException: string;
    let invalidArchiveOperationException: string;
    let invalidArgumentException: string;
    let invalidReceivePortException: string;
    let invalidSendPortException: string;
    let invalidUnarchiveOperationException: string;
    let invocationOperationCancelledException: string;
    let invocationOperationVoidResultException: string;
    let mallocException: string;
    let objectInaccessibleException: string;
    let objectNotAvailableException: string;
    let oldStyleException: string;
    let parseErrorException: string;
    let portReceiveException: string;
    let portSendException: string;
    let portTimeoutException: string;
    let rangeException: string;
    let undefinedKeyException: string;
}
declare namespace NSExpression {
    enum ExpressionType {
        ConstantValueExpressionType = 0,
        EvaluatedObjectExpressionType = 1,
        VariableExpressionType = 2,
        KeyPathExpressionType = 3,
        FunctionExpressionType = 4,
        UnionSetExpressionType = 5,
        IntersectSetExpressionType = 6,
        MinusSetExpressionType = 7,
        SubqueryExpressionType = 13,
        AggregateExpressionType = 14,
        AnyKeyExpressionType = 15,
        BlockExpressionType = 19,
        ConditionalExpressionType = 20
    }
}
declare namespace NSFileCoordinator {
    enum ReadingOptions {
        WithoutChanges = 1,
        ResolvesSymbolicLink = 2,
        ImmediatelyAvailableMetadataOnly = 4,
        ForUploading = 8
    }
    enum WritingOptions {
        ForDeleting = 1,
        ForMoving = 2,
        ForMerging = 4,
        ForReplacing = 8,
        ContentIndependentMetadataOnly = 16
    }
}
declare namespace NSFileVersion {
    enum AddingOptions {
        ByMoving = 1
    }
    enum ReplacingOptions {
        ByMoving = 1
    }
}
declare namespace NSFont {
    let antialiasThresholdChangedNotification: string;
    let identityMatrix: number;
    let fontSetChangedNotification: string;
    let black: number;
    let bold: number;
    let heavy: number;
    let light: number;
    let medium: number;
    let regular: number;
    let semibold: number;
    let thin: number;
    let ultraLight: number;
}
declare namespace NSFontAssetRequest {
    enum Options {
        UsesStandardUI = 1
    }
}
declare namespace NSFontCollection {
    enum Visibility {
        Process = 1,
        User = 2,
        Computer = 4
    }
    let actionUserInfoKey: string;
    let allFonts: string;
    let didChangeNotification: string;
    let favorites: string;
    let nameUserInfoKey: string;
    let oldNameUserInfoKey: string;
    let recentlyUsed: string;
    let user: string;
    let visibilityUserInfoKey: string;
    let hidden: string;
    let renamed: string;
    let shown: string;
}
declare namespace NSFontDescriptor {
    enum SymbolicTraits {
        TraitItalic = 1,
        TraitBold = 2,
        TraitExpanded = 32,
        TraitCondensed = 64,
        TraitMonoSpace = 1024,
        TraitVertical = 2048,
        TraitUIOptimized = 4096,
        TraitTightLeading = 32768,
        TraitLooseLeading = 65536,
        ClassMask = 4026531840,
        ClassUnknown = 0,
        ClassOldStyleSerifs = 268435456,
        ClassTransitionalSerifs = 536870912,
        ClassModernSerifs = 805306368,
        ClassClarendonSerifs = 1073741824,
        ClassSlabSerifs = 1342177280,
        ClassFreeformSerifs = 1879048192,
        ClassSansSerif = 2147483648,
        ClassOrnamentals = 2415919104,
        ClassScripts = 2684354560,
        ClassSymbolic = 3221225472
    }
    let cascadeList: string;
    let characterSet: string;
    let default_: string;
    let monospaced: string;
    let rounded: string;
    let serif: string;
    let face: string;
    let family: string;
    let selectorIdentifier: string;
    let featureSettings: string;
    let typeIdentifier: string;
    let fixedAdvance: string;
    let matrix: string;
    let name: string;
    let size: string;
    let slant: string;
    let symbolic: string;
    let traits: string;
    let variation: string;
    let defaultValue: string;
    let identifier: string;
    let maximumValue: string;
    let minimumValue: string;
    let visibleName: string;
    let weight: string;
    let width: string;
}
declare namespace NSFontPanel {
    enum ModeMask {
        ModeMaskFace = 1,
        ModeMaskSize = 2,
        ModeMaskCollection = 4,
        ModeMaskUnderlineEffect = 256,
        ModeMaskStrikethroughEffect = 512,
        ModeMaskTextColorEffect = 1024,
        ModeMaskDocumentColorEffect = 2048,
        ModeMaskShadowEffect = 4096,
        ModeMaskAllEffects = 1048320,
        ModesMaskStandardModes = 65535,
        ModesMaskAllModes = 4294967295
    }
}
declare namespace NSGestureRecognizer {
    enum State {
        Possible = 0,
        Began = 1,
        Changed = 2,
        Ended = 3,
        Cancelled = 4,
        Failed = 5,
        Recognized = 3
    }
}
declare namespace NSGradient {
    enum DrawingOptions {
        DrawsBeforeStartingLocation = 1,
        DrawsAfterEndingLocation = 2
    }
}
declare namespace NSGraphicsContext {
    let destination: string;
    let pdf: string;
    let postScript: string;
    let representationFormat: string;
}
declare namespace NSGridCell {
    enum Placement {
        Inherited = 0,
        None = 1,
        Leading = 2,
        Top = 2,
        Trailing = 3,
        Bottom = 3,
        Center = 4,
        Fill = 5
    }
}
declare namespace NSGridRow {
    enum Alignment {
        Inherited = 0,
        None = 1,
        FirstBaseline = 2,
        LastBaseline = 3
    }
}
declare namespace NSGridView {
    let sizedForContent: number;
}
declare namespace NSHapticFeedbackManager {
    enum FeedbackPattern {
        Generic = 0,
        Alignment = 1,
        LevelChange = 2
    }
    enum PerformanceTime {
        Default = 0,
        Now = 1,
        DrawCompleted = 2
    }
}
declare namespace NSHelpManager {
    let contextHelpModeDidActivateNotification: string;
    let contextHelpModeDidDeactivateNotification: string;
    type BookName = String;
    type AnchorName = String;
    type ContextHelpKey = String;
}
declare namespace NSImage {
    enum CacheMode {
        Default = 0,
        Always = 1,
        BySize = 2,
        Never = 3
    }
    enum LayoutDirection {
        Unspecified = -1,
        LeftToRight = 2,
        RightToLeft = 3
    }
    enum LoadStatus {
        Completed = 0,
        Cancelled = 1,
        InvalidData = 2,
        UnexpectedEOF = 3,
        ReadError = 4
    }
    enum ResizingMode {
        Stretch = 0,
        Tile = 1
    }
    let actionTemplateName: string;
    let addTemplateName: string;
    let advancedName: string;
    let applicationIconName: string;
    let bluetoothTemplateName: string;
    let bonjourName: string;
    let bookmarksTemplateName: string;
    let cautionName: string;
    let colorPanelName: string;
    let columnViewTemplateName: string;
    let computerName: string;
    let enterFullScreenTemplateName: string;
    let everyoneName: string;
    let exitFullScreenTemplateName: string;
    let flowViewTemplateName: string;
    let folderName: string;
    let folderBurnableName: string;
    let folderSmartName: string;
    let followLinkFreestandingTemplateName: string;
    let fontPanelName: string;
    let goBackTemplateName: string;
    let goForwardTemplateName: string;
    let goLeftTemplateName: string;
    let goRightTemplateName: string;
    let homeTemplateName: string;
    let iChatTheaterTemplateName: string;
    let iconViewTemplateName: string;
    let infoName: string;
    let invalidDataFreestandingTemplateName: string;
    let leftFacingTriangleTemplateName: string;
    let listViewTemplateName: string;
    let lockLockedTemplateName: string;
    let lockUnlockedTemplateName: string;
    let menuMixedStateTemplateName: string;
    let menuOnStateTemplateName: string;
    let mobileMeName: string;
    let multipleDocumentsName: string;
    let networkName: string;
    let pathTemplateName: string;
    let preferencesGeneralName: string;
    let quickLookTemplateName: string;
    let refreshFreestandingTemplateName: string;
    let refreshTemplateName: string;
    let removeTemplateName: string;
    let revealFreestandingTemplateName: string;
    let rightFacingTriangleTemplateName: string;
    let shareTemplateName: string;
    let slideshowTemplateName: string;
    let smartBadgeTemplateName: string;
    let statusAvailableName: string;
    let statusNoneName: string;
    let statusPartiallyAvailableName: string;
    let statusUnavailableName: string;
    let stopProgressFreestandingTemplateName: string;
    let stopProgressTemplateName: string;
    let touchBarAddDetailTemplateName: string;
    let touchBarAddTemplateName: string;
    let touchBarAlarmTemplateName: string;
    let touchBarAudioInputMuteTemplateName: string;
    let touchBarAudioInputTemplateName: string;
    let touchBarAudioOutputMuteTemplateName: string;
    let touchBarAudioOutputVolumeHighTemplateName: string;
    let touchBarAudioOutputVolumeLowTemplateName: string;
    let touchBarAudioOutputVolumeMediumTemplateName: string;
    let touchBarAudioOutputVolumeOffTemplateName: string;
    let touchBarBookmarksTemplateName: string;
    let touchBarColorPickerFillName: string;
    let touchBarColorPickerFontName: string;
    let touchBarColorPickerStrokeName: string;
    let touchBarCommunicationAudioTemplateName: string;
    let touchBarCommunicationVideoTemplateName: string;
    let touchBarComposeTemplateName: string;
    let touchBarDeleteTemplateName: string;
    let touchBarDownloadTemplateName: string;
    let touchBarEnterFullScreenTemplateName: string;
    let touchBarExitFullScreenTemplateName: string;
    let touchBarFastForwardTemplateName: string;
    let touchBarFolderCopyToTemplateName: string;
    let touchBarFolderMoveToTemplateName: string;
    let touchBarFolderTemplateName: string;
    let touchBarGetInfoTemplateName: string;
    let touchBarGoBackTemplateName: string;
    let touchBarGoDownTemplateName: string;
    let touchBarGoForwardTemplateName: string;
    let touchBarGoUpTemplateName: string;
    let touchBarHistoryTemplateName: string;
    let touchBarIconViewTemplateName: string;
    let touchBarListViewTemplateName: string;
    let touchBarMailTemplateName: string;
    let touchBarNewFolderTemplateName: string;
    let touchBarNewMessageTemplateName: string;
    let touchBarOpenInBrowserTemplateName: string;
    let touchBarPauseTemplateName: string;
    let touchBarPlayPauseTemplateName: string;
    let touchBarPlayTemplateName: string;
    let touchBarPlayheadTemplateName: string;
    let touchBarQuickLookTemplateName: string;
    let touchBarRecordStartTemplateName: string;
    let touchBarRecordStopTemplateName: string;
    let touchBarRefreshTemplateName: string;
    let touchBarRemoveTemplateName: string;
    let touchBarRewindTemplateName: string;
    let touchBarRotateLeftTemplateName: string;
    let touchBarRotateRightTemplateName: string;
    let touchBarSearchTemplateName: string;
    let touchBarShareTemplateName: string;
    let touchBarSidebarTemplateName: string;
    let touchBarSkipAhead15SecondsTemplateName: string;
    let touchBarSkipAhead30SecondsTemplateName: string;
    let touchBarSkipAheadTemplateName: string;
    let touchBarSkipBack15SecondsTemplateName: string;
    let touchBarSkipBack30SecondsTemplateName: string;
    let touchBarSkipBackTemplateName: string;
    let touchBarSkipToEndTemplateName: string;
    let touchBarSkipToStartTemplateName: string;
    let touchBarSlideshowTemplateName: string;
    let touchBarTagIconTemplateName: string;
    let touchBarTextBoldTemplateName: string;
    let touchBarTextBoxTemplateName: string;
    let touchBarTextCenterAlignTemplateName: string;
    let touchBarTextItalicTemplateName: string;
    let touchBarTextJustifiedAlignTemplateName: string;
    let touchBarTextLeftAlignTemplateName: string;
    let touchBarTextListTemplateName: string;
    let touchBarTextRightAlignTemplateName: string;
    let touchBarTextStrikethroughTemplateName: string;
    let touchBarTextUnderlineTemplateName: string;
    let touchBarUserAddTemplateName: string;
    let touchBarUserGroupTemplateName: string;
    let touchBarUserTemplateName: string;
    let touchBarVolumeDownTemplateName: string;
    let touchBarVolumeUpTemplateName: string;
    let trashEmptyName: string;
    let trashFullName: string;
    let userName: string;
    let userAccountsName: string;
    let userGroupName: string;
    let userGuestName: string;
    type Name = String;
}
declare namespace NSImageRep {
    let ctm: string;
    let interpolation: string;
    let userInterfaceLayoutDirection: string;
    let registryDidChangeNotification: string;
}
declare namespace NSImageView {
    enum FrameStyle {
        None = 0,
        Photo = 1,
        GrayBezel = 2,
        Groove = 3,
        Button = 4
    }
}
declare namespace NSIndexSet {
    type Element = NSIndexSetIterator;
    type Iterator = NSIndexSetIterator;
}
declare namespace NSItemProvider {
    enum ErrorCode {
        UnknownError = -1,
        ItemUnavailableError = -1000,
        UnexpectedValueClassError = -1100,
        UnavailableCoercionError = -1200
    }
    let errorDomain: string;
}
declare namespace NSKeyValueChangeKey {
    let indexesKey: string;
    let kindKey: string;
    let newKey: string;
    let notificationIsPriorKey: string;
    let oldKey: string;
}
declare namespace NSKeyValueOperator {
    let averageKeyValueOperator: string;
    let countKeyValueOperator: string;
    let distinctUnionOfArraysKeyValueOperator: string;
    let distinctUnionOfObjectsKeyValueOperator: string;
    let distinctUnionOfSetsKeyValueOperator: string;
    let maximumKeyValueOperator: string;
    let minimumKeyValueOperator: string;
    let sumKeyValueOperator: string;
    let unionOfArraysKeyValueOperator: string;
    let unionOfObjectsKeyValueOperator: string;
    let unionOfSetsKeyValueOperator: string;
}
declare namespace NSLayoutConstraint {
    enum Attribute {
        Left = 1,
        Right = 2,
        Top = 3,
        Bottom = 4,
        Leading = 5,
        Trailing = 6,
        Width = 7,
        Height = 8,
        CenterX = 9,
        CenterY = 10,
        LastBaseline = 11,
        Baseline = 11,
        FirstBaseline = 12,
        NotAnAttribute = 0
    }
    enum Orientation {
        Horizontal = 0,
        Vertical = 1
    }
    enum FormatOptions {
        AlignAllLeft = 2,
        AlignAllRight = 4,
        AlignAllTop = 8,
        AlignAllBottom = 16,
        AlignAllLeading = 32,
        AlignAllTrailing = 64,
        AlignAllCenterX = 512,
        AlignAllCenterY = 1024,
        AlignAllLastBaseline = 2048,
        AlignAllFirstBaseline = 4096,
        AlignAllBaseline = 2048,
        AlignmentMask = 65535,
        DirectionLeadingToTrailing = 0,
        DirectionLeftToRight = 65536,
        DirectionRightToLeft = 131072,
        DirectionMask = 196608
    }
    enum Relation {
        LessThanOrEqual = -1,
        Equal = 0,
        GreaterThanOrEqual = 1
    }
    let defaultHigh: number;
    let defaultLow: number;
    let dragThatCanResizeWindow: number;
    let dragThatCannotResizeWindow: number;
    let fittingSizeCompression: number;
    let required: number;
    let windowSizeStayPut: number;
}
declare namespace NSLayoutManager {
    enum ControlCharacterAction {
        ZeroAdvancement = 1,
        Whitespace = 2,
        HorizontalTab = 4,
        LineBreak = 8,
        ParagraphBreak = 16,
        ContainerBreak = 32
    }
    enum GlyphProperty {
        Null = 1,
        ControlCharacter = 2,
        Elastic = 4,
        NonBaseCharacter = 8
    }
    enum TextLayoutOrientation {
        Horizontal = 0,
        Vertical = 1
    }
    enum TypesetterBehavior {
        LatestBehavior = -1,
        OriginalBehavior = 0,
        Behavior_10_2_WithCompatibility = 1,
        Behavior_10_2 = 2,
        Behavior_10_3 = 3,
        Behavior_10_4 = 4
    }
}
declare namespace NSLevelIndicator {
    enum PlaceholderVisibility {
        Automatic = 0,
        Always = 1,
        WhileEditing = 2
    }
    enum Style {
        Relevancy = 0,
        ContinuousCapacity = 1,
        DiscreteCapacity = 2,
        Rating = 3
    }
}
declare namespace NSLinguisticTag {
    let adjective: string;
    let adverb: string;
    let classifier: string;
    let closeParenthesis: string;
    let closeQuote: string;
    let conjunction: string;
    let dash: string;
    let determiner: string;
    let idiom: string;
    let interjection: string;
    let noun: string;
    let number: string;
    let openParenthesis: string;
    let openQuote: string;
    let organizationName: string;
    let other: string;
    let otherPunctuation: string;
    let otherWhitespace: string;
    let otherWord: string;
    let paragraphBreak: string;
    let particle: string;
    let personalName: string;
    let placeName: string;
    let preposition: string;
    let pronoun: string;
    let punctuation: string;
    let sentenceTerminator: string;
    let verb: string;
    let whitespace: string;
    let word: string;
    let wordJoiner: string;
}
declare namespace NSLinguisticTagScheme {
    let language: string;
    let lemma: string;
    let lexicalClass: string;
    let nameType: string;
    let nameTypeOrLexicalClass: string;
    let script: string;
    let tokenType: string;
}
declare namespace NSLinguisticTagger {
    enum Options {
        OmitWords = 1,
        OmitPunctuation = 2,
        OmitWhitespace = 4,
        OmitOther = 8,
        JoinNames = 16
    }
}
declare namespace NSLocale {
    enum LanguageDirection {
        Unknown = 0,
        LeftToRight = 1,
        RightToLeft = 2,
        TopToBottom = 3,
        BottomToTop = 4
    }
    let currentLocaleDidChangeNotification: string;
    let alternateQuotationBeginDelimiterKey: string;
    let alternateQuotationEndDelimiterKey: string;
    let calendar: string;
    let collationIdentifier: string;
    let collatorIdentifier: string;
    let countryCode: string;
    let currencyCode: string;
    let currencySymbol: string;
    let decimalSeparator: string;
    let exemplarCharacterSet: string;
    let groupingSeparator: string;
    let identifier: string;
    let languageCode: string;
    let measurementSystem: string;
    let quotationBeginDelimiterKey: string;
    let quotationEndDelimiterKey: string;
    let scriptCode: string;
    let usesMetricSystem: string;
    let variantCode: string;
}
declare namespace NSMachPort {
    enum Options {
        DeallocateNone = 0,
        DeallocateSendRight = 1,
        DeallocateReceiveRight = 2
    }
}
declare namespace NSManagedObject {
    type ObjectWillChangePublisher = ObservableObjectPublisher;
}
declare namespace NSMatrix {
    enum Mode {
        RadioModeMatrix = 0,
        HighlightModeMatrix = 1,
        ListModeMatrix = 2,
        TrackModeMatrix = 3
    }
}
declare namespace NSMediaLibraryBrowserController {
    enum Library {
        Audio = 1,
        Image = 2,
        Movie = 4
    }
}
declare namespace NSMenu {
    enum Properties {
        PropertyItemTitle = 1,
        PropertyItemAttributedTitle = 2,
        PropertyItemKeyEquivalent = 4,
        PropertyItemImage = 8,
        PropertyItemEnabled = 16,
        PropertyItemAccessibilityDescription = 32
    }
    let didAddItemNotification: string;
    let didBeginTrackingNotification: string;
    let didChangeItemNotification: string;
    let didEndTrackingNotification: string;
    let didRemoveItemNotification: string;
    let didSendActionNotification: string;
    let willSendActionNotification: string;
}
declare namespace NSMenuItem {
    let importFromDeviceIdentifier: string;
}
declare namespace NSNib {
    type Name = String;
}
declare namespace NSNotification {
    let AVAssetChapterMetadataGroupsDidChange: string;
    let AVAssetContainsFragmentsDidChange: string;
    let AVAssetDurationDidChange: string;
    let AVAssetMediaSelectionGroupsDidChange: string;
    let AVAssetTrackSegmentsDidChange: string;
    let AVAssetTrackTimeRangeDidChange: string;
    let AVAssetTrackTrackAssociationsDidChange: string;
    let AVAssetWasDefragmented: string;
    let AVAudioEngineConfigurationChange: string;
    let AVAudioUnitComponentTagsDidChange: string;
    let AVCaptureDeviceSubjectAreaDidChange: string;
    let AVCaptureDeviceWasConnected: string;
    let AVCaptureDeviceWasDisconnected: string;
    let AVCaptureInputPortFormatDescriptionDidChange: string;
    let AVCaptureSessionDidStartRunning: string;
    let AVCaptureSessionDidStopRunning: string;
    let AVCaptureSessionInterruptionEnded: string;
    let AVCaptureSessionRuntimeError: string;
    let AVCaptureSessionWasInterrupted: string;
    let AVFragmentedMovieContainsMovieFragmentsDidChange: string;
    let AVFragmentedMovieDurationDidChange: string;
    let AVFragmentedMovieTrackSegmentsDidChange: string;
    let AVFragmentedMovieTrackTimeRangeDidChange: string;
    let AVFragmentedMovieWasDefragmented: string;
    let AVPlayerAvailableHDRModesDidChange: string;
    let AVPlayerItemDidPlayToEndTime: string;
    let AVPlayerItemFailedToPlayToEndTime: string;
    let AVPlayerItemNewAccessLogEntry: string;
    let AVPlayerItemNewErrorLogEntry: string;
    let AVPlayerItemPlaybackStalled: string;
    let AVPlayerItemTimeJumped: string;
    let AVRouteDetectorMultipleRoutesDetectedDidChange: string;
    let AVSampleBufferAudioRendererWasFlushedAutomatically: string;
    let AVSampleBufferDisplayLayerFailedToDecode: string;
    let NSAppleEventManagerWillProcessFirstEvent: string;
    let NSBundleResourceRequestLowDiskSpace: string;
    let NSCalendarDayChanged: string;
    let NSClassDescriptionNeededForClass: string;
    let NSDidBecomeSingleThreaded: string;
    let NSExtensionHostDidBecomeActive: string;
    let NSExtensionHostDidEnterBackground: string;
    let NSExtensionHostWillEnterForeground: string;
    let NSExtensionHostWillResignActive: string;
    let NSFileHandleConnectionAccepted: string;
    let NSFileHandleDataAvailable: string;
    let NSFileHandleReadToEndOfFileCompletion: string;
    let NSHTTPCookieManagerAcceptPolicyChanged: string;
    let NSHTTPCookieManagerCookiesChanged: string;
    let NSMetadataQueryDidFinishGathering: string;
    let NSMetadataQueryDidStartGathering: string;
    let NSMetadataQueryDidUpdate: string;
    let NSMetadataQueryGatheringProgress: string;
    let NSProcessInfoPowerStateDidChange: string;
    let NSSystemClockDidChange: string;
    let NSSystemTimeZoneDidChange: string;
    let NSThreadWillExit: string;
    let NSURLCredentialStorageChanged: string;
    let NSUbiquityIdentityDidChange: string;
    let NSUndoManagerCheckpoint: string;
    let NSUndoManagerDidCloseUndoGroup: string;
    let NSUndoManagerDidOpenUndoGroup: string;
    let NSUndoManagerDidRedoChange: string;
    let NSUndoManagerDidUndoChange: string;
    let NSUndoManagerWillCloseUndoGroup: string;
    let NSUndoManagerWillRedoChange: string;
    let NSUndoManagerWillUndoChange: string;
    let NSWillBecomeMultiThreaded: string;
    let IKFilterBrowserFilterDoubleClick: string;
    let IKFilterBrowserFilterSelected: string;
    let IKFilterBrowserWillPreviewFilter: string;
    let quartzFilterManagerDidAddFilter: string;
    let quartzFilterManagerDidModifyFilter: string;
    let quartzFilterManagerDidRemoveFilter: string;
    let quartzFilterManagerDidSelectFilter: string;
}
declare namespace NSNumber {
    type BooleanLiteralType = boolean;
    type IntegerLiteralType = number;
    type FloatLiteralType = number;
}
declare namespace NSOrderedSet {
    type Iterator = NSFastEnumerationIterator;
}
declare namespace NSOutlineView {
    let columnDidMoveNotification: string;
    let columnDidResizeNotification: string;
    let disclosureButtonIdentifier: string;
    let itemDidCollapseNotification: string;
    let itemDidExpandNotification: string;
    let itemWillCollapseNotification: string;
    let itemWillExpandNotification: string;
    let selectionDidChangeNotification: string;
    let selectionIsChangingNotification: string;
    let showHideButtonIdentifier: string;
}
declare namespace NSPDFPanel {
    enum Options {
        ShowsPaperSize = 4,
        ShowsOrientation = 8,
        RequestsParentDirectory = 16777216
    }
}
declare namespace NSPageController {
    enum TransitionStyle {
        StackHistory = 0,
        StackBook = 1,
        HorizontalStrip = 2
    }
    type ObjectIdentifier = String;
}
declare namespace NSParagraphStyle {
    enum TextTabType {
        LeftTabStopType = 0,
        RightTabStopType = 1,
        CenterTabStopType = 2,
        DecimalTabStopType = 3
    }
    enum LineBreakStrategy {
        pushOut = 0,
        hangulWordPriority = 1,
        standard = 2
    }
}
declare namespace NSPasteboard {
    enum ContentsOptions {
        CurrentHostOnly = 1
    }
    enum ReadingOptions {
        AsData = 0,
        AsString = 1,
        AsPropertyList = 2,
        AsKeyedArchive = 4
    }
    enum WritingOptions {
        Promised = 512
    }
    let fileContents: string;
    let findPanelSearchOptions: string;
    let drag: string;
    let find: string;
    let font: string;
    let general: string;
    let ruler: string;
    let color: string;
    let fileURL: string;
    let html: string;
    let multipleTextSelection: string;
    let pdf: string;
    let png: string;
    let rtf: string;
    let rtfd: string;
    let sound: string;
    let string: string;
    let tiff: string;
    let tabularText: string;
    let textFinderOptions: string;
    let URL: string;
    let urlReadingContentsConformToTypes: string;
    let urlReadingFileURLsOnly: string;
    let soundPboardType: string;
}
declare namespace NSPathControl {
    enum Style {
        Standard = 0,
        PopUp = 2,
        NavigationBar = 1
    }
}
declare namespace NSPickerTouchBarItem {
    enum ControlRepresentation {
        Automatic = 0,
        Expanded = 1,
        Collapsed = 2
    }
    enum SelectionMode {
        SelectOne = 0,
        SelectAny = 1,
        Momentary = 2
    }
}
declare namespace NSPointerFunctions {
    enum Options {
        StrongMemory = 0,
        ZeroingWeakMemory = 1,
        OpaqueMemory = 2,
        MallocMemory = 3,
        MachVirtualMemory = 4,
        WeakMemory = 5,
        ObjectPersonality = 0,
        OpaquePersonality = 256,
        ObjectPointerPersonality = 512,
        CStringPersonality = 768,
        StructPersonality = 1024,
        IntegerPersonality = 1280,
        CopyIn = 65536
    }
}
declare namespace NSPopUpButton {
    enum ArrowPosition {
        NoArrow = 0,
        ArrowAtCenter = 1,
        ArrowAtBottom = 2
    }
    let willPopUpNotification: string;
}
declare namespace NSPopUpButtonCell {
    let willPopUpNotification: string;
}
declare namespace NSPopover {
    enum Behavior {
        ApplicationDefined = 0,
        Transient = 1,
        Semitransient = 2
    }
    let detachToWindow: string;
    let closeReasonUserInfoKey: string;
    let standard: string;
    let didCloseNotification: string;
    let didShowNotification: string;
    let willCloseNotification: string;
    let willShowNotification: string;
}
declare namespace NSPositionalSpecifier {
    enum InsertionPosition {
        PositionAfter = 0,
        PositionBefore = 1,
        PositionBeginning = 2,
        PositionEnd = 3,
        PositionReplace = 4
    }
}
declare namespace NSPrintInfo {
    enum PaperOrientation {
        Portrait = 0,
        Landscape = 1
    }
    enum PaginationMode {
        Automatic = 0,
        Fit = 1,
        Clip = 2
    }
    let automatic: NSPrintInfo.PaginationMode;
    let clip: NSPrintInfo.PaginationMode;
    let fit: NSPrintInfo.PaginationMode;
    let allPages: string;
    let bottomMargin: string;
    let cancel: string;
    let copies: string;
    let detailedErrorReporting: string;
    let faxNumber: string;
    let firstPage: string;
    let headerAndFooter: string;
    let horizontalPagination: string;
    let horizontallyCentered: string;
    let jobDisposition: string;
    let jobSavingFileNameExtensionHidden: string;
    let jobSavingURL: string;
    let lastPage: string;
    let leftMargin: string;
    let mustCollate: string;
    let orientation: string;
    let pagesAcross: string;
    let pagesDown: string;
    let paperName: string;
    let paperSize: string;
    let preview: string;
    let printer: string;
    let printerName: string;
    let reversePageOrder: string;
    let rightMargin: string;
    let save: string;
    let scalingFactor: string;
    let selectionOnly: string;
    let spool: string;
    let time: string;
    let topMargin: string;
    let verticalPagination: string;
    let verticallyCentered: string;
    type SettingKey = String;
}
declare namespace NSPrintOperation {
    enum RenderingQuality {
        Best = 0,
        Responsive = 1
    }
    enum PageOrder {
        DescendingPageOrder = -1,
        SpecialPageOrder = 0,
        AscendingPageOrder = 1,
        UnknownPageOrder = 2
    }
}
declare namespace NSPrintPanel {
    enum Options {
        ShowsCopies = 1,
        ShowsPageRange = 2,
        ShowsPaperSize = 4,
        ShowsOrientation = 8,
        ShowsScaling = 16,
        ShowsPrintSelection = 32,
        ShowsPageSetupAccessory = 256,
        ShowsPreview = 131072
    }
    let allPresets: string;
    let noPresets: string;
    let itemDescription: string;
    let itemName: string;
    let photo: string;
}
declare namespace NSPrinter {
    enum TableStatus {
        OK = 0,
        NotFound = 1,
        Error = 2
    }
}
declare namespace NSProgressIndicator {
    enum Style {
        Bar = 0,
        Spinning = 1
    }
}
declare namespace NSRegularExpression {
    enum MatchingFlags {
        Progress = 1,
        Completed = 2,
        HitEnd = 4,
        RequiredEnd = 8,
        InternalError = 16
    }
    enum MatchingOptions {
        ReportProgress = 1,
        ReportCompletion = 2,
        Anchored = 4,
        WithTransparentBounds = 8,
        WithoutAnchoringBounds = 16
    }
    enum Options {
        CaseInsensitive = 1,
        AllowCommentsAndWhitespace = 2,
        IgnoreMetacharacters = 4,
        DotMatchesLineSeparators = 8,
        AnchorsMatchLines = 16,
        UseUnixLineSeparators = 32,
        UseUnicodeWordBoundaries = 64
    }
}
declare namespace NSRelativeSpecifier {
    enum RelativePosition {
        After = 0,
        Before = 1
    }
}
declare namespace NSRuleEditor {
    enum NestingMode {
        Single = 0,
        List = 1,
        Compound = 2,
        Simple = 3
    }
    enum RowType {
        Simple = 0,
        Compound = 1
    }
    let comparisonModifier: string;
    let compoundType: string;
    let customSelector: string;
    let leftExpression: string;
    let operatorType: string;
    let options: string;
    let rightExpression: string;
    let rowsDidChangeNotification: string;
}
declare namespace NSRulerView {
    enum Orientation {
        HorizontalRuler = 0,
        VerticalRuler = 1
    }
    let centimeters: string;
    let inches: string;
    let picas: string;
    let points: string;
}
declare namespace NSScreen {
    let colorSpaceDidChangeNotification: string;
}
declare namespace NSScrollView {
    enum Elasticity {
        Automatic = 0,
        None = 1,
        Allowed = 2
    }
    enum FindBarPosition {
        AboveHorizontalRuler = 0,
        AboveContent = 1,
        BelowContent = 2
    }
    let didEndLiveMagnifyNotification: string;
    let didEndLiveScrollNotification: string;
    let didLiveScrollNotification: string;
    let willStartLiveMagnifyNotification: string;
    let willStartLiveScrollNotification: string;
}
declare namespace NSScroller {
    enum KnobStyle {
        Default = 0,
        Dark = 1,
        Light = 2
    }
    enum Part {
        NoPart = 0,
        DecrementPage = 1,
        Knob = 2,
        IncrementPage = 3,
        DecrementLine = 4,
        IncrementLine = 5,
        KnobSlot = 6
    }
    enum Style {
        Legacy = 0,
        Overlay = 1
    }
    enum UsableParts {
        NoScrollerParts = 0,
        OnlyScrollerArrows = 1,
        AllScrollerParts = 2
    }
    let preferredScrollerStyleDidChangeNotification: string;
}
declare namespace NSScrubber {
    enum Alignment {
        None = 0,
        Leading = 1,
        Trailing = 2,
        Center = 3
    }
    enum Mode {
        Fixed = 0,
        Free = 1
    }
}
declare namespace NSSearchField {
    let clearRecentsMenuItemTag: number;
    let noRecentsMenuItemTag: number;
    let recentsMenuItemTag: number;
    let recentsTitleMenuItemTag: number;
    type RecentsAutosaveName = String;
}
declare namespace NSSegmentedControl {
    enum Distribution {
        Fit = 0,
        Fill = 1,
        FillEqually = 2,
        FillProportionally = 3
    }
    enum Style {
        Automatic = 0,
        Rounded = 1,
        RoundRect = 3,
        TexturedSquare = 4,
        SmallSquare = 6,
        Separated = 8,
        TexturedRounded = 2,
        Capsule = 5
    }
    enum SwitchTracking {
        SelectOne = 0,
        SelectAny = 1,
        Momentary = 2,
        MomentaryAccelerator = 3
    }
}
declare namespace NSSet {
    type Iterator = NSFastEnumerationIterator;
}
declare namespace NSSharingService {
    enum CloudKitOptions {
        Standard = 0,
        AllowPublic = 1,
        AllowPrivate = 2,
        AllowReadOnly = 16,
        AllowReadWrite = 32
    }
    enum SharingContentScope {
        Item = 0,
        Partial = 1,
        Full = 2
    }
    let addToAperture: string;
    let addToIPhoto: string;
    let addToSafariReadingList: string;
    let cloudSharing: string;
    let composeEmail: string;
    let composeMessage: string;
    let sendViaAirDrop: string;
    let useAsDesktopPicture: string;
}
declare namespace NSSlider {
    enum SliderType {
        Linear = 0,
        Circular = 1
    }
    enum TickMarkPosition {
        Below = 0,
        Above = 1,
        Leading = 1,
        Trailing = 0
    }
}
declare namespace NSSliderAccessory {
    let default_: number;
    let wide: number;
}
declare namespace NSSound {
    type Name = String;
    type PlaybackDeviceIdentifier = String;
}
declare namespace NSSpecifierTest {
    enum TestComparisonOperation {
        EqualToComparison = 0,
        LessThanOrEqualToComparison = 1,
        LessThanComparison = 2,
        GreaterThanOrEqualToComparison = 3,
        GreaterThanComparison = 4,
        BeginsWithComparison = 5,
        EndsWithComparison = 6,
        ContainsComparison = 7
    }
}
declare namespace NSSpeechSynthesizer {
    enum Boundary {
        ImmediateBoundary = 0,
        WordBoundary = 1,
        SentenceBoundary = 2
    }
    let characterMode: string;
    let commandDelimiter: string;
    let currentVoice: string;
    let abbreviations: string;
    let entryPhonemes: string;
    let entrySpelling: string;
    let localeIdentifier: string;
    let modificationDate: string;
    let pronunciations: string;
    let errors: string;
    let inputMode: string;
    let numberMode: string;
    let outputToFileURL: string;
    let phonemeSymbols: string;
    let pitchBase: string;
    let pitchMod: string;
    let rate: string;
    let recentSync: string;
    let reset: string;
    let status: string;
    let synthesizerInfo: string;
    let volume: string;
    let age: string;
    let demoText: string;
    let gender: string;
    let female: string;
    let male: string;
    let neuter: string;
    let identifier: string;
    let individuallySpokenCharacters: string;
    let name: string;
    let supportedCharacters: string;
}
declare namespace NSSpellChecker {
    enum CorrectionIndicatorType {
        Default = 0,
        Reversion = 1,
        Guesses = 2
    }
    enum CorrectionResponse {
        None = 0,
        Accepted = 1,
        Rejected = 2,
        Ignored = 3,
        Edited = 4,
        Reverted = 5
    }
    let didChangeAutomaticCapitalizationNotification: string;
    let didChangeAutomaticDashSubstitutionNotification: string;
    let didChangeAutomaticPeriodSubstitutionNotification: string;
    let didChangeAutomaticQuoteSubstitutionNotification: string;
    let didChangeAutomaticSpellingCorrectionNotification: string;
    let didChangeAutomaticTextCompletionNotification: string;
    let didChangeAutomaticTextReplacementNotification: string;
    let documentAuthor: string;
    let documentTitle: string;
    let documentURL: string;
    let orthography: string;
    let quotes: string;
    let referenceDate: string;
    let referenceTimeZone: string;
    let regularExpressions: string;
    let replacements: string;
    let selectedRange: string;
}
declare namespace NSSplitView {
    enum DividerStyle {
        Thick = 1,
        Thin = 2,
        PaneSplitter = 3
    }
    let didResizeSubviewsNotification: string;
    let willResizeSubviewsNotification: string;
    type AutosaveName = String;
}
declare namespace NSSplitViewController {
    let automaticDimension: number;
}
declare namespace NSSplitViewItem {
    enum Behavior {
        Default = 0,
        Sidebar = 1,
        ContentList = 2
    }
    enum CollapseBehavior {
        Default = 0,
        PreferResizingSplitViewWithFixedSiblings = 1,
        PreferResizingSiblingsWithFixedSplitView = 2,
        UseConstraints = 3
    }
    let unspecifiedDimension: number;
}
declare namespace NSStackView {
    enum Distribution {
        GravityAreas = -1,
        Fill = 0,
        FillEqually = 1,
        FillProportionally = 2,
        EqualSpacing = 3,
        EqualCentering = 4
    }
    enum Gravity {
        Top = 1,
        Leading = 1,
        Center = 2,
        Bottom = 3,
        Trailing = 3
    }
    let useDefaultSpacing: number;
    let detachOnlyIfNecessary: number;
    let mustHold: number;
    let notVisible: number;
}
declare namespace NSStatusItem {
    enum Behavior {
        RemovalAllowed = 2,
        TerminationOnRemoval = 4
    }
    let squareLength: number;
    let variableLength: number;
    type AutosaveName = String;
}
declare namespace NSStoryboard {
    type Name = String;
    type SceneIdentifier = String;
}
declare namespace NSStoryboardSegue {
    type Identifier = String;
}
declare namespace NSString {
    enum DrawingOptions {
        UsesLineFragmentOrigin = 1,
        UsesFontLeading = 2,
        UsesDeviceMetrics = 8,
        TruncatesLastVisibleLine = 32,
        DisableScreenFontSubstitution = 4,
        OneShot = 16
    }
    enum CompareOptions {
        CaseInsensitiveSearch = 1,
        LiteralSearch = 2,
        BackwardsSearch = 4,
        AnchoredSearch = 8,
        NumericSearch = 64,
        DiacriticInsensitiveSearch = 128,
        WidthInsensitiveSearch = 256,
        ForcedOrderingSearch = 512,
        RegularExpressionSearch = 1024
    }
    enum EncodingConversionOptions {
        AllowLossy = 1,
        ExternalRepresentation = 2
    }
    enum EnumerationOptions {
        ByLines = 0,
        ByParagraphs = 1,
        ByComposedCharacterSequences = 2,
        ByWords = 3,
        BySentences = 4,
        Reverse = 256,
        SubstringNotRequired = 512,
        Localized = 1024
    }
    type StringLiteralType = string;
    type ExtendedGraphemeClusterLiteralType = string;
    type UnicodeScalarLiteralType = string;
}
declare namespace NSTabView {
    enum TabPosition {
        None = 0,
        Top = 1,
        Left = 2,
        Bottom = 3,
        Right = 4
    }
    enum TabViewBorderType {
        None = 0,
        Line = 1,
        Bezel = 2
    }
    enum TabType {
        TopTabsBezelBorder = 0,
        LeftTabsBezelBorder = 1,
        BottomTabsBezelBorder = 2,
        RightTabsBezelBorder = 3,
        NoTabsBezelBorder = 4,
        NoTabsLineBorder = 5,
        NoTabsNoBorder = 6
    }
}
declare namespace NSTabViewController {
    enum TabStyle {
        SegmentedControlOnTop = 0,
        SegmentedControlOnBottom = 1,
        Toolbar = 2,
        Unspecified = -1
    }
}
declare namespace NSTabViewItem {
    enum State {
        SelectedTab = 0,
        BackgroundTab = 1,
        PressedTab = 2
    }
}
declare namespace NSTableColumn {
    enum ResizingOptions {
        NoResizing = 0,
        AutoresizingMask = 1,
        UserResizingMask = 2
    }
}
declare namespace NSTableView {
    enum RowActionEdge {
        Leading = 0,
        Trailing = 1
    }
    enum AnimationOptions {
        EffectNone = 0,
        EffectFade = 1,
        EffectGap = 2,
        SlideUp = 16,
        SlideDown = 32,
        SlideLeft = 48,
        SlideRight = 64
    }
    enum ColumnAutoresizingStyle {
        NoColumnAutoresizing = 0,
        UniformColumnAutoresizingStyle = 1,
        SequentialColumnAutoresizingStyle = 2,
        ReverseSequentialColumnAutoresizingStyle = 3,
        LastColumnOnlyAutoresizingStyle = 4,
        FirstColumnOnlyAutoresizingStyle = 5
    }
    enum DraggingDestinationFeedbackStyle {
        None = -1,
        Regular = 0,
        SourceList = 1,
        Gap = 2
    }
    enum DropOperation {
        On = 0,
        Above = 1
    }
    enum GridLineStyle {
        GridNone = 0,
        SolidVerticalGridLineMask = 1,
        SolidHorizontalGridLineMask = 2,
        DashedHorizontalGridLineMask = 8
    }
    enum RowSizeStyle {
        Default = -1,
        Custom = 0,
        Small = 1,
        Medium = 2,
        Large = 3
    }
    enum SelectionHighlightStyle {
        None = -1,
        Regular = 0,
        SourceList = 1
    }
    let columnDidMoveNotification: string;
    let columnDidResizeNotification: string;
    let rowViewIdentifier: string;
    let selectionDidChangeNotification: string;
    let selectionIsChangingNotification: string;
    type AutosaveName = String;
}
declare namespace NSTableViewRowAction {
    enum Style {
        Regular = 0,
        Destructive = 1
    }
}
declare namespace NSText {
    let didBeginEditingNotification: string;
    let didChangeNotification: string;
    let didEndEditingNotification: string;
    let movementUserInfoKey: string;
}
declare namespace NSTextAlternatives {
    let selectedAlternativeStringNotification: string;
}
declare namespace NSTextBlock {
    enum Dimension {
        Width = 0,
        MinimumWidth = 1,
        MaximumWidth = 2,
        Height = 4,
        MinimumHeight = 5,
        MaximumHeight = 6
    }
    enum Layer {
        Padding = -1,
        Border = 0,
        Margin = 1
    }
    enum ValueType {
        AbsoluteValueType = 0,
        PercentageValueType = 1
    }
    enum VerticalAlignment {
        TopAlignment = 0,
        MiddleAlignment = 1,
        BottomAlignment = 2,
        BaselineAlignment = 3
    }
}
declare namespace NSTextCheckingKey {
    let airline: string;
    let city: string;
    let country: string;
    let flight: string;
    let jobTitle: string;
    let name: string;
    let organization: string;
    let phone: string;
    let state: string;
    let street: string;
    let zip: string;
}
declare namespace NSTextCheckingResult {
    enum CheckingType {
        Orthography = 1,
        Spelling = 2,
        Grammar = 4,
        Date = 8,
        Address = 16,
        Link = 32,
        Quote = 64,
        Dash = 128,
        Replacement = 256,
        Correction = 512,
        RegularExpression = 1024,
        PhoneNumber = 2048,
        TransitInformation = 4096
    }
}
declare namespace NSTextField {
    enum BezelStyle {
        SquareBezel = 0,
        RoundedBezel = 1
    }
}
declare namespace NSTextFinder {
    enum Action {
        ShowFindInterface = 1,
        NextMatch = 2,
        PreviousMatch = 3,
        ReplaceAll = 4,
        Replace = 5,
        ReplaceAndFind = 6,
        SetSearchString = 7,
        ReplaceAllInSelection = 8,
        SelectAll = 9,
        SelectAllInSelection = 10,
        HideFindInterface = 11,
        ShowReplaceInterface = 12,
        HideReplaceInterface = 13
    }
    enum MatchingType {
        Contains = 0,
        StartsWith = 1,
        FullWord = 2,
        EndsWith = 3
    }
}
declare namespace NSTextInputContext {
    let keyboardSelectionDidChangeNotification: string;
}
declare namespace NSTextList {
    enum Options {
        PrependEnclosingMarker = 1
    }
    let box: string;
    let check: string;
    let circle: string;
    let decimal: string;
    let diamond: string;
    let disc: string;
    let hyphen: string;
    let lowercaseAlpha: string;
    let lowercaseHexadecimal: string;
    let lowercaseLatin: string;
    let lowercaseRoman: string;
    let octal: string;
    let square: string;
    let uppercaseAlpha: string;
    let uppercaseHexadecimal: string;
    let uppercaseLatin: string;
    let uppercaseRoman: string;
}
declare namespace NSTextStorage {
    let didProcessEditingNotification: string;
    let willProcessEditingNotification: string;
}
declare namespace NSTextTab {
    let columnTerminators: string;
}
declare namespace NSTextTable {
    enum LayoutAlgorithm {
        AutomaticLayoutAlgorithm = 0,
        FixedLayoutAlgorithm = 1
    }
}
declare namespace NSTextView {
    let didChangeSelectionNotification: string;
    let didChangeTypingAttributesNotification: string;
    let willChangeNotifyingTextViewNotification: string;
}
declare namespace NSTimeZone {
    enum NameStyle {
        Standard = 0,
        ShortStandard = 1,
        DaylightSaving = 2,
        ShortDaylightSaving = 3,
        Generic = 4,
        ShortGeneric = 5
    }
}
declare namespace NSTokenField {
    enum TokenStyle {
        Default = 0,
        None = 1,
        Rounded = 2,
        Squared = 3,
        PlainSquared = 4
    }
}
declare namespace NSToolbar {
    enum DisplayMode {
        Default = 0,
        IconAndLabel = 1,
        IconOnly = 2,
        LabelOnly = 3
    }
    enum SizeMode {
        Default = 0,
        Regular = 1,
        Small = 2
    }
    let didRemoveItemNotification: string;
    let willAddItemNotification: string;
    type Identifier = String;
}
declare namespace NSToolbarItem {
    let cloudSharing: string;
    let customizeToolbar: string;
    let flexibleSpace: string;
    let high: number;
    let low: number;
    let standard: number;
    let user: number;
    let print: string;
    let separator: string;
    let showColors: string;
    let showFonts: string;
    let space: string;
    let toggleSidebar: string;
}
declare namespace NSToolbarItemGroup {
    enum ControlRepresentation {
        Automatic = 0,
        Expanded = 1,
        Collapsed = 2
    }
    enum SelectionMode {
        SelectOne = 0,
        SelectAny = 1,
        Momentary = 2
    }
}
declare namespace NSTouch {
    enum Phase {
        Began = 1,
        Moved = 2,
        Stationary = 4,
        Ended = 8,
        Cancelled = 16,
        Touching = 7,
        Any = -1
    }
    enum TouchType {
        Direct = 0,
        Indirect = 1
    }
    enum TouchTypeMask {
        Direct = 1,
        Indirect = 2
    }
}
declare namespace NSTouchBar {
    type CustomizationIdentifier = String;
}
declare namespace NSTouchBarItem {
    let candidateList: string;
    let characterPicker: string;
    let fixedSpaceLarge: string;
    let fixedSpaceSmall: string;
    let flexibleSpace: string;
    let otherItemsProxy: string;
    let textAlignment: string;
    let textColorPicker: string;
    let textFormat: string;
    let textList: string;
    let textStyle: string;
    let high: number;
    let low: number;
    let normal: number;
}
declare namespace NSTrackingArea {
    enum Options {
        MouseEnteredAndExited = 1,
        MouseMoved = 2,
        CursorUpdate = 4,
        ActiveWhenFirstResponder = 16,
        ActiveInKeyWindow = 32,
        ActiveInActiveApp = 64,
        ActiveAlways = 128,
        AssumeInside = 256,
        InVisibleRect = 512,
        EnabledDuringMouseDrag = 1024
    }
}
declare namespace NSURL {
    enum BookmarkCreationOptions {
        PreferFileIDResolution = 256,
        MinimalBookmark = 512,
        SuitableForBookmarkFile = 1024,
        WithSecurityScope = 2048,
        SecurityScopeAllowOnlyReadAccess = 4096
    }
    enum BookmarkResolutionOptions {
        WithoutUI = 256,
        WithoutMounting = 512,
        WithSecurityScope = 1024
    }
    type BookmarkFileCreationOptions = number;
}
declare namespace NSURLHandle {
    enum Status {
        NotLoaded = 0,
        LoadSucceeded = 1,
        LoadInProgress = 2,
        LoadFailed = 3
    }
}
declare namespace NSURLRequest {
    enum CachePolicy {
        UseProtocolCachePolicy = 0,
        ReloadIgnoringLocalCacheData = 1,
        ReloadIgnoringLocalAndRemoteCacheData = 4,
        ReloadIgnoringCacheData = 1,
        ReturnCacheDataElseLoad = 2,
        ReturnCacheDataDontLoad = 3,
        ReloadRevalidatingCacheData = 5
    }
    enum NetworkServiceType {
        NetworkServiceTypeDefault = 0,
        NetworkServiceTypeVoIP = 1,
        NetworkServiceTypeVideo = 2,
        NetworkServiceTypeBackground = 3,
        NetworkServiceTypeVoice = 4,
        NetworkServiceTypeResponsiveData = 6,
        NetworkServiceTypeAVStreaming = 8,
        NetworkServiceTypeResponsiveAV = 9,
        NetworkServiceTypeCallSignaling = 11
    }
}
declare namespace NSUbiquitousKeyValueStore {
    let didChangeExternallyNotification: string;
}
declare namespace NSUserNotification {
    enum ActivationType {
        None = 0,
        ContentsClicked = 1,
        ActionButtonClicked = 2,
        Replied = 3,
        AdditionalActionClicked = 4
    }
}
declare namespace NSValueTransformerName {
    let isNilTransformerName: string;
    let isNotNilTransformerName: string;
    let negateBooleanTransformerName: string;
    let secureUnarchiveFromDataTransformerName: string;
}
declare namespace NSView {
    enum AutoresizingMask {
        ViewNotSizable = 0,
        ViewMinXMargin = 1,
        ViewWidthSizable = 2,
        ViewMaxXMargin = 4,
        ViewMinYMargin = 8,
        ViewHeightSizable = 16,
        ViewMaxYMargin = 32
    }
    enum BackgroundStyle {
        Normal = 0,
        Emphasized = 1,
        Raised = 2,
        Lowered = 3
    }
    enum LayerContentsPlacement {
        ScaleAxesIndependently = 0,
        ScaleProportionallyToFit = 1,
        ScaleProportionallyToFill = 2,
        Center = 3,
        Top = 4,
        TopRight = 5,
        Right = 6,
        BottomRight = 7,
        Bottom = 8,
        BottomLeft = 9,
        Left = 10,
        TopLeft = 11
    }
    enum LayerContentsRedrawPolicy {
        Never = 0,
        OnSetNeedsDisplay = 1,
        DuringViewResize = 2,
        BeforeViewResize = 3,
        Crossfade = 4
    }
    let emphasized: NSView.BackgroundStyle;
    let normal: NSView.BackgroundStyle;
    let dictionaryApplication: string;
    let presentationType: string;
    let overlay: string;
    let fullScreenModeAllScreens: string;
    let fullScreenModeApplicationPresentationOptions: string;
    let fullScreenModeSetting: string;
    let fullScreenModeWindowLevel: string;
    let boundsDidChangeNotification: string;
    let didUpdateTrackingAreasNotification: string;
    let frameDidChangeNotification: string;
    let noIntrinsicMetric: number;
    type TrackingRectTag = number;
    type ToolTipTag = number;
}
declare namespace NSViewAnimation {
    let effect: string;
    let endFrame: string;
    let fadeIn: string;
    let fadeOut: string;
    let startFrame: string;
    let target: string;
}
declare namespace NSViewController {
    enum TransitionOptions {
        None = 0,
        Crossfade = 1,
        SlideUp = 16,
        SlideDown = 32,
        SlideLeft = 64,
        SlideRight = 128,
        SlideForward = 320,
        SlideBackward = 384,
        AllowUserInteraction = 4096
    }
}
declare namespace NSVisualEffectView {
    enum BlendingMode {
        BehindWindow = 0,
        WithinWindow = 1
    }
    enum Material {
        Titlebar = 3,
        Selection = 4,
        Menu = 5,
        Popover = 6,
        Sidebar = 7,
        HeaderView = 10,
        Sheet = 11,
        WindowBackground = 12,
        HUDWindow = 13,
        FullScreenUI = 15,
        ToolTip = 17,
        ContentBackground = 18,
        UnderWindowBackground = 21,
        UnderPageBackground = 22,
        AppearanceBased = 0,
        Light = 1,
        Dark = 2,
        MediumLight = 8,
        UltraDark = 9
    }
    enum State {
        FollowsWindowActiveState = 0,
        Active = 1,
        Inactive = 2
    }
}
declare namespace NSWhoseSpecifier {
    enum SubelementIdentifier {
        IndexSubelement = 0,
        EverySubelement = 1,
        MiddleSubelement = 2,
        RandomSubelement = 3,
        NoSubelement = 4
    }
}
declare namespace NSWindow {
    enum BackingStoreType {
        Retained = 0,
        Nonretained = 1,
        Buffered = 2
    }
    enum SelectionDirection {
        DirectSelection = 0,
        SelectingNext = 1,
        SelectingPrevious = 2
    }
    enum AnimationBehavior {
        Default = 0,
        None = 2,
        DocumentWindow = 3,
        UtilityWindow = 4,
        AlertPanel = 5
    }
    enum ButtonType {
        CloseButton = 0,
        MiniaturizeButton = 1,
        ZoomButton = 2,
        ToolbarButton = 3,
        DocumentIconButton = 4,
        DocumentVersionsButton = 6
    }
    enum CollectionBehavior {
        Default = 0,
        CanJoinAllSpaces = 1,
        MoveToActiveSpace = 2,
        Managed = 4,
        Transient = 8,
        Stationary = 16,
        ParticipatesInCycle = 32,
        IgnoresCycle = 64,
        FullScreenPrimary = 128,
        FullScreenAuxiliary = 256,
        FullScreenNone = 512,
        FullScreenAllowsTiling = 2048,
        FullScreenDisallowsTiling = 4096
    }
    enum Depth {
        TwentyfourBitRGB = 520,
        SixtyfourBitRGB = 528,
        OnehundredtwentyeightBitRGB = 544
    }
    enum NumberListOptions {
        AllApplications = 1,
        AllSpaces = 16
    }
    enum OcclusionState {
        Visible = 2
    }
    enum OrderingMode {
        Above = 1,
        Below = -1,
        Out = 0
    }
    enum SharingType {
        None = 0,
        ReadOnly = 1,
        ReadWrite = 2
    }
    enum StyleMask {
        Borderless = 0,
        Titled = 1,
        Closable = 2,
        Miniaturizable = 4,
        Resizable = 8,
        TexturedBackground = 256,
        UnifiedTitleAndToolbar = 4096,
        FullScreen = 16384,
        FullSizeContentView = 32768,
        UtilityWindow = 16,
        DocModalWindow = 64,
        NonactivatingPanel = 128,
        HUDWindow = 8192
    }
    enum TabbingMode {
        Automatic = 0,
        Preferred = 1,
        Disallowed = 2
    }
    enum TitleVisibility {
        Visible = 0,
        Hidden = 1
    }
    enum UserTabbingPreference {
        Manual = 0,
        Always = 1,
        InFullScreen = 2
    }
    let oldColorSpaceUserInfoKey: string;
    let oldScaleFactorUserInfoKey: string;
    let floating: number;
    let mainMenu: number;
    let modalPanel: number;
    let normal: number;
    let popUpMenu: number;
    let screenSaver: number;
    let statusBar: number;
    let submenu: number;
    let tornOffMenu: number;
    let didBecomeKeyNotification: string;
    let didBecomeMainNotification: string;
    let didChangeBackingPropertiesNotification: string;
    let didChangeOcclusionStateNotification: string;
    let didChangeScreenNotification: string;
    let didChangeScreenProfileNotification: string;
    let didDeminiaturizeNotification: string;
    let didEndLiveResizeNotification: string;
    let didEndSheetNotification: string;
    let didEnterFullScreenNotification: string;
    let didEnterVersionBrowserNotification: string;
    let didExitFullScreenNotification: string;
    let didExitVersionBrowserNotification: string;
    let didExposeNotification: string;
    let didMiniaturizeNotification: string;
    let didMoveNotification: string;
    let didResignKeyNotification: string;
    let didResignMainNotification: string;
    let didResizeNotification: string;
    let didUpdateNotification: string;
    let willBeginSheetNotification: string;
    let willCloseNotification: string;
    let willEnterFullScreenNotification: string;
    let willEnterVersionBrowserNotification: string;
    let willExitFullScreenNotification: string;
    let willExitVersionBrowserNotification: string;
    let willMiniaturizeNotification: string;
    let willMoveNotification: string;
    let willStartLiveResizeNotification: string;
    type FrameAutosaveName = String;
    type PersistableFrameDescriptor = String;
    type TabbingIdentifier = String;
}
declare namespace NSWorkspace {
    enum AuthorizationType {
        CreateSymbolicLink = 0,
        SetAttributes = 1,
        ReplaceFile = 2
    }
    enum IconCreationOptions {
        ExcludeQuickDrawElementsIconCreationOption = 2,
        Exclude10_4ElementsIconCreationOption = 4
    }
    enum LaunchOptions {
        AndPrint = 2,
        WithErrorPresentation = 64,
        InhibitingBackgroundOnly = 128,
        WithoutAddingToRecents = 256,
        WithoutActivation = 512,
        Async = 65536,
        NewInstance = 524288,
        AndHide = 1048576,
        AndHideOthers = 2097152,
        Default = 65536,
        AllowingClassicStartup = 131072,
        PreferringClassic = 262144
    }
    let accessibilityDisplayOptionsDidChangeNotification: string;
    let activeSpaceDidChangeNotification: string;
    let applicationUserInfoKey: string;
    let allowClipping: string;
    let fillColor: string;
    let imageScaling: string;
    let didActivateApplicationNotification: string;
    let didChangeFileLabelsNotification: string;
    let didDeactivateApplicationNotification: string;
    let didHideApplicationNotification: string;
    let didLaunchApplicationNotification: string;
    let didMountNotification: string;
    let didRenameVolumeNotification: string;
    let didTerminateApplicationNotification: string;
    let didUnhideApplicationNotification: string;
    let didUnmountNotification: string;
    let didWakeNotification: string;
    let appleEvent: string;
    let architecture: string;
    let arguments_: string;
    let environment: string;
    let screensDidSleepNotification: string;
    let screensDidWakeNotification: string;
    let sessionDidBecomeActiveNotification: string;
    let sessionDidResignActiveNotification: string;
    let localizedVolumeNameUserInfoKey: string;
    let oldLocalizedVolumeNameUserInfoKey: string;
    let oldVolumeURLUserInfoKey: string;
    let volumeURLUserInfoKey: string;
    let willLaunchApplicationNotification: string;
    let willPowerOffNotification: string;
    let willSleepNotification: string;
    let willUnmountNotification: string;
}
declare namespace NSXPCConnection {
    enum Options {
        Privileged = 4096
    }
}
declare namespace NetService {
    enum Options {
        noAutoRename = 0,
        listenForConnections = 1,
        center = 2,
        name = 3,
        object = 4
    }
}
declare namespace NotificationQueue {
    enum NotificationCoalescing {
        NoCoalescing = 0,
        CoalescingOnName = 1,
        CoalescingOnSender = 2
    }
    enum PostingStyle {
        WhenIdle = 1,
        ASAP = 2,
        Now = 3
    }
}
declare namespace NumberFormatter {
    enum Behavior {
        BehaviorDefault = 0,
        Behavior10_0 = 1000,
        Behavior10_4 = 1040
    }
    enum PadPosition {
        BeforePrefix = 0,
        AfterPrefix = 1,
        BeforeSuffix = 2,
        AfterSuffix = 3
    }
    enum RoundingMode {
        Ceiling = 0,
        Floor = 1,
        Down = 2,
        Up = 3,
        HalfEven = 4,
        HalfDown = 5,
        HalfUp = 6
    }
    enum Style {
        NoStyle = 0,
        DecimalStyle = 1,
        CurrencyStyle = 2,
        PercentStyle = 3,
        ScientificStyle = 4,
        SpellOutStyle = 5,
        OrdinalStyle = 6,
        CurrencyISOCodeStyle = 8,
        CurrencyPluralStyle = 9,
        CurrencyAccountingStyle = 10
    }
}
declare namespace Operation {
    enum QueuePriority {
        VeryLow = -8,
        Low = -4,
        Normal = 0,
        High = 4,
        VeryHigh = 8
    }
}
declare namespace OperationQueue {
    let defaultMaxConcurrentOperationCount: number;
}
declare namespace PersonNameComponentsFormatter {
    enum Options {
        Phonetic = 2
    }
    enum Style {
        Default = 0,
        Short = 1,
        Medium = 2,
        Long = 3,
        Abbreviated = 4
    }
}
declare namespace Port {
    let didBecomeInvalidNotification: string;
}
declare namespace Process {
    enum TerminationReason {
        Exit = 1,
        UncaughtSignal = 2
    }
    let didTerminateNotification: string;
}
declare namespace ProcessInfo {
    enum ActivityOptions {
        IdleDisplaySleepDisabled = 1099511627776,
        IdleSystemSleepDisabled = 1048576,
        SuddenTerminationDisabled = 16384,
        AutomaticTerminationDisabled = 32768,
        UserInitiated = 16777215,
        UserInitiatedAllowingIdleSystemSleep = 15728639,
        Background = 255,
        LatencyCritical = 1095216660480
    }
    enum ThermalState {
        Nominal = 0,
        Fair = 1,
        Serious = 2,
        Critical = 3
    }
    let thermalStateDidChangeNotification: string;
}
declare namespace Progress {
    let copying: string;
    let decompressingAfterDownloading: string;
    let downloading: string;
    let receiving: string;
}
declare namespace ProgressKind {
    let file: string;
}
declare namespace ProgressUserInfoKey {
    let estimatedTimeRemainingKey: string;
    let fileAnimationImageKey: string;
    let fileAnimationImageOriginalRectKey: string;
    let fileCompletedCountKey: string;
    let fileIconKey: string;
    let fileOperationKindKey: string;
    let fileTotalCountKey: string;
    let fileURLKey: string;
    let throughputKey: string;
}
declare namespace PropertyListSerialization {
    enum PropertyListFormat {
        OpenStepFormat = 1,
        XMLFormat_v1_0 = 100,
        BinaryFormat_v1_0 = 200
    }
    enum MutabilityOptions {
        Immutable = 0,
        MutableContainers = 1,
        MutableContainersAndLeaves = 2
    }
    type ReadOptions = PropertyListSerialization;
    type WriteOptions = number;
}
declare namespace RelativeDateTimeFormatter {
    enum DateTimeStyle {
        Numeric = 0,
        Named = 1
    }
    enum UnitsStyle {
        Full = 0,
        SpellOut = 1,
        Short = 2,
        Abbreviated = 3
    }
}
declare namespace RunLoop {
    let eventTracking: string;
    let modalPanel: string;
    let default_: string;
    let common: string;
}
declare namespace Stream {
    enum Event {
        None = 0,
        OpenCompleted = 1,
        HasBytesAvailable = 2,
        HasSpaceAvailable = 4,
        ErrorOccurred = 8,
        EndEncountered = 16
    }
    enum Status {
        NotOpen = 0,
        Opening = 1,
        Open = 2,
        Reading = 3,
        Writing = 4,
        AtEnd = 5,
        Closed = 6,
        Error = 7
    }
    let dataWrittenToMemoryStreamKey: string;
    let fileCurrentOffsetKey: string;
    let networkServiceType: string;
    let socksProxyConfigurationKey: string;
    let socketSecurityLevelKey: string;
}
declare namespace StreamNetworkServiceTypeValue {
    let background: string;
    let callSignaling: string;
    let video: string;
    let voIP: string;
    let voice: string;
}
declare namespace StreamSOCKSProxyConfiguration {
    let hostKey: string;
    let passwordKey: string;
    let portKey: string;
    let userKey: string;
    let versionKey: string;
}
declare namespace StreamSOCKSProxyVersion {
    let version4: string;
    let version5: string;
}
declare namespace StreamSocketSecurityLevel {
    let negotiatedSSL: string;
    let none: string;
    let ssLv2: string;
    let ssLv3: string;
    let tlSv1: string;
}
declare namespace StringEncodingDetectionOptionsKey {
    let allowLossyKey: string;
    let disallowedEncodingsKey: string;
    let fromWindowsKey: string;
    let likelyLanguageKey: string;
    let lossySubstitutionKey: string;
    let suggestedEncodingsKey: string;
    let useOnlySuggestedEncodingsKey: string;
}
declare namespace StringTransform {
    let fullwidthToHalfwidth: string;
    let hiraganaToKatakana: string;
    let latinToArabic: string;
    let latinToCyrillic: string;
    let latinToGreek: string;
    let latinToHangul: string;
    let latinToHebrew: string;
    let latinToHiragana: string;
    let latinToKatakana: string;
    let latinToThai: string;
    let mandarinToLatin: string;
    let stripCombiningMarks: string;
    let stripDiacritics: string;
    let toLatin: string;
    let toUnicodeName: string;
    let toXMLHex: string;
}
declare namespace SystemPressureState {
    enum Factors {
        systemTemperature = 0,
        peakPower = 1,
        depthModuleTemperature = 2
    }
}
declare namespace URLCache {
    enum StoragePolicy {
        Allowed = 0,
        AllowedInMemoryOnly = 1,
        NotAllowed = 2
    }
}
declare namespace URLCredential {
    enum Persistence {
        None = 0,
        ForSession = 1,
        Permanent = 2,
        Synchronizable = 3
    }
}
declare namespace URLFileProtection {
    let complete: string;
    let completeUnlessOpen: string;
    let completeUntilFirstUserAuthentication: string;
    let none: string;
}
declare namespace URLFileResourceType {
    let blockSpecial: string;
    let characterSpecial: string;
    let directory: string;
    let namedPipe: string;
    let regular: string;
    let socket: string;
    let symbolicLink: string;
    let unknown: string;
}
declare namespace URLResourceKey {
    let addedToDirectoryDateKey: string;
    let applicationIsScriptableKey: string;
    let attributeModificationDateKey: string;
    let canonicalPathKey: string;
    let contentAccessDateKey: string;
    let contentModificationDateKey: string;
    let creationDateKey: string;
    let customIconKey: string;
    let documentIdentifierKey: string;
    let effectiveIconKey: string;
    let fileAllocatedSizeKey: string;
    let fileProtectionKey: string;
    let fileResourceIdentifierKey: string;
    let fileResourceTypeKey: string;
    let fileSecurityKey: string;
    let fileSizeKey: string;
    let generationIdentifierKey: string;
    let hasHiddenExtensionKey: string;
    let isAliasFileKey: string;
    let isApplicationKey: string;
    let isDirectoryKey: string;
    let isExcludedFromBackupKey: string;
    let isExecutableKey: string;
    let isHiddenKey: string;
    let isMountTriggerKey: string;
    let isPackageKey: string;
    let isReadableKey: string;
    let isRegularFileKey: string;
    let isSymbolicLinkKey: string;
    let isSystemImmutableKey: string;
    let isUbiquitousItemKey: string;
    let isUserImmutableKey: string;
    let isVolumeKey: string;
    let isWritableKey: string;
    let keysOfUnsetValuesKey: string;
    let labelColorKey: string;
    let labelNumberKey: string;
    let linkCountKey: string;
    let localizedLabelKey: string;
    let localizedNameKey: string;
    let localizedTypeDescriptionKey: string;
    let nameKey: string;
    let parentDirectoryURLKey: string;
    let pathKey: string;
    let preferredIOBlockSizeKey: string;
    let quarantinePropertiesKey: string;
    let tagNamesKey: string;
    let thumbnailDictionaryKey: string;
    let thumbnailKey: string;
    let totalFileAllocatedSizeKey: string;
    let totalFileSizeKey: string;
    let typeIdentifierKey: string;
    let ubiquitousItemContainerDisplayNameKey: string;
    let ubiquitousItemDownloadRequestedKey: string;
    let ubiquitousItemDownloadingErrorKey: string;
    let ubiquitousItemDownloadingStatusKey: string;
    let ubiquitousItemHasUnresolvedConflictsKey: string;
    let ubiquitousItemIsDownloadingKey: string;
    let ubiquitousItemIsSharedKey: string;
    let ubiquitousItemIsUploadedKey: string;
    let ubiquitousItemIsUploadingKey: string;
    let ubiquitousItemUploadingErrorKey: string;
    let ubiquitousSharedItemCurrentUserPermissionsKey: string;
    let ubiquitousSharedItemCurrentUserRoleKey: string;
    let ubiquitousSharedItemMostRecentEditorNameComponentsKey: string;
    let ubiquitousSharedItemOwnerNameComponentsKey: string;
    let volumeAvailableCapacityForImportantUsageKey: string;
    let volumeAvailableCapacityForOpportunisticUsageKey: string;
    let volumeAvailableCapacityKey: string;
    let volumeCreationDateKey: string;
    let volumeIdentifierKey: string;
    let volumeIsAutomountedKey: string;
    let volumeIsBrowsableKey: string;
    let volumeIsEjectableKey: string;
    let volumeIsEncryptedKey: string;
    let volumeIsInternalKey: string;
    let volumeIsJournalingKey: string;
    let volumeIsLocalKey: string;
    let volumeIsReadOnlyKey: string;
    let volumeIsRemovableKey: string;
    let volumeIsRootFileSystemKey: string;
    let volumeLocalizedFormatDescriptionKey: string;
    let volumeLocalizedNameKey: string;
    let volumeMaximumFileSizeKey: string;
    let volumeNameKey: string;
    let volumeResourceCountKey: string;
    let volumeSupportsAccessPermissionsKey: string;
    let volumeSupportsAdvisoryFileLockingKey: string;
    let volumeSupportsCasePreservedNamesKey: string;
    let volumeSupportsCaseSensitiveNamesKey: string;
    let volumeSupportsCompressionKey: string;
    let volumeSupportsExclusiveRenamingKey: string;
    let volumeSupportsExtendedSecurityKey: string;
    let volumeSupportsFileCloningKey: string;
    let volumeSupportsHardLinksKey: string;
    let volumeSupportsImmutableFilesKey: string;
    let volumeSupportsJournalingKey: string;
    let volumeSupportsPersistentIDsKey: string;
    let volumeSupportsRenamingKey: string;
    let volumeSupportsRootDirectoryDatesKey: string;
    let volumeSupportsSparseFilesKey: string;
    let volumeSupportsSwapRenamingKey: string;
    let volumeSupportsSymbolicLinksKey: string;
    let volumeSupportsVolumeSizesKey: string;
    let volumeSupportsZeroRunsKey: string;
    let volumeTotalCapacityKey: string;
    let volumeURLForRemountingKey: string;
    let volumeURLKey: string;
    let volumeUUIDStringKey: string;
}
declare namespace URLSession {
    enum AuthChallengeDisposition {
        UseCredential = 0,
        PerformDefaultHandling = 1,
        CancelAuthenticationChallenge = 2,
        RejectProtectionSpace = 3
    }
    enum ResponseDisposition {
        Cancel = 0,
        Allow = 1,
        BecomeDownload = 2,
        BecomeStream = 3
    }
}
declare namespace URLSessionTask {
    enum State {
        Running = 0,
        Suspended = 1,
        Canceling = 2,
        Completed = 3
    }
    let defaultPriority: number;
    let highPriority: number;
    let lowPriority: number;
}
declare namespace URLSessionTaskMetrics {
    enum ResourceFetchType {
        Unknown = 0,
        NetworkLoad = 1,
        ServerPush = 2,
        LocalCache = 3
    }
}
declare namespace URLSessionWebSocketTask {
    enum CloseCode {
        Invalid = 0,
        NormalClosure = 1000,
        GoingAway = 1001,
        ProtocolError = 1002,
        UnsupportedData = 1003,
        NoStatusReceived = 1005,
        AbnormalClosure = 1006,
        InvalidFramePayloadData = 1007,
        PolicyViolation = 1008,
        MessageTooBig = 1009,
        MandatoryExtensionMissing = 1010,
        InternalServerError = 1011,
        TLSHandshakeFailure = 1015
    }
}
declare namespace URLThumbnailDictionaryItem {
    let NSThumbnail1024x1024SizeKey: string;
}
declare namespace URLUbiquitousItemDownloadingStatus {
    let current: string;
    let downloaded: string;
    let notDownloaded: string;
}
declare namespace URLUbiquitousSharedItemPermissions {
    let readOnly: string;
    let readWrite: string;
}
declare namespace URLUbiquitousSharedItemRole {
    let owner: string;
    let participant: string;
}
declare namespace UserDefaults {
    let argumentDomain: string;
    let globalDomain: string;
    let registrationDomain: string;
    let completedInitialCloudSyncNotification: string;
    let didChangeCloudAccountsNotification: string;
    let noCloudAccountNotification: string;
    let didChangeNotification: string;
    let sizeLimitExceededNotification: string;
}
declare namespace XMLDTDNode {
    enum DTDKind {
        EntityGeneralKind = 1,
        EntityParsedKind = 2,
        EntityUnparsedKind = 3,
        EntityParameterKind = 4,
        EntityPredefined = 5,
        AttributeCDATAKind = 6,
        AttributeIDKind = 7,
        AttributeIDRefKind = 8,
        AttributeIDRefsKind = 9,
        AttributeEntityKind = 10,
        AttributeEntitiesKind = 11,
        AttributeNMTokenKind = 12,
        AttributeNMTokensKind = 13,
        AttributeEnumerationKind = 14,
        AttributeNotationKind = 15,
        ElementDeclarationUndefinedKind = 16,
        ElementDeclarationEmptyKind = 17,
        ElementDeclarationAnyKind = 18,
        ElementDeclarationMixedKind = 19,
        ElementDeclarationElementKind = 20
    }
}
declare namespace XMLDocument {
    enum ContentKind {
        XMLKind = 0,
        XHTMLKind = 1,
        HTMLKind = 2,
        TextKind = 3
    }
}
declare namespace XMLNode {
    enum Kind {
        InvalidKind = 0,
        DocumentKind = 1,
        ElementKind = 2,
        AttributeKind = 3,
        NamespaceKind = 4,
        ProcessingInstructionKind = 5,
        CommentKind = 6,
        TextKind = 7,
        DTDKind = 8,
        EntityDeclarationKind = 9,
        AttributeDeclarationKind = 10,
        ElementDeclarationKind = 11,
        NotationDeclarationKind = 12
    }
    enum Options {
        NodeOptionsNone = 0,
        NodeIsCDATA = 1,
        NodeExpandEmptyElement = 2,
        NodeCompactEmptyElement = 4,
        NodeUseSingleQuotes = 8,
        NodeUseDoubleQuotes = 16,
        NodeNeverEscapeContents = 32,
        DocumentTidyHTML = 512,
        DocumentTidyXML = 1024,
        DocumentValidate = 8192,
        NodeLoadExternalEntitiesAlways = 16384,
        NodeLoadExternalEntitiesSameOriginOnly = 32768,
        NodeLoadExternalEntitiesNever = 524288,
        DocumentXInclude = 65536,
        NodePrettyPrint = 131072,
        DocumentIncludeContentTypeDeclaration = 262144,
        NodePreserveNamespaceOrder = 1048576,
        NodePreserveAttributeOrder = 2097152,
        NodePreserveEntities = 4194304,
        NodePreservePrefixes = 8388608,
        NodePreserveCDATA = 16777216,
        NodePreserveWhitespace = 33554432,
        NodePreserveDTD = 67108864,
        NodePreserveCharacterReferences = 134217728,
        NodePromoteSignificantWhitespace = 268435456,
        NodePreserveEmptyElements = 6,
        NodePreserveQuotes = 24,
        NodePreserveAll = 4293918750
    }
}
declare namespace XMLParser {
    enum ErrorCode {
        InternalError = 1,
        OutOfMemoryError = 2,
        DocumentStartError = 3,
        EmptyDocumentError = 4,
        PrematureDocumentEndError = 5,
        InvalidHexCharacterRefError = 6,
        InvalidDecimalCharacterRefError = 7,
        InvalidCharacterRefError = 8,
        InvalidCharacterError = 9,
        CharacterRefAtEOFError = 10,
        CharacterRefInPrologError = 11,
        CharacterRefInEpilogError = 12,
        CharacterRefInDTDError = 13,
        EntityRefAtEOFError = 14,
        EntityRefInPrologError = 15,
        EntityRefInEpilogError = 16,
        EntityRefInDTDError = 17,
        ParsedEntityRefAtEOFError = 18,
        ParsedEntityRefInPrologError = 19,
        ParsedEntityRefInEpilogError = 20,
        ParsedEntityRefInInternalSubsetError = 21,
        EntityReferenceWithoutNameError = 22,
        EntityReferenceMissingSemiError = 23,
        ParsedEntityRefNoNameError = 24,
        ParsedEntityRefMissingSemiError = 25,
        UndeclaredEntityError = 26,
        UnparsedEntityError = 28,
        EntityIsExternalError = 29,
        EntityIsParameterError = 30,
        UnknownEncodingError = 31,
        EncodingNotSupportedError = 32,
        StringNotStartedError = 33,
        StringNotClosedError = 34,
        NamespaceDeclarationError = 35,
        EntityNotStartedError = 36,
        EntityNotFinishedError = 37,
        LessThanSymbolInAttributeError = 38,
        AttributeNotStartedError = 39,
        AttributeNotFinishedError = 40,
        AttributeHasNoValueError = 41,
        AttributeRedefinedError = 42,
        LiteralNotStartedError = 43,
        LiteralNotFinishedError = 44,
        CommentNotFinishedError = 45,
        ProcessingInstructionNotStartedError = 46,
        ProcessingInstructionNotFinishedError = 47,
        NotationNotStartedError = 48,
        NotationNotFinishedError = 49,
        AttributeListNotStartedError = 50,
        AttributeListNotFinishedError = 51,
        MixedContentDeclNotStartedError = 52,
        MixedContentDeclNotFinishedError = 53,
        ElementContentDeclNotStartedError = 54,
        ElementContentDeclNotFinishedError = 55,
        XMLDeclNotStartedError = 56,
        XMLDeclNotFinishedError = 57,
        ConditionalSectionNotStartedError = 58,
        ConditionalSectionNotFinishedError = 59,
        ExternalSubsetNotFinishedError = 60,
        DOCTYPEDeclNotFinishedError = 61,
        MisplacedCDATAEndStringError = 62,
        CDATANotFinishedError = 63,
        MisplacedXMLDeclarationError = 64,
        SpaceRequiredError = 65,
        SeparatorRequiredError = 66,
        NMTOKENRequiredError = 67,
        NAMERequiredError = 68,
        PCDATARequiredError = 69,
        URIRequiredError = 70,
        PublicIdentifierRequiredError = 71,
        LTRequiredError = 72,
        GTRequiredError = 73,
        LTSlashRequiredError = 74,
        EqualExpectedError = 75,
        TagNameMismatchError = 76,
        UnfinishedTagError = 77,
        StandaloneValueError = 78,
        InvalidEncodingNameError = 79,
        CommentContainsDoubleHyphenError = 80,
        InvalidEncodingError = 81,
        ExternalStandaloneEntityError = 82,
        InvalidConditionalSectionError = 83,
        EntityValueRequiredError = 84,
        NotWellBalancedError = 85,
        ExtraContentError = 86,
        InvalidCharacterInEntityError = 87,
        ParsedEntityRefInInternalError = 88,
        EntityRefLoopError = 89,
        EntityBoundaryError = 90,
        InvalidURIError = 91,
        URIFragmentError = 92,
        NoDTDError = 94,
        DelegateAbortedParseError = 512
    }
    enum ExternalEntityResolvingPolicy {
        ResolveExternalEntitiesNever = 0,
        ResolveExternalEntitiesNoNetwork = 1,
        ResolveExternalEntitiesSameOriginOnly = 2,
        ResolveExternalEntitiesAlways = 3
    }
    let errorDomain: string;
}
export declare enum AVAssetReferenceRestrictions {
    forbidRemoteReferenceToLocal = 0,
    forbidLocalReferenceToRemote = 1,
    forbidCrossSiteReference = 2,
    forbidLocalReferenceToLocal = 3,
    forbidAll = 4,
    defaultPolicy = 5
}
export declare enum AVAudioPlayerNodeBufferOptions {
    byteSwapped = 0,
    scalarCount = 1,
    loops = 2,
    interrupts = 3,
    interruptsAtLoop = 4
}
export declare enum AVAudioSpatializationFormats {
    monoAndStereo = 0,
    multichannel = 1,
    monoStereoAndMultichannel = 2
}
export declare enum AVMovieWritingOptions {
    errorDomain = 0,
    unknown = 1,
    outOfMemory = 2,
    sessionNotRunning = 3,
    deviceAlreadyUsedByAnotherSession = 4,
    noDataCaptured = 5,
    sessionConfigurationChanged = 6,
    diskFull = 7,
    deviceWasDisconnected = 8,
    mediaChanged = 9,
    maximumDurationReached = 10,
    maximumFileSizeReached = 11,
    mediaDiscontinuity = 12,
    maximumNumberOfSamplesForFileFormatReached = 13,
    deviceNotConnected = 14,
    deviceInUseByAnotherApplication = 15,
    deviceLockedForConfigurationByAnotherProcess = 16,
    exportFailed = 17,
    decodeFailed = 18,
    invalidSourceMedia = 19,
    fileAlreadyExists = 20,
    compositionTrackSegmentsNotContiguous = 21,
    invalidCompositionTrackSegmentDuration = 22,
    invalidCompositionTrackSegmentSourceStartTime = 23,
    invalidCompositionTrackSegmentSourceDuration = 24,
    fileFormatNotRecognized = 25,
    fileFailedToParse = 26,
    maximumStillImageCaptureRequestsExceeded = 27,
    contentIsProtected = 28,
    noImageAtTime = 29,
    decoderNotFound = 30,
    encoderNotFound = 31,
    contentIsNotAuthorized = 32,
    applicationIsNotAuthorized = 33,
    operationNotSupportedForAsset = 34,
    decoderTemporarilyUnavailable = 35,
    encoderTemporarilyUnavailable = 36,
    invalidVideoComposition = 37,
    referenceForbiddenByReferencePolicy = 38,
    invalidOutputURLPathExtension = 39,
    screenCaptureFailed = 40,
    displayWasDisabled = 41,
    torchLevelUnavailable = 42,
    incompatibleAsset = 43,
    failedToLoadMediaData = 44,
    serverIncorrectlyConfigured = 45,
    applicationIsNotAuthorizedToUseDevice = 46,
    failedToParse = 47,
    fileTypeDoesNotSupportSampleReferences = 48,
    undecodableMediaData = 49,
    airPlayControllerRequiresInternet = 50,
    airPlayReceiverRequiresInternet = 51,
    videoCompositorFailed = 52,
    createContentKeyRequestFailed = 53,
    unsupportedOutputSettings = 54,
    operationNotAllowed = 55,
    contentIsUnavailable = 56,
    formatUnsupported = 57,
    malformedDepth = 58,
    contentNotUpdated = 59,
    noLongerPlayable = 60,
    noCompatibleAlternatesForExternalDisplay = 61,
    noSourceTrack = 62,
    externalPlaybackNotSupportedForAsset = 63,
    operationNotSupportedForPreset = 64,
    incorrectlyConfigured = 65,
    segmentStartedWithNonSyncSample = 66,
    rosettaNotInstalled = 67,
    addMovieHeaderToDestination = 68,
    truncateDestinationToMovieHeaderOnly = 69
}
export declare enum AVMusicSequenceLoadOptions {
    smfChannelsToTracks = 0,
    scalarCount = 1
}
export declare enum AlignmentOptions {
    alignMinXInward = 0,
    alignMinYInward = 1,
    alignMaxXInward = 2,
    alignMaxYInward = 3,
    alignWidthInward = 4,
    alignHeightInward = 5,
    alignMinXOutward = 6,
    alignMinYOutward = 7,
    alignMaxXOutward = 8,
    alignMaxYOutward = 9,
    alignWidthOutward = 10,
    alignHeightOutward = 11,
    alignMinXNearest = 12,
    alignMinYNearest = 13,
    alignMaxXNearest = 14,
    alignMaxYNearest = 15,
    alignWidthNearest = 16,
    alignHeightNearest = 17,
    alignRectFlipped = 18,
    alignAllEdgesInward = 19,
    alignAllEdgesOutward = 20,
    alignAllEdgesNearest = 21
}
export declare enum AnyObject {
    byteSwapped = 0,
    scalarCount = 1,
    assureMemoryNow = 2,
    alwaysCopyData = 3,
    dontOptimizeDepth = 4,
    permitEmptyReference = 5
}
export declare enum CAAutoresizingMask {
    layerMinXMargin = 0,
    layerWidthSizable = 1,
    layerMaxXMargin = 2,
    layerMinYMargin = 3,
    layerHeightSizable = 4,
    layerMaxYMargin = 5
}
export declare enum CACornerMask {
    layerMinXMinYCorner = 0,
    layerMaxXMinYCorner = 1,
    layerMinXMaxYCorner = 2,
    layerMaxXMaxYCorner = 3
}
export declare enum CAEdgeAntialiasingMask {
    layerLeftEdge = 0,
    layerRightEdge = 1,
    layerBottomEdge = 2,
    layerTopEdge = 3
}
export declare enum CFCalendarUnit {
    magnitude = 0,
    byteSwapped = 1,
    scalarCount = 2,
    era = 3,
    year = 4,
    month = 5,
    day = 6,
    hour = 7,
    minute = 8,
    second = 9,
    week = 10,
    weekday = 11,
    weekdayOrdinal = 12,
    quarter = 13,
    weekOfMonth = 14,
    weekOfYear = 15,
    yearForWeekOfYear = 16
}
export declare enum CFDataSearchFlags {
    backwards = 0,
    anchored = 1
}
export declare enum CFFileSecurityClearOptions {
    magnitude = 0,
    byteSwapped = 1,
    scalarCount = 2,
    owner = 3,
    group = 4,
    mode = 5,
    ownerUUID = 6,
    groupUUID = 7,
    accessControlList = 8
}
export declare enum CFGregorianUnitFlags {
    unitsYears = 0,
    unitsMonths = 1,
    unitsDays = 2,
    unitsHours = 3,
    unitsMinutes = 4,
    unitsSeconds = 5,
    allUnits = 6
}
export declare enum CFISO8601DateFormatOptions {
    byteSwapped = 0,
    scalarCount = 1,
    withYear = 2,
    withMonth = 3,
    withWeekOfYear = 4,
    withDay = 5,
    withTime = 6,
    withTimeZone = 7,
    withSpaceBetweenDateAndTime = 8,
    withDashSeparatorInDate = 9,
    withColonSeparatorInTime = 10,
    withColonSeparatorInTimeZone = 11,
    withFractionalSeconds = 12,
    withFullDate = 13,
    withFullTime = 14,
    withInternetDateTime = 15
}
export declare enum CFNumberFormatterOptionFlags {
    magnitude = 0,
    byteSwapped = 1,
    scalarCount = 2,
    parseIntegersOnly = 3
}
export declare enum CFPropertyListMutabilityOptions {
    byteSwapped = 0,
    scalarCount = 1,
    mutableContainers = 2,
    mutableContainersAndLeaves = 3
}
export declare enum CFRunLoopActivity {
    entry = 0,
    beforeTimers = 1,
    beforeSources = 2,
    beforeWaiting = 3,
    afterWaiting = 4,
    exit = 5,
    allActivities = 6
}
export declare enum CFSocketCallBackType {
    readCallBack = 0,
    acceptCallBack = 1,
    dataCallBack = 2,
    connectCallBack = 3,
    writeCallBack = 4
}
export declare enum CFStreamEventType {
    magnitude = 0,
    byteSwapped = 1,
    scalarCount = 2,
    openCompleted = 3,
    hasBytesAvailable = 4,
    canAcceptBytes = 5,
    errorOccurred = 6,
    endEncountered = 7
}
export declare enum CFStringCompareFlags {
    compareCaseInsensitive = 0,
    compareBackwards = 1,
    compareAnchored = 2,
    compareNonliteral = 3,
    compareLocalized = 4,
    compareNumerically = 5,
    compareDiacriticInsensitive = 6,
    compareWidthInsensitive = 7,
    compareForcedOrdering = 8
}
export declare enum CFStringTokenizerTokenType {
    byteSwapped = 0,
    scalarCount = 1,
    normal = 2,
    hasSubTokensMask = 3,
    hasDerivedSubTokensMask = 4,
    hasHasNumbersMask = 5,
    hasNonLettersMask = 6,
    isCJWordMask = 7
}
export declare enum CFURLBookmarkCreationOptions {
    byteSwapped = 0,
    scalarCount = 1,
    minimalBookmarkMask = 2,
    suitableForBookmarkFile = 3,
    withSecurityScope = 4,
    securityScopeAllowOnlyReadAccess = 5
}
export declare enum CFURLBookmarkResolutionOptions {
    byteSwapped = 0,
    scalarCount = 1,
    cfurlBookmarkResolutionWithoutUIMask = 2,
    cfurlBookmarkResolutionWithoutMountingMask = 3,
    cfurlBookmarkResolutionWithSecurityScope = 4,
    cfBookmarkResolutionWithoutUIMask = 5,
    cfBookmarkResolutionWithoutMountingMask = 6
}
export declare enum CFURLEnumeratorOptions {
    descendRecursively = 0,
    skipInvisibles = 1,
    generateFileReferenceURLs = 2,
    skipPackageContents = 3,
    includeDirectoriesPreOrder = 4,
    includeDirectoriesPostOrder = 5,
    generateRelativePathURLs = 6
}
export declare enum CFXMLParserOptions {
    validateDocument = 0,
    skipMetaData = 1,
    replacePhysicalEntities = 2,
    skipWhitespace = 3,
    resolveExternalEntities = 4,
    addImpliedAttributes = 5,
    allOptions = 6
}
export declare enum CFXMLParserStatusCode {
    statusParseNotBegun = 0,
    statusParseInProgress = 1,
    errorUnexpectedEOF = 2,
    errorUnknownEncoding = 3,
    errorEncodingConversionFailure = 4,
    errorMalformedProcessingInstruction = 5,
    errorMalformedDTD = 6,
    errorMalformedName = 7,
    errorMalformedCDSect = 8,
    errorMalformedCloseTag = 9,
    errorMalformedStartTag = 10,
    errorMalformedDocument = 11,
    errorElementlessDocument = 12,
    errorMalformedComment = 13,
    errorMalformedCharacterReference = 14,
    errorMalformedParsedCharacterData = 15,
    errorNoData = 16
}
export declare enum CGBitmapInfo {
    alphaInfoMask = 0,
    floatInfoMask = 1,
    floatComponents = 2,
    byteOrderMask = 3,
    byteOrder16Little = 4,
    byteOrder32Little = 5,
    byteOrder16Big = 6,
    byteOrder32Big = 7
}
export declare enum CGCaptureOptions {
    byteSwapped = 0,
    scalarCount = 1,
    noFill = 2
}
export declare enum CGConfigureOption {
    byteSwapped = 0,
    scalarCount = 1,
    forAppOnly = 2,
    forSession = 3,
    permanently = 4
}
export declare enum CGDisplayChangeSummaryFlags {
    byteSwapped = 0,
    scalarCount = 1,
    beginConfigurationFlag = 2,
    movedFlag = 3,
    setMainFlag = 4,
    setModeFlag = 5,
    addFlag = 6,
    removeFlag = 7,
    enabledFlag = 8,
    disabledFlag = 9,
    mirrorFlag = 10,
    unMirrorFlag = 11,
    desktopShapeChangedFlag = 12
}
export declare enum CGEventFilterMask {
    byteSwapped = 0,
    scalarCount = 1,
    permitLocalMouseEvents = 2,
    permitLocalKeyboardEvents = 3,
    permitSystemDefinedEvents = 4
}
export declare enum CGEventFlags {
    maskAlphaShift = 0,
    maskShift = 1,
    maskControl = 2,
    maskAlternate = 3,
    maskCommand = 4,
    maskHelp = 5,
    maskSecondaryFn = 6,
    maskNumericPad = 7,
    maskNonCoalesced = 8
}
export declare enum CGGradientDrawingOptions {
    byteSwapped = 0,
    scalarCount = 1,
    drawsBeforeStartLocation = 2,
    drawsAfterEndLocation = 3
}
export declare enum CGPDFAccessPermissions {
    byteSwapped = 0,
    scalarCount = 1,
    allowsLowQualityPrinting = 2,
    allowsHighQualityPrinting = 3,
    allowsDocumentChanges = 4,
    allowsDocumentAssembly = 5,
    allowsContentCopying = 6,
    allowsContentAccessibility = 7,
    allowsCommenting = 8,
    allowsFormFieldEntry = 9
}
export declare enum CGScreenUpdateOperation {
    byteSwapped = 0,
    scalarCount = 1,
    refresh = 2,
    move = 3,
    reducedDirtyRectangleCount = 4
}
export declare enum CGWindowImageOption {
    byteSwapped = 0,
    scalarCount = 1,
    boundsIgnoreFraming = 2,
    shouldBeOpaque = 3,
    onlyShadows = 4,
    bestResolution = 5,
    nominalResolution = 6
}
export declare enum CGWindowListOption {
    magnitude = 0,
    byteSwapped = 1,
    scalarCount = 2,
    optionAll = 3,
    optionOnScreenOnly = 4,
    optionOnScreenAboveWindow = 5,
    optionOnScreenBelowWindow = 6,
    optionIncludingWindow = 7,
    excludeDesktopElements = 8
}
export declare enum CKContainer_Application_Permissions {
    userDiscoverability = 0
}
export declare enum CMSampleBuffer {
    audioBufferListAssure16ByteAlignment = 0
}
export declare enum CMTimeFlags {
    magnitude = 0,
    byteSwapped = 1,
    scalarCount = 2,
    valid = 3,
    hasBeenRounded = 4,
    positiveInfinity = 5,
    negativeInfinity = 6,
    indefinite = 7,
    impliedValueFlagsMask = 8
}
export declare enum Character {
    request = 0,
    session = 1,
    ascii = 2,
    nextstep = 3,
    japaneseEUC = 4,
    utf8 = 5,
    isoLatin1 = 6,
    symbol = 7,
    nonLossyASCII = 8,
    shiftJIS = 9,
    isoLatin2 = 10,
    unicode = 11,
    windowsCP1251 = 12,
    windowsCP1252 = 13,
    windowsCP1253 = 14,
    windowsCP1254 = 15,
    windowsCP1250 = 16,
    iso2022JP = 17,
    macOSRoman = 18,
    utf16 = 19,
    utf16BigEndian = 20,
    utf16LittleEndian = 21,
    utf32 = 22,
    utf32BigEndian = 23,
    utf32LittleEndian = 24
}
export declare enum Data {
    video = 0,
    audio = 1,
    muxed = 2,
    text = 3,
    closedCaption = 4,
    subtitle = 5,
    timeCode = 6,
    metadata = 7,
    linearPCM = 8,
    ac3 = 9,
    iec60958AC3 = 10,
    appleIMA4 = 11,
    mpeg4AAC = 12,
    mpeg4CELP = 13,
    mpeg4HVXC = 14,
    mpeg4TwinVQ = 15,
    mace3 = 16,
    mace6 = 17,
    uLaw = 18,
    aLaw = 19,
    qDesign = 20,
    qDesign2 = 21,
    qualcomm = 22,
    mpegLayer1 = 23,
    mpegLayer2 = 24,
    mpegLayer3 = 25,
    midiStream = 26,
    parameterValueStream = 27,
    appleLossless = 28,
    mpeg4AAC_HE = 29,
    mpeg4AAC_LD = 30,
    mpeg4AAC_ELD = 31,
    mpeg4AAC_ELD_SBR = 32,
    mpeg4AAC_ELD_V2 = 33,
    mpeg4AAC_HE_V2 = 34,
    mpeg4AAC_Spatial = 35,
    mpegD_USAC = 36,
    amr = 37,
    amr_WB = 38,
    audible = 39,
    iLBC = 40,
    dviIntelIMA = 41,
    microsoftGSM = 42,
    aes3 = 43,
    enhancedAC3 = 44,
    flac = 45,
    opus = 46,
    aacLCProtected = 47,
    aacAudibleProtected = 48,
    pixelFormat_32ARGB = 49,
    pixelFormat_32BGRA = 50,
    pixelFormat_24RGB = 51,
    pixelFormat_16BE555 = 52,
    pixelFormat_16BE565 = 53,
    pixelFormat_16LE555 = 54,
    pixelFormat_16LE565 = 55,
    pixelFormat_16LE5551 = 56,
    pixelFormat_422YpCbCr8 = 57,
    pixelFormat_422YpCbCr8_yuvs = 58,
    pixelFormat_444YpCbCr8 = 59,
    pixelFormat_4444YpCbCrA8 = 60,
    pixelFormat_422YpCbCr16 = 61,
    pixelFormat_422YpCbCr10 = 62,
    pixelFormat_444YpCbCr10 = 63,
    pixelFormat_8IndexedGray_WhiteIsZero = 64,
    animation = 65,
    cinepak = 66,
    jpeg = 67,
    jpeg_OpenDML = 68,
    sorensonVideo = 69,
    sorensonVideo3 = 70,
    h263 = 71,
    h264 = 72,
    hevc = 73,
    hevcWithAlpha = 74,
    mpeg4Video = 75,
    mpeg2Video = 76,
    mpeg1Video = 77,
    dvcNTSC = 78,
    dvcPAL = 79,
    dvcProPAL = 80,
    dvcPro50NTSC = 81,
    dvcPro50PAL = 82,
    dvcPROHD720p60 = 83,
    dvcPROHD720p50 = 84,
    dvcPROHD1080i60 = 85,
    dvcPROHD1080i50 = 86,
    dvcPROHD1080p30 = 87,
    dvcPROHD1080p25 = 88,
    proRes4444XQ = 89,
    proRes4444 = 90,
    proRes422HQ = 91,
    proRes422 = 92,
    proRes422LT = 93,
    proRes422Proxy = 94,
    proResRAW = 95,
    proResRAWHQ = 96,
    mpeg1System = 97,
    mpeg2Transport = 98,
    mpeg2Program = 99,
    dv = 100,
    cea608 = 101,
    cea708 = 102,
    atsc = 103,
    qt = 104,
    mobile3GPP = 105,
    webVTT = 106,
    timeCode32 = 107,
    timeCode64 = 108,
    counter32 = 109,
    counter64 = 110,
    icy = 111,
    id3 = 112,
    boxed = 113,
    emsg = 114,
    streamBasicDescription = 115,
    magicCookie = 116,
    channelLayout = 117,
    extensions = 118,
    all = 119,
    startIndex = 120,
    endIndex = 121
}
export declare enum Int {
    byteSwapped = 0,
    scalarCount = 1
}
export declare enum NSBinarySearchingOptions {
    firstEqual = 0,
    lastEqual = 1,
    insertionIndex = 2
}
export declare enum NSDirectionalRectEdge {
    top = 0,
    leading = 1,
    bottom = 2,
    trailing = 3,
    all = 4
}
export declare enum NSDragOperation {
    copy = 0,
    link = 1,
    generic = 2,
    private = 3,
    move = 4,
    delete = 5,
    every = 6,
    all_Obsolete = 7,
    all = 8
}
export declare enum NSDraggingItemEnumerationOptions {
    concurrent = 0,
    clearNonenumeratedImages = 1
}
export declare enum NSEnumerationOptions {
    concurrent = 0,
    reverse = 1
}
export declare enum NSFetchRequestResultType {
    managedObjectResultType = 0,
    managedObjectIDResultType = 1,
    dictionaryResultType = 2,
    countResultType = 3
}
export declare enum NSFontCollectionOptions {
    applicationOnlyMask = 0
}
export declare enum NSFontTraitMask {
    byteSwapped = 0,
    scalarCount = 1,
    italicFontMask = 2,
    boldFontMask = 3,
    unboldFontMask = 4,
    nonStandardCharacterSetFontMask = 5,
    narrowFontMask = 6,
    expandedFontMask = 7,
    condensedFontMask = 8,
    smallCapsFontMask = 9,
    posterFontMask = 10,
    compressedFontMask = 11,
    fixedPitchFontMask = 12,
    unitalicFontMask = 13
}
export declare enum NSItemProviderFileOptions {
    openInPlace = 0
}
export declare enum NSKeyValueObservingOptions {
    new = 0,
    old = 1,
    initial = 2,
    prior = 3
}
export declare enum NSOrderedCollectionDifferenceCalculationOptions {
    magnitude = 0,
    timeInterval = 1,
    hashValue = 2,
    omitInsertedObjects = 3,
    omitRemovedObjects = 4,
    inferMoves = 5
}
export declare enum NSPersistentCloudKitContainerSchemaInitializationOptions {
    dryRun = 0,
    printSchema = 1
}
export declare enum NSSnapshotEventType {
    undoInsertion = 0,
    undoDeletion = 1,
    undoUpdate = 2,
    rollback = 3,
    refresh = 4,
    mergePolicy = 5
}
export declare enum NSSortOptions {
    magnitude = 0,
    byteSwapped = 1,
    scalarCount = 2,
    concurrent = 3,
    stable = 4
}
export declare enum NSSpringLoadingOptions {
    disabled = 0,
    enabled = 1,
    continuousActivation = 2,
    noHover = 3
}
export declare enum NSTextStorageEditActions {
    editedAttributes = 0,
    editedCharacters = 1
}
export declare enum NSTypesetterControlCharacterAction {
    magnitude = 0,
    byteSwapped = 1,
    scalarCount = 2,
    zeroAdvancementAction = 3,
    whitespaceAction = 4,
    horizontalTabAction = 5,
    lineBreakAction = 6,
    paragraphBreakAction = 7,
    containerBreakAction = 8
}
export declare enum NSUnderlineStyle {
    single = 0,
    thick = 1,
    double = 2,
    patternDot = 3,
    patternDash = 4,
    patternDashDot = 5,
    patternDashDotDot = 6,
    byWord = 7
}
export declare enum UInt {
    magnitude = 0,
    byteSwapped = 1,
    scalarCount = 2,
    hashValue = 3,
    boolValue = 4,
    ptr = 5,
    bitWidth = 6,
    leadingZeroBitCount = 7,
    trailingZeroBitCount = 8,
    nonzeroBitCount = 9,
    count = 10,
    startIndex = 11,
    endIndex = 12,
    indices = 13,
    words = 14
}
export declare enum UInt8 {
    regions = 0,
    startIndex = 1,
    endIndex = 2,
    indices = 3,
    hashValue = 4,
    autoupdatingCurrent = 5,
    current = 6
}
export declare enum AVAssetReferenceRestrictions {
    ForbidNone = 0,
    ForbidRemoteReferenceToLocal = 1,
    ForbidLocalReferenceToRemote = 2,
    ForbidCrossSiteReference = 4,
    ForbidLocalReferenceToLocal = 8,
    ForbidAll = 65535,
    DefaultPolicy = 2
}
export declare enum AVAudio3DMixingPointSourceInHeadMode {
    Mono = 0,
    Bypass = 1
}
export declare enum AVAudio3DMixingRenderingAlgorithm {
    EqualPowerPanning = 0,
    SphericalHead = 1,
    HRTF = 2,
    SoundField = 3,
    StereoPassThrough = 5,
    HRTFHQ = 6,
    Auto = 7
}
export declare enum AVAudio3DMixingSourceMode {
    SpatializeIfMono = 0,
    Bypass = 1,
    PointSource = 2,
    AmbienceBed = 3
}
export declare enum AVAudioCommonFormat {
    OtherFormat = 0,
    PCMFormatFloat32 = 1,
    PCMFormatFloat64 = 2,
    PCMFormatInt16 = 3,
    PCMFormatInt32 = 4
}
export declare enum AVAudioConverterInputStatus {
    HaveData = 0,
    NoDataNow = 1,
    EndOfStream = 2
}
export declare enum AVAudioConverterOutputStatus {
    HaveData = 0,
    InputRanDry = 1,
    EndOfStream = 2,
    Error = 3
}
export declare enum AVAudioConverterPrimeMethod {
    Pre = 0,
    Normal = 1,
    None = 2
}
export declare enum AVAudioEngineManualRenderingError {
    InvalidMode = -80800,
    Initialized = -80801,
    NotRunning = -80802
}
export declare enum AVAudioEngineManualRenderingMode {
    Offline = 0,
    Realtime = 1
}
export declare enum AVAudioEngineManualRenderingStatus {
    Error = -1,
    Success = 0,
    InsufficientDataFromInputNode = 1,
    CannotDoInCurrentContext = 2
}
export declare enum AVAudioEnvironmentDistanceAttenuationModel {
    Exponential = 1,
    Inverse = 2,
    Linear = 3
}
export declare enum AVAudioEnvironmentOutputType {
    Auto = 0,
    Headphones = 1,
    BuiltInSpeakers = 2,
    ExternalSpeakers = 3
}
export declare enum AVAudioPlayerNodeBufferOptions {
    Loops = 1,
    Interrupts = 2,
    InterruptsAtLoop = 4
}
export declare enum AVAudioPlayerNodeCompletionCallbackType {
    DataConsumed = 0,
    DataRendered = 1,
    DataPlayedBack = 2
}
export declare enum AVAudioQuality {
    Min = 0,
    Low = 32,
    Medium = 64,
    High = 96,
    Max = 127
}
export declare enum AVAudioSessionActivationOptions {
    None = 0
}
export declare enum AVAudioUnitDistortionPreset {
    DrumsBitBrush = 0,
    DrumsBufferBeats = 1,
    DrumsLoFi = 2,
    MultiBrokenSpeaker = 3,
    MultiCellphoneConcert = 4,
    MultiDecimated1 = 5,
    MultiDecimated2 = 6,
    MultiDecimated3 = 7,
    MultiDecimated4 = 8,
    MultiDistortedFunk = 9,
    MultiDistortedCubed = 10,
    MultiDistortedSquared = 11,
    MultiEcho1 = 12,
    MultiEcho2 = 13,
    MultiEchoTight1 = 14,
    MultiEchoTight2 = 15,
    MultiEverythingIsBroken = 16,
    SpeechAlienChatter = 17,
    SpeechCosmicInterference = 18,
    SpeechGoldenPi = 19,
    SpeechRadioTower = 20,
    SpeechWaves = 21
}
export declare enum AVAudioUnitEQFilterType {
    Parametric = 0,
    LowPass = 1,
    HighPass = 2,
    ResonantLowPass = 3,
    ResonantHighPass = 4,
    BandPass = 5,
    BandStop = 6,
    LowShelf = 7,
    HighShelf = 8,
    ResonantLowShelf = 9,
    ResonantHighShelf = 10
}
export declare enum AVAudioUnitReverbPreset {
    SmallRoom = 0,
    MediumRoom = 1,
    LargeRoom = 2,
    MediumHall = 3,
    LargeHall = 4,
    Plate = 5,
    MediumChamber = 6,
    LargeChamber = 7,
    Cathedral = 8,
    LargeRoom2 = 9,
    MediumHall2 = 10,
    MediumHall3 = 11,
    LargeHall2 = 12
}
export declare enum AVAuthorizationStatus {
    NotDetermined = 0,
    Restricted = 1,
    Denied = 2,
    Authorized = 3
}
export declare enum AVCaptureColorSpace {
    sRGB = 0,
    P3_D65 = 1
}
export declare enum AVCaptureVideoOrientation {
    Portrait = 1,
    PortraitUpsideDown = 2,
    LandscapeRight = 3,
    LandscapeLeft = 4
}
export declare enum AVContentAuthorizationStatus {
    Unknown = 0,
    Completed = 1,
    Cancelled = 2,
    TimedOut = 3,
    Busy = 4,
    NotAvailable = 5,
    NotPossible = 6
}
export declare enum AVError {
    Unknown = -11800,
    OutOfMemory = -11801,
    SessionNotRunning = -11803,
    DeviceAlreadyUsedByAnotherSession = -11804,
    NoDataCaptured = -11805,
    SessionConfigurationChanged = -11806,
    DiskFull = -11807,
    DeviceWasDisconnected = -11808,
    MediaChanged = -11809,
    MaximumDurationReached = -11810,
    MaximumFileSizeReached = -11811,
    MediaDiscontinuity = -11812,
    MaximumNumberOfSamplesForFileFormatReached = -11813,
    DeviceNotConnected = -11814,
    DeviceInUseByAnotherApplication = -11815,
    DeviceLockedForConfigurationByAnotherProcess = -11817,
    ExportFailed = -11820,
    DecodeFailed = -11821,
    InvalidSourceMedia = -11822,
    FileAlreadyExists = -11823,
    CompositionTrackSegmentsNotContiguous = -11824,
    InvalidCompositionTrackSegmentDuration = -11825,
    InvalidCompositionTrackSegmentSourceStartTime = -11826,
    InvalidCompositionTrackSegmentSourceDuration = -11827,
    FileFormatNotRecognized = -11828,
    FileFailedToParse = -11829,
    MaximumStillImageCaptureRequestsExceeded = -11830,
    ContentIsProtected = -11831,
    NoImageAtTime = -11832,
    DecoderNotFound = -11833,
    EncoderNotFound = -11834,
    ContentIsNotAuthorized = -11835,
    ApplicationIsNotAuthorized = -11836,
    OperationNotSupportedForAsset = -11838,
    DecoderTemporarilyUnavailable = -11839,
    EncoderTemporarilyUnavailable = -11840,
    InvalidVideoComposition = -11841,
    ReferenceForbiddenByReferencePolicy = -11842,
    InvalidOutputURLPathExtension = -11843,
    ScreenCaptureFailed = -11844,
    DisplayWasDisabled = -11845,
    TorchLevelUnavailable = -11846,
    IncompatibleAsset = -11848,
    FailedToLoadMediaData = -11849,
    ServerIncorrectlyConfigured = -11850,
    ApplicationIsNotAuthorizedToUseDevice = -11852,
    FailedToParse = -11853,
    FileTypeDoesNotSupportSampleReferences = -11854,
    UndecodableMediaData = -11855,
    AirPlayControllerRequiresInternet = -11856,
    AirPlayReceiverRequiresInternet = -11857,
    VideoCompositorFailed = -11858,
    CreateContentKeyRequestFailed = -11860,
    UnsupportedOutputSettings = -11861,
    OperationNotAllowed = -11862,
    ContentIsUnavailable = -11863,
    FormatUnsupported = -11864,
    MalformedDepth = -11865,
    ContentNotUpdated = -11866,
    NoLongerPlayable = -11867,
    NoCompatibleAlternatesForExternalDisplay = -11868,
    NoSourceTrack = -11869,
    ExternalPlaybackNotSupportedForAsset = -11870,
    OperationNotSupportedForPreset = -11871,
    SessionHardwareCostOverage = -11872,
    UnsupportedDeviceActiveFormat = -11873
}
export declare enum AVKeyValueStatus {
    Unknown = 0,
    Loading = 1,
    Loaded = 2,
    Failed = 3,
    Cancelled = 4
}
export declare enum AVMovieWritingOptions {
    AddMovieHeaderToDestination = 0,
    TruncateDestinationToMovieHeaderOnly = 1
}
export declare enum AVMusicSequenceLoadOptions {
    SMF_PreserveTracks = 0,
    SMF_ChannelsToTracks = 1
}
export declare enum AVMusicTrackLoopCount {
    Forever = -1
}
export declare enum AVQueuedSampleBufferRenderingStatus {
    Unknown = 0,
    Rendering = 1,
    Failed = 2
}
export declare enum AVSpeechBoundary {
    Immediate = 0,
    Word = 1
}
export declare enum AVSpeechSynthesisVoiceGender {
    Unspecified = 0,
    Male = 1,
    Female = 2
}
export declare enum AVSpeechSynthesisVoiceQuality {
    Default = 1,
    Enhanced = 2
}
export declare enum AVVideoFieldMode {
    Both = 0,
    TopOnly = 1,
    BottomOnly = 2,
    Deinterlace = 3
}
export declare enum AVCaptureViewControlsStyle {
    Inline = 0,
    Floating = 1,
    InlineDeviceSelection = 2,
    Default = 0
}
export declare enum AVPlayerViewControlsStyle {
    None = 0,
    Inline = 1,
    Floating = 2,
    Minimal = 3,
    Default = 1
}
export declare enum AVPlayerViewTrimResult {
    OKButton = 0,
    CancelButton = 1
}
export declare enum AVRoutePickerViewButtonState {
    Normal = 0,
    NormalHighlighted = 1,
    Active = 2,
    ActiveHighlighted = 3
}
export declare enum NSAccessibilityPriorityLevel {
    Low = 10,
    Medium = 50,
    High = 90
}
export declare enum NSAnimationEffect {
    DisappearingItemDefault = 0,
    Poof = 10
}
export declare enum NSBorderType {
    NoBorder = 0,
    LineBorder = 1,
    BezelBorder = 2,
    GrooveBorder = 3
}
export declare enum NSCharacterCollection {
    IdentityMappingCharacterCollection = 0,
    AdobeCNS1CharacterCollection = 1,
    AdobeGB1CharacterCollection = 2,
    AdobeJapan1CharacterCollection = 3,
    AdobeJapan2CharacterCollection = 4,
    AdobeKorea1CharacterCollection = 5
}
export declare enum NSCollectionElementCategory {
    Item = 0,
    SupplementaryView = 1,
    DecorationView = 2,
    InterItemGap = 3
}
export declare enum NSCollectionLayoutSectionOrthogonalScrollingBehavior {
    None = 0,
    Continuous = 1,
    ContinuousGroupLeadingBoundary = 2,
    Paging = 3,
    GroupPaging = 4,
    GroupPagingCentered = 5
}
export declare enum NSColorRenderingIntent {
    Default = 0,
    AbsoluteColorimetric = 1,
    RelativeColorimetric = 2,
    Perceptual = 3,
    Saturation = 4
}
export declare enum NSCompositingOperation {
    Clear = 0,
    Copy = 1,
    SourceOver = 2,
    SourceIn = 3,
    SourceOut = 4,
    SourceAtop = 5,
    DestinationOver = 6,
    DestinationIn = 7,
    DestinationOut = 8,
    DestinationAtop = 9,
    XOR = 10,
    PlusDarker = 11,
    Highlight = 12,
    PlusLighter = 13,
    Multiply = 14,
    Screen = 15,
    Overlay = 16,
    Darken = 17,
    Lighten = 18,
    ColorDodge = 19,
    ColorBurn = 20,
    SoftLight = 21,
    HardLight = 22,
    Difference = 23,
    Exclusion = 24,
    Hue = 25,
    Saturation = 26,
    Color = 27,
    Luminosity = 28
}
export declare enum NSControlTint {
    DefaultControlTint = 0,
    BlueControlTint = 1,
    GraphiteControlTint = 6,
    ClearControlTint = 7
}
export declare enum NSDirectionalRectEdge {
    None = 0,
    Top = 1,
    Leading = 2,
    Bottom = 4,
    Trailing = 8,
    All = 15
}
export declare enum NSDisplayGamut {
    SRGB = 1,
    P3 = 2
}
export declare enum NSDragOperation {
    None = 0,
    Copy = 1,
    Link = 2,
    Generic = 4,
    Private = 8,
    Move = 16,
    Delete = 32,
    Every = -1,
    All_Obsolete = 15,
    All = 15
}
export declare enum NSDraggingContext {
    OutsideApplication = 0,
    WithinApplication = 1
}
export declare enum NSDraggingFormation {
    Default = 0,
    None = 1,
    Pile = 2,
    List = 3,
    Stack = 4
}
export declare enum NSDraggingItemEnumerationOptions {
    Concurrent = 1,
    ClearNonenumeratedImages = 65536
}
export declare enum NSFindPanelAction {
    ShowFindPanel = 1,
    Next = 2,
    Previous = 3,
    ReplaceAll = 4,
    Replace = 5,
    ReplaceAndFind = 6,
    SetFindString = 7,
    ReplaceAllInSelection = 8,
    SelectAll = 9,
    SelectAllInSelection = 10
}
export declare enum NSFindPanelSubstringMatchType {
    Contains = 0,
    StartsWith = 1,
    FullWord = 2,
    EndsWith = 3
}
export declare enum NSFocusRingPlacement {
    Only = 0,
    Below = 1,
    Above = 2
}
export declare enum NSFocusRingType {
    Default = 0,
    None = 1,
    Exterior = 2
}
export declare enum NSFontAction {
    NoFontChangeAction = 0,
    ViaPanelFontAction = 1,
    AddTraitFontAction = 2,
    SizeUpFontAction = 3,
    SizeDownFontAction = 4,
    HeavierFontAction = 5,
    LighterFontAction = 6,
    RemoveTraitFontAction = 7
}
export declare enum NSFontCollectionOptions {
    ApplicationOnlyMask = 1
}
export declare enum NSFontRenderingMode {
    DefaultRenderingMode = 0,
    AntialiasedRenderingMode = 1,
    IntegerAdvancementsRenderingMode = 2,
    AntialiasedIntegerAdvancementsRenderingMode = 3
}
export declare enum NSFontTraitMask {
    ItalicFontMask = 1,
    BoldFontMask = 2,
    UnboldFontMask = 4,
    NonStandardCharacterSetFontMask = 8,
    NarrowFontMask = 16,
    ExpandedFontMask = 32,
    CondensedFontMask = 64,
    SmallCapsFontMask = 128,
    PosterFontMask = 256,
    CompressedFontMask = 512,
    FixedPitchFontMask = 1024,
    UnitalicFontMask = 16777216
}
export declare enum NSImageAlignment {
    Center = 0,
    Top = 1,
    TopLeft = 2,
    TopRight = 3,
    Left = 4,
    Bottom = 5,
    BottomLeft = 6,
    BottomRight = 7,
    Right = 8
}
export declare enum NSImageInterpolation {
    Default = 0,
    None = 1,
    Low = 2,
    Medium = 4,
    High = 3
}
export declare enum NSImageScaling {
    ImageScaleProportionallyDown = 0,
    ImageScaleAxesIndependently = 1,
    ImageScaleNone = 2,
    ImageScaleProportionallyUpOrDown = 3,
    ScaleProportionally = 0,
    ScaleToFit = 1,
    ScaleNone = 2
}
export declare enum NSLineBreakMode {
    ByWordWrapping = 0,
    ByCharWrapping = 1,
    ByClipping = 2,
    ByTruncatingHead = 3,
    ByTruncatingTail = 4,
    ByTruncatingMiddle = 5
}
export declare enum NSLineMovementDirection {
    DoesntMove = 0,
    MovesLeft = 1,
    MovesRight = 2,
    MovesDown = 3,
    MovesUp = 4
}
export declare enum NSLineSweepDirection {
    Left = 0,
    Right = 1,
    Down = 2,
    Up = 3
}
export declare enum NSRectAlignment {
    None = 0,
    Top = 1,
    TopLeading = 2,
    Leading = 3,
    BottomLeading = 4,
    Bottom = 5,
    BottomTrailing = 6,
    Trailing = 7,
    TopTrailing = 8
}
export declare enum NSSelectionAffinity {
    Upstream = 0,
    Downstream = 1
}
export declare enum NSSelectionGranularity {
    ByCharacter = 0,
    ByWord = 1,
    ByParagraph = 2
}
export declare enum NSSpringLoadingHighlight {
    None = 0,
    Standard = 1,
    Emphasized = 2
}
export declare enum NSSpringLoadingOptions {
    Disabled = 0,
    Enabled = 1,
    ContinuousActivation = 2,
    NoHover = 8
}
export declare enum NSTextAlignment {
    Left = 0,
    Right = 1,
    Center = 2,
    Justified = 3,
    Natural = 4
}
export declare enum NSTextInputTraitType {
    Default = 0,
    No = 1,
    Yes = 2
}
export declare enum NSTextMovement {
    Return = 16,
    Tab = 17,
    Backtab = 18,
    Left = 19,
    Right = 20,
    Up = 21,
    Down = 22,
    Cancel = 23,
    Other = 0
}
export declare enum NSTextScalingType {
    Standard = 0,
    iOS = 1
}
export declare enum NSTextStorageEditActions {
    EditedAttributes = 1,
    EditedCharacters = 2
}
export declare enum NSTypesetterControlCharacterAction {
    ZeroAdvancementAction = 1,
    WhitespaceAction = 2,
    HorizontalTabAction = 4,
    LineBreakAction = 8,
    ParagraphBreakAction = 16,
    ContainerBreakAction = 32
}
export declare enum NSUnderlineStyle {
    None = 0,
    Single = 1,
    Thick = 2,
    Double = 9,
    PatternSolid = 0,
    PatternDot = 256,
    PatternDash = 512,
    PatternDashDot = 768,
    PatternDashDotDot = 1024,
    ByWord = 32768
}
export declare enum NSUserInterfaceLayoutDirection {
    LeftToRight = 0,
    RightToLeft = 1
}
export declare enum NSUserInterfaceLayoutOrientation {
    Horizontal = 0,
    Vertical = 1
}
export declare enum NSWritingDirection {
    Natural = -1,
    LeftToRight = 0,
    RightToLeft = 1
}
export declare enum NSWritingDirectionFormatType {
    Embedding = 0,
    Override = 2
}
export declare enum NSAttributeType {
    UndefinedAttributeType = 0,
    Integer16AttributeType = 100,
    Integer32AttributeType = 200,
    Integer64AttributeType = 300,
    DecimalAttributeType = 400,
    DoubleAttributeType = 500,
    FloatAttributeType = 600,
    StringAttributeType = 700,
    BooleanAttributeType = 800,
    DateAttributeType = 900,
    BinaryDataAttributeType = 1000,
    UUIDAttributeType = 1100,
    URIAttributeType = 1200,
    TransformableAttributeType = 1800,
    ObjectIDAttributeType = 2000
}
export declare enum NSBatchDeleteRequestResultType {
    ResultTypeStatusOnly = 0,
    ResultTypeObjectIDs = 1,
    ResultTypeCount = 2
}
export declare enum NSBatchInsertRequestResultType {
    StatusOnly = 0,
    ObjectIDs = 1,
    Count = 2
}
export declare enum NSBatchUpdateRequestResultType {
    StatusOnlyResultType = 0,
    UpdatedObjectIDsResultType = 1,
    UpdatedObjectsCountResultType = 2
}
export declare enum NSDeleteRule {
    NoActionDeleteRule = 0,
    NullifyDeleteRule = 1,
    CascadeDeleteRule = 2,
    DenyDeleteRule = 3
}
export declare enum NSEntityMappingType {
    UndefinedEntityMappingType = 0,
    CustomEntityMappingType = 1,
    AddEntityMappingType = 2,
    RemoveEntityMappingType = 3,
    CopyEntityMappingType = 4,
    TransformEntityMappingType = 5
}
export declare enum NSFetchIndexElementType {
    Binary = 0,
    RTree = 1
}
export declare enum NSFetchRequestResultType {
    ManagedObjectResultType = 0,
    ManagedObjectIDResultType = 1,
    DictionaryResultType = 2,
    CountResultType = 4
}
export declare enum NSFetchedResultsChangeType {
    Insert = 1,
    Delete = 2,
    Move = 3,
    Update = 4
}
export declare enum NSManagedObjectContextConcurrencyType {
    ConfinementConcurrencyType = 0,
    PrivateQueueConcurrencyType = 1,
    MainQueueConcurrencyType = 2
}
export declare enum NSMergePolicyType {
    ErrorMergePolicyType = 0,
    MergeByPropertyStoreTrumpMergePolicyType = 1,
    MergeByPropertyObjectTrumpMergePolicyType = 2,
    OverwriteMergePolicyType = 3,
    RollbackMergePolicyType = 4
}
export declare enum NSPersistentCloudKitContainerSchemaInitializationOptions {
    None = 0,
    DryRun = 2,
    PrintSchema = 4
}
export declare enum NSPersistentHistoryChangeType {
    Insert = 0,
    Update = 1,
    Delete = 2
}
export declare enum NSPersistentHistoryResultType {
    StatusOnly = 0,
    ObjectIDs = 1,
    Count = 2,
    TransactionsOnly = 3,
    ChangesOnly = 4,
    TransactionsAndChanges = 5
}
export declare enum NSPersistentStoreRequestType {
    FetchRequestType = 1,
    SaveRequestType = 2,
    BatchInsertRequestType = 5,
    BatchUpdateRequestType = 6,
    BatchDeleteRequestType = 7
}
export declare enum NSSnapshotEventType {
    UndoInsertion = 2,
    UndoDeletion = 4,
    UndoUpdate = 8,
    Rollback = 16,
    Refresh = 32,
    MergePolicy = 64
}
export declare enum CFCalendarUnit {
    kCFCalendarUnitEra = 2,
    kCFCalendarUnitYear = 4,
    kCFCalendarUnitMonth = 8,
    kCFCalendarUnitDay = 16,
    kCFCalendarUnitHour = 32,
    kCFCalendarUnitMinute = 64,
    kCFCalendarUnitSecond = 128,
    kCFCalendarUnitWeek = 256,
    kCFCalendarUnitWeekday = 512,
    kCFCalendarUnitWeekdayOrdinal = 1024,
    kCFCalendarUnitQuarter = 2048,
    kCFCalendarUnitWeekOfMonth = 4096,
    kCFCalendarUnitWeekOfYear = 8192,
    kCFCalendarUnitYearForWeekOfYear = 16384
}
export declare enum CFCharacterSetPredefinedSet {
    kCFCharacterSetControl = 1,
    kCFCharacterSetWhitespace = 2,
    kCFCharacterSetWhitespaceAndNewline = 3,
    kCFCharacterSetDecimalDigit = 4,
    kCFCharacterSetLetter = 5,
    kCFCharacterSetLowercaseLetter = 6,
    kCFCharacterSetUppercaseLetter = 7,
    kCFCharacterSetNonBase = 8,
    kCFCharacterSetDecomposable = 9,
    kCFCharacterSetAlphaNumeric = 10,
    kCFCharacterSetPunctuation = 11,
    kCFCharacterSetCapitalizedLetter = 13,
    kCFCharacterSetSymbol = 14,
    kCFCharacterSetNewline = 15,
    kCFCharacterSetIllegal = 12
}
export declare enum CFComparisonResult {
    kCFCompareLessThan = -1,
    kCFCompareEqualTo = 0,
    kCFCompareGreaterThan = 1
}
export declare enum CFDataSearchFlags {
    kCFDataSearchBackwards = 1,
    kCFDataSearchAnchored = 2
}
export declare enum CFDateFormatterStyle {
    kCFDateFormatterNoStyle = 0,
    kCFDateFormatterShortStyle = 1,
    kCFDateFormatterMediumStyle = 2,
    kCFDateFormatterLongStyle = 3,
    kCFDateFormatterFullStyle = 4
}
export declare enum CFFileSecurityClearOptions {
    kCFFileSecurityClearOwner = 1,
    kCFFileSecurityClearGroup = 2,
    kCFFileSecurityClearMode = 4,
    kCFFileSecurityClearOwnerUUID = 8,
    kCFFileSecurityClearGroupUUID = 16,
    kCFFileSecurityClearAccessControlList = 32
}
export declare enum CFGregorianUnitFlags {
    kCFGregorianUnitsYears = 1,
    kCFGregorianUnitsMonths = 2,
    kCFGregorianUnitsDays = 4,
    kCFGregorianUnitsHours = 8,
    kCFGregorianUnitsMinutes = 16,
    kCFGregorianUnitsSeconds = 32,
    kCFGregorianAllUnits = 16777215
}
export declare enum CFISO8601DateFormatOptions {
    kCFISO8601DateFormatWithYear = 1,
    kCFISO8601DateFormatWithMonth = 2,
    kCFISO8601DateFormatWithWeekOfYear = 4,
    kCFISO8601DateFormatWithDay = 16,
    kCFISO8601DateFormatWithTime = 32,
    kCFISO8601DateFormatWithTimeZone = 64,
    kCFISO8601DateFormatWithSpaceBetweenDateAndTime = 128,
    kCFISO8601DateFormatWithDashSeparatorInDate = 256,
    kCFISO8601DateFormatWithColonSeparatorInTime = 512,
    kCFISO8601DateFormatWithColonSeparatorInTimeZone = 1024,
    kCFISO8601DateFormatWithFractionalSeconds = 2048,
    kCFISO8601DateFormatWithFullDate = 275,
    kCFISO8601DateFormatWithFullTime = 1632,
    kCFISO8601DateFormatWithInternetDateTime = 1907
}
export declare enum CFLocaleLanguageDirection {
    kCFLocaleLanguageDirectionUnknown = 0,
    kCFLocaleLanguageDirectionLeftToRight = 1,
    kCFLocaleLanguageDirectionRightToLeft = 2,
    kCFLocaleLanguageDirectionTopToBottom = 3,
    kCFLocaleLanguageDirectionBottomToTop = 4
}
export declare enum CFNotificationSuspensionBehavior {
    Drop = 1,
    Coalesce = 2,
    Hold = 3,
    DeliverImmediately = 4
}
export declare enum CFNumberFormatterOptionFlags {
    kCFNumberFormatterParseIntegersOnly = 1
}
export declare enum CFNumberFormatterPadPosition {
    kCFNumberFormatterPadBeforePrefix = 0,
    kCFNumberFormatterPadAfterPrefix = 1,
    kCFNumberFormatterPadBeforeSuffix = 2,
    kCFNumberFormatterPadAfterSuffix = 3
}
export declare enum CFNumberFormatterRoundingMode {
    kCFNumberFormatterRoundCeiling = 0,
    kCFNumberFormatterRoundFloor = 1,
    kCFNumberFormatterRoundDown = 2,
    kCFNumberFormatterRoundUp = 3,
    kCFNumberFormatterRoundHalfEven = 4,
    kCFNumberFormatterRoundHalfDown = 5,
    kCFNumberFormatterRoundHalfUp = 6
}
export declare enum CFNumberFormatterStyle {
    kCFNumberFormatterNoStyle = 0,
    kCFNumberFormatterDecimalStyle = 1,
    kCFNumberFormatterCurrencyStyle = 2,
    kCFNumberFormatterPercentStyle = 3,
    kCFNumberFormatterScientificStyle = 4,
    kCFNumberFormatterSpellOutStyle = 5,
    kCFNumberFormatterOrdinalStyle = 6,
    kCFNumberFormatterCurrencyISOCodeStyle = 8,
    kCFNumberFormatterCurrencyPluralStyle = 9,
    kCFNumberFormatterCurrencyAccountingStyle = 10
}
export declare enum CFNumberType {
    kCFNumberSInt8Type = 1,
    kCFNumberSInt16Type = 2,
    kCFNumberSInt32Type = 3,
    kCFNumberSInt64Type = 4,
    kCFNumberFloat32Type = 5,
    kCFNumberFloat64Type = 6,
    kCFNumberCharType = 7,
    kCFNumberShortType = 8,
    kCFNumberIntType = 9,
    kCFNumberLongType = 10,
    kCFNumberLongLongType = 11,
    kCFNumberFloatType = 12,
    kCFNumberDoubleType = 13,
    kCFNumberCFIndexType = 14,
    kCFNumberNSIntegerType = 15,
    kCFNumberCGFloatType = 16,
    kCFNumberMaxType = 16
}
export declare enum CFPropertyListFormat {
    kCFPropertyListOpenStepFormat = 1,
    kCFPropertyListXMLFormat_v1_0 = 100,
    kCFPropertyListBinaryFormat_v1_0 = 200
}
export declare enum CFPropertyListMutabilityOptions {
    kCFPropertyListImmutable = 0,
    kCFPropertyListMutableContainers = 1,
    kCFPropertyListMutableContainersAndLeaves = 2
}
export declare enum CFRunLoopActivity {
    kCFRunLoopEntry = 1,
    kCFRunLoopBeforeTimers = 2,
    kCFRunLoopBeforeSources = 4,
    kCFRunLoopBeforeWaiting = 32,
    kCFRunLoopAfterWaiting = 64,
    kCFRunLoopExit = 128,
    kCFRunLoopAllActivities = 268435455
}
export declare enum CFRunLoopRunResult {
    kCFRunLoopRunFinished = 1,
    kCFRunLoopRunStopped = 2,
    kCFRunLoopRunTimedOut = 3,
    kCFRunLoopRunHandledSource = 4
}
export declare enum CFSocketCallBackType {
    kCFSocketNoCallBack = 0,
    kCFSocketReadCallBack = 1,
    kCFSocketAcceptCallBack = 2,
    kCFSocketDataCallBack = 3,
    kCFSocketConnectCallBack = 4,
    kCFSocketWriteCallBack = 8
}
export declare enum CFSocketError {
    kCFSocketSuccess = 0,
    kCFSocketError = -1,
    kCFSocketTimeout = -2
}
export declare enum CFStreamErrorDomain {
    kCFStreamErrorDomainCustom = -1,
    kCFStreamErrorDomainPOSIX = 1,
    kCFStreamErrorDomainMacOSStatus = 2
}
export declare enum CFStreamEventType {
    kCFStreamEventNone = 0,
    kCFStreamEventOpenCompleted = 1,
    kCFStreamEventHasBytesAvailable = 2,
    kCFStreamEventCanAcceptBytes = 4,
    kCFStreamEventErrorOccurred = 8,
    kCFStreamEventEndEncountered = 16
}
export declare enum CFStreamStatus {
    kCFStreamStatusNotOpen = 0,
    kCFStreamStatusOpening = 1,
    kCFStreamStatusOpen = 2,
    kCFStreamStatusReading = 3,
    kCFStreamStatusWriting = 4,
    kCFStreamStatusAtEnd = 5,
    kCFStreamStatusClosed = 6,
    kCFStreamStatusError = 7
}
export declare enum CFStringBuiltInEncodings {
    kCFStringEncodingMacRoman = 0,
    kCFStringEncodingWindowsLatin1 = 1280,
    kCFStringEncodingISOLatin1 = 513,
    kCFStringEncodingNextStepLatin = 2817,
    kCFStringEncodingASCII = 1536,
    kCFStringEncodingUnicode = 256,
    kCFStringEncodingUTF8 = 134217984,
    kCFStringEncodingNonLossyASCII = 3071,
    kCFStringEncodingUTF16 = 256,
    kCFStringEncodingUTF16BE = 268435712,
    kCFStringEncodingUTF16LE = 335544576,
    kCFStringEncodingUTF32 = 201326848,
    kCFStringEncodingUTF32BE = 402653440,
    kCFStringEncodingUTF32LE = 469762304
}
export declare enum CFStringCompareFlags {
    kCFCompareCaseInsensitive = 1,
    kCFCompareBackwards = 4,
    kCFCompareAnchored = 8,
    kCFCompareNonliteral = 16,
    kCFCompareLocalized = 32,
    kCFCompareNumerically = 64,
    kCFCompareDiacriticInsensitive = 128,
    kCFCompareWidthInsensitive = 256,
    kCFCompareForcedOrdering = 512
}
export declare enum CFStringEncodings {
    kCFStringEncodingMacJapanese = 1,
    kCFStringEncodingMacChineseTrad = 2,
    kCFStringEncodingMacKorean = 3,
    kCFStringEncodingMacArabic = 4,
    kCFStringEncodingMacHebrew = 5,
    kCFStringEncodingMacGreek = 6,
    kCFStringEncodingMacCyrillic = 7,
    kCFStringEncodingMacDevanagari = 9,
    kCFStringEncodingMacGurmukhi = 10,
    kCFStringEncodingMacGujarati = 11,
    kCFStringEncodingMacOriya = 12,
    kCFStringEncodingMacBengali = 13,
    kCFStringEncodingMacTamil = 14,
    kCFStringEncodingMacTelugu = 15,
    kCFStringEncodingMacKannada = 16,
    kCFStringEncodingMacMalayalam = 17,
    kCFStringEncodingMacSinhalese = 18,
    kCFStringEncodingMacBurmese = 19,
    kCFStringEncodingMacKhmer = 20,
    kCFStringEncodingMacThai = 21,
    kCFStringEncodingMacLaotian = 22,
    kCFStringEncodingMacGeorgian = 23,
    kCFStringEncodingMacArmenian = 24,
    kCFStringEncodingMacChineseSimp = 25,
    kCFStringEncodingMacTibetan = 26,
    kCFStringEncodingMacMongolian = 27,
    kCFStringEncodingMacEthiopic = 28,
    kCFStringEncodingMacCentralEurRoman = 29,
    kCFStringEncodingMacVietnamese = 30,
    kCFStringEncodingMacExtArabic = 31,
    kCFStringEncodingMacSymbol = 33,
    kCFStringEncodingMacDingbats = 34,
    kCFStringEncodingMacTurkish = 35,
    kCFStringEncodingMacCroatian = 36,
    kCFStringEncodingMacIcelandic = 37,
    kCFStringEncodingMacRomanian = 38,
    kCFStringEncodingMacCeltic = 39,
    kCFStringEncodingMacGaelic = 40,
    kCFStringEncodingMacFarsi = 140,
    kCFStringEncodingMacUkrainian = 152,
    kCFStringEncodingMacInuit = 236,
    kCFStringEncodingMacVT100 = 252,
    kCFStringEncodingMacHFS = 255,
    kCFStringEncodingISOLatin2 = 514,
    kCFStringEncodingISOLatin3 = 515,
    kCFStringEncodingISOLatin4 = 516,
    kCFStringEncodingISOLatinCyrillic = 517,
    kCFStringEncodingISOLatinArabic = 518,
    kCFStringEncodingISOLatinGreek = 519,
    kCFStringEncodingISOLatinHebrew = 520,
    kCFStringEncodingISOLatin5 = 521,
    kCFStringEncodingISOLatin6 = 522,
    kCFStringEncodingISOLatinThai = 523,
    kCFStringEncodingISOLatin7 = 525,
    kCFStringEncodingISOLatin8 = 526,
    kCFStringEncodingISOLatin9 = 527,
    kCFStringEncodingISOLatin10 = 528,
    kCFStringEncodingDOSLatinUS = 1024,
    kCFStringEncodingDOSGreek = 1029,
    kCFStringEncodingDOSBalticRim = 1030,
    kCFStringEncodingDOSLatin1 = 1040,
    kCFStringEncodingDOSGreek1 = 1041,
    kCFStringEncodingDOSLatin2 = 1042,
    kCFStringEncodingDOSCyrillic = 1043,
    kCFStringEncodingDOSTurkish = 1044,
    kCFStringEncodingDOSPortuguese = 1045,
    kCFStringEncodingDOSIcelandic = 1046,
    kCFStringEncodingDOSHebrew = 1047,
    kCFStringEncodingDOSCanadianFrench = 1048,
    kCFStringEncodingDOSArabic = 1049,
    kCFStringEncodingDOSNordic = 1050,
    kCFStringEncodingDOSRussian = 1051,
    kCFStringEncodingDOSGreek2 = 1052,
    kCFStringEncodingDOSThai = 1053,
    kCFStringEncodingDOSJapanese = 1056,
    kCFStringEncodingDOSChineseSimplif = 1057,
    kCFStringEncodingDOSKorean = 1058,
    kCFStringEncodingDOSChineseTrad = 1059,
    kCFStringEncodingWindowsLatin2 = 1281,
    kCFStringEncodingWindowsCyrillic = 1282,
    kCFStringEncodingWindowsGreek = 1283,
    kCFStringEncodingWindowsLatin5 = 1284,
    kCFStringEncodingWindowsHebrew = 1285,
    kCFStringEncodingWindowsArabic = 1286,
    kCFStringEncodingWindowsBalticRim = 1287,
    kCFStringEncodingWindowsVietnamese = 1288,
    kCFStringEncodingWindowsKoreanJohab = 1296,
    kCFStringEncodingANSEL = 1537,
    kCFStringEncodingJIS_X0201_76 = 1568,
    kCFStringEncodingJIS_X0208_83 = 1569,
    kCFStringEncodingJIS_X0208_90 = 1570,
    kCFStringEncodingJIS_X0212_90 = 1571,
    kCFStringEncodingJIS_C6226_78 = 1572,
    kCFStringEncodingShiftJIS_X0213 = 1576,
    kCFStringEncodingShiftJIS_X0213_MenKuTen = 1577,
    kCFStringEncodingGB_2312_80 = 1584,
    kCFStringEncodingGBK_95 = 1585,
    kCFStringEncodingGB_18030_2000 = 1586,
    kCFStringEncodingKSC_5601_87 = 1600,
    kCFStringEncodingKSC_5601_92_Johab = 1601,
    kCFStringEncodingCNS_11643_92_P1 = 1617,
    kCFStringEncodingCNS_11643_92_P2 = 1618,
    kCFStringEncodingCNS_11643_92_P3 = 1619,
    kCFStringEncodingISO_2022_JP = 2080,
    kCFStringEncodingISO_2022_JP_2 = 2081,
    kCFStringEncodingISO_2022_JP_1 = 2082,
    kCFStringEncodingISO_2022_JP_3 = 2083,
    kCFStringEncodingISO_2022_CN = 2096,
    kCFStringEncodingISO_2022_CN_EXT = 2097,
    kCFStringEncodingISO_2022_KR = 2112,
    kCFStringEncodingEUC_JP = 2336,
    kCFStringEncodingEUC_CN = 2352,
    kCFStringEncodingEUC_TW = 2353,
    kCFStringEncodingEUC_KR = 2368,
    kCFStringEncodingShiftJIS = 2561,
    kCFStringEncodingKOI8_R = 2562,
    kCFStringEncodingBig5 = 2563,
    kCFStringEncodingMacRomanLatin1 = 2564,
    kCFStringEncodingHZ_GB_2312 = 2565,
    kCFStringEncodingBig5_HKSCS_1999 = 2566,
    kCFStringEncodingVISCII = 2567,
    kCFStringEncodingKOI8_U = 2568,
    kCFStringEncodingBig5_E = 2569,
    kCFStringEncodingNextStepJapanese = 2818,
    kCFStringEncodingEBCDIC_US = 3073,
    kCFStringEncodingEBCDIC_CP037 = 3074,
    kCFStringEncodingUTF7 = 67109120,
    kCFStringEncodingUTF7_IMAP = 2576,
    kCFStringEncodingShiftJIS_X0213_00 = 1576
}
export declare enum CFStringNormalizationForm {
    kCFStringNormalizationFormD = 0,
    kCFStringNormalizationFormKD = 1,
    kCFStringNormalizationFormC = 2,
    kCFStringNormalizationFormKC = 3
}
export declare enum CFStringTokenizerTokenType {
    kCFStringTokenizerTokenNone = 0,
    kCFStringTokenizerTokenNormal = 1,
    kCFStringTokenizerTokenHasSubTokensMask = 2,
    kCFStringTokenizerTokenHasDerivedSubTokensMask = 4,
    kCFStringTokenizerTokenHasHasNumbersMask = 8,
    kCFStringTokenizerTokenHasNonLettersMask = 16,
    kCFStringTokenizerTokenIsCJWordMask = 32
}
export declare enum CFTimeZoneNameStyle {
    kCFTimeZoneNameStyleStandard = 0,
    kCFTimeZoneNameStyleShortStandard = 1,
    kCFTimeZoneNameStyleDaylightSaving = 2,
    kCFTimeZoneNameStyleShortDaylightSaving = 3,
    kCFTimeZoneNameStyleGeneric = 4,
    kCFTimeZoneNameStyleShortGeneric = 5
}
export declare enum CFURLBookmarkCreationOptions {
    kCFURLBookmarkCreationMinimalBookmarkMask = 512,
    kCFURLBookmarkCreationSuitableForBookmarkFile = 1024,
    kCFURLBookmarkCreationWithSecurityScope = 2048,
    kCFURLBookmarkCreationSecurityScopeAllowOnlyReadAccess = 4096,
    kCFURLBookmarkCreationPreferFileIDResolutionMask = 256
}
export declare enum CFURLBookmarkResolutionOptions {
    kCFURLBookmarkResolutionWithoutUIMask = 256,
    kCFURLBookmarkResolutionWithoutMountingMask = 512,
    kCFURLBookmarkResolutionWithSecurityScope = 1024,
    kCFBookmarkResolutionWithoutUIMask = 256,
    kCFBookmarkResolutionWithoutMountingMask = 512
}
export declare enum CFURLComponentType {
    kCFURLComponentScheme = 1,
    kCFURLComponentNetLocation = 2,
    kCFURLComponentPath = 3,
    kCFURLComponentResourceSpecifier = 4,
    kCFURLComponentUser = 5,
    kCFURLComponentPassword = 6,
    kCFURLComponentUserInfo = 7,
    kCFURLComponentHost = 8,
    kCFURLComponentPort = 9,
    kCFURLComponentParameterString = 10,
    kCFURLComponentQuery = 11,
    kCFURLComponentFragment = 12
}
export declare enum CFURLEnumeratorOptions {
    kCFURLEnumeratorDefaultBehavior = 0,
    kCFURLEnumeratorDescendRecursively = 1,
    kCFURLEnumeratorSkipInvisibles = 2,
    kCFURLEnumeratorGenerateFileReferenceURLs = 4,
    kCFURLEnumeratorSkipPackageContents = 8,
    kCFURLEnumeratorIncludeDirectoriesPreOrder = 16,
    kCFURLEnumeratorIncludeDirectoriesPostOrder = 32,
    kCFURLEnumeratorGenerateRelativePathURLs = 64
}
export declare enum CFURLEnumeratorResult {
    kCFURLEnumeratorSuccess = 1,
    kCFURLEnumeratorEnd = 2,
    kCFURLEnumeratorError = 3,
    kCFURLEnumeratorDirectoryPostOrderSuccess = 4
}
export declare enum CFURLPathStyle {
    kCFURLPOSIXPathStyle = 0,
    kCFURLHFSPathStyle = 1,
    kCFURLWindowsPathStyle = 2
}
export declare enum CFXMLEntityTypeCode {
    kCFXMLEntityTypeParameter = 0,
    kCFXMLEntityTypeParsedInternal = 1,
    kCFXMLEntityTypeParsedExternal = 2,
    kCFXMLEntityTypeUnparsed = 3,
    kCFXMLEntityTypeCharacter = 4
}
export declare enum CFXMLNodeTypeCode {
    kCFXMLNodeTypeDocument = 1,
    kCFXMLNodeTypeElement = 2,
    kCFXMLNodeTypeAttribute = 3,
    kCFXMLNodeTypeProcessingInstruction = 4,
    kCFXMLNodeTypeComment = 5,
    kCFXMLNodeTypeText = 6,
    kCFXMLNodeTypeCDATASection = 7,
    kCFXMLNodeTypeDocumentFragment = 8,
    kCFXMLNodeTypeEntity = 9,
    kCFXMLNodeTypeEntityReference = 10,
    kCFXMLNodeTypeDocumentType = 11,
    kCFXMLNodeTypeWhitespace = 12,
    kCFXMLNodeTypeNotation = 13,
    kCFXMLNodeTypeElementTypeDeclaration = 14,
    kCFXMLNodeTypeAttributeListDeclaration = 15
}
export declare enum CFXMLParserOptions {
    kCFXMLParserValidateDocument = 1,
    kCFXMLParserSkipMetaData = 2,
    kCFXMLParserReplacePhysicalEntities = 4,
    kCFXMLParserSkipWhitespace = 8,
    kCFXMLParserResolveExternalEntities = 16,
    kCFXMLParserAddImpliedAttributes = 32,
    kCFXMLParserAllOptions = 16777215,
    kCFXMLParserNoOptions = 0
}
export declare enum CFXMLParserStatusCode {
    kCFXMLStatusParseNotBegun = -2,
    kCFXMLStatusParseInProgress = -1,
    kCFXMLStatusParseSuccessful = 0,
    kCFXMLErrorUnexpectedEOF = 1,
    kCFXMLErrorUnknownEncoding = 2,
    kCFXMLErrorEncodingConversionFailure = 3,
    kCFXMLErrorMalformedProcessingInstruction = 4,
    kCFXMLErrorMalformedDTD = 5,
    kCFXMLErrorMalformedName = 6,
    kCFXMLErrorMalformedCDSect = 7,
    kCFXMLErrorMalformedCloseTag = 8,
    kCFXMLErrorMalformedStartTag = 9,
    kCFXMLErrorMalformedDocument = 10,
    kCFXMLErrorElementlessDocument = 11,
    kCFXMLErrorMalformedComment = 12,
    kCFXMLErrorMalformedCharacterReference = 13,
    kCFXMLErrorMalformedParsedCharacterData = 14,
    kCFXMLErrorNoData = 15
}
export declare enum __CFByteOrder {
    CFByteOrderUnknown = 0,
    CFByteOrderLittleEndian = 1,
    CFByteOrderBigEndian = 2
}
export declare enum CGBitmapInfo {
    kCGBitmapAlphaInfoMask = 31,
    kCGBitmapFloatInfoMask = 3840,
    kCGBitmapFloatComponents = 256,
    kCGBitmapByteOrderMask = 28672,
    kCGBitmapByteOrderDefault = 0,
    kCGBitmapByteOrder16Little = 4096,
    kCGBitmapByteOrder32Little = 8192,
    kCGBitmapByteOrder16Big = 12288,
    kCGBitmapByteOrder32Big = 16384
}
export declare enum CGBlendMode {
    kCGBlendModeNormal = 0,
    kCGBlendModeMultiply = 1,
    kCGBlendModeScreen = 2,
    kCGBlendModeOverlay = 3,
    kCGBlendModeDarken = 4,
    kCGBlendModeLighten = 5,
    kCGBlendModeColorDodge = 6,
    kCGBlendModeColorBurn = 7,
    kCGBlendModeSoftLight = 8,
    kCGBlendModeHardLight = 9,
    kCGBlendModeDifference = 10,
    kCGBlendModeExclusion = 11,
    kCGBlendModeHue = 12,
    kCGBlendModeSaturation = 13,
    kCGBlendModeColor = 14,
    kCGBlendModeLuminosity = 15,
    kCGBlendModeClear = 16,
    kCGBlendModeCopy = 17,
    kCGBlendModeSourceIn = 18,
    kCGBlendModeSourceOut = 19,
    kCGBlendModeSourceAtop = 20,
    kCGBlendModeDestinationOver = 21,
    kCGBlendModeDestinationIn = 22,
    kCGBlendModeDestinationOut = 23,
    kCGBlendModeDestinationAtop = 24,
    kCGBlendModeXOR = 25,
    kCGBlendModePlusDarker = 26,
    kCGBlendModePlusLighter = 27
}
export declare enum CGCaptureOptions {
    kCGCaptureNoOptions = 0,
    kCGCaptureNoFill = 1
}
export declare enum CGColorConversionInfoTransformType {
    kCGColorConversionTransformFromSpace = 0,
    kCGColorConversionTransformToSpace = 1,
    kCGColorConversionTransformApplySpace = 2
}
export declare enum CGColorRenderingIntent {
    kCGRenderingIntentDefault = 0,
    kCGRenderingIntentAbsoluteColorimetric = 1,
    kCGRenderingIntentRelativeColorimetric = 2,
    kCGRenderingIntentPerceptual = 3,
    kCGRenderingIntentSaturation = 4
}
export declare enum CGColorSpaceModel {
    kCGColorSpaceModelUnknown = -1,
    kCGColorSpaceModelMonochrome = 0,
    kCGColorSpaceModelRGB = 1,
    kCGColorSpaceModelCMYK = 2,
    kCGColorSpaceModelLab = 3,
    kCGColorSpaceModelDeviceN = 4,
    kCGColorSpaceModelIndexed = 5,
    kCGColorSpaceModelPattern = 6,
    kCGColorSpaceModelXYZ = 7
}
export declare enum CGConfigureOption {
    kCGConfigureForAppOnly = 0,
    kCGConfigureForSession = 1,
    kCGConfigurePermanently = 2
}
export declare enum CGDisplayChangeSummaryFlags {
    kCGDisplayBeginConfigurationFlag = 1,
    kCGDisplayMovedFlag = 2,
    kCGDisplaySetMainFlag = 4,
    kCGDisplaySetModeFlag = 8,
    kCGDisplayAddFlag = 16,
    kCGDisplayRemoveFlag = 32,
    kCGDisplayEnabledFlag = 256,
    kCGDisplayDisabledFlag = 512,
    kCGDisplayMirrorFlag = 1024,
    kCGDisplayUnMirrorFlag = 2048,
    kCGDisplayDesktopShapeChangedFlag = 4096
}
export declare enum CGDisplayStreamFrameStatus {
    kCGDisplayStreamFrameStatusFrameComplete = 0,
    kCGDisplayStreamFrameStatusFrameIdle = 1,
    kCGDisplayStreamFrameStatusFrameBlank = 2,
    kCGDisplayStreamFrameStatusStopped = 3
}
export declare enum CGDisplayStreamUpdateRectType {
    kCGDisplayStreamUpdateRefreshedRects = 0,
    kCGDisplayStreamUpdateMovedRects = 1,
    kCGDisplayStreamUpdateDirtyRects = 2,
    kCGDisplayStreamUpdateReducedDirtyRects = 3
}
export declare enum CGError {
    kCGErrorSuccess = 0,
    kCGErrorFailure = 1000,
    kCGErrorIllegalArgument = 1001,
    kCGErrorInvalidConnection = 1002,
    kCGErrorInvalidContext = 1003,
    kCGErrorCannotComplete = 1004,
    kCGErrorNotImplemented = 1006,
    kCGErrorRangeCheck = 1007,
    kCGErrorTypeCheck = 1008,
    kCGErrorInvalidOperation = 1010,
    kCGErrorNoneAvailable = 1011
}
export declare enum CGEventField {
    kCGMouseEventNumber = 0,
    kCGMouseEventClickState = 1,
    kCGMouseEventPressure = 2,
    kCGMouseEventButtonNumber = 3,
    kCGMouseEventDeltaX = 4,
    kCGMouseEventDeltaY = 5,
    kCGMouseEventInstantMouser = 6,
    kCGMouseEventSubtype = 7,
    kCGKeyboardEventAutorepeat = 8,
    kCGKeyboardEventKeycode = 9,
    kCGKeyboardEventKeyboardType = 10,
    kCGScrollWheelEventDeltaAxis1 = 11,
    kCGScrollWheelEventDeltaAxis2 = 12,
    kCGScrollWheelEventDeltaAxis3 = 13,
    kCGScrollWheelEventFixedPtDeltaAxis1 = 93,
    kCGScrollWheelEventFixedPtDeltaAxis2 = 94,
    kCGScrollWheelEventFixedPtDeltaAxis3 = 95,
    kCGScrollWheelEventPointDeltaAxis1 = 96,
    kCGScrollWheelEventPointDeltaAxis2 = 97,
    kCGScrollWheelEventPointDeltaAxis3 = 98,
    kCGScrollWheelEventScrollPhase = 99,
    kCGScrollWheelEventScrollCount = 100,
    kCGScrollWheelEventMomentumPhase = 123,
    kCGScrollWheelEventInstantMouser = 14,
    kCGTabletEventPointX = 15,
    kCGTabletEventPointY = 16,
    kCGTabletEventPointZ = 17,
    kCGTabletEventPointButtons = 18,
    kCGTabletEventPointPressure = 19,
    kCGTabletEventTiltX = 20,
    kCGTabletEventTiltY = 21,
    kCGTabletEventRotation = 22,
    kCGTabletEventTangentialPressure = 23,
    kCGTabletEventDeviceID = 24,
    kCGTabletEventVendor1 = 25,
    kCGTabletEventVendor2 = 26,
    kCGTabletEventVendor3 = 27,
    kCGTabletProximityEventVendorID = 28,
    kCGTabletProximityEventTabletID = 29,
    kCGTabletProximityEventPointerID = 30,
    kCGTabletProximityEventDeviceID = 31,
    kCGTabletProximityEventSystemTabletID = 32,
    kCGTabletProximityEventVendorPointerType = 33,
    kCGTabletProximityEventVendorPointerSerialNumber = 34,
    kCGTabletProximityEventVendorUniqueID = 35,
    kCGTabletProximityEventCapabilityMask = 36,
    kCGTabletProximityEventPointerType = 37,
    kCGTabletProximityEventEnterProximity = 38,
    kCGEventTargetProcessSerialNumber = 39,
    kCGEventTargetUnixProcessID = 40,
    kCGEventSourceUnixProcessID = 41,
    kCGEventSourceUserData = 42,
    kCGEventSourceUserID = 43,
    kCGEventSourceGroupID = 44,
    kCGEventSourceStateID = 45,
    kCGScrollWheelEventIsContinuous = 88,
    kCGMouseEventWindowUnderMousePointer = 91,
    kCGMouseEventWindowUnderMousePointerThatCanHandleThisEvent = 92,
    kCGEventUnacceleratedPointerMovementX = 170,
    kCGEventUnacceleratedPointerMovementY = 171
}
export declare enum CGEventFilterMask {
    kCGEventFilterMaskPermitLocalMouseEvents = 1,
    kCGEventFilterMaskPermitLocalKeyboardEvents = 2,
    kCGEventFilterMaskPermitSystemDefinedEvents = 4
}
export declare enum CGEventFlags {
    kCGEventFlagMaskAlphaShift = 65536,
    kCGEventFlagMaskShift = 131072,
    kCGEventFlagMaskControl = 262144,
    kCGEventFlagMaskAlternate = 524288,
    kCGEventFlagMaskCommand = 1048576,
    kCGEventFlagMaskHelp = 4194304,
    kCGEventFlagMaskSecondaryFn = 8388608,
    kCGEventFlagMaskNumericPad = 2097152,
    kCGEventFlagMaskNonCoalesced = 256
}
export declare enum CGEventMouseSubtype {
    kCGEventMouseSubtypeDefault = 0,
    kCGEventMouseSubtypeTabletPoint = 1,
    kCGEventMouseSubtypeTabletProximity = 2
}
export declare enum CGEventSourceStateID {
    kCGEventSourceStatePrivate = -1,
    kCGEventSourceStateCombinedSessionState = 0,
    kCGEventSourceStateHIDSystemState = 1
}
export declare enum CGEventSuppressionState {
    kCGEventSuppressionStateSuppressionInterval = 0,
    kCGEventSuppressionStateRemoteMouseDrag = 1,
    kCGNumberOfEventSuppressionStates = 2
}
export declare enum CGEventTapLocation {
    kCGHIDEventTap = 0,
    kCGSessionEventTap = 1,
    kCGAnnotatedSessionEventTap = 2
}
export declare enum CGEventTapOptions {
    kCGEventTapOptionDefault = 0,
    kCGEventTapOptionListenOnly = 1
}
export declare enum CGEventTapPlacement {
    kCGHeadInsertEventTap = 0,
    kCGTailAppendEventTap = 1
}
export declare enum CGEventType {
    kCGEventNull = 0,
    kCGEventLeftMouseDown = 1,
    kCGEventLeftMouseUp = 2,
    kCGEventRightMouseDown = 3,
    kCGEventRightMouseUp = 4,
    kCGEventMouseMoved = 5,
    kCGEventLeftMouseDragged = 6,
    kCGEventRightMouseDragged = 7,
    kCGEventKeyDown = 10,
    kCGEventKeyUp = 11,
    kCGEventFlagsChanged = 12,
    kCGEventScrollWheel = 22,
    kCGEventTabletPointer = 23,
    kCGEventTabletProximity = 24,
    kCGEventOtherMouseDown = 25,
    kCGEventOtherMouseUp = 26,
    kCGEventOtherMouseDragged = 27,
    kCGEventTapDisabledByTimeout = 4294967294,
    kCGEventTapDisabledByUserInput = 4294967295
}
export declare enum CGFontPostScriptFormat {
    kCGFontPostScriptFormatType1 = 1,
    kCGFontPostScriptFormatType3 = 3,
    kCGFontPostScriptFormatType42 = 42
}
export declare enum CGGesturePhase {
    kCGGesturePhaseNone = 0,
    kCGGesturePhaseBegan = 1,
    kCGGesturePhaseChanged = 2,
    kCGGesturePhaseEnded = 4,
    kCGGesturePhaseCancelled = 8,
    kCGGesturePhaseMayBegin = 128
}
export declare enum CGGlyphDeprecatedEnum {
    Min = 0,
    Max = 1
}
export declare enum CGGradientDrawingOptions {
    kCGGradientDrawsBeforeStartLocation = 1,
    kCGGradientDrawsAfterEndLocation = 2
}
export declare enum CGImageAlphaInfo {
    kCGImageAlphaNone = 0,
    kCGImageAlphaPremultipliedLast = 1,
    kCGImageAlphaPremultipliedFirst = 2,
    kCGImageAlphaLast = 3,
    kCGImageAlphaFirst = 4,
    kCGImageAlphaNoneSkipLast = 5,
    kCGImageAlphaNoneSkipFirst = 6,
    kCGImageAlphaOnly = 7
}
export declare enum CGImageByteOrderInfo {
    kCGImageByteOrderMask = 28672,
    kCGImageByteOrderDefault = 0,
    kCGImageByteOrder16Little = 4096,
    kCGImageByteOrder32Little = 8192,
    kCGImageByteOrder16Big = 12288,
    kCGImageByteOrder32Big = 16384
}
export declare enum CGImagePixelFormatInfo {
    kCGImagePixelFormatMask = 983040,
    kCGImagePixelFormatPacked = 0,
    kCGImagePixelFormatRGB555 = 65536,
    kCGImagePixelFormatRGB565 = 131072,
    kCGImagePixelFormatRGB101010 = 196608,
    kCGImagePixelFormatRGBCIF10 = 262144
}
export declare enum CGInterpolationQuality {
    kCGInterpolationDefault = 0,
    kCGInterpolationNone = 1,
    kCGInterpolationLow = 2,
    kCGInterpolationMedium = 4,
    kCGInterpolationHigh = 3
}
export declare enum CGLineCap {
    kCGLineCapButt = 0,
    kCGLineCapRound = 1,
    kCGLineCapSquare = 2
}
export declare enum CGLineJoin {
    kCGLineJoinMiter = 0,
    kCGLineJoinRound = 1,
    kCGLineJoinBevel = 2
}
export declare enum CGMomentumScrollPhase {
    kCGMomentumScrollPhaseNone = 0,
    kCGMomentumScrollPhaseBegin = 1,
    kCGMomentumScrollPhaseContinue = 2,
    kCGMomentumScrollPhaseEnd = 3
}
export declare enum CGMouseButton {
    kCGMouseButtonLeft = 0,
    kCGMouseButtonRight = 1,
    kCGMouseButtonCenter = 2
}
export declare enum CGPDFAccessPermissions {
    kCGPDFAllowsLowQualityPrinting = 1,
    kCGPDFAllowsHighQualityPrinting = 2,
    kCGPDFAllowsDocumentChanges = 4,
    kCGPDFAllowsDocumentAssembly = 8,
    kCGPDFAllowsContentCopying = 16,
    kCGPDFAllowsContentAccessibility = 32,
    kCGPDFAllowsCommenting = 64,
    kCGPDFAllowsFormFieldEntry = 128
}
export declare enum CGPDFBox {
    kCGPDFMediaBox = 0,
    kCGPDFCropBox = 1,
    kCGPDFBleedBox = 2,
    kCGPDFTrimBox = 3,
    kCGPDFArtBox = 4
}
export declare enum CGPDFDataFormat {
    Raw = 0,
    JPEGEncoded = 1,
    JPEG2000 = 2
}
export declare enum CGPDFObjectType {
    kCGPDFObjectTypeNull = 1,
    kCGPDFObjectTypeBoolean = 2,
    kCGPDFObjectTypeInteger = 3,
    kCGPDFObjectTypeReal = 4,
    kCGPDFObjectTypeName = 5,
    kCGPDFObjectTypeString = 6,
    kCGPDFObjectTypeArray = 7,
    kCGPDFObjectTypeDictionary = 8,
    kCGPDFObjectTypeStream = 9
}
export declare enum CGPDFTagType {
    Document = 100,
    Part = 101,
    Art = 102,
    Section = 103,
    Div = 104,
    BlockQuote = 105,
    Caption = 106,
    TOC = 107,
    TOCI = 108,
    Index = 109,
    NonStructure = 110,
    Private = 111,
    Paragraph = 200,
    Header = 201,
    Header1 = 202,
    Header2 = 203,
    Header3 = 204,
    Header4 = 205,
    Header5 = 206,
    Header6 = 207,
    List = 300,
    ListItem = 301,
    Label = 302,
    ListBody = 303,
    Table = 400,
    TableRow = 401,
    TableHeaderCell = 402,
    TableDataCell = 403,
    TableHeader = 404,
    TableBody = 405,
    TableFooter = 406,
    Span = 500,
    Quote = 501,
    Note = 502,
    Reference = 503,
    Bibliography = 504,
    Code = 505,
    Link = 506,
    Annotation = 507,
    Ruby = 600,
    RubyBaseText = 601,
    RubyAnnotationText = 602,
    RubyPunctuation = 603,
    Warichu = 604,
    WarichuText = 605,
    WarichuPunctiation = 606,
    Figure = 700,
    Formula = 701,
    Form = 702
}
export declare enum CGPathDrawingMode {
    kCGPathFill = 0,
    kCGPathEOFill = 1,
    kCGPathStroke = 2,
    kCGPathFillStroke = 3,
    kCGPathEOFillStroke = 4
}
export declare enum CGPathElementType {
    kCGPathElementMoveToPoint = 0,
    kCGPathElementAddLineToPoint = 1,
    kCGPathElementAddQuadCurveToPoint = 2,
    kCGPathElementAddCurveToPoint = 3,
    kCGPathElementCloseSubpath = 4
}
export declare enum CGPatternTiling {
    kCGPatternTilingNoDistortion = 0,
    kCGPatternTilingConstantSpacingMinimalDistortion = 1,
    kCGPatternTilingConstantSpacing = 2
}
export declare enum CGRectEdge {
    MinXEdge = 0,
    MinYEdge = 1,
    MaxXEdge = 2,
    MaxYEdge = 3
}
export declare enum CGScreenUpdateOperation {
    kCGScreenUpdateOperationRefresh = 0,
    kCGScreenUpdateOperationMove = 1,
    kCGScreenUpdateOperationReducedDirtyRectangleCount = 2147483648
}
export declare enum CGScrollEventUnit {
    kCGScrollEventUnitPixel = 0,
    kCGScrollEventUnitLine = 1
}
export declare enum CGScrollPhase {
    kCGScrollPhaseBegan = 1,
    kCGScrollPhaseChanged = 2,
    kCGScrollPhaseEnded = 4,
    kCGScrollPhaseCancelled = 8,
    kCGScrollPhaseMayBegin = 128
}
export declare enum CGTextDrawingMode {
    kCGTextFill = 0,
    kCGTextStroke = 1,
    kCGTextFillStroke = 2,
    kCGTextInvisible = 3,
    kCGTextFillClip = 4,
    kCGTextStrokeClip = 5,
    kCGTextFillStrokeClip = 6,
    kCGTextClip = 7
}
export declare enum CGWindowBackingType {
    kCGBackingStoreRetained = 0,
    kCGBackingStoreNonretained = 1,
    kCGBackingStoreBuffered = 2
}
export declare enum CGWindowImageOption {
    kCGWindowImageDefault = 0,
    kCGWindowImageBoundsIgnoreFraming = 1,
    kCGWindowImageShouldBeOpaque = 2,
    kCGWindowImageOnlyShadows = 4,
    kCGWindowImageBestResolution = 8,
    kCGWindowImageNominalResolution = 16
}
export declare enum CGWindowLevelKey {
    kCGBaseWindowLevelKey = 0,
    kCGMinimumWindowLevelKey = 1,
    kCGDesktopWindowLevelKey = 2,
    kCGBackstopMenuLevelKey = 3,
    kCGNormalWindowLevelKey = 4,
    kCGFloatingWindowLevelKey = 5,
    kCGTornOffMenuWindowLevelKey = 6,
    kCGDockWindowLevelKey = 7,
    kCGMainMenuWindowLevelKey = 8,
    kCGStatusWindowLevelKey = 9,
    kCGModalPanelWindowLevelKey = 10,
    kCGPopUpMenuWindowLevelKey = 11,
    kCGDraggingWindowLevelKey = 12,
    kCGScreenSaverWindowLevelKey = 13,
    kCGMaximumWindowLevelKey = 14,
    kCGOverlayWindowLevelKey = 15,
    kCGHelpWindowLevelKey = 16,
    kCGUtilityWindowLevelKey = 17,
    kCGDesktopIconWindowLevelKey = 18,
    kCGCursorWindowLevelKey = 19,
    kCGAssistiveTechHighWindowLevelKey = 20,
    kCGNumberOfWindowLevelKeys = 21
}
export declare enum CGWindowListOption {
    kCGWindowListOptionAll = 0,
    kCGWindowListOptionOnScreenOnly = 1,
    kCGWindowListOptionOnScreenAboveWindow = 2,
    kCGWindowListOptionOnScreenBelowWindow = 4,
    kCGWindowListOptionIncludingWindow = 8,
    kCGWindowListExcludeDesktopElements = 16
}
export declare enum CGWindowSharingType {
    kCGWindowSharingNone = 0,
    kCGWindowSharingReadOnly = 1,
    kCGWindowSharingReadWrite = 2
}
export declare enum CIDataMatrixCodeECCVersion {
    Version000 = 0,
    Version050 = 50,
    Version080 = 80,
    Version100 = 100,
    Version140 = 140,
    Version200 = 200
}
export declare enum CIQRCodeErrorCorrectionLevel {
    L = 76,
    M = 77,
    Q = 81,
    H = 72
}
export declare enum CIRenderDestinationAlphaMode {
    None = 0,
    Premultiplied = 1,
    Unpremultiplied = 2
}
export declare enum CMTimeFlags {
    kCMTimeFlags_Valid = 1,
    kCMTimeFlags_HasBeenRounded = 2,
    kCMTimeFlags_PositiveInfinity = 4,
    kCMTimeFlags_NegativeInfinity = 8,
    kCMTimeFlags_Indefinite = 16,
    kCMTimeFlags_ImpliedValueFlagsMask = 28
}
export declare enum CMTimeRoundingMethod {
    kCMTimeRoundingMethod_RoundHalfAwayFromZero = 1,
    kCMTimeRoundingMethod_RoundTowardZero = 2,
    kCMTimeRoundingMethod_RoundAwayFromZero = 3,
    kCMTimeRoundingMethod_QuickTime = 4,
    kCMTimeRoundingMethod_RoundTowardPositiveInfinity = 5,
    kCMTimeRoundingMethod_RoundTowardNegativeInfinity = 6,
    kCMTimeRoundingMethod_Default = 1
}
export declare enum AlignmentOptions {
    MinXInward = 1,
    MinYInward = 2,
    MaxXInward = 4,
    MaxYInward = 8,
    WidthInward = 16,
    HeightInward = 32,
    MinXOutward = 256,
    MinYOutward = 512,
    MaxXOutward = 1024,
    MaxYOutward = 2048,
    WidthOutward = 4096,
    HeightOutward = 8192,
    MinXNearest = 65536,
    MinYNearest = 131072,
    MaxXNearest = 262144,
    MaxYNearest = 524288,
    WidthNearest = 1048576,
    HeightNearest = 2097152,
    RectFlipped = -9223372036854776000,
    AllEdgesInward = 15,
    AllEdgesOutward = 3840,
    AllEdgesNearest = 983040
}
export declare enum NSBinarySearchingOptions {
    FirstEqual = 256,
    LastEqual = 512,
    InsertionIndex = 1024
}
export declare enum NSCollectionChangeType {
    Insert = 0,
    Remove = 1
}
export declare enum ComparisonResult {
    OrderedAscending = -1,
    OrderedSame = 0,
    OrderedDescending = 1
}
export declare enum NSEnumerationOptions {
    Concurrent = 1,
    Reverse = 2
}
export declare enum NSItemProviderFileOptions {
    OpenInPlace = 1
}
export declare enum NSItemProviderRepresentationVisibility {
    All = 0,
    Team = 1,
    Group = 2,
    OwnProcess = 3
}
export declare enum NSKeyValueChange {
    Setting = 1,
    Insertion = 2,
    Removal = 3,
    Replacement = 4
}
export declare enum NSKeyValueObservingOptions {
    New = 1,
    Old = 2,
    Initial = 4,
    Prior = 8
}
export declare enum NSKeyValueSetMutationKind {
    UnionSetMutation = 1,
    MinusSetMutation = 2,
    IntersectSetMutation = 3,
    SetSetMutation = 4
}
export declare enum NSLinguisticTaggerUnit {
    Word = 0,
    Sentence = 1,
    Paragraph = 2,
    Document = 3
}
export declare enum NSOrderedCollectionDifferenceCalculationOptions {
    OmitInsertedObjects = 1,
    OmitRemovedObjects = 2,
    InferMoves = 4
}
export declare enum QualityOfService {
    UserInteractive = 33,
    UserInitiated = 25,
    Utility = 17,
    Background = 9,
    Default = -1
}
export declare enum NSRectEdge {
    RectEdgeMinX = 0,
    RectEdgeMinY = 1,
    RectEdgeMaxX = 2,
    RectEdgeMaxY = 3,
    MinXEdge = 0,
    MinYEdge = 1,
    MaxXEdge = 2,
    MaxYEdge = 3
}
export declare enum NSSaveOptions {
    Yes = 0,
    No = 1,
    Ask = 2
}
export declare enum NSSortOptions {
    Concurrent = 1,
    Stable = 16
}
export declare enum NSURLErrorNetworkUnavailableReason {
    Cellular = 0,
    Expensive = 1,
    Constrained = 2
}
export declare enum NSURLSessionDelayedRequestDisposition {
    ContinueLoading = 0,
    UseNewRequest = 1,
    Cancel = 2
}
export declare enum NSURLSessionWebSocketMessageType {
    Data = 0,
    String = 1
}
export declare enum IKCameraDeviceViewDisplayMode {
    None = -1,
    Table = 0,
    Icon = 1
}
export declare enum IKCameraDeviceViewTransferMode {
    FileBased = 0,
    MemoryBased = 1
}
export declare enum IKDeviceBrowserViewDisplayMode {
    Table = 0,
    Outline = 1,
    Icon = 2
}
export declare enum IKImageBrowserCellState {
    StateNoImage = 0,
    StateInvalid = 1,
    StateReady = 2
}
export declare enum IKImageBrowserDropOperation {
    On = 0,
    Before = 1
}
export declare enum IKScannerDeviceViewDisplayMode {
    None = -1,
    Simple = 0,
    Advanced = 1
}
export declare enum IKScannerDeviceViewTransferMode {
    FileBased = 0,
    MemoryBased = 1
}
export declare enum QCPlugInExecutionMode {
    kQCPlugInExecutionModeProvider = 1,
    kQCPlugInExecutionModeProcessor = 2,
    kQCPlugInExecutionModeConsumer = 3
}
export declare enum QCPlugInTimeMode {
    kQCPlugInTimeModeNone = 0,
    kQCPlugInTimeModeIdle = 1,
    kQCPlugInTimeModeTimeBase = 2
}
export declare enum QLPreviewViewStyle {
    Normal = 0,
    Compact = 1
}
export declare enum CAAutoresizingMask {
    kCALayerNotSizable = 0,
    kCALayerMinXMargin = 1,
    kCALayerWidthSizable = 2,
    kCALayerMaxXMargin = 4,
    kCALayerMinYMargin = 8,
    kCALayerHeightSizable = 16,
    kCALayerMaxYMargin = 32
}
export declare enum CAConstraintAttribute {
    kCAConstraintMinX = 0,
    kCAConstraintMidX = 1,
    kCAConstraintMaxX = 2,
    kCAConstraintWidth = 3,
    kCAConstraintMinY = 4,
    kCAConstraintMidY = 5,
    kCAConstraintMaxY = 6,
    kCAConstraintHeight = 7
}
export declare enum CACornerMask {
    kCALayerMinXMinYCorner = 1,
    kCALayerMaxXMinYCorner = 2,
    kCALayerMinXMaxYCorner = 4,
    kCALayerMaxXMaxYCorner = 8
}
export declare enum CAEdgeAntialiasingMask {
    kCALayerLeftEdge = 1,
    kCALayerRightEdge = 2,
    kCALayerBottomEdge = 4,
    kCALayerTopEdge = 8
}
export { AVAsset, AVAssetCache, AVAssetExportSession, AVAssetImageGenerator, AVAssetReader, AVAssetReaderAudioMixOutput, AVAssetReaderOutput, AVAssetReaderOutputMetadataAdaptor, AVAssetReaderSampleReferenceOutput, AVAssetReaderTrackOutput, AVAssetReaderVideoCompositionOutput, AVAssetResourceLoader, AVAssetResourceLoaderDelegate, AVAssetResourceLoadingContentInformationRequest, AVAssetResourceLoadingDataRequest, AVAssetResourceLoadingRequest, AVAssetResourceLoadingRequestor, AVAssetResourceRenewalRequest, AVAssetTrack, AVAssetTrackGroup, AVAssetTrackSegment, AVAssetWriter, AVAssetWriterInput, AVAssetWriterInputGroup, AVAssetWriterInputMetadataAdaptor, AVAssetWriterInputPassDescription, AVAssetWriterInputPixelBufferAdaptor, AVAsynchronousCIImageFilteringRequest, AVAsynchronousKeyValueLoading, AVAsynchronousVideoCompositionRequest, AVAudio3DMixing, AVAudioBuffer, AVAudioChannelLayout, AVAudioCompressedBuffer, AVAudioConnectionPoint, AVAudioConverter, AVAudioEngine, AVAudioEnvironmentDistanceAttenuationParameters, AVAudioEnvironmentNode, AVAudioEnvironmentReverbParameters, AVAudioFile, AVAudioFormat, AVAudioIONode, AVAudioInputNode, AVAudioMix, AVAudioMixInputParameters, AVAudioMixerNode, AVAudioMixing, AVAudioMixingDestination, AVAudioNode, AVAudioOutputNode, AVAudioPCMBuffer, AVAudioPlayer, AVAudioPlayerDelegate, AVAudioPlayerNode, AVAudioRecorder, AVAudioRecorderDelegate, AVAudioSequencer, AVAudioSession, AVAudioSinkNode, AVAudioSourceNode, AVAudioStereoMixing, AVAudioTime, AVAudioTimePitchAlgorithm, AVAudioUnit, AVAudioUnitComponent, AVAudioUnitComponentManager, AVAudioUnitDelay, AVAudioUnitDistortion, AVAudioUnitEQ, AVAudioUnitEQFilterParameters, AVAudioUnitEffect, AVAudioUnitGenerator, AVAudioUnitMIDIInstrument, AVAudioUnitReverb, AVAudioUnitSampler, AVAudioUnitTimeEffect, AVAudioUnitTimePitch, AVAudioUnitVarispeed, AVCameraCalibrationData, AVCaptureAudioChannel, AVCaptureAudioDataOutput, AVCaptureAudioDataOutputSampleBufferDelegate, AVCaptureAudioFileOutput, AVCaptureAudioPreviewOutput, AVCaptureConnection, AVCaptureDevice, AVCaptureDeviceInput, AVCaptureFileOutput, AVCaptureFileOutputDelegate, AVCaptureFileOutputRecordingDelegate, AVCaptureInput, AVCaptureMovieFileOutput, AVCaptureOutput, AVCapturePhoto, AVCapturePhotoCaptureDelegate, AVCapturePhotoOutput, AVCapturePhotoSettings, AVCaptureResolvedPhotoSettings, AVCaptureScreenInput, AVCaptureSession, AVCaptureVideoDataOutput, AVCaptureVideoDataOutputSampleBufferDelegate, AVCaptureVideoPreviewLayer, AVCaptureView, AVCaptureViewDelegate, AVComposition, AVCompositionTrack, AVCompositionTrackFormatDescriptionReplacement, AVCompositionTrackSegment, AVContentKeyRecipient, AVContentKeyRequest, AVContentKeyResponse, AVContentKeySession, AVContentKeySessionDelegate, AVContentKeySessionServerPlaybackContextOption, AVContentKeySystem, AVDateRangeMetadataGroup, AVDepthData, AVFileType, AVFragmentMinding, AVFragmentedAsset, AVFragmentedAssetMinder, AVFragmentedAssetTrack, AVFragmentedMovie, AVFragmentedMovieMinder, AVFragmentedMovieTrack, AVFrameRateRange, AVLayerVideoGravity, AVMIDIPlayer, AVMediaCharacteristic, AVMediaDataStorage, AVMediaSelection, AVMediaSelectionGroup, AVMediaSelectionOption, AVMediaType, AVMetadataBodyObject, AVMetadataCatBodyObject, AVMetadataDogBodyObject, AVMetadataExtraAttributeKey, AVMetadataFaceObject, AVMetadataFormat, AVMetadataGroup, AVMetadataHumanBodyObject, AVMetadataIdentifier, AVMetadataItem, AVMetadataItemFilter, AVMetadataItemValueRequest, AVMetadataKey, AVMetadataKeySpace, AVMetadataMachineReadableCodeObject, AVMetadataObject, AVMetadataSalientObject, AVMovie, AVMovieTrack, AVMusicTrack, AVMutableAudioMix, AVMutableAudioMixInputParameters, AVMutableComposition, AVMutableCompositionTrack, AVMutableDateRangeMetadataGroup, AVMutableMediaSelection, AVMutableMetadataItem, AVMutableMovie, AVMutableMovieTrack, AVMutableTimedMetadataGroup, AVMutableVideoComposition, AVMutableVideoCompositionInstruction, AVMutableVideoCompositionLayerInstruction, AVOutputSettingsAssistant, AVOutputSettingsPreset, AVPersistableContentKeyRequest, AVPictureInPictureController, AVPictureInPictureControllerDelegate, AVPlayer, AVPlayerItem, AVPlayerItemAccessLog, AVPlayerItemAccessLogEvent, AVPlayerItemErrorLog, AVPlayerItemErrorLogEvent, AVPlayerItemLegibleOutput, AVPlayerItemLegibleOutputPushDelegate, AVPlayerItemMediaDataCollector, AVPlayerItemMetadataCollector, AVPlayerItemMetadataCollectorPushDelegate, AVPlayerItemMetadataOutput, AVPlayerItemMetadataOutputPushDelegate, AVPlayerItemOutput, AVPlayerItemOutputPullDelegate, AVPlayerItemOutputPushDelegate, AVPlayerItemTrack, AVPlayerItemVideoOutput, AVPlayerLayer, AVPlayerLooper, AVPlayerMediaSelectionCriteria, AVPlayerView, AVPlayerViewPictureInPictureDelegate, AVPortraitEffectsMatte, AVQueuePlayer, AVQueuedSampleBufferRendering, AVRouteDetector, AVRoutePickerView, AVRoutePickerViewDelegate, AVSampleBufferAudioRenderer, AVSampleBufferDisplayLayer, AVSampleBufferGenerator, AVSampleBufferRenderSynchronizer, AVSampleBufferRequest, AVSampleCursor, AVSemanticSegmentationMatte, AVSpeechSynthesisVoice, AVSpeechSynthesizer, AVSpeechSynthesizerDelegate, AVSpeechUtterance, AVSynchronizedLayer, AVTextStyleRule, AVTimedMetadataGroup, AVURLAsset, AVVideoApertureMode, AVVideoCodecType, AVVideoCompositing, AVVideoComposition, AVVideoCompositionCoreAnimationTool, AVVideoCompositionInstruction, AVVideoCompositionLayerInstruction, AVVideoCompositionRenderContext, AVVideoCompositionRenderHint, AVVideoCompositionValidationHandling, Authorization, BlockOperation, Bundle, ByteCountFormatter, CAAction, CAAnimation, CAAnimationCalculationMode, CAAnimationDelegate, CAAnimationGroup, CAAnimationRotationMode, CABasicAnimation, CAConstraint, CAConstraintLayoutManager, CAEDRMetadata, CAEmitterCell, CAEmitterLayer, CAEmitterLayerEmitterMode, CAEmitterLayerEmitterShape, CAEmitterLayerRenderMode, CAGradientLayer, CAGradientLayerType, CAKeyframeAnimation, CALayer, CALayerContentsFilter, CALayerContentsFormat, CALayerContentsGravity, CALayerCornerCurve, CALayerDelegate, CALayoutManager, CAMediaTiming, CAMediaTimingFillMode, CAMediaTimingFunction, CAMediaTimingFunctionName, CAMetalDrawable, CAMetalLayer, CAPropertyAnimation, CARemoteLayerClient, CARemoteLayerServer, CARenderer, CAReplicatorLayer, CAScrollLayer, CAScrollLayerScrollMode, CAShapeLayer, CAShapeLayerFillRule, CAShapeLayerLineCap, CAShapeLayerLineJoin, CASpringAnimation, CATextLayer, CATextLayerAlignmentMode, CATextLayerTruncationMode, CATiledLayer, CATransaction, CATransformLayer, CATransition, CATransitionSubtype, CATransitionType, CAValueFunction, CAValueFunctionName, CFCalendarIdentifier, CFDateFormatterKey, CFLocaleKey, CFNotificationName, CFNumberFormatterKey, CFRunLoopMode, CFStreamPropertyKey, CGAffineTransform, CGColor, CGColorSpace, CGDisplayStream, CGFont, CGPDFTagProperty, CGPoint, CGRect, CGSize, CIAccordionFoldTransition, CIAffineClamp, CIAffineTile, CIAttributedTextImageGenerator, CIAztecCodeDescriptor, CIAztecCodeGenerator, CIBarcodeDescriptor, CIBarcodeGenerator, CIBarsSwipeTransition, CIBicubicScaleTransform, CIBlendKernel, CIBlendWithMask, CIBloom, CIBokehBlur, CIBoxBlur, CICMYKHalftone, CICheckerboardGenerator, CICircularScreen, CICode128BarcodeGenerator, CIColor, CIColorClamp, CIColorControls, CIColorCrossPolynomial, CIColorCube, CIColorCubeWithColorSpace, CIColorCubesMixedWithMask, CIColorCurves, CIColorInvert, CIColorKernel, CIColorMap, CIColorMatrix, CIColorMonochrome, CIColorPolynomial, CIColorPosterize, CIComicEffect, CICompositeOperation, CIContext, CIContextOption, CIConvolution, CICopyMachineTransition, CICoreMLModel, CICrystallize, CIDataMatrixCodeDescriptor, CIDepthOfField, CIDepthToDisparity, CIDetector, CIDiscBlur, CIDisintegrateWithMaskTransition, CIDisparityToDepth, CIDissolveTransition, CIDither, CIDocumentEnhancer, CIDotScreen, CIEdgePreserveUpsample, CIEdgeWork, CIEdges, CIEightfoldReflectedTile, CIExposureAdjust, CIFaceFeature, CIFalseColor, CIFeature, CIFilter, CIFilterConstructor, CIFilterGenerator, CIFilterShape, CIFlashTransition, CIFormat, CIFourCoordinateGeometryFilter, CIFourfoldReflectedTile, CIFourfoldRotatedTile, CIFourfoldTranslatedTile, CIGaborGradients, CIGammaAdjust, CIGaussianBlur, CIGaussianGradient, CIGlideReflectedTile, CIGloom, CIHatchedScreen, CIHeightFieldFromMask, CIHexagonalPixellate, CIHighlightShadowAdjust, CIHueAdjust, CIHueSaturationValueGradient, CIImage, CIImageAccumulator, CIImageAutoAdjustmentOption, CIImageOption, CIImageProcessorInput, CIImageProcessorKernel, CIImageProcessorOutput, CIImageRepresentationOption, CIKaleidoscope, CIKernel, CIKeystoneCorrectionCombined, CIKeystoneCorrectionHorizontal, CIKeystoneCorrectionVertical, CILabDeltaE, CILanczosScaleTransform, CILenticularHaloGenerator, CILineOverlay, CILineScreen, CILinearGradient, CILinearToSRGBToneCurve, CIMaskToAlpha, CIMaskedVariableBlur, CIMaximumComponent, CIMedian, CIMeshGenerator, CIMinimumComponent, CIMix, CIModTransition, CIMorphologyGradient, CIMorphologyMaximum, CIMorphologyMinimum, CIMorphologyRectangleMaximum, CIMorphologyRectangleMinimum, CIMotionBlur, CINoiseReduction, CIOpTile, CIPDF417BarcodeGenerator, CIPDF417CodeDescriptor, CIPageCurlTransition, CIPageCurlWithShadowTransition, CIPaletteCentroid, CIPalettize, CIParallelogramTile, CIPerspectiveCorrection, CIPerspectiveRotate, CIPerspectiveTile, CIPerspectiveTransform, CIPerspectiveTransformWithExtent, CIPhotoEffect, CIPixellate, CIPlugIn, CIPlugInRegistration, CIPointillize, CIQRCodeDescriptor, CIQRCodeFeature, CIQRCodeGenerator, CIRAWFilterOption, CIRadialGradient, CIRandomGenerator, CIRectangleFeature, CIRenderDestination, CIRenderInfo, CIRenderTask, CIRippleTransition, CIRoundedRectangleGenerator, CISRGBToneCurveToLinear, CISaliencyMap, CISampler, CISepiaTone, CIShadedMaterial, CISharpenLuminance, CISixfoldReflectedTile, CISixfoldRotatedTile, CISmoothLinearGradient, CISpotColor, CISpotLight, CIStarShineGenerator, CIStraighten, CIStripesGenerator, CISunbeamsGenerator, CISwipeTransition, CITemperatureAndTint, CITextFeature, CITextImageGenerator, CIThermal, CIToneCurve, CITransitionFilter, CITriangleKaleidoscope, CITriangleTile, CITwelvefoldReflectedTile, CIUnsharpMask, CIVector, CIVibrance, CIVignette, CIVignetteEffect, CIWarpKernel, CIWhitePointAdjust, CIXRay, CIZoomBlur, CMImageDescriptionFlavor, CMSampleTimingInfo, CMSoundDescriptionFlavor, CMTime, CMTimeMapping, CMTimeRange, CachedURLResponse, DateComponentsFormatter, DateFormatter, DateIntervalFormatter, Decimal, Dimension, DirectoryEnumerator, DiscoverySession, DistributedNotificationCenter, EnergyFormatter, FileAttributeKey, FileAttributeType, FileHandle, FileManager, FileManagerDelegate, FileProtectionType, FileWrapper, Format, Formatter, HTTPCookie, HTTPCookiePropertyKey, HTTPCookieStorage, HTTPCookieStringPolicy, HTTPURLResponse, Host, IKCameraDeviceView, IKCameraDeviceViewDelegate, IKDeviceBrowserView, IKDeviceBrowserViewDelegate, IKFilterBrowserPanel, IKFilterBrowserView, IKFilterCustomUIProvider, IKFilterUIView, IKImageBrowserCell, IKImageEditPanel, IKImageEditPanelDataSource, IKImageView, IKPictureTaker, IKSaveOptions, IKScannerDeviceView, IKScannerDeviceViewDelegate, IKSlideshow, IKSlideshowDataSource, ISO8601DateFormatter, InputSource, InputStream, ItemResult, JSONSerialization, LengthFormatter, ListFormatter, MassFormatter, MeasurementFormatter, MessagePort, NSATSTypesetter, NSAccessibility, NSAccessibilityButton, NSAccessibilityCheckBox, NSAccessibilityContainsTransientUI, NSAccessibilityCustomAction, NSAccessibilityCustomRotor, NSAccessibilityCustomRotorItemSearchDelegate, NSAccessibilityElement, NSAccessibilityElementLoading, NSAccessibilityGroup, NSAccessibilityImage, NSAccessibilityLayoutArea, NSAccessibilityLayoutItem, NSAccessibilityList, NSAccessibilityNavigableStaticText, NSAccessibilityOutline, NSAccessibilityProgressIndicator, NSAccessibilityRadioButton, NSAccessibilityRow, NSAccessibilitySlider, NSAccessibilityStaticText, NSAccessibilityStepper, NSAccessibilitySwitch, NSAccessibilityTable, NSActionCell, NSAffineTransform, NSAlert, NSAlertDelegate, NSAlignmentFeedbackFilter, NSAlignmentFeedbackToken, NSAnimatablePropertyContainer, NSAnimation, NSAnimationContext, NSAnimationDelegate, NSAppKitVersion, NSAppearance, NSAppearanceCustomization, NSAppleEventDescriptor, NSAppleEventManager, NSAppleScript, NSApplication, NSApplicationDelegate, NSArray, NSArrayController, NSAssertionHandler, NSAsynchronousFetchRequest, NSAsynchronousFetchResult, NSAtomicStore, NSAtomicStoreCacheNode, NSAttributeDescription, NSAttributedString, NSAutoreleasePool, NSBackgroundActivityScheduler, NSBatchDeleteRequest, NSBatchDeleteResult, NSBatchInsertRequest, NSBatchInsertResult, NSBatchUpdateRequest, NSBatchUpdateResult, NSBezierPath, NSBindingInfoKey, NSBindingName, NSBindingOption, NSBindingSelectionMarker, NSBitmapImageRep, NSBox, NSBrowser, NSBrowserCell, NSBrowserDelegate, NSButton, NSButtonCell, NSButtonTouchBarItem, NSCIImageRep, NSCache, NSCacheDelegate, NSCalendar, NSCandidateListTouchBarItem, NSCandidateListTouchBarItemDelegate, NSCell, NSChangeSpelling, NSCharacterSet, NSClassDescription, NSClickGestureRecognizer, NSClipView, NSCloneCommand, NSCloseCommand, NSCloudSharingServiceDelegate, NSCloudSharingValidation, NSCoder, NSCoding, NSCollectionLayoutAnchor, NSCollectionLayoutBoundarySupplementaryItem, NSCollectionLayoutContainer, NSCollectionLayoutDecorationItem, NSCollectionLayoutDimension, NSCollectionLayoutEdgeSpacing, NSCollectionLayoutEnvironment, NSCollectionLayoutGroup, NSCollectionLayoutGroupCustomItem, NSCollectionLayoutItem, NSCollectionLayoutSection, NSCollectionLayoutSize, NSCollectionLayoutSpacing, NSCollectionLayoutSupplementaryItem, NSCollectionLayoutVisibleItem, NSCollectionView, NSCollectionViewCompositionalLayout, NSCollectionViewCompositionalLayoutConfiguration, NSCollectionViewDataSource, NSCollectionViewDelegate, NSCollectionViewDelegateFlowLayout, NSCollectionViewDiffableDataSourceReference, NSCollectionViewElement, NSCollectionViewFlowLayout, NSCollectionViewFlowLayoutInvalidationContext, NSCollectionViewGridLayout, NSCollectionViewItem, NSCollectionViewLayout, NSCollectionViewLayoutAttributes, NSCollectionViewLayoutInvalidationContext, NSCollectionViewPrefetching, NSCollectionViewSectionHeaderView, NSCollectionViewTransitionLayout, NSCollectionViewUpdateItem, NSColor, NSColorChanging, NSColorList, NSColorPanel, NSColorPicker, NSColorPickerTouchBarItem, NSColorPickingCustom, NSColorPickingDefault, NSColorSampler, NSColorSpace, NSColorSpaceName, NSColorWell, NSComboBox, NSComboBoxCell, NSComboBoxCellDataSource, NSComboBoxDataSource, NSComboBoxDelegate, NSComparisonPredicate, NSCompoundPredicate, NSCondition, NSConditionLock, NSConstraintConflict, NSControl, NSControlTextEditingDelegate, NSController, NSCopying, NSCoreDataCoreSpotlightDelegate, NSCountCommand, NSCountedSet, NSCreateCommand, NSCursor, NSCustomImageRep, NSCustomTouchBarItem, NSData, NSDataAsset, NSDataDetector, NSDate, NSDateComponents, NSDateInterval, NSDatePicker, NSDatePickerCell, NSDatePickerCellDelegate, NSDecimalNumber, NSDecimalNumberBehaviors, NSDecimalNumberHandler, NSDeleteCommand, NSDerivedAttributeDescription, NSDeviceDescriptionKey, NSDictionary, NSDictionaryController, NSDictionaryControllerKeyValuePair, NSDiffableDataSourceSnapshotReference, NSDiscardableContent, NSDistributedLock, NSDockTile, NSDockTilePlugIn, NSDocument, NSDocumentController, NSDraggingDestination, NSDraggingImageComponent, NSDraggingInfo, NSDraggingItem, NSDraggingSession, NSDraggingSource, NSDrawer, NSDrawerDelegate, NSEPSImageRep, NSEditor, NSEditorRegistration, NSEntityDescription, NSEntityMapping, NSEntityMigrationPolicy, NSEnumerator, NSError, NSEvent, NSException, NSExceptionName, NSExistsCommand, NSExpression, NSExpressionDescription, NSExtensionContext, NSExtensionItem, NSExtensionRequestHandling, NSFastEnumeration, NSFetchIndexDescription, NSFetchIndexElementDescription, NSFetchRequest, NSFetchRequestExpression, NSFetchRequestResult, NSFetchedPropertyDescription, NSFetchedResultsController, NSFetchedResultsControllerDelegate, NSFetchedResultsSectionInfo, NSFileAccessIntent, NSFileCoordinator, NSFilePresenter, NSFilePromiseProvider, NSFilePromiseProviderDelegate, NSFilePromiseReceiver, NSFileProviderService, NSFileSecurity, NSFileVersion, NSFont, NSFontAssetRequest, NSFontChanging, NSFontCollection, NSFontDescriptor, NSFontManager, NSFontPanel, NSFormCell, NSGestureRecognizer, NSGestureRecognizerDelegate, NSGetCommand, NSGlyphGenerator, NSGlyphInfo, NSGlyphStorage, NSGradient, NSGraphicsContext, NSGridCell, NSGridColumn, NSGridRow, NSGridView, NSGroupTouchBarItem, NSHapticFeedbackManager, NSHapticFeedbackPerformer, NSHashTable, NSHelpManager, NSIgnoreMisspelledWords, NSImage, NSImageCell, NSImageDelegate, NSImageRep, NSImageView, NSIncrementalStore, NSIncrementalStoreNode, NSIndexPath, NSIndexSet, NSIndexSpecifier, NSInputServerMouseTracker, NSInputServiceProvider, NSItemProvider, NSItemProviderReading, NSItemProviderWriting, NSKeyValueChangeKey, NSKeyValueOperator, NSKeyedArchiver, NSKeyedArchiverDelegate, NSKeyedUnarchiver, NSKeyedUnarchiverDelegate, NSLayoutAnchor, NSLayoutConstraint, NSLayoutDimension, NSLayoutGuide, NSLayoutManager, NSLayoutManagerDelegate, NSLayoutXAxisAnchor, NSLayoutYAxisAnchor, NSLevelIndicator, NSLevelIndicatorCell, NSLinguisticTag, NSLinguisticTagScheme, NSLinguisticTagger, NSLocale, NSLock, NSLocking, NSLogicalTest, NSMachPort, NSMachPortDelegate, NSMagnificationGestureRecognizer, NSManagedObject, NSManagedObjectContext, NSManagedObjectID, NSManagedObjectModel, NSMapTable, NSMappingModel, NSMatrix, NSMatrixDelegate, NSMeasurement, NSMediaLibraryBrowserController, NSMenu, NSMenuDelegate, NSMenuItem, NSMenuItemCell, NSMenuItemValidation, NSMenuToolbarItem, NSMergeConflict, NSMergePolicy, NSMetadataItem, NSMetadataQuery, NSMetadataQueryAttributeValueTuple, NSMetadataQueryDelegate, NSMetadataQueryResultGroup, NSMiddleSpecifier, NSMigrationManager, NSMoveCommand, NSMutableArray, NSMutableAttributedString, NSMutableCharacterSet, NSMutableCopying, NSMutableData, NSMutableDictionary, NSMutableFontCollection, NSMutableIndexSet, NSMutableOrderedSet, NSMutableParagraphStyle, NSMutableSet, NSMutableString, NSMutableURLRequest, NSNameSpecifier, NSNib, NSNotification, NSNull, NSNumber, NSObjectController, NSOpenPanel, NSOpenSavePanelDelegate, NSOrderedCollectionChange, NSOrderedCollectionDifference, NSOrderedSet, NSOrthography, NSOutlineView, NSOutlineViewDataSource, NSOutlineViewDelegate, NSPDFImageRep, NSPDFInfo, NSPDFPanel, NSPICTImageRep, NSPageController, NSPageControllerDelegate, NSPageLayout, NSPanGestureRecognizer, NSPanel, NSParagraphStyle, NSPasteboard, NSPasteboardItem, NSPasteboardItemDataProvider, NSPasteboardReading, NSPasteboardTypeOwner, NSPasteboardWriting, NSPathCell, NSPathCellDelegate, NSPathComponentCell, NSPathControl, NSPathControlDelegate, NSPathControlItem, NSPersistentCloudKitContainer, NSPersistentCloudKitContainerOptions, NSPersistentContainer, NSPersistentDocument, NSPersistentHistoryChange, NSPersistentHistoryChangeRequest, NSPersistentHistoryResult, NSPersistentHistoryToken, NSPersistentHistoryTransaction, NSPersistentStore, NSPersistentStoreAsynchronousResult, NSPersistentStoreCoordinator, NSPersistentStoreDescription, NSPersistentStoreRequest, NSPersistentStoreResult, NSPersonNameComponents, NSPickerTouchBarItem, NSPointerArray, NSPointerFunctions, NSPopUpButton, NSPopUpButtonCell, NSPopover, NSPopoverDelegate, NSPopoverTouchBarItem, NSPositionalSpecifier, NSPredicate, NSPredicateEditor, NSPredicateEditorRowTemplate, NSPressGestureRecognizer, NSPressureConfiguration, NSPrintInfo, NSPrintOperation, NSPrintPanel, NSPrintPanelAccessorizing, NSPrinter, NSProgressIndicator, NSPropertyDescription, NSPropertyMapping, NSPropertySpecifier, NSProtocolChecker, NSProxy, NSPurgeableData, NSQueryGenerationToken, NSQuitCommand, NSRandomSpecifier, NSRangeSpecifier, NSRecursiveLock, NSRegularExpression, NSRelationshipDescription, NSRelativeSpecifier, NSResponder, NSRotationGestureRecognizer, NSRuleEditor, NSRuleEditorDelegate, NSRulerMarker, NSRulerView, NSRunningApplication, NSSaveChangesRequest, NSSavePanel, NSScreen, NSScriptClassDescription, NSScriptCoercionHandler, NSScriptCommand, NSScriptCommandDescription, NSScriptExecutionContext, NSScriptObjectSpecifier, NSScriptSuiteRegistry, NSScriptWhoseTest, NSScrollView, NSScroller, NSScrubber, NSScrubberArrangedView, NSScrubberDataSource, NSScrubberDelegate, NSScrubberFlowLayout, NSScrubberFlowLayoutDelegate, NSScrubberImageItemView, NSScrubberItemView, NSScrubberLayout, NSScrubberLayoutAttributes, NSScrubberProportionalLayout, NSScrubberSelectionStyle, NSScrubberSelectionView, NSScrubberTextItemView, NSSearchField, NSSearchFieldCell, NSSearchFieldDelegate, NSSecureCoding, NSSecureTextField, NSSecureTextFieldCell, NSSecureUnarchiveFromDataTransformer, NSSegmentedCell, NSSegmentedControl, NSSeguePerforming, NSServicesMenuRequestor, NSSet, NSSetCommand, NSShadow, NSSharingService, NSSharingServiceDelegate, NSSharingServicePicker, NSSharingServicePickerDelegate, NSSharingServicePickerToolbarItem, NSSharingServicePickerToolbarItemDelegate, NSSharingServicePickerTouchBarItem, NSSharingServicePickerTouchBarItemDelegate, NSSlider, NSSliderAccessory, NSSliderAccessoryBehavior, NSSliderCell, NSSliderTouchBarItem, NSSortDescriptor, NSSound, NSSoundDelegate, NSSpecifierTest, NSSpeechRecognizer, NSSpeechRecognizerDelegate, NSSpeechSynthesizer, NSSpeechSynthesizerDelegate, NSSpellChecker, NSSpellServer, NSSpellServerDelegate, NSSplitView, NSSplitViewController, NSSplitViewDelegate, NSSplitViewItem, NSSpringLoadingDestination, NSStackView, NSStackViewDelegate, NSStandardKeyBindingResponding, NSStatusBar, NSStatusBarButton, NSStatusItem, NSStepper, NSStepperCell, NSStepperTouchBarItem, NSStoryboard, NSStoryboardSegue, NSString, NSStringDrawingContext, NSSwitch, NSTabView, NSTabViewController, NSTabViewDelegate, NSTabViewItem, NSTableCellView, NSTableColumn, NSTableHeaderCell, NSTableHeaderView, NSTableRowView, NSTableView, NSTableViewDataSource, NSTableViewDelegate, NSTableViewRowAction, NSText, NSTextAlternatives, NSTextAttachment, NSTextAttachmentCell, NSTextAttachmentContainer, NSTextBlock, NSTextCheckingClient, NSTextCheckingController, NSTextCheckingKey, NSTextCheckingResult, NSTextContainer, NSTextDelegate, NSTextField, NSTextFieldCell, NSTextFieldDelegate, NSTextFinder, NSTextFinderBarContainer, NSTextFinderClient, NSTextInput, NSTextInputClient, NSTextInputContext, NSTextInputTraits, NSTextLayoutOrientationProvider, NSTextList, NSTextStorage, NSTextStorageDelegate, NSTextTab, NSTextTable, NSTextTableBlock, NSTextView, NSTextViewDelegate, NSTimeZone, NSTitlebarAccessoryViewController, NSTokenField, NSTokenFieldCell, NSTokenFieldCellDelegate, NSTokenFieldDelegate, NSToolbar, NSToolbarDelegate, NSToolbarItem, NSToolbarItemGroup, NSToolbarItemValidation, NSTouch, NSTouchBar, NSTouchBarDelegate, NSTouchBarItem, NSTouchBarProvider, NSTrackingArea, NSTreeController, NSTreeNode, NSTypesetter, NSURL, NSURLComponents, NSURLConnection, NSURLConnectionDataDelegate, NSURLConnectionDelegate, NSURLConnectionDownloadDelegate, NSURLDownload, NSURLDownloadDelegate, NSURLHandle, NSURLQueryItem, NSURLRequest, NSURLSessionWebSocketMessage, NSUUID, NSUbiquitousKeyValueStore, NSUniqueIDSpecifier, NSUnitInformationStorage, NSUserActivity, NSUserActivityDelegate, NSUserActivityRestoring, NSUserAppleScriptTask, NSUserAutomatorTask, NSUserDefaultsController, NSUserInterfaceCompression, NSUserInterfaceCompressionOptions, NSUserInterfaceItemIdentification, NSUserInterfaceItemSearching, NSUserInterfaceValidations, NSUserNotification, NSUserNotificationAction, NSUserNotificationCenter, NSUserNotificationCenterDelegate, NSUserScriptTask, NSUserUnixTask, NSValidatedUserInterfaceItem, NSValue, NSValueTransformerName, NSView, NSViewAnimation, NSViewController, NSViewControllerPresentationAnimator, NSViewLayerContentScaleDelegate, NSViewToolTipOwner, NSVisualEffectView, NSWhoseSpecifier, NSWindow, NSWindowController, NSWindowDelegate, NSWindowRestoration, NSWindowTab, NSWindowTabGroup, NSWorkspace, NSXPCCoder, NSXPCConnection, NSXPCInterface, NSXPCListener, NSXPCListenerDelegate, NSXPCListenerEndpoint, NSXPCProxyCreating, NetService, NetServiceBrowser, NetServiceBrowserDelegate, NetServiceDelegate, NotificationCenter, NotificationQueue, NumberFormatter, OpenConfiguration, Operation, OperationQueue, OutputStream, PersonNameComponentsFormatter, Pipe, Port, PortDelegate, PortMessage, Process, ProcessInfo, Progress, ProgressKind, ProgressReporting, ProgressUserInfoKey, PropertyListSerialization, QLPreviewItem, QLPreviewPanel, QLPreviewPanelDataSource, QLPreviewPanelDelegate, QLPreviewView, QLPreviewingController, QuartzFilter, QuartzFilterManager, QuartzFilterView, RelativeDateTimeFormatter, RunLoop, Scanner, SearchParameters, SocketPort, Stream, StreamDelegate, StreamNetworkServiceTypeValue, StreamSOCKSProxyConfiguration, StreamSOCKSProxyVersion, StreamSocketSecurityLevel, StringEncodingDetectionOptionsKey, StringTransform, SystemPressureState, Thread, Timer, URLAuthenticationChallenge, URLAuthenticationChallengeSender, URLCache, URLCredential, URLCredentialStorage, URLFileProtection, URLFileResourceType, URLProtectionSpace, URLProtocol, URLProtocolClient, URLResourceKey, URLResponse, URLSession, URLSessionConfiguration, URLSessionDataDelegate, URLSessionDataTask, URLSessionDelegate, URLSessionDownloadDelegate, URLSessionDownloadTask, URLSessionStreamDelegate, URLSessionStreamTask, URLSessionTask, URLSessionTaskDelegate, URLSessionTaskMetrics, URLSessionTaskTransactionMetrics, URLSessionUploadTask, URLSessionWebSocketDelegate, URLSessionWebSocketTask, URLThumbnailDictionaryItem, URLUbiquitousItemDownloadingStatus, URLUbiquitousSharedItemPermissions, URLUbiquitousSharedItemRole, UndoManager, Unit, UnitAcceleration, UnitAngle, UnitArea, UnitConcentrationMass, UnitConverter, UnitConverterLinear, UnitDispersion, UnitDuration, UnitElectricCharge, UnitElectricCurrent, UnitElectricPotentialDifference, UnitElectricResistance, UnitEnergy, UnitFrequency, UnitFuelEfficiency, UnitIlluminance, UnitLength, UnitMass, UnitPower, UnitPressure, UnitSpeed, UnitTemperature, UnitVolume, UserDefaults, ValueTransformer, XMLDTD, XMLDTDNode, XMLDocument, XMLElement, XMLNode, XMLParser, XMLParserDelegate };
