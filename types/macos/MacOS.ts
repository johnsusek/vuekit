/* eslint-disable */

declare global {

export class AVAsset extends NSObject {
  allMediaSelections: AVMediaSelection[];
  availableChapterLocales: Locale[];
  availableMediaCharacteristicsWithMediaSelectionOptions: string[];
  availableMetadataFormats: string[];
  canContainFragments: boolean;
  commonMetadata: AVMetadataItem[];
  isCompatibleWithAirPlayVideo: boolean;
  isComposable: boolean;
  containsFragments: boolean;
  creationDate: AVMetadataItem;
  duration: CMTime;
  isExportable: boolean;
  hasProtectedContent: boolean;
  lyrics: string;
  metadata: AVMetadataItem[];
  minimumTimeOffsetFromLive: CMTime;
  overallDurationHint: CMTime;
  isPlayable: boolean;
  preferredMediaSelection: AVMediaSelection;
  preferredRate: number;
  preferredTransform: CGAffineTransform;
  preferredVolume: number;
  providesPreciseDurationAndTiming: boolean;
  isReadable: boolean;
  referenceRestrictions: AVAsset.AVAssetReferenceRestrictions;
  trackGroups: AVAssetTrackGroup[];
  tracks: AVAssetTrack[];
  cancelLoading(): void;
  chapterMetadataGroupsBestMatchingPreferredLanguages(bestMatchingPreferredLanguages: string[]): AVTimedMetadataGroup[];
  chapterMetadataGroupsWithTitleLocaleContainingItemsWithCommonKeys(withTitleLocale: Locale, containingItemsWithCommonKeys?: string[]): AVTimedMetadataGroup[];
  mediaSelectionGroupForMediaCharacteristic(forMediaCharacteristic: string): AVMediaSelectionGroup;
  // dupe name w instance property   metadataForFormat(forFormat: string): AVMetadataItem[];
  trackWithTrackID(withTrackID: number): AVAssetTrack;
  // dupe name w instance property   tracksWithMediaCharacteristic(withMediaCharacteristic: string): AVAssetTrack[];
  // dupe name w instance property   tracksWithMediaType(withMediaType: string): AVAssetTrack[];
  unusedTrackID(): number;
}

export class AVAssetCache extends NSObject {
  isPlayableOffline: boolean;
  mediaSelectionOptionsInMediaSelectionGroup(in_: AVMediaSelectionGroup): AVMediaSelectionOption[];
}

export class AVAssetExportSession extends NSObject {
  static allExportPresets(): string[];
  static determineCompatibilityOfExportPresetWithAssetOutputFileTypeCompletionHandler(ofExportPreset: string, with_: AVAsset, outputFileType?: string, completionHandler?: (p1: boolean) => void): void;
  static exportPresetsCompatibleWithAsset(compatibleWith: AVAsset): string[];
  asset: AVAsset;
  audioMix: AVAudioMix;
  setAudioMix(_: AVAudioMix);
  audioTimePitchAlgorithm: string;
  setAudioTimePitchAlgorithm(_: string);
  canPerformMultiplePassesOverSourceMediaData: boolean;
  setCanPerformMultiplePassesOverSourceMediaData(_: boolean);
  customVideoCompositor: any;
  directoryForTemporaryFiles: URL;
  setDirectoryForTemporaryFiles(_: URL);
  error: Error;
  estimatedOutputFileLength: number;
  fileLengthLimit: number;
  setFileLengthLimit(_: number);
  maxDuration: CMTime;
  metadata: AVMetadataItem[];
  setMetadata(_: AVMetadataItem[]);
  metadataItemFilter: AVMetadataItemFilter;
  setMetadataItemFilter(_: AVMetadataItemFilter);
  outputFileType: string;
  setOutputFileType(_: string);
  outputURL: URL;
  setOutputURL(_: URL);
  presetName: string;
  progress: number;
  shouldOptimizeForNetworkUse: boolean;
  setShouldOptimizeForNetworkUse(_: boolean);
  status: AVAssetExportSession.Status;
  supportedFileTypes: string[];
  timeRange: CMTimeRange;
  setTimeRange(_: CMTimeRange);
  videoComposition: AVVideoComposition;
  setVideoComposition(_: AVVideoComposition);
  cancelExport(): void;
  determineCompatibleFileTypesWithCompletionHandler(completionHandler: (p1: string[]) => void): void;
  estimateMaximumDurationWithCompletionHandler(completionHandler?: (p1: CMTime, p2: Error) => void): void;
  estimateOutputFileLengthWithCompletionHandler(completionHandler?: (p1: number, p2: Error) => void): void;
  exportAsynchronouslyWithCompletionHandler(completionHandler: () => void): void;
  static initWithAssetPresetName(_: AVAsset, presetName: string): AVAssetExportSession;
}

export class AVAssetImageGenerator extends NSObject {
  apertureMode: string;
  setApertureMode(_: string);
  appliesPreferredTrackTransform: boolean;
  setAppliesPreferredTrackTransform(_: boolean);
  asset: AVAsset;
  customVideoCompositor: any;
  maximumSize: CGSize;
  setMaximumSize(_: CGSize);
  requestedTimeToleranceAfter: CMTime;
  setRequestedTimeToleranceAfter(_: CMTime);
  requestedTimeToleranceBefore: CMTime;
  setRequestedTimeToleranceBefore(_: CMTime);
  videoComposition: AVVideoComposition;
  setVideoComposition(_: AVVideoComposition);
  cancelAllCGImageGeneration(): void;
  copyCGImageAtTimeActualTime(actualTime: CMTime, error?: CMTime): any;
  generateCGImagesAsynchronouslyForTimesCompletionHandler(forTimes: NSValue[], completionHandler: (p1: CMTime, p2: any, p3: CMTime, p4: AVAssetImageGenerator.Result, p5: Error) => void): void;
  static initWithAsset(_: AVAsset): AVAssetImageGenerator;
}

export class AVAssetReader extends NSObject {
  static assetReaderWithAsset(error: AVAsset): AVAssetReader;
  asset: AVAsset;
  error: Error;
  outputs: AVAssetReaderOutput[];
  status: AVAssetReader.Status;
  timeRange: CMTimeRange;
  setTimeRange(_: CMTimeRange);
  addOutput(_: AVAssetReaderOutput): void;
  canAddOutput(_: AVAssetReaderOutput): boolean;
  cancelReading(): void;
  static initWithAsset(error: AVAsset): AVAssetReader;
  startReading(): boolean;
}

export class AVAssetReaderAudioMixOutput extends AVAssetReaderOutput {
  audioMix: AVAudioMix;
  setAudioMix(_: AVAudioMix);
  audioSettings: Map<string, any>;
  audioTimePitchAlgorithm: string;
  setAudioTimePitchAlgorithm(_: string);
  audioTracks: AVAssetTrack[];
  static initWithAudioTracksAudioSettings(_: AVAssetTrack[], audioSettings?: Map<string, any>): AVAssetReaderAudioMixOutput;
}

export class AVAssetReaderOutput extends NSObject {
  alwaysCopiesSampleData: boolean;
  setAlwaysCopiesSampleData(_: boolean);
  mediaType: string;
  supportsRandomAccess: boolean;
  setSupportsRandomAccess(_: boolean);
  copyNextSampleBuffer(): any;
  markConfigurationAsFinal(): void;
  resetForReadingTimeRanges(forReadingTimeRanges: NSValue[]): void;
}

export class AVAssetReaderOutputMetadataAdaptor extends NSObject {
  assetReaderTrackOutput: AVAssetReaderTrackOutput;
  static initWithAssetReaderTrackOutput(_: AVAssetReaderTrackOutput): AVAssetReaderOutputMetadataAdaptor;
  nextTimedMetadataGroup(): AVTimedMetadataGroup;
}

export class AVAssetReaderSampleReferenceOutput extends AVAssetReaderOutput {
  track: AVAssetTrack;
  static initWithTrack(_: AVAssetTrack): AVAssetReaderSampleReferenceOutput;
}

export class AVAssetReaderTrackOutput extends AVAssetReaderOutput {
  audioTimePitchAlgorithm: string;
  setAudioTimePitchAlgorithm(_: string);
  outputSettings: Map<string, any>;
  track: AVAssetTrack;
  static initWithTrackOutputSettings(_: AVAssetTrack, outputSettings?: Map<string, any>): AVAssetReaderTrackOutput;
}

export class AVAssetReaderVideoCompositionOutput extends AVAssetReaderOutput {
  customVideoCompositor: any;
  videoComposition: AVVideoComposition;
  setVideoComposition(_: AVVideoComposition);
  videoSettings: Map<string, any>;
  videoTracks: AVAssetTrack[];
  static initWithVideoTracksVideoSettings(_: AVAssetTrack[], videoSettings?: Map<string, any>): AVAssetReaderVideoCompositionOutput;
}

export class AVAssetResourceLoader extends NSObject {
  delegate: any;
  delegateQueue: NSObject;
  preloadsEligibleContentKeys: boolean;
  setPreloadsEligibleContentKeys(_: boolean);
  setDelegateQueue(_?: any, queue?: NSObject): void;
}

interface AVAssetResourceLoaderDelegate {
  resourceLoaderShouldWaitForLoadingOfRequestedResource(_: AVAssetResourceLoader, shouldWaitForLoadingOfRequestedResource: AVAssetResourceLoadingRequest): boolean;
  resourceLoaderShouldWaitForRenewalOfRequestedResource(_: AVAssetResourceLoader, shouldWaitForRenewalOfRequestedResource: AVAssetResourceRenewalRequest): boolean;
  resourceLoaderDidCancelLoadingRequest(_: AVAssetResourceLoader, didCancel: AVAssetResourceLoadingRequest): void;
  resourceLoaderShouldWaitForResponseToAuthenticationChallenge(_: AVAssetResourceLoader, shouldWaitForResponseTo: URLAuthenticationChallenge): boolean;
  resourceLoaderDidCancelAuthenticationChallenge(_: AVAssetResourceLoader, didCancel: URLAuthenticationChallenge): void;
}

export class AVAssetResourceLoadingContentInformationRequest extends NSObject {
  allowedContentTypes: string[];
  isByteRangeAccessSupported: boolean;
  setByteRangeAccessSupported(_: boolean);
  contentLength: number;
  setContentLength(_: number);
  contentType: string;
  setContentType(_: string);
  renewalDate: Date;
  setRenewalDate(_: Date);
}

export class AVAssetResourceLoadingDataRequest extends NSObject {
  currentOffset: number;
  requestedLength: number;
  requestedOffset: number;
  requestsAllDataToEndOfResource: boolean;
  respondWithData(with_: Data): void;
}

export class AVAssetResourceLoadingRequest extends NSObject {
  isCancelled: boolean;
  contentInformationRequest: AVAssetResourceLoadingContentInformationRequest;
  dataRequest: AVAssetResourceLoadingDataRequest;
  isFinished: boolean;
  redirect: URLRequest;
  setRedirect(_: URLRequest);
  request: URLRequest;
  requestor: AVAssetResourceLoadingRequestor;
  response: URLResponse;
  setResponse(_: URLResponse);
  finishLoading(): void;
  finishLoadingWithError(with_?: Error): void;
  persistentContentKeyFromKeyVendorResponseOptions(options: Data, error?: Map<string, any>): Data;
  streamingContentKeyRequestDataForAppContentIdentifierOptions(contentIdentifier: Data, options: Data, error?: Map<string, any>): Data;
}

export class AVAssetResourceLoadingRequestor extends NSObject {
  providesExpiredSessionReports: boolean;
}

export class AVAssetResourceRenewalRequest extends AVAssetResourceLoadingRequest {
}

export class AVAssetTrack extends NSObject {
  asset: AVAsset;
  availableMetadataFormats: string[];
  availableTrackAssociationTypes: string[];
  canProvideSampleCursors: boolean;
  commonMetadata: AVMetadataItem[];
  isDecodable: boolean;
  isEnabled: boolean;
  estimatedDataRate: number;
  extendedLanguageTag: string;
  formatDescriptions: any[];
  hasAudioSampleDependencies: boolean;
  languageCode: string;
  mediaType: string;
  metadata: AVMetadataItem[];
  minFrameDuration: CMTime;
  naturalSize: CGSize;
  naturalTimeScale: number;
  nominalFrameRate: number;
  isPlayable: boolean;
  preferredTransform: CGAffineTransform;
  preferredVolume: number;
  requiresFrameReordering: boolean;
  segments: AVAssetTrackSegment[];
  isSelfContained: boolean;
  timeRange: CMTimeRange;
  totalSampleDataLength: number;
  trackID: number;
  associatedTracksOfType(ofType: string): AVAssetTrack[];
  hasMediaCharacteristic(_: string): boolean;
  makeSampleCursorAtFirstSampleInDecodeOrder(): AVSampleCursor;
  makeSampleCursorAtLastSampleInDecodeOrder(): AVSampleCursor;
  makeSampleCursorWithPresentationTimeStamp(presentationTimeStamp: CMTime): AVSampleCursor;
  // dupe name w instance property   metadataForFormat(forFormat: string): AVMetadataItem[];
  samplePresentationTimeForTrackTime(forTrackTime: CMTime): CMTime;
  segmentForTrackTime(forTrackTime: CMTime): AVAssetTrackSegment;
}

export class AVAssetTrackGroup extends NSObject {
  trackIDs: number[];
}

export class AVAssetTrackSegment extends NSObject {
  isEmpty: boolean;
  timeMapping: CMTimeMapping;
}

export class AVAssetWriter extends NSObject {
  static assetWriterWithURLFileType(fileType: URL, error: string): AVAssetWriter;
  availableMediaTypes: string[];
  directoryForTemporaryFiles: URL;
  setDirectoryForTemporaryFiles(_: URL);
  error: Error;
  inputGroups: AVAssetWriterInputGroup[];
  inputs: AVAssetWriterInput[];
  metadata: AVMetadataItem[];
  setMetadata(_: AVMetadataItem[]);
  movieFragmentInterval: CMTime;
  setMovieFragmentInterval(_: CMTime);
  movieTimeScale: number;
  setMovieTimeScale(_: number);
  outputFileType: string;
  outputURL: URL;
  overallDurationHint: CMTime;
  setOverallDurationHint(_: CMTime);
  shouldOptimizeForNetworkUse: boolean;
  setShouldOptimizeForNetworkUse(_: boolean);
  status: AVAssetWriter.Status;
  addInput(_: AVAssetWriterInput): void;
  addInputGroup(_: AVAssetWriterInputGroup): void;
  canAddInput(_: AVAssetWriterInput): boolean;
  canAddInputGroup(_: AVAssetWriterInputGroup): boolean;
  canApplyOutputSettingsForMediaType(outputSettings?: Map<string, any>, forMediaType?: string): boolean;
  cancelWriting(): void;
  endSessionAtSourceTime(atSourceTime: CMTime): void;
  finishWritingWithCompletionHandler(completionHandler: () => void): void;
  startSessionAtSourceTime(atSourceTime: CMTime): void;
  startWriting(): boolean;
}

export class AVAssetWriterInput extends NSObject {
  canPerformMultiplePasses: boolean;
  currentPassDescription: AVAssetWriterInputPassDescription;
  expectsMediaDataInRealTime: boolean;
  setExpectsMediaDataInRealTime(_: boolean);
  extendedLanguageTag: string;
  setExtendedLanguageTag(_: string);
  languageCode: string;
  setLanguageCode(_: string);
  marksOutputTrackAsEnabled: boolean;
  setMarksOutputTrackAsEnabled(_: boolean);
  mediaDataLocation: string;
  setMediaDataLocation(_: string);
  mediaTimeScale: number;
  setMediaTimeScale(_: number);
  mediaType: string;
  metadata: AVMetadataItem[];
  setMetadata(_: AVMetadataItem[]);
  naturalSize: CGSize;
  setNaturalSize(_: CGSize);
  outputSettings: Map<string, any>;
  performsMultiPassEncodingIfSupported: boolean;
  setPerformsMultiPassEncodingIfSupported(_: boolean);
  preferredMediaChunkAlignment: number;
  setPreferredMediaChunkAlignment(_: number);
  preferredMediaChunkDuration: CMTime;
  setPreferredMediaChunkDuration(_: CMTime);
  preferredVolume: number;
  setPreferredVolume(_: number);
  isReadyForMoreMediaData: boolean;
  sampleReferenceBaseURL: URL;
  setSampleReferenceBaseURL(_: URL);
  sourceFormatHint: any;
  transform: CGAffineTransform;
  setTransform(_: CGAffineTransform);
  addTrackAssociationWithTrackOfInputType(withTrackOf: AVAssetWriterInput, type: string): void;
  appendSampleBuffer(_: any): boolean;
  canAddTrackAssociationWithTrackOfInputType(withTrackOf: AVAssetWriterInput, type: string): boolean;
  static initWithMediaTypeOutputSettings(_: string, outputSettings?: Map<string, any>): AVAssetWriterInput;
  static initWithMediaTypeOutputSettingsSourceFormatHint(_: string, outputSettings?: Map<string, any>, sourceFormatHint?: any): AVAssetWriterInput;
  markAsFinished(): void;
  markCurrentPassAsFinished(): void;
  requestMediaDataWhenReadyOnQueueUsingBlock(on: NSObject, using: () => void): void;
  respondToEachPassDescriptionOnQueueUsingBlock(on: NSObject, using: () => void): void;
}

export class AVAssetWriterInputGroup extends AVMediaSelectionGroup {
  defaultInput: AVAssetWriterInput;
  inputs: AVAssetWriterInput[];
  static initWithInputsDefaultInput(_: AVAssetWriterInput[], defaultInput?: AVAssetWriterInput): AVAssetWriterInputGroup;
}

export class AVAssetWriterInputMetadataAdaptor extends NSObject {
  assetWriterInput: AVAssetWriterInput;
  appendTimedMetadataGroup(_: AVTimedMetadataGroup): boolean;
  static initWithAssetWriterInput(_: AVAssetWriterInput): AVAssetWriterInputMetadataAdaptor;
}

export class AVAssetWriterInputPassDescription extends NSObject {
  sourceTimeRanges: NSValue[];
}

export class AVAssetWriterInputPixelBufferAdaptor extends NSObject {
  assetWriterInput: AVAssetWriterInput;
  pixelBufferPool: any;
  sourcePixelBufferAttributes: Map<string, any>;
  appendPixelBufferWithPresentationTime(_: any, withPresentationTime: CMTime): boolean;
  static initWithAssetWriterInputSourcePixelBufferAttributes(_: AVAssetWriterInput, sourcePixelBufferAttributes?: Map<string, any>): AVAssetWriterInputPixelBufferAdaptor;
}

export class AVAsynchronousCIImageFilteringRequest extends NSObject {
  compositionTime: CMTime;
  renderSize: CGSize;
  sourceImage: CIImage;
  finishWithError(with_: Error): void;
  finishWithImageContext(with_: CIImage, context?: CIContext): void;
}

interface AVAsynchronousKeyValueLoading {
  loadValuesAsynchronouslyForKeysCompletionHandler(forKeys: string[], completionHandler?: () => void): void;
  statusOfValueForKey(forKey: string): AVAsynchronousKeyValueLoading.AVKeyValueStatus;
}

export class AVAsynchronousVideoCompositionRequest extends NSObject {
  compositionTime: CMTime;
  renderContext: AVVideoCompositionRenderContext;
  sourceTrackIDs: number[];
  videoCompositionInstruction: any;
  finishCancelledRequest(): void;
  finishWithComposedVideoFrame(withComposedVideoFrame: any): void;
  finishWithError(with_: Error): void;
  sourceFrameByTrackID(byTrackID: number): any;
}

interface AVAudio3DMixing {
  obstruction: number;
  setObstruction(_: number);
  occlusion: number;
  setOcclusion(_: number);
  pointSourceInHeadMode: AVAudioMixing.AVAudio3DMixingPointSourceInHeadMode;
  setPointSourceInHeadMode(_: AVAudioMixing.AVAudio3DMixingPointSourceInHeadMode);
  position: AVAudio3DPoint;
  setPosition(_: AVAudio3DPoint);
  rate: number;
  setRate(_: number);
  renderingAlgorithm: AVAudioMixing.AVAudio3DMixingRenderingAlgorithm;
  setRenderingAlgorithm(_: AVAudioMixing.AVAudio3DMixingRenderingAlgorithm);
  reverbBlend: number;
  setReverbBlend(_: number);
  sourceMode: AVAudioMixing.AVAudio3DMixingSourceMode;
  setSourceMode(_: AVAudioMixing.AVAudio3DMixingSourceMode);
}

export class AVAudioBuffer extends NSObject {
  audioBufferList: AudioBufferList;
  format: AVAudioFormat;
  mutableAudioBufferList: AudioBufferList;
}

export class AVAudioChannelLayout extends NSObject {
  channelCount: number;
  layout: AudioChannelLayout;
  layoutTag: number;
  static initWithLayout(_: AudioChannelLayout): AVAudioChannelLayout;
  static initWithLayoutTag(_: number): AVAudioChannelLayout;
}

export class AVAudioCompressedBuffer extends AVAudioBuffer {
  byteCapacity: number;
  byteLength: number;
  setByteLength(_: number);
  data: any;
  maximumPacketSize: number;
  packetCapacity: number;
  packetCount: number;
  setPacketCount(_: number);
  packetDescriptions: AudioStreamPacketDescription;
  static initWithFormatPacketCapacity(_: AVAudioFormat, packetCapacity: number): AVAudioCompressedBuffer;
  static initWithFormatPacketCapacityMaximumPacketSize(_: AVAudioFormat, packetCapacity: number, maximumPacketSize: number): AVAudioCompressedBuffer;
}

export class AVAudioConnectionPoint extends NSObject {
  bus: number;
  node: AVAudioNode;
  static initWithNodeBus(_: AVAudioNode, bus: number): AVAudioConnectionPoint;
}

export class AVAudioConverter extends NSObject {
  applicableEncodeBitRates: number[];
  applicableEncodeSampleRates: number[];
  availableEncodeBitRates: number[];
  availableEncodeChannelLayoutTags: number[];
  availableEncodeSampleRates: number[];
  bitRate: number;
  setBitRate(_: number);
  bitRateStrategy: string;
  setBitRateStrategy(_: string);
  channelMap: number[];
  setChannelMap(_: number[]);
  dither: boolean;
  setDither(_: boolean);
  downmix: boolean;
  setDownmix(_: boolean);
  inputFormat: AVAudioFormat;
  magicCookie: Data;
  setMagicCookie(_: Data);
  maximumOutputPacketSize: number;
  outputFormat: AVAudioFormat;
  primeInfo: AVAudioConverterPrimeInfo;
  setPrimeInfo(_: AVAudioConverterPrimeInfo);
  primeMethod: AVAudioConverter.AVAudioConverterPrimeMethod;
  setPrimeMethod(_: AVAudioConverter.AVAudioConverterPrimeMethod);
  sampleRateConverterAlgorithm: string;
  setSampleRateConverterAlgorithm(_: string);
  sampleRateConverterQuality: number;
  setSampleRateConverterQuality(_: number);
  convertToBufferErrorWithInputFromBlock(to: AVAudioBuffer, error?: Error, withInputFrom?: (p1: number, p2: AVAudioConverter.AVAudioConverterInputStatus) => AVAudioBuffer): AVAudioConverter.AVAudioConverterOutputStatus;
  convertToBufferFromBuffer(fromBuffer: AVAudioPCMBuffer, error: AVAudioPCMBuffer): boolean;
  static initFromFormatToFormat(_: AVAudioFormat, toFormat: AVAudioFormat): AVAudioConverter;
  reset(): void;
}

export class AVAudioEngine extends NSObject {
  attachedNodes: Set<any>;
  isAutoShutdownEnabled: boolean;
  setAutoShutdownEnabled(_: boolean);
  inputNode: AVAudioInputNode;
  isInManualRenderingMode: boolean;
  mainMixerNode: AVAudioMixerNode;
  manualRenderingBlock: (p1: number, p2: AudioBufferList, p3: number) => AVAudioEngine.AVAudioEngineManualRenderingStatus;
  manualRenderingFormat: AVAudioFormat;
  manualRenderingMaximumFrameCount: number;
  manualRenderingMode: AVAudioEngine.AVAudioEngineManualRenderingMode;
  manualRenderingSampleTime: number;
  musicSequence: any;
  setMusicSequence(_: any);
  outputNode: AVAudioOutputNode;
  isRunning: boolean;
  attachNode(_: AVAudioNode): void;
  connectToFormat(_: AVAudioNode, to: AVAudioNode, format?: AVAudioFormat): void;
  connectToFromBusToBusFormat(_: AVAudioNode, to: AVAudioNode, fromBus: number, toBus: number, format?: AVAudioFormat): void;
  connectToConnectionPointsFromBusFormat(_: AVAudioNode, to: AVAudioConnectionPoint[], fromBus: number, format?: AVAudioFormat): void;
  connectMIDIToFormatBlock(_: AVAudioNode, to: AVAudioNode, format?: AVAudioFormat, block?: (p1: number, p2: number, p3: number, p4: string) => number): void;
  connectMIDIToNodesFormatBlock(_: AVAudioNode, to: AVAudioNode[], format?: AVAudioFormat, block?: (p1: number, p2: number, p3: number, p4: string) => number): void;
  detachNode(_: AVAudioNode): void;
  disableManualRenderingMode(): void;
  disconnectMIDIFrom(_: AVAudioNode, from: AVAudioNode): void;
  disconnectMIDIFromNodes(_: AVAudioNode, from: AVAudioNode[]): void;
  disconnectMIDIInput(_: AVAudioNode): void;
  disconnectMIDIOutput(_: AVAudioNode): void;
  disconnectNodeInput(_: AVAudioNode): void;
  disconnectNodeInputBus(_: AVAudioNode, bus: number): void;
  disconnectNodeOutput(_: AVAudioNode): void;
  disconnectNodeOutputBus(_: AVAudioNode, bus: number): void;
  enableManualRenderingModeFormatMaximumFrameCount(format: AVAudioEngine.AVAudioEngineManualRenderingMode, maximumFrameCount: AVAudioFormat, error: number): boolean;
  inputConnectionPointForNodeInputBus(for_: AVAudioNode, inputBus: number): AVAudioConnectionPoint;
  outputConnectionPointsForNodeOutputBus(for_: AVAudioNode, outputBus: number): AVAudioConnectionPoint[];
  pause(): void;
  prepare(): void;
  renderOfflineToBuffer(toBuffer: number, error: AVAudioPCMBuffer): AVAudioEngine.AVAudioEngineManualRenderingStatus;
  reset(): void;
  startAndReturnError(): boolean;
  stop(): void;
}

export class AVAudioEnvironmentDistanceAttenuationParameters extends NSObject {
  distanceAttenuationModel: AVAudioEnvironmentNode.AVAudioEnvironmentDistanceAttenuationModel;
  setDistanceAttenuationModel(_: AVAudioEnvironmentNode.AVAudioEnvironmentDistanceAttenuationModel);
  maximumDistance: number;
  setMaximumDistance(_: number);
  referenceDistance: number;
  setReferenceDistance(_: number);
  rolloffFactor: number;
  setRolloffFactor(_: number);
}

export class AVAudioEnvironmentNode extends AVAudioNode {
  applicableRenderingAlgorithms: number[];
  distanceAttenuationParameters: AVAudioEnvironmentDistanceAttenuationParameters;
  listenerAngularOrientation: AVAudio3DAngularOrientation;
  setListenerAngularOrientation(_: AVAudio3DAngularOrientation);
  listenerPosition: AVAudio3DPoint;
  setListenerPosition(_: AVAudio3DPoint);
  listenerVectorOrientation: AVAudio3DVectorOrientation;
  setListenerVectorOrientation(_: AVAudio3DVectorOrientation);
  nextAvailableInputBus: number;
  outputType: AVAudioEnvironmentNode.AVAudioEnvironmentOutputType;
  setOutputType(_: AVAudioEnvironmentNode.AVAudioEnvironmentOutputType);
  outputVolume: number;
  setOutputVolume(_: number);
  reverbParameters: AVAudioEnvironmentReverbParameters;
}

export class AVAudioEnvironmentReverbParameters extends NSObject {
  enable: boolean;
  setEnable(_: boolean);
  filterParameters: AVAudioUnitEQFilterParameters;
  level: number;
  setLevel(_: number);
  loadFactoryReverbPreset(_: AVAudioUnitReverb.AVAudioUnitReverbPreset): void;
}

export class AVAudioFile extends NSObject {
  fileFormat: AVAudioFormat;
  framePosition: number;
  setFramePosition(_: number);
  length: number;
  processingFormat: AVAudioFormat;
  url: URL;
  static initForReadingCommonFormatInterleaved(commonFormat: URL, interleaved: AVAudioFormat.AVAudioCommonFormat, error: boolean): AVAudioFile;
  static initForReading(error: URL): AVAudioFile;
  static initForWritingSettingsCommonFormatInterleaved(settings: URL, commonFormat: Map<string, any>, interleaved: AVAudioFormat.AVAudioCommonFormat, error: boolean): AVAudioFile;
  static initForWritingSettings(settings: URL, error: Map<string, any>): AVAudioFile;
  readIntoBuffer(error: AVAudioPCMBuffer): boolean;
  readIntoBufferFrameCount(frameCount: AVAudioPCMBuffer, error: number): boolean;
  writeFromBuffer(error: AVAudioPCMBuffer): boolean;
}

export class AVAudioFormat extends NSObject {
  channelCount: number;
  channelLayout: AVAudioChannelLayout;
  commonFormat: AVAudioFormat.AVAudioCommonFormat;
  formatDescription: any;
  isInterleaved: boolean;
  magicCookie: Data;
  setMagicCookie(_: Data);
  sampleRate: number;
  settings: Map<string, any>;
  isStandard: boolean;
  streamDescription: AudioStreamBasicDescription;
  static initStandardFormatWithSampleRateChannelLayout(_: number, channelLayout: AVAudioChannelLayout): AVAudioFormat;
  static initStandardFormatWithSampleRateChannels(_: number, channels: number): AVAudioFormat;
  static initWithCMAudioFormatDescription(_: any): AVAudioFormat;
  static initWithCommonFormatSampleRateChannelsInterleaved(_: AVAudioFormat.AVAudioCommonFormat, sampleRate: number, channels: number, interleaved: boolean): AVAudioFormat;
  static initWithCommonFormatSampleRateInterleavedChannelLayout(_: AVAudioFormat.AVAudioCommonFormat, sampleRate: number, interleaved: boolean, channelLayout: AVAudioChannelLayout): AVAudioFormat;
  static initWithSettings(_: Map<string, any>): AVAudioFormat;
  static initWithStreamDescription(_: AudioStreamBasicDescription): AVAudioFormat;
  static initWithStreamDescriptionChannelLayout(_: AudioStreamBasicDescription, channelLayout?: AVAudioChannelLayout): AVAudioFormat;
}

export class AVAudioIONode extends AVAudioNode {
  audioUnit: ComponentInstanceRecord;
  presentationLatency: number;
  isVoiceProcessingEnabled: boolean;
  setVoiceProcessingEnabled(error: boolean): boolean;
}

export class AVAudioInputNode extends AVAudioIONode {
  isVoiceProcessingAGCEnabled: boolean;
  setVoiceProcessingAGCEnabled(_: boolean);
  isVoiceProcessingBypassed: boolean;
  setVoiceProcessingBypassed(_: boolean);
  isVoiceProcessingInputMuted: boolean;
  setVoiceProcessingInputMuted(_: boolean);
  setManualRenderingInputPCMFormatInputBlock(_: AVAudioFormat, inputBlock: (p1: number) => AudioBufferList): boolean;
}

export class AVAudioMix extends NSObject {
  inputParameters: AVAudioMixInputParameters[];
}

export class AVAudioMixInputParameters extends NSObject {
  audioTapProcessor: any;
  audioTimePitchAlgorithm: string;
  trackID: number;
  getVolumeRampForTimeStartVolumeEndVolumeTimeRange(for_: CMTime, startVolume?: number, endVolume?: number, timeRange?: CMTimeRange): boolean;
}

export class AVAudioMixerNode extends AVAudioNode {
  nextAvailableInputBus: number;
  outputVolume: number;
  setOutputVolume(_: number);
}

interface AVAudioMixing {
  volume: number;
  setVolume(_: number);
  destinationForMixerBus(forMixer: AVAudioNode, bus: number): AVAudioMixingDestination;
}

export class AVAudioMixingDestination extends NSObject {
  connectionPoint: AVAudioConnectionPoint;
}

export class AVAudioNode extends NSObject {
  AUAudioUnit: AUAudioUnit;
  engine: AVAudioEngine;
  lastRenderTime: AVAudioTime;
  latency: number;
  numberOfInputs: number;
  numberOfOutputs: number;
  outputPresentationLatency: number;
  inputFormatForBus(forBus: number): AVAudioFormat;
  installTapOnBusBufferSizeFormatBlock(onBus: number, bufferSize: number, format?: AVAudioFormat, block?: (p1: AVAudioPCMBuffer, p2: AVAudioTime) => void): void;
  nameForInputBus(forInputBus: number): string;
  nameForOutputBus(forOutputBus: number): string;
  outputFormatForBus(forBus: number): AVAudioFormat;
  removeTapOnBus(onBus: number): void;
  reset(): void;
}

export class AVAudioOutputNode extends AVAudioIONode {
}

export class AVAudioPCMBuffer extends AVAudioBuffer {
  floatChannelData: number;
  frameCapacity: number;
  frameLength: number;
  setFrameLength(_: number);
  int16ChannelData: number;
  int32ChannelData: number;
  stride: number;
  static initWithPCMFormatFrameCapacity(_: AVAudioFormat, frameCapacity: number): AVAudioPCMBuffer;
}

export class AVAudioPlayer extends NSObject {
  currentDevice: string;
  setCurrentDevice(_: string);
  currentTime: number;
  setCurrentTime(_: number);
  data: Data;
  delegate: any;
  setDelegate(_: any);
  deviceCurrentTime: number;
  duration: number;
  enableRate: boolean;
  setEnableRate(_: boolean);
  format: AVAudioFormat;
  isMeteringEnabled: boolean;
  setMeteringEnabled(_: boolean);
  numberOfChannels: number;
  numberOfLoops: number;
  setNumberOfLoops(_: number);
  pan: number;
  setPan(_: number);
  isPlaying: boolean;
  rate: number;
  setRate(_: number);
  settings: Map<string, any>;
  url: URL;
  volume: number;
  setVolume(_: number);
  averagePowerForChannel(forChannel: number): number;
  static initWithContentsOfURL(error: URL): AVAudioPlayer;
  static initWithContentsOfURLFileTypeHint(fileTypeHint: URL, error?: string): AVAudioPlayer;
  static initWithData(error: Data): AVAudioPlayer;
  static initWithDataFileTypeHint(fileTypeHint: Data, error?: string): AVAudioPlayer;
  pause(): void;
  peakPowerForChannel(forChannel: number): number;
  play(): boolean;
  playAtTime(atTime: number): boolean;
  prepareToPlay(): boolean;
  setVolumeFadeDuration(_: number, fadeDuration: number): void;
  stop(): void;
  updateMeters(): void;
}

interface AVAudioPlayerDelegate {
  audioPlayerDecodeErrorDidOccurError(_: AVAudioPlayer, error?: Error): void;
  audioPlayerDidFinishPlayingSuccessfully(_: AVAudioPlayer, successfully: boolean): void;
}

export class AVAudioPlayerNode extends AVAudioNode {
  isPlaying: boolean;
  nodeTimeForPlayerTime(forPlayerTime: AVAudioTime): AVAudioTime;
  pause(): void;
  play(): void;
  playAtTime(at?: AVAudioTime): void;
  playerTimeForNodeTime(forNodeTime: AVAudioTime): AVAudioTime;
  prepareWithFrameCount(withFrameCount: number): void;
  scheduleBufferAtTimeOptionsCompletionCallbackTypeCompletionHandler(_: AVAudioPCMBuffer, at?: AVAudioTime, options?: AVAudioPlayerNode.AVAudioPlayerNodeBufferOptions, completionCallbackType?: AVAudioPlayerNode.AVAudioPlayerNodeCompletionCallbackType, completionHandler?: (p1: AVAudioPlayerNode.AVAudioPlayerNodeCompletionCallbackType) => void): void;
  scheduleBufferAtTimeOptionsCompletionHandler(_: AVAudioPCMBuffer, at?: AVAudioTime, options?: AVAudioPlayerNode.AVAudioPlayerNodeBufferOptions, completionHandler?: () => void): void;
  scheduleBufferCompletionCallbackTypeCompletionHandler(_: AVAudioPCMBuffer, completionCallbackType: AVAudioPlayerNode.AVAudioPlayerNodeCompletionCallbackType, completionHandler?: (p1: AVAudioPlayerNode.AVAudioPlayerNodeCompletionCallbackType) => void): void;
  scheduleBufferCompletionHandler(_: AVAudioPCMBuffer, completionHandler?: () => void): void;
  scheduleFileAtTimeCompletionCallbackTypeCompletionHandler(_: AVAudioFile, at?: AVAudioTime, completionCallbackType?: AVAudioPlayerNode.AVAudioPlayerNodeCompletionCallbackType, completionHandler?: (p1: AVAudioPlayerNode.AVAudioPlayerNodeCompletionCallbackType) => void): void;
  scheduleFileAtTimeCompletionHandler(_: AVAudioFile, at?: AVAudioTime, completionHandler?: () => void): void;
  scheduleSegmentStartingFrameFrameCountAtTimeCompletionCallbackTypeCompletionHandler(_: AVAudioFile, startingFrame: number, frameCount: number, at?: AVAudioTime, completionCallbackType?: AVAudioPlayerNode.AVAudioPlayerNodeCompletionCallbackType, completionHandler?: (p1: AVAudioPlayerNode.AVAudioPlayerNodeCompletionCallbackType) => void): void;
  scheduleSegmentStartingFrameFrameCountAtTimeCompletionHandler(_: AVAudioFile, startingFrame: number, frameCount: number, at?: AVAudioTime, completionHandler?: () => void): void;
  stop(): void;
}

export class AVAudioRecorder extends NSObject {
  currentTime: number;
  delegate: any;
  setDelegate(_: any);
  deviceCurrentTime: number;
  format: AVAudioFormat;
  isMeteringEnabled: boolean;
  setMeteringEnabled(_: boolean);
  isRecording: boolean;
  settings: Map<string, any>;
  url: URL;
  averagePowerForChannel(forChannel: number): number;
  deleteRecording(): boolean;
  static initWithURLFormat(format: URL, error: AVAudioFormat): AVAudioRecorder;
  static initWithURLSettings(settings: URL, error: Map<string, any>): AVAudioRecorder;
  pause(): void;
  peakPowerForChannel(forChannel: number): number;
  prepareToRecord(): boolean;
  record(): boolean;
  recordAtTime(atTime: number): boolean;
  recordAtTimeForDuration(atTime: number, forDuration: number): boolean;
  recordForDuration(forDuration: number): boolean;
  stop(): void;
  updateMeters(): void;
}

interface AVAudioRecorderDelegate {
  audioRecorderDidFinishRecordingSuccessfully(_: AVAudioRecorder, successfully: boolean): void;
  audioRecorderEncodeErrorDidOccurError(_: AVAudioRecorder, error?: Error): void;
}

export class AVAudioSequencer extends NSObject {
  currentPositionInBeats: number;
  setCurrentPositionInBeats(_: number);
  currentPositionInSeconds: number;
  setCurrentPositionInSeconds(_: number);
  isPlaying: boolean;
  rate: number;
  setRate(_: number);
  tempoTrack: AVMusicTrack;
  tracks: AVMusicTrack[];
  userInfo: Map<string, any>;
  beatsForHostTime(forHostTime: number): number;
  beatsForSeconds(forSeconds: number): number;
  dataWithSMPTEResolution(withSMPTEResolution: number): Data;
  hostTimeForBeats(forBeats: number): number;
  static initWithAudioEngine(_: AVAudioEngine): AVAudioSequencer;
  loadFromDataOptions(options: Data, error: AVAudioSequencer.AVMusicSequenceLoadOptions): boolean;
  loadFromURLOptions(options: URL, error: AVAudioSequencer.AVMusicSequenceLoadOptions): boolean;
  prepareToPlay(): void;
  secondsForBeats(forBeats: number): number;
  startAndReturnError(): boolean;
  stop(): void;
  writeToURLSMPTEResolutionReplaceExisting(SMPTEResolution: URL, replaceExisting: number, error: boolean): boolean;
}

export class AVAudioSession extends NSObject {
}

export class AVAudioSessionChannelDescription extends NSObject {
}

export class AVAudioSessionDataSourceDescription extends NSObject {
}

interface AVAudioSessionDelegate {
}

export class AVAudioSessionPortDescription extends NSObject {
}

export class AVAudioSessionRouteDescription extends NSObject {
}

export class AVAudioSinkNode extends AVAudioNode {
  static initWithReceiverBlock(_: (p1: AudioTimeStamp, p2: number, p3: AudioBufferList) => number): AVAudioSinkNode;
}

export class AVAudioSourceNode extends AVAudioNode {
  static initWithFormatRenderBlock(_: AVAudioFormat, renderBlock: (p1: boolean, p2: AudioTimeStamp, p3: number, p4: AudioBufferList) => number): AVAudioSourceNode;
  static initWithRenderBlock(_: (p1: boolean, p2: AudioTimeStamp, p3: number, p4: AudioBufferList) => number): AVAudioSourceNode;
}

interface AVAudioStereoMixing {
  pan: number;
  setPan(_: number);
}

export class AVAudioTime extends NSObject {
  //  static hostTimeForSeconds(forSeconds: number): number;
  static secondsForHostTime(forHostTime: number): number;
  audioTimeStamp: AudioTimeStamp;
  hostTime: number;
  isHostTimeValid: boolean;
  sampleRate: number;
  sampleTime: number;
  isSampleTimeValid: boolean;
  extrapolateTimeFromAnchor(fromAnchor: AVAudioTime): AVAudioTime;
  static initWithAudioTimeStampSampleRate(_: AudioTimeStamp, sampleRate: number): AVAudioTime;
  static initWithHostTime(_: number): AVAudioTime;
  static initWithHostTimeSampleTimeAtRate(_: number, sampleTime: number, atRate: number): AVAudioTime;
  static initWithSampleTimeAtRate(_: number, atRate: number): AVAudioTime;
}

export class AVAudioUnit extends AVAudioNode {
  static instantiateWithComponentDescriptionOptionsCompletionHandler(with_: AudioComponentDescription, options: AudioComponent.AudioComponentInstantiationOptions, completionHandler?: (p1: AVAudioUnit, p2: Error) => void): void;
  audioComponentDescription: AudioComponentDescription;
  audioUnit: ComponentInstanceRecord;
  manufacturerName: string;
  //   version: number;
  loadAudioUnitPresetAtURL(error: URL): boolean;
}

export class AVAudioUnitComponent extends NSObject {
  allTagNames: string[];
  audioComponent: any;
  audioComponentDescription: AudioComponentDescription;
  availableArchitectures: number[];
  configurationDictionary: Map<string, any>;
  hasCustomView: boolean;
  hasMIDIInput: boolean;
  hasMIDIOutput: boolean;
  icon: NSImage;
  iconURL: URL;
  localizedTypeName: string;
  manufacturerName: string;
  name: string;
  passesAUVal: boolean;
  isSandboxSafe: boolean;
  typeName: string;
  userTagNames: string[];
  setUserTagNames(_: string[]);
  //   version: number;
  versionString: string;
  supportsNumberInputChannelsOutputChannels(_: number, outputChannels: number): boolean;
}

export class AVAudioUnitComponentManager extends NSObject {
  static sharedAudioUnitComponentManager(): AVAudioUnitComponentManager;
  standardLocalizedTagNames: string[];
  tagNames: string[];
  componentsMatchingDescription(matching: AudioComponentDescription): AVAudioUnitComponent[];
  componentsMatchingPredicate(matching: NSPredicate): AVAudioUnitComponent[];
  componentsPassingTest(passingTest: (p1: AVAudioUnitComponent, p2: boolean) => boolean): AVAudioUnitComponent[];
}

export class AVAudioUnitDelay extends AVAudioUnitEffect {
  delayTime: number;
  setDelayTime(_: number);
  feedback: number;
  setFeedback(_: number);
  lowPassCutoff: number;
  setLowPassCutoff(_: number);
  wetDryMix: number;
  setWetDryMix(_: number);
}

export class AVAudioUnitDistortion extends AVAudioUnitEffect {
  preGain: number;
  setPreGain(_: number);
  wetDryMix: number;
  setWetDryMix(_: number);
  loadFactoryPreset(_: AVAudioUnitDistortion.AVAudioUnitDistortionPreset): void;
}

export class AVAudioUnitEQ extends AVAudioUnitEffect {
  bands: AVAudioUnitEQFilterParameters[];
  globalGain: number;
  setGlobalGain(_: number);
  static initWithNumberOfBands(_: number): AVAudioUnitEQ;
}

export class AVAudioUnitEQFilterParameters extends NSObject {
  bandwidth: number;
  setBandwidth(_: number);
  bypass: boolean;
  setBypass(_: boolean);
  filterType: AVAudioUnitEQ.AVAudioUnitEQFilterType;
  setFilterType(_: AVAudioUnitEQ.AVAudioUnitEQFilterType);
  frequency: number;
  setFrequency(_: number);
  gain: number;
  setGain(_: number);
}

export class AVAudioUnitEffect extends AVAudioUnit {
  bypass: boolean;
  setBypass(_: boolean);
  static initWithAudioComponentDescription(_: AudioComponentDescription): AVAudioUnitEffect;
}

export class AVAudioUnitGenerator extends AVAudioUnit {
  bypass: boolean;
  setBypass(_: boolean);
  static initWithAudioComponentDescription(_: AudioComponentDescription): AVAudioUnitGenerator;
}

export class AVAudioUnitMIDIInstrument extends AVAudioUnit {
  static initWithAudioComponentDescription(_: AudioComponentDescription): AVAudioUnitMIDIInstrument;
  sendControllerWithValueOnChannel(_: number, withValue: number, onChannel: number): void;
  sendMIDIEventData1(_: number, data1: number): void;
  sendMIDIEventData1Data2(_: number, data1: number, data2: number): void;
  sendMIDISysExEvent(_: Data): void;
  sendPitchBendOnChannel(_: number, onChannel: number): void;
  sendPressureOnChannel(_: number, onChannel: number): void;
  sendPressureForKeyWithValueOnChannel(forKey: number, withValue: number, onChannel: number): void;
  sendProgramChangeBankMSBBankLSBOnChannel(_: number, bankMSB: number, bankLSB: number, onChannel: number): void;
  sendProgramChangeOnChannel(_: number, onChannel: number): void;
  startNoteWithVelocityOnChannel(_: number, withVelocity: number, onChannel: number): void;
  stopNoteOnChannel(_: number, onChannel: number): void;
}

export class AVAudioUnitReverb extends AVAudioUnitEffect {
  wetDryMix: number;
  setWetDryMix(_: number);
  loadFactoryPreset(_: AVAudioUnitReverb.AVAudioUnitReverbPreset): void;
}

export class AVAudioUnitSampler extends AVAudioUnitMIDIInstrument {
  globalTuning: number;
  setGlobalTuning(_: number);
  masterGain: number;
  setMasterGain(_: number);
  stereoPan: number;
  setStereoPan(_: number);
  loadAudioFilesAtURLs(error: URL[]): boolean;
  loadInstrumentAtURL(error: URL): boolean;
  loadSoundBankInstrumentAtURLProgramBankMSBBankLSB(program: URL, bankMSB: number, bankLSB: number, error: number): boolean;
}

export class AVAudioUnitTimeEffect extends AVAudioUnit {
  bypass: boolean;
  setBypass(_: boolean);
  static initWithAudioComponentDescription(_: AudioComponentDescription): AVAudioUnitTimeEffect;
}

export class AVAudioUnitTimePitch extends AVAudioUnitTimeEffect {
  overlap: number;
  setOverlap(_: number);
  pitch: number;
  setPitch(_: number);
  rate: number;
  setRate(_: number);
}

export class AVAudioUnitVarispeed extends AVAudioUnitTimeEffect {
  rate: number;
  setRate(_: number);
}

export class AVCameraCalibrationData extends NSObject {
  extrinsicMatrix: simd_float4x3;
  intrinsicMatrix: simd_float3x3;
  intrinsicMatrixReferenceDimensions: CGSize;
  inverseLensDistortionLookupTable: Data;
  lensDistortionCenter: CGPoint;
  lensDistortionLookupTable: Data;
  pixelSize: number;
}

export class AVCaptureAudioChannel extends NSObject {
  averagePowerLevel: number;
  isEnabled: boolean;
  setEnabled(_: boolean);
  peakHoldLevel: number;
  volume: number;
  setVolume(_: number);
}

export class AVCaptureAudioDataOutput extends AVCaptureOutput {
  audioSettings: Map<string, any>;
  setAudioSettings(_: Map<string, any>);
  sampleBufferCallbackQueue: NSObject;
  sampleBufferDelegate: any;
  recommendedAudioSettingsForAssetWriterWithOutputFileType(writingTo: string): Map<any, any>;
  setSampleBufferDelegateQueue(_?: any, queue?: NSObject): void;
}

interface AVCaptureAudioDataOutputSampleBufferDelegate {
  captureOutputDidOutputSampleBufferFromConnection(_: AVCaptureOutput, didOutput: any, from: AVCaptureConnection): void;
}

export class AVCaptureAudioFileOutput extends AVCaptureFileOutput {
  static availableOutputFileTypes(): string[];
  audioSettings: Map<string, any>;
  setAudioSettings(_: Map<string, any>);
  metadata: AVMetadataItem[];
  setMetadata(_: AVMetadataItem[]);
  startRecordingToOutputFileURLOutputFileTypeRecordingDelegate(to: URL, outputFileType: string, recordingDelegate: any): void;
}

export class AVCaptureAudioPreviewOutput extends AVCaptureOutput {
  outputDeviceUniqueID: string;
  setOutputDeviceUniqueID(_: string);
  volume: number;
  setVolume(_: number);
}

export class AVCaptureAutoExposureBracketedStillImageSettings extends AVCaptureBracketedStillImageSettings {
  static autoExposureSettingsWithExposureTargetBias(exposureTargetBias: number): AVCaptureAutoExposureBracketedStillImageSettings;
  exposureTargetBias: number;
}

export class AVCaptureBracketedStillImageSettings extends NSObject {
}

export class AVCaptureConnection extends NSObject {
  isActive: boolean;
  audioChannels: AVCaptureAudioChannel[];
  automaticallyAdjustsVideoMirroring: boolean;
  setAutomaticallyAdjustsVideoMirroring(_: boolean);
  isEnabled: boolean;
  setEnabled(_: boolean);
  inputPorts: AVCaptureInput.Port[];
  output: AVCaptureOutput;
  isVideoFieldModeSupported: boolean;
  isVideoMaxFrameDurationSupported: boolean;
  isVideoMinFrameDurationSupported: boolean;
  isVideoMirroringSupported: boolean;
  isVideoOrientationSupported: boolean;
  videoFieldMode: AVCaptureSession.AVVideoFieldMode;
  setVideoFieldMode(_: AVCaptureSession.AVVideoFieldMode);
  videoMaxFrameDuration: CMTime;
  setVideoMaxFrameDuration(_: CMTime);
  videoMinFrameDuration: CMTime;
  setVideoMinFrameDuration(_: CMTime);
  isVideoMirrored: boolean;
  setVideoMirrored(_: boolean);
  videoOrientation: AVCaptureSession.AVCaptureVideoOrientation;
  setVideoOrientation(_: AVCaptureSession.AVCaptureVideoOrientation);
  videoPreviewLayer: AVCaptureVideoPreviewLayer;
  static initWithInputPortVideoPreviewLayer(_: AVCaptureInput.Port, videoPreviewLayer: AVCaptureVideoPreviewLayer): AVCaptureConnection;
  static initWithInputPortsOutput(_: AVCaptureInput.Port[], output: AVCaptureOutput): AVCaptureConnection;
}

export class AVCaptureDataOutputSynchronizer extends NSObject {
  dataOutputs: AVCaptureOutput[];
  delegate: any;
  delegateCallbackQueue: NSObject;
  static initWithDataOutputs(_: AVCaptureOutput[]): AVCaptureDataOutputSynchronizer;
  setDelegateQueue(_?: any, queue?: NSObject): void;
}

interface AVCaptureDataOutputSynchronizerDelegate {
  dataOutputSynchronizerDidOutputSynchronizedDataCollection(_: AVCaptureDataOutputSynchronizer, didOutput: AVCaptureSynchronizedDataCollection): void;
}

export class AVCaptureDepthDataOutput extends AVCaptureOutput {
  alwaysDiscardsLateDepthData: boolean;
  setAlwaysDiscardsLateDepthData(_: boolean);
  delegate: any;
  delegateCallbackQueue: NSObject;
  isFilteringEnabled: boolean;
  setFilteringEnabled(_: boolean);
  setDelegateCallbackQueue(_?: any, callbackQueue?: NSObject): void;
}

interface AVCaptureDepthDataOutputDelegate {
  depthDataOutputDidOutputDepthDataTimestampConnection(_: AVCaptureDepthDataOutput, didOutput: AVDepthData, timestamp: CMTime, connection: AVCaptureConnection): void;
  depthDataOutputDidDropDepthDataTimestampConnectionReason(_: AVCaptureDepthDataOutput, didDrop: AVDepthData, timestamp: CMTime, connection: AVCaptureConnection, reason: AVCaptureOutputBase.AVCaptureOutput.DataDroppedReason): void;
}

export class AVCaptureDevice extends NSObject {
  static authorizationStatusForMediaType(for_: string): AVCaptureDevice.AVAuthorizationStatus;
  static defaultDeviceWithDeviceTypeMediaTypePosition(_: string, for_?: string, position?: AVCaptureDevice.Position): AVCaptureDevice;
  static defaultDeviceWithMediaType(for_: string): AVCaptureDevice;
  static requestAccessForMediaTypeCompletionHandler(for_: string, completionHandler: (p1: boolean) => void): void;
  activeColorSpace: AVCaptureDevice.AVCaptureColorSpace;
  setActiveColorSpace(_: AVCaptureDevice.AVCaptureColorSpace);
  activeFormat: AVCaptureDevice.Format;
  setActiveFormat(_: AVCaptureDevice.Format);
  activeInputSource: AVCaptureDevice.InputSource;
  setActiveInputSource(_: AVCaptureDevice.InputSource);
  activeVideoMaxFrameDuration: CMTime;
  setActiveVideoMaxFrameDuration(_: CMTime);
  activeVideoMinFrameDuration: CMTime;
  setActiveVideoMinFrameDuration(_: CMTime);
  isAdjustingExposure: boolean;
  isAdjustingFocus: boolean;
  isAdjustingWhiteBalance: boolean;
  isConnected: boolean;
  deviceType: string;
  exposureMode: AVCaptureDevice.ExposureMode;
  setExposureMode(_: AVCaptureDevice.ExposureMode);
  exposurePointOfInterest: CGPoint;
  setExposurePointOfInterest(_: CGPoint);
  isExposurePointOfInterestSupported: boolean;
  isFlashAvailable: boolean;
  flashMode: AVCaptureDevice.FlashMode;
  setFlashMode(_: AVCaptureDevice.FlashMode);
  focusMode: AVCaptureDevice.FocusMode;
  setFocusMode(_: AVCaptureDevice.FocusMode);
  focusPointOfInterest: CGPoint;
  setFocusPointOfInterest(_: CGPoint);
  isFocusPointOfInterestSupported: boolean;
  formats: AVCaptureDevice.Format[];
  hasFlash: boolean;
  hasTorch: boolean;
  isInUseByAnotherApplication: boolean;
  inputSources: AVCaptureDevice.InputSource[];
  linkedDevices: AVCaptureDevice[];
  localizedName: string;
  manufacturer: string;
  modelID: string;
  position: AVCaptureDevice.Position;
  isSuspended: boolean;
  isTorchActive: boolean;
  isTorchAvailable: boolean;
  torchLevel: number;
  torchMode: AVCaptureDevice.TorchMode;
  setTorchMode(_: AVCaptureDevice.TorchMode);
  transportControlsPlaybackMode: AVCaptureDevice.TransportControlsPlaybackMode;
  transportControlsSpeed: number;
  transportControlsSupported: boolean;
  transportType: number;
  uniqueID: string;
  whiteBalanceMode: AVCaptureDevice.WhiteBalanceMode;
  setWhiteBalanceMode(_: AVCaptureDevice.WhiteBalanceMode);
  hasMediaType(_: string): boolean;
  isExposureModeSupported(_: AVCaptureDevice.ExposureMode): boolean;
  isFlashModeSupported(_: AVCaptureDevice.FlashMode): boolean;
  isFocusModeSupported(_: AVCaptureDevice.FocusMode): boolean;
  isTorchModeSupported(_: AVCaptureDevice.TorchMode): boolean;
  isWhiteBalanceModeSupported(_: AVCaptureDevice.WhiteBalanceMode): boolean;
  lockForConfiguration(): boolean;
  setTorchModeOnWithLevel(level: number): boolean;
  setTransportControlsPlaybackModeSpeed(_: AVCaptureDevice.TransportControlsPlaybackMode, speed: number): void;
  supportsAVCaptureSessionPreset(_: string): boolean;
  unlockForConfiguration(): void;
}

export class AVCaptureDeviceInput extends AVCaptureInput {
  static deviceInputWithDevice(error: AVCaptureDevice): AVCaptureDeviceInput;
  device: AVCaptureDevice;
  static initWithDevice(error: AVCaptureDevice): AVCaptureDeviceInput;
}

export class AVCaptureFileOutput extends AVCaptureOutput {
  delegate: any;
  setDelegate(_: any);
  maxRecordedDuration: CMTime;
  setMaxRecordedDuration(_: CMTime);
  maxRecordedFileSize: number;
  setMaxRecordedFileSize(_: number);
  minFreeDiskSpaceLimit: number;
  setMinFreeDiskSpaceLimit(_: number);
  outputFileURL: URL;
  recordedDuration: CMTime;
  recordedFileSize: number;
  isRecording: boolean;
  isRecordingPaused: boolean;
  pauseRecording(): void;
  resumeRecording(): void;
  startRecordingToOutputFileURLRecordingDelegate(to: URL, recordingDelegate: any): void;
  stopRecording(): void;
}

interface AVCaptureFileOutputDelegate {
  captureOutputDidOutputSampleBufferFromConnection(_: AVCaptureFileOutput, didOutputSampleBuffer: any, from: AVCaptureConnection): void;
  captureOutputShouldProvideSampleAccurateRecordingStart(_: AVCaptureOutput): boolean;
}

interface AVCaptureFileOutputRecordingDelegate {
  captureOutputDidStartRecordingToOutputFileAtURLFromConnections(_: AVCaptureFileOutput, didStartRecordingTo: URL, from: AVCaptureConnection[]): void;
  captureOutputDidPauseRecordingToOutputFileAtURLFromConnections(_: AVCaptureFileOutput, didPauseRecordingTo: URL, from: AVCaptureConnection[]): void;
  captureOutputDidResumeRecordingToOutputFileAtURLFromConnections(_: AVCaptureFileOutput, didResumeRecordingTo: URL, from: AVCaptureConnection[]): void;
  captureOutputWillFinishRecordingToOutputFileAtURLFromConnectionsError(_: AVCaptureFileOutput, willFinishRecordingTo: URL, from: AVCaptureConnection[], error?: Error): void;
  captureOutputDidFinishRecordingToOutputFileAtURLFromConnectionsError(_: AVCaptureFileOutput, didFinishRecordingTo: URL, from: AVCaptureConnection[], error?: Error): void;
}

export class AVCaptureInput extends NSObject {
  ports: AVCaptureInput.Port[];
}

export class AVCaptureManualExposureBracketedStillImageSettings extends AVCaptureBracketedStillImageSettings {
  static manualExposureSettingsWithExposureDurationISO(exposureDuration: CMTime, iso: number): AVCaptureManualExposureBracketedStillImageSettings;
  ISO: number;
  exposureDuration: CMTime;
}

export class AVCaptureMetadataInput extends AVCaptureInput {
  appendTimedMetadataGroup(error: AVTimedMetadataGroup): boolean;
  static initWithFormatDescriptionClock(_: any, clock: any): AVCaptureMetadataInput;
}

export class AVCaptureMetadataOutput extends AVCaptureOutput {
  availableMetadataObjectTypes: string[];
  metadataObjectTypes: string[];
  setMetadataObjectTypes(_: string[]);
  metadataObjectsCallbackQueue: NSObject;
  metadataObjectsDelegate: any;
  rectOfInterest: CGRect;
  setRectOfInterest(_: CGRect);
  setMetadataObjectsDelegateQueue(_?: any, queue?: NSObject): void;
}

interface AVCaptureMetadataOutputObjectsDelegate {
  captureOutputDidOutputMetadataObjectsFromConnection(_: AVCaptureOutput, didOutput: AVMetadataObject[], from: AVCaptureConnection): void;
}

export class AVCaptureMovieFileOutput extends AVCaptureFileOutput {
  metadata: AVMetadataItem[];
  setMetadata(_: AVMetadataItem[]);
  movieFragmentInterval: CMTime;
  setMovieFragmentInterval(_: CMTime);
  outputSettingsForConnection(for_: AVCaptureConnection): Map<string, any>;
  setOutputSettingsForConnection(_?: Map<string, any>, for_?: AVCaptureConnection): void;
}

export class AVCaptureMultiCamSession extends AVCaptureSession {
  hardwareCost: number;
  systemPressureCost: number;
  static isMultiCamSupported: boolean;
}

export class AVCaptureOutput extends NSObject {
  connections: AVCaptureConnection[];
  connectionWithMediaType(with_: string): AVCaptureConnection;
  metadataOutputRectOfInterestForRect(fromOutputRect: CGRect): CGRect;
  rectForMetadataOutputRectOfInterest(fromMetadataOutputRect: CGRect): CGRect;
  transformedMetadataObjectForMetadataObjectConnection(for_: AVMetadataObject, connection: AVCaptureConnection): AVMetadataObject;
}

export class AVCapturePhoto extends NSObject {
  photoCount: number;
  pixelBuffer: any;
  resolvedSettings: AVCaptureResolvedPhotoSettings;
  timestamp: CMTime;
  cGImageRepresentation(): any;
  fileDataRepresentation(): Data;
}

export class AVCapturePhotoBracketSettings extends AVCapturePhotoSettings {
  bracketedSettings: AVCaptureBracketedStillImageSettings[];
  isLensStabilizationEnabled: boolean;
  setLensStabilizationEnabled(_: boolean);
}

interface AVCapturePhotoCaptureDelegate {
  captureOutputWillBeginCaptureForResolvedSettings(_: AVCapturePhotoOutput, willBeginCaptureFor: AVCaptureResolvedPhotoSettings): void;
  captureOutputWillCapturePhotoForResolvedSettings(_: AVCapturePhotoOutput, willCapturePhotoFor: AVCaptureResolvedPhotoSettings): void;
  captureOutputDidCapturePhotoForResolvedSettings(_: AVCapturePhotoOutput, didCapturePhotoFor: AVCaptureResolvedPhotoSettings): void;
  captureOutputDidFinishProcessingPhotoError(_: AVCapturePhotoOutput, didFinishProcessingPhoto: AVCapturePhoto, error?: Error): void;
  captureOutputDidFinishCaptureForResolvedSettingsError(_: AVCapturePhotoOutput, didFinishCaptureFor: AVCaptureResolvedPhotoSettings, error?: Error): void;
}

interface AVCapturePhotoFileDataRepresentationCustomizer {
  replacementDepthDataForPhoto(for_: AVCapturePhoto): AVDepthData;
  replacementEmbeddedThumbnailPixelBufferWithPhotoFormatForPhoto(withPhotoFormat?: Map<string, any>, for_?: AVCapturePhoto): any;
  replacementMetadataForPhoto(for_: AVCapturePhoto): Map<string, any>;
  replacementPortraitEffectsMatteForPhoto(for_: AVCapturePhoto): AVPortraitEffectsMatte;
  replacementSemanticSegmentationMatteOfTypeForPhoto(ofType: string, for_: AVCapturePhoto): AVSemanticSegmentationMatte;
}

export class AVCapturePhotoOutput extends AVCaptureOutput {
  availablePhotoCodecTypes: string[];
  availablePhotoFileTypes: string[];
  availablePhotoPixelFormatTypes: number[];
  capturePhotoWithSettingsDelegate(with_: AVCapturePhotoSettings, delegate: any): void;
  supportedPhotoCodecTypesForFileType(for_: string): string[];
  supportedPhotoPixelFormatTypesForFileType(for_: string): number[];
}

export class AVCapturePhotoSettings extends NSObject {
  format: Map<string, any>;
  processedFileType: string;
  uniqueID: number;
}

export class AVCaptureResolvedPhotoSettings extends NSObject {
  expectedPhotoCount: number;
  photoDimensions: CMVideoDimensions;
  uniqueID: number;
}

export class AVCaptureScreenInput extends AVCaptureInput {
  capturesCursor: boolean;
  setCapturesCursor(_: boolean);
  capturesMouseClicks: boolean;
  setCapturesMouseClicks(_: boolean);
  cropRect: CGRect;
  setCropRect(_: CGRect);
  minFrameDuration: CMTime;
  setMinFrameDuration(_: CMTime);
  scaleFactor: number;
  setScaleFactor(_: number);
  static initWithDisplayID(_: number): AVCaptureScreenInput;
}

export class AVCaptureSession extends NSObject {
  connections: AVCaptureConnection[];
  inputs: AVCaptureInput[];
  masterClock: any;
  outputs: AVCaptureOutput[];
  isRunning: boolean;
  sessionPreset: string;
  setSessionPreset(_: string);
  addConnection(_: AVCaptureConnection): void;
  addInput(_: AVCaptureInput): void;
  addInputWithNoConnections(_: AVCaptureInput): void;
  addOutput(_: AVCaptureOutput): void;
  addOutputWithNoConnections(_: AVCaptureOutput): void;
  beginConfiguration(): void;
  canAddConnection(_: AVCaptureConnection): boolean;
  canAddInput(_: AVCaptureInput): boolean;
  canAddOutput(_: AVCaptureOutput): boolean;
  canSetSessionPreset(_: string): boolean;
  commitConfiguration(): void;
  removeConnection(_: AVCaptureConnection): void;
  removeInput(_: AVCaptureInput): void;
  removeOutput(_: AVCaptureOutput): void;
  startRunning(): void;
  stopRunning(): void;
}

export class AVCaptureSynchronizedData extends NSObject {
  timestamp: CMTime;
}

export class AVCaptureSynchronizedDataCollection extends NSObject {
  count: number;
  synchronizedDataForCaptureOutput(for_: AVCaptureOutput): AVCaptureSynchronizedData;
}

export class AVCaptureSynchronizedDepthData extends AVCaptureSynchronizedData {
  depthData: AVDepthData;
  depthDataWasDropped: boolean;
  droppedReason: AVCaptureOutputBase.AVCaptureOutput.DataDroppedReason;
}

export class AVCaptureSynchronizedMetadataObjectData extends AVCaptureSynchronizedData {
  metadataObjects: AVMetadataObject[];
}

export class AVCaptureSynchronizedSampleBufferData extends AVCaptureSynchronizedData {
  droppedReason: AVCaptureOutputBase.AVCaptureOutput.DataDroppedReason;
  sampleBuffer: any;
  sampleBufferWasDropped: boolean;
}

export class AVCaptureVideoDataOutput extends AVCaptureOutput {
  alwaysDiscardsLateVideoFrames: boolean;
  setAlwaysDiscardsLateVideoFrames(_: boolean);
  availableVideoCVPixelFormatTypes: number[];
  availableVideoCodecTypes: string[];
  sampleBufferCallbackQueue: NSObject;
  sampleBufferDelegate: any;
  videoSettings: Map<string, any>;
  setVideoSettings(_: Map<string, any>);
  availableVideoCodecTypesForAssetWriterWithOutputFileType(writingTo: string): string[];
  recommendedVideoSettingsForAssetWriterWithOutputFileType(writingTo: string): Map<string, any>;
  recommendedVideoSettingsForVideoCodecTypeAssetWriterOutputFileType(forVideoCodecType: string, assetWriterOutputFileType: string): Map<any, any>;
  setSampleBufferDelegateQueue(_?: any, queue?: NSObject): void;
}

interface AVCaptureVideoDataOutputSampleBufferDelegate {
  captureOutputDidOutputSampleBufferFromConnection(_: AVCaptureOutput, didOutput: any, from: AVCaptureConnection): void;
  captureOutputDidDropSampleBufferFromConnection(_: AVCaptureOutput, didDrop: any, from: AVCaptureConnection): void;
}

export class AVCaptureVideoPreviewLayer extends CALayer {
  connection: AVCaptureConnection;
  session: AVCaptureSession;
  setSession(_: AVCaptureSession);
  videoGravity: string;
  setVideoGravity(_: string);
  captureDevicePointOfInterestForPoint(fromLayerPoint: CGPoint): CGPoint;
  static initWithSession(_: AVCaptureSession): AVCaptureVideoPreviewLayer;
  static initWithSessionWithNoConnection(_: AVCaptureSession): AVCaptureVideoPreviewLayer;
  metadataOutputRectOfInterestForRect(fromLayerRect: CGRect): CGRect;
  pointForCaptureDevicePointOfInterest(fromCaptureDevicePoint: CGPoint): CGPoint;
  rectForMetadataOutputRectOfInterest(fromMetadataOutputRect: CGRect): CGRect;
  setSessionWithNoConnection(_: AVCaptureSession): void;
  transformedMetadataObjectForMetadataObject(for_: AVMetadataObject): AVMetadataObject;
}

export class AVComposition extends AVAsset {
  URLAssetInitializationOptions: Map<string, any>;
  naturalSize: CGSize;
  trackWithTrackID(withTrackID: number): AVCompositionTrack;
}

export class AVCompositionTrack extends AVAssetTrack {
  formatDescriptionReplacements: AVCompositionTrackFormatDescriptionReplacement[];
  segmentForTrackTime(forTrackTime: CMTime): AVCompositionTrackSegment;
}

export class AVCompositionTrackFormatDescriptionReplacement extends NSObject {
  originalFormatDescription: any;
  replacementFormatDescription: any;
}

export class AVCompositionTrackSegment extends AVAssetTrackSegment {
  sourceTrackID: number;
  sourceURL: URL;
  static initWithTimeRange(_: CMTimeRange): AVCompositionTrackSegment;
  static initWithURLTrackIDSourceTimeRangeTargetTimeRange(_: URL, trackID: number, sourceTimeRange: CMTimeRange, targetTimeRange: CMTimeRange): AVCompositionTrackSegment;
}

interface AVContentKeyRecipient {
  mayRequireContentKeysForMediaDataProcessing: boolean;
}

export class AVContentKeyRequest extends NSObject {
  canProvidePersistableContentKey: boolean;
  error: Error;
  identifier: any;
  initializationData: Data;
  options: Map<string, any>;
  renewsExpiringResponseData: boolean;
  status: AVContentKeySession.AVContentKeyRequest.Status;
  makeStreamingContentKeyRequestDataForAppContentIdentifierOptionsCompletionHandler(forApp: Data, contentIdentifier?: Data, options?: Map<string, any>, completionHandler?: (p1: Data, p2: Error) => void): void;
  processContentKeyResponse(_: AVContentKeyResponse): void;
  processContentKeyResponseError(_: Error): void;
  respondByRequestingPersistableContentKeyRequestAndReturnError(): boolean;
}

export class AVContentKeyResponse extends NSObject {
}

export class AVContentKeySession extends NSObject {
  static pendingExpiredSessionReportsWithAppIdentifierStorageDirectoryAtURL(withAppIdentifier: Data, storageDirectoryAt: URL): Data[];
  static removePendingExpiredSessionReportsWithAppIdentifierStorageDirectoryAtURL(_: Data[], withAppIdentifier: Data, storageDirectoryAt: URL): void;
  contentKeyRecipients: any[];
  contentProtectionSessionIdentifier: Data;
  delegate: any;
  delegateQueue: NSObject;
  keySystem: string;
  storageURL: URL;
  addContentKeyRecipient(_: any): void;
  expire(): void;
  invalidateAllPersistableContentKeysForAppOptionsCompletionHandler(forApp: Data, options?: Map<string, any>, completionHandler?: (p1: Data, p2: Error) => void): void;
  invalidatePersistableContentKeyOptionsCompletionHandler(_: Data, options?: Map<string, any>, completionHandler?: (p1: Data, p2: Error) => void): void;
  makeSecureTokenForExpirationDateOfPersistableContentKeyCompletionHandler(ofPersistableContentKey: Data, completionHandler?: (p1: Data, p2: Error) => void): void;
  processContentKeyRequestWithIdentifierInitializationDataOptions(withIdentifier?: any, initializationData?: Data, options?: Map<string, any>): void;
  removeContentKeyRecipient(_: any): void;
  renewExpiringResponseDataForContentKeyRequest(for_: AVContentKeyRequest): void;
  setDelegateQueue(_?: any, queue?: NSObject): void;
}

interface AVContentKeySessionDelegate {
  contentKeySessionDidProvideContentKeyRequest(_: AVContentKeySession, didProvide: AVContentKeyRequest): void;
  contentKeySessionDidProvideRenewingContentKeyRequest(_: AVContentKeySession, didProvideRenewingContentKeyRequest: AVContentKeyRequest): void;
  contentKeySessionDidProvidePersistableContentKeyRequest(_: AVContentKeySession, didProvide: AVPersistableContentKeyRequest): void;
  contentKeySessionDidUpdatePersistableContentKeyForContentKeyIdentifier(_: AVContentKeySession, didUpdatePersistableContentKey: Data, forContentKeyIdentifier: any): void;
  contentKeySessionContentKeyRequestDidFailWithError(_: AVContentKeySession, contentKeyRequest: AVContentKeyRequest, didFailWithError: Error): void;
  contentKeySessionShouldRetryContentKeyRequestReason(_: AVContentKeySession, shouldRetry: AVContentKeyRequest, reason: string): boolean;
  contentKeySessionContentKeyRequestDidSucceed(_: AVContentKeySession, contentKeyRequestDidSucceed: AVContentKeyRequest): void;
  contentKeySessionContentProtectionSessionIdentifierDidChange(_: AVContentKeySession): void;
  contentKeySessionDidGenerateExpiredSessionReport(_: AVContentKeySession): void;
}

export class AVDateRangeMetadataGroup extends AVMetadataGroup {
  endDate: Date;
  startDate: Date;
  static initWithItemsStartDateEndDate(_: AVMetadataItem[], startDate: Date, endDate?: Date): AVDateRangeMetadataGroup;
}

export class AVDepthData extends NSObject {
  static depthDataFromDictionaryRepresentation(error: Map<any, any>): AVDepthData;
  availableDepthDataTypes: number[];
  cameraCalibrationData: AVCameraCalibrationData;
  depthDataAccuracy: AVDepthData.Accuracy;
  isDepthDataFiltered: boolean;
  depthDataMap: any;
  depthDataQuality: AVDepthData.Quality;
  depthDataType: number;
  depthDataByApplyingExifOrientation(_: CGImageProperties.CGImagePropertyOrientation): AVDepthData;
  depthDataByConvertingToDepthDataType(toDepthDataType: number): AVDepthData;
  depthDataByReplacingDepthDataMapWithPixelBuffer(error: any): AVDepthData;
  dictionaryRepresentationForAuxiliaryDataType(forAuxiliaryDataType?: string): Map<any, any>;
}

interface AVFragmentMinding {
  isAssociatedWithFragmentMinder: boolean;
}

export class AVFragmentedAsset extends AVURLAsset {
  trackWithTrackID(withTrackID: number): AVFragmentedAssetTrack;
}

export class AVFragmentedAssetMinder extends NSObject {
  assets: AVAsset[];
  mindingInterval: number;
  setMindingInterval(_: number);
  addFragmentedAsset(_: AVAsset): void;
  static initWithAssetMindingInterval(_: AVAsset, mindingInterval: number): AVFragmentedAssetMinder;
  removeFragmentedAsset(_: AVAsset): void;
}

export class AVFragmentedAssetTrack extends AVAssetTrack {
}

export class AVFragmentedMovie extends AVMovie {
  trackWithTrackID(withTrackID: number): AVFragmentedMovieTrack;
}

export class AVFragmentedMovieMinder extends AVFragmentedAssetMinder {
  movies: AVFragmentedMovie[];
  addFragmentedMovie(_: AVFragmentedMovie): void;
  static initWithMovieMindingInterval(_: AVFragmentedMovie, mindingInterval: number): AVFragmentedMovieMinder;
  removeFragmentedMovie(_: AVFragmentedMovie): void;
}

export class AVFragmentedMovieTrack extends AVMovieTrack {
}

export class AVFrameRateRange extends NSObject {
  maxFrameDuration: CMTime;
  maxFrameRate: number;
  minFrameDuration: CMTime;
  minFrameRate: number;
}

export class AVMIDIPlayer extends NSObject {
  currentPosition: number;
  setCurrentPosition(_: number);
  duration: number;
  isPlaying: boolean;
  rate: number;
  setRate(_: number);
  static initWithContentsOfURLSoundBankURL(soundBankURL: URL, error?: URL): AVMIDIPlayer;
  static initWithDataSoundBankURL(soundBankURL: Data, error?: URL): AVMIDIPlayer;
  play(_?: () => void): void;
  prepareToPlay(): void;
  stop(): void;
}

// export function AVMakeRectWithAspectRatioInsideRect(aspectRatio: CGSize, boundingRect: CGRect): CGRect;

export class AVMediaDataStorage extends NSObject {
  uRL(): URL;
  static initWithURLOptions(_: URL, options?: Map<string, any>): AVMediaDataStorage;
}

export class AVMediaSelection extends NSObject {
  asset: AVAsset;
  mediaSelectionCriteriaCanBeAppliedAutomaticallyToMediaSelectionGroup(to: AVMediaSelectionGroup): boolean;
  selectedMediaOptionInMediaSelectionGroup(in_: AVMediaSelectionGroup): AVMediaSelectionOption;
}

export class AVMediaSelectionGroup extends NSObject {
  static mediaSelectionOptionsFromArrayFilteredAndSortedAccordingToPreferredLanguages(from: AVMediaSelectionOption[], filteredAndSortedAccordingToPreferredLanguages: string[]): AVMediaSelectionOption[];
  static mediaSelectionOptionsFromArrayWithLocale(from: AVMediaSelectionOption[], with_: Locale): AVMediaSelectionOption[];
  static mediaSelectionOptionsFromArrayWithMediaCharacteristics(from: AVMediaSelectionOption[], withMediaCharacteristics: string[]): AVMediaSelectionOption[];
  static mediaSelectionOptionsFromArrayWithoutMediaCharacteristics(from: AVMediaSelectionOption[], withoutMediaCharacteristics: string[]): AVMediaSelectionOption[];
  static playableMediaSelectionOptionsFromArray(from: AVMediaSelectionOption[]): AVMediaSelectionOption[];
  allowsEmptySelection: boolean;
  defaultOption: AVMediaSelectionOption;
  options: AVMediaSelectionOption[];
  mediaSelectionOptionWithPropertyList(withPropertyList: any): AVMediaSelectionOption;
}

export class AVMediaSelectionOption extends NSObject {
  availableMetadataFormats: string[];
  commonMetadata: AVMetadataItem[];
  displayName: string;
  extendedLanguageTag: string;
  locale: Locale;
  mediaSubTypes: number[];
  mediaType: string;
  isPlayable: boolean;
  associatedMediaSelectionOptionInMediaSelectionGroup(in_: AVMediaSelectionGroup): AVMediaSelectionOption;
  // dupe name w instance property   displayNameWithLocale(with_: Locale): string;
  hasMediaCharacteristic(_: string): boolean;
  metadataForFormat(forFormat: string): AVMetadataItem[];
  propertyList(): any;
}

export class AVMetadataBodyObject extends AVMetadataObject {
  bodyID: number;
}

export class AVMetadataCatBodyObject extends AVMetadataBodyObject {
}

export class AVMetadataDogBodyObject extends AVMetadataBodyObject {
}

export class AVMetadataFaceObject extends AVMetadataObject {
  faceID: number;
  hasRollAngle: boolean;
  hasYawAngle: boolean;
  rollAngle: number;
  yawAngle: number;
}

export class AVMetadataGroup extends NSObject {
  classifyingLabel: string;
  items: AVMetadataItem[];
  uniqueID: string;
}

export class AVMetadataHumanBodyObject extends AVMetadataBodyObject {
}

export class AVMetadataItem extends NSObject {
  //  static identifierForKeyKeySpace(forKey: any, keySpace: string): string;
  //  static keyForIdentifier(forIdentifier: string): any;
  //  static keySpaceForIdentifier(forIdentifier: string): string;
  static metadataItemsFromArrayFilteredAndSortedAccordingToPreferredLanguages(from: AVMetadataItem[], filteredAndSortedAccordingToPreferredLanguages: string[]): AVMetadataItem[];
  static metadataItemsFromArrayFilteredByIdentifier(from: AVMetadataItem[], filteredByIdentifier: string): AVMetadataItem[];
  static metadataItemsFromArrayFilteredByMetadataItemFilter(from: AVMetadataItem[], filteredBy: AVMetadataItemFilter): AVMetadataItem[];
  static metadataItemsFromArrayWithKeyKeySpace(from: AVMetadataItem[], withKey?: any, keySpace?: string): AVMetadataItem[];
  static metadataItemsFromArrayWithLocale(from: AVMetadataItem[], with_: Locale): AVMetadataItem[];
  commonKey: string;
  dataType: string;
  dataValue: Data;
  dateValue: Date;
  duration: CMTime;
  extendedLanguageTag: string;
  extraAttributes: Map<string, any>;
  identifier: string;
  key: any;
  keySpace: string;
  locale: Locale;
  numberValue: number;
  startDate: Date;
  stringValue: string;
  time: CMTime;
}

export class AVMetadataItemFilter extends NSObject {
  static metadataItemFilterForSharing(): AVMetadataItemFilter;
}

export class AVMetadataItemValueRequest extends NSObject {
  metadataItem: AVMetadataItem;
  respondWithError(error: Error): void;
  respondWithValue(value: any): void;
}

export class AVMetadataMachineReadableCodeObject extends AVMetadataObject {
  corners: Map<any, any>[];
  descriptor: CIBarcodeDescriptor;
  stringValue: string;
}

export class AVMetadataObject extends NSObject {
  bounds: CGRect;
  duration: CMTime;
  time: CMTime;
  type: string;
}

export class AVMetadataSalientObject extends AVMetadataObject {
  objectID: number;
}

export class AVMovie extends AVAsset {
  static movieTypes(): string[];
  URL: URL;
  canContainMovieFragments: boolean;
  containsMovieFragments: boolean;
  data: Data;
  defaultMediaDataStorage: AVMediaDataStorage;
  static initWithDataOptions(_: Data, options?: Map<string, any>): AVMovie;
  static initWithURLOptions(_: URL, options?: Map<string, any>): AVMovie;
  isCompatibleWithFileType(compatibleWithFileType: string): boolean;
  movieHeaderWithFileType(fileType: string): Data;
  trackWithTrackID(withTrackID: number): AVMovieTrack;
  writeMovieHeaderToURLFileTypeOptions(fileType: URL, options: string, error: AVMovie.AVMovieWritingOptions): boolean;
}

export class AVMovieTrack extends AVAssetTrack {
  alternateGroupID: number;
  mediaDataStorage: AVMediaDataStorage;
  mediaDecodeTimeRange: CMTimeRange;
  mediaPresentationTimeRange: CMTimeRange;
}

export class AVMusicTrack extends NSObject {
  destinationAudioUnit: AVAudioUnit;
  setDestinationAudioUnit(_: AVAudioUnit);
  destinationMIDIEndpoint: number;
  setDestinationMIDIEndpoint(_: number);
  lengthInBeats: number;
  setLengthInBeats(_: number);
  lengthInSeconds: number;
  setLengthInSeconds(_: number);
  loopRange: AVBeatRange;
  setLoopRange(_: AVBeatRange);
  isLoopingEnabled: boolean;
  setLoopingEnabled(_: boolean);
  isMuted: boolean;
  setMuted(_: boolean);
  numberOfLoops: number;
  setNumberOfLoops(_: number);
  offsetTime: number;
  setOffsetTime(_: number);
  isSoloed: boolean;
  setSoloed(_: boolean);
  timeResolution: number;
}

export class AVMutableAudioMix extends AVAudioMix {
  inputParameters: AVAudioMixInputParameters[];
  setInputParameters(_: AVAudioMixInputParameters[]);
}

export class AVMutableAudioMixInputParameters extends AVAudioMixInputParameters {
  audioTapProcessor: any;
  setAudioTapProcessor(_: any);
  audioTimePitchAlgorithm: string;
  setAudioTimePitchAlgorithm(_: string);
  trackID: number;
  setTrackID(_: number);
  setVolumeAtTime(_: number, at: CMTime): void;
  setVolumeRampFromStartVolumeToEndVolumeTimeRange(fromStartVolume: number, toEndVolume: number, timeRange: CMTimeRange): void;
}

export class AVMutableComposition extends AVComposition {
  naturalSize: CGSize;
  setNaturalSize(_: CGSize);
  addMutableTrackWithMediaTypePreferredTrackID(withMediaType: string, preferredTrackID: number): AVMutableCompositionTrack;
  insertEmptyTimeRange(_: CMTimeRange): void;
  insertTimeRangeOfAssetAtTime(_: CMTimeRange, of: AVAsset, at: CMTime): boolean;
  mutableTrackCompatibleWithTrack(compatibleWith: AVAssetTrack): AVMutableCompositionTrack;
  removeTimeRange(_: CMTimeRange): void;
  removeTrack(_: AVCompositionTrack): void;
  scaleTimeRangeToDuration(_: CMTimeRange, toDuration: CMTime): void;
  trackWithTrackID(withTrackID: number): AVMutableCompositionTrack;
}

export class AVMutableCompositionTrack extends AVCompositionTrack {
  isEnabled: boolean;
  setEnabled(_: boolean);
  extendedLanguageTag: string;
  setExtendedLanguageTag(_: string);
  languageCode: string;
  setLanguageCode(_: string);
  naturalTimeScale: number;
  setNaturalTimeScale(_: number);
  preferredTransform: CGAffineTransform;
  setPreferredTransform(_: CGAffineTransform);
  preferredVolume: number;
  setPreferredVolume(_: number);
  segments: AVCompositionTrackSegment[];
  setSegments(_: AVCompositionTrackSegment[]);
  addTrackAssociationToTrackType(to: AVCompositionTrack, type: string): void;
  insertEmptyTimeRange(_: CMTimeRange): void;
  insertTimeRangeOfTrackAtTime(ofTrack: CMTimeRange, atTime: AVAssetTrack, error: CMTime): boolean;
  insertTimeRangesOfTracksAtTime(ofTracks: NSValue[], atTime: AVAssetTrack[], error: CMTime): boolean;
  removeTimeRange(_: CMTimeRange): void;
  removeTrackAssociationToTrackType(to: AVCompositionTrack, type: string): void;
  replaceFormatDescriptionWithFormatDescription(_: any, with_?: any): void;
  scaleTimeRangeToDuration(_: CMTimeRange, toDuration: CMTime): void;
  validateTrackSegments(error: AVCompositionTrackSegment[]): boolean;
}

export class AVMutableDateRangeMetadataGroup extends AVDateRangeMetadataGroup {
  endDate: Date;
  setEndDate(_: Date);
  items: AVMetadataItem[];
  setItems(_: AVMetadataItem[]);
  startDate: Date;
  setStartDate(_: Date);
}

export class AVMutableMediaSelection extends AVMediaSelection {
  selectMediaOptionInMediaSelectionGroup(_?: AVMediaSelectionOption, in_?: AVMediaSelectionGroup): void;
}

export class AVMutableMetadataItem extends AVMetadataItem {
  dataType: string;
  setDataType(_: string);
  duration: CMTime;
  setDuration(_: CMTime);
  extendedLanguageTag: string;
  setExtendedLanguageTag(_: string);
  extraAttributes: Map<string, any>;
  setExtraAttributes(_: Map<string, any>);
  identifier: string;
  setIdentifier(_: string);
  key: any;
  setKey(_: any);
  keySpace: string;
  setKeySpace(_: string);
  locale: Locale;
  setLocale(_: Locale);
  startDate: Date;
  setStartDate(_: Date);
  time: CMTime;
  setTime(_: CMTime);
}

export class AVMutableMovie extends AVMovie {
  static movieWithSettingsFromMovieOptions(options?: AVMovie, error?: Map<string, any>): AVMutableMovie;
  defaultMediaDataStorage: AVMediaDataStorage;
  setDefaultMediaDataStorage(_: AVMediaDataStorage);
  interleavingPeriod: CMTime;
  setInterleavingPeriod(_: CMTime);
  isModified: boolean;
  setModified(_: boolean);
  preferredRate: number;
  setPreferredRate(_: number);
  preferredTransform: CGAffineTransform;
  setPreferredTransform(_: CGAffineTransform);
  preferredVolume: number;
  setPreferredVolume(_: number);
  timescale: number;
  setTimescale(_: number);
  addMutableTrackWithMediaTypeCopySettingsFromTrackOptions(withMediaType: string, copySettingsFrom?: AVAssetTrack, options?: Map<string, any>): AVMutableMovieTrack;
  addMutableTracksCopyingSettingsFromTracksOptions(from: AVAssetTrack[], options?: Map<string, any>): AVMutableMovieTrack[];
  static initWithDataOptions(options: Data, error?: Map<string, any>): AVMutableMovie;
  static initWithSettingsFromMovieOptions(options?: AVMovie, error?: Map<string, any>): AVMutableMovie;
  static initWithURLOptions(options: URL, error?: Map<string, any>): AVMutableMovie;
  insertEmptyTimeRange(_: CMTimeRange): void;
  insertTimeRangeOfAssetAtTimeCopySampleData(_: CMTimeRange, of: AVAsset, at: CMTime, copySampleData: boolean): boolean;
  mutableTrackCompatibleWithTrack(compatibleWith: AVAssetTrack): AVMutableMovieTrack;
  removeTimeRange(_: CMTimeRange): void;
  removeTrack(_: AVMovieTrack): void;
  scaleTimeRangeToDuration(_: CMTimeRange, toDuration: CMTime): void;
  trackWithTrackID(withTrackID: number): AVMutableMovieTrack;
}

export class AVMutableMovieTrack extends AVMovieTrack {
  alternateGroupID: number;
  setAlternateGroupID(_: number);
  cleanApertureDimensions: CGSize;
  setCleanApertureDimensions(_: CGSize);
  isEnabled: boolean;
  setEnabled(_: boolean);
  encodedPixelsDimensions: CGSize;
  setEncodedPixelsDimensions(_: CGSize);
  extendedLanguageTag: string;
  setExtendedLanguageTag(_: string);
  hasProtectedContent: boolean;
  languageCode: string;
  setLanguageCode(_: string);
  mediaDataStorage: AVMediaDataStorage;
  setMediaDataStorage(_: AVMediaDataStorage);
  isModified: boolean;
  setModified(_: boolean);
  naturalSize: CGSize;
  setNaturalSize(_: CGSize);
  preferredMediaChunkAlignment: number;
  setPreferredMediaChunkAlignment(_: number);
  preferredMediaChunkDuration: CMTime;
  setPreferredMediaChunkDuration(_: CMTime);
  preferredMediaChunkSize: number;
  setPreferredMediaChunkSize(_: number);
  preferredTransform: CGAffineTransform;
  setPreferredTransform(_: CGAffineTransform);
  preferredVolume: number;
  setPreferredVolume(_: number);
  productionApertureDimensions: CGSize;
  setProductionApertureDimensions(_: CGSize);
  sampleReferenceBaseURL: URL;
  setSampleReferenceBaseURL(_: URL);
  timescale: number;
  setTimescale(_: number);
  addTrackAssociationToTrackType(to: AVMovieTrack, type: string): void;
  appendSampleBufferDecodeTimePresentationTime(_: any, decodeTime?: CMTime, presentationTime?: CMTime): boolean;
  insertEmptyTimeRange(_: CMTimeRange): void;
  insertMediaTimeRangeIntoTimeRange(_: CMTimeRange, into: CMTimeRange): boolean;
  insertTimeRangeOfTrackAtTimeCopySampleData(ofTrack: CMTimeRange, atTime: AVAssetTrack, copySampleData: CMTime, error: boolean): boolean;
  removeTimeRange(_: CMTimeRange): void;
  removeTrackAssociationToTrackType(to: AVMovieTrack, type: string): void;
  replaceFormatDescriptionWithFormatDescription(_: any, with_: any): void;
  scaleTimeRangeToDuration(_: CMTimeRange, toDuration: CMTime): void;
}

export class AVMutableTimedMetadataGroup extends AVTimedMetadataGroup {
  items: AVMetadataItem[];
  setItems(_: AVMetadataItem[]);
  timeRange: CMTimeRange;
  setTimeRange(_: CMTimeRange);
}

export class AVMutableVideoComposition extends AVVideoComposition {
  animationTool: AVVideoCompositionCoreAnimationTool;
  setAnimationTool(_: AVVideoCompositionCoreAnimationTool);
  colorPrimaries: string;
  setColorPrimaries(_: string);
  colorTransferFunction: string;
  setColorTransferFunction(_: string);
  colorYCbCrMatrix: string;
  setColorYCbCrMatrix(_: string);
  customVideoCompositorClass: typeof NSObject;
  setCustomVideoCompositorClass(_: typeof NSObject);
  frameDuration: CMTime;
  setFrameDuration(_: CMTime);
  instructions: any[];
  setInstructions(_: any[]);
  renderScale: number;
  setRenderScale(_: number);
  renderSize: CGSize;
  setRenderSize(_: CGSize);
  sourceTrackIDForFrameTiming: number;
  setSourceTrackIDForFrameTiming(_: number);
}

export class AVMutableVideoCompositionInstruction extends AVVideoCompositionInstruction {
  backgroundColor: any;
  setBackgroundColor(_: any);
  enablePostProcessing: boolean;
  setEnablePostProcessing(_: boolean);
  layerInstructions: AVVideoCompositionLayerInstruction[];
  setLayerInstructions(_: AVVideoCompositionLayerInstruction[]);
  timeRange: CMTimeRange;
  setTimeRange(_: CMTimeRange);
}

export class AVMutableVideoCompositionLayerInstruction extends AVVideoCompositionLayerInstruction {
  trackID: number;
  setTrackID(_: number);
  setCropRectangleAtTime(_: CGRect, at: CMTime): void;
  setCropRectangleRampFromStartCropRectangleToEndCropRectangleTimeRange(fromStartCropRectangle: CGRect, toEndCropRectangle: CGRect, timeRange: CMTimeRange): void;
  setOpacityAtTime(_: number, at: CMTime): void;
  setOpacityRampFromStartOpacityToEndOpacityTimeRange(fromStartOpacity: number, toEndOpacity: number, timeRange: CMTimeRange): void;
  setTransformAtTime(_: CGAffineTransform, at: CMTime): void;
  setTransformRampFromStartTransformToEndTransformTimeRange(fromStart: CGAffineTransform, toEnd: CGAffineTransform, timeRange: CMTimeRange): void;
}

export class AVOutputSettingsAssistant extends NSObject {
  static availableOutputSettingsPresets(): string[];
  audioSettings: Map<string, any>;
  outputFileType: string;
  sourceAudioFormat: any;
  setSourceAudioFormat(_: any);
  sourceVideoAverageFrameDuration: CMTime;
  setSourceVideoAverageFrameDuration(_: CMTime);
  sourceVideoFormat: any;
  setSourceVideoFormat(_: any);
  sourceVideoMinFrameDuration: CMTime;
  setSourceVideoMinFrameDuration(_: CMTime);
  videoSettings: Map<string, any>;
}

export class AVPersistableContentKeyRequest extends AVContentKeyRequest {
  persistableContentKeyFromKeyVendorResponseOptions(options: Data, error?: Map<string, any>): Data;
}

export class AVPlayer extends NSObject {
  actionAtItemEnd: AVPlayer.ActionAtItemEnd;
  setActionAtItemEnd(_: AVPlayer.ActionAtItemEnd);
  allowsExternalPlayback: boolean;
  setAllowsExternalPlayback(_: boolean);
  appliesMediaSelectionCriteriaAutomatically: boolean;
  setAppliesMediaSelectionCriteriaAutomatically(_: boolean);
  audioOutputDeviceUniqueID: string;
  setAudioOutputDeviceUniqueID(_: string);
  automaticallyWaitsToMinimizeStalling: boolean;
  setAutomaticallyWaitsToMinimizeStalling(_: boolean);
  currentItem: AVPlayerItem;
  error: Error;
  isExternalPlaybackActive: boolean;
  masterClock: any;
  setMasterClock(_: any);
  isMuted: boolean;
  setMuted(_: boolean);
  outputObscuredDueToInsufficientExternalProtection: boolean;
  preferredVideoDecoderGPURegistryID: number;
  setPreferredVideoDecoderGPURegistryID(_: number);
  preventsDisplaySleepDuringVideoPlayback: boolean;
  setPreventsDisplaySleepDuringVideoPlayback(_: boolean);
  rate: number;
  setRate(_: number);
  reasonForWaitingToPlay: string;
  status: AVPlayer.Status;
  timeControlStatus: AVPlayer.TimeControlStatus;
  volume: number;
  setVolume(_: number);
  static eligibleForHDRPlayback: boolean;
  addBoundaryTimeObserverForTimesQueueUsingBlock(forTimes: NSValue[], queue?: NSObject, using?: () => void): any;
  addPeriodicTimeObserverForIntervalQueueUsingBlock(forInterval: CMTime, queue?: NSObject, using?: (p1: CMTime) => void): any;
  cancelPendingPrerolls(): void;
  currentTime(): CMTime;
  static initWithPlayerItem(_?: AVPlayerItem): AVPlayer;
  static initWithURL(_: URL): AVPlayer;
  mediaSelectionCriteriaForMediaCharacteristic(forMediaCharacteristic: string): AVPlayerMediaSelectionCriteria;
  pause(): void;
  play(): void;
  playImmediatelyAtRate(atRate: number): void;
  prerollAtRateCompletionHandler(atRate: number, completionHandler?: (p1: boolean) => void): void;
  removeTimeObserver(_: any): void;
  replaceCurrentItemWithPlayerItem(with_?: AVPlayerItem): void;
  seekToDate(to: Date): void;
  seekToDateCompletionHandler(to: Date, completionHandler: (p1: boolean) => void): void;
  seekToTime(to: CMTime): void;
  seekToTimeCompletionHandler(to: CMTime, completionHandler: (p1: boolean) => void): void;
  seekToTimeToleranceBeforeToleranceAfter(to: CMTime, toleranceBefore: CMTime, toleranceAfter: CMTime): void;
  seekToTimeToleranceBeforeToleranceAfterCompletionHandler(to: CMTime, toleranceBefore: CMTime, toleranceAfter: CMTime, completionHandler: (p1: boolean) => void): void;
  setMediaSelectionCriteriaForMediaCharacteristic(_?: AVPlayerMediaSelectionCriteria, forMediaCharacteristic?: string): void;
  setRateTimeAtHostTime(_: number, time: CMTime, atHostTime: CMTime): void;
}

export class AVPlayerItem extends NSObject {
  isApplicationAuthorizedForPlayback: boolean;
  asset: AVAsset;
  audioMix: AVAudioMix;
  setAudioMix(_: AVAudioMix);
  isAudioSpatializationAllowed: boolean;
  setAudioSpatializationAllowed(_: boolean);
  audioTimePitchAlgorithm: string;
  setAudioTimePitchAlgorithm(_: string);
  isAuthorizationRequiredForPlayback: boolean;
  automaticallyLoadedAssetKeys: string[];
  automaticallyPreservesTimeOffsetFromLive: boolean;
  setAutomaticallyPreservesTimeOffsetFromLive(_: boolean);
  canPlayFastForward: boolean;
  canPlayFastReverse: boolean;
  canPlayReverse: boolean;
  canPlaySlowForward: boolean;
  canPlaySlowReverse: boolean;
  canStepBackward: boolean;
  canStepForward: boolean;
  canUseNetworkResourcesForLiveStreamingWhilePaused: boolean;
  setCanUseNetworkResourcesForLiveStreamingWhilePaused(_: boolean);
  configuredTimeOffsetFromLive: CMTime;
  setConfiguredTimeOffsetFromLive(_: CMTime);
  contentAuthorizationRequestStatus: AVPlayerItemProtectedContentAdditions.AVContentAuthorizationStatus;
  isContentAuthorizedForPlayback: boolean;
  currentMediaSelection: AVMediaSelection;
  customVideoCompositor: any;
  duration: CMTime;
  error: Error;
  forwardPlaybackEndTime: CMTime;
  setForwardPlaybackEndTime(_: CMTime);
  loadedTimeRanges: NSValue[];
  mediaDataCollectors: AVPlayerItemMediaDataCollector[];
  outputs: AVPlayerItemOutput[];
  isPlaybackBufferEmpty: boolean;
  isPlaybackBufferFull: boolean;
  isPlaybackLikelyToKeepUp: boolean;
  preferredForwardBufferDuration: number;
  setPreferredForwardBufferDuration(_: number);
  preferredMaximumResolution: CGSize;
  setPreferredMaximumResolution(_: CGSize);
  preferredPeakBitRate: number;
  setPreferredPeakBitRate(_: number);
  presentationSize: CGSize;
  recommendedTimeOffsetFromLive: CMTime;
  reversePlaybackEndTime: CMTime;
  setReversePlaybackEndTime(_: CMTime);
  seekableTimeRanges: NSValue[];
  seekingWaitsForVideoCompositionRendering: boolean;
  setSeekingWaitsForVideoCompositionRendering(_: boolean);
  status: AVPlayerItem.Status;
  textStyleRules: AVTextStyleRule[];
  setTextStyleRules(_: AVTextStyleRule[]);
  timebase: any;
  tracks: AVPlayerItemTrack[];
  videoApertureMode: string;
  setVideoApertureMode(_: string);
  videoComposition: AVVideoComposition;
  setVideoComposition(_: AVVideoComposition);
  accessLog(): AVPlayerItemAccessLog;
  addMediaDataCollector(_: AVPlayerItemMediaDataCollector): void;
  addOutput(_: AVPlayerItemOutput): void;
  cancelContentAuthorizationRequest(): void;
  cancelPendingSeeks(): void;
  currentDate(): Date;
  currentTime(): CMTime;
  errorLog(): AVPlayerItemErrorLog;
  static initWithAsset(_: AVAsset): AVPlayerItem;
  static initWithAssetAutomaticallyLoadedAssetKeys(_: AVAsset, automaticallyLoadedAssetKeys?: string[]): AVPlayerItem;
  static initWithURL(_: URL): AVPlayerItem;
  removeMediaDataCollector(_: AVPlayerItemMediaDataCollector): void;
  removeOutput(_: AVPlayerItemOutput): void;
  requestContentAuthorizationAsynchronouslyWithTimeoutIntervalCompletionHandler(withTimeoutInterval: number, completionHandler: () => void): void;
  seekToDateCompletionHandler(to: Date, completionHandler?: (p1: boolean) => void): boolean;
  seekToTimeCompletionHandler(to: CMTime, completionHandler?: (p1: boolean) => void): void;
  seekToTimeToleranceBeforeToleranceAfterCompletionHandler(to: CMTime, toleranceBefore: CMTime, toleranceAfter: CMTime, completionHandler?: (p1: boolean) => void): void;
  selectMediaOptionInMediaSelectionGroup(_?: AVMediaSelectionOption, in_?: AVMediaSelectionGroup): void;
  selectMediaOptionAutomaticallyInMediaSelectionGroup(in_: AVMediaSelectionGroup): void;
  stepByCount(byCount: number): void;
}

export class AVPlayerItemAccessLog extends NSObject {
  events: AVPlayerItemAccessLogEvent[];
  extendedLogDataStringEncoding: number;
  extendedLogData(): Data;
}

export class AVPlayerItemAccessLogEvent extends NSObject {
  URI: string;
  averageAudioBitrate: number;
  averageVideoBitrate: number;
  downloadOverdue: number;
  durationWatched: number;
  indicatedAverageBitrate: number;
  indicatedBitrate: number;
  mediaRequestsWWAN: number;
  numberOfBytesTransferred: number;
  numberOfDroppedVideoFrames: number;
  numberOfMediaRequests: number;
  numberOfServerAddressChanges: number;
  numberOfStalls: number;
  observedBitrate: number;
  observedBitrateStandardDeviation: number;
  observedMaxBitrate: number;
  observedMinBitrate: number;
  playbackSessionID: string;
  playbackStartDate: Date;
  playbackStartOffset: number;
  playbackType: string;
  segmentsDownloadedDuration: number;
  serverAddress: string;
  startupTime: number;
  switchBitrate: number;
  transferDuration: number;
}

export class AVPlayerItemErrorLog extends NSObject {
  events: AVPlayerItemErrorLogEvent[];
  extendedLogDataStringEncoding: number;
  extendedLogData(): Data;
}

export class AVPlayerItemErrorLogEvent extends NSObject {
  URI: string;
  date: Date;
  errorComment: string;
  errorDomain: string;
  errorStatusCode: number;
  playbackSessionID: string;
  serverAddress: string;
}

export class AVPlayerItemLegibleOutput extends AVPlayerItemOutput {
  advanceIntervalForDelegateInvocation: number;
  setAdvanceIntervalForDelegateInvocation(_: number);
  delegate: any;
  delegateQueue: NSObject;
  textStylingResolution: string;
  setTextStylingResolution(_: string);
  static initWithMediaSubtypesForNativeRepresentation(_: number[]): AVPlayerItemLegibleOutput;
  setDelegateQueue(_?: any, queue?: NSObject): void;
}

interface AVPlayerItemLegibleOutputPushDelegate {
  legibleOutputDidOutputAttributedStringsNativeSampleBuffersForItemTime(_: AVPlayerItemLegibleOutput, didOutputAttributedStrings: NSAttributedString[], nativeSampleBuffers: any[], forItemTime: CMTime): void;
}

export class AVPlayerItemMediaDataCollector extends NSObject {
}

export class AVPlayerItemMetadataCollector extends AVPlayerItemMediaDataCollector {
  delegate: any;
  delegateQueue: NSObject;
  static initWithIdentifiersClassifyingLabels(_?: string[], classifyingLabels?: string[]): AVPlayerItemMetadataCollector;
  setDelegateQueue(_?: any, queue?: NSObject): void;
}

interface AVPlayerItemMetadataCollectorPushDelegate {
  metadataCollectorDidCollectDateRangeMetadataGroupsIndexesOfNewGroupsIndexesOfModifiedGroups(_: AVPlayerItemMetadataCollector, didCollect: AVDateRangeMetadataGroup[], indexesOfNewGroups: IndexSet, indexesOfModifiedGroups: IndexSet): void;
}

export class AVPlayerItemMetadataOutput extends AVPlayerItemOutput {
  advanceIntervalForDelegateInvocation: number;
  setAdvanceIntervalForDelegateInvocation(_: number);
  delegate: any;
  delegateQueue: NSObject;
  static initWithIdentifiers(_?: string[]): AVPlayerItemMetadataOutput;
  setDelegateQueue(_?: any, queue?: NSObject): void;
}

interface AVPlayerItemMetadataOutputPushDelegate {
  metadataOutputDidOutputTimedMetadataGroupsFromPlayerItemTrack(_: AVPlayerItemMetadataOutput, didOutputTimedMetadataGroups: AVTimedMetadataGroup[], from?: AVPlayerItemTrack): void;
}

export class AVPlayerItemOutput extends NSObject {
  suppressesPlayerRendering: boolean;
  setSuppressesPlayerRendering(_: boolean);
  itemTimeForCVTimeStamp(for_: CVTimeStamp): CMTime;
  itemTimeForHostTime(forHostTime: number): CMTime;
  itemTimeForMachAbsoluteTime(forMachAbsoluteTime: number): CMTime;
}

interface AVPlayerItemOutputPullDelegate {
  outputMediaDataWillChange(_: AVPlayerItemOutput): void;
  outputSequenceWasFlushed(_: AVPlayerItemOutput): void;
}

interface AVPlayerItemOutputPushDelegate {
  outputSequenceWasFlushed(_: AVPlayerItemOutput): void;
}

export class AVPlayerItemTrack extends NSObject {
  assetTrack: AVAssetTrack;
  currentVideoFrameRate: number;
  isEnabled: boolean;
  setEnabled(_: boolean);
  videoFieldMode: string;
  setVideoFieldMode(_: string);
}

export class AVPlayerItemVideoOutput extends AVPlayerItemOutput {
  delegate: any;
  delegateQueue: NSObject;
  copyPixelBufferForItemTimeItemTimeForDisplay(forItemTime: CMTime, itemTimeForDisplay?: CMTime): any;
  hasNewPixelBufferForItemTime(forItemTime: CMTime): boolean;
  static initWithOutputSettings(_?: Map<string, any>): AVPlayerItemVideoOutput;
  static initWithPixelBufferAttributes(_?: Map<string, any>): AVPlayerItemVideoOutput;
  requestNotificationOfMediaDataChangeWithAdvanceInterval(withAdvanceInterval: number): void;
  setDelegateQueue(_?: any, queue?: NSObject): void;
}

export class AVPlayerLayer extends CALayer {
  pixelBufferAttributes: Map<string, any>;
  setPixelBufferAttributes(_: Map<string, any>);
  player: AVPlayer;
  setPlayer(_: AVPlayer);
  isReadyForDisplay: boolean;
  videoGravity: string;
  setVideoGravity(_: string);
  videoRect: CGRect;
}

export class AVPlayerLooper extends NSObject {
  error: Error;
  loopCount: number;
  loopingPlayerItems: AVPlayerItem[];
  status: AVPlayerLooper.Status;
  disableLooping(): void;
  static initWithPlayerTemplateItemTimeRange(_: AVQueuePlayer, templateItem: AVPlayerItem, timeRange: CMTimeRange): AVPlayerLooper;
}

export class AVPlayerMediaSelectionCriteria extends NSObject {
  preferredLanguages: string[];
  preferredMediaCharacteristics: string[];
  principalMediaCharacteristics: string[];
  static initWithPreferredLanguagesPreferredMediaCharacteristics(_?: string[], preferredMediaCharacteristics?: string[]): AVPlayerMediaSelectionCriteria;
  static initWithPrincipalMediaCharacteristicsPreferredLanguagesPreferredMediaCharacteristics(_?: string[], preferredLanguages?: string[], preferredMediaCharacteristics?: string[]): AVPlayerMediaSelectionCriteria;
}

export class AVPortraitEffectsMatte extends NSObject {
  static portraitEffectsMatteFromDictionaryRepresentation(error: Map<any, any>): AVPortraitEffectsMatte;
  mattingImage: any;
  pixelFormatType: number;
  dictionaryRepresentationForAuxiliaryDataType(forAuxiliaryDataType?: string): Map<any, any>;
  portraitEffectsMatteByApplyingExifOrientation(_: CGImageProperties.CGImagePropertyOrientation): AVPortraitEffectsMatte;
  portraitEffectsMatteByReplacingPortraitEffectsMatteWithPixelBuffer(error: any): AVPortraitEffectsMatte;
}

export class AVQueuePlayer extends AVPlayer {
  advanceToNextItem(): void;
  canInsertItemAfterItem(_: AVPlayerItem, after?: AVPlayerItem): boolean;
  static initWithItems(_: AVPlayerItem[]): AVQueuePlayer;
  insertItemAfterItem(_: AVPlayerItem, after?: AVPlayerItem): void;
  items(): AVPlayerItem[];
  removeAllItems(): void;
  removeItem(_: AVPlayerItem): void;
}

interface AVQueuedSampleBufferRendering {
  isReadyForMoreMediaData: boolean;
  timebase: any;
  enqueueSampleBuffer(_: any): void;
  flush(): void;
  requestMediaDataWhenReadyOnQueueUsingBlock(on: NSObject, using: () => void): void;
  stopRequestingMediaData(): void;
}

export class AVRouteDetector extends NSObject {
  multipleRoutesDetected: boolean;
  isRouteDetectionEnabled: boolean;
  setRouteDetectionEnabled(_: boolean);
}

export class AVSampleBufferAudioRenderer extends NSObject {
  audioOutputDeviceUniqueID: string;
  setAudioOutputDeviceUniqueID(_: string);
  audioTimePitchAlgorithm: string;
  setAudioTimePitchAlgorithm(_: string);
  error: Error;
  isMuted: boolean;
  setMuted(_: boolean);
  status: AVQueuedSampleBufferRendering.AVQueuedSampleBufferRenderingStatus;
  volume: number;
  setVolume(_: number);
  flushFromSourceTimeCompletionHandler(fromSourceTime: CMTime, completionHandler: (p1: boolean) => void): void;
}

export class AVSampleBufferDisplayLayer extends CALayer {
  controlTimebase: any;
  setControlTimebase(_: any);
  error: Error;
  preventsCapture: boolean;
  setPreventsCapture(_: boolean);
  preventsDisplaySleepDuringVideoPlayback: boolean;
  setPreventsDisplaySleepDuringVideoPlayback(_: boolean);
  status: AVQueuedSampleBufferRendering.AVQueuedSampleBufferRenderingStatus;
  videoGravity: string;
  setVideoGravity(_: string);
  flushAndRemoveImage(): void;
}

export class AVSampleBufferGenerator extends NSObject {
  static notifyOfDataReadyForSampleBufferCompletionHandler(for_: any, completionHandler: (p1: boolean, p2: Error) => void): void;
  createSampleBufferForRequest(for_: AVSampleBufferRequest): any;
  static initWithAssetTimebase(_: AVAsset, timebase?: any): AVSampleBufferGenerator;
}

export class AVSampleBufferRenderSynchronizer extends NSObject {
  rate: number;
  setRate(_: number);
  renderers: any[];
  timebase: any;
  addBoundaryTimeObserverForTimesQueueUsingBlock(forTimes: NSValue[], queue?: NSObject, using?: () => void): any;
  addPeriodicTimeObserverForIntervalQueueUsingBlock(forInterval: CMTime, queue?: NSObject, using?: (p1: CMTime) => void): any;
  addRenderer(_: any): void;
  currentTime(): CMTime;
  removeRendererAtTimeCompletionHandler(_: any, at: CMTime, completionHandler?: (p1: boolean) => void): void;
  removeTimeObserver(_: any): void;
  setRateTime(_: number, time: CMTime): void;
}

export class AVSampleBufferRequest extends NSObject {
  direction: AVSampleBufferGenerator.AVSampleBufferRequest.Direction;
  setDirection(_: AVSampleBufferGenerator.AVSampleBufferRequest.Direction);
  limitCursor: AVSampleCursor;
  setLimitCursor(_: AVSampleCursor);
  maxSampleCount: number;
  setMaxSampleCount(_: number);
  mode: AVSampleBufferGenerator.AVSampleBufferRequest.Mode;
  setMode(_: AVSampleBufferGenerator.AVSampleBufferRequest.Mode);
  overrideTime: CMTime;
  setOverrideTime(_: CMTime);
  preferredMinSampleCount: number;
  setPreferredMinSampleCount(_: number);
  startCursor: AVSampleCursor;
  static initWithStartCursor(_: AVSampleCursor): AVSampleBufferRequest;
}

export class AVSampleCursor extends NSObject {
  currentChunkInfo: AVSampleCursorChunkInfo;
  currentChunkStorageRange: AVSampleCursorStorageRange;
  currentChunkStorageURL: URL;
  currentSampleAudioDependencyInfo: AVSampleCursorAudioDependencyInfo;
  currentSampleDependencyInfo: AVSampleCursorDependencyInfo;
  currentSampleDuration: CMTime;
  currentSampleIndexInChunk: number;
  currentSampleStorageRange: AVSampleCursorStorageRange;
  currentSampleSyncInfo: AVSampleCursorSyncInfo;
  decodeTimeStamp: CMTime;
  presentationTimeStamp: CMTime;
  samplesRequiredForDecoderRefresh: number;
  comparePositionInDecodeOrderWithPositionOfCursor(withPositionOf: AVSampleCursor): NSObjCRuntime.ComparisonResult;
  copyCurrentSampleFormatDescription(): any;
  samplesWithEarlierDecodeTimeStampsMayHaveLaterPresentationTimeStampsThanCursor(laterThan: AVSampleCursor): boolean;
  samplesWithLaterDecodeTimeStampsMayHaveEarlierPresentationTimeStampsThanCursor(earlierThan: AVSampleCursor): boolean;
  stepByDecodeTimeWasPinned(byDecodeTime: CMTime, wasPinned?: boolean): CMTime;
  stepByPresentationTimeWasPinned(byPresentationTime: CMTime, wasPinned?: boolean): CMTime;
  stepInDecodeOrderByCount(byCount: number): number;
  stepInPresentationOrderByCount(byCount: number): number;
}

export class AVSemanticSegmentationMatte extends NSObject {
  static semanticSegmentationMatteFromImageSourceAuxiliaryDataTypeDictionaryRepresentation(dictionaryRepresentation: string, error: Map<any, any>): AVSemanticSegmentationMatte;
  matteType: string;
  mattingImage: any;
  pixelFormatType: number;
  dictionaryRepresentationForAuxiliaryDataType(forAuxiliaryDataType?: string): Map<any, any>;
  semanticSegmentationMatteByApplyingExifOrientation(_: CGImageProperties.CGImagePropertyOrientation): AVSemanticSegmentationMatte;
  semanticSegmentationMatteByReplacingSemanticSegmentationMatteWithPixelBuffer(error: any): AVSemanticSegmentationMatte;
}

export class AVSpeechSynthesisVoice extends NSObject {
  static currentLanguageCode(): string;
  static speechVoices(): AVSpeechSynthesisVoice[];
  audioFileSettings: Map<string, any>;
  gender: AVSpeechSynthesis.AVSpeechSynthesisVoiceGender;
  identifier: string;
  language: string;
  name: string;
  quality: AVSpeechSynthesis.AVSpeechSynthesisVoiceQuality;
}

export class AVSpeechSynthesizer extends NSObject {
  delegate: any;
  setDelegate(_: any);
  isPaused: boolean;
  isSpeaking: boolean;
  continueSpeaking(): boolean;
  pauseSpeakingAtBoundary(at: AVSpeechSynthesis.AVSpeechBoundary): boolean;
  speakUtterance(_: AVSpeechUtterance): void;
  stopSpeakingAtBoundary(at: AVSpeechSynthesis.AVSpeechBoundary): boolean;
  writeUtteranceToBufferCallback(_: AVSpeechUtterance, toBufferCallback: (p1: AVAudioBuffer) => void): void;
}

interface AVSpeechSynthesizerDelegate {
  speechSynthesizerDidStartSpeechUtterance(_: AVSpeechSynthesizer, didStart: AVSpeechUtterance): void;
  speechSynthesizerDidFinishSpeechUtterance(_: AVSpeechSynthesizer, didFinish: AVSpeechUtterance): void;
  speechSynthesizerDidPauseSpeechUtterance(_: AVSpeechSynthesizer, didPause: AVSpeechUtterance): void;
  speechSynthesizerDidContinueSpeechUtterance(_: AVSpeechSynthesizer, didContinue: AVSpeechUtterance): void;
  speechSynthesizerDidCancelSpeechUtterance(_: AVSpeechSynthesizer, didCancel: AVSpeechUtterance): void;
  speechSynthesizerWillSpeakRangeOfSpeechStringUtterance(_: AVSpeechSynthesizer, willSpeakRangeOfSpeechString: NSRange, utterance: AVSpeechUtterance): void;
}

export class AVSpeechUtterance extends NSObject {
  attributedSpeechString: NSAttributedString;
  pitchMultiplier: number;
  setPitchMultiplier(_: number);
  postUtteranceDelay: number;
  setPostUtteranceDelay(_: number);
  preUtteranceDelay: number;
  setPreUtteranceDelay(_: number);
  rate: number;
  setRate(_: number);
  speechString: string;
  voice: AVSpeechSynthesisVoice;
  setVoice(_: AVSpeechSynthesisVoice);
  volume: number;
  setVolume(_: number);
  static initWithAttributedString(_: NSAttributedString): AVSpeechUtterance;
  static initWithString(_: string): AVSpeechUtterance;
}

export class AVSynchronizedLayer extends CALayer {
  playerItem: AVPlayerItem;
  setPlayerItem(_: AVPlayerItem);
}

export class AVTextStyleRule extends NSObject {
  static propertyListForTextStyleRules(for_: AVTextStyleRule[]): any;
  static textStyleRulesFromPropertyList(fromPropertyList: any): AVTextStyleRule[];
  textMarkupAttributes: Map<string, any>;
  textSelector: string;
  static initWithTextMarkupAttributes(_: Map<string, any>): AVTextStyleRule;
  static initWithTextMarkupAttributesTextSelector(_: Map<string, any>, textSelector?: string): AVTextStyleRule;
}

export class AVTimedMetadataGroup extends AVMetadataGroup {
  timeRange: CMTimeRange;
  copyFormatDescription(): any;
  static initWithItemsTimeRange(_: AVMetadataItem[], timeRange: CMTimeRange): AVTimedMetadataGroup;
  static initWithSampleBuffer(_: any): AVTimedMetadataGroup;
}

export class AVURLAsset extends AVAsset {
  static audiovisualMIMETypes(): string[];
  static audiovisualTypes(): string[];
  static isPlayableExtendedMIMEType(_: string): boolean;
  URL: URL;
  assetCache: AVAssetCache;
  resourceLoader: AVAssetResourceLoader;
  compatibleTrackForCompositionTrack(for_: AVCompositionTrack): AVAssetTrack;
  static initWithURLOptions(_: URL, options?: Map<string, any>): AVURLAsset;
}

interface AVVideoCompositing {
  requiredPixelBufferAttributesForRenderContext: Map<string, any>;
  sourcePixelBufferAttributes: Map<string, any>;
  supportsWideColorSourceFrames?: boolean;
  anticipateRenderingUsingHint(using: AVVideoCompositionRenderHint): void;
  cancelAllPendingVideoCompositionRequests(): void;
  prerollForRenderingUsingHint(using: AVVideoCompositionRenderHint): void;
  renderContextChanged(_: AVVideoCompositionRenderContext): void;
  startVideoCompositionRequest(_: AVAsynchronousVideoCompositionRequest): void;
}

export class AVVideoComposition extends NSObject {
  animationTool: AVVideoCompositionCoreAnimationTool;
  colorPrimaries: string;
  colorTransferFunction: string;
  colorYCbCrMatrix: string;
  customVideoCompositorClass: typeof NSObject;
  frameDuration: CMTime;
  instructions: any[];
  renderScale: number;
  renderSize: CGSize;
  sourceTrackIDForFrameTiming: number;
  isValidForAssetTimeRangeValidationDelegate(for_?: AVAsset, timeRange?: CMTimeRange, validationDelegate?: any): boolean;
}

export class AVVideoCompositionCoreAnimationTool extends NSObject {
}

export class AVVideoCompositionInstruction extends NSObject {
  backgroundColor: any;
  layerInstructions: AVVideoCompositionLayerInstruction[];
}

interface AVVideoCompositionInstructionProtocol {
  containsTweening: boolean;
  enablePostProcessing: boolean;
  passthroughTrackID: number;
  requiredSourceTrackIDs: NSValue[];
  timeRange: CMTimeRange;
}

export class AVVideoCompositionLayerInstruction extends NSObject {
  trackID: number;
  getCropRectangleRampForTimeStartCropRectangleEndCropRectangleTimeRange(for_: CMTime, startCropRectangle?: CGRect, endCropRectangle?: CGRect, timeRange?: CMTimeRange): boolean;
  getOpacityRampForTimeStartOpacityEndOpacityTimeRange(for_: CMTime, startOpacity?: number, endOpacity?: number, timeRange?: CMTimeRange): boolean;
  getTransformRampForTimeStartTransformEndTransformTimeRange(for_: CMTime, start?: CGAffineTransform, end?: CGAffineTransform, timeRange?: CMTimeRange): boolean;
}

export class AVVideoCompositionRenderContext extends NSObject {
  edgeWidths: AVEdgeWidths;
  highQualityRendering: boolean;
  pixelAspectRatio: AVPixelAspectRatio;
  renderScale: number;
  renderTransform: CGAffineTransform;
  size: CGSize;
  videoComposition: AVVideoComposition;
  newPixelBuffer(): any;
}

export class AVVideoCompositionRenderHint extends NSObject {
  endCompositionTime: CMTime;
  startCompositionTime: CMTime;
}

interface AVVideoCompositionValidationHandling {
  videoCompositionShouldContinueValidatingAfterFindingInvalidValueForKey(_: AVVideoComposition, shouldContinueValidatingAfterFindingInvalidValueForKey: string): boolean;
  videoCompositionShouldContinueValidatingAfterFindingEmptyTimeRange(_: AVVideoComposition, shouldContinueValidatingAfterFindingEmptyTimeRange: CMTimeRange): boolean;
  videoCompositionShouldContinueValidatingAfterFindingInvalidTimeRangeInInstruction(_: AVVideoComposition, shouldContinueValidatingAfterFindingInvalidTimeRangeIn: any): boolean;
  videoCompositionShouldContinueValidatingAfterFindingInvalidTrackIDInInstructionLayerInstructionAsset(_: AVVideoComposition, shouldContinueValidatingAfterFindingInvalidTrackIDIn: any, layerInstruction: AVVideoCompositionLayerInstruction, asset: AVAsset): boolean;
}

export class AVCaptureView extends NSView {
  controlsStyle: AVCaptureView.AVCaptureViewControlsStyle;
  setControlsStyle(_: AVCaptureView.AVCaptureViewControlsStyle);
  delegate: any;
  setDelegate(_: any);
  fileOutput: AVCaptureFileOutput;
  session: AVCaptureSession;
  videoGravity: string;
  setVideoGravity(_: string);
  setSessionShowVideoPreviewShowAudioPreview(_?: AVCaptureSession, showVideoPreview?: boolean, showAudioPreview?: boolean): void;
}

interface AVCaptureViewDelegate {
  captureViewStartRecordingToFileOutput(_: AVCaptureView, startRecordingTo: AVCaptureFileOutput): void;
}

export class AVPictureInPictureController extends NSObject {
  static isPictureInPictureSupported(): boolean;
  delegate: any;
  setDelegate(_: any);
  isPictureInPictureActive: boolean;
  isPictureInPicturePossible: boolean;
  isPictureInPictureSuspended: boolean;
  playerLayer: AVPlayerLayer;
  static pictureInPictureButtonStartImage: NSImage;
  static pictureInPictureButtonStopImage: NSImage;
  static initWithPlayerLayer(_: AVPlayerLayer): AVPictureInPictureController;
  startPictureInPicture(): void;
  stopPictureInPicture(): void;
}

interface AVPictureInPictureControllerDelegate {
  pictureInPictureControllerFailedToStartPictureInPictureWithError(_: AVPictureInPictureController, failedToStartPictureInPictureWithError: Error): void;
  pictureInPictureControllerRestoreUserInterfaceForPictureInPictureStopWithCompletionHandler(_: AVPictureInPictureController, restoreUserInterfaceForPictureInPictureStopWithCompletionHandler: (p1: boolean) => void): void;
  pictureInPictureControllerDidStartPictureInPicture(_: AVPictureInPictureController): void;
  pictureInPictureControllerDidStopPictureInPicture(_: AVPictureInPictureController): void;
  pictureInPictureControllerWillStartPictureInPicture(_: AVPictureInPictureController): void;
  pictureInPictureControllerWillStopPictureInPicture(_: AVPictureInPictureController): void;
}

export class AVPlayerView extends NSView {
  actionPopUpButtonMenu: NSMenu;
  setActionPopUpButtonMenu(_: NSMenu);
  allowsPictureInPicturePlayback: boolean;
  setAllowsPictureInPicturePlayback(_: boolean);
  canBeginTrimming: boolean;
  contentOverlayView: NSView;
  controlsStyle: AVPlayerView.AVPlayerViewControlsStyle;
  setControlsStyle(_: AVPlayerView.AVPlayerViewControlsStyle);
  pictureInPictureDelegate: any;
  setPictureInPictureDelegate(_: any);
  player: AVPlayer;
  setPlayer(_: AVPlayer);
  isReadyForDisplay: boolean;
  showsFrameSteppingButtons: boolean;
  setShowsFrameSteppingButtons(_: boolean);
  showsFullScreenToggleButton: boolean;
  setShowsFullScreenToggleButton(_: boolean);
  showsSharingServiceButton: boolean;
  setShowsSharingServiceButton(_: boolean);
  showsTimecodes: boolean;
  setShowsTimecodes(_: boolean);
  updatesNowPlayingInfoCenter: boolean;
  setUpdatesNowPlayingInfoCenter(_: boolean);
  videoBounds: CGRect;
  videoGravity: string;
  setVideoGravity(_: string);
  beginTrimmingWithCompletionHandler(completionHandler?: (p1: AVPlayerView.AVPlayerViewTrimResult) => void): void;
  flashChapterNumberChapterTitle(_: number, chapterTitle?: string): void;
}

interface AVPlayerViewPictureInPictureDelegate {
  playerViewFailedToStartPictureInPictureWithError(_: AVPlayerView, failedToStartPictureInPictureWithError: Error): void;
  playerViewRestoreUserInterfaceForPictureInPictureStopWithCompletionHandler(_: AVPlayerView, restoreUserInterfaceForPictureInPictureStopWithCompletionHandler: (p1: boolean) => void): void;
  playerViewDidStartPictureInPicture(inPicture: AVPlayerView): void;
  playerViewDidStopPictureInPicture(inPicture: AVPlayerView): void;
  playerViewShouldAutomaticallyDismissAtPictureInPictureStart(inPictureStart: AVPlayerView): boolean;
  playerViewWillStartPictureInPicture(inPicture: AVPlayerView): void;
  playerViewWillStopPictureInPicture(inPicture: AVPlayerView): void;
}

export class AVRoutePickerView extends NSView {
  delegate: any;
  setDelegate(_: any);
  player: AVPlayer;
  setPlayer(_: AVPlayer);
  isRoutePickerButtonBordered: boolean;
  setRoutePickerButtonBordered(_: boolean);
  routePickerButtonColorForState(for_: AVRoutePickerView.AVRoutePickerViewButtonState): NSColor;
  setRoutePickerButtonColorForState(_?: NSColor, for_?: AVRoutePickerView.AVRoutePickerViewButtonState): void;
}

interface AVRoutePickerViewDelegate {
  routePickerViewDidEndPresentingRoutes(_: AVRoutePickerView): void;
  routePickerViewWillBeginPresentingRoutes(_: AVRoutePickerView): void;
}

export class NSATSTypesetter extends NSTypesetter {
  static sharedTypesetter: NSATSTypesetter;
}

interface NSAccessibility {
  accessibilityActivationPoint: CGPoint;
  setAccessibilityActivationPoint(_: CGPoint);
  accessibilityAllowedValues: number[];
  setAccessibilityAllowedValues(_: number[]);
  isAccessibilityAlternateUIVisible: boolean;
  setAccessibilityAlternateUIVisible(_: boolean);
  accessibilityApplicationFocusedUIElement: any;
  setAccessibilityApplicationFocusedUIElement(_: any);
  accessibilityCancelButton: any;
  setAccessibilityCancelButton(_: any);
  accessibilityChildren: any[];
  setAccessibilityChildren(_: any[]);
  accessibilityChildrenInNavigationOrder: any[];
  setAccessibilityChildrenInNavigationOrder(_: any[]);
  accessibilityClearButton: any;
  setAccessibilityClearButton(_: any);
  accessibilityCloseButton: any;
  setAccessibilityCloseButton(_: any);
  accessibilityColumnCount: number;
  setAccessibilityColumnCount(_: number);
  accessibilityColumnHeaderUIElements: any[];
  setAccessibilityColumnHeaderUIElements(_: any[]);
  accessibilityColumnIndexRange: NSRange;
  setAccessibilityColumnIndexRange(_: NSRange);
  accessibilityColumns: any[];
  setAccessibilityColumns(_: any[]);
  accessibilityColumnTitles: any[];
  setAccessibilityColumnTitles(_: any[]);
  accessibilityContents: any[];
  setAccessibilityContents(_: any[]);
  accessibilityCriticalValue: any;
  setAccessibilityCriticalValue(_: any);
  accessibilityCustomActions: NSAccessibilityCustomAction[];
  setAccessibilityCustomActions(_: NSAccessibilityCustomAction[]);
  accessibilityCustomRotors: NSAccessibilityCustomRotor[];
  setAccessibilityCustomRotors(_: NSAccessibilityCustomRotor[]);
  accessibilityDecrementButton: any;
  setAccessibilityDecrementButton(_: any);
  accessibilityDefaultButton: any;
  setAccessibilityDefaultButton(_: any);
  isAccessibilityDisclosed: boolean;
  setAccessibilityDisclosed(_: boolean);
  accessibilityDisclosedByRow: any;
  setAccessibilityDisclosedByRow(_: any);
  accessibilityDisclosedRows: any;
  setAccessibilityDisclosedRows(_: any);
  accessibilityDisclosureLevel: number;
  setAccessibilityDisclosureLevel(_: number);
  accessibilityDocument: string;
  setAccessibilityDocument(_: string);
  isAccessibilityEdited: boolean;
  setAccessibilityEdited(_: boolean);
  isAccessibilityElement: boolean;
  setAccessibilityElement(_: boolean);
  isAccessibilityEnabled: boolean;
  setAccessibilityEnabled(_: boolean);
  isAccessibilityExpanded: boolean;
  setAccessibilityExpanded(_: boolean);
  accessibilityExtrasMenuBar: any;
  setAccessibilityExtrasMenuBar(_: any);
  accessibilityFilename: string;
  setAccessibilityFilename(_: string);
  isAccessibilityFocused: boolean;
  setAccessibilityFocused(_: boolean);
  accessibilityFocusedWindow: any;
  setAccessibilityFocusedWindow(_: any);
  accessibilityFrame: CGRect;
  setAccessibilityFrame(_: CGRect);
  isAccessibilityFrontmost: boolean;
  setAccessibilityFrontmost(_: boolean);
  accessibilityFullScreenButton: any;
  setAccessibilityFullScreenButton(_: any);
  accessibilityGrowArea: any;
  setAccessibilityGrowArea(_: any);
  accessibilityHandles: any[];
  setAccessibilityHandles(_: any[]);
  accessibilityHeader: any;
  setAccessibilityHeader(_: any);
  accessibilityHelp: string;
  setAccessibilityHelp(_: string);
  isAccessibilityHidden: boolean;
  setAccessibilityHidden(_: boolean);
  accessibilityHorizontalScrollBar: any;
  setAccessibilityHorizontalScrollBar(_: any);
  accessibilityHorizontalUnitDescription: string;
  setAccessibilityHorizontalUnitDescription(_: string);
  accessibilityHorizontalUnits: NSAccessibilityConstants.NSAccessibility.Units;
  setAccessibilityHorizontalUnits(_: NSAccessibilityConstants.NSAccessibility.Units);
  accessibilityIdentifier: string;
  setAccessibilityIdentifier(_: string);
  accessibilityIncrementButton: any;
  setAccessibilityIncrementButton(_: any);
  accessibilityIndex: number;
  setAccessibilityIndex(_: number);
  accessibilityInsertionPointLineNumber: number;
  setAccessibilityInsertionPointLineNumber(_: number);
  accessibilityLabel: string;
  setAccessibilityLabel(_: string);
  accessibilityLabelUIElements: any[];
  setAccessibilityLabelUIElements(_: any[]);
  accessibilityLabelValue: number;
  setAccessibilityLabelValue(_: number);
  accessibilityLinkedUIElements: any[];
  setAccessibilityLinkedUIElements(_: any[]);
  isAccessibilityMain: boolean;
  setAccessibilityMain(_: boolean);
  accessibilityMainWindow: any;
  setAccessibilityMainWindow(_: any);
  accessibilityMarkerGroupUIElement: any;
  setAccessibilityMarkerGroupUIElement(_: any);
  accessibilityMarkerTypeDescription: string;
  setAccessibilityMarkerTypeDescription(_: string);
  accessibilityMarkerUIElements: any[];
  setAccessibilityMarkerUIElements(_: any[]);
  accessibilityMarkerValues: any;
  setAccessibilityMarkerValues(_: any);
  accessibilityMaxValue: any;
  setAccessibilityMaxValue(_: any);
  accessibilityMenuBar: any;
  setAccessibilityMenuBar(_: any);
  accessibilityMinimizeButton: any;
  setAccessibilityMinimizeButton(_: any);
  isAccessibilityMinimized: boolean;
  setAccessibilityMinimized(_: boolean);
  accessibilityMinValue: any;
  setAccessibilityMinValue(_: any);
  isAccessibilityModal: boolean;
  setAccessibilityModal(_: boolean);
  accessibilityNextContents: any[];
  setAccessibilityNextContents(_: any[]);
  accessibilityNumberOfCharacters: number;
  setAccessibilityNumberOfCharacters(_: number);
  isAccessibilityOrderedByRow: boolean;
  setAccessibilityOrderedByRow(_: boolean);
  accessibilityOrientation: NSAccessibilityConstants.NSAccessibility.Orientation;
  setAccessibilityOrientation(_: NSAccessibilityConstants.NSAccessibility.Orientation);
  accessibilityOverflowButton: any;
  setAccessibilityOverflowButton(_: any);
  accessibilityParent: any;
  setAccessibilityParent(_: any);
  accessibilityPlaceholderValue: string;
  setAccessibilityPlaceholderValue(_: string);
  accessibilityPreviousContents: any[];
  setAccessibilityPreviousContents(_: any[]);
  isAccessibilityProtectedContent: boolean;
  setAccessibilityProtectedContent(_: boolean);
  accessibilityProxy: any;
  setAccessibilityProxy(_: any);
  isAccessibilityRequired: boolean;
  setAccessibilityRequired(_: boolean);
  accessibilityRole: string;
  setAccessibilityRole(_: string);
  accessibilityRoleDescription: string;
  setAccessibilityRoleDescription(_: string);
  accessibilityRowCount: number;
  setAccessibilityRowCount(_: number);
  accessibilityRowHeaderUIElements: any[];
  setAccessibilityRowHeaderUIElements(_: any[]);
  accessibilityRowIndexRange: NSRange;
  setAccessibilityRowIndexRange(_: NSRange);
  accessibilityRows: any[];
  setAccessibilityRows(_: any[]);
  accessibilityRulerMarkerType: NSAccessibilityConstants.NSAccessibility.RulerMarkerType;
  setAccessibilityRulerMarkerType(_: NSAccessibilityConstants.NSAccessibility.RulerMarkerType);
  accessibilitySearchButton: any;
  setAccessibilitySearchButton(_: any);
  accessibilitySearchMenu: any;
  setAccessibilitySearchMenu(_: any);
  isAccessibilitySelected: boolean;
  setAccessibilitySelected(_: boolean);
  accessibilitySelectedCells: any[];
  setAccessibilitySelectedCells(_: any[]);
  accessibilitySelectedChildren: any[];
  setAccessibilitySelectedChildren(_: any[]);
  accessibilitySelectedColumns: any[];
  setAccessibilitySelectedColumns(_: any[]);
  accessibilitySelectedRows: any[];
  setAccessibilitySelectedRows(_: any[]);
  accessibilitySelectedText: string;
  setAccessibilitySelectedText(_: string);
  accessibilitySelectedTextRange: NSRange;
  setAccessibilitySelectedTextRange(_: NSRange);
  accessibilitySelectedTextRanges: NSValue[];
  setAccessibilitySelectedTextRanges(_: NSValue[]);
  accessibilityServesAsTitleForUIElements: any[];
  setAccessibilityServesAsTitleForUIElements(_: any[]);
  accessibilitySharedCharacterRange: NSRange;
  setAccessibilitySharedCharacterRange(_: NSRange);
  accessibilitySharedFocusElements: any[];
  setAccessibilitySharedFocusElements(_: any[]);
  accessibilitySharedTextUIElements: any[];
  setAccessibilitySharedTextUIElements(_: any[]);
  accessibilityShownMenu: any;
  setAccessibilityShownMenu(_: any);
  accessibilitySortDirection: NSAccessibilityConstants.NSAccessibility.SortDirection;
  setAccessibilitySortDirection(_: NSAccessibilityConstants.NSAccessibility.SortDirection);
  accessibilitySplitters: any[];
  setAccessibilitySplitters(_: any[]);
  accessibilitySubrole: string;
  setAccessibilitySubrole(_: string);
  accessibilityTabs: any[];
  setAccessibilityTabs(_: any[]);
  accessibilityTitle: string;
  setAccessibilityTitle(_: string);
  accessibilityTitleUIElement: any;
  setAccessibilityTitleUIElement(_: any);
  accessibilityToolbarButton: any;
  setAccessibilityToolbarButton(_: any);
  accessibilityTopLevelUIElement: any;
  setAccessibilityTopLevelUIElement(_: any);
  accessibilityUnitDescription: string;
  setAccessibilityUnitDescription(_: string);
  accessibilityUnits: NSAccessibilityConstants.NSAccessibility.Units;
  setAccessibilityUnits(_: NSAccessibilityConstants.NSAccessibility.Units);
  accessibilityURL: URL;
  setAccessibilityURL(_: URL);
  accessibilityValue: any;
  setAccessibilityValue(_: any);
  accessibilityValueDescription: string;
  setAccessibilityValueDescription(_: string);
  accessibilityVerticalScrollBar: any;
  setAccessibilityVerticalScrollBar(_: any);
  accessibilityVerticalUnitDescription: string;
  setAccessibilityVerticalUnitDescription(_: string);
  accessibilityVerticalUnits: NSAccessibilityConstants.NSAccessibility.Units;
  setAccessibilityVerticalUnits(_: NSAccessibilityConstants.NSAccessibility.Units);
  accessibilityVisibleCells: any[];
  setAccessibilityVisibleCells(_: any[]);
  accessibilityVisibleCharacterRange: NSRange;
  setAccessibilityVisibleCharacterRange(_: NSRange);
  accessibilityVisibleChildren: any[];
  setAccessibilityVisibleChildren(_: any[]);
  accessibilityVisibleColumns: any[];
  setAccessibilityVisibleColumns(_: any[]);
  accessibilityVisibleRows: any[];
  setAccessibilityVisibleRows(_: any[]);
  accessibilityWarningValue: any;
  setAccessibilityWarningValue(_: any);
  accessibilityWindow: any;
  setAccessibilityWindow(_: any);
  accessibilityWindows: any[];
  setAccessibilityWindows(_: any[]);
  accessibilityZoomButton: any;
  setAccessibilityZoomButton(_: any);
  accessibilityAttributedStringForRange(_: NSRange): NSAttributedString;
  accessibilityCellForColumnRow(_: number, row: number): any;
  accessibilityFrameForRange(_: NSRange): CGRect;
  accessibilityLayoutPointForScreenPoint(_: CGPoint): CGPoint;
  accessibilityLayoutSizeForScreenSize(_: CGSize): CGSize;
  accessibilityLineForIndex(_: number): number;
  accessibilityPerformCancel(): boolean;
  accessibilityPerformConfirm(): boolean;
  accessibilityPerformDecrement(): boolean;
  accessibilityPerformDelete(): boolean;
  accessibilityPerformIncrement(): boolean;
  accessibilityPerformPick(): boolean;
  accessibilityPerformPress(): boolean;
  accessibilityPerformRaise(): boolean;
  accessibilityPerformShowAlternateUI(): boolean;
  accessibilityPerformShowDefaultUI(): boolean;
  accessibilityPerformShowMenu(): boolean;
  accessibilityRangeForIndex(_: number): NSRange;
  accessibilityRangeForLine(_: number): NSRange;
  accessibilityRangeForPosition(_: CGPoint): NSRange;
  accessibilityRTFForRange(_: NSRange): Data;
  accessibilityScreenPointForLayoutPoint(_: CGPoint): CGPoint;
  accessibilityScreenSizeForLayoutSize(_: CGSize): CGSize;
  accessibilityStringForRange(_: NSRange): string;
  accessibilityStyleRangeForIndex(_: number): NSRange;
  isAccessibilitySelectorAllowed(_: string): boolean;
}

// export function NSAccessibilityActionDescription(action: string): string;

interface NSAccessibilityButton {
  accessibilityLabel(): string;
  accessibilityPerformPress(): boolean;
}

interface NSAccessibilityCheckBox {
  accessibilityValue(): number;
}

interface NSAccessibilityContainsTransientUI {
  accessibilityPerformShowAlternateUI(): boolean;
  accessibilityPerformShowDefaultUI(): boolean;
  isAccessibilityAlternateUIVisible(): boolean;
}

export class NSAccessibilityCustomAction extends NSObject {
  handler: () => boolean;
  setHandler(_: () => boolean);
  name: string;
  setName(_: string);
  selector: string;
  setSelector(_: string);
  target: any;
  setTarget(_: any);
  static initWithNameHandler(_: string, handler?: () => boolean): NSAccessibilityCustomAction;
  static initWithNameTargetSelector(_: string, target: any, selector: string): NSAccessibilityCustomAction;
}

export class NSAccessibilityCustomRotor extends NSObject {
  itemLoadingDelegate: any;
  setItemLoadingDelegate(_: any);
  itemSearchDelegate: any;
  setItemSearchDelegate(_: any);
  label: string;
  setLabel(_: string);
  type: NSAccessibilityCustomRotor.RotorType;
  setType(_: NSAccessibilityCustomRotor.RotorType);
  static initWithLabelItemSearchDelegate(_: string, itemSearchDelegate: any): NSAccessibilityCustomRotor;
  static initWithRotorTypeItemSearchDelegate(_: NSAccessibilityCustomRotor.RotorType, itemSearchDelegate: any): NSAccessibilityCustomRotor;
}

interface NSAccessibilityCustomRotorItemSearchDelegate {
  rotorResultForSearchParameters(_: NSAccessibilityCustomRotor, resultFor: NSAccessibilityCustomRotor.SearchParameters): NSAccessibilityCustomRotor.ItemResult;
}

export class NSAccessibilityElement extends NSObject {
  static accessibilityElementWithRoleFrameLabelParent(withRole: string, frame: CGRect, label?: string, parent?: any): any;
  accessibilityFrameInParentSpace: CGRect;
  setAccessibilityFrameInParentSpace(_: CGRect);
  accessibilityAddChildElement(_: NSAccessibilityElement): void;
}

interface NSAccessibilityElementLoading {
  accessibilityElementWithToken(withToken: any): any;
  accessibilityRangeInTargetElementWithToken(withToken: any): NSRange;
}

interface NSAccessibilityElementProtocol {
  accessibilityFrame(): CGRect;
  accessibilityIdentifier(): string;
  accessibilityParent(): any;
  isAccessibilityFocused(): boolean;
}

// export function NSAccessibilityFrameInView(parentView: NSView, frame: CGRect): CGRect;

interface NSAccessibilityGroup {
}

interface NSAccessibilityImage {
  accessibilityLabel(): string;
}

interface NSAccessibilityLayoutArea {
  accessibilityFocusedUIElement: any;
  accessibilityChildren(): any[];
  accessibilityLabel(): string;
  accessibilitySelectedChildren(): any[];
}

interface NSAccessibilityLayoutItem {
  setAccessibilityFrame(_: CGRect): void;
}

interface NSAccessibilityList {
}

interface NSAccessibilityNavigableStaticText {
  accessibilityFrameForRange(for_: NSRange): CGRect;
  accessibilityLineForIndex(for_: number): number;
  accessibilityRangeForLine(forLine: number): NSRange;
  accessibilityStringForRange(for_: NSRange): string;
}

interface NSAccessibilityOutline {
}

// export function NSAccessibilityPointInView(parentView: NSView, point: CGPoint): CGPoint;

// export function NSAccessibilityPostNotification(element: any, notification: string): void;

// export function NSAccessibilityPostNotificationWithUserInfo(element: any, notification: string, userInfo: Map<string, any>): void;

interface NSAccessibilityProgressIndicator {
  accessibilityValue(): number;
}

interface NSAccessibilityRadioButton {
  accessibilityValue(): number;
}

// export function NSAccessibilityRoleDescription(role: string, subrole: string): string;

// export function NSAccessibilityRoleDescriptionForUIElement(element: any): string;

interface NSAccessibilityRow {
  accessibilityDisclosureLevel(): number;
  accessibilityIndex(): number;
}

// export function NSAccessibilitySetMayContainProtectedContent(flag: boolean): boolean;

interface NSAccessibilitySlider {
  accessibilityLabel(): string;
  accessibilityPerformDecrement(): boolean;
  accessibilityPerformIncrement(): boolean;
  accessibilityValue(): any;
}

interface NSAccessibilityStaticText {
  accessibilityAttributedStringForRange(for_: NSRange): NSAttributedString;
  accessibilityValue(): string;
  accessibilityVisibleCharacterRange(): NSRange;
}

interface NSAccessibilityStepper {
  accessibilityLabel(): string;
  accessibilityPerformDecrement(): boolean;
  accessibilityPerformIncrement(): boolean;
  accessibilityValue(): any;
}

interface NSAccessibilitySwitch {
  accessibilityPerformDecrement(): boolean;
  accessibilityPerformIncrement(): boolean;
  accessibilityValue(): string;
}

interface NSAccessibilityTable {
  accessibilityColumnHeaderUIElements(): any[];
  accessibilityColumns(): any[];
  accessibilityLabel(): string;
  accessibilityRowHeaderUIElements(): any[];
  accessibilityRows(): any[];
  accessibilitySelectedCells(): any[];
  accessibilitySelectedColumns(): any[];
  accessibilitySelectedRows(): any[];
  accessibilityVisibleCells(): any[];
  accessibilityVisibleColumns(): any[];
  accessibilityVisibleRows(): any[];
  setAccessibilitySelectedRows(_: any[]): void;
}

// export function NSAccessibilityUnignoredAncestor(element: any): any;

// export function NSAccessibilityUnignoredChildren(originalChildren: any[]): any[];

// export function NSAccessibilityUnignoredChildrenForOnlyChild(originalChild: any): any[];

// export function NSAccessibilityUnignoredDescendant(element: any): any;

export class NSActionCell extends NSCell {
}

export class NSAlert extends NSObject {
  accessoryView: NSView;
  setAccessoryView(_: NSView);
  alertStyle: NSAlert.Style;
  setAlertStyle(_: NSAlert.Style);
  buttons: NSButton[];
  delegate: any;
  setDelegate(_: any);
  helpAnchor: string;
  setHelpAnchor(_: string);
  icon: NSImage;
  setIcon(_: NSImage);
  informativeText: string;
  setInformativeText(_: string);
  messageText: string;
  setMessageText(_: string);
  showsHelp: boolean;
  setShowsHelp(_: boolean);
  showsSuppressionButton: boolean;
  setShowsSuppressionButton(_: boolean);
  suppressionButton: NSButton;
  window: NSWindow;
  addButtonWithTitle(withTitle: string): NSButton;
  beginSheetModalForWindowCompletionHandler(for_: NSWindow, completionHandler?: (p1: number) => void): void;
  layout(): void;
  runModal(): number;
}

interface NSAlertDelegate {
  alertShowHelp(_: NSAlert): boolean;
}

export class NSAlignmentFeedbackFilter extends NSObject {
  static inputEventMask: NSEvent.EventTypeMask;
  alignmentFeedbackTokenForHorizontalMovementInViewPreviousXAlignedXDefaultX(in_?: NSView, previousX?: number, alignedX?: number, defaultX?: number): any;
  alignmentFeedbackTokenForMovementInViewPreviousPointAlignedPointDefaultPoint(in_?: NSView, previousPoint?: CGPoint, alignedPoint?: CGPoint, defaultPoint?: CGPoint): any;
  alignmentFeedbackTokenForVerticalMovementInViewPreviousYAlignedYDefaultY(in_?: NSView, previousY?: number, alignedY?: number, defaultY?: number): any;
  performFeedbackPerformanceTime(_: any[], performanceTime: NSHapticFeedback.NSHapticFeedbackManager.PerformanceTime): void;
  updateWithEvent(with_: NSEvent): void;
  updateWithPanRecognizer(withPanRecognizer: NSPanGestureRecognizer): void;
}

interface NSAlignmentFeedbackToken {
}

interface NSAnimatablePropertyContainer {
  animations: Map<string, any>;
  setAnimations(_: Map<string, any>);
  animationForKey(forKey: string): any;
  animator(): NSAnimatablePropertyContainer;
}

export class NSAnimation extends NSObject {
  isAnimating: boolean;
  animationBlockingMode: NSAnimation.BlockingMode;
  setAnimationBlockingMode(_: NSAnimation.BlockingMode);
  animationCurve: NSAnimation.Curve;
  setAnimationCurve(_: NSAnimation.Curve);
  currentProgress: number;
  setCurrentProgress(_: number);
  currentValue: number;
  delegate: any;
  setDelegate(_: any);
  duration: number;
  setDuration(_: number);
  frameRate: number;
  setFrameRate(_: number);
  progressMarks: number[];
  setProgressMarks(_: number[]);
  runLoopModesForAnimating: string[];
  addProgressMark(_: number): void;
  clearStartAnimation(): void;
  clearStopAnimation(): void;
  static initWithDurationAnimationCurve(_: number, animationCurve: NSAnimation.Curve): NSAnimation;
  removeProgressMark(_: number): void;
  startAnimation(): void;
  startWhenAnimationReachesProgress(when: NSAnimation, reachesProgress: number): void;
  stopAnimation(): void;
  stopWhenAnimationReachesProgress(when: NSAnimation, reachesProgress: number): void;
}

export class NSAnimationContext extends NSObject {
  static beginGrouping(): void;
  static endGrouping(): void;
  static runAnimationGroup(_: (p1: NSAnimationContext) => void): void;
  static runAnimationGroupCompletionHandler(_: (p1: NSAnimationContext) => void, completionHandler?: () => void): void;
  allowsImplicitAnimation: boolean;
  setAllowsImplicitAnimation(_: boolean);
  completionHandler: () => void;
  setCompletionHandler(_: () => void);
  duration: number;
  setDuration(_: number);
  timingFunction: CAMediaTimingFunction;
  setTimingFunction(_: CAMediaTimingFunction);
  static currentContext: NSAnimationContext;
}

interface NSAnimationDelegate {
  animationValueForProgress(_: NSAnimation, valueForProgress: number): number;
  animationDidReachProgressMark(_: NSAnimation, didReachProgressMark: number): void;
  animationDidEnd(_: NSAnimation): void;
  animationDidStop(_: NSAnimation): void;
  animationShouldStart(_: NSAnimation): boolean;
}

export class NSAppearance extends NSObject {
  allowsVibrancy: boolean;
  name: string;
  static currentAppearance: NSAppearance;
  setCurrentAppearance(_: NSAppearance);
  bestMatchFromAppearancesWithNames(from: string[]): string;
  static initWithAppearanceNamedBundle(_: string, bundle?: Bundle): NSAppearance;
}

interface NSAppearanceCustomization {
  appearance: NSAppearance;
  setAppearance(_: NSAppearance);
  effectiveAppearance: NSAppearance;
}

export class NSApplication extends NSResponder {
  static detachDrawingThreadToTargetWithObject(_: string, toTarget: any, with_?: any): void;
  isActive: boolean;
  applicationIconImage: NSImage;
  setApplicationIconImage(_: NSImage);
  isAutomaticCustomizeTouchBarMenuItemEnabled: boolean;
  setAutomaticCustomizeTouchBarMenuItemEnabled(_: boolean);
  currentEvent: NSEvent;
  currentSystemPresentationOptions: NSApplication.PresentationOptions;
  delegate: any;
  setDelegate(_: any);
  dockTile: NSDockTile;
  enabledRemoteNotificationTypes: NSApplication.RemoteNotificationType;
  isFullKeyboardAccessEnabled: boolean;
  helpMenu: NSMenu;
  setHelpMenu(_: NSMenu);
  isHidden: boolean;
  keyWindow: NSWindow;
  mainMenu: NSMenu;
  setMainMenu(_: NSMenu);
  mainWindow: NSWindow;
  modalWindow: NSWindow;
  occlusionState: NSApplication.OcclusionState;
  orderedDocuments: NSDocument[];
  orderedWindows: NSWindow[];
  presentationOptions: NSApplication.PresentationOptions;
  setPresentationOptions(_: NSApplication.PresentationOptions);
  isRegisteredForRemoteNotifications: boolean;
  isRunning: boolean;
  servicesMenu: NSMenu;
  setServicesMenu(_: NSMenu);
  servicesProvider: any;
  setServicesProvider(_: any);
  userInterfaceLayoutDirection: NSUserInterfaceLayout.NSUserInterfaceLayoutDirection;
  windows: NSWindow[];
  windowsMenu: NSMenu;
  setWindowsMenu(_: NSMenu);
  static sharedApplication: NSApplication;
  abortModal(): void;
  activateContextHelpMode(_?: any): void;
  activateIgnoringOtherApps(ignoringOtherApps: boolean): void;
  activationPolicy(): NSRunningApplication.NSApplication.ActivationPolicy;
  addWindowsItemTitleFilename(_: NSWindow, title: string, filename: boolean): void;
  arrangeInFront(_?: any): void;
  beginModalSessionForWindow(for_: NSWindow): any;
  cancelUserAttentionRequest(_: number): void;
  changeWindowsItemTitleFilename(_: NSWindow, title: string, filename: boolean): void;
  completeStateRestoration(): void;
  deactivate(): void;
  disableRelaunchOnLogin(): void;
  discardEventsMatchingMaskBeforeEvent(matching: NSEvent.EventTypeMask, before?: NSEvent): void;
  enableRelaunchOnLogin(): void;
  endModalSession(_: any): void;
  enumerateWindowsWithOptionsUsingBlock(options: NSApplication.WindowListOptions, using: (p1: NSWindow, p2: boolean) => void): void;
  extendStateRestoration(): void;
  finishLaunching(): void;
  hide(_?: any): void;
  hideOtherApplications(_?: any): void;
  miniaturizeAll(_?: any): void;
  nextEventMatchingMaskUntilDateInModeDequeue(matching: NSEvent.EventTypeMask, until?: Date, inMode?: string, dequeue?: boolean): NSEvent;
  orderFrontCharacterPalette(_?: any): void;
  orderFrontColorPanel(_?: any): void;
  orderFrontStandardAboutPanel(_?: any): void;
  orderFrontStandardAboutPanelWithOptions(options: Map<string, any>): void;
  postEventAtStart(_: NSEvent, atStart: boolean): void;
  preventWindowOrdering(): void;
  registerForRemoteNotificationTypes(matching: NSApplication.RemoteNotificationType): void;
  registerForRemoteNotifications(): void;
  registerServicesMenuSendTypesReturnTypes(_: string[], returnTypes: string[]): void;
  registerUserInterfaceItemSearchHandler(_: any): void;
  removeWindowsItem(_: NSWindow): void;
  replyToApplicationShouldTerminate(toApplicationShouldTerminate: boolean): void;
  replyToOpenOrPrint(toOpenOrPrint: NSApplication.DelegateReply): void;
  reportException(_: NSException): void;
  requestUserAttention(_: NSApplication.RequestUserAttentionType): number;
  restoreWindowWithIdentifierStateCompletionHandler(withIdentifier: string, state: NSCoder, completionHandler?: (p1: NSWindow, p2: Error) => void): boolean;
  run(): void;
  runModalForWindow(for_: NSWindow): number;
  runModalSession(_: any): number;
  runPageLayout(_?: any): void;
  searchStringInUserInterfaceItemStringSearchRangeFoundRange(_: string, inUserInterfaceItemString: string, range: NSRange, found?: NSRange): boolean;
  sendActionToFrom(_: string, to?: any, from?: any): boolean;
  sendEvent(_: NSEvent): void;
  setActivationPolicy(_: NSRunningApplication.NSApplication.ActivationPolicy): boolean;
  setWindowsNeedUpdate(_: boolean): void;
  showHelp(_?: any): void;
  stop(_?: any): void;
  stopModal(): void;
  stopModalWithCode(withCode: number): void;
  targetForAction(forAction: string): any;
  targetForActionToFrom(forAction: string, to?: any, from?: any): any;
  terminate(_?: any): void;
  toggleTouchBarCustomizationPalette(_?: any): void;
  unhide(_?: any): void;
  unhideAllApplications(_?: any): void;
  unhideWithoutActivation(): void;
  unregisterForRemoteNotifications(): void;
  unregisterUserInterfaceItemSearchHandler(_: any): void;
  updateWindows(): void;
  updateWindowsItem(_: NSWindow): void;
  windowWithWindowNumber(withWindowNumber: number): NSWindow;
}

interface NSApplicationDelegate {
  applicationContinueUserActivityRestorationHandler(_: NSApplication, continue_: NSUserActivity, restorationHandler: (p1: any[]) => void): boolean;
  applicationOpenURLs(_: NSApplication, open: URL[]): void;
  applicationOpenFile(_: NSApplication, openFile: string): boolean;
  applicationOpenFiles(_: NSApplication, openFiles: string[]): void;
  applicationOpenTempFile(_: NSApplication, openTempFile: string): boolean;
  applicationDelegateHandlesKey(_: NSApplication, delegateHandlesKey: string): boolean;
  applicationOpenFileWithoutUI(_: any, openFileWithoutUI: string): boolean;
  applicationPrintFile(_: NSApplication, printFile: string): boolean;
  applicationPrintFilesWithSettingsShowPrintPanels(_: NSApplication, printFiles: string[], withSettings: Map<string, any>, showPrintPanels: boolean): NSApplication.PrintReply;
  applicationUserDidAcceptCloudKitShareWithMetadata(_: NSApplication, userDidAcceptCloudKitShareWith: CKShare.Metadata): void;
  applicationDidUpdateUserActivity(_: NSApplication, didUpdate: NSUserActivity): void;
  applicationDidFailToContinueUserActivityWithTypeError(_: NSApplication, didFailToContinueUserActivityWithType: string, error: Error): void;
  applicationWillPresentError(_: NSApplication, willPresentError: Error): Error;
  applicationDidRegisterForRemoteNotificationsWithDeviceToken(_: NSApplication, didRegisterForRemoteNotificationsWithDeviceToken: Data): void;
  applicationDidFailToRegisterForRemoteNotificationsWithError(_: NSApplication, didFailToRegisterForRemoteNotificationsWithError: Error): void;
  applicationDidReceiveRemoteNotification(_: NSApplication, didReceiveRemoteNotification: Map<string, any>): void;
  applicationWillEncodeRestorableState(_: NSApplication, willEncodeRestorableState: NSCoder): void;
  applicationDidDecodeRestorableState(_: NSApplication, didDecodeRestorableState: NSCoder): void;
  applicationWillContinueUserActivityWithType(_: NSApplication, willContinueUserActivityWithType: string): boolean;
  applicationDidBecomeActive(_: Notification): void;
  applicationDidChangeOcclusionState(_: Notification): void;
  applicationDidChangeScreenParameters(_: Notification): void;
  applicationDidFinishLaunching(_: Notification): void;
  applicationDidHide(_: Notification): void;
  applicationDidResignActive(_: Notification): void;
  applicationDidUnhide(_: Notification): void;
  applicationDidUpdate(_: Notification): void;
  applicationDockMenu(_: NSApplication): NSMenu;
  applicationOpenUntitledFile(_: NSApplication): boolean;
  applicationShouldHandleReopenHasVisibleWindows(_: NSApplication, hasVisibleWindows: boolean): boolean;
  applicationShouldOpenUntitledFile(_: NSApplication): boolean;
  applicationShouldTerminate(_: NSApplication): NSApplication.TerminateReply;
  applicationShouldTerminateAfterLastWindowClosed(_: NSApplication): boolean;
  applicationWillBecomeActive(_: Notification): void;
  applicationWillFinishLaunching(_: Notification): void;
  applicationWillHide(_: Notification): void;
  applicationWillResignActive(_: Notification): void;
  applicationWillTerminate(_: Notification): void;
  applicationWillUnhide(_: Notification): void;
  applicationWillUpdate(_: Notification): void;
}

// export function NSApplicationLoad(): boolean;

// export function NSApplicationMain(argc: number, argv: string): never;

export class NSArrayController extends NSObjectController {
  alwaysUsesMultipleValuesMarker: boolean;
  setAlwaysUsesMultipleValuesMarker(_: boolean);
  arrangedObjects: any;
  automaticRearrangementKeyPaths: string[];
  automaticallyRearrangesObjects: boolean;
  setAutomaticallyRearrangesObjects(_: boolean);
  avoidsEmptySelection: boolean;
  setAvoidsEmptySelection(_: boolean);
  canInsert: boolean;
  canSelectNext: boolean;
  canSelectPrevious: boolean;
  clearsFilterPredicateOnInsertion: boolean;
  setClearsFilterPredicateOnInsertion(_: boolean);
  filterPredicate: NSPredicate;
  setFilterPredicate(_: NSPredicate);
  preservesSelection: boolean;
  setPreservesSelection(_: boolean);
  selectionIndex: number;
  selectionIndexes: IndexSet;
  selectsInsertedObjects: boolean;
  setSelectsInsertedObjects(_: boolean);
  sortDescriptors: NSSortDescriptor[];
  setSortDescriptors(_: NSSortDescriptor[]);
  addObjects(contentsOf: any[]): void;
  addSelectedObjects(_: any[]): boolean;
  addSelectionIndexes(_: IndexSet): boolean;
  arrangeObjects(_: any[]): any[];
  didChangeArrangementCriteria(): void;
  insert(_?: any): void;
  insertObjectAtArrangedObjectIndex(_: any, atArrangedObjectIndex: number): void;
  insertObjectsAtArrangedObjectIndexes(contentsOf: any[], atArrangedObjectIndexes: IndexSet): void;
  rearrangeObjects(): void;
  removeObjectAtArrangedObjectIndex(atArrangedObjectIndex: number): void;
  removeObjects(contentsOf: any[]): void;
  removeObjectsAtArrangedObjectIndexes(atArrangedObjectIndexes: IndexSet): void;
  removeSelectedObjects(_: any[]): boolean;
  removeSelectionIndexes(_: IndexSet): boolean;
  selectNext(_?: any): void;
  selectPrevious(_?: any): void;
  setSelectedObjects(_: any[]): boolean;
  setSelectionIndex(_: number): boolean;
  setSelectionIndexes(_: IndexSet): boolean;
}

// export function NSAvailableWindowDepths(): NSGraphics.NSWindow.Depth;

// export function NSBeep(): void;

// export function NSBestDepth(colorSpace: string, bps: number, bpp: number, planar: boolean, exactMatch: boolean): NSGraphics.NSWindow.Depth;

export class NSBezierPath extends NSObject {
  static clipRect(_: CGRect): void;
  static drawPackedGlyphsAtPoint(_: string, at: CGPoint): void;
  static fillRect(_: CGRect): void;
  static strokeLineFromPointToPoint(from: CGPoint, to: CGPoint): void;
  static strokeRect(_: CGRect): void;
  bezierPathByFlatteningPath: NSBezierPath;
  bezierPathByReversingPath: NSBezierPath;
  bounds: CGRect;
  controlPointBounds: CGRect;
  currentPoint: CGPoint;
  elementCount: number;
  isEmpty: boolean;
  flatness: number;
  setFlatness(_: number);
  lineCapStyle: NSBezierPath.LineCapStyle;
  setLineCapStyle(_: NSBezierPath.LineCapStyle);
  lineJoinStyle: NSBezierPath.LineJoinStyle;
  setLineJoinStyle(_: NSBezierPath.LineJoinStyle);
  lineWidth: number;
  setLineWidth(_: number);
  miterLimit: number;
  setMiterLimit(_: number);
  windingRule: NSBezierPath.WindingRule;
  setWindingRule(_: NSBezierPath.WindingRule);
  static defaultFlatness: number;
  setDefaultFlatness(_: number);
  static defaultLineCapStyle: NSBezierPath.LineCapStyle;
  setDefaultLineCapStyle(_: NSBezierPath.LineCapStyle);
  static defaultLineJoinStyle: NSBezierPath.LineJoinStyle;
  setDefaultLineJoinStyle(_: NSBezierPath.LineJoinStyle);
  static defaultLineWidth: number;
  setDefaultLineWidth(_: number);
  static defaultMiterLimit: number;
  setDefaultMiterLimit(_: number);
  static defaultWindingRule: NSBezierPath.WindingRule;
  setDefaultWindingRule(_: NSBezierPath.WindingRule);
  addClip(): void;
  appendBezierPath(_: NSBezierPath): void;
  appendBezierPathWithArcFromPointToPointRadius(from: CGPoint, to: CGPoint, radius: number): void;
  appendBezierPathWithArcWithCenterRadiusStartAngleEndAngle(withCenter: CGPoint, radius: number, startAngle: number, endAngle: number): void;
  appendBezierPathWithArcWithCenterRadiusStartAngleEndAngleClockwise(withCenter: CGPoint, radius: number, startAngle: number, endAngle: number, clockwise: boolean): void;
  appendBezierPathWithCGGlyphInFont(withCGGlyph: number, in_: NSFont): void;
  appendBezierPathWithCGGlyphsCountInFont(withCGGlyphs: number, count: number, in_: NSFont): void;
  appendBezierPathWithOvalInRect(in_: CGRect): void;
  appendBezierPathWithPointsCount(_: CGPoint, count: number): void;
  appendBezierPathWithRect(_: CGRect): void;
  appendBezierPathWithRoundedRectXRadiusYRadius(_: CGRect, xRadius: number, yRadius: number): void;
  closePath(): void;
  containsPoint(_: CGPoint): boolean;
  curveToPointControlPoint1ControlPoint2(to: CGPoint, controlPoint1: CGPoint, controlPoint2: CGPoint): void;
  elementAtIndex(at: number): NSBezierPath.ElementType;
  elementAtIndexAssociatedPoints(at: number, associatedPoints?: CGPoint): NSBezierPath.ElementType;
  fill(): void;
  getLineDashCountPhase(_?: number, count?: number, phase?: number): void;
  lineToPoint(to: CGPoint): void;
  moveToPoint(to: CGPoint): void;
  relativeCurveToPointControlPoint1ControlPoint2(to: CGPoint, controlPoint1: CGPoint, controlPoint2: CGPoint): void;
  relativeLineToPoint(to: CGPoint): void;
  relativeMoveToPoint(to: CGPoint): void;
  removeAllPoints(): void;
  setAssociatedPointsAtIndex(_?: CGPoint, at?: number): void;
  setClip(): void;
  setLineDashCountPhase(_?: number, count?: number, phase?: number): void;
  stroke(): void;
  transformUsingAffineTransform(using: AffineTransform): void;
}

export class NSBindingSelectionMarker extends NSObject {
  static defaultPlaceholderForMarkerOnClassWithBinding(for_?: NSBindingSelectionMarker, on?: typeof NSObject, withBinding?: string): any;
  static setDefaultPlaceholderForMarkerOnClassWithBinding(_?: any, for_?: NSBindingSelectionMarker, on?: typeof NSObject, withBinding?: string): void;
  static multipleValuesSelectionMarker: NSBindingSelectionMarker;
  static noSelectionMarker: NSBindingSelectionMarker;
  static notApplicableSelectionMarker: NSBindingSelectionMarker;
}

export class NSBitmapImageRep extends NSImageRep {
  static tIFFRepresentationOfImageRepsInArray(in_: NSImageRep[]): Data;
  static tIFFRepresentationOfImageRepsInArrayUsingCompressionFactor(in_: NSImageRep[], using: NSBitmapImageRep.TIFFCompression, factor: number): Data;
  static getTIFFCompressionTypesCount(_?: NSBitmapImageRep.TIFFCompression, count?: number): void;
  static imageRepsWithData(with_: Data): NSImageRep[];
  static localizedNameForTIFFCompressionType(forTIFFCompressionType: NSBitmapImageRep.TIFFCompression): string;
  static representationOfImageRepsInArrayUsingTypeProperties(in_: NSImageRep[], using: NSBitmapImageRep.FileType, properties: Map<string, any>): Data;
  CGImage: any;
  TIFFRepresentation: Data;
  bitmapData: string;
  bitmapFormat: NSBitmapImageRep.Format;
  bitsPerPixel: number;
  bytesPerPlane: number;
  bytesPerRow: number;
  colorSpace: NSColorSpace;
  numberOfPlanes: number;
  isPlanar: boolean;
  samplesPerPixel: number;
  tIFFRepresentationUsingCompressionFactor(using: NSBitmapImageRep.TIFFCompression, factor: number): Data;
  bitmapImageRepByConvertingToColorSpaceRenderingIntent(to: NSColorSpace, renderingIntent: NSGraphics.NSColorRenderingIntent): NSBitmapImageRep;
  bitmapImageRepByRetaggingWithColorSpace(with_: NSColorSpace): NSBitmapImageRep;
  canBeCompressedUsing(using: NSBitmapImageRep.TIFFCompression): boolean;
  colorAtXY(x: number, y: number): NSColor;
  colorizeByMappingGrayToColorBlackMappingWhiteMapping(byMappingGray: number, to?: NSColor, blackMapping?: NSColor, whiteMapping?: NSColor): void;
  getBitmapDataPlanes(_?: string): void;
  getCompressionFactor(_?: NSBitmapImageRep.TIFFCompression, factor?: number): void;
  getPixelAtXY(_: number, atX: number, y: number): void;
  incrementalLoadFromDataComplete(from: Data, complete: boolean): number;
  static initForIncrementalLoad(): NSBitmapImageRep;
  static initWithBitmapDataPlanesPixelsWidePixelsHighBitsPerSampleSamplesPerPixelHasAlphaIsPlanarColorSpaceNameBitmapFormatBytesPerRowBitsPerPixel(_?: string, pixelsWide?: number, pixelsHigh?: number, bitsPerSample?: number, samplesPerPixel?: number, hasAlpha?: boolean, isPlanar?: boolean, colorSpaceName?: string, bitmapFormat?: NSBitmapImageRep.Format, bytesPerRow?: number, bitsPerPixel?: number): NSBitmapImageRep;
  static initWithBitmapDataPlanesPixelsWidePixelsHighBitsPerSampleSamplesPerPixelHasAlphaIsPlanarColorSpaceNameBytesPerRowBitsPerPixel(_?: string, pixelsWide?: number, pixelsHigh?: number, bitsPerSample?: number, samplesPerPixel?: number, hasAlpha?: boolean, isPlanar?: boolean, colorSpaceName?: string, bytesPerRow?: number, bitsPerPixel?: number): NSBitmapImageRep;
  static initWithCGImage(_: any): NSBitmapImageRep;
  static initWithCIImage(_: CIImage): NSBitmapImageRep;
  static initWithData(_: Data): NSBitmapImageRep;
  representationUsingTypeProperties(using: NSBitmapImageRep.FileType, properties: Map<string, any>): Data;
  setColorAtXY(_: NSColor, atX: number, y: number): void;
  setCompressionFactor(_: NSBitmapImageRep.TIFFCompression, factor: number): void;
  setPixelAtXY(_: number, atX: number, y: number): void;
  setPropertyWithValue(_: string, withValue?: any): void;
  valueForProperty(forProperty: string): any;
}

// export function NSBitsPerPixelFromDepth(depth: NSGraphics.NSWindow.Depth): number;

// export function NSBitsPerSampleFromDepth(depth: NSGraphics.NSWindow.Depth): number;

export class NSBox extends NSView {
  borderColor: NSColor;
  setBorderColor(_: NSColor);
  borderRect: CGRect;
  borderWidth: number;
  setBorderWidth(_: number);
  boxType: NSBox.BoxType;
  setBoxType(_: NSBox.BoxType);
  contentView: NSView;
  setContentView(_: NSView);
  contentViewMargins: CGSize;
  setContentViewMargins(_: CGSize);
  cornerRadius: number;
  setCornerRadius(_: number);
  fillColor: NSColor;
  setFillColor(_: NSColor);
  title: string;
  setTitle(_: string);
  titleCell: any;
  titleFont: NSFont;
  setTitleFont(_: NSFont);
  titlePosition: NSBox.TitlePosition;
  setTitlePosition(_: NSBox.TitlePosition);
  titleRect: CGRect;
  isTransparent: boolean;
  setTransparent(_: boolean);
  setFrameFromContentFrame(_: CGRect): void;
  sizeToFit(): void;
}

export class NSBrowser extends NSControl {
  static removeSavedColumnsWithAutosaveName(withAutosaveName: string): void;
  allowsBranchSelection: boolean;
  setAllowsBranchSelection(_: boolean);
  allowsEmptySelection: boolean;
  setAllowsEmptySelection(_: boolean);
  allowsMultipleSelection: boolean;
  setAllowsMultipleSelection(_: boolean);
  allowsTypeSelect: boolean;
  setAllowsTypeSelect(_: boolean);
  autohidesScroller: boolean;
  setAutohidesScroller(_: boolean);
  backgroundColor: NSColor;
  setBackgroundColor(_: NSColor);
  cellPrototype: any;
  setCellPrototype(_: any);
  clickedColumn: number;
  clickedRow: number;
  columnResizingType: NSBrowser.ColumnResizingType;
  setColumnResizingType(_: NSBrowser.ColumnResizingType);
  columnsAutosaveName: string;
  setColumnsAutosaveName(_: string);
  delegate: any;
  setDelegate(_: any);
  doubleAction: string;
  setDoubleAction(_: string);
  firstVisibleColumn: number;
  hasHorizontalScroller: boolean;
  setHasHorizontalScroller(_: boolean);
  lastColumn: number;
  setLastColumn(_: number);
  lastVisibleColumn: number;
  isLoaded: boolean;
  maxVisibleColumns: number;
  setMaxVisibleColumns(_: number);
  minColumnWidth: number;
  setMinColumnWidth(_: number);
  numberOfVisibleColumns: number;
  pathSeparator: string;
  setPathSeparator(_: string);
  prefersAllColumnUserResizing: boolean;
  setPrefersAllColumnUserResizing(_: boolean);
  reusesColumns: boolean;
  setReusesColumns(_: boolean);
  rowHeight: number;
  setRowHeight(_: number);
  selectedCells: NSCell[];
  selectedColumn: number;
  selectionIndexPath: IndexPath;
  setSelectionIndexPath(_: IndexPath);
  selectionIndexPaths: IndexPath[];
  setSelectionIndexPaths(_: IndexPath[]);
  sendsActionOnArrowKeys: boolean;
  setSendsActionOnArrowKeys(_: boolean);
  separatesColumns: boolean;
  setSeparatesColumns(_: boolean);
  takesTitleFromPreviousColumn: boolean;
  setTakesTitleFromPreviousColumn(_: boolean);
  titleHeight: number;
  isTitled: boolean;
  setTitled(_: boolean);
  static cellClass: typeof NSObject;
  addColumn(): void;
  canDragRowsWithIndexesInColumnWithEvent(with_: IndexSet, inColumn: number, with_2: NSEvent): boolean;
  columnContentWidthForColumnWidth(forColumnWidth: number): number;
  columnWidthForColumnContentWidth(forColumnContentWidth: number): number;
  defaultColumnWidth(): number;
  doClick(_?: any): void;
  doDoubleClick(_?: any): void;
  draggingImageForRowsWithIndexesInColumnWithEventOffset(with_: IndexSet, inColumn: number, with_2: NSEvent, offset?: CGPoint): NSImage;
  drawTitleOfColumnInRect(ofColumn: number, in_: CGRect): void;
  editItemAtIndexPathWithEventSelect(at: IndexPath, with_?: NSEvent, select?: boolean): void;
  getRowColumnForPoint(_?: number, column?: number, for_?: CGPoint): boolean;
  indexPathForColumn(forColumn: number): IndexPath;
  isLeafItem(_?: any): boolean;
  itemAtIndexPath(at: IndexPath): any;
  itemAtRowInColumn(atRow: number, inColumn: number): any;
  loadColumnZero(): void;
  loadedCellAtRowColumn(atRow: number, column: number): any;
  noteHeightOfRowsWithIndexesChangedInColumn(_: IndexSet, inColumn: number): void;
  parentForItemsInColumn(inColumn: number): any;
  path(): string;
  pathToColumn(toColumn: number): string;
  reloadColumn(_: number): void;
  reloadDataForRowIndexesInColumn(forRowIndexes: IndexSet, inColumn: number): void;
  scrollColumnToVisible(_: number): void;
  scrollColumnsLeftBy(by: number): void;
  scrollColumnsRightBy(by: number): void;
  scrollRowToVisibleInColumn(_: number, inColumn: number): void;
  selectRowInColumn(_: number, inColumn: number): void;
  selectRowIndexesInColumn(_: IndexSet, inColumn: number): void;
  // dupe name w instance property   selectedCellInColumn(inColumn: number): any;
  selectedRowInColumn(inColumn: number): number;
  selectedRowIndexesInColumn(inColumn: number): IndexSet;
  sendAction(): boolean;
  setCellClass(_: typeof NSObject): void;
  setDefaultColumnWidth(_: number): void;
  setDraggingSourceOperationMaskForLocal(_: NSDragging.NSDragOperation, forLocal: boolean): void;
  setPath(_: string): boolean;
  setTitleOfColumn(_: string, ofColumn: number): void;
  setWidthOfColumn(_: number, ofColumn: number): void;
  tile(): void;
  titleFrameOfColumn(ofColumn: number): CGRect;
  titleOfColumn(ofColumn: number): string;
  validateVisibleColumns(): void;
  widthOfColumn(ofColumn: number): number;
}

export class NSBrowserCell extends NSCell {
  alternateImage: NSImage;
  setAlternateImage(_: NSImage);
  isLeaf: boolean;
  setLeaf(_: boolean);
  isLoaded: boolean;
  setLoaded(_: boolean);
  static branchImage: NSImage;
  static highlightedBranchImage: NSImage;
  highlightColorInView(in_: NSView): NSColor;
  reset(): void;
  set(): void;
}

interface NSBrowserDelegate {
  browserNumberOfRowsInColumn(_: NSBrowser, numberOfRowsInColumn: number): number;
  browserCreateRowsForColumnInMatrix(_: NSBrowser, createRowsForColumn: number, in_: NSMatrix): void;
  browserNumberOfChildrenOfItem(_: NSBrowser, numberOfChildrenOfItem?: any): number;
  browserChildOfItem(_: NSBrowser, child: number, ofItem?: any): any;
  browserIsLeafItem(_: NSBrowser, isLeafItem?: any): boolean;
  browserObjectValueForItem(_: NSBrowser, objectValueForItem?: any): any;
  browserHeightOfRowInColumn(_: NSBrowser, heightOfRow: number, inColumn: number): number;
  browserDidChangeLastColumnToColumn(_: NSBrowser, didChangeLastColumn: number, toColumn: number): void;
  browserSetObjectValueForItem(_: NSBrowser, setObjectValue?: any, forItem?: any): void;
  browserShouldEditItem(_: NSBrowser, shouldEditItem?: any): boolean;
  browserWillDisplayCellAtRowColumn(_: NSBrowser, willDisplayCell: any, atRow: number, column: number): void;
  browserTitleOfColumn(_: NSBrowser, titleOfColumn: number): string;
  browserSelectCellWithStringInColumn(_: NSBrowser, selectCellWith: string, inColumn: number): boolean;
  browserSelectRowInColumn(_: NSBrowser, selectRow: number, inColumn: number): boolean;
  browserIsColumnValid(_: NSBrowser, isColumnValid: number): boolean;
  browserHeaderViewControllerForItem(_: NSBrowser, headerViewControllerForItem?: any): NSViewController;
  browserSelectionIndexesForProposedSelectionInColumn(_: NSBrowser, selectionIndexesForProposedSelection: IndexSet, inColumn: number): IndexSet;
  browserShouldSizeColumnForUserResizeToWidth(_: NSBrowser, shouldSizeColumn: number, forUserResize: boolean, toWidth: number): number;
  browserSizeToFitWidthOfColumn(_: NSBrowser, sizeToFitWidthOfColumn: number): number;
  browserPreviewViewControllerForLeafItem(_: NSBrowser, previewViewControllerForLeafItem: any): NSViewController;
  browserShouldShowCellExpansionForRowColumn(_: NSBrowser, shouldShowCellExpansionForRow: number, column: number): boolean;
  browserWriteRowsWithIndexesInColumnToPasteboard(_: NSBrowser, writeRowsWith: IndexSet, inColumn: number, to: NSPasteboard): boolean;
  browserCanDragRowsWithIndexesInColumnWithEvent(_: NSBrowser, canDragRowsWith: IndexSet, inColumn: number, with_: NSEvent): boolean;
  browserDraggingImageForRowsWithIndexesInColumnWithEventOffset(_: NSBrowser, draggingImageForRowsWith: IndexSet, inColumn: number, with_: NSEvent, offset: CGPoint): NSImage;
  browserValidateDropProposedRowColumnDropOperation(_: NSBrowser, validateDrop: any, proposedRow: number, column: number, dropOperation: NSBrowser.DropOperation): NSDragging.NSDragOperation;
  browserAcceptDropAtRowColumnDropOperation(_: NSBrowser, acceptDrop: any, atRow: number, column: number, dropOperation: NSBrowser.DropOperation): boolean;
  browserTypeSelectStringForRowInColumn(_: NSBrowser, typeSelectStringForRow: number, inColumn: number): string;
  browserShouldTypeSelectForEventWithCurrentSearchString(_: NSBrowser, shouldTypeSelectFor: NSEvent, withCurrentSearch?: string): boolean;
  browserNextTypeSelectMatchFromRowToRowInColumnForString(_: NSBrowser, nextTypeSelectMatchFromRow: number, toRow: number, inColumn: number, for_?: string): number;
  browserColumnConfigurationDidChange(_: Notification): void;
  browserDidScroll(_: NSBrowser): void;
  browserWillScroll(_: NSBrowser): void;
  rootItemForBrowser(for_: NSBrowser): any;
}

export class NSButton extends NSControl {
  allowsMixedState: boolean;
  setAllowsMixedState(_: boolean);
  alternateImage: NSImage;
  setAlternateImage(_: NSImage);
  alternateTitle: string;
  setAlternateTitle(_: string);
  attributedAlternateTitle: NSAttributedString;
  setAttributedAlternateTitle(_: NSAttributedString);
  attributedTitle: NSAttributedString;
  setAttributedTitle(_: NSAttributedString);
  bezelColor: NSColor;
  setBezelColor(_: NSColor);
  bezelStyle: NSButtonCell.NSButton.BezelStyle;
  setBezelStyle(_: NSButtonCell.NSButton.BezelStyle);
  isBordered: boolean;
  setBordered(_: boolean);
  contentTintColor: NSColor;
  setContentTintColor(_: NSColor);
  image: NSImage;
  setImage(_: NSImage);
  imageHugsTitle: boolean;
  setImageHugsTitle(_: boolean);
  imagePosition: NSCell.NSControl.ImagePosition;
  setImagePosition(_: NSCell.NSControl.ImagePosition);
  imageScaling: NSCell.NSImageScaling;
  setImageScaling(_: NSCell.NSImageScaling);
  keyEquivalent: string;
  setKeyEquivalent(_: string);
  keyEquivalentModifierMask: NSEvent.ModifierFlags;
  setKeyEquivalentModifierMask(_: NSEvent.ModifierFlags);
  maxAcceleratorLevel: number;
  setMaxAcceleratorLevel(_: number);
  showsBorderOnlyWhileMouseInside: boolean;
  setShowsBorderOnlyWhileMouseInside(_: boolean);
  sound: NSSound;
  setSound(_: NSSound);
  isSpringLoaded: boolean;
  setSpringLoaded(_: boolean);
  state: number;
  setState(_: number);
  title: string;
  setTitle(_: string);
  isTransparent: boolean;
  setTransparent(_: boolean);
  getPeriodicDelayInterval(_: number, interval: number): void;
  highlight(_: boolean): void;
  setButtonType(_: NSButtonCell.NSButton.ButtonType): void;
  setNextState(): void;
  setPeriodicDelayInterval(_: number, interval: number): void;
}

export class NSButtonCell extends NSActionCell {
  alternateImage: NSImage;
  setAlternateImage(_: NSImage);
  alternateTitle: string;
  setAlternateTitle(_: string);
  attributedAlternateTitle: NSAttributedString;
  setAttributedAlternateTitle(_: NSAttributedString);
  attributedTitle: NSAttributedString;
  setAttributedTitle(_: NSAttributedString);
  backgroundColor: NSColor;
  setBackgroundColor(_: NSColor);
  bezelStyle: NSButtonCell.NSButton.BezelStyle;
  setBezelStyle(_: NSButtonCell.NSButton.BezelStyle);
  highlightsBy: NSCell.StyleMask;
  setHighlightsBy(_: NSCell.StyleMask);
  imageDimsWhenDisabled: boolean;
  setImageDimsWhenDisabled(_: boolean);
  imagePosition: NSCell.NSControl.ImagePosition;
  setImagePosition(_: NSCell.NSControl.ImagePosition);
  imageScaling: NSCell.NSImageScaling;
  setImageScaling(_: NSCell.NSImageScaling);
  keyEquivalent: string;
  setKeyEquivalent(_: string);
  keyEquivalentModifierMask: NSEvent.ModifierFlags;
  setKeyEquivalentModifierMask(_: NSEvent.ModifierFlags);
  showsBorderOnlyWhileMouseInside: boolean;
  setShowsBorderOnlyWhileMouseInside(_: boolean);
  showsStateBy: NSCell.StyleMask;
  setShowsStateBy(_: NSCell.StyleMask);
  sound: NSSound;
  setSound(_: NSSound);
  isTransparent: boolean;
  setTransparent(_: boolean);
  drawBezelWithFrameInView(withFrame: CGRect, in_: NSView): void;
  drawImageWithFrameInView(_: NSImage, withFrame: CGRect, in_: NSView): void;
  drawTitleWithFrameInView(_: NSAttributedString, withFrame: CGRect, in_: NSView): CGRect;
  mouseEntered(with_: NSEvent): void;
  mouseExited(with_: NSEvent): void;
  setButtonType(_: NSButtonCell.NSButton.ButtonType): void;
  setPeriodicDelayInterval(_: number, interval: number): void;
}

export class NSButtonTouchBarItem extends NSTouchBarItem {
  action: string;
  setAction(_: string);
  bezelColor: NSColor;
  setBezelColor(_: NSColor);
  customizationLabel: string;
  setCustomizationLabel(_: string);
  isEnabled: boolean;
  setEnabled(_: boolean);
  image: NSImage;
  setImage(_: NSImage);
  target: any;
  setTarget(_: any);
  title: string;
  setTitle(_: string);
}

export class NSCIImageRep extends NSImageRep {
  CIImage: CIImage;
  static initWithCIImage(_: CIImage): NSCIImageRep;
}

export class NSCandidateListTouchBarItem<CandidateType> extends NSTouchBarItem {
  allowsCollapsing: boolean;
  setAllowsCollapsing(_: boolean);
  allowsTextInputContextCandidates: boolean;
  setAllowsTextInputContextCandidates(_: boolean);
  attributedStringForCandidate: (p1: CandidateType, p2: number) => NSAttributedString;
  setAttributedStringForCandidate(_: (p1: CandidateType, p2: number) => NSAttributedString);
  isCandidateListVisible: boolean;
  candidates: CandidateType[];
  client: NSView;
  setClient(_: NSView);
  isCollapsed: boolean;
  setCollapsed(_: boolean);
  customizationLabel: string;
  setCustomizationLabel(_: string);
  delegate: any;
  setDelegate(_: any);
  setCandidatesForSelectedRangeInString(_: CandidateType[], forSelectedRange: NSRange, in_?: string): void;
  updateWithInsertionPointVisibility(withInsertionPointVisibility: boolean): void;
}

interface NSCandidateListTouchBarItemDelegate {
  candidateListTouchBarItemBeginSelectingCandidateAtIndex(_: NSCandidateListTouchBarItem<any>, beginSelectingCandidateAt: number): void;
  candidateListTouchBarItemChangeSelectionFromCandidateAtIndexToIndex(_: NSCandidateListTouchBarItem<any>, changeSelectionFromCandidateAt: number, to: number): void;
  candidateListTouchBarItemEndSelectingCandidateAtIndex(_: NSCandidateListTouchBarItem<any>, endSelectingCandidateAt: number): void;
  candidateListTouchBarItemChangedCandidateListVisibility(_: NSCandidateListTouchBarItem<any>, changedCandidateListVisibility: boolean): void;
}

export class NSCell extends NSObject implements NSUserInterfaceItemIdentification {
  acceptsFirstResponder: boolean;
  action: string;
  setAction(_: string);
  alignment: NSText.NSTextAlignment;
  setAlignment(_: NSText.NSTextAlignment);
  allowsEditingTextAttributes: boolean;
  setAllowsEditingTextAttributes(_: boolean);
  allowsMixedState: boolean;
  setAllowsMixedState(_: boolean);
  allowsUndo: boolean;
  setAllowsUndo(_: boolean);
  attributedStringValue: NSAttributedString;
  setAttributedStringValue(_: NSAttributedString);
  backgroundStyle: NSCell.NSView.BackgroundStyle;
  setBackgroundStyle(_: NSCell.NSView.BackgroundStyle);
  baseWritingDirection: NSText.NSWritingDirection;
  setBaseWritingDirection(_: NSText.NSWritingDirection);
  isBezeled: boolean;
  setBezeled(_: boolean);
  isBordered: boolean;
  setBordered(_: boolean);
  cellSize: CGSize;
  isContinuous: boolean;
  setContinuous(_: boolean);
  controlSize: NSCell.NSControl.ControlSize;
  setControlSize(_: NSCell.NSControl.ControlSize);
  controlView: NSView;
  setControlView(_: NSView);
  doubleValue: number;
  setDoubleValue(_: number);
  isEditable: boolean;
  setEditable(_: boolean);
  isEnabled: boolean;
  setEnabled(_: boolean);
  floatValue: number;
  setFloatValue(_: number);
  focusRingType: NSGraphics.NSFocusRingType;
  setFocusRingType(_: NSGraphics.NSFocusRingType);
  font: NSFont;
  setFont(_: NSFont);
  formatter: Formatter;
  setFormatter(_: Formatter);
  hasValidObjectValue: boolean;
  isHighlighted: boolean;
  setHighlighted(_: boolean);
  image: NSImage;
  setImage(_: NSImage);
  importsGraphics: boolean;
  setImportsGraphics(_: boolean);
  intValue: number;
  setIntValue(_: number);
  integerValue: number;
  setIntegerValue(_: number);
  interiorBackgroundStyle: NSCell.NSView.BackgroundStyle;
  keyEquivalent: string;
  lineBreakMode: NSParagraphStyle.NSLineBreakMode;
  setLineBreakMode(_: NSParagraphStyle.NSLineBreakMode);
  menu: NSMenu;
  setMenu(_: NSMenu);
  mouseDownFlags: number;
  nextState: number;
  objectValue: any;
  setObjectValue(_: any);
  isOpaque: boolean;
  refusesFirstResponder: boolean;
  setRefusesFirstResponder(_: boolean);
  representedObject: any;
  setRepresentedObject(_: any);
  isScrollable: boolean;
  setScrollable(_: boolean);
  isSelectable: boolean;
  setSelectable(_: boolean);
  sendsActionOnEndEditing: boolean;
  setSendsActionOnEndEditing(_: boolean);
  showsFirstResponder: boolean;
  setShowsFirstResponder(_: boolean);
  state: number;
  setState(_: number);
  stringValue: string;
  setStringValue(_: string);
  tag: number;
  setTag(_: number);
  target: any;
  setTarget(_: any);
  title: string;
  setTitle(_: string);
  truncatesLastVisibleLine: boolean;
  setTruncatesLastVisibleLine(_: boolean);
  type: NSCell.CellType;
  setType(_: NSCell.CellType);
  userInterfaceLayoutDirection: NSUserInterfaceLayout.NSUserInterfaceLayoutDirection;
  setUserInterfaceLayoutDirection(_: NSUserInterfaceLayout.NSUserInterfaceLayoutDirection);
  usesSingleLineMode: boolean;
  setUsesSingleLineMode(_: boolean);
  wantsNotificationForMarkedText: boolean;
  wraps: boolean;
  setWraps(_: boolean);
  static defaultFocusRingType: NSGraphics.NSFocusRingType;
  static defaultMenu: NSMenu;
  static prefersTrackingUntilMouseUp: boolean;
  identifier: string;
  setIdentifier(_: string);
  calcDrawInfo(_: CGRect): void;
  cellAttribute(_: NSCell.Attribute): number;
  // dupe name w instance property   cellSizeForBounds(forBounds: CGRect): CGSize;
  compare(_: any): NSObjCRuntime.ComparisonResult;
  continueTrackingAtInView(last: CGPoint, current: CGPoint, in_: NSView): boolean;
  draggingImageComponentsWithFrameInView(withFrame: CGRect, in_: NSView): NSDraggingImageComponent[];
  drawFocusRingMaskWithFrameInView(withFrame: CGRect, in_: NSView): void;
  drawInteriorWithFrameInView(withFrame: CGRect, in_: NSView): void;
  drawWithExpansionFrameInView(withExpansionFrame: CGRect, in_: NSView): void;
  drawWithFrameInView(withFrame: CGRect, in_: NSView): void;
  drawingRectForBounds(forBounds: CGRect): CGRect;
  editWithFrameInViewEditorDelegateEvent(withFrame: CGRect, in_: NSView, editor: NSText, delegate?: any, event?: NSEvent): void;
  endEditing(_: NSText): void;
  expansionFrameWithFrameInView(withFrame: CGRect, in_: NSView): CGRect;
  fieldEditorForView(for_: NSView): NSTextView;
  focusRingMaskBoundsForFrameInView(forFrame: CGRect, in_: NSView): CGRect;
  getPeriodicDelayInterval(_: number, interval: number): void;
  highlightWithFrameInView(_: boolean, withFrame: CGRect, in_: NSView): void;
  highlightColorWithFrameInView(withFrame: CGRect, in_: NSView): NSColor;
  hitTestForEventInRectOfView(for_: NSEvent, in_: CGRect, of: NSView): NSCell.HitResult;
  imageRectForBounds(forBounds: CGRect): CGRect;
  static initImageCell(_?: NSImage): NSCell;
  static initTextCell(_: string): NSCell;
  // dupe name w instance property   menuForEventInRectOfView(for_: NSEvent, in_: CGRect, of: NSView): NSMenu;
  performClick(_?: any): void;
  resetCursorRectInView(_: CGRect, in_: NSView): void;
  selectWithFrameInViewEditorDelegateStartLength(withFrame: CGRect, in_: NSView, editor: NSText, delegate?: any, start?: number, length?: number): void;
  sendActionOn(on: NSEvent.EventTypeMask): number;
  setCellAttributeTo(_: NSCell.Attribute, to: number): void;
  setNextState(): void;
  setUpFieldEditorAttributes(_: NSText): NSText;
  startTrackingAtInView(at: CGPoint, in_: NSView): boolean;
  stopTrackingAtInViewMouseIsUp(last: CGPoint, current: CGPoint, in_: NSView, mouseIsUp: boolean): void;
  takeDoubleValueFrom(_?: any): void;
  takeFloatValueFrom(_?: any): void;
  takeIntValueFrom(_?: any): void;
  takeIntegerValueFrom(_?: any): void;
  takeObjectValueFrom(_?: any): void;
  takeStringValueFrom(_?: any): void;
  titleRectForBounds(forBounds: CGRect): CGRect;
  trackMouseInRectOfViewUntilMouseUp(with_: NSEvent, in_: CGRect, of: NSView, untilMouseUp: boolean): boolean;
}

interface NSChangeSpelling {
  changeSpelling(_?: any): void;
}

export class NSClickGestureRecognizer extends NSGestureRecognizer {
  buttonMask: number;
  setButtonMask(_: number);
  numberOfClicksRequired: number;
  setNumberOfClicksRequired(_: number);
  numberOfTouchesRequired: number;
  setNumberOfTouchesRequired(_: number);
}

export class NSClipView extends NSView {
  automaticallyAdjustsContentInsets: boolean;
  setAutomaticallyAdjustsContentInsets(_: boolean);
  backgroundColor: NSColor;
  setBackgroundColor(_: NSColor);
  contentInsets: NSEdgeInsets;
  setContentInsets(_: NSEdgeInsets);
  documentCursor: NSCursor;
  setDocumentCursor(_: NSCursor);
  documentRect: CGRect;
  documentView: NSView;
  setDocumentView(_: NSView);
  documentVisibleRect: CGRect;
  drawsBackground: boolean;
  setDrawsBackground(_: boolean);
  constrainBoundsRect(_: CGRect): CGRect;
  scrollToPoint(to: CGPoint): void;
  viewBoundsChanged(_: Notification): void;
  viewFrameChanged(_: Notification): void;
}

interface NSCloudSharingServiceDelegate {
  optionsForSharingServiceShareProvider(for_: NSSharingService, share: NSItemProvider): NSSharingService.CloudKitOptions;
  sharingServiceDidCompleteForItemsError(_: NSSharingService, didCompleteForItems: any[], error?: Error): void;
  sharingServiceDidSaveShare(_: NSSharingService, didSave: CKShare): void;
  sharingServiceDidStopSharing(_: NSSharingService, didStopSharing: CKShare): void;
}

interface NSCloudSharingValidation {
  cloudShareForUserInterfaceItem(for_: any): CKShare;
}

export class NSCollectionLayoutAnchor extends NSObject {
  edges: NSCollectionViewCompositionalLayout.NSDirectionalRectEdge;
  isAbsoluteOffset: boolean;
  isFractionalOffset: boolean;
  offset: CGPoint;
}

export class NSCollectionLayoutBoundarySupplementaryItem extends NSCollectionLayoutSupplementaryItem {
  alignment: NSCollectionViewCompositionalLayout.NSRectAlignment;
  extendsBoundary: boolean;
  setExtendsBoundary(_: boolean);
  offset: CGPoint;
  pinToVisibleBounds: boolean;
  setPinToVisibleBounds(_: boolean);
}

interface NSCollectionLayoutContainer {
  contentInsets: NSDirectionalEdgeInsets;
  contentSize: CGSize;
  effectiveContentInsets: NSDirectionalEdgeInsets;
  effectiveContentSize: CGSize;
}

export class NSCollectionLayoutDecorationItem extends NSCollectionLayoutItem {
  static backgroundDecorationItemWithElementKind(elementKind: string): NSCollectionLayoutDecorationItem;
  elementKind: string;
  zIndex: number;
  setZIndex(_: number);
}

export class NSCollectionLayoutDimension extends NSObject {
  static absoluteDimension(_: number): NSCollectionLayoutDimension;
  static estimatedDimension(_: number): NSCollectionLayoutDimension;
  static fractionalHeightDimension(_: number): NSCollectionLayoutDimension;
  static fractionalWidthDimension(_: number): NSCollectionLayoutDimension;
  dimension: number;
  isAbsolute: boolean;
  isEstimated: boolean;
  isFractionalHeight: boolean;
  isFractionalWidth: boolean;
}

export class NSCollectionLayoutEdgeSpacing extends NSObject {
  bottom: NSCollectionLayoutSpacing;
  leading: NSCollectionLayoutSpacing;
  top: NSCollectionLayoutSpacing;
  trailing: NSCollectionLayoutSpacing;
}

interface NSCollectionLayoutEnvironment {
  container: any;
}

export class NSCollectionLayoutGroup extends NSCollectionLayoutItem {
  static customGroupWithLayoutSizeItemProvider(layoutSize: NSCollectionLayoutSize, itemProvider: (p1: any) => NSCollectionLayoutGroupCustomItem[]): NSCollectionLayoutGroup;
  static horizontalGroupWithLayoutSizeSubitemCount(layoutSize: NSCollectionLayoutSize, subitem: NSCollectionLayoutItem, count: number): NSCollectionLayoutGroup;
  static horizontalGroupWithLayoutSizeSubitems(layoutSize: NSCollectionLayoutSize, subitems: NSCollectionLayoutItem[]): NSCollectionLayoutGroup;
  static verticalGroupWithLayoutSizeSubitemCount(layoutSize: NSCollectionLayoutSize, subitem: NSCollectionLayoutItem, count: number): NSCollectionLayoutGroup;
  static verticalGroupWithLayoutSizeSubitems(layoutSize: NSCollectionLayoutSize, subitems: NSCollectionLayoutItem[]): NSCollectionLayoutGroup;
  interItemSpacing: NSCollectionLayoutSpacing;
  setInterItemSpacing(_: NSCollectionLayoutSpacing);
  subitems: NSCollectionLayoutItem[];
  supplementaryItems: NSCollectionLayoutSupplementaryItem[];
  setSupplementaryItems(_: NSCollectionLayoutSupplementaryItem[]);
  visualDescription(): string;
}

export class NSCollectionLayoutGroupCustomItem extends NSObject {
  frame: CGRect;
  zIndex: number;
}

export class NSCollectionLayoutItem extends NSObject {
  contentInsets: NSDirectionalEdgeInsets;
  setContentInsets(_: NSDirectionalEdgeInsets);
  edgeSpacing: NSCollectionLayoutEdgeSpacing;
  setEdgeSpacing(_: NSCollectionLayoutEdgeSpacing);
  layoutSize: NSCollectionLayoutSize;
  supplementaryItems: NSCollectionLayoutSupplementaryItem[];
}

export class NSCollectionLayoutSection extends NSObject {
  boundarySupplementaryItems: NSCollectionLayoutBoundarySupplementaryItem[];
  setBoundarySupplementaryItems(_: NSCollectionLayoutBoundarySupplementaryItem[]);
  contentInsets: NSDirectionalEdgeInsets;
  setContentInsets(_: NSDirectionalEdgeInsets);
  decorationItems: NSCollectionLayoutDecorationItem[];
  setDecorationItems(_: NSCollectionLayoutDecorationItem[]);
  interGroupSpacing: number;
  setInterGroupSpacing(_: number);
  orthogonalScrollingBehavior: NSCollectionViewCompositionalLayout.NSCollectionLayoutSectionOrthogonalScrollingBehavior;
  setOrthogonalScrollingBehavior(_: NSCollectionViewCompositionalLayout.NSCollectionLayoutSectionOrthogonalScrollingBehavior);
  supplementariesFollowContentInsets: boolean;
  setSupplementariesFollowContentInsets(_: boolean);
  visibleItemsInvalidationHandler: (p1: any[], p2: CGPoint, p3: any) => void;
  setVisibleItemsInvalidationHandler(_: (p1: any[], p2: CGPoint, p3: any) => void);
}

export class NSCollectionLayoutSize extends NSObject {
  heightDimension: NSCollectionLayoutDimension;
  widthDimension: NSCollectionLayoutDimension;
}

export class NSCollectionLayoutSpacing extends NSObject {
  static fixedSpacing(_: number): NSCollectionLayoutSpacing;
  static flexibleSpacing(_: number): NSCollectionLayoutSpacing;
  isFixedSpacing: boolean;
  isFlexibleSpacing: boolean;
  spacing: number;
}

export class NSCollectionLayoutSupplementaryItem extends NSCollectionLayoutItem {
  containerAnchor: NSCollectionLayoutAnchor;
  elementKind: string;
  itemAnchor: NSCollectionLayoutAnchor;
  zIndex: number;
  setZIndex(_: number);
}

interface NSCollectionLayoutVisibleItem {
  alpha: number;
  setAlpha(_: number);
  bounds: CGRect;
  center: CGPoint;
  setCenter(_: CGPoint);
  frame: CGRect;
  indexPath: IndexPath;
  isHidden: boolean;
  setHidden(_: boolean);
  name: string;
  representedElementCategory: NSCollectionViewLayout.NSCollectionElementCategory;
  representedElementKind: string;
  zIndex: number;
  setZIndex(_: number);
}

export class NSCollectionView extends NSView {
  allowsEmptySelection: boolean;
  setAllowsEmptySelection(_: boolean);
  allowsMultipleSelection: boolean;
  setAllowsMultipleSelection(_: boolean);
  backgroundColors: NSColor[];
  setBackgroundColors(_: NSColor[]);
  backgroundView: NSView;
  setBackgroundView(_: NSView);
  backgroundViewScrollsWithContent: boolean;
  setBackgroundViewScrollsWithContent(_: boolean);
  collectionViewLayout: NSCollectionViewLayout;
  setCollectionViewLayout(_: NSCollectionViewLayout);
  content: any[];
  setContent(_: any[]);
  dataSource: any;
  setDataSource(_: any);
  delegate: any;
  setDelegate(_: any);
  isFirstResponder: boolean;
  numberOfSections: number;
  prefetchDataSource: any;
  setPrefetchDataSource(_: any);
  isSelectable: boolean;
  setSelectable(_: boolean);
  selectionIndexPaths: Set<any>;
  setSelectionIndexPaths(_: Set<any>);
  selectionIndexes: IndexSet;
  setSelectionIndexes(_: IndexSet);
  deleteItemsAtIndexPaths(at: Set<any>): void;
  deleteSections(_: IndexSet): void;
  deselectAll(_?: any): void;
  deselectItemsAtIndexPaths(at: Set<any>): void;
  draggingImageForItemsAtIndexPathsWithEventOffset(at: Set<any>, with_: NSEvent, offset: CGPoint): NSImage;
  draggingImageForItemsAtIndexesWithEventOffset(at: IndexSet, with_: NSEvent, offset: CGPoint): NSImage;
  frameForItemAtIndex(at: number): CGRect;
  frameForItemAtIndexWithNumberOfItems(at: number, withNumberOfItems: number): CGRect;
  indexPathForItem(for_: NSCollectionViewItem): IndexPath;
  indexPathForItemAtPoint(at: CGPoint): IndexPath;
  indexPathsForVisibleItems(): Set<any>;
  indexPathsForVisibleSupplementaryElementsOfKind(ofKind: string): Set<any>;
  insertItemsAtIndexPaths(at: Set<any>): void;
  insertSections(_: IndexSet): void;
  itemAtIndex(at: number): NSCollectionViewItem;
  itemAtIndexPath(at: IndexPath): NSCollectionViewItem;
  layoutAttributesForItemAtIndexPath(at: IndexPath): NSCollectionViewLayoutAttributes;
  layoutAttributesForSupplementaryElementOfKindAtIndexPath(ofKind: string, at: IndexPath): NSCollectionViewLayoutAttributes;
  makeItemWithIdentifierForIndexPath(withIdentifier: string, for_: IndexPath): NSCollectionViewItem;
  makeSupplementaryViewOfKindWithIdentifierForIndexPath(ofKind: string, withIdentifier: string, for_: IndexPath): NSView;
  moveItemAtIndexPathToIndexPath(at: IndexPath, to: IndexPath): void;
  moveSectionToSection(_: number, toSection: number): void;
  numberOfItemsInSection(inSection: number): number;
  performBatchUpdatesCompletionHandler(_?: () => void, completionHandler?: (p1: boolean) => void): void;
  registerClassForItemWithIdentifier(_?: typeof NSObject, forItemWithIdentifier?: string): void;
  registerClassForSupplementaryViewOfKindWithIdentifier(_?: typeof NSObject, forSupplementaryViewOfKind?: string, withIdentifier?: string): void;
  registerNibForItemWithIdentifier(_?: NSNib, forItemWithIdentifier?: string): void;
  registerNibForSupplementaryViewOfKindWithIdentifier(_?: NSNib, forSupplementaryViewOfKind?: string, withIdentifier?: string): void;
  reloadData(): void;
  reloadItemsAtIndexPaths(at: Set<any>): void;
  reloadSections(_: IndexSet): void;
  scrollToItemsAtIndexPathsScrollPosition(at: Set<any>, scrollPosition: NSCollectionView.ScrollPosition): void;
  selectItemsAtIndexPathsScrollPosition(at: Set<any>, scrollPosition: NSCollectionView.ScrollPosition): void;
  setDraggingSourceOperationMaskForLocal(_: NSDragging.NSDragOperation, forLocal: boolean): void;
  supplementaryViewForElementKindAtIndexPath(forElementKind: string, at: IndexPath): NSView;
  toggleSectionCollapse(_: any): void;
  visibleItems(): NSCollectionViewItem[];
  visibleSupplementaryViewsOfKind(ofKind: string): NSView[];
}

export class NSCollectionViewCompositionalLayout extends NSCollectionViewLayout {
  configuration: NSCollectionViewCompositionalLayoutConfiguration;
  setConfiguration(_: NSCollectionViewCompositionalLayoutConfiguration);
  static initWithSection(_: NSCollectionLayoutSection): NSCollectionViewCompositionalLayout;
  static initWithSectionConfiguration(_: NSCollectionLayoutSection, configuration: NSCollectionViewCompositionalLayoutConfiguration): NSCollectionViewCompositionalLayout;
  static initWithSectionProvider(_: (p1: number, p2: any) => NSCollectionLayoutSection): NSCollectionViewCompositionalLayout;
  static initWithSectionProviderConfiguration(_: (p1: number, p2: any) => NSCollectionLayoutSection, configuration: NSCollectionViewCompositionalLayoutConfiguration): NSCollectionViewCompositionalLayout;
}

export class NSCollectionViewCompositionalLayoutConfiguration extends NSObject {
  boundarySupplementaryItems: NSCollectionLayoutBoundarySupplementaryItem[];
  setBoundarySupplementaryItems(_: NSCollectionLayoutBoundarySupplementaryItem[]);
  interSectionSpacing: number;
  setInterSectionSpacing(_: number);
  scrollDirection: NSCollectionViewFlowLayout.NSCollectionView.ScrollDirection;
  setScrollDirection(_: NSCollectionViewFlowLayout.NSCollectionView.ScrollDirection);
}

interface NSCollectionViewDataSource {
  collectionViewNumberOfItemsInSection(_: NSCollectionView, numberOfItemsInSection: number): number;
  collectionViewItemForRepresentedObjectAtIndexPath(_: NSCollectionView, itemForRepresentedObjectAt: IndexPath): NSCollectionViewItem;
  collectionViewViewForSupplementaryElementOfKindAtIndexPath(_: NSCollectionView, viewForSupplementaryElementOfKind: string, at: IndexPath): NSView;
  numberOfSectionsInCollectionView(in_: NSCollectionView): number;
}

interface NSCollectionViewDelegate {
  collectionViewCanDragItemsAtIndexPathsWithEvent(_: NSCollectionView, canDragItemsAt: Set<any>, with_: NSEvent): boolean;
  collectionViewCanDragItemsAtIndexesWithEvent(_: NSCollectionView, canDragItemsAt: IndexSet, with_: NSEvent): boolean;
  collectionViewWriteItemsAtIndexPathsToPasteboard(_: NSCollectionView, writeItemsAt: Set<any>, to: NSPasteboard): boolean;
  collectionViewWriteItemsAtIndexesToPasteboard(_: NSCollectionView, writeItemsAt: IndexSet, to: NSPasteboard): boolean;
  collectionViewDraggingImageForItemsAtIndexPathsWithEventOffset(_: NSCollectionView, draggingImageForItemsAt: Set<any>, with_: NSEvent, offset: CGPoint): NSImage;
  collectionViewDraggingImageForItemsAtIndexesWithEventOffset(_: NSCollectionView, draggingImageForItemsAt: IndexSet, with_: NSEvent, offset: CGPoint): NSImage;
  collectionViewValidateDropProposedIndexPathDropOperation(_: NSCollectionView, validateDrop: any, proposedIndexPath: IndexPath, dropOperation: NSCollectionView.DropOperation): NSDragging.NSDragOperation;
  collectionViewValidateDropProposedIndexDropOperation(_: NSCollectionView, validateDrop: any, proposedIndex: number, dropOperation: NSCollectionView.DropOperation): NSDragging.NSDragOperation;
  collectionViewAcceptDropIndexPathDropOperation(_: NSCollectionView, acceptDrop: any, indexPath: IndexPath, dropOperation: NSCollectionView.DropOperation): boolean;
  collectionViewAcceptDropIndexDropOperation(_: NSCollectionView, acceptDrop: any, index: number, dropOperation: NSCollectionView.DropOperation): boolean;
  collectionViewPasteboardWriterForItemAtIndexPath(_: NSCollectionView, pasteboardWriterForItemAt: IndexPath): any;
  collectionViewPasteboardWriterForItemAtIndex(_: NSCollectionView, pasteboardWriterForItemAt: number): any;
  collectionViewDraggingSessionWillBeginAtPointForItemsAtIndexPaths(_: NSCollectionView, draggingSession: NSDraggingSession, willBeginAt: CGPoint, forItemsAt: Set<any>): void;
  collectionViewDraggingSessionWillBeginAtPointForItemsAtIndexes(_: NSCollectionView, draggingSession: NSDraggingSession, willBeginAt: CGPoint, forItemsAt: IndexSet): void;
  collectionViewDraggingSessionEndedAtPointDragOperation(_: NSCollectionView, draggingSession: NSDraggingSession, endedAt: CGPoint, dragOperation: NSDragging.NSDragOperation): void;
  collectionViewUpdateDraggingItemsForDrag(_: NSCollectionView, updateDraggingItemsForDrag: any): void;
  collectionViewShouldChangeItemsAtIndexPathsToHighlightState(_: NSCollectionView, shouldChangeItemsAt: Set<any>, to: NSCollectionView.NSCollectionViewItem.HighlightState): Set<any>;
  collectionViewDidChangeItemsAtIndexPathsToHighlightState(_: NSCollectionView, didChangeItemsAt: Set<any>, to: NSCollectionView.NSCollectionViewItem.HighlightState): void;
  collectionViewShouldSelectItemsAtIndexPaths(_: NSCollectionView, shouldSelectItemsAt: Set<any>): Set<any>;
  collectionViewShouldDeselectItemsAtIndexPaths(_: NSCollectionView, shouldDeselectItemsAt: Set<any>): Set<any>;
  collectionViewDidSelectItemsAtIndexPaths(_: NSCollectionView, didSelectItemsAt: Set<any>): void;
  collectionViewDidDeselectItemsAtIndexPaths(_: NSCollectionView, didDeselectItemsAt: Set<any>): void;
  collectionViewWillDisplayItemForRepresentedObjectAtIndexPath(_: NSCollectionView, willDisplay: NSCollectionViewItem, forRepresentedObjectAt: IndexPath): void;
  collectionViewWillDisplaySupplementaryViewForElementKindAtIndexPath(_: NSCollectionView, willDisplaySupplementaryView: NSView, forElementKind: string, at: IndexPath): void;
  collectionViewDidEndDisplayingItemForRepresentedObjectAtIndexPath(_: NSCollectionView, didEndDisplaying: NSCollectionViewItem, forRepresentedObjectAt: IndexPath): void;
  collectionViewDidEndDisplayingSupplementaryViewForElementOfKindAtIndexPath(_: NSCollectionView, didEndDisplayingSupplementaryView: NSView, forElementOfKind: string, at: IndexPath): void;
  collectionViewTransitionLayoutForOldLayoutNewLayout(_: NSCollectionView, transitionLayoutForOldLayout: NSCollectionViewLayout, newLayout: NSCollectionViewLayout): NSCollectionViewTransitionLayout;
}

interface NSCollectionViewDelegateFlowLayout {
  collectionViewLayoutSizeForItemAtIndexPath(_: NSCollectionView, layout: NSCollectionViewLayout, sizeForItemAt: IndexPath): CGSize;
  collectionViewLayoutInsetForSectionAtIndex(_: NSCollectionView, layout: NSCollectionViewLayout, insetForSectionAt: number): NSEdgeInsets;
  collectionViewLayoutMinimumLineSpacingForSectionAtIndex(_: NSCollectionView, layout: NSCollectionViewLayout, minimumLineSpacingForSectionAt: number): number;
  collectionViewLayoutMinimumInteritemSpacingForSectionAtIndex(_: NSCollectionView, layout: NSCollectionViewLayout, minimumInteritemSpacingForSectionAt: number): number;
  collectionViewLayoutReferenceSizeForHeaderInSection(_: NSCollectionView, layout: NSCollectionViewLayout, referenceSizeForHeaderInSection: number): CGSize;
  collectionViewLayoutReferenceSizeForFooterInSection(_: NSCollectionView, layout: NSCollectionViewLayout, referenceSizeForFooterInSection: number): CGSize;
}

export class NSCollectionViewDiffableDataSourceReference<SectionIdentifierType, ItemIdentifierType> extends NSObject {
  supplementaryViewProvider: (p1: NSCollectionView, p2: string, p3: IndexPath) => NSView;
  setSupplementaryViewProvider(_: (p1: NSCollectionView, p2: string, p3: IndexPath) => NSView);
  applySnapshotAnimatingDifferences(_: NSDiffableDataSourceSnapshotReference<SectionIdentifierType, ItemIdentifierType>, animatingDifferences: boolean): void;
  indexPathForItemIdentifier(forItemIdentifier: ItemIdentifierType): IndexPath;
  itemIdentifierForIndexPath(for_: IndexPath): ItemIdentifierType;
  snapshot(): NSDiffableDataSourceSnapshotReference<SectionIdentifierType, ItemIdentifierType>;
}

interface NSCollectionViewElement {
  applyLayoutAttributes(_: NSCollectionViewLayoutAttributes): void;
  didTransitionFromLayoutToLayout(from: NSCollectionViewLayout, to: NSCollectionViewLayout): void;
  preferredLayoutAttributesFittingAttributes(_: NSCollectionViewLayoutAttributes): NSCollectionViewLayoutAttributes;
  prepareForReuse(): void;
  willTransitionFromLayoutToLayout(from: NSCollectionViewLayout, to: NSCollectionViewLayout): void;
}

export class NSCollectionViewFlowLayout extends NSCollectionViewLayout {
  estimatedItemSize: CGSize;
  setEstimatedItemSize(_: CGSize);
  footerReferenceSize: CGSize;
  setFooterReferenceSize(_: CGSize);
  headerReferenceSize: CGSize;
  setHeaderReferenceSize(_: CGSize);
  itemSize: CGSize;
  setItemSize(_: CGSize);
  minimumInteritemSpacing: number;
  setMinimumInteritemSpacing(_: number);
  minimumLineSpacing: number;
  setMinimumLineSpacing(_: number);
  scrollDirection: NSCollectionViewFlowLayout.NSCollectionView.ScrollDirection;
  setScrollDirection(_: NSCollectionViewFlowLayout.NSCollectionView.ScrollDirection);
  sectionFootersPinToVisibleBounds: boolean;
  setSectionFootersPinToVisibleBounds(_: boolean);
  sectionHeadersPinToVisibleBounds: boolean;
  setSectionHeadersPinToVisibleBounds(_: boolean);
  sectionInset: NSEdgeInsets;
  setSectionInset(_: NSEdgeInsets);
  collapseSectionAtIndex(at: number): void;
  expandSectionAtIndex(at: number): void;
  sectionAtIndexIsCollapsed(atIndexIsCollapsed: number): boolean;
}

export class NSCollectionViewFlowLayoutInvalidationContext extends NSCollectionViewLayoutInvalidationContext {
  invalidateFlowLayoutAttributes: boolean;
  setInvalidateFlowLayoutAttributes(_: boolean);
  invalidateFlowLayoutDelegateMetrics: boolean;
  setInvalidateFlowLayoutDelegateMetrics(_: boolean);
}

export class NSCollectionViewGridLayout extends NSCollectionViewLayout {
  backgroundColors: NSColor[];
  setBackgroundColors(_: NSColor[]);
  margins: NSEdgeInsets;
  setMargins(_: NSEdgeInsets);
  maximumItemSize: CGSize;
  setMaximumItemSize(_: CGSize);
  maximumNumberOfColumns: number;
  setMaximumNumberOfColumns(_: number);
  maximumNumberOfRows: number;
  setMaximumNumberOfRows(_: number);
  minimumInteritemSpacing: number;
  setMinimumInteritemSpacing(_: number);
  minimumItemSize: CGSize;
  setMinimumItemSize(_: CGSize);
  minimumLineSpacing: number;
  setMinimumLineSpacing(_: number);
}

export class NSCollectionViewItem extends NSViewController {
  collectionView: NSCollectionView;
  draggingImageComponents: NSDraggingImageComponent[];
  highlightState: NSCollectionView.NSCollectionViewItem.HighlightState;
  setHighlightState(_: NSCollectionView.NSCollectionViewItem.HighlightState);
  imageView: NSImageView;
  setImageView(_: NSImageView);
  isSelected: boolean;
  setSelected(_: boolean);
  textField: NSTextField;
  setTextField(_: NSTextField);
}

export class NSCollectionViewLayout extends NSObject {
  collectionView: NSCollectionView;
  collectionViewContentSize: CGSize;
  static invalidationContextClass: typeof NSObject;
  static layoutAttributesClass: typeof NSObject;
  finalLayoutAttributesForDisappearingDecorationElementOfKindAtIndexPath(ofKind: string, at: IndexPath): NSCollectionViewLayoutAttributes;
  finalLayoutAttributesForDisappearingItemAtIndexPath(at: IndexPath): NSCollectionViewLayoutAttributes;
  finalLayoutAttributesForDisappearingSupplementaryElementOfKindAtIndexPath(ofKind: string, at: IndexPath): NSCollectionViewLayoutAttributes;
  finalizeAnimatedBoundsChange(): void;
  finalizeCollectionViewUpdates(): void;
  finalizeLayoutTransition(): void;
  indexPathsToDeleteForDecorationViewOfKind(ofKind: string): Set<any>;
  indexPathsToDeleteForSupplementaryViewOfKind(ofKind: string): Set<any>;
  indexPathsToInsertForDecorationViewOfKind(ofKind: string): Set<any>;
  indexPathsToInsertForSupplementaryViewOfKind(ofKind: string): Set<any>;
  initialLayoutAttributesForAppearingDecorationElementOfKindAtIndexPath(ofKind: string, at: IndexPath): NSCollectionViewLayoutAttributes;
  initialLayoutAttributesForAppearingItemAtIndexPath(at: IndexPath): NSCollectionViewLayoutAttributes;
  initialLayoutAttributesForAppearingSupplementaryElementOfKindAtIndexPath(ofKind: string, at: IndexPath): NSCollectionViewLayoutAttributes;
  invalidateLayout(): void;
  invalidateLayoutWithContext(with_: NSCollectionViewLayoutInvalidationContext): void;
  invalidationContextForBoundsChange(forBoundsChange: CGRect): NSCollectionViewLayoutInvalidationContext;
  invalidationContextForPreferredLayoutAttributesWithOriginalAttributes(forPreferredLayoutAttributes: NSCollectionViewLayoutAttributes, withOriginalAttributes: NSCollectionViewLayoutAttributes): NSCollectionViewLayoutInvalidationContext;
  layoutAttributesForDecorationViewOfKindAtIndexPath(ofKind: string, at: IndexPath): NSCollectionViewLayoutAttributes;
  layoutAttributesForDropTargetAtPoint(at: CGPoint): NSCollectionViewLayoutAttributes;
  layoutAttributesForElementsInRect(in_: CGRect): NSCollectionViewLayoutAttributes[];
  layoutAttributesForInterItemGapBeforeIndexPath(before: IndexPath): NSCollectionViewLayoutAttributes;
  layoutAttributesForItemAtIndexPath(at: IndexPath): NSCollectionViewLayoutAttributes;
  layoutAttributesForSupplementaryViewOfKindAtIndexPath(ofKind: string, at: IndexPath): NSCollectionViewLayoutAttributes;
  prepareForAnimatedBoundsChange(forAnimatedBoundsChange: CGRect): void;
  prepareForCollectionViewUpdates(forCollectionViewUpdates: NSCollectionViewUpdateItem[]): void;
  prepareForTransitionFromLayout(from: NSCollectionViewLayout): void;
  prepareForTransitionToLayout(to: NSCollectionViewLayout): void;
  prepareLayout(): void;
  registerClassForDecorationViewOfKind(_?: typeof NSObject, forDecorationViewOfKind?: string): void;
  registerNibForDecorationViewOfKind(_?: NSNib, forDecorationViewOfKind?: string): void;
  shouldInvalidateLayoutForBoundsChange(forBoundsChange: CGRect): boolean;
  shouldInvalidateLayoutForPreferredLayoutAttributesWithOriginalAttributes(forPreferredLayoutAttributes: NSCollectionViewLayoutAttributes, withOriginalAttributes: NSCollectionViewLayoutAttributes): boolean;
  targetContentOffsetForProposedContentOffset(forProposedContentOffset: CGPoint): CGPoint;
  targetContentOffsetForProposedContentOffsetWithScrollingVelocity(forProposedContentOffset: CGPoint, withScrollingVelocity: CGPoint): CGPoint;
}

export class NSCollectionViewLayoutAttributes extends NSObject {
  alpha: number;
  setAlpha(_: number);
  frame: CGRect;
  setFrame(_: CGRect);
  isHidden: boolean;
  setHidden(_: boolean);
  indexPath: IndexPath;
  setIndexPath(_: IndexPath);
  representedElementCategory: NSCollectionViewLayout.NSCollectionElementCategory;
  representedElementKind: string;
  size: CGSize;
  setSize(_: CGSize);
  zIndex: number;
  setZIndex(_: number);
}

export class NSCollectionViewLayoutInvalidationContext extends NSObject {
  contentOffsetAdjustment: CGPoint;
  setContentOffsetAdjustment(_: CGPoint);
  contentSizeAdjustment: CGSize;
  setContentSizeAdjustment(_: CGSize);
  invalidateDataSourceCounts: boolean;
  invalidateEverything: boolean;
  invalidatedDecorationIndexPaths: Map<string, Set<any>>;
  invalidatedItemIndexPaths: Set<any>;
  invalidatedSupplementaryIndexPaths: Map<string, Set<any>>;
  invalidateDecorationElementsOfKindAtIndexPaths(ofKind: string, at: Set<any>): void;
  invalidateItemsAtIndexPaths(at: Set<any>): void;
  invalidateSupplementaryElementsOfKindAtIndexPaths(ofKind: string, at: Set<any>): void;
}

interface NSCollectionViewPrefetching {
  collectionViewPrefetchItemsAtIndexPaths(_: NSCollectionView, prefetchItemsAt: IndexPath[]): void;
  collectionViewCancelPrefetchingForItemsAtIndexPaths(_: NSCollectionView, cancelPrefetchingForItemsAt: IndexPath[]): void;
}

interface NSCollectionViewSectionHeaderView {
  sectionCollapseButton?: NSButton;
  setSectionCollapseButton(_: NSButton);
}

export class NSCollectionViewTransitionLayout extends NSCollectionViewLayout {
  currentLayout: NSCollectionViewLayout;
  nextLayout: NSCollectionViewLayout;
  transitionProgress: number;
  setTransitionProgress(_: number);
  static initWithCurrentLayoutNextLayout(_: NSCollectionViewLayout, nextLayout: NSCollectionViewLayout): NSCollectionViewTransitionLayout;
  updateValueForAnimatedKey(_: number, forAnimatedKey: string): void;
  valueForAnimatedKey(forAnimatedKey: string): number;
}

export class NSCollectionViewUpdateItem extends NSObject {
  indexPathAfterUpdate: IndexPath;
  indexPathBeforeUpdate: IndexPath;
  updateAction: NSCollectionViewLayout.NSCollectionView.UpdateAction;
}

export class NSColor extends NSObject {
  CGColor: any;
  alphaComponent: number;
  blackComponent: number;
  blueComponent: number;
  brightnessComponent: number;
  catalogNameComponent: string;
  colorNameComponent: string;
  colorSpace: NSColorSpace;
  cyanComponent: number;
  greenComponent: number;
  hueComponent: number;
  localizedCatalogNameComponent: string;
  localizedColorNameComponent: string;
  magentaComponent: number;
  numberOfComponents: number;
  patternImage: NSImage;
  redComponent: number;
  saturationComponent: number;
  type: NSColor.ColorType;
  whiteComponent: number;
  yellowComponent: number;
  static alternateSelectedControlTextColor: NSColor;
  static alternatingContentBackgroundColors: NSColor[];
  static blackColor: NSColor;
  static blueColor: NSColor;
  static brownColor: NSColor;
  static clearColor: NSColor;
  static controlAccentColor: NSColor;
  static controlBackgroundColor: NSColor;
  static controlColor: NSColor;
  static controlTextColor: NSColor;
  static currentControlTint: NSCell.NSControlTint;
  static cyanColor: NSColor;
  static darkGrayColor: NSColor;
  static disabledControlTextColor: NSColor;
  static findHighlightColor: NSColor;
  static grayColor: NSColor;
  static greenColor: NSColor;
  static gridColor: NSColor;
  static headerTextColor: NSColor;
  static highlightColor: NSColor;
  static ignoresAlpha: boolean;
  setIgnoresAlpha(_: boolean);
  static keyboardFocusIndicatorColor: NSColor;
  static labelColor: NSColor;
  static lightGrayColor: NSColor;
  static linkColor: NSColor;
  static magentaColor: NSColor;
  static orangeColor: NSColor;
  static placeholderTextColor: NSColor;
  static purpleColor: NSColor;
  static quaternaryLabelColor: NSColor;
  static redColor: NSColor;
  static scrubberTexturedBackgroundColor: NSColor;
  static secondaryLabelColor: NSColor;
  static selectedContentBackgroundColor: NSColor;
  static selectedControlColor: NSColor;
  static selectedControlTextColor: NSColor;
  static selectedMenuItemTextColor: NSColor;
  static selectedTextBackgroundColor: NSColor;
  static selectedTextColor: NSColor;
  static separatorColor: NSColor;
  static shadowColor: NSColor;
  static systemBlueColor: NSColor;
  static systemBrownColor: NSColor;
  static systemGrayColor: NSColor;
  static systemGreenColor: NSColor;
  static systemIndigoColor: NSColor;
  static systemOrangeColor: NSColor;
  static systemPinkColor: NSColor;
  static systemPurpleColor: NSColor;
  static systemRedColor: NSColor;
  static systemTealColor: NSColor;
  static systemYellowColor: NSColor;
  static tertiaryLabelColor: NSColor;
  static textBackgroundColor: NSColor;
  static textColor: NSColor;
  static underPageBackgroundColor: NSColor;
  static unemphasizedSelectedContentBackgroundColor: NSColor;
  static unemphasizedSelectedTextBackgroundColor: NSColor;
  static unemphasizedSelectedTextColor: NSColor;
  static whiteColor: NSColor;
  static windowBackgroundColor: NSColor;
  static windowFrameTextColor: NSColor;
  static yellowColor: NSColor;
  blendedColorWithFractionOfColor(withFraction: number, of: NSColor): NSColor;
  colorUsingColorSpace(_: NSColorSpace): NSColor;
  colorUsingType(_: NSColor.ColorType): NSColor;
  colorWithAlphaComponent(_: number): NSColor;
  colorWithSystemEffect(_: NSColor.SystemEffect): NSColor;
  drawSwatchInRect(in_: CGRect): void;
  getComponents(_: number): void;
  getCyanMagentaYellowBlackAlpha(_?: number, magenta?: number, yellow?: number, black?: number, alpha?: number): void;
  getHueSaturationBrightnessAlpha(_?: number, saturation?: number, brightness?: number, alpha?: number): void;
  getRedGreenBlueAlpha(_?: number, green?: number, blue?: number, alpha?: number): void;
  getWhiteAlpha(_?: number, alpha?: number): void;
  highlightWithLevel(withLevel: number): NSColor;
  set(): void;
  setFill(): void;
  setStroke(): void;
  shadowWithLevel(withLevel: number): NSColor;
  writeToPasteboard(to: NSPasteboard): void;
}

interface NSColorChanging {
  changeColor(_?: NSColorPanel): void;
}

export class NSColorList extends NSObject {
  allKeys: string[];
  isEditable: boolean;
  name: string;
  static availableColorLists: NSColorList[];
  colorWithKey(withKey: string): NSColor;
  static initWithName(_: string): NSColorList;
  static initWithNameFromFile(_: string, fromFile?: string): NSColorList;
  insertColorKeyAtIndex(_: NSColor, key: string, at: number): void;
  removeColorWithKey(withKey: string): void;
  removeFile(): void;
  setColorForKey(_: NSColor, forKey: string): void;
  writeToURL(error?: URL): boolean;
}

export class NSColorPanel extends NSPanel {
  static dragColorWithEventFromView(_: NSColor, with_: NSEvent, from: NSView): boolean;
  static setPickerMask(_: NSColorPanel.Options): void;
  static setPickerMode(_: NSColorPanel.Mode): void;
  accessoryView: NSView;
  setAccessoryView(_: NSView);
  alpha: number;
  color: NSColor;
  setColor(_: NSColor);
  isContinuous: boolean;
  setContinuous(_: boolean);
  mode: NSColorPanel.Mode;
  setMode(_: NSColorPanel.Mode);
  showsAlpha: boolean;
  setShowsAlpha(_: boolean);
  static sharedColorPanel: NSColorPanel;
  static sharedColorPanelExists: boolean;
  attachColorList(_: NSColorList): void;
  detachColorList(_: NSColorList): void;
  setAction(_?: string): void;
  setTarget(_?: any): void;
}

export class NSColorPicker extends NSObject {
  buttonToolTip: string;
  colorPanel: NSColorPanel;
  minContentSize: CGSize;
  provideNewButtonImage: NSImage;
}

export class NSColorPickerTouchBarItem extends NSTouchBarItem {
  static colorPickerWithIdentifier(withIdentifier: string): NSColorPickerTouchBarItem;
  static colorPickerWithIdentifierButtonImage(withIdentifier: string, buttonImage: NSImage): NSColorPickerTouchBarItem;
  static strokeColorPickerWithIdentifier(withIdentifier: string): NSColorPickerTouchBarItem;
  static textColorPickerWithIdentifier(withIdentifier: string): NSColorPickerTouchBarItem;
  action: string;
  setAction(_: string);
  allowedColorSpaces: NSColorSpace[];
  setAllowedColorSpaces(_: NSColorSpace[]);
  color: NSColor;
  setColor(_: NSColor);
  colorList: NSColorList;
  setColorList(_: NSColorList);
  customizationLabel: string;
  setCustomizationLabel(_: string);
  isEnabled: boolean;
  setEnabled(_: boolean);
  showsAlpha: boolean;
  setShowsAlpha(_: boolean);
  target: any;
  setTarget(_: any);
}

interface NSColorPickingCustom {
  currentMode(): NSColorPanel.Mode;
  provideNewView(_: boolean): NSView;
  setColor(_: NSColor): void;
  supportsMode(_: NSColorPanel.Mode): boolean;
}

interface NSColorPickingDefault {
  provideNewButtonImage: NSImage;
  buttonToolTip: string;
  minContentSize: CGSize;
  alphaControlAddedOrRemoved(_?: any): void;
  attachColorList(_: NSColorList): void;
  detachColorList(_: NSColorList): void;
  insertNewButtonImageIn(_: NSImage, in_: NSButtonCell): void;
  setMode(_: NSColorPanel.Mode): void;
  viewSizeChanged(_?: any): void;
}

export class NSColorSampler extends NSObject {
  showSamplerWithSelectionHandler(selectionHandler?: (p1: NSColor) => void): void;
}

export class NSColorSpace extends NSObject {
  static availableColorSpacesWithModel(with_: NSColorSpace.Model): NSColorSpace[];
  CGColorSpace: any;
  ICCProfileData: Data;
  colorSpaceModel: NSColorSpace.Model;
  colorSyncProfile: any;
  localizedName: string;
  numberOfColorComponents: number;
  static adobeRGB1998ColorSpace: NSColorSpace;
  static deviceCMYKColorSpace: NSColorSpace;
  static deviceGrayColorSpace: NSColorSpace;
  static deviceRGBColorSpace: NSColorSpace;
  static displayP3ColorSpace: NSColorSpace;
  static extendedGenericGamma22GrayColorSpace: NSColorSpace;
  static extendedSRGBColorSpace: NSColorSpace;
  static genericCMYKColorSpace: NSColorSpace;
  static genericGamma22GrayColorSpace: NSColorSpace;
  static genericGrayColorSpace: NSColorSpace;
  static genericRGBColorSpace: NSColorSpace;
  static sRGBColorSpace: NSColorSpace;
  static initWithCGColorSpace(_: any): NSColorSpace;
  static initWithColorSyncProfile(_: any): NSColorSpace;
  static initWithICCProfileData(_: Data): NSColorSpace;
}

// export function NSColorSpaceFromDepth(depth: NSGraphics.NSWindow.Depth): string;

export class NSColorWell extends NSControl {
  isActive: boolean;
  isBordered: boolean;
  setBordered(_: boolean);
  color: NSColor;
  setColor(_: NSColor);
  activate(_: boolean): void;
  deactivate(): void;
  drawWellInside(inside: CGRect): void;
  takeColorFrom(_?: any): void;
}

export class NSComboBox extends NSTextField {
  isButtonBordered: boolean;
  setButtonBordered(_: boolean);
  completes: boolean;
  setCompletes(_: boolean);
  dataSource: any;
  setDataSource(_: any);
  delegate: any;
  setDelegate(_: any);
  hasVerticalScroller: boolean;
  setHasVerticalScroller(_: boolean);
  indexOfSelectedItem: number;
  intercellSpacing: CGSize;
  setIntercellSpacing(_: CGSize);
  itemHeight: number;
  setItemHeight(_: number);
  numberOfItems: number;
  numberOfVisibleItems: number;
  setNumberOfVisibleItems(_: number);
  objectValueOfSelectedItem: any;
  objectValues: any[];
  usesDataSource: boolean;
  setUsesDataSource(_: boolean);
  addItemWithObjectValue(withObjectValue: any): void;
  addItemsWithObjectValues(withObjectValues: any[]): void;
  deselectItemAtIndex(at: number): void;
  indexOfItemWithObjectValue(withObjectValue: any): number;
  insertItemWithObjectValueAtIndex(withObjectValue: any, at: number): void;
  itemObjectValueAtIndex(at: number): any;
  noteNumberOfItemsChanged(): void;
  reloadData(): void;
  removeAllItems(): void;
  removeItemAtIndex(at: number): void;
  removeItemWithObjectValue(withObjectValue: any): void;
  scrollItemAtIndexToTop(_: number): void;
  scrollItemAtIndexToVisible(_: number): void;
  selectItemAtIndex(at: number): void;
  selectItemWithObjectValue(withObjectValue?: any): void;
}

export class NSComboBoxCell extends NSTextFieldCell {
  isButtonBordered: boolean;
  setButtonBordered(_: boolean);
  completes: boolean;
  setCompletes(_: boolean);
  dataSource: any;
  setDataSource(_: any);
  hasVerticalScroller: boolean;
  setHasVerticalScroller(_: boolean);
  indexOfSelectedItem: number;
  intercellSpacing: CGSize;
  setIntercellSpacing(_: CGSize);
  itemHeight: number;
  setItemHeight(_: number);
  numberOfItems: number;
  numberOfVisibleItems: number;
  setNumberOfVisibleItems(_: number);
  objectValueOfSelectedItem: any;
  objectValues: any[];
  usesDataSource: boolean;
  setUsesDataSource(_: boolean);
  addItemWithObjectValue(withObjectValue: any): void;
  addItemsWithObjectValues(withObjectValues: any[]): void;
  completedString(_: string): string;
  deselectItemAtIndex(at: number): void;
  indexOfItemWithObjectValue(withObjectValue: any): number;
  insertItemWithObjectValueAtIndex(withObjectValue: any, at: number): void;
  itemObjectValueAtIndex(at: number): any;
  noteNumberOfItemsChanged(): void;
  reloadData(): void;
  removeAllItems(): void;
  removeItemAtIndex(at: number): void;
  removeItemWithObjectValue(withObjectValue: any): void;
  scrollItemAtIndexToTop(_: number): void;
  scrollItemAtIndexToVisible(_: number): void;
  selectItemAtIndex(at: number): void;
  selectItemWithObjectValue(withObjectValue?: any): void;
}

interface NSComboBoxCellDataSource {
  comboBoxCellObjectValueForItemAtIndex(_: NSComboBoxCell, objectValueForItemAt: number): any;
  comboBoxCellIndexOfItemWithStringValue(_: NSComboBoxCell, indexOfItemWithStringValue: string): number;
  comboBoxCellCompletedString(_: NSComboBoxCell, completedString: string): string;
  numberOfItemsInComboBoxCell(in_: NSComboBoxCell): number;
}

interface NSComboBoxDataSource {
  comboBoxObjectValueForItemAtIndex(_: NSComboBox, objectValueForItemAt: number): any;
  comboBoxIndexOfItemWithStringValue(_: NSComboBox, indexOfItemWithStringValue: string): number;
  comboBoxCompletedString(_: NSComboBox, completedString: string): string;
  numberOfItemsInComboBox(in_: NSComboBox): number;
}

interface NSComboBoxDelegate {
  comboBoxSelectionDidChange(_: Notification): void;
  comboBoxSelectionIsChanging(_: Notification): void;
  comboBoxWillDismiss(_: Notification): void;
  comboBoxWillPopUp(_: Notification): void;
}

export class NSControl extends NSView {
  action: string;
  setAction(_: string);
  alignment: NSText.NSTextAlignment;
  setAlignment(_: NSText.NSTextAlignment);
  allowsExpansionToolTips: boolean;
  setAllowsExpansionToolTips(_: boolean);
  attributedStringValue: NSAttributedString;
  setAttributedStringValue(_: NSAttributedString);
  baseWritingDirection: NSText.NSWritingDirection;
  setBaseWritingDirection(_: NSText.NSWritingDirection);
  cell: NSCell;
  setCell(_: NSCell);
  isContinuous: boolean;
  setContinuous(_: boolean);
  controlSize: NSCell.NSControl.ControlSize;
  setControlSize(_: NSCell.NSControl.ControlSize);
  doubleValue: number;
  setDoubleValue(_: number);
  isEnabled: boolean;
  setEnabled(_: boolean);
  floatValue: number;
  setFloatValue(_: number);
  font: NSFont;
  setFont(_: NSFont);
  formatter: Formatter;
  setFormatter(_: Formatter);
  isHighlighted: boolean;
  setHighlighted(_: boolean);
  ignoresMultiClick: boolean;
  setIgnoresMultiClick(_: boolean);
  intValue: number;
  setIntValue(_: number);
  integerValue: number;
  setIntegerValue(_: number);
  lineBreakMode: NSParagraphStyle.NSLineBreakMode;
  setLineBreakMode(_: NSParagraphStyle.NSLineBreakMode);
  objectValue: any;
  setObjectValue(_: any);
  refusesFirstResponder: boolean;
  setRefusesFirstResponder(_: boolean);
  stringValue: string;
  setStringValue(_: string);
  tag: number;
  setTag(_: number);
  target: any;
  setTarget(_: any);
  usesSingleLineMode: boolean;
  setUsesSingleLineMode(_: boolean);
  static cellClass: typeof NSObject;
  setCellClass(_: typeof NSObject);
  abortEditing(): boolean;
  currentEditor(): NSText;
  drawCell(_: NSCell): void;
  drawCellInside(_: NSCell): void;
  drawWithExpansionFrameInView(withExpansionFrame: CGRect, in_: NSView): void;
  editWithFrameEditorDelegateEvent(withFrame: CGRect, editor: NSText, delegate?: any, event?: NSEvent): void;
  endEditing(_: NSText): void;
  expansionFrameWithFrame(withFrame: CGRect): CGRect;
  invalidateIntrinsicContentSizeForCell(for_: NSCell): void;
  performClick(_?: any): void;
  selectCell(_: NSCell): void;
  selectWithFrameEditorDelegateStartLength(withFrame: CGRect, editor: NSText, delegate?: any, start?: number, length?: number): void;
  selectedCell(): NSCell;
  selectedTag(): number;
  sendActionTo(_?: string, to?: any): boolean;
  sendActionOn(on: NSEvent.EventTypeMask): number;
  sizeThatFits(_: CGSize): CGSize;
  sizeToFit(): void;
  takeDoubleValueFrom(_?: any): void;
  takeFloatValueFrom(_?: any): void;
  takeIntValueFrom(_?: any): void;
  takeIntegerValueFrom(_?: any): void;
  takeObjectValueFrom(_?: any): void;
  takeStringValueFrom(_?: any): void;
  updateCell(_: NSCell): void;
  updateCellInside(_: NSCell): void;
  validateEditing(): void;
}

interface NSControlTextEditingDelegate {
  controlTextShouldBeginEditing(_: NSControl, textShouldBeginEditing: NSText): boolean;
  controlTextShouldEndEditing(_: NSControl, textShouldEndEditing: NSText): boolean;
  controlDidFailToFormatStringErrorDescription(_: NSControl, didFailToFormatString: string, errorDescription?: string): boolean;
  controlDidFailToValidatePartialStringErrorDescription(_: NSControl, didFailToValidatePartialString: string, errorDescription?: string): void;
  controlIsValidObject(_: NSControl, isValidObject?: any): boolean;
  controlTextViewDoCommandBySelector(_: NSControl, textView: NSTextView, doCommandBy: string): boolean;
  controlTextViewCompletionsForPartialWordRangeIndexOfSelectedItem(_: NSControl, textView: NSTextView, completions: string[], forPartialWordRange: NSRange, indexOfSelectedItem: number): string[];
  controlTextDidBeginEditing(_: Notification): void;
  controlTextDidChange(_: Notification): void;
  controlTextDidEndEditing(_: Notification): void;
}

export class NSController extends NSObject {
  isEditing: boolean;
}

// export function NSCreateFileContentsPboardType(fileType: string): string;

// export function NSCreateFilenamePboardType(fileType: string): string;

export class NSCursor extends NSObject {
  static hide(): void;
  //  static pop(): void;
  static setHiddenUntilMouseMoves(_: boolean): void;
  static unhide(): void;
  hotSpot: CGPoint;
  image: NSImage;
  static IBeamCursor: NSCursor;
  static IBeamCursorForVerticalLayout: NSCursor;
  static arrowCursor: NSCursor;
  static closedHandCursor: NSCursor;
  static contextualMenuCursor: NSCursor;
  static crosshairCursor: NSCursor;
  static currentCursor: NSCursor;
  static currentSystemCursor: NSCursor;
  static disappearingItemCursor: NSCursor;
  static dragCopyCursor: NSCursor;
  static dragLinkCursor: NSCursor;
  static openHandCursor: NSCursor;
  static operationNotAllowedCursor: NSCursor;
  static pointingHandCursor: NSCursor;
  static resizeDownCursor: NSCursor;
  static resizeLeftCursor: NSCursor;
  static resizeLeftRightCursor: NSCursor;
  static resizeRightCursor: NSCursor;
  static resizeUpCursor: NSCursor;
  static resizeUpDownCursor: NSCursor;
  static initWithImageHotSpot(_: NSImage, hotSpot: CGPoint): NSCursor;
  pop(): void;
  push(): void;
  set(): void;
}

export class NSCustomImageRep extends NSImageRep {
  delegate: any;
  drawSelector: string;
  drawingHandler: (p1: CGRect) => boolean;
  static initWithDrawSelectorDelegate(_: string, delegate: any): NSCustomImageRep;
  static initWithSizeFlippedDrawingHandler(_: CGSize, flipped: boolean, drawingHandler: (p1: CGRect) => boolean): NSCustomImageRep;
}

export class NSCustomTouchBarItem extends NSTouchBarItem {
  customizationLabel: string;
  setCustomizationLabel(_: string);
  viewController: NSViewController;
  setViewController(_: NSViewController);
}

export class NSDataAsset extends NSObject {
  data: Data;
  name: string;
  typeIdentifier: string;
  static initWithName(_: string): NSDataAsset;
  static initWithNameBundle(_: string, bundle: Bundle): NSDataAsset;
}

export class NSDatePicker extends NSControl {
  backgroundColor: NSColor;
  setBackgroundColor(_: NSColor);
  isBezeled: boolean;
  setBezeled(_: boolean);
  isBordered: boolean;
  setBordered(_: boolean);
  calendar: Calendar;
  setCalendar(_: Calendar);
  datePickerElements: NSDatePickerCell.NSDatePicker.ElementFlags;
  setDatePickerElements(_: NSDatePickerCell.NSDatePicker.ElementFlags);
  datePickerMode: NSDatePickerCell.NSDatePicker.Mode;
  setDatePickerMode(_: NSDatePickerCell.NSDatePicker.Mode);
  datePickerStyle: NSDatePickerCell.NSDatePicker.Style;
  setDatePickerStyle(_: NSDatePickerCell.NSDatePicker.Style);
  dateValue: Date;
  setDateValue(_: Date);
  delegate: any;
  setDelegate(_: any);
  drawsBackground: boolean;
  setDrawsBackground(_: boolean);
  locale: Locale;
  setLocale(_: Locale);
  maxDate: Date;
  setMaxDate(_: Date);
  minDate: Date;
  setMinDate(_: Date);
  presentsCalendarOverlay: boolean;
  setPresentsCalendarOverlay(_: boolean);
  textColor: NSColor;
  setTextColor(_: NSColor);
  timeInterval: number;
  setTimeInterval(_: number);
  timeZone: TimeZone;
  setTimeZone(_: TimeZone);
}

export class NSDatePickerCell extends NSActionCell {
  backgroundColor: NSColor;
  setBackgroundColor(_: NSColor);
  calendar: Calendar;
  setCalendar(_: Calendar);
  datePickerElements: NSDatePickerCell.NSDatePicker.ElementFlags;
  setDatePickerElements(_: NSDatePickerCell.NSDatePicker.ElementFlags);
  datePickerMode: NSDatePickerCell.NSDatePicker.Mode;
  setDatePickerMode(_: NSDatePickerCell.NSDatePicker.Mode);
  datePickerStyle: NSDatePickerCell.NSDatePicker.Style;
  setDatePickerStyle(_: NSDatePickerCell.NSDatePicker.Style);
  dateValue: Date;
  setDateValue(_: Date);
  delegate: any;
  setDelegate(_: any);
  drawsBackground: boolean;
  setDrawsBackground(_: boolean);
  locale: Locale;
  setLocale(_: Locale);
  maxDate: Date;
  setMaxDate(_: Date);
  minDate: Date;
  setMinDate(_: Date);
  textColor: NSColor;
  setTextColor(_: NSColor);
  timeInterval: number;
  setTimeInterval(_: number);
  timeZone: TimeZone;
  setTimeZone(_: TimeZone);
}

interface NSDatePickerCellDelegate {
  datePickerCellValidateProposedDateValueTimeInterval(_: NSDatePickerCell, validateProposedDateValue: Date, timeInterval?: number): void;
}

export class NSDictionaryController extends NSArrayController {
  excludedKeys: string[];
  setExcludedKeys(_: string[]);
  includedKeys: string[];
  setIncludedKeys(_: string[]);
  initialKey: string;
  setInitialKey(_: string);
  initialValue: any;
  setInitialValue(_: any);
  localizedKeyDictionary: Map<string, string>;
  setLocalizedKeyDictionary(_: Map<string, string>);
  localizedKeyTable: string;
  setLocalizedKeyTable(_: string);
  newObject(): NSDictionaryControllerKeyValuePair;
}

export class NSDictionaryControllerKeyValuePair extends NSObject {
  isExplicitlyIncluded: boolean;
  key: string;
  setKey(_: string);
  localizedKey: string;
  setLocalizedKey(_: string);
}

export class NSDiffableDataSourceSnapshotReference<SectionIdentifierType, ItemIdentifierType> extends NSObject {
  itemIdentifiers: ItemIdentifierType[];
  numberOfItems: number;
  numberOfSections: number;
  sectionIdentifiers: SectionIdentifierType[];
  appendItemsWithIdentifiers(withIdentifiers: ItemIdentifierType[]): void;
  appendItemsWithIdentifiersIntoSectionWithIdentifier(withIdentifiers: ItemIdentifierType[], intoSectionWithIdentifier: SectionIdentifierType): void;
  appendSectionsWithIdentifiers(withIdentifiers: any[]): void;
  deleteAllItems(): void;
  deleteItemsWithIdentifiers(withIdentifiers: ItemIdentifierType[]): void;
  deleteSectionsWithIdentifiers(withIdentifiers: SectionIdentifierType[]): void;
  indexOfItemIdentifier(ofItemIdentifier: ItemIdentifierType): number;
  indexOfSectionIdentifier(ofSectionIdentifier: SectionIdentifierType): number;
  insertItemsWithIdentifiersAfterItemWithIdentifier(withIdentifiers: ItemIdentifierType[], afterItemWithIdentifier: ItemIdentifierType): void;
  insertItemsWithIdentifiersBeforeItemWithIdentifier(withIdentifiers: ItemIdentifierType[], beforeItemWithIdentifier: ItemIdentifierType): void;
  insertSectionsWithIdentifiersAfterSectionWithIdentifier(withIdentifiers: SectionIdentifierType[], afterSectionWithIdentifier: SectionIdentifierType): void;
  insertSectionsWithIdentifiersBeforeSectionWithIdentifier(withIdentifiers: SectionIdentifierType[], beforeSectionWithIdentifier: SectionIdentifierType): void;
  itemIdentifiersInSectionWithIdentifier(withIdentifier: SectionIdentifierType): ItemIdentifierType[];
  moveItemWithIdentifierAfterItemWithIdentifier(withIdentifier: ItemIdentifierType, afterItemWithIdentifier: ItemIdentifierType): void;
  moveItemWithIdentifierBeforeItemWithIdentifier(withIdentifier: ItemIdentifierType, beforeItemWithIdentifier: ItemIdentifierType): void;
  moveSectionWithIdentifierAfterSectionWithIdentifier(withIdentifier: SectionIdentifierType, afterSectionWithIdentifier: SectionIdentifierType): void;
  moveSectionWithIdentifierBeforeSectionWithIdentifier(withIdentifier: SectionIdentifierType, beforeSectionWithIdentifier: SectionIdentifierType): void;
  // dupe name w instance property   numberOfItemsInSection(inSection: SectionIdentifierType): number;
  reloadItemsWithIdentifiers(withIdentifiers: ItemIdentifierType[]): void;
  reloadSectionsWithIdentifiers(withIdentifiers: SectionIdentifierType[]): void;
  sectionIdentifierForSectionContainingItemIdentifier(forSectionContainingItemIdentifier: ItemIdentifierType): SectionIdentifierType;
}

export class NSDockTile extends NSObject {
  badgeLabel: string;
  setBadgeLabel(_: string);
  contentView: NSView;
  setContentView(_: NSView);
  owner: any;
  showsApplicationBadge: boolean;
  setShowsApplicationBadge(_: boolean);
  size: CGSize;
  display(): void;
}

interface NSDockTilePlugIn {
  dockMenu(): NSMenu;
  setDockTile(_?: NSDockTile): void;
}

export class NSDocument extends NSObject {
  static canConcurrentlyReadDocumentsOfType(ofType: string): boolean;
  static isNativeType(_: string): boolean;
  PDFPrintOperation: NSPrintOperation;
  allowsDocumentSharing: boolean;
  autosavedContentsFileURL: URL;
  setAutosavedContentsFileURL(_: URL);
  autosavingFileType: string;
  autosavingIsImplicitlyCancellable: boolean;
  backupFileURL: URL;
  isBrowsingVersions: boolean;
  displayName: string;
  setDisplayName(_: string);
  isDocumentEdited: boolean;
  isDraft: boolean;
  setDraft(_: boolean);
  isEntireFileLoaded: boolean;
  fileModificationDate: Date;
  setFileModificationDate(_: Date);
  fileNameExtensionWasHiddenInLastRunSavePanel: boolean;
  fileType: string;
  setFileType(_: string);
  fileTypeFromLastRunSavePanel: string;
  fileURL: URL;
  setFileURL(_: URL);
  hasUnautosavedChanges: boolean;
  hasUndoManager: boolean;
  setHasUndoManager(_: boolean);
  isInViewingMode: boolean;
  keepBackupFile: boolean;
  lastComponentOfFileName: string;
  setLastComponentOfFileName(_: string);
  isLocked: boolean;
  printInfo: NSPrintInfo;
  setPrintInfo(_: NSPrintInfo);
  shouldRunSavePanelWithAccessoryView: boolean;
  undoManager: UndoManager;
  setUndoManager(_: UndoManager);
  userActivity: NSUserActivity;
  setUserActivity(_: NSUserActivity);
  windowControllers: NSWindowController[];
  windowForSheet: NSWindow;
  windowNibName: string;
  static autosavesDrafts: boolean;
  static autosavesInPlace: boolean;
  static preservesVersions: boolean;
  static readableTypes: string[];
  static restorableStateKeyPaths: string[];
  static usesUbiquitousStorage: boolean;
  static writableTypes: string[];
  addWindowController(_: NSWindowController): void;
  autosaveDocumentWithDelegateDidAutosaveSelectorContextInfo(withDelegate?: any, didAutosave?: string, contextInfo?: any): void;
  autosaveWithImplicitCancellabilityCompletionHandler(withImplicitCancellability: boolean, completionHandler?: (p1: Error) => void): void;
  browseDocumentVersions(_?: any): void;
  canAsynchronouslyWriteToURLOfTypeForSaveOperation(to: URL, ofType: string, for_: NSDocument.SaveOperationType): boolean;
  canCloseDocumentWithDelegateShouldCloseSelectorContextInfo(withDelegate: any, shouldClose?: string, contextInfo?: any): void;
  changeCountTokenForSaveOperation(for_: NSDocument.SaveOperationType): any;
  checkAutosavingSafetyAndReturnError(): boolean;
  close(): void;
  continueActivityUsingBlock(_: () => void): void;
  continueAsynchronousWorkOnMainThreadUsingBlock(_: () => void): void;
  dataOfType(error: string): Data;
  defaultDraftName(): string;
  duplicateAndReturnError(): NSDocument;
  duplicateDocument(_?: any): void;
  duplicateDocumentWithDelegateDidDuplicateSelectorContextInfo(withDelegate?: any, didDuplicate?: string, contextInfo?: any): void;
  encodeRestorableStateWithCoder(with_: NSCoder): void;
  encodeRestorableStateWithCoderBackgroundQueue(with_: NSCoder, backgroundQueue: OperationQueue): void;
  fileAttributesToWriteToURLOfTypeForSaveOperationOriginalContentsURL(ofType: URL, forSaveOperation: string, originalContentsURL: NSDocument.SaveOperationType, error?: URL): Map<string, any>;
  fileNameExtensionForTypeSaveOperation(forType: string, saveOperation: NSDocument.SaveOperationType): string;
  fileWrapperOfType(error: string): FileWrapper;
  handleCloseScriptCommand(_: NSCloseCommand): any;
  handlePrintScriptCommand(_: NSScriptCommand): any;
  handleSaveScriptCommand(_: NSScriptCommand): any;
  static initForURLWithContentsOfURLOfType(withContentsOfURL?: URL, ofType?: URL, error?: string): NSDocument;
  static initWithContentsOfURLOfType(ofType: URL, error: string): NSDocument;
  static initWithType(error: string): NSDocument;
  invalidateRestorableState(): void;
  lockDocument(_?: any): void;
  lockDocumentWithCompletionHandler(completionHandler?: (p1: boolean) => void): void;
  lockWithCompletionHandler(completionHandler?: (p1: Error) => void): void;
  makeWindowControllers(): void;
  moveDocument(_?: any): void;
  moveDocumentToUbiquityContainer(_?: any): void;
  moveDocumentWithCompletionHandler(completionHandler?: (p1: boolean) => void): void;
  moveToURLCompletionHandler(to: URL, completionHandler?: (p1: Error) => void): void;
  performActivityWithSynchronousWaitingUsingBlock(withSynchronousWaiting: boolean, using: (p1: () => void) => void): void;
  performAsynchronousFileAccessUsingBlock(_: (p1: () => void) => void): void;
  performSynchronousFileAccessUsingBlock(_: () => void): void;
  preparePageLayout(_: NSPageLayout): boolean;
  prepareSavePanel(_: NSSavePanel): boolean;
  prepareSharingServicePicker(_: NSSharingServicePicker): void;
  presentError(_: Error): boolean;
  presentErrorModalForWindowDelegateDidPresentSelectorContextInfo(_: Error, modalFor: NSWindow, delegate?: any, didPresent?: string, contextInfo?: any): void;
  printDocument(_?: any): void;
  printDocumentWithSettingsShowPrintPanelDelegateDidPrintSelectorContextInfo(withSettings: Map<string, any>, showPrintPanel: boolean, delegate?: any, didPrint?: string, contextInfo?: any): void;
  printOperationWithSettings(error: Map<string, any>): NSPrintOperation;
  readFromDataOfType(ofType: Data, error: string): boolean;
  readFromFileWrapperOfType(ofType: FileWrapper, error: string): boolean;
  readFromURLOfType(ofType: URL, error: string): boolean;
  removeWindowController(_: NSWindowController): void;
  renameDocument(_?: any): void;
  restoreDocumentWindowWithIdentifierStateCompletionHandler(withIdentifier: string, state: NSCoder, completionHandler?: (p1: NSWindow, p2: Error) => void): void;
  restoreStateWithCoder(with_: NSCoder): void;
  revertDocumentToSaved(_?: any): void;
  revertToContentsOfURLOfType(ofType: URL, error: string): boolean;
  runModalPageLayoutWithPrintInfoDelegateDidRunSelectorContextInfo(with_: NSPrintInfo, delegate?: any, didRun?: string, contextInfo?: any): void;
  runModalPrintOperationDelegateDidRunSelectorContextInfo(_: NSPrintOperation, delegate?: any, didRun?: string, contextInfo?: any): void;
  runModalSavePanelForSaveOperationDelegateDidSaveSelectorContextInfo(for_: NSDocument.SaveOperationType, delegate?: any, didSave?: string, contextInfo?: any): void;
  runPageLayout(_?: any): void;
  saveDocument(_?: any): void;
  saveDocumentAs(_?: any): void;
  saveDocumentTo(_?: any): void;
  saveDocumentToPDF(_?: any): void;
  saveDocumentWithDelegateDidSaveSelectorContextInfo(withDelegate?: any, didSave?: string, contextInfo?: any): void;
  saveToURLOfTypeForSaveOperationCompletionHandler(to: URL, ofType: string, for_: NSDocument.SaveOperationType, completionHandler?: (p1: Error) => void): void;
  saveToURLOfTypeForSaveOperationDelegateDidSaveSelectorContextInfo(to: URL, ofType: string, for_: NSDocument.SaveOperationType, delegate?: any, didSave?: string, contextInfo?: any): void;
  scheduleAutosaving(): void;
  setDisplayName(_?: string): void;
  setWindow(_?: NSWindow): void;
  shareDocumentWithSharingServiceCompletionHandler(with_: NSSharingService, completionHandler?: (p1: boolean) => void): void;
  shouldChangePrintInfo(_: NSPrintInfo): boolean;
  shouldCloseWindowControllerDelegateShouldCloseSelectorContextInfo(_: NSWindowController, delegate?: any, shouldClose?: string, contextInfo?: any): void;
  showWindows(): void;
  stopBrowsingVersionsWithCompletionHandler(completionHandler?: () => void): void;
  unblockUserInteraction(): void;
  unlockDocument(_?: any): void;
  unlockDocumentWithCompletionHandler(completionHandler?: (p1: boolean) => void): void;
  unlockWithCompletionHandler(completionHandler?: (p1: Error) => void): void;
  updateChangeCount(_: NSDocument.ChangeType): void;
  updateChangeCountWithTokenForSaveOperation(withToken: any, for_: NSDocument.SaveOperationType): void;
  updateUserActivityState(_: NSUserActivity): void;
  willNotPresentError(_: Error): void;
  willPresentError(_: Error): Error;
  windowControllerDidLoadNib(_: NSWindowController): void;
  windowControllerWillLoadNib(_: NSWindowController): void;
  // dupe name w static property   writableTypesForSaveOperation(for_: NSDocument.SaveOperationType): string[];
  writeSafelyToURLOfTypeForSaveOperation(ofType: URL, forSaveOperation: string, error: NSDocument.SaveOperationType): boolean;
  writeToURLOfType(ofType: URL, error: string): boolean;
  writeToURLOfTypeForSaveOperationOriginalContentsURL(ofType: URL, forSaveOperation: string, originalContentsURL: NSDocument.SaveOperationType, error?: URL): boolean;
}

export class NSDocumentController extends NSObject {
  allowsAutomaticShareMenu: boolean;
  autosavingDelay: number;
  setAutosavingDelay(_: number);
  currentDirectory: string;
  currentDocument: NSDocument;
  defaultType: string;
  documentClassNames: string[];
  documents: NSDocument[];
  hasEditedDocuments: boolean;
  maximumRecentDocumentCount: number;
  recentDocumentURLs: URL[];
  static sharedDocumentController: NSDocumentController;
  uRLsFromRunningOpenPanel(): URL[];
  addDocument(_: NSDocument): void;
  beginOpenPanelForTypesCompletionHandler(_: NSOpenPanel, forTypes?: string[], completionHandler?: (p1: number) => void): void;
  beginOpenPanelWithCompletionHandler(completionHandler?: (p1: URL[]) => void): void;
  clearRecentDocuments(_?: any): void;
  closeAllDocumentsWithDelegateDidCloseAllSelectorContextInfo(withDelegate?: any, didCloseAllSelector?: string, contextInfo?: any): void;
  displayNameForType(forType: string): string;
  documentClassForType(forType: string): typeof NSObject;
  documentForURL(for_: URL): NSDocument;
  documentForWindow(for_: NSWindow): NSDocument;
  duplicateDocumentWithContentsOfURLCopyingDisplayName(copying: URL, displayName: boolean, error?: string): NSDocument;
  makeDocumentForURLWithContentsOfURLOfType(withContentsOfURL?: URL, ofType?: URL, error?: string): NSDocument;
  makeDocumentWithContentsOfURLOfType(ofType: URL, error: string): NSDocument;
  makeUntitledDocumentOfType(error: string): NSDocument;
  newDocument(_?: any): void;
  noteNewRecentDocument(_: NSDocument): void;
  noteNewRecentDocumentURL(_: URL): void;
  openDocument(_?: any): void;
  openDocumentWithContentsOfURLDisplayCompletionHandler(withContentsOf: URL, display: boolean, completionHandler?: (p1: NSDocument, p2: boolean, p3: Error) => void): void;
  openUntitledDocumentAndDisplay(error: boolean): NSDocument;
  presentError(_: Error): boolean;
  presentErrorModalForWindowDelegateDidPresentSelectorContextInfo(_: Error, modalFor: NSWindow, delegate?: any, didPresent?: string, contextInfo?: any): void;
  removeDocument(_: NSDocument): void;
  reopenDocumentForURLWithContentsOfURLDisplayCompletionHandler(for_?: URL, withContentsOf?: URL, display?: boolean, completionHandler?: (p1: NSDocument, p2: boolean, p3: Error) => void): void;
  reviewUnsavedDocumentsWithAlertTitleCancellableDelegateDidReviewAllSelectorContextInfo(withAlertTitle?: string, cancellable?: boolean, delegate?: any, didReviewAllSelector?: string, contextInfo?: any): void;
  runModalOpenPanelForTypes(_: NSOpenPanel, forTypes?: string[]): number;
  saveAllDocuments(_?: any): void;
  standardShareMenuItem(): NSMenuItem;
  typeForContentsOfURL(error: URL): string;
  willPresentError(_: Error): Error;
}

// export function NSDottedFrameRect(rect: CGRect): void;

interface NSDraggingDestination {
  concludeDragOperation(_?: any): void;
  draggingEnded(_: any): void;
  draggingEntered(_: any): NSDragging.NSDragOperation;
  draggingExited(_?: any): void;
  draggingUpdated(_: any): NSDragging.NSDragOperation;
  performDragOperation(_: any): boolean;
  prepareForDragOperation(_: any): boolean;
  updateDraggingItemsForDrag(_?: any): void;
  wantsPeriodicDraggingUpdates(): boolean;
}

export class NSDraggingImageComponent extends NSObject {
  contents: any;
  setContents(_: any);
  frame: CGRect;
  setFrame(_: CGRect);
  key: string;
  setKey(_: string);
  static initWithKey(_: string): NSDraggingImageComponent;
}

interface NSDraggingInfo {
  animatesToDestination: boolean;
  setAnimatesToDestination(_: boolean);
    // unavailableInSwift draggedImage: NSImage;
  draggedImageLocation: CGPoint;
  draggingDestinationWindow: NSWindow;
  draggingFormation: NSDragging.NSDraggingFormation;
  setDraggingFormation(_: NSDragging.NSDraggingFormation);
  draggingLocation: CGPoint;
  draggingPasteboard: NSPasteboard;
  draggingSequenceNumber: number;
  draggingSource: any;
  draggingSourceOperationMask: NSDragging.NSDragOperation;
  numberOfValidItemsForDrop: number;
  setNumberOfValidItemsForDrop(_: number);
  springLoadingHighlight: NSDragging.NSSpringLoadingHighlight;
  enumerateDraggingItemsWithOptionsForViewClassesSearchOptionsUsingBlock(options: NSDragging.NSDraggingItemEnumerationOptions, for_?: NSView, classes?: typeof NSObject[], searchOptions?: Map<string, any>, using?: (p1: NSDraggingItem, p2: number, p3: boolean) => void): void;
  resetSpringLoading(): void;
  slideDraggedImageTo(to: CGPoint): void;
}

export class NSDraggingItem extends NSObject {
  draggingFrame: CGRect;
  setDraggingFrame(_: CGRect);
  imageComponents: NSDraggingImageComponent[];
  imageComponentsProvider: () => NSDraggingImageComponent[];
  setImageComponentsProvider(_: () => NSDraggingImageComponent[]);
  item: any;
  static initWithPasteboardWriter(_: any): NSDraggingItem;
  setDraggingFrameContents(_: CGRect, contents?: any): void;
}

export class NSDraggingSession extends NSObject {
  animatesToStartingPositionsOnCancelOrFail: boolean;
  setAnimatesToStartingPositionsOnCancelOrFail(_: boolean);
  draggingFormation: NSDragging.NSDraggingFormation;
  setDraggingFormation(_: NSDragging.NSDraggingFormation);
  draggingLeaderIndex: number;
  setDraggingLeaderIndex(_: number);
  draggingLocation: CGPoint;
  draggingPasteboard: NSPasteboard;
  draggingSequenceNumber: number;
  enumerateDraggingItemsWithOptionsForViewClassesSearchOptionsUsingBlock(options: NSDragging.NSDraggingItemEnumerationOptions, for_?: NSView, classes?: typeof NSObject[], searchOptions?: Map<string, any>, using?: (p1: NSDraggingItem, p2: number, p3: boolean) => void): void;
}

interface NSDraggingSource {
  draggingSessionSourceOperationMaskForDraggingContext(_: NSDraggingSession, sourceOperationMaskFor: NSDragging.NSDraggingContext): NSDragging.NSDragOperation;
  draggingSessionWillBeginAtPoint(_: NSDraggingSession, willBeginAt: CGPoint): void;
  draggingSessionMovedToPoint(_: NSDraggingSession, movedTo: CGPoint): void;
  draggingSessionEndedAtPointOperation(_: NSDraggingSession, endedAt: CGPoint, operation: NSDragging.NSDragOperation): void;
  ignoreModifierKeysForDraggingSession(for_: NSDraggingSession): boolean;
}

// export function NSDrawBitmap(rect: CGRect, width: number, height: number, bps: number, spp: number, bpp: number, bpr: number, isPlanar: boolean, hasAlpha: boolean, colorSpaceName: string, data: string): void;

// export function NSDrawButton(rect: CGRect, clipRect: CGRect): void;

// export function NSDrawColorTiledRects(boundsRect: CGRect, clipRect: CGRect, sides: NSGeometry.NSRectEdge, colors: NSColor, count: number): CGRect;

// export function NSDrawDarkBezel(rect: CGRect, clipRect: CGRect): void;

// export function NSDrawGrayBezel(rect: CGRect, clipRect: CGRect): void;

// export function NSDrawGroove(rect: CGRect, clipRect: CGRect): void;

// export function NSDrawLightBezel(rect: CGRect, clipRect: CGRect): void;

// export function NSDrawNinePartImage(frame: CGRect, topLeftCorner: NSImage, topEdgeFill: NSImage, topRightCorner: NSImage, leftEdgeFill: NSImage, centerFill: NSImage, rightEdgeFill: NSImage, bottomLeftCorner: NSImage, bottomEdgeFill: NSImage, bottomRightCorner: NSImage, op: NSGraphics.NSCompositingOperation, alphaFraction: number, flipped: boolean): void;

// export function NSDrawThreePartImage(frame: CGRect, startCap: NSImage, centerFill: NSImage, endCap: NSImage, vertical: boolean, op: NSGraphics.NSCompositingOperation, alphaFraction: number, flipped: boolean): void;

// export function NSDrawTiledRects(boundsRect: CGRect, clipRect: CGRect, sides: NSGeometry.NSRectEdge, grays: number, count: number): CGRect;

// export function NSDrawWhiteBezel(rect: CGRect, clipRect: CGRect): void;

// export function NSDrawWindowBackground(rect: CGRect): void;

interface NSDrawerDelegate {
}

export class NSEPSImageRep extends NSImageRep {
  EPSRepresentation: Data;
  boundingBox: CGRect;
  static initWithData(_: Data): NSEPSImageRep;
}

interface NSEditor {
  commitEditing(): boolean;
  commitEditingWithDelegateDidCommitSelectorContextInfo(withDelegate?: any, didCommit?: string, contextInfo?: any): void;
  commitEditingAndReturnError(): boolean;
  discardEditing(): void;
}

interface NSEditorRegistration {
  objectDidBeginEditing(_: any): void;
  objectDidEndEditing(_: any): void;
}

// export function NSEraseRect(rect: CGRect): void;

export class NSEvent extends NSObject {
  static addGlobalMonitorForEventsMatchingMaskHandler(matching: NSEvent.EventTypeMask, handler: (p1: NSEvent) => void): any;
  static addLocalMonitorForEventsMatchingMaskHandler(matching: NSEvent.EventTypeMask, handler?: (p1: NSEvent) => NSEvent): any;
  static enterExitEventWithTypeLocationModifierFlagsTimestampWindowNumberContextEventNumberTrackingNumberUserData(with_: NSEvent.EventType, location: CGPoint, modifierFlags: NSEvent.ModifierFlags, timestamp: number, windowNumber: number, context?: NSGraphicsContext, eventNumber?: number, trackingNumber?: number, userData?: any): NSEvent;
  static keyEventWithTypeLocationModifierFlagsTimestampWindowNumberContextCharactersCharactersIgnoringModifiersIsARepeatKeyCode(with_: NSEvent.EventType, location: CGPoint, modifierFlags: NSEvent.ModifierFlags, timestamp: number, windowNumber: number, context?: NSGraphicsContext, characters?: string, charactersIgnoringModifiers?: string, isARepeat?: boolean, keyCode?: number): NSEvent;
  static mouseEventWithTypeLocationModifierFlagsTimestampWindowNumberContextEventNumberClickCountPressure(with_: NSEvent.EventType, location: CGPoint, modifierFlags: NSEvent.ModifierFlags, timestamp: number, windowNumber: number, context?: NSGraphicsContext, eventNumber?: number, clickCount?: number, pressure?: number): NSEvent;
  static otherEventWithTypeLocationModifierFlagsTimestampWindowNumberContextSubtypeData1Data2(with_: NSEvent.EventType, location: CGPoint, modifierFlags: NSEvent.ModifierFlags, timestamp: number, windowNumber: number, context?: NSGraphicsContext, subtype?: number, data1?: number, data2?: number): NSEvent;
  static removeMonitor(_: any): void;
  static startPeriodicEventsAfterDelayWithPeriod(afterDelay: number, withPeriod: number): void;
  static stopPeriodicEvents(): void;
  isARepeat: boolean;
  CGEvent: any;
  absoluteX: number;
  absoluteY: number;
  absoluteZ: number;
  associatedEventsMask: NSEvent.EventTypeMask;
  buttonMask: NSEvent.ButtonMask;
  buttonNumber: number;
  capabilityMask: number;
  characters: string;
  charactersIgnoringModifiers: string;
  clickCount: number;
  data1: number;
  data2: number;
  deltaX: number;
  deltaY: number;
  deltaZ: number;
  deviceID: number;
  isDirectionInvertedFromDevice: boolean;
  isEnteringProximity: boolean;
  eventNumber: number;
  eventRef: any;
  hasPreciseScrollingDeltas: boolean;
  keyCode: number;
  locationInWindow: CGPoint;
  magnification: number;
  modifierFlags: NSEvent.ModifierFlags;
  momentumPhase: NSEvent.Phase;
  phase: NSEvent.Phase;
  pointingDeviceID: number;
  pointingDeviceSerialNumber: number;
  pointingDeviceType: NSEvent.PointingDeviceType;
  pressure: number;
  pressureBehavior: NSEvent.PressureBehavior;
  rotation: number;
  scrollingDeltaX: number;
  scrollingDeltaY: number;
  stage: number;
  stageTransition: number;
  subtype: NSEvent.EventSubtype;
  systemTabletID: number;
  tabletID: number;
  tangentialPressure: number;
  tilt: CGPoint;
  timestamp: number;
  trackingArea: NSTrackingArea;
  trackingNumber: number;
  type: NSEvent.EventType;
  uniqueID: number;
  userData: any;
  vendorDefined: any;
  vendorID: number;
  vendorPointingDeviceType: number;
  window: NSWindow;
  windowNumber: number;
  static doubleClickInterval: number;
  static keyRepeatDelay: number;
  static keyRepeatInterval: number;
  //   static modifierFlags: NSEvent.ModifierFlags;
  static isMouseCoalescingEnabled: boolean;
  setMouseCoalescingEnabled(_: boolean);
  static mouseLocation: CGPoint;
  static pressedMouseButtons: number;
  static isSwipeTrackingFromScrollEventsEnabled: boolean;
  allTouches(): Set<any>;
  // dupe name w instance property   charactersByApplyingModifiers(byApplyingModifiers: NSEvent.ModifierFlags): string;
  coalescedTouchesForTouch(for_: NSTouch): NSTouch[];
  touchesForView(for_: NSView): Set<any>;
  touchesMatchingPhaseInView(matching: NSTouch.Phase, in_?: NSView): Set<any>;
  trackSwipeEventWithOptionsDampenAmountThresholdMinMaxUsingHandler(options: NSEvent.SwipeTrackingOptions, dampenAmountThresholdMin: number, max: number, usingHandler: (p1: number, p2: NSEvent.Phase, p3: boolean, p4: boolean) => void): void;
}

export class NSFilePromiseProvider extends NSObject {
  delegate: any;
  setDelegate(_: any);
  fileType: string;
  setFileType(_: string);
  userInfo: any;
  setUserInfo(_: any);
  static initWithFileTypeDelegate(_: string, delegate: any): NSFilePromiseProvider;
}

interface NSFilePromiseProviderDelegate {
  filePromiseProviderFileNameForType(_: NSFilePromiseProvider, fileNameForType: string): string;
  filePromiseProviderWritePromiseToURLCompletionHandler(_: NSFilePromiseProvider, writePromiseTo: URL, completionHandler?: (p1: Error) => void): void;
  operationQueueForFilePromiseProvider(for_: NSFilePromiseProvider): OperationQueue;
}

export class NSFilePromiseReceiver extends NSObject {
  fileNames: string[];
  fileTypes: string[];
  static readableDraggedTypes: string[];
  receivePromisedFilesAtDestinationOptionsOperationQueueReader(atDestination: URL, options: Map<any, any>, operationQueue: OperationQueue, reader?: (p1: URL, p2: Error) => void): void;
}

export class NSFont extends NSObject {
  static boldSystemFontOfSize(ofSize: number): NSFont;
  static controlContentFontOfSize(ofSize: number): NSFont;
  static labelFontOfSize(ofSize: number): NSFont;
  static menuBarFontOfSize(ofSize: number): NSFont;
  static menuFontOfSize(ofSize: number): NSFont;
  static messageFontOfSize(ofSize: number): NSFont;
  static monospacedDigitSystemFontOfSizeWeight(ofSize: number, weight: number): NSFont;
  static monospacedSystemFontOfSizeWeight(ofSize: number, weight: number): NSFont;
  static paletteFontOfSize(ofSize: number): NSFont;
  static setUserFixedPitchFont(_?: NSFont): void;
  static setUserFont(_?: NSFont): void;
  static systemFontOfSize(ofSize: number): NSFont;
  static systemFontOfSizeWeight(ofSize: number, weight: number): NSFont;
  //  static systemFontSizeForControlSize(for_: NSCell.NSControl.ControlSize): number;
  static titleBarFontOfSize(ofSize: number): NSFont;
  static toolTipsFontOfSize(ofSize: number): NSFont;
  static userFixedPitchFontOfSize(ofSize: number): NSFont;
  static userFontOfSize(ofSize: number): NSFont;
  ascender: number;
  boundingRectForFont: CGRect;
  capHeight: number;
  coveredCharacterSet: CharacterSet;
  descender: number;
  displayName: string;
  familyName: string;
  isFixedPitch: boolean;
  fontDescriptor: NSFontDescriptor;
  fontName: string;
  italicAngle: number;
  leading: number;
  matrix: number;
  maximumAdvancement: CGSize;
  mostCompatibleStringEncoding: number;
  numberOfGlyphs: number;
  pointSize: number;
  printerFont: NSFont;
  renderingMode: NSFont.NSFontRenderingMode;
  screenFont: NSFont;
  textTransform: AffineTransform;
  underlinePosition: number;
  underlineThickness: number;
  isVertical: boolean;
  verticalFont: NSFont;
  xHeight: number;
  static labelFontSize: number;
  static smallSystemFontSize: number;
  static systemFontSize: number;
  advancementForCGGlyph(forCGGlyph: number): CGSize;
  advancementForGlyph(forGlyph: number): CGSize;
  boundingRectForCGGlyph(forCGGlyph: number): CGRect;
  boundingRectForGlyph(forGlyph: number): CGRect;
  getAdvancementsForCGGlyphsCount(_: CGSize, forCGGlyphs: number, count: number): void;
  getAdvancementsForGlyphsCount(_: CGSize, forGlyphs: number, count: number): void;
  getAdvancementsForPackedGlyphsLength(_: CGSize, forPackedGlyphs: any, length: number): void;
  getBoundingRectsForCGGlyphsCount(_: CGRect, forCGGlyphs: number, count: number): void;
  getBoundingRectsForGlyphsCount(_: CGRect, forGlyphs: number, count: number): void;
  glyphWithName(withName: string): number;
  // dupe name w instance property   screenFontWithRenderingMode(with_: NSFont.NSFontRenderingMode): NSFont;
  set(): void;
  setInContext(in_: NSGraphicsContext): void;
}

export class NSFontAssetRequest extends NSObject {
  downloadedFontDescriptors: NSFontDescriptor[];
  downloadFontAssetsWithCompletionHandler(withCompletionHandler?: (p1: Error) => boolean): void;
  static initWithFontDescriptorsOptions(_: NSFontDescriptor[], options: NSFontAssetRequest.Options): NSFontAssetRequest;
}

interface NSFontChanging {
  changeFont(_?: NSFontManager): void;
  validModesForFontPanel(_: NSFontPanel): NSFontPanel.ModeMask;
}

export class NSFontCollection extends NSObject {
  static hideFontCollectionWithNameVisibility(visibility: string, error: NSFontCollection.Visibility): boolean;
  static renameFontCollectionWithNameVisibilityToName(fromName: string, visibility: NSFontCollection.Visibility, toName: string): boolean;
  static showFontCollectionWithNameVisibility(withName: NSFontCollection, visibility: string, error: NSFontCollection.Visibility): boolean;
  exclusionDescriptors: NSFontDescriptor[];
  matchingDescriptors: NSFontDescriptor[];
  queryDescriptors: NSFontDescriptor[];
  static allFontCollectionNames: string[];
  static fontCollectionWithAllAvailableDescriptors: NSFontCollection;
  // dupe name w instance property   matchingDescriptorsForFamily(forFamily: string): NSFontDescriptor[];
  // dupe name w instance property   matchingDescriptorsForFamilyOptions(forFamily: string, options?: Map<string, number>): NSFontDescriptor[];
  // dupe name w instance property   matchingDescriptorsWithOptions(options?: Map<string, number>): NSFontDescriptor[];
}

export class NSFontDescriptor extends NSObject {
  fontAttributes: Map<string, any>;
  matrix: AffineTransform;
  pointSize: number;
  postscriptName: string;
  requiresFontAssetRequest: boolean;
  symbolicTraits: NSFontDescriptor.SymbolicTraits;
  fontDescriptorByAddingAttributes(_: Map<string, any>): NSFontDescriptor;
  fontDescriptorWithDesign(_: string): NSFontDescriptor;
  fontDescriptorWithFace(_: string): NSFontDescriptor;
  fontDescriptorWithFamily(_: string): NSFontDescriptor;
  fontDescriptorWithMatrix(_: AffineTransform): NSFontDescriptor;
  fontDescriptorWithSize(_: number): NSFontDescriptor;
  fontDescriptorWithSymbolicTraits(_: NSFontDescriptor.SymbolicTraits): NSFontDescriptor;
  static initWithFontAttributes(_?: Map<string, any>): NSFontDescriptor;
  matchingFontDescriptorWithMandatoryKeys(withMandatoryKeys?: Set<any>): NSFontDescriptor;
  matchingFontDescriptorsWithMandatoryKeys(withMandatoryKeys?: Set<any>): NSFontDescriptor[];
  objectForKey(forKey: string): any;
}

export class NSFontManager extends NSObject {
  static setFontManagerFactory(_?: typeof NSObject): void;
  static setFontPanelFactory(_?: typeof NSObject): void;
  action: string;
  setAction(_: string);
  availableFontFamilies: string[];
  availableFonts: string[];
  currentFontAction: NSFontManager.NSFontAction;
  isEnabled: boolean;
  setEnabled(_: boolean);
  isMultiple: boolean;
  selectedFont: NSFont;
  target: any;
  setTarget(_: any);
  static sharedFontManager: NSFontManager;
  addFontTrait(_?: any): void;
  availableFontNamesWithTraits(with_: NSFontManager.NSFontTraitMask): string[];
  availableMembersOfFontFamily(ofFontFamily: string): any[][];
  convertAttributes(_: Map<string, any>): Map<string, any>;
  convertFont(_: NSFont): NSFont;
  convertFontToFace(_: NSFont, toFace: string): NSFont;
  convertFontToFamily(_: NSFont, toFamily: string): NSFont;
  convertFontToHaveTrait(_: NSFont, toHaveTrait: NSFontManager.NSFontTraitMask): NSFont;
  convertFontToNotHaveTrait(_: NSFont, toNotHaveTrait: NSFontManager.NSFontTraitMask): NSFont;
  convertFontToSize(_: NSFont, toSize: number): NSFont;
  convertFontTraits(_: NSFontManager.NSFontTraitMask): NSFontManager.NSFontTraitMask;
  convertWeightOfFont(_: boolean, of: NSFont): NSFont;
  fontMenu(_: boolean): NSMenu;
  fontNamedHasTraits(_: string, hasTraits: NSFontManager.NSFontTraitMask): boolean;
  fontPanel(_: boolean): NSFontPanel;
  fontWithFamilyTraitsWeightSize(withFamily: string, traits: NSFontManager.NSFontTraitMask, weight: number, size: number): NSFont;
  localizedNameForFamilyFace(forFamily: string, face?: string): string;
  modifyFont(_?: any): void;
  modifyFontViaPanel(_?: any): void;
  orderFrontFontPanel(_?: any): void;
  orderFrontStylesPanel(_?: any): void;
  removeFontTrait(_?: any): void;
  sendAction(): boolean;
  setFontMenu(_: NSMenu): void;
  setSelectedAttributesIsMultiple(_: Map<string, any>, isMultiple: boolean): void;
  setSelectedFontIsMultiple(_: NSFont, isMultiple: boolean): void;
  traitsOfFont(of: NSFont): NSFontManager.NSFontTraitMask;
  weightOfFont(of: NSFont): number;
}

export class NSFontPanel extends NSPanel {
  accessoryView: NSView;
  setAccessoryView(_: NSView);
  isEnabled: boolean;
  setEnabled(_: boolean);
  static sharedFontPanel: NSFontPanel;
  static sharedFontPanelExists: boolean;
  panelConvertFont(_: NSFont): NSFont;
  reloadDefaultFontFamilies(): void;
  setPanelFontIsMultiple(_: NSFont, isMultiple: boolean): void;
}

export class NSFormCell extends NSActionCell {
  attributedTitle: NSAttributedString;
  setAttributedTitle(_: NSAttributedString);
  placeholderAttributedString: NSAttributedString;
  setPlaceholderAttributedString(_: NSAttributedString);
  placeholderString: string;
  setPlaceholderString(_: string);
  preferredTextFieldWidth: number;
  setPreferredTextFieldWidth(_: number);
  titleAlignment: NSText.NSTextAlignment;
  setTitleAlignment(_: NSText.NSTextAlignment);
  titleBaseWritingDirection: NSText.NSWritingDirection;
  setTitleBaseWritingDirection(_: NSText.NSWritingDirection);
  titleFont: NSFont;
  setTitleFont(_: NSFont);
  titleWidth: number;
  setTitleWidth(_: number);
  // dupe name w instance property   titleWidth(_: CGSize): number;
}

// export function NSFrameRect(rect: CGRect): void;

// export function NSFrameRectWithWidth(rect: CGRect, frameWidth: number): void;

// export function NSFrameRectWithWidthUsingOperation(rect: CGRect, frameWidth: number, op: NSGraphics.NSCompositingOperation): void;

export class NSGestureRecognizer extends NSObject {
  action: string;
  setAction(_: string);
  allowedTouchTypes: NSTouch.TouchTypeMask;
  setAllowedTouchTypes(_: NSTouch.TouchTypeMask);
  delaysKeyEvents: boolean;
  setDelaysKeyEvents(_: boolean);
  delaysMagnificationEvents: boolean;
  setDelaysMagnificationEvents(_: boolean);
  delaysOtherMouseButtonEvents: boolean;
  setDelaysOtherMouseButtonEvents(_: boolean);
  delaysPrimaryMouseButtonEvents: boolean;
  setDelaysPrimaryMouseButtonEvents(_: boolean);
  delaysRotationEvents: boolean;
  setDelaysRotationEvents(_: boolean);
  delaysSecondaryMouseButtonEvents: boolean;
  setDelaysSecondaryMouseButtonEvents(_: boolean);
  delegate: any;
  setDelegate(_: any);
  isEnabled: boolean;
  setEnabled(_: boolean);
  pressureConfiguration: NSPressureConfiguration;
  setPressureConfiguration(_: NSPressureConfiguration);
  state: NSGestureRecognizer.State;
  setState(_: NSGestureRecognizer.State);
  target: any;
  setTarget(_: any);
  canBePreventedByGestureRecognizer(by: NSGestureRecognizer): boolean;
  canPreventGestureRecognizer(_: NSGestureRecognizer): boolean;
  flagsChanged(with_: NSEvent): void;
  static initWithTargetAction(_?: any, action?: string): NSGestureRecognizer;
  keyDown(with_: NSEvent): void;
  keyUp(with_: NSEvent): void;
  locationInView(in_?: NSView): CGPoint;
  magnifyWithEvent(with_: NSEvent): void;
  mouseDown(with_: NSEvent): void;
  mouseDragged(with_: NSEvent): void;
  mouseUp(with_: NSEvent): void;
  otherMouseDown(with_: NSEvent): void;
  otherMouseDragged(with_: NSEvent): void;
  otherMouseUp(with_: NSEvent): void;
  pressureChangeWithEvent(with_: NSEvent): void;
  reset(): void;
  rightMouseDown(with_: NSEvent): void;
  rightMouseDragged(with_: NSEvent): void;
  rightMouseUp(with_: NSEvent): void;
  rotateWithEvent(with_: NSEvent): void;
  shouldBeRequiredToFailByGestureRecognizer(by: NSGestureRecognizer): boolean;
  shouldRequireFailureOfGestureRecognizer(of: NSGestureRecognizer): boolean;
  tabletPoint(with_: NSEvent): void;
  touchesBeganWithEvent(with_: NSEvent): void;
  touchesCancelledWithEvent(with_: NSEvent): void;
  touchesEndedWithEvent(with_: NSEvent): void;
  touchesMovedWithEvent(with_: NSEvent): void;
}

interface NSGestureRecognizerDelegate {
  gestureRecognizerShouldAttemptToRecognizeWithEvent(_: NSGestureRecognizer, shouldAttemptToRecognizeWith: NSEvent): boolean;
  gestureRecognizerShouldRecognizeSimultaneouslyWithGestureRecognizer(_: NSGestureRecognizer, shouldRecognizeSimultaneouslyWith: NSGestureRecognizer): boolean;
  gestureRecognizerShouldRequireFailureOfGestureRecognizer(_: NSGestureRecognizer, shouldRequireFailureOf: NSGestureRecognizer): boolean;
  gestureRecognizerShouldBeRequiredToFailByGestureRecognizer(_: NSGestureRecognizer, shouldBeRequiredToFailBy: NSGestureRecognizer): boolean;
  gestureRecognizerShouldReceiveTouch(_: NSGestureRecognizer, shouldReceive: NSTouch): boolean;
  gestureRecognizerShouldBegin(_: NSGestureRecognizer): boolean;
}

// export function NSGetFileType(pboardType: string): string;

// export function NSGetFileTypes(pboardTypes: string[]): string[];

export class NSGlyphGenerator extends NSObject {
  static sharedGlyphGenerator: NSGlyphGenerator;
  generateGlyphsForGlyphStorageDesiredNumberOfCharactersGlyphIndexCharacterIndex(for_: any, desiredNumberOfCharacters: number, glyphIndex?: number, characterIndex?: number): void;
}

export class NSGlyphInfo extends NSObject {
  baseString: string;
  characterCollection: NSGlyphInfo.NSCharacterCollection;
  characterIdentifier: number;
  glyphID: number;
  glyphName: string;
}

interface NSGlyphStorage {
  attributedString(): NSAttributedString;
  insertGlyphsLengthForStartingGlyphAtIndexCharacterIndex(_: number, length: number, forStartingGlyphAt: number, characterIndex: number): void;
  layoutOptions(): number;
  setIntAttributeValueForGlyphAtIndex(_: number, value: number, forGlyphAt: number): void;
}

export class NSGradient extends NSObject {
  colorSpace: NSColorSpace;
  numberOfColorStops: number;
  drawFromCenterRadiusToCenterRadiusOptions(fromCenter: CGPoint, radius: number, toCenter: CGPoint, radius2: number, options: NSGradient.DrawingOptions): void;
  drawFromPointToPointOptions(from: CGPoint, to: CGPoint, options: NSGradient.DrawingOptions): void;
  drawInBezierPathAngle(in_: NSBezierPath, angle: number): void;
  drawInBezierPathRelativeCenterPosition(in_: NSBezierPath, relativeCenterPosition: CGPoint): void;
  drawInRectAngle(in_: CGRect, angle: number): void;
  drawInRectRelativeCenterPosition(in_: CGRect, relativeCenterPosition: CGPoint): void;
  getColorLocationAtIndex(_?: NSColor, location?: number, at?: number): void;
  static initWithColors(_: NSColor[]): NSGradient;
  static initWithColorsAtLocationsColorSpace(_: NSColor[], atLocations?: number, colorSpace?: NSColorSpace): NSGradient;
  static initWithColorsAndLocations(_: NSColor): NSGradient;
  static initWithStartingColorEndingColor(_: NSColor, endingColor: NSColor): NSGradient;
  interpolatedColorAtLocation(atLocation: number): NSColor;
}

export class NSGraphicsContext extends NSObject {
  static currentContextDrawingToScreen(): boolean;
  //  static restoreGraphicsState(): void;
  //  static saveGraphicsState(): void;
  CGContext: any;
  CIContext: CIContext;
  attributes: Map<string, any>;
  colorRenderingIntent: NSGraphics.NSColorRenderingIntent;
  setColorRenderingIntent(_: NSGraphics.NSColorRenderingIntent);
  compositingOperation: NSGraphics.NSCompositingOperation;
  setCompositingOperation(_: NSGraphics.NSCompositingOperation);
  isDrawingToScreen: boolean;
  isFlipped: boolean;
  imageInterpolation: NSGraphicsContext.NSImageInterpolation;
  setImageInterpolation(_: NSGraphicsContext.NSImageInterpolation);
  patternPhase: CGPoint;
  setPatternPhase(_: CGPoint);
  shouldAntialias: boolean;
  setShouldAntialias(_: boolean);
  static currentContext: NSGraphicsContext;
  setCurrentContext(_: NSGraphicsContext);
  flushGraphics(): void;
  restoreGraphicsState(): void;
  saveGraphicsState(): void;
}

export class NSGridCell extends NSObject {
  column: NSGridColumn;
  contentView: NSView;
  setContentView(_: NSView);
  customPlacementConstraints: NSLayoutConstraint[];
  setCustomPlacementConstraints(_: NSLayoutConstraint[]);
  row: NSGridRow;
  rowAlignment: NSGridView.NSGridRow.Alignment;
  setRowAlignment(_: NSGridView.NSGridRow.Alignment);
  xPlacement: NSGridView.NSGridCell.Placement;
  setXPlacement(_: NSGridView.NSGridCell.Placement);
  yPlacement: NSGridView.NSGridCell.Placement;
  setYPlacement(_: NSGridView.NSGridCell.Placement);
  static emptyContentView: NSView;
}

export class NSGridColumn extends NSObject {
  gridView: NSGridView;
  isHidden: boolean;
  setHidden(_: boolean);
  leadingPadding: number;
  setLeadingPadding(_: number);
  numberOfCells: number;
  trailingPadding: number;
  setTrailingPadding(_: number);
  width: number;
  setWidth(_: number);
  xPlacement: NSGridView.NSGridCell.Placement;
  setXPlacement(_: NSGridView.NSGridCell.Placement);
  cellAtIndex(at: number): NSGridCell;
  mergeCellsInRange(in_: NSRange): void;
}

export class NSGridRow extends NSObject {
  bottomPadding: number;
  setBottomPadding(_: number);
  gridView: NSGridView;
  height: number;
  setHeight(_: number);
  isHidden: boolean;
  setHidden(_: boolean);
  numberOfCells: number;
  rowAlignment: NSGridView.NSGridRow.Alignment;
  setRowAlignment(_: NSGridView.NSGridRow.Alignment);
  topPadding: number;
  setTopPadding(_: number);
  yPlacement: NSGridView.NSGridCell.Placement;
  setYPlacement(_: NSGridView.NSGridCell.Placement);
  cellAtIndex(at: number): NSGridCell;
  mergeCellsInRange(in_: NSRange): void;
}

export class NSGridView extends NSView {
  columnSpacing: number;
  setColumnSpacing(_: number);
  numberOfColumns: number;
  numberOfRows: number;
  rowAlignment: NSGridView.NSGridRow.Alignment;
  setRowAlignment(_: NSGridView.NSGridRow.Alignment);
  rowSpacing: number;
  setRowSpacing(_: number);
  xPlacement: NSGridView.NSGridCell.Placement;
  setXPlacement(_: NSGridView.NSGridCell.Placement);
  yPlacement: NSGridView.NSGridCell.Placement;
  setYPlacement(_: NSGridView.NSGridCell.Placement);
  addColumnWithViews(with_: NSView[]): NSGridColumn;
  addRowWithViews(with_: NSView[]): NSGridRow;
  cellAtColumnIndexRowIndex(atColumnIndex: number, rowIndex: number): NSGridCell;
  cellForView(for_: NSView): NSGridCell;
  columnAtIndex(at: number): NSGridColumn;
  indexOfColumn(of: NSGridColumn): number;
  indexOfRow(of: NSGridRow): number;
  insertColumnAtIndexWithViews(at: number, with_: NSView[]): NSGridColumn;
  insertRowAtIndexWithViews(at: number, with_: NSView[]): NSGridRow;
  mergeCellsInHorizontalRangeVerticalRange(inHorizontalRange: NSRange, verticalRange: NSRange): void;
  moveColumnAtIndexToIndex(at: number, to: number): void;
  moveRowAtIndexToIndex(at: number, to: number): void;
  removeColumnAtIndex(at: number): void;
  removeRowAtIndex(at: number): void;
  rowAtIndex(at: number): NSGridRow;
}

export class NSGroupTouchBarItem extends NSTouchBarItem {
  customizationLabel: string;
  setCustomizationLabel(_: string);
  effectiveCompressionOptions: NSUserInterfaceCompressionOptions;
  groupTouchBar: NSTouchBar;
  setGroupTouchBar(_: NSTouchBar);
  groupUserInterfaceLayoutDirection: NSUserInterfaceLayout.NSUserInterfaceLayoutDirection;
  setGroupUserInterfaceLayoutDirection(_: NSUserInterfaceLayout.NSUserInterfaceLayoutDirection);
  preferredItemWidth: number;
  setPreferredItemWidth(_: number);
  prefersEqualWidths: boolean;
  setPrefersEqualWidths(_: boolean);
  prioritizedCompressionOptions: NSUserInterfaceCompressionOptions[];
  setPrioritizedCompressionOptions(_: NSUserInterfaceCompressionOptions[]);
}

export class NSHapticFeedbackManager extends NSObject {
  static defaultPerformer: any;
}

interface NSHapticFeedbackPerformer {
  performFeedbackPatternPerformanceTime(_: NSHapticFeedback.NSHapticFeedbackManager.FeedbackPattern, performanceTime: NSHapticFeedback.NSHapticFeedbackManager.PerformanceTime): void;
}

export class NSHelpManager extends NSObject {
  static isContextHelpModeActive: boolean;
  setContextHelpModeActive(_: boolean);
  static sharedHelpManager: NSHelpManager;
  contextHelpForObject(for_: any): NSAttributedString;
  findStringInBook(_: string, inBook?: string): void;
  openHelpAnchorInBook(_: string, inBook?: string): void;
  registerBooksInBundle(in_: Bundle): boolean;
  removeContextHelpForObject(for_: any): void;
  setContextHelpForObject(_: NSAttributedString, for_: any): void;
  showContextHelpForObjectLocationHint(for_: any, locationHint: CGPoint): boolean;
}

interface NSIgnoreMisspelledWords {
  ignoreSpelling(_?: any): void;
}

export class NSImage extends NSObject {
  static canInitWithPasteboard(with_: NSPasteboard): boolean;
  TIFFRepresentation: Data;
  accessibilityDescription: string;
  setAccessibilityDescription(_: string);
  alignmentRect: CGRect;
  setAlignmentRect(_: CGRect);
  backgroundColor: NSColor;
  setBackgroundColor(_: NSColor);
  cacheMode: NSImage.CacheMode;
  setCacheMode(_: NSImage.CacheMode);
  capInsets: NSEdgeInsets;
  setCapInsets(_: NSEdgeInsets);
  delegate: any;
  setDelegate(_: any);
  matchesOnMultipleResolution: boolean;
  setMatchesOnMultipleResolution(_: boolean);
  matchesOnlyOnBestFittingAxis: boolean;
  setMatchesOnlyOnBestFittingAxis(_: boolean);
  prefersColorMatch: boolean;
  setPrefersColorMatch(_: boolean);
  representations: NSImageRep[];
  resizingMode: NSImage.ResizingMode;
  setResizingMode(_: NSImage.ResizingMode);
  size: CGSize;
  setSize(_: CGSize);
  isTemplate: boolean;
  setTemplate(_: boolean);
  usesEPSOnResolutionMismatch: boolean;
  setUsesEPSOnResolutionMismatch(_: boolean);
  isValid: boolean;
  static imageTypes: string[];
  static imageUnfilteredTypes: string[];
  cGImageForProposedRectContextHints(forProposedRect?: CGRect, context?: NSGraphicsContext, hints?: Map<string, any>): any;
  tIFFRepresentationUsingCompressionFactor(using: NSBitmapImageRep.TIFFCompression, factor: number): Data;
  addRepresentation(_: NSImageRep): void;
  addRepresentations(_: NSImageRep[]): void;
  bestRepresentationForRectContextHints(for_: CGRect, context?: NSGraphicsContext, hints?: Map<string, any>): NSImageRep;
  cancelIncrementalLoad(): void;
  drawAtPointFromRectOperationFraction(at: CGPoint, from: CGRect, operation: NSGraphics.NSCompositingOperation, fraction: number): void;
  drawInRect(in_: CGRect): void;
  drawInRectFromRectOperationFraction(in_: CGRect, from: CGRect, operation: NSGraphics.NSCompositingOperation, fraction: number): void;
  drawInRectFromRectOperationFractionRespectFlippedHints(in_: CGRect, from: CGRect, operation: NSGraphics.NSCompositingOperation, fraction: number, respectFlipped: boolean, hints?: Map<string, any>): void;
  drawRepresentationInRect(_: NSImageRep, in_: CGRect): boolean;
  hitTestRectWithImageDestinationRectContextHintsFlipped(_: CGRect, withDestinationRect: CGRect, context?: NSGraphicsContext, hints?: Map<string, any>, flipped?: boolean): boolean;
  static initByReferencingFile(_: string): NSImage;
  static initWithCGImageSize(_: any, size: CGSize): NSImage;
  static initWithContentsOfFile(_: string): NSImage;
  static initWithContentsOfURL(_: URL): NSImage;
  static initWithData(_: Data): NSImage;
  static initWithDataIgnoringOrientation(_: Data): NSImage;
  static initWithIconRef(_: any): NSImage;
  static initWithPasteboard(_: NSPasteboard): NSImage;
  static initWithSize(_: CGSize): NSImage;
  layerContentsForContentsScale(forContentsScale: number): any;
  lockFocus(): void;
  lockFocusFlipped(_: boolean): void;
  name(): string;
  recache(): void;
  recommendedLayerContentsScale(_: number): number;
  removeRepresentation(_: NSImageRep): void;
  setName(_?: string): boolean;
  unlockFocus(): void;
}

export class NSImageCell extends NSCell {
  imageAlignment: NSImageCell.NSImageAlignment;
  setImageAlignment(_: NSImageCell.NSImageAlignment);
  imageFrameStyle: NSImageCell.NSImageView.FrameStyle;
  setImageFrameStyle(_: NSImageCell.NSImageView.FrameStyle);
  imageScaling: NSCell.NSImageScaling;
  setImageScaling(_: NSCell.NSImageScaling);
}

interface NSImageDelegate {
  imageWillLoadRepresentation(_: NSImage, willLoadRepresentation: NSImageRep): void;
  imageDidLoadRepresentationHeader(_: NSImage, didLoadRepresentationHeader: NSImageRep): void;
  imageDidLoadPartOfRepresentationWithValidRows(_: NSImage, didLoadPartOfRepresentation: NSImageRep, withValidRows: number): void;
  imageDidLoadRepresentationWithStatus(_: NSImage, didLoadRepresentation: NSImageRep, with_: NSImage.LoadStatus): void;
  imageDidNotDrawInRect(_: NSImage, in_: CGRect): NSImage;
}

export class NSImageRep extends NSObject {
  static canInitWithData(with_: Data): boolean;
  static canInitWithPasteboard(with_: NSPasteboard): boolean;
  static imageRepClassForData(for_: Data): typeof NSObject;
  static imageRepClassForType(forType: string): typeof NSObject;
  static imageRepsWithContentsOfFile(withContentsOfFile: string): NSImageRep[];
  static imageRepsWithContentsOfURL(withContentsOf: URL): NSImageRep[];
  static imageRepsWithPasteboard(with_: NSPasteboard): NSImageRep[];
  static registerImageRepClass(_: typeof NSObject): void;
  static unregisterImageRepClass(_: typeof NSObject): void;
  hasAlpha: boolean;
  setAlpha(_: boolean);
  bitsPerSample: number;
  setBitsPerSample(_: number);
  colorSpaceName: string;
  setColorSpaceName(_: string);
  layoutDirection: NSImageRep.NSImage.LayoutDirection;
  setLayoutDirection(_: NSImageRep.NSImage.LayoutDirection);
  isOpaque: boolean;
  setOpaque(_: boolean);
  pixelsHigh: number;
  setPixelsHigh(_: number);
  pixelsWide: number;
  setPixelsWide(_: number);
  size: CGSize;
  setSize(_: CGSize);
  static imageTypes: string[];
  static imageUnfilteredTypes: string[];
  static registeredImageRepClasses: typeof NSObject[];
  cGImageForProposedRectContextHints(forProposedRect?: CGRect, context?: NSGraphicsContext, hints?: Map<string, any>): any;
  draw(): boolean;
  drawAtPoint(at: CGPoint): boolean;
  drawInRect(in_: CGRect): boolean;
  drawInRectFromRectOperationFractionRespectFlippedHints(in_: CGRect, from: CGRect, operation: NSGraphics.NSCompositingOperation, fraction: number, respectFlipped: boolean, hints?: Map<string, any>): boolean;
}

export class NSImageView extends NSControl {
  allowsCutCopyPaste: boolean;
  setAllowsCutCopyPaste(_: boolean);
  animates: boolean;
  setAnimates(_: boolean);
  contentTintColor: NSColor;
  setContentTintColor(_: NSColor);
  isEditable: boolean;
  setEditable(_: boolean);
  image: NSImage;
  setImage(_: NSImage);
  imageAlignment: NSImageCell.NSImageAlignment;
  setImageAlignment(_: NSImageCell.NSImageAlignment);
  imageFrameStyle: NSImageCell.NSImageView.FrameStyle;
  setImageFrameStyle(_: NSImageCell.NSImageView.FrameStyle);
  imageScaling: NSCell.NSImageScaling;
  setImageScaling(_: NSCell.NSImageScaling);
}

interface NSInputServerMouseTracker {
}

interface NSInputServiceProvider {
}

// export function NSIsControllerMarker(object_: any): boolean;

export class NSLayoutAnchor<AnchorType> extends NSObject {
  constraintsAffectingLayout: NSLayoutConstraint[];
  hasAmbiguousLayout: boolean;
  item: any;
  name: string;
  constraintEqualToAnchor(equalTo: NSLayoutAnchor<any>): NSLayoutConstraint;
  constraintEqualToAnchorConstant(equalTo: NSLayoutAnchor<any>, constant: number): NSLayoutConstraint;
  constraintGreaterThanOrEqualToAnchor(greaterThanOrEqualTo: NSLayoutAnchor<any>): NSLayoutConstraint;
  constraintGreaterThanOrEqualToAnchorConstant(greaterThanOrEqualTo: NSLayoutAnchor<any>, constant: number): NSLayoutConstraint;
  constraintLessThanOrEqualToAnchor(lessThanOrEqualTo: NSLayoutAnchor<any>): NSLayoutConstraint;
  constraintLessThanOrEqualToAnchorConstant(lessThanOrEqualTo: NSLayoutAnchor<any>, constant: number): NSLayoutConstraint;
}

export class NSLayoutConstraint extends NSObject {
  static activateConstraints(_: NSLayoutConstraint[]): void;
  static constraintsWithVisualFormatOptionsMetricsViews(withVisualFormat: string, options: NSLayoutConstraint.FormatOptions, metrics?: Map<string, any>, views?: Map<string, any>): NSLayoutConstraint[];
  static deactivateConstraints(_: NSLayoutConstraint[]): void;
  isActive: boolean;
  setActive(_: boolean);
  constant: number;
  setConstant(_: number);
  firstAnchor: NSLayoutAnchor<any>;
  firstAttribute: NSLayoutConstraint.Attribute;
  firstItem: any;
  identifier: string;
  setIdentifier(_: string);
  multiplier: number;
  priority: number;
  setPriority(_: number);
  relation: NSLayoutConstraint.Relation;
  secondAnchor: NSLayoutAnchor<any>;
  secondAttribute: NSLayoutConstraint.Attribute;
  secondItem: any;
  shouldBeArchived: boolean;
  setShouldBeArchived(_: boolean);
}

export class NSLayoutDimension extends NSLayoutAnchor<NSLayoutDimension> {
  constraintEqualToAnchorMultiplier(equalTo: NSLayoutDimension, multiplier: number): NSLayoutConstraint;
  constraintEqualToAnchorMultiplierConstant(equalTo: NSLayoutDimension, multiplier: number, constant: number): NSLayoutConstraint;
  constraintEqualToConstant(equalToConstant: number): NSLayoutConstraint;
  constraintGreaterThanOrEqualToAnchorMultiplier(greaterThanOrEqualTo: NSLayoutDimension, multiplier: number): NSLayoutConstraint;
  constraintGreaterThanOrEqualToAnchorMultiplierConstant(greaterThanOrEqualTo: NSLayoutDimension, multiplier: number, constant: number): NSLayoutConstraint;
  constraintGreaterThanOrEqualToConstant(greaterThanOrEqualToConstant: number): NSLayoutConstraint;
  constraintLessThanOrEqualToAnchorMultiplier(lessThanOrEqualTo: NSLayoutDimension, multiplier: number): NSLayoutConstraint;
  constraintLessThanOrEqualToAnchorMultiplierConstant(lessThanOrEqualTo: NSLayoutDimension, multiplier: number, constant: number): NSLayoutConstraint;
  constraintLessThanOrEqualToConstant(lessThanOrEqualToConstant: number): NSLayoutConstraint;
}

export class NSLayoutGuide extends NSObject implements NSUserInterfaceItemIdentification {
  bottomAnchor: NSLayoutYAxisAnchor;
  centerXAnchor: NSLayoutXAxisAnchor;
  centerYAnchor: NSLayoutYAxisAnchor;
  frame: CGRect;
  hasAmbiguousLayout: boolean;
  heightAnchor: NSLayoutDimension;
  leadingAnchor: NSLayoutXAxisAnchor;
  leftAnchor: NSLayoutXAxisAnchor;
  owningView: NSView;
  setOwningView(_: NSView);
  rightAnchor: NSLayoutXAxisAnchor;
  topAnchor: NSLayoutYAxisAnchor;
  trailingAnchor: NSLayoutXAxisAnchor;
  widthAnchor: NSLayoutDimension;
  identifier: string;
  setIdentifier(_: string);
  constraintsAffectingLayoutForOrientation(for_: NSLayoutConstraint.Orientation): NSLayoutConstraint[];
}

export class NSLayoutManager extends NSObject {
  allowsNonContiguousLayout: boolean;
  setAllowsNonContiguousLayout(_: boolean);
  backgroundLayoutEnabled: boolean;
  setBackgroundLayoutEnabled(_: boolean);
  defaultAttachmentScaling: NSCell.NSImageScaling;
  setDefaultAttachmentScaling(_: NSCell.NSImageScaling);
  delegate: any;
  setDelegate(_: any);
  extraLineFragmentRect: CGRect;
  extraLineFragmentTextContainer: NSTextContainer;
  extraLineFragmentUsedRect: CGRect;
  firstTextView: NSTextView;
  glyphGenerator: NSGlyphGenerator;
  setGlyphGenerator(_: NSGlyphGenerator);
  hasNonContiguousLayout: boolean;
  limitsLayoutForSuspiciousContents: boolean;
  setLimitsLayoutForSuspiciousContents(_: boolean);
  numberOfGlyphs: number;
  showsControlCharacters: boolean;
  setShowsControlCharacters(_: boolean);
  showsInvisibleCharacters: boolean;
  setShowsInvisibleCharacters(_: boolean);
  textContainers: NSTextContainer[];
  textStorage: NSTextStorage;
  setTextStorage(_: NSTextStorage);
  textViewForBeginningOfSelection: NSTextView;
  typesetter: NSTypesetter;
  setTypesetter(_: NSTypesetter);
  typesetterBehavior: NSLayoutManager.TypesetterBehavior;
  setTypesetterBehavior(_: NSLayoutManager.TypesetterBehavior);
  usesDefaultHyphenation: boolean;
  setUsesDefaultHyphenation(_: boolean);
  usesFontLeading: boolean;
  setUsesFontLeading(_: boolean);
  cGGlyphAtIndex(at: number): number;
  cGGlyphAtIndexIsValidIndex(at: number, isValidIndex?: boolean): number;
  addTemporaryAttributeValueForCharacterRange(_: string, value: any, forCharacterRange: NSRange): void;
  addTemporaryAttributesForCharacterRange(_: Map<string, any>, forCharacterRange: NSRange): void;
  addTextContainer(_: NSTextContainer): void;
  attachmentSizeForGlyphAtIndex(forGlyphAt: number): CGSize;
  boundingRectForGlyphRangeInTextContainer(forGlyphRange: NSRange, in_: NSTextContainer): CGRect;
  boundsRectForTextBlockAtIndexEffectiveRange(for_: NSTextBlock, at: number, effectiveRange?: NSRange): CGRect;
  boundsRectForTextBlockGlyphRange(for_: NSTextBlock, glyphRange: NSRange): CGRect;
  characterIndexForGlyphAtIndex(at: number): number;
  characterIndexForPointInTextContainerFractionOfDistanceBetweenInsertionPoints(for_: CGPoint, in_: NSTextContainer, fractionOfDistanceBetweenInsertionPoints?: number): number;
  characterRangeForGlyphRangeActualGlyphRange(forGlyphRange: NSRange, actualGlyphRange?: NSRange): NSRange;
  defaultBaselineOffsetForFont(for_: NSFont): number;
  defaultLineHeightForFont(for_: NSFont): number;
  drawBackgroundForGlyphRangeAtPoint(forGlyphRange: NSRange, at: CGPoint): void;
  drawGlyphsForGlyphRangeAtPoint(forGlyphRange: NSRange, at: CGPoint): void;
  drawStrikethroughForGlyphRangeStrikethroughTypeBaselineOffsetLineFragmentRectLineFragmentGlyphRangeContainerOrigin(forGlyphRange: NSRange, strikethroughType: NSAttributedString.NSUnderlineStyle, baselineOffset: number, lineFragmentRect: CGRect, lineFragmentGlyphRange: NSRange, containerOrigin: CGPoint): void;
  drawUnderlineForGlyphRangeUnderlineTypeBaselineOffsetLineFragmentRectLineFragmentGlyphRangeContainerOrigin(forGlyphRange: NSRange, underlineType: NSAttributedString.NSUnderlineStyle, baselineOffset: number, lineFragmentRect: CGRect, lineFragmentGlyphRange: NSRange, containerOrigin: CGPoint): void;
  drawsOutsideLineFragmentForGlyphAtIndex(forGlyphAt: number): boolean;
  ensureGlyphsForCharacterRange(forCharacterRange: NSRange): void;
  ensureGlyphsForGlyphRange(forGlyphRange: NSRange): void;
  ensureLayoutForBoundingRectInTextContainer(forBoundingRect: CGRect, in_: NSTextContainer): void;
  ensureLayoutForCharacterRange(forCharacterRange: NSRange): void;
  ensureLayoutForGlyphRange(forGlyphRange: NSRange): void;
  ensureLayoutForTextContainer(for_: NSTextContainer): void;
  enumerateEnclosingRectsForGlyphRangeWithinSelectedGlyphRangeInTextContainerUsingBlock(forGlyphRange: NSRange, withinSelectedGlyphRange: NSRange, in_: NSTextContainer, using: (p1: CGRect, p2: boolean) => void): void;
  enumerateLineFragmentsForGlyphRangeUsingBlock(forGlyphRange: NSRange, using: (p1: CGRect, p2: CGRect, p3: NSTextContainer, p4: NSRange, p5: boolean) => void): void;
  fillBackgroundRectArrayCountForCharacterRangeColor(_: CGRect, count: number, forCharacterRange: NSRange, color: NSColor): void;
  firstUnlaidCharacterIndex(): number;
  firstUnlaidGlyphIndex(): number;
  fractionOfDistanceThroughGlyphForPointInTextContainer(for_: CGPoint, in_: NSTextContainer): number;
  getFirstUnlaidCharacterIndexGlyphIndex(_?: number, glyphIndex?: number): void;
  getGlyphsInRangeGlyphsPropertiesCharacterIndexesBidiLevels(in_: NSRange, glyphs?: number, properties?: NSLayoutManager.GlyphProperty, characterIndexes?: number, bidiLevels?: string): number;
  getLineFragmentInsertionPointsForCharacterAtIndexAlternatePositionsInDisplayOrderPositionsCharacterIndexes(forCharacterAt: number, alternatePositions: boolean, inDisplayOrder: boolean, positions?: number, characterIndexes?: number): number;
  glyphAtIndex(at: number): number;
  glyphAtIndexIsValidIndex(at: number, isValidIndex?: boolean): number;
  glyphIndexForCharacterAtIndex(at: number): number;
  glyphIndexForPointInTextContainer(for_: CGPoint, in_: NSTextContainer): number;
  glyphIndexForPointInTextContainerFractionOfDistanceThroughGlyph(for_: CGPoint, in_: NSTextContainer, fractionOfDistanceThroughGlyph?: number): number;
  glyphRangeForBoundingRectInTextContainer(forBoundingRect: CGRect, in_: NSTextContainer): NSRange;
  glyphRangeForBoundingRectWithoutAdditionalLayoutInTextContainer(forBoundingRectWithoutAdditionalLayout: CGRect, in_: NSTextContainer): NSRange;
  glyphRangeForCharacterRangeActualCharacterRange(forCharacterRange: NSRange, actualCharacterRange?: NSRange): NSRange;
  glyphRangeForTextContainer(for_: NSTextContainer): NSRange;
  insertTextContainerAtIndex(_: NSTextContainer, at: number): void;
  invalidateDisplayForCharacterRange(forCharacterRange: NSRange): void;
  invalidateDisplayForGlyphRange(forGlyphRange: NSRange): void;
  invalidateGlyphsForCharacterRangeChangeInLengthActualCharacterRange(forCharacterRange: NSRange, changeInLength: number, actualCharacterRange?: NSRange): void;
  invalidateLayoutForCharacterRangeActualCharacterRange(forCharacterRange: NSRange, actualCharacterRange?: NSRange): void;
  isValidGlyphIndex(_: number): boolean;
  layoutManagerOwnsFirstResponderInWindow(in_: NSWindow): boolean;
  layoutRectForTextBlockAtIndexEffectiveRange(for_: NSTextBlock, at: number, effectiveRange?: NSRange): CGRect;
  layoutRectForTextBlockGlyphRange(for_: NSTextBlock, glyphRange: NSRange): CGRect;
  lineFragmentRectForGlyphAtIndexEffectiveRange(forGlyphAt: number, effectiveRange?: NSRange): CGRect;
  lineFragmentRectForGlyphAtIndexEffectiveRangeWithoutAdditionalLayout(forGlyphAt: number, effectiveRange?: NSRange, withoutAdditionalLayout?: boolean): CGRect;
  lineFragmentUsedRectForGlyphAtIndexEffectiveRange(forGlyphAt: number, effectiveRange?: NSRange): CGRect;
  lineFragmentUsedRectForGlyphAtIndexEffectiveRangeWithoutAdditionalLayout(forGlyphAt: number, effectiveRange?: NSRange, withoutAdditionalLayout?: boolean): CGRect;
  locationForGlyphAtIndex(forGlyphAt: number): CGPoint;
  notShownAttributeForGlyphAtIndex(forGlyphAt: number): boolean;
  processEditingForTextStorageEditedRangeChangeInLengthInvalidatedRange(for_: NSTextStorage, edited: NSTextStorage.NSTextStorageEditActions, range: NSRange, changeInLength: number, invalidatedRange: NSRange): void;
  propertyForGlyphAtIndex(at: number): NSLayoutManager.GlyphProperty;
  rangeOfNominallySpacedGlyphsContainingIndex(ofNominallySpacedGlyphsContaining: number): NSRange;
  rectArrayForCharacterRangeWithinSelectedCharacterRangeInTextContainerRectCount(forCharacterRange: NSRange, withinSelectedCharacterRange: NSRange, in_: NSTextContainer, rectCount: number): CGRect;
  rectArrayForGlyphRangeWithinSelectedGlyphRangeInTextContainerRectCount(forGlyphRange: NSRange, withinSelectedGlyphRange: NSRange, in_: NSTextContainer, rectCount: number): CGRect;
  removeTemporaryAttributeForCharacterRange(_: string, forCharacterRange: NSRange): void;
  removeTextContainerAtIndex(at: number): void;
  replaceTextStorage(_: NSTextStorage): void;
  rulerAccessoryViewForTextViewParagraphStyleRulerEnabled(for_: NSTextView, paragraphStyle: NSParagraphStyle, ruler: NSRulerView, enabled: boolean): NSView;
  rulerMarkersForTextViewParagraphStyleRuler(for_: NSTextView, paragraphStyle: NSParagraphStyle, ruler: NSRulerView): NSRulerMarker[];
  setAttachmentSizeForGlyphRange(_: CGSize, forGlyphRange: NSRange): void;
  setBoundsRectForTextBlockGlyphRange(_: CGRect, for_: NSTextBlock, glyphRange: NSRange): void;
  setDrawsOutsideLineFragmentForGlyphAtIndex(_: boolean, forGlyphAt: number): void;
  setExtraLineFragmentRectUsedRectTextContainer(_: CGRect, usedRect: CGRect, textContainer: NSTextContainer): void;
  setGlyphsPropertiesCharacterIndexesFontForGlyphRange(_: number, properties: NSLayoutManager.GlyphProperty, characterIndexes: number, font: NSFont, forGlyphRange: NSRange): void;
  setLayoutRectForTextBlockGlyphRange(_: CGRect, for_: NSTextBlock, glyphRange: NSRange): void;
  setLineFragmentRectForGlyphRangeUsedRect(_: CGRect, forGlyphRange: NSRange, usedRect: CGRect): void;
  setLocationForStartOfGlyphRange(_: CGPoint, forStartOfGlyphRange: NSRange): void;
  setNotShownAttributeForGlyphAtIndex(_: boolean, forGlyphAt: number): void;
  setTemporaryAttributesForCharacterRange(_: Map<string, any>, forCharacterRange: NSRange): void;
  setTextContainerForGlyphRange(_: NSTextContainer, forGlyphRange: NSRange): void;
  showAttachmentCellInRectCharacterIndex(_: NSCell, in_: CGRect, characterIndex: number): void;
  showCGGlyphsPositionsCountFontTextMatrixAttributesInContext(_: number, positions: CGPoint, count: number, font: NSFont, textMatrix: CGAffineTransform, attributes: Map<string, any>, in_: any): void;
  strikethroughGlyphRangeStrikethroughTypeLineFragmentRectLineFragmentGlyphRangeContainerOrigin(_: NSRange, strikethroughType: NSAttributedString.NSUnderlineStyle, lineFragmentRect: CGRect, lineFragmentGlyphRange: NSRange, containerOrigin: CGPoint): void;
  temporaryAttributeAtCharacterIndexEffectiveRange(_: string, atCharacterIndex: number, effectiveRange?: NSRange): any;
  temporaryAttributeAtCharacterIndexLongestEffectiveRangeInRange(_: string, atCharacterIndex: number, longestEffectiveRange?: NSRange, in_?: NSRange): any;
  temporaryAttributesAtCharacterIndexEffectiveRange(atCharacterIndex: number, effectiveRange?: NSRange): Map<string, any>;
  temporaryAttributesAtCharacterIndexLongestEffectiveRangeInRange(atCharacterIndex: number, longestEffectiveRange?: NSRange, in_?: NSRange): Map<string, any>;
  textContainerChangedGeometry(_: NSTextContainer): void;
  textContainerChangedTextView(_: NSTextContainer): void;
  textContainerForGlyphAtIndexEffectiveRange(forGlyphAt: number, effectiveRange?: NSRange): NSTextContainer;
  textContainerForGlyphAtIndexEffectiveRangeWithoutAdditionalLayout(forGlyphAt: number, effectiveRange?: NSRange, withoutAdditionalLayout?: boolean): NSTextContainer;
  truncatedGlyphRangeInLineFragmentForGlyphAtIndex(inLineFragmentForGlyphAt: number): NSRange;
  underlineGlyphRangeUnderlineTypeLineFragmentRectLineFragmentGlyphRangeContainerOrigin(_: NSRange, underlineType: NSAttributedString.NSUnderlineStyle, lineFragmentRect: CGRect, lineFragmentGlyphRange: NSRange, containerOrigin: CGPoint): void;
  usedRectForTextContainer(for_: NSTextContainer): CGRect;
}

interface NSLayoutManagerDelegate {
  layoutManagerShouldGenerateGlyphsPropertiesCharacterIndexesFontForGlyphRange(_: NSLayoutManager, shouldGenerateGlyphs: number, properties: NSLayoutManager.GlyphProperty, characterIndexes: number, font: NSFont, forGlyphRange: NSRange): number;
  layoutManagerLineSpacingAfterGlyphAtIndexWithProposedLineFragmentRect(_: NSLayoutManager, lineSpacingAfterGlyphAt: number, withProposedLineFragmentRect: CGRect): number;
  layoutManagerParagraphSpacingBeforeGlyphAtIndexWithProposedLineFragmentRect(_: NSLayoutManager, paragraphSpacingBeforeGlyphAt: number, withProposedLineFragmentRect: CGRect): number;
  layoutManagerParagraphSpacingAfterGlyphAtIndexWithProposedLineFragmentRect(_: NSLayoutManager, paragraphSpacingAfterGlyphAt: number, withProposedLineFragmentRect: CGRect): number;
  layoutManagerShouldUseActionForControlCharacterAtIndex(_: NSLayoutManager, shouldUse: NSLayoutManager.ControlCharacterAction, forControlCharacterAt: number): NSLayoutManager.ControlCharacterAction;
  layoutManagerShouldBreakLineByWordBeforeCharacterAtIndex(_: NSLayoutManager, shouldBreakLineByWordBeforeCharacterAt: number): boolean;
  layoutManagerShouldBreakLineByHyphenatingBeforeCharacterAtIndex(_: NSLayoutManager, shouldBreakLineByHyphenatingBeforeCharacterAt: number): boolean;
  layoutManagerBoundingBoxForControlGlyphAtIndexForTextContainerProposedLineFragmentGlyphPositionCharacterIndex(_: NSLayoutManager, boundingBoxForControlGlyphAt: number, for_: NSTextContainer, proposedLineFragment: CGRect, glyphPosition: CGPoint, characterIndex: number): CGRect;
  layoutManagerShouldSetLineFragmentRectLineFragmentUsedRectBaselineOffsetInTextContainerForGlyphRange(_: NSLayoutManager, shouldSetLineFragmentRect: CGRect, lineFragmentUsedRect: CGRect, baselineOffset: number, in_: NSTextContainer, forGlyphRange: NSRange): boolean;
  layoutManagerDidCompleteLayoutForTextContainerAtEnd(_: NSLayoutManager, didCompleteLayoutFor?: NSTextContainer, atEnd?: boolean): void;
  layoutManagerTextContainerDidChangeGeometryFromSize(_: NSLayoutManager, textContainer: NSTextContainer, didChangeGeometryFrom: CGSize): void;
  layoutManagerShouldUseTemporaryAttributesForDrawingToScreenAtCharacterIndexEffectiveRange(_: NSLayoutManager, shouldUseTemporaryAttributes: Map<string, any>, forDrawingToScreen: boolean, atCharacterIndex: number, effectiveRange?: NSRange): Map<string, any>;
  layoutManagerDidInvalidateLayout(_: NSLayoutManager): void;
}

export class NSLayoutXAxisAnchor extends NSLayoutAnchor<NSLayoutXAxisAnchor> {
  anchorWithOffsetToAnchor(to: NSLayoutXAxisAnchor): NSLayoutDimension;
}

export class NSLayoutYAxisAnchor extends NSLayoutAnchor<NSLayoutYAxisAnchor> {
  anchorWithOffsetToAnchor(to: NSLayoutYAxisAnchor): NSLayoutDimension;
}

export class NSLevelIndicator extends NSControl {
  criticalFillColor: NSColor;
  setCriticalFillColor(_: NSColor);
  criticalValue: number;
  setCriticalValue(_: number);
  drawsTieredCapacityLevels: boolean;
  setDrawsTieredCapacityLevels(_: boolean);
  isEditable: boolean;
  setEditable(_: boolean);
  fillColor: NSColor;
  setFillColor(_: NSColor);
  levelIndicatorStyle: NSLevelIndicatorCell.NSLevelIndicator.Style;
  setLevelIndicatorStyle(_: NSLevelIndicatorCell.NSLevelIndicator.Style);
  maxValue: number;
  setMaxValue(_: number);
  minValue: number;
  setMinValue(_: number);
  numberOfMajorTickMarks: number;
  setNumberOfMajorTickMarks(_: number);
  numberOfTickMarks: number;
  setNumberOfTickMarks(_: number);
  placeholderVisibility: NSLevelIndicator.PlaceholderVisibility;
  setPlaceholderVisibility(_: NSLevelIndicator.PlaceholderVisibility);
  ratingImage: NSImage;
  setRatingImage(_: NSImage);
  ratingPlaceholderImage: NSImage;
  setRatingPlaceholderImage(_: NSImage);
  tickMarkPosition: NSSliderCell.NSSlider.TickMarkPosition;
  setTickMarkPosition(_: NSSliderCell.NSSlider.TickMarkPosition);
  warningFillColor: NSColor;
  setWarningFillColor(_: NSColor);
  warningValue: number;
  setWarningValue(_: number);
  rectOfTickMarkAtIndex(at: number): CGRect;
  tickMarkValueAtIndex(at: number): number;
}

export class NSLevelIndicatorCell extends NSActionCell {
  criticalValue: number;
  setCriticalValue(_: number);
  levelIndicatorStyle: NSLevelIndicatorCell.NSLevelIndicator.Style;
  setLevelIndicatorStyle(_: NSLevelIndicatorCell.NSLevelIndicator.Style);
  maxValue: number;
  setMaxValue(_: number);
  minValue: number;
  setMinValue(_: number);
  numberOfMajorTickMarks: number;
  setNumberOfMajorTickMarks(_: number);
  numberOfTickMarks: number;
  setNumberOfTickMarks(_: number);
  tickMarkPosition: NSSliderCell.NSSlider.TickMarkPosition;
  setTickMarkPosition(_: NSSliderCell.NSSlider.TickMarkPosition);
  warningValue: number;
  setWarningValue(_: number);
  static initWithLevelIndicatorStyle(_: NSLevelIndicatorCell.NSLevelIndicator.Style): NSLevelIndicatorCell;
  rectOfTickMarkAtIndex(at: number): CGRect;
  tickMarkValueAtIndex(at: number): number;
}

export class NSMagnificationGestureRecognizer extends NSGestureRecognizer {
  magnification: number;
  setMagnification(_: number);
}

export class NSMatrix extends NSControl {
  allowsEmptySelection: boolean;
  setAllowsEmptySelection(_: boolean);
  autorecalculatesCellSize: boolean;
  setAutorecalculatesCellSize(_: boolean);
  autosizesCells: boolean;
  setAutosizesCells(_: boolean);
  backgroundColor: NSColor;
  setBackgroundColor(_: NSColor);
  cellBackgroundColor: NSColor;
  setCellBackgroundColor(_: NSColor);
  cellClass: typeof NSObject;
  setCellClass(_: typeof NSObject);
  cellSize: CGSize;
  setCellSize(_: CGSize);
  cells: NSCell[];
  delegate: any;
  setDelegate(_: any);
  doubleAction: string;
  setDoubleAction(_: string);
  drawsBackground: boolean;
  setDrawsBackground(_: boolean);
  drawsCellBackground: boolean;
  setDrawsCellBackground(_: boolean);
  intercellSpacing: CGSize;
  setIntercellSpacing(_: CGSize);
  keyCell: NSCell;
  setKeyCell(_: NSCell);
  mode: NSMatrix.Mode;
  setMode(_: NSMatrix.Mode);
  mouseDownFlags: number;
  numberOfColumns: number;
  numberOfRows: number;
  prototype: NSCell;
  setPrototype(_: NSCell);
  selectedCells: NSCell[];
  selectedColumn: number;
  selectedRow: number;
  isSelectionByRect: boolean;
  setSelectionByRect(_: boolean);
  tabKeyTraversesCells: boolean;
  setTabKeyTraversesCells(_: boolean);
  addColumn(): void;
  addColumnWithCells(with_: NSCell[]): void;
  addRow(): void;
  addRowWithCells(with_: NSCell[]): void;
  cellFrameAtRowColumn(atRow: number, column: number): CGRect;
  deselectAllCells(): void;
  deselectSelectedCell(): void;
  drawCellAtRowColumn(atRow: number, column: number): void;
  getNumberOfRowsColumns(_?: number, columns?: number): void;
  getRowColumnForPoint(_: number, column: number, for_: CGPoint): boolean;
  getRowColumnOfCell(_: number, column: number, of: NSCell): boolean;
  highlightCellAtRowColumn(_: boolean, atRow: number, column: number): void;
  static initWithFrameModeCellClassNumberOfRowsNumberOfColumns(_: CGRect, mode: NSMatrix.Mode, cellClass?: typeof NSObject, numberOfRows?: number, numberOfColumns?: number): NSMatrix;
  static initWithFrameModePrototypeNumberOfRowsNumberOfColumns(_: CGRect, mode: NSMatrix.Mode, prototype: NSCell, numberOfRows: number, numberOfColumns: number): NSMatrix;
  insertColumn(_: number): void;
  insertColumnWithCells(_: number, with_?: NSCell[]): void;
  insertRow(_: number): void;
  insertRowWithCells(_: number, with_?: NSCell[]): void;
  makeCellAtRowColumn(atRow: number, column: number): NSCell;
  putCellAtRowColumn(_: NSCell, atRow: number, column: number): void;
  removeColumn(_: number): void;
  removeRow(_: number): void;
  renewRowsColumns(_: number, columns: number): void;
  scrollCellToVisibleAtRowColumn(atRow: number, column: number): void;
  selectCellAtRowColumn(atRow: number, column: number): void;
  selectCellWithTag(withTag: number): boolean;
  selectText(_?: any): void;
  selectTextAtRowColumn(atRow: number, column: number): NSCell;
  sendAction(): boolean;
  sendActionToForAllCells(_: string, to: any, forAllCells: boolean): void;
  sendDoubleAction(): void;
  setScrollable(_: boolean): void;
  setSelectionFromToAnchorHighlight(_: number, to: number, anchor: number, highlight: boolean): void;
  setStateAtRowColumn(_: number, atRow: number, column: number): void;
  setToolTipForCell(_?: string, for_?: NSCell): void;
  setValidateSize(_: boolean): void;
  sizeToCells(): void;
  sortUsingFunctionContext(using?: (p1: any, p2: any, p3: any) => number, context?: any): void;
  sortUsingSelector(using: string): void;
  textDidBeginEditing(_: Notification): void;
  textDidChange(_: Notification): void;
  textDidEndEditing(_: Notification): void;
  textShouldBeginEditing(_: NSText): boolean;
  textShouldEndEditing(_: NSText): boolean;
}

interface NSMatrixDelegate {
}

export class NSMediaLibraryBrowserController extends NSObject {
  frame: CGRect;
  setFrame(_: CGRect);
  mediaLibraries: NSMediaLibraryBrowserController.Library;
  setMediaLibraries(_: NSMediaLibraryBrowserController.Library);
  isVisible: boolean;
  setVisible(_: boolean);
  static sharedMediaLibraryBrowserController: NSMediaLibraryBrowserController;
  togglePanel(_?: any): void;
}

export class NSMenu extends NSObject implements NSUserInterfaceItemIdentification {
  static menuBarVisible(): boolean;
  static popUpContextMenuWithEventForView(_: NSMenu, with_: NSEvent, for_: NSView): void;
  static popUpContextMenuWithEventForViewWithFont(_: NSMenu, with_: NSEvent, for_: NSView, with_2?: NSFont): void;
  static setMenuBarVisible(_: boolean): void;
  allowsContextMenuPlugIns: boolean;
  setAllowsContextMenuPlugIns(_: boolean);
  autoenablesItems: boolean;
  setAutoenablesItems(_: boolean);
  delegate: any;
  setDelegate(_: any);
  font: NSFont;
  setFont(_: NSFont);
  highlightedItem: NSMenuItem;
  itemArray: NSMenuItem[];
  setItemArray(_: NSMenuItem[]);
  menuBarHeight: number;
  minimumWidth: number;
  setMinimumWidth(_: number);
  numberOfItems: number;
  propertiesToUpdate: NSMenu.Properties;
  showsStateColumn: boolean;
  setShowsStateColumn(_: boolean);
  size: CGSize;
  supermenu: NSMenu;
  setSupermenu(_: NSMenu);
  title: string;
  setTitle(_: string);
  userInterfaceLayoutDirection: NSUserInterfaceLayout.NSUserInterfaceLayoutDirection;
  setUserInterfaceLayoutDirection(_: NSUserInterfaceLayout.NSUserInterfaceLayoutDirection);
  identifier: string;
  setIdentifier(_: string);
  addItem(_: NSMenuItem): void;
  addItemWithTitleActionKeyEquivalent(withTitle: string, action?: string, keyEquivalent?: string): NSMenuItem;
  cancelTracking(): void;
  cancelTrackingWithoutAnimation(): void;
  indexOfItem(of: NSMenuItem): number;
  indexOfItemWithRepresentedObject(withRepresentedObject?: any): number;
  indexOfItemWithSubmenu(withSubmenu?: NSMenu): number;
  indexOfItemWithTag(withTag: number): number;
  indexOfItemWithTargetAndAction(withTarget?: any, andAction?: string): number;
  indexOfItemWithTitle(withTitle: string): number;
  static initWithTitle(_: string): NSMenu;
  insertItemAtIndex(_: NSMenuItem, at: number): void;
  insertItemWithTitleActionKeyEquivalentAtIndex(withTitle: string, action?: string, keyEquivalent?: string, at?: number): NSMenuItem;
  itemAtIndex(at: number): NSMenuItem;
  itemChanged(_: NSMenuItem): void;
  itemWithTag(withTag: number): NSMenuItem;
  itemWithTitle(withTitle: string): NSMenuItem;
  performActionForItemAtIndex(at: number): void;
  performKeyEquivalent(with_: NSEvent): boolean;
  popUpMenuPositioningItemAtLocationInView(positioning?: NSMenuItem, at?: CGPoint, in_?: NSView): boolean;
  removeAllItems(): void;
  removeItem(_: NSMenuItem): void;
  removeItemAtIndex(at: number): void;
  setSubmenuForItem(_?: NSMenu, for_?: NSMenuItem): void;
  submenuAction(_?: any): void;
  update(): void;
}

interface NSMenuDelegate {
  confinementRectForMenuOnScreen(for_: NSMenu, on?: NSScreen): CGRect;
  menuUpdateItemAtIndexShouldCancel(_: NSMenu, update: NSMenuItem, at: number, shouldCancel: boolean): boolean;
  menuWillHighlightItem(_: NSMenu, willHighlight?: NSMenuItem): void;
  menuDidClose(_: NSMenu): void;
  menuHasKeyEquivalentForEventTargetAction(_: NSMenu, for_: NSEvent, target?: any, action?: string): boolean;
  menuNeedsUpdate(_: NSMenu): void;
  menuWillOpen(_: NSMenu): void;
  numberOfItemsInMenu(in_: NSMenu): number;
}

export class NSMenuItem extends NSObject implements NSUserInterfaceItemIdentification {
  static separatorItem(): NSMenuItem;
  action: string;
  setAction(_: string);
  allowsKeyEquivalentWhenHidden: boolean;
  setAllowsKeyEquivalentWhenHidden(_: boolean);
  isAlternate: boolean;
  setAlternate(_: boolean);
  attributedTitle: NSAttributedString;
  setAttributedTitle(_: NSAttributedString);
  isEnabled: boolean;
  setEnabled(_: boolean);
  hasSubmenu: boolean;
  isHidden: boolean;
  setHidden(_: boolean);
  isHiddenOrHasHiddenAncestor: boolean;
  isHighlighted: boolean;
  image: NSImage;
  setImage(_: NSImage);
  indentationLevel: number;
  setIndentationLevel(_: number);
  keyEquivalent: string;
  setKeyEquivalent(_: string);
  keyEquivalentModifierMask: NSEvent.ModifierFlags;
  setKeyEquivalentModifierMask(_: NSEvent.ModifierFlags);
  menu: NSMenu;
  setMenu(_: NSMenu);
  mixedStateImage: NSImage;
  setMixedStateImage(_: NSImage);
  offStateImage: NSImage;
  setOffStateImage(_: NSImage);
  onStateImage: NSImage;
  setOnStateImage(_: NSImage);
  parentItem: NSMenuItem;
  representedObject: any;
  setRepresentedObject(_: any);
  //   isSeparatorItem: boolean;
  state: number;
  setState(_: number);
  submenu: NSMenu;
  setSubmenu(_: NSMenu);
  tag: number;
  setTag(_: number);
  target: any;
  setTarget(_: any);
  title: string;
  setTitle(_: string);
  toolTip: string;
  setToolTip(_: string);
  userKeyEquivalent: string;
  static usesUserKeyEquivalents: boolean;
  setUsesUserKeyEquivalents(_: boolean);
  identifier: string;
  setIdentifier(_: string);
  static initWithTitleActionKeyEquivalent(_: string, action?: string, keyEquivalent?: string): NSMenuItem;
}

export class NSMenuItemCell extends NSButtonCell {
  imageWidth: number;
  keyEquivalentWidth: number;
  menuItem: NSMenuItem;
  setMenuItem(_: NSMenuItem);
  needsDisplay: boolean;
  setNeedsDisplay(_: boolean);
  needsSizing: boolean;
  setNeedsSizing(_: boolean);
  stateImageWidth: number;
  titleWidth: number;
  calcSize(): void;
  drawBorderAndBackgroundWithFrameInView(withFrame: CGRect, in_: NSView): void;
  // drawImageWithFrameInView(withFrame: CGRect, in_: NSView): void;
  drawKeyEquivalentWithFrameInView(withFrame: CGRect, in_: NSView): void;
  drawSeparatorItemWithFrameInView(withFrame: CGRect, in_: NSView): void;
  drawStateImageWithFrameInView(withFrame: CGRect, in_: NSView): void;
  // drawTitleWithFrameInView(withFrame: CGRect, in_: NSView): void;
  keyEquivalentRectForBounds(forBounds: CGRect): CGRect;
  stateImageRectForBounds(forBounds: CGRect): CGRect;
}

interface NSMenuItemValidation {
  validateMenuItem(_: NSMenuItem): boolean;
}

export class NSMenuToolbarItem extends NSToolbarItem {
  menu: NSMenu;
  setMenu(_: NSMenu);
  showsIndicator: boolean;
  setShowsIndicator(_: boolean);
}

export class NSMutableFontCollection extends NSFontCollection {
  exclusionDescriptors: NSFontDescriptor[];
  setExclusionDescriptors(_: NSFontDescriptor[]);
  queryDescriptors: NSFontDescriptor[];
  setQueryDescriptors(_: NSFontDescriptor[]);
  static fontCollectionWithAllAvailableDescriptors: NSMutableFontCollection;
  addQueryForDescriptors(for_: NSFontDescriptor[]): void;
  removeQueryForDescriptors(for_: NSFontDescriptor[]): void;
}

export class NSMutableParagraphStyle extends NSParagraphStyle {
  alignment: NSText.NSTextAlignment;
  setAlignment(_: NSText.NSTextAlignment);
  allowsDefaultTighteningForTruncation: boolean;
  setAllowsDefaultTighteningForTruncation(_: boolean);
  baseWritingDirection: NSText.NSWritingDirection;
  setBaseWritingDirection(_: NSText.NSWritingDirection);
  defaultTabInterval: number;
  setDefaultTabInterval(_: number);
  firstLineHeadIndent: number;
  setFirstLineHeadIndent(_: number);
  headIndent: number;
  setHeadIndent(_: number);
  headerLevel: number;
  setHeaderLevel(_: number);
  hyphenationFactor: number;
  setHyphenationFactor(_: number);
  lineBreakMode: NSParagraphStyle.NSLineBreakMode;
  setLineBreakMode(_: NSParagraphStyle.NSLineBreakMode);
  lineHeightMultiple: number;
  setLineHeightMultiple(_: number);
  lineSpacing: number;
  setLineSpacing(_: number);
  maximumLineHeight: number;
  setMaximumLineHeight(_: number);
  minimumLineHeight: number;
  setMinimumLineHeight(_: number);
  paragraphSpacing: number;
  setParagraphSpacing(_: number);
  paragraphSpacingBefore: number;
  setParagraphSpacingBefore(_: number);
  tabStops: NSTextTab[];
  setTabStops(_: NSTextTab[]);
  tailIndent: number;
  setTailIndent(_: number);
  textBlocks: NSTextBlock[];
  setTextBlocks(_: NSTextBlock[]);
  textLists: NSTextList[];
  setTextLists(_: NSTextList[]);
  tighteningFactorForTruncation: number;
  setTighteningFactorForTruncation(_: number);
  addTabStop(_: NSTextTab): void;
  removeTabStop(_: NSTextTab): void;
  setParagraphStyle(_: NSParagraphStyle): void;
}

export class NSNib extends NSObject {
  static initWithNibDataBundle(_: Data, bundle?: Bundle): NSNib;
  static initWithNibNamedBundle(_: string, bundle?: Bundle): NSNib;
  instantiateWithOwnerTopLevelObjects(withOwner?: any, topLevelObjects?: any[]): boolean;
}

// export function NSNumberOfColorComponents(colorSpaceName: string): number;

export class NSObjectController extends NSController {
  automaticallyPreparesContent: boolean;
  setAutomaticallyPreparesContent(_: boolean);
  canAdd: boolean;
  canRemove: boolean;
  content: any;
  setContent(_: any);
  isEditable: boolean;
  setEditable(_: boolean);
  entityName: string;
  setEntityName(_: string);
  fetchPredicate: NSPredicate;
  setFetchPredicate(_: NSPredicate);
  managedObjectContext: NSManagedObjectContext;
  setManagedObjectContext(_: NSManagedObjectContext);
  objectClass: typeof NSObject;
  setObjectClass(_: typeof NSObject);
  selectedObjects: any[];
  selection: any;
  usesLazyFetching: boolean;
  setUsesLazyFetching(_: boolean);
  add(_?: any): void;
  addObject(_: any): void;
  defaultFetchRequest(): NSFetchRequest<any>;
  fetch(_?: any): void;
  fetchWithRequestMerge(merge?: NSFetchRequest<any>, error?: boolean): boolean;
  static initWithContent(_?: any): NSObjectController;
  newObject(): any;
  prepareContent(): void;
  remove(_?: any): void;
  removeObject(_: any): void;
  validateUserInterfaceItem(_: any): boolean;
}

export class NSOpenPanel extends NSSavePanel {
  URLs: URL[];
  isAccessoryViewDisclosed: boolean;
  setAccessoryViewDisclosed(_: boolean);
  allowsMultipleSelection: boolean;
  setAllowsMultipleSelection(_: boolean);
  canChooseDirectories: boolean;
  setCanChooseDirectories(_: boolean);
  canChooseFiles: boolean;
  setCanChooseFiles(_: boolean);
  canDownloadUbiquitousContents: boolean;
  setCanDownloadUbiquitousContents(_: boolean);
  canResolveUbiquitousConflicts: boolean;
  setCanResolveUbiquitousConflicts(_: boolean);
  resolvesAliases: boolean;
  setResolvesAliases(_: boolean);
}

interface NSOpenSavePanelDelegate {
  panelShouldEnableURL(_: any, shouldEnable: URL): boolean;
  panelValidateURL(validateURL: any, error: URL): boolean;
  panelDidChangeToDirectoryURL(_: any, didChangeToDirectoryURL?: URL): void;
  panelUserEnteredFilenameConfirmed(_: any, userEnteredFilename: string, confirmed: boolean): string;
  panelWillExpand(_: any, willExpand: boolean): void;
  panelSelectionDidChange(_?: any): void;
}

export class NSOutlineView extends NSTableView {
  autoresizesOutlineColumn: boolean;
  setAutoresizesOutlineColumn(_: boolean);
  autosaveExpandedItems: boolean;
  setAutosaveExpandedItems(_: boolean);
  dataSource: any;
  setDataSource(_: any);
  delegate: any;
  setDelegate(_: any);
  indentationMarkerFollowsCell: boolean;
  setIndentationMarkerFollowsCell(_: boolean);
  indentationPerLevel: number;
  setIndentationPerLevel(_: number);
  outlineTableColumn: NSTableColumn;
  setOutlineTableColumn(_: NSTableColumn);
  stronglyReferencesItems: boolean;
  setStronglyReferencesItems(_: boolean);
  childOfItem(_: number, ofItem?: any): any;
  childIndexForItem(forItem: any): number;
  collapseItem(_?: any): void;
  collapseItemCollapseChildren(_?: any, collapseChildren?: boolean): void;
  expandItem(_?: any): void;
  expandItemExpandChildren(_?: any, expandChildren?: boolean): void;
  frameOfOutlineCellAtRow(atRow: number): CGRect;
  insertItemsAtIndexesInParentWithAnimation(at: IndexSet, inParent?: any, withAnimation?: NSTableView.AnimationOptions): void;
  isExpandable(_?: any): boolean;
  isItemExpanded(_?: any): boolean;
  itemAtRow(atRow: number): any;
  levelForItem(forItem?: any): number;
  levelForRow(forRow: number): number;
  moveItemAtIndexInParentToIndexInParent(at: number, inParent?: any, to?: number, inParent2?: any): void;
  numberOfChildrenOfItem(ofItem?: any): number;
  parentForItem(forItem?: any): any;
  reloadItem(_?: any): void;
  reloadItemReloadChildren(_?: any, reloadChildren?: boolean): void;
  removeItemsAtIndexesInParentWithAnimation(at: IndexSet, inParent?: any, withAnimation?: NSTableView.AnimationOptions): void;
  rowForItem(forItem?: any): number;
  setDropItemDropChildIndex(_?: any, dropChildIndex?: number): void;
  shouldCollapseAutoExpandedItemsForDeposited(forDeposited: boolean): boolean;
}

interface NSOutlineViewDataSource {
  outlineViewNumberOfChildrenOfItem(_: NSOutlineView, numberOfChildrenOfItem?: any): number;
  outlineViewChildOfItem(_: NSOutlineView, child: number, ofItem?: any): any;
  outlineViewIsItemExpandable(_: NSOutlineView, isItemExpandable: any): boolean;
  outlineViewObjectValueForTableColumnByItem(_: NSOutlineView, objectValueFor?: NSTableColumn, byItem?: any): any;
  outlineViewSetObjectValueForTableColumnByItem(_: NSOutlineView, setObjectValue?: any, for_?: NSTableColumn, byItem?: any): void;
  outlineViewItemForPersistentObject(_: NSOutlineView, itemForPersistentObject: any): any;
  outlineViewPersistentObjectForItem(_: NSOutlineView, persistentObjectForItem?: any): any;
  outlineViewSortDescriptorsDidChange(_: NSOutlineView, sortDescriptorsDidChange: NSSortDescriptor[]): void;
  outlineViewPasteboardWriterForItem(_: NSOutlineView, pasteboardWriterForItem: any): any;
  outlineViewDraggingSessionWillBeginAtPointForItems(_: NSOutlineView, draggingSession: NSDraggingSession, willBeginAt: CGPoint, forItems: any[]): void;
  outlineViewDraggingSessionEndedAtPointOperation(_: NSOutlineView, draggingSession: NSDraggingSession, endedAt: CGPoint, operation: NSDragging.NSDragOperation): void;
  outlineViewWriteItemsToPasteboard(_: NSOutlineView, writeItems: any[], to: NSPasteboard): boolean;
  outlineViewUpdateDraggingItemsForDrag(_: NSOutlineView, updateDraggingItemsForDrag: any): void;
  outlineViewValidateDropProposedItemProposedChildIndex(_: NSOutlineView, validateDrop: any, proposedItem?: any, proposedChildIndex?: number): NSDragging.NSDragOperation;
  outlineViewAcceptDropItemChildIndex(_: NSOutlineView, acceptDrop: any, item?: any, childIndex?: number): boolean;
}

interface NSOutlineViewDelegate {
  outlineViewViewForTableColumnItem(_: NSOutlineView, viewFor?: NSTableColumn, item?: any): NSView;
  outlineViewRowViewForItem(_: NSOutlineView, rowViewForItem: any): NSTableRowView;
  outlineViewDidAddRowViewForRow(_: NSOutlineView, didAdd: NSTableRowView, forRow: number): void;
  outlineViewDidRemoveRowViewForRow(_: NSOutlineView, didRemove: NSTableRowView, forRow: number): void;
  outlineViewWillDisplayCellForTableColumnItem(_: NSOutlineView, willDisplayCell: any, for_?: NSTableColumn, item?: any): void;
  outlineViewShouldEditTableColumnItem(_: NSOutlineView, shouldEdit?: NSTableColumn, item?: any): boolean;
  outlineViewShouldShowOutlineCellForItem(_: NSOutlineView, shouldShowOutlineCellForItem: any): boolean;
  outlineViewShouldSelectItem(_: NSOutlineView, shouldSelectItem: any): boolean;
  outlineViewSelectionIndexesForProposedSelection(_: NSOutlineView, selectionIndexesForProposedSelection: IndexSet): IndexSet;
  outlineViewShouldSelectTableColumn(_: NSOutlineView, shouldSelect?: NSTableColumn): boolean;
  outlineViewMouseDownInHeaderOfTableColumn(_: NSOutlineView, mouseDownInHeaderOf: NSTableColumn): void;
  outlineViewDidClickTableColumn(_: NSOutlineView, didClick: NSTableColumn): void;
  outlineViewDidDragTableColumn(_: NSOutlineView, didDrag: NSTableColumn): void;
  outlineViewToolTipForCellRectTableColumnItemMouseLocation(_: NSOutlineView, toolTipFor: NSCell, rect: CGRect, tableColumn?: NSTableColumn, item?: any, mouseLocation?: CGPoint): string;
  outlineViewHeightOfRowByItem(_: NSOutlineView, heightOfRowByItem: any): number;
  outlineViewTypeSelectStringForTableColumnItem(_: NSOutlineView, typeSelectStringFor?: NSTableColumn, item?: any): string;
  outlineViewNextTypeSelectMatchFromItemToItemForString(_: NSOutlineView, nextTypeSelectMatchFromItem: any, toItem: any, for_: string): any;
  outlineViewShouldTypeSelectForEventWithCurrentSearchString(_: NSOutlineView, shouldTypeSelectFor: NSEvent, withCurrentSearch?: string): boolean;
  outlineViewShouldShowCellExpansionForTableColumnItem(_: NSOutlineView, shouldShowCellExpansionFor?: NSTableColumn, item?: any): boolean;
  outlineViewShouldTrackCellForTableColumnItem(_: NSOutlineView, shouldTrackCell: NSCell, for_?: NSTableColumn, item?: any): boolean;
  outlineViewDataCellForTableColumnItem(_: NSOutlineView, dataCellFor?: NSTableColumn, item?: any): NSCell;
  outlineViewIsGroupItem(_: NSOutlineView, isGroupItem: any): boolean;
  outlineViewShouldExpandItem(_: NSOutlineView, shouldExpandItem: any): boolean;
  outlineViewShouldCollapseItem(_: NSOutlineView, shouldCollapseItem: any): boolean;
  outlineViewWillDisplayOutlineCellForTableColumnItem(_: NSOutlineView, willDisplayOutlineCell: any, for_?: NSTableColumn, item?: any): void;
  outlineViewSizeToFitWidthOfColumn(_: NSOutlineView, sizeToFitWidthOfColumn: number): number;
  outlineViewShouldReorderColumnToColumn(_: NSOutlineView, shouldReorderColumn: number, toColumn: number): boolean;
  outlineViewColumnDidMove(_: Notification): void;
  outlineViewColumnDidResize(_: Notification): void;
  outlineViewItemDidCollapse(_: Notification): void;
  outlineViewItemDidExpand(_: Notification): void;
  outlineViewItemWillCollapse(_: Notification): void;
  outlineViewItemWillExpand(_: Notification): void;
  outlineViewSelectionDidChange(_: Notification): void;
  outlineViewSelectionIsChanging(_: Notification): void;
  selectionShouldChangeInOutlineView(in_: NSOutlineView): boolean;
}

export class NSPDFImageRep extends NSImageRep {
  PDFRepresentation: Data;
  bounds: CGRect;
  currentPage: number;
  setCurrentPage(_: number);
  pageCount: number;
  static initWithData(_: Data): NSPDFImageRep;
}

export class NSPDFInfo extends NSObject {
  URL: URL;
  setURL(_: URL);
  attributes: Map<string, any>;
  isFileExtensionHidden: boolean;
  setFileExtensionHidden(_: boolean);
  orientation: NSPrintInfo.PaperOrientation;
  setOrientation(_: NSPrintInfo.PaperOrientation);
  paperSize: CGSize;
  setPaperSize(_: CGSize);
  tagNames: string[];
  setTagNames(_: string[]);
}

export class NSPDFPanel extends NSObject {
  accessoryController: NSViewController;
  setAccessoryController(_: NSViewController);
  defaultFileName: string;
  setDefaultFileName(_: string);
  options: NSPDFPanel.Options;
  setOptions(_: NSPDFPanel.Options);
  beginSheetWithPDFInfoModalForWindowCompletionHandler(with_: NSPDFInfo, modalFor?: NSWindow, completionHandler?: (p1: number) => void): void;
}

export class NSPICTImageRep extends NSImageRep {
  PICTRepresentation: Data;
  boundingBox: CGRect;
  static initWithData(_: Data): NSPICTImageRep;
}

export class NSPageController extends NSViewController {
  arrangedObjects: any[];
  setArrangedObjects(_: any[]);
  delegate: any;
  setDelegate(_: any);
  selectedIndex: number;
  setSelectedIndex(_: number);
  selectedViewController: NSViewController;
  transitionStyle: NSPageController.TransitionStyle;
  setTransitionStyle(_: NSPageController.TransitionStyle);
  completeTransition(): void;
  navigateBack(_?: any): void;
  navigateForward(_?: any): void;
  navigateForwardToObject(to: any): void;
  takeSelectedIndexFrom(_?: any): void;
}

interface NSPageControllerDelegate {
  pageControllerIdentifierForObject(_: NSPageController, identifierFor: any): string;
  pageControllerViewControllerForIdentifier(_: NSPageController, viewControllerForIdentifier: string): NSViewController;
  pageControllerFrameForObject(_: NSPageController, frameFor?: any): CGRect;
  pageControllerPrepareViewControllerWithObject(_: NSPageController, prepare: NSViewController, with_?: any): void;
  pageControllerDidTransitionToObject(_: NSPageController, didTransitionTo: any): void;
  pageControllerDidEndLiveTransition(_: NSPageController): void;
  pageControllerWillStartLiveTransition(_: NSPageController): void;
}

export class NSPageLayout extends NSObject {
  accessoryControllers: NSViewController[];
  printInfo: NSPrintInfo;
  addAccessoryController(_: NSViewController): void;
  beginSheetWithPrintInfoModalForWindowDelegateDidEndSelectorContextInfo(with_: NSPrintInfo, modalFor: NSWindow, delegate?: any, didEnd?: string, contextInfo?: any): void;
  removeAccessoryController(_: NSViewController): void;
  runModal(): number;
  runModalWithPrintInfo(with_: NSPrintInfo): number;
}

export class NSPanGestureRecognizer extends NSGestureRecognizer {
  buttonMask: number;
  setButtonMask(_: number);
  numberOfTouchesRequired: number;
  setNumberOfTouchesRequired(_: number);
  setTranslationInView(_: CGPoint, in_?: NSView): void;
  translationInView(in_?: NSView): CGPoint;
  velocityInView(in_?: NSView): CGPoint;
}

export class NSPanel extends NSWindow {
  becomesKeyOnlyIfNeeded: boolean;
  setBecomesKeyOnlyIfNeeded(_: boolean);
  isFloatingPanel: boolean;
  setFloatingPanel(_: boolean);
  worksWhenModal: boolean;
  setWorksWhenModal(_: boolean);
}

export class NSParagraphStyle extends NSObject {
  static defaultWritingDirectionForLanguage(forLanguage?: string): NSText.NSWritingDirection;
  alignment: NSText.NSTextAlignment;
  allowsDefaultTighteningForTruncation: boolean;
  baseWritingDirection: NSText.NSWritingDirection;
  defaultTabInterval: number;
  firstLineHeadIndent: number;
  headIndent: number;
  headerLevel: number;
  hyphenationFactor: number;
  lineBreakMode: NSParagraphStyle.NSLineBreakMode;
  lineHeightMultiple: number;
  lineSpacing: number;
  maximumLineHeight: number;
  minimumLineHeight: number;
  paragraphSpacing: number;
  paragraphSpacingBefore: number;
  tabStops: NSTextTab[];
  tailIndent: number;
  textBlocks: NSTextBlock[];
  textLists: NSTextList[];
  tighteningFactorForTruncation: number;
  static defaultParagraphStyle: NSParagraphStyle;
}

export class NSPasteboard extends NSObject {
  static pasteboardWithUniqueName(): NSPasteboard;
  //  static typesFilterableTo(filterableTo: string): string[];
  changeCount: number;
  name: string;
  pasteboardItems: NSPasteboardItem[];
  types: string[];
  static generalPasteboard: NSPasteboard;
  addTypesOwner(_: string[], owner?: any): number;
  availableTypeFromArray(from: string[]): string;
  canReadItemWithDataConformingToTypes(withDataConformingToTypes: string[]): boolean;
  canReadObjectForClassesOptions(forClasses: typeof NSObject[], options?: Map<string, any>): boolean;
  clearContents(): number;
  dataForType(forType: string): Data;
  declareTypesOwner(_: string[], owner?: any): number;
  indexOfPasteboardItem(of: NSPasteboardItem): number;
  prepareForNewContentsWithOptions(with_: NSPasteboard.ContentsOptions): number;
  propertyListForType(forType: string): any;
  readFileContentsTypeToFile(_?: string, toFile?: string): string;
  readFileWrapper(): FileWrapper;
  readObjectsForClassesOptions(forClasses: typeof NSObject[], options?: Map<string, any>): any[];
  releaseGlobally(): void;
  setDataForType(_?: Data, forType?: string): boolean;
  setPropertyListForType(_: any, forType: string): boolean;
  setStringForType(_: string, forType: string): boolean;
  writeFileContents(_: string): boolean;
  writeFileWrapper(_: FileWrapper): boolean;
  writeObjects(_: any[]): boolean;
}

export class NSPasteboardItem extends NSObject {
  types: string[];
  availableTypeFromArray(from: string[]): string;
  dataForType(forType: string): Data;
  propertyListForType(forType: string): any;
  setDataForType(_: Data, forType: string): boolean;
  setDataProviderForTypes(_: any, forTypes: string[]): boolean;
  setPropertyListForType(_: any, forType: string): boolean;
  setStringForType(_: string, forType: string): boolean;
}

interface NSPasteboardItemDataProvider {
  pasteboardItemProvideDataForType(_?: NSPasteboard, item?: NSPasteboardItem, provideDataForType?: string): void;
  pasteboardFinishedWithDataProvider(_: NSPasteboard): void;
}

interface NSPasteboardReading {
}

interface NSPasteboardTypeOwner {
  pasteboardProvideDataForType(_: NSPasteboard, provideDataForType: string): void;
  pasteboardChangedOwner(_: NSPasteboard): void;
}

interface NSPasteboardWriting {
  pasteboardPropertyListForType(forType: string): any;
  writableTypesForPasteboard(for_: NSPasteboard): string[];
  writingOptionsForTypePasteboard(forType: string, pasteboard: NSPasteboard): NSPasteboard.WritingOptions;
}

export class NSPathCell extends NSActionCell {
  URL: URL;
  setURL(_: URL);
  allowedTypes: string[];
  setAllowedTypes(_: string[]);
  backgroundColor: NSColor;
  setBackgroundColor(_: NSColor);
  clickedPathComponentCell: NSPathComponentCell;
  delegate: any;
  setDelegate(_: any);
  doubleAction: string;
  setDoubleAction(_: string);
  pathComponentCells: NSPathComponentCell[];
  setPathComponentCells(_: NSPathComponentCell[]);
  pathStyle: NSPathCell.NSPathControl.Style;
  setPathStyle(_: NSPathCell.NSPathControl.Style);
  placeholderAttributedString: NSAttributedString;
  setPlaceholderAttributedString(_: NSAttributedString);
  placeholderString: string;
  setPlaceholderString(_: string);
  static pathComponentCellClass: typeof NSObject;
  mouseEnteredWithFrameInView(with_: NSEvent, frame: CGRect, in_: NSView): void;
  mouseExitedWithFrameInView(with_: NSEvent, frame: CGRect, in_: NSView): void;
  pathComponentCellAtPointWithFrameInView(at: CGPoint, withFrame: CGRect, in_: NSView): NSPathComponentCell;
  rectOfPathComponentCellWithFrameInView(of: NSPathComponentCell, withFrame: CGRect, in_: NSView): CGRect;
  setObjectValue(_?: any): void;
}

interface NSPathCellDelegate {
  pathCellWillDisplayOpenPanel(_: NSPathCell, willDisplay: NSOpenPanel): void;
  pathCellWillPopUpMenu(_: NSPathCell, willPopUp: NSMenu): void;
}

export class NSPathComponentCell extends NSTextFieldCell {
  URL: URL;
  setURL(_: URL);
}

export class NSPathControl extends NSControl {
  URL: URL;
  setURL(_: URL);
  allowedTypes: string[];
  setAllowedTypes(_: string[]);
  backgroundColor: NSColor;
  setBackgroundColor(_: NSColor);
  clickedPathItem: NSPathControlItem;
  delegate: any;
  setDelegate(_: any);
  doubleAction: string;
  setDoubleAction(_: string);
  isEditable: boolean;
  setEditable(_: boolean);
  pathItems: NSPathControlItem[];
  setPathItems(_: NSPathControlItem[]);
  pathStyle: NSPathCell.NSPathControl.Style;
  setPathStyle(_: NSPathCell.NSPathControl.Style);
  placeholderAttributedString: NSAttributedString;
  setPlaceholderAttributedString(_: NSAttributedString);
  placeholderString: string;
  setPlaceholderString(_: string);
  setDraggingSourceOperationMaskForLocal(_: NSDragging.NSDragOperation, forLocal: boolean): void;
}

interface NSPathControlDelegate {
  pathControlShouldDragItemWithPasteboard(_: NSPathControl, shouldDrag: NSPathControlItem, with_: NSPasteboard): boolean;
  pathControlShouldDragPathComponentCellWithPasteboard(_: NSPathControl, shouldDrag: NSPathComponentCell, with_: NSPasteboard): boolean;
  pathControlValidateDrop(_: NSPathControl, validateDrop: any): NSDragging.NSDragOperation;
  pathControlAcceptDrop(_: NSPathControl, acceptDrop: any): boolean;
  pathControlWillDisplayOpenPanel(_: NSPathControl, willDisplay: NSOpenPanel): void;
  pathControlWillPopUpMenu(_: NSPathControl, willPopUp: NSMenu): void;
}

export class NSPathControlItem extends NSObject {
  URL: URL;
  attributedTitle: NSAttributedString;
  setAttributedTitle(_: NSAttributedString);
  image: NSImage;
  setImage(_: NSImage);
  title: string;
  setTitle(_: string);
}

// export function NSPerformService(itemName: string, pboard: NSPasteboard): boolean;

export class NSPersistentDocument extends NSDocument {
  managedObjectContext: NSManagedObjectContext;
  setManagedObjectContext(_: NSManagedObjectContext);
  managedObjectModel: NSManagedObjectModel;
  configurePersistentStoreCoordinatorForURLOfTypeModelConfigurationStoreOptions(ofType: URL, modelConfiguration: string, storeOptions?: string, error?: Map<string, any>): boolean;
  persistentStoreTypeForFileType(forFileType: string): string;
}

export class NSPickerTouchBarItem extends NSTouchBarItem {
  action: string;
  setAction(_: string);
  collapsedRepresentationImage: NSImage;
  setCollapsedRepresentationImage(_: NSImage);
  collapsedRepresentationLabel: string;
  setCollapsedRepresentationLabel(_: string);
  controlRepresentation: NSPickerTouchBarItem.ControlRepresentation;
  setControlRepresentation(_: NSPickerTouchBarItem.ControlRepresentation);
  customizationLabel: string;
  setCustomizationLabel(_: string);
  isEnabled: boolean;
  setEnabled(_: boolean);
  numberOfOptions: number;
  setNumberOfOptions(_: number);
  selectedIndex: number;
  setSelectedIndex(_: number);
  selectionColor: NSColor;
  setSelectionColor(_: NSColor);
  selectionMode: NSPickerTouchBarItem.SelectionMode;
  setSelectionMode(_: NSPickerTouchBarItem.SelectionMode);
  target: any;
  setTarget(_: any);
  imageAtIndex(at: number): NSImage;
  isEnabledAtIndex(at: number): boolean;
  labelAtIndex(at: number): string;
  setEnabledAtIndex(_: boolean, at: number): void;
  setImageAtIndex(_?: NSImage, at?: number): void;
  setLabelAtIndex(_: string, at: number): void;
}

// export function NSPlanarFromDepth(depth: NSGraphics.NSWindow.Depth): boolean;

export class NSPopUpButton extends NSButton {
  autoenablesItems: boolean;
  setAutoenablesItems(_: boolean);
  indexOfSelectedItem: number;
  itemArray: NSMenuItem[];
  itemTitles: string[];
  lastItem: NSMenuItem;
  numberOfItems: number;
  preferredEdge: NSGeometry.NSRectEdge;
  setPreferredEdge(_: NSGeometry.NSRectEdge);
  pullsDown: boolean;
  setPullsDown(_: boolean);
  selectedItem: NSMenuItem;
  titleOfSelectedItem: string;
  addItemWithTitle(withTitle: string): void;
  addItemsWithTitles(withTitles: string[]): void;
  indexOfItem(of: NSMenuItem): number;
  indexOfItemWithRepresentedObject(withRepresentedObject?: any): number;
  indexOfItemWithTag(withTag: number): number;
  indexOfItemWithTargetAndAction(withTarget?: any, andAction?: string): number;
  indexOfItemWithTitle(withTitle: string): number;
  static initWithFramePullsDown(_: CGRect, pullsDown: boolean): NSPopUpButton;
  insertItemWithTitleAtIndex(withTitle: string, at: number): void;
  itemAtIndex(at: number): NSMenuItem;
  itemTitleAtIndex(at: number): string;
  itemWithTitle(withTitle: string): NSMenuItem;
  removeAllItems(): void;
  removeItemAtIndex(at: number): void;
  removeItemWithTitle(withTitle: string): void;
  selectItem(_?: NSMenuItem): void;
  selectItemAtIndex(at: number): void;
  selectItemWithTag(withTag: number): boolean;
  selectItemWithTitle(withTitle: string): void;
  setTitle(_: string): void;
  synchronizeTitleAndSelectedItem(): void;
}

export class NSPopUpButtonCell extends NSMenuItemCell {
  altersStateOfSelectedItem: boolean;
  setAltersStateOfSelectedItem(_: boolean);
  arrowPosition: NSPopUpButtonCell.NSPopUpButton.ArrowPosition;
  setArrowPosition(_: NSPopUpButtonCell.NSPopUpButton.ArrowPosition);
  autoenablesItems: boolean;
  setAutoenablesItems(_: boolean);
  indexOfSelectedItem: number;
  itemArray: NSMenuItem[];
  itemTitles: string[];
  lastItem: NSMenuItem;
  numberOfItems: number;
  preferredEdge: NSGeometry.NSRectEdge;
  setPreferredEdge(_: NSGeometry.NSRectEdge);
  pullsDown: boolean;
  setPullsDown(_: boolean);
  selectedItem: NSMenuItem;
  titleOfSelectedItem: string;
  usesItemFromMenu: boolean;
  setUsesItemFromMenu(_: boolean);
  addItemWithTitle(withTitle: string): void;
  addItemsWithTitles(withTitles: string[]): void;
  attachPopUpWithFrameInView(withFrame: CGRect, in_: NSView): void;
  dismissPopUp(): void;
  indexOfItem(of: NSMenuItem): number;
  indexOfItemWithRepresentedObject(withRepresentedObject?: any): number;
  indexOfItemWithTag(withTag: number): number;
  indexOfItemWithTargetAndAction(withTarget?: any, andAction?: string): number;
  indexOfItemWithTitle(withTitle: string): number;
  static initTextCellPullsDown(_: string, pullsDown: boolean): NSPopUpButtonCell;
  insertItemWithTitleAtIndex(withTitle: string, at: number): void;
  itemAtIndex(at: number): NSMenuItem;
  itemTitleAtIndex(at: number): string;
  itemWithTitle(withTitle: string): NSMenuItem;
  performClickWithFrameInView(withFrame: CGRect, in_: NSView): void;
  removeAllItems(): void;
  removeItemAtIndex(at: number): void;
  removeItemWithTitle(withTitle: string): void;
  selectItem(_?: NSMenuItem): void;
  selectItemAtIndex(at: number): void;
  selectItemWithTag(withTag: number): boolean;
  selectItemWithTitle(withTitle: string): void;
  setTitle(_?: string): void;
  synchronizeTitleAndSelectedItem(): void;
}

export class NSPopover extends NSResponder {
  animates: boolean;
  setAnimates(_: boolean);
  behavior: NSPopover.Behavior;
  setBehavior(_: NSPopover.Behavior);
  contentSize: CGSize;
  setContentSize(_: CGSize);
  contentViewController: NSViewController;
  setContentViewController(_: NSViewController);
  delegate: any;
  setDelegate(_: any);
  isDetached: boolean;
  positioningRect: CGRect;
  setPositioningRect(_: CGRect);
  isShown: boolean;
  close(): void;
  performClose(_?: any): void;
  showRelativeToRectOfViewPreferredEdge(relativeTo: CGRect, of: NSView, preferredEdge: NSGeometry.NSRectEdge): void;
}

interface NSPopoverDelegate {
  detachableWindowForPopover(for_: NSPopover): NSWindow;
  popoverDidClose(_: Notification): void;
  popoverDidDetach(_: NSPopover): void;
  popoverDidShow(_: Notification): void;
  popoverShouldClose(_: NSPopover): boolean;
  popoverShouldDetach(_: NSPopover): boolean;
  popoverWillClose(_: Notification): void;
  popoverWillShow(_: Notification): void;
}

export class NSPopoverTouchBarItem extends NSTouchBarItem {
  collapsedRepresentation: NSView;
  setCollapsedRepresentation(_: NSView);
  collapsedRepresentationImage: NSImage;
  setCollapsedRepresentationImage(_: NSImage);
  collapsedRepresentationLabel: string;
  setCollapsedRepresentationLabel(_: string);
  customizationLabel: string;
  setCustomizationLabel(_: string);
  popoverTouchBar: NSTouchBar;
  setPopoverTouchBar(_: NSTouchBar);
  pressAndHoldTouchBar: NSTouchBar;
  setPressAndHoldTouchBar(_: NSTouchBar);
  showsCloseButton: boolean;
  setShowsCloseButton(_: boolean);
  dismissPopover(_?: any): void;
  makeStandardActivatePopoverGestureRecognizer(): NSGestureRecognizer;
  showPopover(_?: any): void;
}

export class NSPredicateEditor extends NSRuleEditor {
  rowTemplates: NSPredicateEditorRowTemplate[];
  setRowTemplates(_: NSPredicateEditorRowTemplate[]);
}

export class NSPredicateEditorRowTemplate extends NSObject {
  static templatesWithAttributeKeyPathsInEntityDescription(withAttributeKeyPaths: string[], in_: NSEntityDescription): NSPredicateEditorRowTemplate[];
  compoundTypes: number[];
  leftExpressions: NSExpression[];
  modifier: NSComparisonPredicate.Modifier;
  operators: number[];
  options: number;
  rightExpressionAttributeType: NSAttributeDescription.NSAttributeType;
  rightExpressions: NSExpression[];
  templateViews: NSView[];
  displayableSubpredicatesOfPredicate(of: NSPredicate): NSPredicate[];
  static initWithCompoundTypes(_: number[]): NSPredicateEditorRowTemplate;
  static initWithLeftExpressionsRightExpressionAttributeTypeModifierOperatorsOptions(_: NSExpression[], rightExpressionAttributeType: NSAttributeDescription.NSAttributeType, modifier: NSComparisonPredicate.Modifier, operators: number[], options: number): NSPredicateEditorRowTemplate;
  static initWithLeftExpressionsRightExpressionsModifierOperatorsOptions(_: NSExpression[], rightExpressions: NSExpression[], modifier: NSComparisonPredicate.Modifier, operators: number[], options: number): NSPredicateEditorRowTemplate;
  matchForPredicate(for_: NSPredicate): number;
  predicateWithSubpredicates(withSubpredicates?: NSPredicate[]): NSPredicate;
  setPredicate(_: NSPredicate): void;
}

export class NSPressGestureRecognizer extends NSGestureRecognizer {
  allowableMovement: number;
  setAllowableMovement(_: number);
  buttonMask: number;
  setButtonMask(_: number);
  minimumPressDuration: number;
  setMinimumPressDuration(_: number);
  numberOfTouchesRequired: number;
  setNumberOfTouchesRequired(_: number);
}

export class NSPressureConfiguration extends NSObject {
  pressureBehavior: NSEvent.PressureBehavior;
  static initWithPressureBehavior(_: NSEvent.PressureBehavior): NSPressureConfiguration;
  set(): void;
}

export class NSPrintInfo extends NSObject {
  bottomMargin: number;
  setBottomMargin(_: number);
  horizontalPagination: NSPrintInfo.PaginationMode;
  setHorizontalPagination(_: NSPrintInfo.PaginationMode);
  isHorizontallyCentered: boolean;
  setHorizontallyCentered(_: boolean);
  imageablePageBounds: CGRect;
  jobDisposition: string;
  setJobDisposition(_: string);
  leftMargin: number;
  setLeftMargin(_: number);
  localizedPaperName: string;
  orientation: NSPrintInfo.PaperOrientation;
  setOrientation(_: NSPrintInfo.PaperOrientation);
  paperName: string;
  setPaperName(_: string);
  paperSize: CGSize;
  setPaperSize(_: CGSize);
  printSettings: Map<string, any>;
  printer: NSPrinter;
  setPrinter(_: NSPrinter);
  rightMargin: number;
  setRightMargin(_: number);
  scalingFactor: number;
  setScalingFactor(_: number);
  isSelectionOnly: boolean;
  setSelectionOnly(_: boolean);
  topMargin: number;
  setTopMargin(_: number);
  verticalPagination: NSPrintInfo.PaginationMode;
  setVerticalPagination(_: NSPrintInfo.PaginationMode);
  isVerticallyCentered: boolean;
  setVerticallyCentered(_: boolean);
  static defaultPrinter: NSPrinter;
  static sharedPrintInfo: NSPrintInfo;
  setSharedPrintInfo(_: NSPrintInfo);
  pMPageFormat(): any;
  pMPrintSession(): any;
  pMPrintSettings(): any;
  dictionary(): Map<string, any>;
  static initWithDictionary(_: Map<string, any>): NSPrintInfo;
  setUpPrintOperationDefaultValues(): void;
  takeSettingsFromPDFInfo(from: NSPDFInfo): void;
  updateFromPMPageFormat(): void;
  updateFromPMPrintSettings(): void;
}

export class NSPrintOperation extends NSObject {
  static ePSOperationWithViewInsideRectToData(with_: NSView, inside: CGRect, to?: NSMutableData): NSPrintOperation;
  static ePSOperationWithViewInsideRectToDataPrintInfo(with_: NSView, inside: CGRect, to: NSMutableData, printInfo: NSPrintInfo): NSPrintOperation;
  static ePSOperationWithViewInsideRectToPathPrintInfo(with_: NSView, inside: CGRect, toPath: string, printInfo: NSPrintInfo): NSPrintOperation;
  static pDFOperationWithViewInsideRectToData(with_: NSView, inside: CGRect, to: NSMutableData): NSPrintOperation;
  static pDFOperationWithViewInsideRectToDataPrintInfo(with_: NSView, inside: CGRect, to: NSMutableData, printInfo: NSPrintInfo): NSPrintOperation;
  static pDFOperationWithViewInsideRectToPathPrintInfo(with_: NSView, inside: CGRect, toPath: string, printInfo: NSPrintInfo): NSPrintOperation;
  PDFPanel: NSPDFPanel;
  setPDFPanel(_: NSPDFPanel);
  canSpawnSeparateThread: boolean;
  setCanSpawnSeparateThread(_: boolean);
  context: NSGraphicsContext;
  isCopyingOperation: boolean;
  currentPage: number;
  jobTitle: string;
  setJobTitle(_: string);
  pageOrder: NSPrintOperation.PageOrder;
  setPageOrder(_: NSPrintOperation.PageOrder);
  pageRange: NSRange;
  preferredRenderingQuality: NSPrintOperation.RenderingQuality;
  printInfo: NSPrintInfo;
  setPrintInfo(_: NSPrintInfo);
  printPanel: NSPrintPanel;
  setPrintPanel(_: NSPrintPanel);
  showsPrintPanel: boolean;
  setShowsPrintPanel(_: boolean);
  showsProgressPanel: boolean;
  setShowsProgressPanel(_: boolean);
  static currentOperation: NSPrintOperation;
  setCurrentOperation(_: NSPrintOperation);
  cleanUpOperation(): void;
  createContext(): NSGraphicsContext;
  deliverResult(): boolean;
  destroyContext(): void;
  runOperation(): boolean;
  runOperationModalForWindowDelegateDidRunSelectorContextInfo(for_: NSWindow, delegate?: any, didRun?: string, contextInfo?: any): void;
}

export class NSPrintPanel extends NSObject {
  accessoryControllers: NSViewController[];
  helpAnchor: string;
  setHelpAnchor(_: string);
  jobStyleHint: string;
  setJobStyleHint(_: string);
  options: NSPrintPanel.Options;
  setOptions(_: NSPrintPanel.Options);
  printInfo: NSPrintInfo;
  addAccessoryController(_: NSViewController): void;
  beginSheetWithPrintInfoModalForWindowDelegateDidEndSelectorContextInfo(with_: NSPrintInfo, modalFor: NSWindow, delegate?: any, didEnd?: string, contextInfo?: any): void;
  defaultButtonTitle(): string;
  removeAccessoryController(_: NSViewController): void;
  runModal(): number;
  runModalWithPrintInfo(with_: NSPrintInfo): number;
  setDefaultButtonTitle(_?: string): void;
}

interface NSPrintPanelAccessorizing {
  keyPathsForValuesAffectingPreview(): Set<any>;
  localizedSummaryItems(): Map<string, string>[];
}

export class NSPrinter extends NSObject {
  deviceDescription: Map<string, any>;
  languageLevel: number;
  name: string;
  type: string;
  static printerNames: string[];
  static printerTypes: string[];
  pageSizeForPaper(forPaper: string): CGSize;
}

export class NSProgressIndicator extends NSView {
  isBezeled: boolean;
  setBezeled(_: boolean);
  controlSize: NSCell.NSControl.ControlSize;
  setControlSize(_: NSCell.NSControl.ControlSize);
  controlTint: NSCell.NSControlTint;
  setControlTint(_: NSCell.NSControlTint);
  isDisplayedWhenStopped: boolean;
  setDisplayedWhenStopped(_: boolean);
  doubleValue: number;
  setDoubleValue(_: number);
  isIndeterminate: boolean;
  setIndeterminate(_: boolean);
  maxValue: number;
  setMaxValue(_: number);
  minValue: number;
  setMinValue(_: number);
  style: NSProgressIndicator.Style;
  setStyle(_: NSProgressIndicator.Style);
  usesThreadedAnimation: boolean;
  setUsesThreadedAnimation(_: boolean);
  incrementBy(by: number): void;
  sizeToFit(): void;
  startAnimation(_?: any): void;
  stopAnimation(_?: any): void;
}

// export function NSRectClip(rect: CGRect): void;

// export function NSRectClipList(rects: CGRect, count: number): void;

// export function NSRectFill(rect: CGRect): void;

// export function NSRectFillList(rects: CGRect, count: number): void;

// export function NSRectFillListUsingOperation(rects: CGRect, count: number, op: NSGraphics.NSCompositingOperation): void;

// export function NSRectFillListWithColors(rects: CGRect, colors: NSColor, num: number): void;

// export function NSRectFillListWithColorsUsingOperation(rects: CGRect, colors: NSColor, num: number, op: NSGraphics.NSCompositingOperation): void;

// export function NSRectFillListWithGrays(rects: CGRect, grays: number, num: number): void;

// export function NSRectFillUsingOperation(rect: CGRect, op: NSGraphics.NSCompositingOperation): void;

// export function NSRegisterServicesProvider(provider: any, name: string): void;

export class NSResponder extends NSObject {
  acceptsFirstResponder: boolean;
  menu: NSMenu;
  setMenu(_: NSMenu);
  nextResponder: NSResponder;
  setNextResponder(_: NSResponder);
  touchBar: NSTouchBar;
  setTouchBar(_: NSTouchBar);
  undoManager: UndoManager;
  userActivity: NSUserActivity;
  setUserActivity(_: NSUserActivity);
  static restorableStateKeyPaths: string[];
  becomeFirstResponder(): boolean;
  beginGestureWithEvent(with_: NSEvent): void;
  changeModeWithEvent(with_: NSEvent): void;
  cursorUpdate(with_: NSEvent): void;
  encodeRestorableStateWithCoder(with_: NSCoder): void;
  encodeRestorableStateWithCoderBackgroundQueue(with_: NSCoder, backgroundQueue: OperationQueue): void;
  endGestureWithEvent(with_: NSEvent): void;
  flagsChanged(with_: NSEvent): void;
  flushBufferedKeyEvents(): void;
  helpRequested(_: NSEvent): void;
  interpretKeyEvents(_: NSEvent[]): void;
  invalidateRestorableState(): void;
  keyDown(with_: NSEvent): void;
  keyUp(with_: NSEvent): void;
  magnifyWithEvent(with_: NSEvent): void;
  makeTouchBar(): NSTouchBar;
  mouseDown(with_: NSEvent): void;
  mouseDragged(with_: NSEvent): void;
  mouseEntered(with_: NSEvent): void;
  mouseExited(with_: NSEvent): void;
  mouseMoved(with_: NSEvent): void;
  mouseUp(with_: NSEvent): void;
  newWindowForTab(_?: any): void;
  noResponderFor(for_: string): void;
  otherMouseDown(with_: NSEvent): void;
  otherMouseDragged(with_: NSEvent): void;
  otherMouseUp(with_: NSEvent): void;
  performKeyEquivalent(with_: NSEvent): boolean;
  performTextFinderAction(_?: any): void;
  presentError(_: Error): boolean;
  presentErrorModalForWindowDelegateDidPresentSelectorContextInfo(_: Error, modalFor: NSWindow, delegate?: any, didPresent?: string, contextInfo?: any): void;
  pressureChangeWithEvent(with_: NSEvent): void;
  quickLookWithEvent(with_: NSEvent): void;
  resignFirstResponder(): boolean;
  restoreStateWithCoder(with_: NSCoder): void;
  rightMouseDown(with_: NSEvent): void;
  rightMouseDragged(with_: NSEvent): void;
  rightMouseUp(with_: NSEvent): void;
  rotateWithEvent(with_: NSEvent): void;
  scrollWheel(with_: NSEvent): void;
  shouldBeTreatedAsInkEvent(_: NSEvent): boolean;
  showContextHelp(_?: any): void;
  smartMagnifyWithEvent(with_: NSEvent): void;
  supplementalTargetForActionSender(forAction: string, sender?: any): any;
  swipeWithEvent(with_: NSEvent): void;
  tabletPoint(with_: NSEvent): void;
  tabletProximity(with_: NSEvent): void;
  touchesBeganWithEvent(with_: NSEvent): void;
  touchesCancelledWithEvent(with_: NSEvent): void;
  touchesEndedWithEvent(with_: NSEvent): void;
  touchesMovedWithEvent(with_: NSEvent): void;
  tryToPerformWith(_: string, with_?: any): boolean;
  updateUserActivityState(_: NSUserActivity): void;
  validRequestorForSendTypeReturnType(forSendType?: string, returnType?: string): any;
  validateProposedFirstResponderForEvent(_: NSResponder, for_?: NSEvent): boolean;
  wantsForwardedScrollEventsForAxis(for_: NSEvent.GestureAxis): boolean;
  wantsScrollEventsForSwipeTrackingOnAxis(on: NSEvent.GestureAxis): boolean;
  willPresentError(_: Error): Error;
}

export class NSRotationGestureRecognizer extends NSGestureRecognizer {
  rotation: number;
  setRotation(_: number);
  rotationInDegrees: number;
  setRotationInDegrees(_: number);
}

export class NSRuleEditor extends NSControl {
  canRemoveAllRows: boolean;
  setCanRemoveAllRows(_: boolean);
  criteriaKeyPath: string;
  setCriteriaKeyPath(_: string);
  delegate: any;
  setDelegate(_: any);
  displayValuesKeyPath: string;
  setDisplayValuesKeyPath(_: string);
  isEditable: boolean;
  setEditable(_: boolean);
  formattingDictionary: Map<string, string>;
  setFormattingDictionary(_: Map<string, string>);
  formattingStringsFilename: string;
  setFormattingStringsFilename(_: string);
  nestingMode: NSRuleEditor.NestingMode;
  setNestingMode(_: NSRuleEditor.NestingMode);
  numberOfRows: number;
  predicate: NSPredicate;
  rowClass: typeof NSObject;
  setRowClass(_: typeof NSObject);
  rowHeight: number;
  setRowHeight(_: number);
  rowTypeKeyPath: string;
  setRowTypeKeyPath(_: string);
  selectedRowIndexes: IndexSet;
  subrowsKeyPath: string;
  setSubrowsKeyPath(_: string);
  addRow(_?: any): void;
  criteriaForRow(forRow: number): any[];
  displayValuesForRow(forRow: number): any[];
  insertRowAtIndexWithTypeAsSubrowOfRowAnimate(at: number, with_: NSRuleEditor.RowType, asSubrowOfRow: number, animate: boolean): void;
  parentRowForRow(forRow: number): number;
  // dupe name w instance property   predicateForRow(forRow: number): NSPredicate;
  reloadCriteria(): void;
  reloadPredicate(): void;
  removeRowAtIndex(at: number): void;
  removeRowsAtIndexesIncludeSubrows(at: IndexSet, includeSubrows: boolean): void;
  rowForDisplayValue(forDisplayValue: any): number;
  rowTypeForRow(forRow: number): NSRuleEditor.RowType;
  selectRowIndexesByExtendingSelection(_: IndexSet, byExtendingSelection: boolean): void;
  setCriteriaAndDisplayValuesForRowAtIndex(_: any[], andDisplayValues: any[], forRowAt: number): void;
  subrowIndexesForRow(forRow: number): IndexSet;
}

interface NSRuleEditorDelegate {
  ruleEditorNumberOfChildrenForCriterionWithRowType(_: NSRuleEditor, numberOfChildrenForCriterion?: any, with_?: NSRuleEditor.RowType): number;
  ruleEditorChildForCriterionWithRowType(_: NSRuleEditor, child: number, forCriterion?: any, with_?: NSRuleEditor.RowType): any;
  ruleEditorDisplayValueForCriterionInRow(_: NSRuleEditor, displayValueForCriterion: any, inRow: number): any;
  ruleEditorPredicatePartsForCriterionWithDisplayValueInRow(_: NSRuleEditor, predicatePartsForCriterion: any, withDisplayValue: any, inRow: number): Map<string, any>;
  ruleEditorRowsDidChange(_: Notification): void;
}

export class NSRulerMarker extends NSObject {
  isDragging: boolean;
  image: NSImage;
  setImage(_: NSImage);
  imageOrigin: CGPoint;
  setImageOrigin(_: CGPoint);
  imageRectInRuler: CGRect;
  markerLocation: number;
  setMarkerLocation(_: number);
  isMovable: boolean;
  setMovable(_: boolean);
  isRemovable: boolean;
  setRemovable(_: boolean);
  representedObject: any;
  setRepresentedObject(_: any);
  ruler: NSRulerView;
  thicknessRequiredInRuler: number;
  drawRect(_: CGRect): void;
  static initWithRulerViewMarkerLocationImageImageOrigin(_: NSRulerView, markerLocation: number, image: NSImage, imageOrigin: CGPoint): NSRulerMarker;
  trackMouseAdding(with_: NSEvent, adding: boolean): boolean;
}

export class NSRulerView extends NSView {
  static registerUnitWithNameAbbreviationUnitToPointsConversionFactorStepUpCycleStepDownCycle(withName: string, abbreviation: string, unitToPointsConversionFactor: number, stepUpCycle: number[], stepDownCycle: number[]): void;
  accessoryView: NSView;
  setAccessoryView(_: NSView);
  baselineLocation: number;
  clientView: NSView;
  setClientView(_: NSView);
  markers: NSRulerMarker[];
  setMarkers(_: NSRulerMarker[]);
  measurementUnits: string;
  setMeasurementUnits(_: string);
  orientation: NSRulerView.Orientation;
  setOrientation(_: NSRulerView.Orientation);
  originOffset: number;
  setOriginOffset(_: number);
  requiredThickness: number;
  reservedThicknessForAccessoryView: number;
  setReservedThicknessForAccessoryView(_: number);
  reservedThicknessForMarkers: number;
  setReservedThicknessForMarkers(_: number);
  ruleThickness: number;
  setRuleThickness(_: number);
  scrollView: NSScrollView;
  setScrollView(_: NSScrollView);
  addMarker(_: NSRulerMarker): void;
  drawHashMarksAndLabelsInRect(in_: CGRect): void;
  drawMarkersInRect(in_: CGRect): void;
  static initWithScrollViewOrientation(_?: NSScrollView, orientation?: NSRulerView.Orientation): NSRulerView;
  invalidateHashMarks(): void;
  moveRulerlineFromLocationToLocation(fromLocation: number, toLocation: number): void;
  removeMarker(_: NSRulerMarker): void;
  trackMarkerWithMouseEvent(_: NSRulerMarker, withMouseEvent: NSEvent): boolean;
}

export class NSRunningApplication extends NSObject {
  static runningApplicationsWithBundleIdentifier(withBundleIdentifier: string): NSRunningApplication[];
  static terminateAutomaticallyTerminableApplications(): void;
  activationPolicy: NSRunningApplication.NSApplication.ActivationPolicy;
  isActive: boolean;
  bundleIdentifier: string;
  bundleURL: URL;
  executableArchitecture: number;
  executableURL: URL;
  isFinishedLaunching: boolean;
  isHidden: boolean;
  icon: NSImage;
  launchDate: Date;
  localizedName: string;
  ownsMenuBar: boolean;
  processIdentifier: number;
  isTerminated: boolean;
  static currentApplication: NSRunningApplication;
  activateWithOptions(options: NSRunningApplication.NSApplication.ActivationOptions): boolean;
  forceTerminate(): boolean;
  hide(): boolean;
  terminate(): boolean;
  unhide(): boolean;
}

export class NSSavePanel extends NSPanel {
  URL: URL;
  accessoryView: NSView;
  setAccessoryView(_: NSView);
  allowedFileTypes: string[];
  setAllowedFileTypes(_: string[]);
  allowsOtherFileTypes: boolean;
  setAllowsOtherFileTypes(_: boolean);
  canCreateDirectories: boolean;
  setCanCreateDirectories(_: boolean);
  canSelectHiddenExtension: boolean;
  setCanSelectHiddenExtension(_: boolean);
  delegate: any;
  setDelegate(_: any);
  directoryURL: URL;
  setDirectoryURL(_: URL);
  isExpanded: boolean;
  isExtensionHidden: boolean;
  setExtensionHidden(_: boolean);
  message: string;
  setMessage(_: string);
  nameFieldLabel: string;
  setNameFieldLabel(_: string);
  nameFieldStringValue: string;
  setNameFieldStringValue(_: string);
  prompt: string;
  setPrompt(_: string);
  showsHiddenFiles: boolean;
  setShowsHiddenFiles(_: boolean);
  showsTagField: boolean;
  setShowsTagField(_: boolean);
  tagNames: string[];
  setTagNames(_: string[]);
  treatsFilePackagesAsDirectories: boolean;
  setTreatsFilePackagesAsDirectories(_: boolean);
  beginSheetModalForWindowCompletionHandler(for_: NSWindow, completionHandler: (p1: number) => void): void;
  beginWithCompletionHandler(completionHandler: (p1: number) => void): void;
  cancel(_?: any): void;
  ok(_?: any): void;
  runModal(): number;
  validateVisibleColumns(): void;
}

export class NSScreen extends NSObject {
  backingScaleFactor: number;
  colorSpace: NSColorSpace;
  depth: NSGraphics.NSWindow.Depth;
  deviceDescription: Map<string, any>;
  frame: CGRect;
  localizedName: string;
  maximumExtendedDynamicRangeColorComponentValue: number;
  maximumPotentialExtendedDynamicRangeColorComponentValue: number;
  maximumReferenceExtendedDynamicRangeColorComponentValue: number;
  supportedWindowDepths: NSGraphics.NSWindow.Depth;
  visibleFrame: CGRect;
  static deepestScreen: NSScreen;
  static mainScreen: NSScreen;
  static screens: NSScreen[];
  static screensHaveSeparateSpaces: boolean;
  backingAlignedRectOptions(_: CGRect, options: NSGeometry.AlignmentOptions): CGRect;
  canRepresentDisplayGamut(_: NSGraphics.NSDisplayGamut): boolean;
  convertRectFromBacking(_: CGRect): CGRect;
  convertRectToBacking(_: CGRect): CGRect;
}

export class NSScrollView extends NSView {
  //  static contentSizeForFrameSizeHorizontalScrollerClassVerticalScrollerClassBorderTypeControlSizeScrollerStyle(forFrameSize: CGSize, horizontalScrollerClass?: typeof NSObject, verticalScrollerClass?: typeof NSObject, borderType?: NSView.NSBorderType, controlSize?: NSCell.NSControl.ControlSize, scrollerStyle?: NSScroller.Style): CGSize;
  static frameSizeForContentSizeHorizontalScrollerClassVerticalScrollerClassBorderTypeControlSizeScrollerStyle(forContentSize: CGSize, horizontalScrollerClass?: typeof NSObject, verticalScrollerClass?: typeof NSObject, borderType?: NSView.NSBorderType, controlSize?: NSCell.NSControl.ControlSize, scrollerStyle?: NSScroller.Style): CGSize;
  allowsMagnification: boolean;
  setAllowsMagnification(_: boolean);
  autohidesScrollers: boolean;
  setAutohidesScrollers(_: boolean);
  automaticallyAdjustsContentInsets: boolean;
  setAutomaticallyAdjustsContentInsets(_: boolean);
  backgroundColor: NSColor;
  setBackgroundColor(_: NSColor);
  borderType: NSView.NSBorderType;
  setBorderType(_: NSView.NSBorderType);
  contentInsets: NSEdgeInsets;
  setContentInsets(_: NSEdgeInsets);
  contentSize: CGSize;
  contentView: NSClipView;
  setContentView(_: NSClipView);
  documentCursor: NSCursor;
  setDocumentCursor(_: NSCursor);
  documentView: NSView;
  setDocumentView(_: NSView);
  documentVisibleRect: CGRect;
  drawsBackground: boolean;
  setDrawsBackground(_: boolean);
  findBarPosition: NSScrollView.FindBarPosition;
  setFindBarPosition(_: NSScrollView.FindBarPosition);
  hasHorizontalRuler: boolean;
  setHasHorizontalRuler(_: boolean);
  hasHorizontalScroller: boolean;
  setHasHorizontalScroller(_: boolean);
  hasVerticalRuler: boolean;
  setHasVerticalRuler(_: boolean);
  hasVerticalScroller: boolean;
  setHasVerticalScroller(_: boolean);
  horizontalLineScroll: number;
  setHorizontalLineScroll(_: number);
  horizontalPageScroll: number;
  setHorizontalPageScroll(_: number);
  horizontalRulerView: NSRulerView;
  setHorizontalRulerView(_: NSRulerView);
  horizontalScrollElasticity: NSScrollView.Elasticity;
  setHorizontalScrollElasticity(_: NSScrollView.Elasticity);
  horizontalScroller: NSScroller;
  setHorizontalScroller(_: NSScroller);
  lineScroll: number;
  setLineScroll(_: number);
  magnification: number;
  setMagnification(_: number);
  maxMagnification: number;
  setMaxMagnification(_: number);
  minMagnification: number;
  setMinMagnification(_: number);
  pageScroll: number;
  setPageScroll(_: number);
  rulersVisible: boolean;
  setRulersVisible(_: boolean);
  scrollerInsets: NSEdgeInsets;
  setScrollerInsets(_: NSEdgeInsets);
  scrollerKnobStyle: NSScroller.KnobStyle;
  setScrollerKnobStyle(_: NSScroller.KnobStyle);
  scrollerStyle: NSScroller.Style;
  setScrollerStyle(_: NSScroller.Style);
  scrollsDynamically: boolean;
  setScrollsDynamically(_: boolean);
  usesPredominantAxisScrolling: boolean;
  setUsesPredominantAxisScrolling(_: boolean);
  verticalLineScroll: number;
  setVerticalLineScroll(_: number);
  verticalPageScroll: number;
  setVerticalPageScroll(_: number);
  verticalRulerView: NSRulerView;
  setVerticalRulerView(_: NSRulerView);
  verticalScrollElasticity: NSScrollView.Elasticity;
  setVerticalScrollElasticity(_: NSScrollView.Elasticity);
  verticalScroller: NSScroller;
  setVerticalScroller(_: NSScroller);
  static rulerViewClass: typeof NSObject;
  setRulerViewClass(_: typeof NSObject);
  addFloatingSubviewForAxis(_: NSView, for_: NSEvent.GestureAxis): void;
  flashScrollers(): void;
  magnifyToFitRect(toFit: CGRect): void;
  setMagnificationCenteredAtPoint(_: number, centeredAt: CGPoint): void;
  tile(): void;
}

export class NSScroller extends NSControl {
  static scrollerWidthForControlSizeScrollerStyle(for_: NSCell.NSControl.ControlSize, scrollerStyle: NSScroller.Style): number;
  hitPart: NSScroller.Part;
  knobProportion: number;
  setKnobProportion(_: number);
  knobStyle: NSScroller.KnobStyle;
  setKnobStyle(_: NSScroller.KnobStyle);
  scrollerStyle: NSScroller.Style;
  setScrollerStyle(_: NSScroller.Style);
  usableParts: NSScroller.UsableParts;
  static isCompatibleWithOverlayScrollers: boolean;
  static preferredScrollerStyle: NSScroller.Style;
  checkSpaceForParts(): void;
  drawKnob(): void;
  drawKnobSlotInRectHighlight(in_: CGRect, highlight: boolean): void;
  rectForPart(for_: NSScroller.Part): CGRect;
  setKnobProportion(_: number): void;
  testPart(_: CGPoint): NSScroller.Part;
  trackKnob(with_: NSEvent): void;
}

export class NSScrubber extends NSView {
  backgroundColor: NSColor;
  setBackgroundColor(_: NSColor);
  backgroundView: NSView;
  setBackgroundView(_: NSView);
  isContinuous: boolean;
  setContinuous(_: boolean);
  dataSource: any;
  setDataSource(_: any);
  delegate: any;
  setDelegate(_: any);
  floatsSelectionViews: boolean;
  setFloatsSelectionViews(_: boolean);
  highlightedIndex: number;
  itemAlignment: NSScrubber.Alignment;
  setItemAlignment(_: NSScrubber.Alignment);
  mode: NSScrubber.Mode;
  setMode(_: NSScrubber.Mode);
  numberOfItems: number;
  scrubberLayout: NSScrubberLayout;
  setScrubberLayout(_: NSScrubberLayout);
  selectedIndex: number;
  setSelectedIndex(_: number);
  selectionBackgroundStyle: NSScrubberSelectionStyle;
  setSelectionBackgroundStyle(_: NSScrubberSelectionStyle);
  selectionOverlayStyle: NSScrubberSelectionStyle;
  setSelectionOverlayStyle(_: NSScrubberSelectionStyle);
  showsAdditionalContentIndicators: boolean;
  setShowsAdditionalContentIndicators(_: boolean);
  showsArrowButtons: boolean;
  setShowsArrowButtons(_: boolean);
  insertItemsAtIndexes(at: IndexSet): void;
  itemViewForItemAtIndex(at: number): NSScrubberItemView;
  makeItemWithIdentifierOwner(withIdentifier: string, owner?: any): NSScrubberItemView;
  moveItemAtIndexToIndex(at: number, to: number): void;
  performSequentialBatchUpdates(_: () => void): void;
  registerClassForItemIdentifier(_?: typeof NSObject, forItemIdentifier?: string): void;
  registerNibForItemIdentifier(_?: NSNib, forItemIdentifier?: string): void;
  reloadData(): void;
  reloadItemsAtIndexes(at: IndexSet): void;
  removeItemsAtIndexes(at: IndexSet): void;
  scrollItemAtIndexToAlignment(at: number, to: NSScrubber.Alignment): void;
}

export class NSScrubberArrangedView extends NSView {
  isHighlighted: boolean;
  setHighlighted(_: boolean);
  isSelected: boolean;
  setSelected(_: boolean);
  applyLayoutAttributes(_: NSScrubberLayoutAttributes): void;
}

interface NSScrubberDataSource {
  numberOfItemsForScrubber(for_: NSScrubber): number;
  scrubberViewForItemAtIndex(_: NSScrubber, viewForItemAt: number): NSScrubberItemView;
}

interface NSScrubberDelegate {
  didBeginInteractingWithScrubber(with_: NSScrubber): void;
  didCancelInteractingWithScrubber(with_: NSScrubber): void;
  didFinishInteractingWithScrubber(with_: NSScrubber): void;
  scrubberDidSelectItemAtIndex(_: NSScrubber, didSelectItemAt: number): void;
  scrubberDidHighlightItemAtIndex(_: NSScrubber, didHighlightItemAt: number): void;
  scrubberDidChangeVisibleRange(_: NSScrubber, didChangeVisibleRange: NSRange): void;
}

export class NSScrubberFlowLayout extends NSScrubberLayout {
  itemSize: CGSize;
  setItemSize(_: CGSize);
  itemSpacing: number;
  setItemSpacing(_: number);
  invalidateLayoutForItemsAtIndexes(at: IndexSet): void;
}

interface NSScrubberFlowLayoutDelegate {
  scrubberLayoutSizeForItemAtIndex(_: NSScrubber, layout: NSScrubberFlowLayout, sizeForItemAt: number): CGSize;
}

export class NSScrubberImageItemView extends NSScrubberItemView {
  image: NSImage;
  setImage(_: NSImage);
  imageAlignment: NSImageCell.NSImageAlignment;
  setImageAlignment(_: NSImageCell.NSImageAlignment);
  imageView: NSImageView;
}

export class NSScrubberItemView extends NSScrubberArrangedView {
}

export class NSScrubberLayout extends NSObject {
  automaticallyMirrorsInRightToLeftLayout: boolean;
  scrubber: NSScrubber;
  scrubberContentSize: CGSize;
  shouldInvalidateLayoutForHighlightChange: boolean;
  shouldInvalidateLayoutForSelectionChange: boolean;
  visibleRect: CGRect;
  static layoutAttributesClass: typeof NSObject;
  invalidateLayout(): void;
  layoutAttributesForItemAtIndex(at: number): NSScrubberLayoutAttributes;
  layoutAttributesForItemsInRect(in_: CGRect): Set<any>;
  prepareLayout(): void;
  shouldInvalidateLayoutForChangeFromVisibleRectToVisibleRect(fromVisibleRect: CGRect, toVisibleRect: CGRect): boolean;
}

export class NSScrubberLayoutAttributes extends NSObject {
  alpha: number;
  setAlpha(_: number);
  frame: CGRect;
  setFrame(_: CGRect);
  itemIndex: number;
  setItemIndex(_: number);
}

export class NSScrubberProportionalLayout extends NSScrubberLayout {
  numberOfVisibleItems: number;
  setNumberOfVisibleItems(_: number);
  static initWithNumberOfVisibleItems(_: number): NSScrubberProportionalLayout;
}

export class NSScrubberSelectionStyle extends NSObject {
  static outlineOverlayStyle: NSScrubberSelectionStyle;
  static roundedBackgroundStyle: NSScrubberSelectionStyle;
  makeSelectionView(): NSScrubberSelectionView;
}

export class NSScrubberSelectionView extends NSScrubberArrangedView {
}

export class NSScrubberTextItemView extends NSScrubberItemView {
  textField: NSTextField;
  title: string;
  setTitle(_: string);
}

export class NSSearchField extends NSTextField {
  centersPlaceholder: boolean;
  setCentersPlaceholder(_: boolean);
  delegate: any;
  setDelegate(_: any);
  maximumRecents: number;
  setMaximumRecents(_: number);
  recentSearches: string[];
  setRecentSearches(_: string[]);
  recentsAutosaveName: string;
  setRecentsAutosaveName(_: string);
  searchMenuTemplate: NSMenu;
  setSearchMenuTemplate(_: NSMenu);
  sendsSearchStringImmediately: boolean;
  setSendsSearchStringImmediately(_: boolean);
  sendsWholeSearchString: boolean;
  setSendsWholeSearchString(_: boolean);
  rectForCancelButtonWhenCentered(whenCentered: boolean): CGRect;
  rectForSearchButtonWhenCentered(whenCentered: boolean): CGRect;
  rectForSearchTextWhenCentered(whenCentered: boolean): CGRect;
}

export class NSSearchFieldCell extends NSTextFieldCell {
  cancelButtonCell: NSButtonCell;
  setCancelButtonCell(_: NSButtonCell);
  maximumRecents: number;
  setMaximumRecents(_: number);
  recentSearches: string[];
  setRecentSearches(_: string[]);
  recentsAutosaveName: string;
  setRecentsAutosaveName(_: string);
  searchButtonCell: NSButtonCell;
  setSearchButtonCell(_: NSButtonCell);
  searchMenuTemplate: NSMenu;
  setSearchMenuTemplate(_: NSMenu);
  sendsSearchStringImmediately: boolean;
  setSendsSearchStringImmediately(_: boolean);
  sendsWholeSearchString: boolean;
  setSendsWholeSearchString(_: boolean);
  cancelButtonRectForBounds(forBounds: CGRect): CGRect;
  resetCancelButtonCell(): void;
  resetSearchButtonCell(): void;
  searchButtonRectForBounds(forBounds: CGRect): CGRect;
  searchTextRectForBounds(forBounds: CGRect): CGRect;
}

interface NSSearchFieldDelegate {
  searchFieldDidEndSearching(_: NSSearchField): void;
  searchFieldDidStartSearching(_: NSSearchField): void;
}

export class NSSecureTextField extends NSTextField {
}

export class NSSecureTextFieldCell extends NSTextFieldCell {
  echosBullets: boolean;
  setEchosBullets(_: boolean);
}

export class NSSegmentedCell extends NSActionCell {
  segmentCount: number;
  setSegmentCount(_: number);
  segmentStyle: NSSegmentedControl.Style;
  setSegmentStyle(_: NSSegmentedControl.Style);
  selectedSegment: number;
  setSelectedSegment(_: number);
  trackingMode: NSSegmentedControl.SwitchTracking;
  setTrackingMode(_: NSSegmentedControl.SwitchTracking);
  drawSegmentInFrameWithView(_: number, inFrame: CGRect, with_: NSView): void;
  imageScalingForSegment(forSegment: number): NSCell.NSImageScaling;
  isSelectedForSegment(forSegment: number): boolean;
  labelForSegment(forSegment: number): string;
  makeNextSegmentKey(): void;
  makePreviousSegmentKey(): void;
  selectSegmentWithTag(withTag: number): boolean;
  setEnabledForSegment(_: boolean, forSegment: number): void;
  setImageForSegment(_?: NSImage, forSegment?: number): void;
  setImageScalingForSegment(_: NSCell.NSImageScaling, forSegment: number): void;
  setLabelForSegment(_: string, forSegment: number): void;
  setMenuForSegment(_?: NSMenu, forSegment?: number): void;
  setSelectedForSegment(_: boolean, forSegment: number): void;
  setTagForSegment(_: number, forSegment: number): void;
  setToolTipForSegment(_?: string, forSegment?: number): void;
  setWidthForSegment(_: number, forSegment: number): void;
  toolTipForSegment(forSegment: number): string;
  widthForSegment(forSegment: number): number;
}

export class NSSegmentedControl extends NSControl {
  doubleValueForSelectedSegment: number;
  indexOfSelectedItem: number;
  segmentCount: number;
  setSegmentCount(_: number);
  segmentDistribution: NSSegmentedControl.Distribution;
  setSegmentDistribution(_: NSSegmentedControl.Distribution);
  segmentStyle: NSSegmentedControl.Style;
  setSegmentStyle(_: NSSegmentedControl.Style);
  selectedSegment: number;
  setSelectedSegment(_: number);
  selectedSegmentBezelColor: NSColor;
  setSelectedSegmentBezelColor(_: NSColor);
  isSpringLoaded: boolean;
  setSpringLoaded(_: boolean);
  trackingMode: NSSegmentedControl.SwitchTracking;
  setTrackingMode(_: NSSegmentedControl.SwitchTracking);
  imageForSegment(forSegment: number): NSImage;
  imageScalingForSegment(forSegment: number): NSCell.NSImageScaling;
  isSelectedForSegment(forSegment: number): boolean;
  labelForSegment(forSegment: number): string;
  selectSegmentWithTag(withTag: number): boolean;
  setAlignmentForSegment(_: NSText.NSTextAlignment, forSegment: number): void;
  setEnabledForSegment(_: boolean, forSegment: number): void;
  setImageForSegment(_?: NSImage, forSegment?: number): void;
  setImageScalingForSegment(_: NSCell.NSImageScaling, forSegment: number): void;
  setLabelForSegment(_: string, forSegment: number): void;
  setMenuForSegment(_?: NSMenu, forSegment?: number): void;
  setSelectedForSegment(_: boolean, forSegment: number): void;
  setShowsMenuIndicatorForSegment(_: boolean, forSegment: number): void;
  setTagForSegment(_: number, forSegment: number): void;
  setToolTipForSegment(_?: string, forSegment?: number): void;
  setWidthForSegment(_: number, forSegment: number): void;
  showsMenuIndicatorForSegment(forSegment: number): boolean;
  widthForSegment(forSegment: number): number;
}

interface NSSeguePerforming {
  performSegueWithIdentifierSender(withIdentifier: string, sender?: any): void;
  prepareForSegueSender(for_: NSStoryboardSegue, sender?: any): void;
  shouldPerformSegueWithIdentifierSender(withIdentifier: string, sender?: any): boolean;
}

interface NSServicesMenuRequestor {
  readSelectionFromPasteboard(from: NSPasteboard): boolean;
  writeSelectionToPasteboardTypes(to: NSPasteboard, types: string[]): boolean;
}

// export function NSSetFocusRingStyle(placement: NSGraphics.NSFocusRingPlacement): void;

// export function NSSetShowsServicesMenuItem(itemName: string, enabled: boolean): number;

export class NSShadow extends NSObject {
  shadowBlurRadius: number;
  setShadowBlurRadius(_: number);
  shadowColor: NSColor;
  setShadowColor(_: NSColor);
  shadowOffset: CGSize;
  setShadowOffset(_: CGSize);
  set(): void;
}

export class NSSharingService extends NSObject {
  static sharingServicesForItems(forItems: any[]): NSSharingService[];
  accountName: string;
  alternateImage: NSImage;
  attachmentFileURLs: URL[];
  delegate: any;
  setDelegate(_: any);
  image: NSImage;
  menuItemTitle: string;
  setMenuItemTitle(_: string);
  messageBody: string;
  permanentLink: URL;
  recipients: string[];
  setRecipients(_: string[]);
  subject: string;
  setSubject(_: string);
  title: string;
  canPerformWithItems(withItems?: any[]): boolean;
  static initWithTitleImageAlternateImageHandler(_: string, image: NSImage, alternateImage?: NSImage, handler?: () => void): NSSharingService;
  performWithItems(withItems: any[]): void;
}

interface NSSharingServiceDelegate {
  anchoringViewForSharingServiceShowRelativeToRectPreferredEdge(for_: NSSharingService, showRelativeTo: CGRect, preferredEdge: NSGeometry.NSRectEdge): NSView;
  sharingServiceWillShareItems(_: NSSharingService, willShareItems: any[]): void;
  sharingServiceDidFailToShareItemsError(_: NSSharingService, didFailToShareItems: any[], error: Error): void;
  sharingServiceDidShareItems(_: NSSharingService, didShareItems: any[]): void;
  sharingServiceSourceFrameOnScreenForShareItem(_: NSSharingService, sourceFrameOnScreenForShareItem: any): CGRect;
  sharingServiceTransitionImageForShareItemContentRect(_: NSSharingService, transitionImageForShareItem: any, contentRect: CGRect): NSImage;
  sharingServiceSourceWindowForShareItemsSharingContentScope(_: NSSharingService, sourceWindowForShareItems: any[], sharingContentScope: NSSharingService.SharingContentScope): NSWindow;
}

export class NSSharingServicePicker extends NSObject {
  delegate: any;
  setDelegate(_: any);
  static initWithItems(_: any[]): NSSharingServicePicker;
  showRelativeToRectOfViewPreferredEdge(relativeTo: CGRect, of: NSView, preferredEdge: NSGeometry.NSRectEdge): void;
}

interface NSSharingServicePickerDelegate {
  sharingServicePickerSharingServicesForItemsProposedSharingServices(_: NSSharingServicePicker, sharingServicesForItems: any[], proposedSharingServices: NSSharingService[]): NSSharingService[];
  sharingServicePickerDelegateForSharingService(_: NSSharingServicePicker, delegateFor: NSSharingService): any;
  sharingServicePickerDidChooseSharingService(_: NSSharingServicePicker, didChoose?: NSSharingService): void;
}

export class NSSharingServicePickerToolbarItem extends NSToolbarItem {
  delegate: any;
  setDelegate(_: any);
}

interface NSSharingServicePickerToolbarItemDelegate {
  itemsForSharingServicePickerToolbarItem(for_: NSSharingServicePickerToolbarItem): any[];
}

export class NSSharingServicePickerTouchBarItem extends NSTouchBarItem {
  buttonImage: NSImage;
  setButtonImage(_: NSImage);
  buttonTitle: string;
  setButtonTitle(_: string);
  delegate: any;
  setDelegate(_: any);
  isEnabled: boolean;
  setEnabled(_: boolean);
}

interface NSSharingServicePickerTouchBarItemDelegate {
  itemsForSharingServicePickerTouchBarItem(for_: NSSharingServicePickerTouchBarItem): any[];
}

// export function NSShowAnimationEffect(animationEffect: NSGraphics.NSAnimationEffect, centerLocation: CGPoint, size: CGSize, animationDelegate: any, didEndSelector: string, contextInfo: any): void;

// export function NSShowsServicesMenuItem(itemName: string): boolean;

export class NSSlider extends NSControl {
  allowsTickMarkValuesOnly: boolean;
  setAllowsTickMarkValuesOnly(_: boolean);
  altIncrementValue: number;
  setAltIncrementValue(_: number);
  knobThickness: number;
  maxValue: number;
  setMaxValue(_: number);
  minValue: number;
  setMinValue(_: number);
  numberOfTickMarks: number;
  setNumberOfTickMarks(_: number);
  sliderType: NSSliderCell.NSSlider.SliderType;
  setSliderType(_: NSSliderCell.NSSlider.SliderType);
  tickMarkPosition: NSSliderCell.NSSlider.TickMarkPosition;
  setTickMarkPosition(_: NSSliderCell.NSSlider.TickMarkPosition);
  trackFillColor: NSColor;
  setTrackFillColor(_: NSColor);
  isVertical: boolean;
  closestTickMarkValueToValue(toValue: number): number;
  indexOfTickMarkAtPoint(at: CGPoint): number;
  rectOfTickMarkAtIndex(at: number): CGRect;
  tickMarkValueAtIndex(at: number): number;
}

export class NSSliderAccessory extends NSObject {
  behavior: NSSliderAccessoryBehavior;
  setBehavior(_: NSSliderAccessoryBehavior);
  isEnabled: boolean;
  setEnabled(_: boolean);
}

export class NSSliderAccessoryBehavior extends NSObject {
  static automaticBehavior: NSSliderAccessoryBehavior;
  static valueResetBehavior: NSSliderAccessoryBehavior;
  static valueStepBehavior: NSSliderAccessoryBehavior;
  handleAction(_: NSSliderAccessory): void;
}

export class NSSliderCell extends NSActionCell {
  allowsTickMarkValuesOnly: boolean;
  setAllowsTickMarkValuesOnly(_: boolean);
  altIncrementValue: number;
  setAltIncrementValue(_: number);
  knobThickness: number;
  maxValue: number;
  setMaxValue(_: number);
  minValue: number;
  setMinValue(_: number);
  numberOfTickMarks: number;
  setNumberOfTickMarks(_: number);
  sliderType: NSSliderCell.NSSlider.SliderType;
  setSliderType(_: NSSliderCell.NSSlider.SliderType);
  tickMarkPosition: NSSliderCell.NSSlider.TickMarkPosition;
  setTickMarkPosition(_: NSSliderCell.NSSlider.TickMarkPosition);
  trackRect: CGRect;
  isVertical: boolean;
  barRectFlipped(flipped: boolean): CGRect;
  closestTickMarkValueToValue(toValue: number): number;
  drawBarInsideFlipped(inside: CGRect, flipped: boolean): void;
  drawKnob(): void;
  drawKnob(_: CGRect): void;
  drawTickMarks(): void;
  indexOfTickMarkAtPoint(at: CGPoint): number;
  knobRectFlipped(flipped: boolean): CGRect;
  rectOfTickMarkAtIndex(at: number): CGRect;
  tickMarkValueAtIndex(at: number): number;
}

export class NSSliderTouchBarItem extends NSTouchBarItem {
  action: string;
  setAction(_: string);
  customizationLabel: string;
  setCustomizationLabel(_: string);
  doubleValue: number;
  setDoubleValue(_: number);
  label: string;
  setLabel(_: string);
  maximumSliderWidth: number;
  setMaximumSliderWidth(_: number);
  maximumValueAccessory: NSSliderAccessory;
  setMaximumValueAccessory(_: NSSliderAccessory);
  minimumSliderWidth: number;
  setMinimumSliderWidth(_: number);
  minimumValueAccessory: NSSliderAccessory;
  setMinimumValueAccessory(_: NSSliderAccessory);
  slider: NSSlider;
  setSlider(_: NSSlider);
  target: any;
  setTarget(_: any);
  valueAccessoryWidth: number;
  setValueAccessoryWidth(_: number);
}

export class NSSound extends NSObject {
  static canInitWithPasteboard(with_: NSPasteboard): boolean;
  currentTime: number;
  setCurrentTime(_: number);
  delegate: any;
  setDelegate(_: any);
  duration: number;
  loops: boolean;
  setLoops(_: boolean);
  name: string;
  playbackDeviceIdentifier: string;
  setPlaybackDeviceIdentifier(_: string);
  isPlaying: boolean;
  volume: number;
  setVolume(_: number);
  static soundUnfilteredTypes: string[];
  static initWithContentsOfFileByReference(_: string, byReference: boolean): NSSound;
  static initWithContentsOfURLByReference(_: URL, byReference: boolean): NSSound;
  static initWithData(_: Data): NSSound;
  static initWithPasteboard(_: NSPasteboard): NSSound;
  pause(): boolean;
  play(): boolean;
  resume(): boolean;
  setName(_?: string): boolean;
  stop(): boolean;
  writeToPasteboard(to: NSPasteboard): void;
}

interface NSSoundDelegate {
  soundDidFinishPlaying(_: NSSound, didFinishPlaying: boolean): void;
}

export class NSSpeechRecognizer extends NSObject {
  blocksOtherRecognizers: boolean;
  setBlocksOtherRecognizers(_: boolean);
  commands: string[];
  setCommands(_: string[]);
  delegate: any;
  setDelegate(_: any);
  displayedCommandsTitle: string;
  setDisplayedCommandsTitle(_: string);
  listensInForegroundOnly: boolean;
  setListensInForegroundOnly(_: boolean);
  startListening(): void;
  stopListening(): void;
}

interface NSSpeechRecognizerDelegate {
  speechRecognizerDidRecognizeCommand(_: NSSpeechRecognizer, didRecognizeCommand: string): void;
}

export class NSSpeechSynthesizer extends NSObject {
  static attributesForVoice(forVoice: string): Map<string, any>;
  delegate: any;
  setDelegate(_: any);
  rate: number;
  setRate(_: number);
  isSpeaking: boolean;
  usesFeedbackWindow: boolean;
  setUsesFeedbackWindow(_: boolean);
  volume: number;
  setVolume(_: number);
  static isAnyApplicationSpeaking: boolean;
  static availableVoices: string[];
  static defaultVoice: string;
  addSpeechDictionary(_: Map<string, any>): void;
  continueSpeaking(): void;
  static initWithVoice(_?: string): NSSpeechSynthesizer;
  objectForProperty(error: string): any;
  pauseSpeakingAtBoundary(at: NSSpeechSynthesizer.Boundary): void;
  phonemesFromText(from: string): string;
  setObjectForProperty(forProperty?: any, error?: string): boolean;
  setVoice(_?: string): boolean;
  startSpeakingString(_: string): boolean;
  startSpeakingStringToURL(_: string, to: URL): boolean;
  stopSpeaking(): void;
  stopSpeakingAtBoundary(at: NSSpeechSynthesizer.Boundary): void;
  voice(): string;
}

interface NSSpeechSynthesizerDelegate {
  speechSynthesizerDidFinishSpeaking(_: NSSpeechSynthesizer, didFinishSpeaking: boolean): void;
  speechSynthesizerWillSpeakWordOfString(_: NSSpeechSynthesizer, willSpeakWord: NSRange, of: string): void;
  speechSynthesizerWillSpeakPhoneme(_: NSSpeechSynthesizer, willSpeakPhoneme: number): void;
  speechSynthesizerDidEncounterErrorAtIndexOfStringMessage(_: NSSpeechSynthesizer, didEncounterErrorAt: number, of: string, message: string): void;
  speechSynthesizerDidEncounterSyncMessage(_: NSSpeechSynthesizer, didEncounterSyncMessage: string): void;
}

export class NSSpellChecker extends NSObject {
  static uniqueSpellDocumentTag(): number;
  accessoryView: NSView;
  setAccessoryView(_: NSView);
  automaticallyIdentifiesLanguages: boolean;
  setAutomaticallyIdentifiesLanguages(_: boolean);
  availableLanguages: string[];
  spellingPanel: NSPanel;
  substitutionsPanel: NSPanel;
  substitutionsPanelAccessoryViewController: NSViewController;
  setSubstitutionsPanelAccessoryViewController(_: NSViewController);
  userPreferredLanguages: string[];
  userReplacementsDictionary: Map<string, string>;
  static isAutomaticCapitalizationEnabled: boolean;
  static isAutomaticDashSubstitutionEnabled: boolean;
  static isAutomaticPeriodSubstitutionEnabled: boolean;
  static isAutomaticQuoteSubstitutionEnabled: boolean;
  static isAutomaticSpellingCorrectionEnabled: boolean;
  static isAutomaticTextCompletionEnabled: boolean;
  static isAutomaticTextReplacementEnabled: boolean;
  static sharedSpellChecker: NSSpellChecker;
  static sharedSpellCheckerExists: boolean;
  checkGrammarOfStringStartingAtLanguageWrapInSpellDocumentWithTagDetails(of: string, startingAt: number, language?: string, wrap?: boolean, inSpellDocumentWithTag?: number, details?: Map<string, any>[]): NSRange;
  checkSpellingOfStringStartingAt(of: string, startingAt: number): NSRange;
  checkSpellingOfStringStartingAtLanguageWrapInSpellDocumentWithTagWordCount(of: string, startingAt: number, language?: string, wrap?: boolean, inSpellDocumentWithTag?: number, wordCount?: number): NSRange;
  checkStringRangeTypesOptionsInSpellDocumentWithTagOrthographyWordCount(_: string, range: NSRange, types: number, options?: Map<string, any>, inSpellDocumentWithTag?: number, orthography?: NSOrthography, wordCount?: number): NSTextCheckingResult[];
  closeSpellDocumentWithTag(withTag: number): void;
  completionsForPartialWordRangeInStringLanguageInSpellDocumentWithTag(forPartialWordRange: NSRange, in_: string, language?: string, inSpellDocumentWithTag?: number): string[];
  correctionForWordRangeInStringLanguageInSpellDocumentWithTag(forWordRange: NSRange, in_: string, language: string, inSpellDocumentWithTag: number): string;
  countWordsInStringLanguage(in_: string, language?: string): number;
  deletesAutospaceBetweenStringAndStringLanguage(_: string, andString: string, language?: string): boolean;
  dismissCorrectionIndicatorForView(for_: NSView): void;
  guessesForWordRangeInStringLanguageInSpellDocumentWithTag(forWordRange: NSRange, in_: string, language?: string, inSpellDocumentWithTag?: number): string[];
  hasLearnedWord(_: string): boolean;
  ignoreWordInSpellDocumentWithTag(_: string, inSpellDocumentWithTag: number): void;
  ignoredWordsInSpellDocumentWithTag(inSpellDocumentWithTag: number): string[];
  language(): string;
  languageForWordRangeInStringOrthography(forWordRange: NSRange, in_: string, orthography?: NSOrthography): string;
  learnWord(_: string): void;
  menuForResultStringOptionsAtLocationInView(for_: NSTextCheckingResult, string: string, options?: Map<string, any>, atLocation?: CGPoint, in_?: NSView): NSMenu;
  preventsAutocorrectionBeforeStringLanguage(before: string, language?: string): boolean;
  recordResponseToCorrectionForWordLanguageInSpellDocumentWithTag(_: NSSpellChecker.CorrectionResponse, toCorrection: string, forWord: string, language?: string, inSpellDocumentWithTag?: number): void;
  requestCandidatesForSelectedRangeInStringTypesOptionsInSpellDocumentWithTagCompletionHandler(forSelectedRange: NSRange, in_: string, types: number, options?: Map<string, any>, inSpellDocumentWithTag?: number, completionHandler?: (p1: number, p2: NSTextCheckingResult[]) => void): number;
  requestCheckingOfStringRangeTypesOptionsInSpellDocumentWithTagCompletionHandler(of: string, range: NSRange, types: number, options?: Map<string, any>, inSpellDocumentWithTag?: number, completionHandler?: (p1: number, p2: NSTextCheckingResult[], p3: NSOrthography, p4: number) => void): number;
  setIgnoredWordsInSpellDocumentWithTag(_: string[], inSpellDocumentWithTag: number): void;
  setLanguage(_: string): boolean;
  setWordFieldStringValue(_: string): void;
  showCorrectionIndicatorOfTypePrimaryStringAlternativeStringsForStringInRectViewCompletionHandler(of: NSSpellChecker.CorrectionIndicatorType, primaryString: string, alternativeStrings: string[], forStringIn: CGRect, view: NSView, completionHandler?: (p1: string) => void): void;
  unlearnWord(_: string): void;
  updatePanels(): void;
  updateSpellingPanelWithGrammarStringDetail(withGrammarString: string, detail: Map<string, any>): void;
  updateSpellingPanelWithMisspelledWord(withMisspelledWord: string): void;
  userQuotesArrayForLanguage(forLanguage: string): string[];
}

export class NSSplitView extends NSView {
  arrangedSubviews: NSView[];
  arrangesAllSubviews: boolean;
  setArrangesAllSubviews(_: boolean);
  autosaveName: string;
  setAutosaveName(_: string);
  delegate: any;
  setDelegate(_: any);
  dividerColor: NSColor;
  dividerStyle: NSSplitView.DividerStyle;
  setDividerStyle(_: NSSplitView.DividerStyle);
  dividerThickness: number;
  isVertical: boolean;
  setVertical(_: boolean);
  addArrangedSubview(_: NSView): void;
  adjustSubviews(): void;
  drawDividerInRect(in_: CGRect): void;
  holdingPriorityForSubviewAtIndex(at: number): number;
  insertArrangedSubviewAtIndex(_: NSView, at: number): void;
  isSubviewCollapsed(_: NSView): boolean;
  maxPossiblePositionOfDividerAtIndex(at: number): number;
  minPossiblePositionOfDividerAtIndex(at: number): number;
  removeArrangedSubview(_: NSView): void;
  setHoldingPriorityForSubviewAtIndex(_: number, forSubviewAt: number): void;
  setPositionOfDividerAtIndex(_: number, ofDividerAt: number): void;
}

export class NSSplitViewController extends NSViewController {
  minimumThicknessForInlineSidebars: number;
  setMinimumThicknessForInlineSidebars(_: number);
  splitView: NSSplitView;
  setSplitView(_: NSSplitView);
  splitViewItems: NSSplitViewItem[];
  setSplitViewItems(_: NSSplitViewItem[]);
  addSplitViewItem(_: NSSplitViewItem): void;
  insertSplitViewItemAtIndex(_: NSSplitViewItem, at: number): void;
  removeSplitViewItem(_: NSSplitViewItem): void;
  splitViewItemForViewController(for_: NSViewController): NSSplitViewItem;
  toggleSidebar(_?: any): void;
}

interface NSSplitViewDelegate {
  splitViewCanCollapseSubview(_: NSSplitView, canCollapseSubview: NSView): boolean;
  splitViewConstrainMinCoordinateOfSubviewAt(_: NSSplitView, constrainMinCoordinate: number, ofSubviewAt: number): number;
  splitViewConstrainMaxCoordinateOfSubviewAt(_: NSSplitView, constrainMaxCoordinate: number, ofSubviewAt: number): number;
  splitViewConstrainSplitPositionOfSubviewAt(_: NSSplitView, constrainSplitPosition: number, ofSubviewAt: number): number;
  splitViewResizeSubviewsWithOldSize(_: NSSplitView, resizeSubviewsWithOldSize: CGSize): void;
  splitViewShouldAdjustSizeOfSubview(_: NSSplitView, shouldAdjustSizeOfSubview: NSView): boolean;
  splitViewShouldHideDividerAtIndex(_: NSSplitView, shouldHideDividerAt: number): boolean;
  splitViewEffectiveRectForDrawnRectOfDividerAtIndex(_: NSSplitView, effectiveRect: CGRect, forDrawnRect: CGRect, ofDividerAt: number): CGRect;
  splitViewAdditionalEffectiveRectOfDividerAtIndex(_: NSSplitView, additionalEffectiveRectOfDividerAt: number): CGRect;
  splitViewDidResizeSubviews(_: Notification): void;
  splitViewWillResizeSubviews(_: Notification): void;
}

export class NSSplitViewItem extends NSObject {
  automaticMaximumThickness: number;
  setAutomaticMaximumThickness(_: number);
  behavior: NSSplitViewItem.Behavior;
  canCollapse: boolean;
  setCanCollapse(_: boolean);
  collapseBehavior: NSSplitViewItem.CollapseBehavior;
  setCollapseBehavior(_: NSSplitViewItem.CollapseBehavior);
  isCollapsed: boolean;
  setCollapsed(_: boolean);
  holdingPriority: number;
  setHoldingPriority(_: number);
  maximumThickness: number;
  setMaximumThickness(_: number);
  minimumThickness: number;
  setMinimumThickness(_: number);
  preferredThicknessFraction: number;
  setPreferredThicknessFraction(_: number);
  isSpringLoaded: boolean;
  setSpringLoaded(_: boolean);
  viewController: NSViewController;
  setViewController(_: NSViewController);
}

interface NSSpringLoadingDestination {
  draggingEnded(_: any): void;
  springLoadingActivatedDraggingInfo(_: boolean, draggingInfo: any): void;
  springLoadingEntered(_: any): NSDragging.NSSpringLoadingOptions;
  springLoadingExited(_: any): void;
  springLoadingHighlightChanged(_: any): void;
  springLoadingUpdated(_: any): NSDragging.NSSpringLoadingOptions;
}

export class NSStackView extends NSView {
  alignment: NSLayoutConstraint.Attribute;
  setAlignment(_: NSLayoutConstraint.Attribute);
  arrangedSubviews: NSView[];
  delegate: any;
  setDelegate(_: any);
  detachedViews: NSView[];
  detachesHiddenViews: boolean;
  setDetachesHiddenViews(_: boolean);
  distribution: NSStackView.Distribution;
  setDistribution(_: NSStackView.Distribution);
  edgeInsets: NSEdgeInsets;
  setEdgeInsets(_: NSEdgeInsets);
  orientation: NSUserInterfaceLayout.NSUserInterfaceLayoutOrientation;
  setOrientation(_: NSUserInterfaceLayout.NSUserInterfaceLayoutOrientation);
  spacing: number;
  setSpacing(_: number);
  views: NSView[];
  addArrangedSubview(_: NSView): void;
  addViewInGravity(_: NSView, in_: NSStackView.Gravity): void;
  clippingResistancePriorityForOrientation(for_: NSLayoutConstraint.Orientation): number;
  customSpacingAfterView(after: NSView): number;
  huggingPriorityForOrientation(for_: NSLayoutConstraint.Orientation): number;
  insertArrangedSubviewAtIndex(_: NSView, at: number): void;
  insertViewAtIndexInGravity(_: NSView, at: number, in_: NSStackView.Gravity): void;
  removeArrangedSubview(_: NSView): void;
  removeView(_: NSView): void;
  setClippingResistancePriorityForOrientation(_: number, for_: NSLayoutConstraint.Orientation): void;
  setCustomSpacingAfterView(_: number, after: NSView): void;
  setHuggingPriorityForOrientation(_: number, for_: NSLayoutConstraint.Orientation): void;
  setViewsInGravity(_: NSView[], in_: NSStackView.Gravity): void;
  setVisibilityPriorityForView(_: number, for_: NSView): void;
  // dupe name w instance property   viewsInGravity(in_: NSStackView.Gravity): NSView[];
  visibilityPriorityForView(for_: NSView): number;
}

interface NSStackViewDelegate {
  stackViewWillDetachViews(_: NSStackView, willDetach: NSView[]): void;
  stackViewDidReattachViews(_: NSStackView, didReattach: NSView[]): void;
}

interface NSStandardKeyBindingResponding {
  cancelOperation(_?: any): void;
  capitalizeWord(_?: any): void;
  centerSelectionInVisibleArea(_?: any): void;
  changeCaseOfLetter(_?: any): void;
  complete(_?: any): void;
  deleteBackward(_?: any): void;
  deleteBackwardByDecomposingPreviousCharacter(_?: any): void;
  deleteForward(_?: any): void;
  deleteToBeginningOfLine(_?: any): void;
  deleteToBeginningOfParagraph(_?: any): void;
  deleteToEndOfLine(_?: any): void;
  deleteToEndOfParagraph(_?: any): void;
  deleteToMark(_?: any): void;
  deleteWordBackward(_?: any): void;
  deleteWordForward(_?: any): void;
  doCommandBySelector(by: string): void;
  indent(_?: any): void;
  insertBacktab(_?: any): void;
  insertContainerBreak(_?: any): void;
  insertDoubleQuoteIgnoringSubstitution(_?: any): void;
  insertLineBreak(_?: any): void;
  insertNewline(_?: any): void;
  insertNewlineIgnoringFieldEditor(_?: any): void;
  insertParagraphSeparator(_?: any): void;
  insertSingleQuoteIgnoringSubstitution(_?: any): void;
  insertTab(_?: any): void;
  insertTabIgnoringFieldEditor(_?: any): void;
  insertText(_: any): void;
  lowercaseWord(_?: any): void;
  makeBaseWritingDirectionLeftToRight(_?: any): void;
  makeBaseWritingDirectionNatural(_?: any): void;
  makeBaseWritingDirectionRightToLeft(_?: any): void;
  makeTextWritingDirectionLeftToRight(_?: any): void;
  makeTextWritingDirectionNatural(_?: any): void;
  makeTextWritingDirectionRightToLeft(_?: any): void;
  moveBackward(_?: any): void;
  moveBackwardAndModifySelection(_?: any): void;
  moveDown(_?: any): void;
  moveDownAndModifySelection(_?: any): void;
  moveForward(_?: any): void;
  moveForwardAndModifySelection(_?: any): void;
  moveLeft(_?: any): void;
  moveLeftAndModifySelection(_?: any): void;
  moveParagraphBackwardAndModifySelection(_?: any): void;
  moveParagraphForwardAndModifySelection(_?: any): void;
  moveRight(_?: any): void;
  moveRightAndModifySelection(_?: any): void;
  moveToBeginningOfDocument(_?: any): void;
  moveToBeginningOfDocumentAndModifySelection(_?: any): void;
  moveToBeginningOfLine(_?: any): void;
  moveToBeginningOfLineAndModifySelection(_?: any): void;
  moveToBeginningOfParagraph(_?: any): void;
  moveToBeginningOfParagraphAndModifySelection(_?: any): void;
  moveToEndOfDocument(_?: any): void;
  moveToEndOfDocumentAndModifySelection(_?: any): void;
  moveToEndOfLine(_?: any): void;
  moveToEndOfLineAndModifySelection(_?: any): void;
  moveToEndOfParagraph(_?: any): void;
  moveToEndOfParagraphAndModifySelection(_?: any): void;
  moveToLeftEndOfLine(_?: any): void;
  moveToLeftEndOfLineAndModifySelection(_?: any): void;
  moveToRightEndOfLine(_?: any): void;
  moveToRightEndOfLineAndModifySelection(_?: any): void;
  moveUp(_?: any): void;
  moveUpAndModifySelection(_?: any): void;
  moveWordBackward(_?: any): void;
  moveWordBackwardAndModifySelection(_?: any): void;
  moveWordForward(_?: any): void;
  moveWordForwardAndModifySelection(_?: any): void;
  moveWordLeft(_?: any): void;
  moveWordLeftAndModifySelection(_?: any): void;
  moveWordRight(_?: any): void;
  moveWordRightAndModifySelection(_?: any): void;
  pageDown(_?: any): void;
  pageDownAndModifySelection(_?: any): void;
  pageUp(_?: any): void;
  pageUpAndModifySelection(_?: any): void;
  quickLookPreviewItems(_?: any): void;
  scrollLineDown(_?: any): void;
  scrollLineUp(_?: any): void;
  scrollPageDown(_?: any): void;
  scrollPageUp(_?: any): void;
  scrollToBeginningOfDocument(_?: any): void;
  scrollToEndOfDocument(_?: any): void;
  selectAll(_?: any): void;
  selectLine(_?: any): void;
  selectParagraph(_?: any): void;
  selectToMark(_?: any): void;
  selectWord(_?: any): void;
  setMark(_?: any): void;
  swapWithMark(_?: any): void;
  transpose(_?: any): void;
  transposeWords(_?: any): void;
  uppercaseWord(_?: any): void;
  yank(_?: any): void;
}

export class NSStatusBar extends NSObject {
  thickness: number;
  isVertical: boolean;
  static systemStatusBar: NSStatusBar;
  removeStatusItem(_: NSStatusItem): void;
  statusItemWithLength(withLength: number): NSStatusItem;
}

export class NSStatusBarButton extends NSButton {
  appearsDisabled: boolean;
  setAppearsDisabled(_: boolean);
}

export class NSStatusItem extends NSObject {
  autosaveName: string;
  setAutosaveName(_: string);
  behavior: NSStatusItem.Behavior;
  setBehavior(_: NSStatusItem.Behavior);
  button: NSStatusBarButton;
  length: number;
  setLength(_: number);
  menu: NSMenu;
  setMenu(_: NSMenu);
  statusBar: NSStatusBar;
  isVisible: boolean;
  setVisible(_: boolean);
}

export class NSStepper extends NSControl {
  autorepeat: boolean;
  setAutorepeat(_: boolean);
  increment: number;
  setIncrement(_: number);
  maxValue: number;
  setMaxValue(_: number);
  minValue: number;
  setMinValue(_: number);
  valueWraps: boolean;
  setValueWraps(_: boolean);
}

export class NSStepperCell extends NSActionCell {
  autorepeat: boolean;
  setAutorepeat(_: boolean);
  increment: number;
  setIncrement(_: number);
  maxValue: number;
  setMaxValue(_: number);
  minValue: number;
  setMinValue(_: number);
  valueWraps: boolean;
  setValueWraps(_: boolean);
}

export class NSStepperTouchBarItem extends NSTouchBarItem {
  action: string;
  setAction(_: string);
  customizationLabel: string;
  setCustomizationLabel(_: string);
  increment: number;
  setIncrement(_: number);
  maxValue: number;
  setMaxValue(_: number);
  minValue: number;
  setMinValue(_: number);
  target: any;
  setTarget(_: any);
}

export class NSStoryboard extends NSObject {
  static mainStoryboard: NSStoryboard;
  instantiateControllerWithIdentifier(withIdentifier: string): any;
  instantiateControllerWithIdentifierCreator(_: string, creator?: (p1: NSCoder) => any): any;
  instantiateInitialController(): any;
  instantiateInitialControllerWithCreator(_?: (p1: NSCoder) => any): any;
}

export class NSStoryboardSegue extends NSObject {
  destinationController: any;
  identifier: string;
  sourceController: any;
  static initWithIdentifierSourceDestination(_: string, source: any, destination: any): NSStoryboardSegue;
  perform(): void;
}

export class NSStringDrawingContext extends NSObject {
  actualScaleFactor: number;
  minimumScaleFactor: number;
  setMinimumScaleFactor(_: number);
  totalBounds: CGRect;
}

export class NSSwitch extends NSControl {
  state: number;
  setState(_: number);
}

export class NSTabView extends NSView {
  allowsTruncatedLabels: boolean;
  setAllowsTruncatedLabels(_: boolean);
  contentRect: CGRect;
  controlSize: NSCell.NSControl.ControlSize;
  setControlSize(_: NSCell.NSControl.ControlSize);
  delegate: any;
  setDelegate(_: any);
  drawsBackground: boolean;
  setDrawsBackground(_: boolean);
  font: NSFont;
  setFont(_: NSFont);
  minimumSize: CGSize;
  numberOfTabViewItems: number;
  selectedTabViewItem: NSTabViewItem;
  tabPosition: NSTabView.TabPosition;
  setTabPosition(_: NSTabView.TabPosition);
  tabViewBorderType: NSTabView.TabViewBorderType;
  setTabViewBorderType(_: NSTabView.TabViewBorderType);
  tabViewItems: NSTabViewItem[];
  setTabViewItems(_: NSTabViewItem[]);
  tabViewType: NSTabView.TabType;
  setTabViewType(_: NSTabView.TabType);
  addTabViewItem(_: NSTabViewItem): void;
  indexOfTabViewItem(_: NSTabViewItem): number;
  indexOfTabViewItemWithIdentifier(withIdentifier: any): number;
  insertTabViewItemAtIndex(_: NSTabViewItem, at: number): void;
  removeTabViewItem(_: NSTabViewItem): void;
  selectFirstTabViewItem(_?: any): void;
  selectLastTabViewItem(_?: any): void;
  selectNextTabViewItem(_?: any): void;
  selectPreviousTabViewItem(_?: any): void;
  selectTabViewItem(_?: NSTabViewItem): void;
  selectTabViewItemAtIndex(at: number): void;
  selectTabViewItemWithIdentifier(withIdentifier: any): void;
  tabViewItemAtIndex(at: number): NSTabViewItem;
  tabViewItemAtPoint(at: CGPoint): NSTabViewItem;
  takeSelectedTabViewItemFromSender(_?: any): void;
}

export class NSTabViewController extends NSViewController {
  canPropagateSelectedChildViewControllerTitle: boolean;
  setCanPropagateSelectedChildViewControllerTitle(_: boolean);
  selectedTabViewItemIndex: number;
  setSelectedTabViewItemIndex(_: number);
  tabStyle: NSTabViewController.TabStyle;
  setTabStyle(_: NSTabViewController.TabStyle);
  tabView: NSTabView;
  setTabView(_: NSTabView);
  tabViewItems: NSTabViewItem[];
  setTabViewItems(_: NSTabViewItem[]);
  transitionOptions: NSViewController.TransitionOptions;
  setTransitionOptions(_: NSViewController.TransitionOptions);
  addTabViewItem(_: NSTabViewItem): void;
  insertTabViewItemAtIndex(_: NSTabViewItem, at: number): void;
  removeTabViewItem(_: NSTabViewItem): void;
  tabViewItemForViewController(for_: NSViewController): NSTabViewItem;
}

interface NSTabViewDelegate {
  tabViewShouldSelectTabViewItem(_: NSTabView, shouldSelect?: NSTabViewItem): boolean;
  tabViewWillSelectTabViewItem(_: NSTabView, willSelect?: NSTabViewItem): void;
  tabViewDidSelectTabViewItem(_: NSTabView, didSelect?: NSTabViewItem): void;
  tabViewDidChangeNumberOfTabViewItems(_: NSTabView): void;
}

export class NSTabViewItem extends NSObject {
  color: NSColor;
  setColor(_: NSColor);
  identifier: any;
  setIdentifier(_: any);
  image: NSImage;
  setImage(_: NSImage);
  initialFirstResponder: NSView;
  setInitialFirstResponder(_: NSView);
  label: string;
  setLabel(_: string);
  tabState: NSTabViewItem.State;
  tabView: NSTabView;
  toolTip: string;
  setToolTip(_: string);
  viewController: NSViewController;
  setViewController(_: NSViewController);
  drawLabelInRect(_: boolean, in_: CGRect): void;
  static initWithIdentifier(_?: any): NSTabViewItem;
  sizeOfLabel(_: boolean): CGSize;
}

export class NSTableCellView extends NSView {
  backgroundStyle: NSCell.NSView.BackgroundStyle;
  setBackgroundStyle(_: NSCell.NSView.BackgroundStyle);
  draggingImageComponents: NSDraggingImageComponent[];
  imageView: NSImageView;
  setImageView(_: NSImageView);
  objectValue: any;
  setObjectValue(_: any);
  rowSizeStyle: NSTableView.RowSizeStyle;
  setRowSizeStyle(_: NSTableView.RowSizeStyle);
  textField: NSTextField;
  setTextField(_: NSTextField);
}

export class NSTableColumn extends NSObject implements NSUserInterfaceItemIdentification {
  dataCell: any;
  setDataCell(_: any);
  isEditable: boolean;
  setEditable(_: boolean);
  headerCell: NSTableHeaderCell;
  setHeaderCell(_: NSTableHeaderCell);
  headerToolTip: string;
  setHeaderToolTip(_: string);
  isHidden: boolean;
  setHidden(_: boolean);
  maxWidth: number;
  setMaxWidth(_: number);
  minWidth: number;
  setMinWidth(_: number);
  resizingMask: NSTableColumn.ResizingOptions;
  setResizingMask(_: NSTableColumn.ResizingOptions);
  sortDescriptorPrototype: NSSortDescriptor;
  setSortDescriptorPrototype(_: NSSortDescriptor);
  tableView: NSTableView;
  setTableView(_: NSTableView);
  title: string;
  setTitle(_: string);
  width: number;
  setWidth(_: number);
  identifier: string;
  setIdentifier(_: string);
  // dupe name w instance property   dataCellForRow(forRow: number): any;
  static initWithIdentifier(_: string): NSTableColumn;
  sizeToFit(): void;
}

export class NSTableHeaderCell extends NSTextFieldCell {
  drawSortIndicatorWithFrameInViewAscendingPriority(withFrame: CGRect, in_: NSView, ascending: boolean, priority: number): void;
  sortIndicatorRectForBounds(forBounds: CGRect): CGRect;
}

export class NSTableHeaderView extends NSView {
  draggedColumn: number;
  draggedDistance: number;
  resizedColumn: number;
  tableView: NSTableView;
  setTableView(_: NSTableView);
  columnAtPoint(at: CGPoint): number;
  headerRectOfColumn(ofColumn: number): CGRect;
}

export class NSTableRowView extends NSView {
  backgroundColor: NSColor;
  setBackgroundColor(_: NSColor);
  draggingDestinationFeedbackStyle: NSTableView.DraggingDestinationFeedbackStyle;
  setDraggingDestinationFeedbackStyle(_: NSTableView.DraggingDestinationFeedbackStyle);
  isEmphasized: boolean;
  setEmphasized(_: boolean);
  isFloating: boolean;
  setFloating(_: boolean);
  isGroupRowStyle: boolean;
  setGroupRowStyle(_: boolean);
  indentationForDropOperation: number;
  setIndentationForDropOperation(_: number);
  interiorBackgroundStyle: NSCell.NSView.BackgroundStyle;
  isNextRowSelected: boolean;
  setNextRowSelected(_: boolean);
  numberOfColumns: number;
  isPreviousRowSelected: boolean;
  setPreviousRowSelected(_: boolean);
  isSelected: boolean;
  setSelected(_: boolean);
  selectionHighlightStyle: NSTableView.SelectionHighlightStyle;
  setSelectionHighlightStyle(_: NSTableView.SelectionHighlightStyle);
  isTargetForDropOperation: boolean;
  setTargetForDropOperation(_: boolean);
  drawBackgroundInRect(in_: CGRect): void;
  drawDraggingDestinationFeedbackInRect(in_: CGRect): void;
  drawSelectionInRect(in_: CGRect): void;
  drawSeparatorInRect(in_: CGRect): void;
  viewAtColumn(atColumn: number): any;
}

export class NSTableView extends NSControl {
  allowsColumnReordering: boolean;
  setAllowsColumnReordering(_: boolean);
  allowsColumnResizing: boolean;
  setAllowsColumnResizing(_: boolean);
  allowsColumnSelection: boolean;
  setAllowsColumnSelection(_: boolean);
  allowsEmptySelection: boolean;
  setAllowsEmptySelection(_: boolean);
  allowsMultipleSelection: boolean;
  setAllowsMultipleSelection(_: boolean);
  allowsTypeSelect: boolean;
  setAllowsTypeSelect(_: boolean);
  autosaveName: string;
  setAutosaveName(_: string);
  autosaveTableColumns: boolean;
  setAutosaveTableColumns(_: boolean);
  backgroundColor: NSColor;
  setBackgroundColor(_: NSColor);
  clickedColumn: number;
  clickedRow: number;
  columnAutoresizingStyle: NSTableView.ColumnAutoresizingStyle;
  setColumnAutoresizingStyle(_: NSTableView.ColumnAutoresizingStyle);
  cornerView: NSView;
  setCornerView(_: NSView);
  dataSource: any;
  setDataSource(_: any);
  delegate: any;
  setDelegate(_: any);
  doubleAction: string;
  setDoubleAction(_: string);
  draggingDestinationFeedbackStyle: NSTableView.DraggingDestinationFeedbackStyle;
  setDraggingDestinationFeedbackStyle(_: NSTableView.DraggingDestinationFeedbackStyle);
  editedColumn: number;
  editedRow: number;
  effectiveRowSizeStyle: NSTableView.RowSizeStyle;
  floatsGroupRows: boolean;
  setFloatsGroupRows(_: boolean);
  gridColor: NSColor;
  setGridColor(_: NSColor);
  gridStyleMask: NSTableView.GridLineStyle;
  setGridStyleMask(_: NSTableView.GridLineStyle);
  headerView: NSTableHeaderView;
  setHeaderView(_: NSTableHeaderView);
  hiddenRowIndexes: IndexSet;
  highlightedTableColumn: NSTableColumn;
  setHighlightedTableColumn(_: NSTableColumn);
  intercellSpacing: CGSize;
  setIntercellSpacing(_: CGSize);
  numberOfColumns: number;
  numberOfRows: number;
  numberOfSelectedColumns: number;
  numberOfSelectedRows: number;
  registeredNibsByIdentifier: Map<string, NSNib>;
  rowActionsVisible: boolean;
  setRowActionsVisible(_: boolean);
  rowHeight: number;
  setRowHeight(_: number);
  rowSizeStyle: NSTableView.RowSizeStyle;
  setRowSizeStyle(_: NSTableView.RowSizeStyle);
  selectedColumn: number;
  selectedColumnIndexes: IndexSet;
  selectedRow: number;
  selectedRowIndexes: IndexSet;
  selectionHighlightStyle: NSTableView.SelectionHighlightStyle;
  setSelectionHighlightStyle(_: NSTableView.SelectionHighlightStyle);
  sortDescriptors: NSSortDescriptor[];
  setSortDescriptors(_: NSSortDescriptor[]);
  tableColumns: NSTableColumn[];
  usesAlternatingRowBackgroundColors: boolean;
  setUsesAlternatingRowBackgroundColors(_: boolean);
  usesAutomaticRowHeights: boolean;
  setUsesAutomaticRowHeights(_: boolean);
  usesStaticContents: boolean;
  setUsesStaticContents(_: boolean);
  verticalMotionCanBeginDrag: boolean;
  setVerticalMotionCanBeginDrag(_: boolean);
  addTableColumn(_: NSTableColumn): void;
  beginUpdates(): void;
  canDragRowsWithIndexesAtPoint(with_: IndexSet, at: CGPoint): boolean;
  columnAtPoint(at: CGPoint): number;
  columnForView(for_: NSView): number;
  columnIndexesInRect(in_: CGRect): IndexSet;
  columnWithIdentifier(withIdentifier: string): number;
  deselectAll(_?: any): void;
  deselectColumn(_: number): void;
  deselectRow(_: number): void;
  didAddRowViewForRow(_: NSTableRowView, forRow: number): void;
  didRemoveRowViewForRow(_: NSTableRowView, forRow: number): void;
  dragImageForRowsWithIndexesTableColumnsEventOffset(with_: IndexSet, tableColumns: NSTableColumn[], event: NSEvent, offset: CGPoint): NSImage;
  drawBackgroundInClipRect(inClipRect: CGRect): void;
  drawGridInClipRect(inClipRect: CGRect): void;
  drawRowClipRect(_: number, clipRect: CGRect): void;
  editColumnRowWithEventSelect(_: number, row: number, with_?: NSEvent, select?: boolean): void;
  endUpdates(): void;
  enumerateAvailableRowViewsUsingBlock(_: (p1: NSTableRowView, p2: number) => void): void;
  frameOfCellAtColumnRow(atColumn: number, row: number): CGRect;
  hideRowsAtIndexesWithAnimation(at: IndexSet, withAnimation: NSTableView.AnimationOptions): void;
  highlightSelectionInClipRect(inClipRect: CGRect): void;
  indicatorImageInTableColumn(in_: NSTableColumn): NSImage;
  insertRowsAtIndexesWithAnimation(at: IndexSet, withAnimation: NSTableView.AnimationOptions): void;
  isColumnSelected(_: number): boolean;
  isRowSelected(_: number): boolean;
  makeViewWithIdentifierOwner(withIdentifier: string, owner?: any): NSView;
  moveColumnToColumn(_: number, toColumn: number): void;
  moveRowAtIndexToIndex(at: number, to: number): void;
  noteHeightOfRowsWithIndexesChanged(withIndexesChanged: IndexSet): void;
  noteNumberOfRowsChanged(): void;
  rectOfColumn(ofColumn: number): CGRect;
  rectOfRow(ofRow: number): CGRect;
  registerNibForIdentifier(_?: NSNib, forIdentifier?: string): void;
  reloadData(): void;
  reloadDataForRowIndexesColumnIndexes(forRowIndexes: IndexSet, columnIndexes: IndexSet): void;
  removeRowsAtIndexesWithAnimation(at: IndexSet, withAnimation: NSTableView.AnimationOptions): void;
  removeTableColumn(_: NSTableColumn): void;
  rowAtPoint(at: CGPoint): number;
  rowForView(for_: NSView): number;
  rowViewAtRowMakeIfNecessary(atRow: number, makeIfNecessary: boolean): NSTableRowView;
  rowsInRect(in_: CGRect): NSRange;
  scrollColumnToVisible(_: number): void;
  scrollRowToVisible(_: number): void;
  selectColumnIndexesByExtendingSelection(_: IndexSet, byExtendingSelection: boolean): void;
  selectRowIndexesByExtendingSelection(_: IndexSet, byExtendingSelection: boolean): void;
  setDraggingSourceOperationMaskForLocal(_: NSDragging.NSDragOperation, forLocal: boolean): void;
  setDropRowDropOperation(_: number, dropOperation: NSTableView.DropOperation): void;
  setIndicatorImageInTableColumn(_?: NSImage, in_?: NSTableColumn): void;
  sizeLastColumnToFit(): void;
  tableColumnWithIdentifier(withIdentifier: string): NSTableColumn;
  tile(): void;
  unhideRowsAtIndexesWithAnimation(at: IndexSet, withAnimation: NSTableView.AnimationOptions): void;
  viewAtColumnRowMakeIfNecessary(atColumn: number, row: number, makeIfNecessary: boolean): NSView;
}

interface NSTableViewDataSource {
  numberOfRowsInTableView(in_: NSTableView): number;
  tableViewObjectValueForTableColumnRow(_: NSTableView, objectValueFor?: NSTableColumn, row?: number): any;
  tableViewSetObjectValueForTableColumnRow(_: NSTableView, setObjectValue?: any, for_?: NSTableColumn, row?: number): void;
  tableViewSortDescriptorsDidChange(_: NSTableView, sortDescriptorsDidChange: NSSortDescriptor[]): void;
  tableViewPasteboardWriterForRow(_: NSTableView, pasteboardWriterForRow: number): any;
  tableViewDraggingSessionWillBeginAtPointForRowIndexes(_: NSTableView, draggingSession: NSDraggingSession, willBeginAt: CGPoint, forRowIndexes: IndexSet): void;
  tableViewDraggingSessionEndedAtPointOperation(_: NSTableView, draggingSession: NSDraggingSession, endedAt: CGPoint, operation: NSDragging.NSDragOperation): void;
  tableViewUpdateDraggingItemsForDrag(_: NSTableView, updateDraggingItemsForDrag: any): void;
  tableViewWriteRowsWithIndexesToPasteboard(_: NSTableView, writeRowsWith: IndexSet, to: NSPasteboard): boolean;
  tableViewValidateDropProposedRowProposedDropOperation(_: NSTableView, validateDrop: any, proposedRow: number, proposedDropOperation: NSTableView.DropOperation): NSDragging.NSDragOperation;
  tableViewAcceptDropRowDropOperation(_: NSTableView, acceptDrop: any, row: number, dropOperation: NSTableView.DropOperation): boolean;
}

interface NSTableViewDelegate {
  selectionShouldChangeInTableView(in_: NSTableView): boolean;
  tableViewViewForTableColumnRow(_: NSTableView, viewFor?: NSTableColumn, row?: number): NSView;
  tableViewRowViewForRow(_: NSTableView, rowViewForRow: number): NSTableRowView;
  tableViewDidAddRowViewForRow(_: NSTableView, didAdd: NSTableRowView, forRow: number): void;
  tableViewDidRemoveRowViewForRow(_: NSTableView, didRemove: NSTableRowView, forRow: number): void;
  tableViewWillDisplayCellForTableColumnRow(_: NSTableView, willDisplayCell: any, for_?: NSTableColumn, row?: number): void;
  tableViewShouldEditTableColumnRow(_: NSTableView, shouldEdit?: NSTableColumn, row?: number): boolean;
  tableViewToolTipForCellRectTableColumnRowMouseLocation(_: NSTableView, toolTipFor: NSCell, rect: CGRect, tableColumn?: NSTableColumn, row?: number, mouseLocation?: CGPoint): string;
  tableViewShouldShowCellExpansionForTableColumnRow(_: NSTableView, shouldShowCellExpansionFor?: NSTableColumn, row?: number): boolean;
  tableViewShouldTrackCellForTableColumnRow(_: NSTableView, shouldTrackCell: NSCell, for_?: NSTableColumn, row?: number): boolean;
  tableViewDataCellForTableColumnRow(_: NSTableView, dataCellFor?: NSTableColumn, row?: number): NSCell;
  tableViewShouldSelectRow(_: NSTableView, shouldSelectRow: number): boolean;
  tableViewSelectionIndexesForProposedSelection(_: NSTableView, selectionIndexesForProposedSelection: IndexSet): IndexSet;
  tableViewShouldSelectTableColumn(_: NSTableView, shouldSelect?: NSTableColumn): boolean;
  tableViewMouseDownInHeaderOfTableColumn(_: NSTableView, mouseDownInHeaderOf: NSTableColumn): void;
  tableViewDidClickTableColumn(_: NSTableView, didClick: NSTableColumn): void;
  tableViewDidDragTableColumn(_: NSTableView, didDrag: NSTableColumn): void;
  tableViewHeightOfRow(_: NSTableView, heightOfRow: number): number;
  tableViewTypeSelectStringForTableColumnRow(_: NSTableView, typeSelectStringFor?: NSTableColumn, row?: number): string;
  tableViewNextTypeSelectMatchFromRowToRowForString(_: NSTableView, nextTypeSelectMatchFromRow: number, toRow: number, for_: string): number;
  tableViewShouldTypeSelectForEventWithCurrentSearchString(_: NSTableView, shouldTypeSelectFor: NSEvent, withCurrentSearch?: string): boolean;
  tableViewIsGroupRow(_: NSTableView, isGroupRow: number): boolean;
  tableViewSizeToFitWidthOfColumn(_: NSTableView, sizeToFitWidthOfColumn: number): number;
  tableViewShouldReorderColumnToColumn(_: NSTableView, shouldReorderColumn: number, toColumn: number): boolean;
  tableViewRowActionsForRowEdge(_: NSTableView, rowActionsForRow: number, edge: NSTableView.RowActionEdge): NSTableViewRowAction[];
  tableViewColumnDidMove(_: Notification): void;
  tableViewColumnDidResize(_: Notification): void;
  tableViewSelectionDidChange(_: Notification): void;
  tableViewSelectionIsChanging(_: Notification): void;
}

export class NSTableViewRowAction extends NSObject {
  backgroundColor: NSColor;
  setBackgroundColor(_: NSColor);
  image: NSImage;
  setImage(_: NSImage);
  style: NSTableViewRowAction.Style;
  title: string;
  setTitle(_: string);
}

export class NSText extends NSView {
  alignment: NSText.NSTextAlignment;
  setAlignment(_: NSText.NSTextAlignment);
  backgroundColor: NSColor;
  setBackgroundColor(_: NSColor);
  baseWritingDirection: NSText.NSWritingDirection;
  setBaseWritingDirection(_: NSText.NSWritingDirection);
  delegate: any;
  setDelegate(_: any);
  drawsBackground: boolean;
  setDrawsBackground(_: boolean);
  isEditable: boolean;
  setEditable(_: boolean);
  isFieldEditor: boolean;
  setFieldEditor(_: boolean);
  font: NSFont;
  setFont(_: NSFont);
  isHorizontallyResizable: boolean;
  setHorizontallyResizable(_: boolean);
  importsGraphics: boolean;
  setImportsGraphics(_: boolean);
  maxSize: CGSize;
  setMaxSize(_: CGSize);
  minSize: CGSize;
  setMinSize(_: CGSize);
  isRichText: boolean;
  setRichText(_: boolean);
  isRulerVisible: boolean;
  isSelectable: boolean;
  setSelectable(_: boolean);
  selectedRange: NSRange;
  setSelectedRange(_: NSRange);
  textColor: NSColor;
  setTextColor(_: NSColor);
  usesFontPanel: boolean;
  setUsesFontPanel(_: boolean);
  isVerticallyResizable: boolean;
  setVerticallyResizable(_: boolean);
  rTFDFromRange(from: NSRange): Data;
  rTFFromRange(from: NSRange): Data;
  alignCenter(_?: any): void;
  alignLeft(_?: any): void;
  alignRight(_?: any): void;
  checkSpelling(_?: any): void;
  copy(_?: any): void;
  copyFont(_?: any): void;
  copyRuler(_?: any): void;
  cut(_?: any): void;
  delete(_?: any): void;
  paste(_?: any): void;
  pasteFont(_?: any): void;
  pasteRuler(_?: any): void;
  readRTFDFromFile(fromFile: string): boolean;
  replaceCharactersInRangeWithRTF(in_: NSRange, withRTF: Data): void;
  replaceCharactersInRangeWithRTFD(in_: NSRange, withRTFD: Data): void;
  replaceCharactersInRangeWithString(in_: NSRange, with_: string): void;
  scrollRangeToVisible(_: NSRange): void;
  setFontRange(_: NSFont, range: NSRange): void;
  setTextColorRange(_?: NSColor, range?: NSRange): void;
  showGuessPanel(_?: any): void;
  sizeToFit(): void;
  subscript(_?: any): void;
  superscript(_?: any): void;
  toggleRuler(_?: any): void;
  underline(_?: any): void;
  unscript(_?: any): void;
  writeRTFDToFileAtomically(toFile: string, atomically: boolean): boolean;
}

export class NSTextAlternatives extends NSObject {
  alternativeStrings: string[];
  primaryString: string;
  static initWithPrimaryStringAlternativeStrings(_: string, alternativeStrings: string[]): NSTextAlternatives;
  noteSelectedAlternativeString(_: string): void;
}

export class NSTextAttachment extends NSObject {
  attachmentCell: any;
  setAttachmentCell(_: any);
  bounds: CGRect;
  setBounds(_: CGRect);
  contents: Data;
  setContents(_: Data);
  fileType: string;
  setFileType(_: string);
  fileWrapper: FileWrapper;
  setFileWrapper(_: FileWrapper);
  image: NSImage;
  setImage(_: NSImage);
  static initWithDataOfType(_?: Data, ofType?: string): NSTextAttachment;
  static initWithFileWrapper(_?: FileWrapper): NSTextAttachment;
}

export class NSTextAttachmentCell extends NSCell {
}

interface NSTextAttachmentCellProtocol {
  attachment: NSTextAttachment;
  setAttachment(_: NSTextAttachment);
  cellBaselineOffset(): CGPoint;
  cellFrameForTextContainerProposedLineFragmentGlyphPositionCharacterIndex(_: NSTextContainer, proposedLineFragment: CGRect, glyphPosition: CGPoint, characterIndex: number): CGRect;
  cellSize(): CGSize;
  drawWithFrameInView(_: CGRect, inView?: NSView): void;
  drawWithFrameInViewCharacterIndex(_: CGRect, inView?: NSView, characterIndex?: number): void;
  drawWithFrameInViewCharacterIndexLayoutManager(_: CGRect, inView?: NSView, characterIndex?: number, layoutManager?: NSLayoutManager): void;
  highlightWithFrameInView(_: boolean, withFrame: CGRect, inView?: NSView): void;
  trackMouseInRectOfViewUntilMouseUp(_: NSEvent, inRect: CGRect, ofView?: NSView, untilMouseUp?: boolean): boolean;
  trackMouseInRectOfViewAtCharacterIndexUntilMouseUp(_: NSEvent, inRect: CGRect, ofView?: NSView, atCharacterIndex?: number, untilMouseUp?: boolean): boolean;
  wantsToTrackMouse(): boolean;
  wantsToTrackMouseForEventInRectOfViewAtCharacterIndex(_: NSEvent, inRect: CGRect, ofView?: NSView, atCharacterIndex?: number): boolean;
}

interface NSTextAttachmentContainer {
  attachmentBoundsForTextContainerProposedLineFragmentGlyphPositionCharacterIndex(for_?: NSTextContainer, proposedLineFragment?: CGRect, glyphPosition?: CGPoint, characterIndex?: number): CGRect;
  imageForBoundsTextContainerCharacterIndex(forBounds: CGRect, textContainer?: NSTextContainer, characterIndex?: number): NSImage;
}

export class NSTextBlock extends NSObject {
  backgroundColor: NSColor;
  setBackgroundColor(_: NSColor);
  contentWidth: number;
  contentWidthValueType: NSTextTable.NSTextBlock.ValueType;
  verticalAlignment: NSTextTable.NSTextBlock.VerticalAlignment;
  setVerticalAlignment(_: NSTextTable.NSTextBlock.VerticalAlignment);
  borderColorForEdge(for_: NSGeometry.NSRectEdge): NSColor;
  boundsRectForContentRectInRectTextContainerCharacterRange(forContentRect: CGRect, in_: CGRect, textContainer: NSTextContainer, characterRange: NSRange): CGRect;
  drawBackgroundWithFrameInViewCharacterRangeLayoutManager(withFrame: CGRect, in_: NSView, characterRange: NSRange, layoutManager: NSLayoutManager): void;
  rectForLayoutAtPointInRectTextContainerCharacterRange(at: CGPoint, in_: CGRect, textContainer: NSTextContainer, characterRange: NSRange): CGRect;
  setBorderColor(_?: NSColor): void;
  setBorderColorForEdge(_?: NSColor, for_?: NSGeometry.NSRectEdge): void;
  setContentWidthType(_: number, type: NSTextTable.NSTextBlock.ValueType): void;
  setValueTypeForDimension(_: number, type: NSTextTable.NSTextBlock.ValueType, for_: NSTextTable.NSTextBlock.Dimension): void;
  setWidthTypeForLayer(_: number, type: NSTextTable.NSTextBlock.ValueType, for_: NSTextTable.NSTextBlock.Layer): void;
  setWidthTypeForLayerEdge(_: number, type: NSTextTable.NSTextBlock.ValueType, for_: NSTextTable.NSTextBlock.Layer, edge: NSGeometry.NSRectEdge): void;
  valueForDimension(for_: NSTextTable.NSTextBlock.Dimension): number;
  valueTypeForDimension(for_: NSTextTable.NSTextBlock.Dimension): NSTextTable.NSTextBlock.ValueType;
  widthForLayerEdge(for_: NSTextTable.NSTextBlock.Layer, edge: NSGeometry.NSRectEdge): number;
  widthValueTypeForLayerEdge(for_: NSTextTable.NSTextBlock.Layer, edge: NSGeometry.NSRectEdge): NSTextTable.NSTextBlock.ValueType;
}

interface NSTextCheckingClient {
  addAnnotationsRange(_: Map<string, string>, range: NSRange): void;
  annotatedSubstringForProposedRangeActualRange(forProposedRange: NSRange, actualRange?: NSRange): NSAttributedString;
  candidateListTouchBarItem(): NSCandidateListTouchBarItem<any>;
  removeAnnotationRange(_: string, range: NSRange): void;
  replaceCharactersInRangeWithAnnotatedString(in_: NSRange, withAnnotatedString: NSAttributedString): void;
  selectAndShowRange(_: NSRange): void;
  setAnnotationsRange(_: Map<string, string>, range: NSRange): void;
  viewForRangeFirstRectActualRange(for_: NSRange, firstRect?: CGRect, actualRange?: NSRange): NSView;
}

export class NSTextCheckingController extends NSObject {
  client: any;
  spellCheckerDocumentTag: number;
  setSpellCheckerDocumentTag(_: number);
  changeSpelling(_?: any): void;
  checkSpelling(_?: any): void;
  checkTextInDocument(_?: any): void;
  checkTextInRangeTypesOptions(in_: NSRange, types: number, options: Map<string, any>): void;
  checkTextInSelection(_?: any): void;
  considerTextCheckingForRange(for_: NSRange): void;
  didChangeSelectedRange(): void;
  didChangeTextInRange(in_: NSRange): void;
  ignoreSpelling(_?: any): void;
  static initWithClient(_: any): NSTextCheckingController;
  insertedTextInRange(in_: NSRange): void;
  invalidate(): void;
  menuAtIndexClickedOnSelectionEffectiveRange(at: number, clickedOnSelection: boolean, effectiveRange: NSRange): NSMenu;
  orderFrontSubstitutionsPanel(_?: any): void;
  showGuessPanel(_?: any): void;
  updateCandidates(): void;
  validAnnotations(): string[];
}

export class NSTextContainer extends NSObject {
  containerSize: CGSize;
  setContainerSize(_: CGSize);
  exclusionPaths: NSBezierPath[];
  setExclusionPaths(_: NSBezierPath[]);
  heightTracksTextView: boolean;
  setHeightTracksTextView(_: boolean);
  layoutManager: NSLayoutManager;
  setLayoutManager(_: NSLayoutManager);
  lineBreakMode: NSParagraphStyle.NSLineBreakMode;
  setLineBreakMode(_: NSParagraphStyle.NSLineBreakMode);
  lineFragmentPadding: number;
  setLineFragmentPadding(_: number);
  maximumNumberOfLines: number;
  setMaximumNumberOfLines(_: number);
  isSimpleRectangularTextContainer: boolean;
  size: CGSize;
  setSize(_: CGSize);
  textView: NSTextView;
  setTextView(_: NSTextView);
  widthTracksTextView: boolean;
  setWidthTracksTextView(_: boolean);
  static initWithContainerSize(_: CGSize): NSTextContainer;
  static initWithSize(_: CGSize): NSTextContainer;
  lineFragmentRectForProposedRectAtIndexWritingDirectionRemainingRect(forProposedRect: CGRect, at: number, writingDirection: NSText.NSWritingDirection, remaining?: CGRect): CGRect;
  lineFragmentRectForProposedRectSweepDirectionMovementDirectionRemainingRect(forProposedRect: CGRect, sweepDirection: NSTextContainer.NSLineSweepDirection, movementDirection: NSTextContainer.NSLineMovementDirection, remaining?: CGRect): CGRect;
  replaceLayoutManager(_: NSLayoutManager): void;
}

interface NSTextDelegate {
  textDidBeginEditing(_: Notification): void;
  textDidChange(_: Notification): void;
  textDidEndEditing(_: Notification): void;
  textShouldBeginEditing(_: NSText): boolean;
  textShouldEndEditing(_: NSText): boolean;
}

export class NSTextField extends NSControl {
  allowsCharacterPickerTouchBarItem: boolean;
  setAllowsCharacterPickerTouchBarItem(_: boolean);
  allowsDefaultTighteningForTruncation: boolean;
  setAllowsDefaultTighteningForTruncation(_: boolean);
  allowsEditingTextAttributes: boolean;
  setAllowsEditingTextAttributes(_: boolean);
  isAutomaticTextCompletionEnabled: boolean;
  setAutomaticTextCompletionEnabled(_: boolean);
  backgroundColor: NSColor;
  setBackgroundColor(_: NSColor);
  bezelStyle: NSTextFieldCell.NSTextField.BezelStyle;
  setBezelStyle(_: NSTextFieldCell.NSTextField.BezelStyle);
  isBezeled: boolean;
  setBezeled(_: boolean);
  isBordered: boolean;
  setBordered(_: boolean);
  delegate: any;
  setDelegate(_: any);
  drawsBackground: boolean;
  setDrawsBackground(_: boolean);
  isEditable: boolean;
  setEditable(_: boolean);
  importsGraphics: boolean;
  setImportsGraphics(_: boolean);
  maximumNumberOfLines: number;
  setMaximumNumberOfLines(_: number);
  placeholderAttributedString: NSAttributedString;
  setPlaceholderAttributedString(_: NSAttributedString);
  placeholderString: string;
  setPlaceholderString(_: string);
  preferredMaxLayoutWidth: number;
  setPreferredMaxLayoutWidth(_: number);
  isSelectable: boolean;
  setSelectable(_: boolean);
  textColor: NSColor;
  setTextColor(_: NSColor);
  selectText(_?: any): void;
  textDidBeginEditing(_: Notification): void;
  textDidChange(_: Notification): void;
  textDidEndEditing(_: Notification): void;
  textShouldBeginEditing(_: NSText): boolean;
  textShouldEndEditing(_: NSText): boolean;
}

export class NSTextFieldCell extends NSActionCell {
  allowedInputSourceLocales: string[];
  setAllowedInputSourceLocales(_: string[]);
  backgroundColor: NSColor;
  setBackgroundColor(_: NSColor);
  bezelStyle: NSTextFieldCell.NSTextField.BezelStyle;
  setBezelStyle(_: NSTextFieldCell.NSTextField.BezelStyle);
  drawsBackground: boolean;
  setDrawsBackground(_: boolean);
  placeholderAttributedString: NSAttributedString;
  setPlaceholderAttributedString(_: NSAttributedString);
  placeholderString: string;
  setPlaceholderString(_: string);
  textColor: NSColor;
  setTextColor(_: NSColor);
  setWantsNotificationForMarkedText(_: boolean): void;
}

interface NSTextFieldDelegate {
  textFieldTextViewCandidatesForSelectedRange(_: NSTextField, textView: NSTextView, candidatesForSelectedRange: NSRange): any[];
  textFieldTextViewCandidatesForSelectedRange(_: NSTextField, textView: NSTextView, candidates: NSTextCheckingResult[], forSelectedRange: NSRange): NSTextCheckingResult[];
  textFieldTextViewShouldSelectCandidateAtIndex(_: NSTextField, textView: NSTextView, shouldSelectCandidateAt: number): boolean;
}

export class NSTextFinder extends NSObject {
  static drawIncrementalMatchHighlightInRect(in_: CGRect): void;
  client: any;
  setClient(_: any);
  findBarContainer: any;
  setFindBarContainer(_: any);
  findIndicatorNeedsUpdate: boolean;
  setFindIndicatorNeedsUpdate(_: boolean);
  incrementalMatchRanges: NSValue[];
  isIncrementalSearchingEnabled: boolean;
  setIncrementalSearchingEnabled(_: boolean);
  incrementalSearchingShouldDimContentView: boolean;
  setIncrementalSearchingShouldDimContentView(_: boolean);
  cancelFindIndicator(): void;
  noteClientStringWillChange(): void;
  performAction(_: NSTextFinder.Action): void;
  validateAction(_: NSTextFinder.Action): boolean;
}

interface NSTextFinderBarContainer {
  findBarView: NSView;
  setFindBarView(_: NSView);
  isFindBarVisible: boolean;
  setFindBarVisible(_: boolean);
  contentView: NSView;
  findBarViewDidChangeHeight(): void;
}

interface NSTextFinderClient {
  allowsMultipleSelection?: boolean;
  firstSelectedRange?: NSRange;
  isEditable?: boolean;
  isSelectable?: boolean;
  selectedRanges?: NSValue[];
  setSelectedRanges(_: NSValue[]);
  
  visibleCharacterRanges?: NSValue[];
  contentViewAtIndexEffectiveCharacterRange(at: number, effectiveCharacterRange: NSRange): NSView;
  didReplaceCharacters(): void;
  drawCharactersInRangeForContentView(in_: NSRange, forContentView: NSView): void;
  rectsForCharacterRange(forCharacterRange: NSRange): NSValue[];
  replaceCharactersInRangeWithString(in_: NSRange, with_: string): void;
  scrollRangeToVisible(_: NSRange): void;
  shouldReplaceCharactersInRangesWithStrings(inRanges: NSValue[], with_: string[]): boolean;
  stringLength(): number;
}

interface NSTextInput {
}

interface NSTextInputClient {
  attributedString(): NSAttributedString;
  attributedSubstringForProposedRangeActualRange(forProposedRange: NSRange, actualRange?: NSRange): NSAttributedString;
  baselineDeltaForCharacterAtIndex(at: number): number;
  characterIndexForPoint(for_: CGPoint): number;
  doCommandBySelector(by: string): void;
  drawsVerticallyForCharacterAtIndex(at: number): boolean;
  firstRectForCharacterRangeActualRange(forCharacterRange: NSRange, actualRange?: NSRange): CGRect;
  fractionOfDistanceThroughGlyphForPoint(for_: CGPoint): number;
  hasMarkedText(): boolean;
  insertTextReplacementRange(_: any, replacementRange: NSRange): void;
  markedRange(): NSRange;
  selectedRange(): NSRange;
  setMarkedTextSelectedRangeReplacementRange(_: any, selectedRange: NSRange, replacementRange: NSRange): void;
  unmarkText(): void;
  validAttributesForMarkedText(): string[];
  windowLevel(): number;
}

export class NSTextInputContext extends NSObject {
  static localizedNameForInputSource(forInputSource: string): string;
  acceptsGlyphInfo: boolean;
  setAcceptsGlyphInfo(_: boolean);
  allowedInputSourceLocales: string[];
  setAllowedInputSourceLocales(_: string[]);
  client: any;
  keyboardInputSources: string[];
  selectedKeyboardInputSource: string;
  setSelectedKeyboardInputSource(_: string);
  static currentInputContext: NSTextInputContext;
  activate(): void;
  deactivate(): void;
  discardMarkedText(): void;
  handleEvent(_: NSEvent): boolean;
  static initWithClient(_: any): NSTextInputContext;
  invalidateCharacterCoordinates(): void;
}

interface NSTextInputTraits {
  autocorrectionType?: NSTextCheckingClient.NSTextInputTraitType;
  setAutocorrectionType(_: NSTextCheckingClient.NSTextInputTraitType);
  dataDetectionType?: NSTextCheckingClient.NSTextInputTraitType;
  setDataDetectionType(_: NSTextCheckingClient.NSTextInputTraitType);
  grammarCheckingType?: NSTextCheckingClient.NSTextInputTraitType;
  setGrammarCheckingType(_: NSTextCheckingClient.NSTextInputTraitType);
  linkDetectionType?: NSTextCheckingClient.NSTextInputTraitType;
  setLinkDetectionType(_: NSTextCheckingClient.NSTextInputTraitType);
  smartDashesType?: NSTextCheckingClient.NSTextInputTraitType;
  setSmartDashesType(_: NSTextCheckingClient.NSTextInputTraitType);
  smartInsertDeleteType?: NSTextCheckingClient.NSTextInputTraitType;
  setSmartInsertDeleteType(_: NSTextCheckingClient.NSTextInputTraitType);
  smartQuotesType?: NSTextCheckingClient.NSTextInputTraitType;
  setSmartQuotesType(_: NSTextCheckingClient.NSTextInputTraitType);
  spellCheckingType?: NSTextCheckingClient.NSTextInputTraitType;
  setSpellCheckingType(_: NSTextCheckingClient.NSTextInputTraitType);
  textCompletionType?: NSTextCheckingClient.NSTextInputTraitType;
  setTextCompletionType(_: NSTextCheckingClient.NSTextInputTraitType);
  textReplacementType?: NSTextCheckingClient.NSTextInputTraitType;
  setTextReplacementType(_: NSTextCheckingClient.NSTextInputTraitType);
}

interface NSTextLayoutOrientationProvider {
  layoutOrientation: NSLayoutManager.TextLayoutOrientation;
}

export class NSTextList extends NSObject {
  listOptions: NSTextList.Options;
  markerFormat: string;
  startingItemNumber: number;
  setStartingItemNumber(_: number);
  static initWithMarkerFormatOptions(_: string, options: number): NSTextList;
  markerForItemNumber(forItemNumber: number): string;
}

export class NSTextStorage extends NSMutableAttributedString {
  attributeRuns: NSTextStorage[];
  setAttributeRuns(_: NSTextStorage[]);
  changeInLength: number;
  characters: NSTextStorage[];
  setCharacters(_: NSTextStorage[]);
  delegate: any;
  setDelegate(_: any);
  editedMask: NSTextStorage.NSTextStorageEditActions;
  editedRange: NSRange;
  fixesAttributesLazily: boolean;
  font: NSFont;
  setFont(_: NSFont);
  foregroundColor: NSColor;
  setForegroundColor(_: NSColor);
  layoutManagers: NSLayoutManager[];
  paragraphs: NSTextStorage[];
  setParagraphs(_: NSTextStorage[]);
  words: NSTextStorage[];
  setWords(_: NSTextStorage[]);
  addLayoutManager(_: NSLayoutManager): void;
  editedRangeChangeInLength(_: NSTextStorage.NSTextStorageEditActions, range: NSRange, changeInLength: number): void;
  ensureAttributesAreFixedInRange(in_: NSRange): void;
  invalidateAttributesInRange(in_: NSRange): void;
  processEditing(): void;
  removeLayoutManager(_: NSLayoutManager): void;
}

interface NSTextStorageDelegate {
  textStorageWillProcessEditingRangeChangeInLength(_: NSTextStorage, willProcessEditing: NSTextStorage.NSTextStorageEditActions, range: NSRange, changeInLength: number): void;
  textStorageDidProcessEditingRangeChangeInLength(_: NSTextStorage, didProcessEditing: NSTextStorage.NSTextStorageEditActions, range: NSRange, changeInLength: number): void;
}

export class NSTextTab extends NSObject {
  static columnTerminatorsForLocale(for_?: Locale): CharacterSet;
  alignment: NSText.NSTextAlignment;
  location: number;
  options: Map<string, any>;
  tabStopType: NSParagraphStyle.TextTabType;
  static initWithTextAlignmentLocationOptions(_: NSText.NSTextAlignment, location: number, options: Map<string, any>): NSTextTab;
  static initWithTypeLocation(_: NSParagraphStyle.TextTabType, location: number): NSTextTab;
}

export class NSTextTable extends NSTextBlock {
  collapsesBorders: boolean;
  setCollapsesBorders(_: boolean);
  hidesEmptyCells: boolean;
  setHidesEmptyCells(_: boolean);
  layoutAlgorithm: NSTextTable.LayoutAlgorithm;
  setLayoutAlgorithm(_: NSTextTable.LayoutAlgorithm);
  numberOfColumns: number;
  setNumberOfColumns(_: number);
  boundsRectForBlockContentRectInRectTextContainerCharacterRange(for_: NSTextTableBlock, contentRect: CGRect, in_: CGRect, textContainer: NSTextContainer, characterRange: NSRange): CGRect;
  drawBackgroundForBlockWithFrameInViewCharacterRangeLayoutManager(for_: NSTextTableBlock, withFrame: CGRect, in_: NSView, characterRange: NSRange, layoutManager: NSLayoutManager): void;
  rectForBlockLayoutAtPointInRectTextContainerCharacterRange(for_: NSTextTableBlock, layoutAt: CGPoint, in_: CGRect, textContainer: NSTextContainer, characterRange: NSRange): CGRect;
}

export class NSTextTableBlock extends NSTextBlock {
  columnSpan: number;
  rowSpan: number;
  startingColumn: number;
  startingRow: number;
  table: NSTextTable;
  static initWithTableStartingRowRowSpanStartingColumnColumnSpan(_: NSTextTable, startingRow: number, rowSpan: number, startingColumn: number, columnSpan: number): NSTextTableBlock;
}

export class NSTextView extends NSText {
  static fieldEditor(): NSTextView;
  static registerForServices(): void;
  static scrollableDocumentContentTextView(): NSScrollView;
  static scrollablePlainDocumentContentTextView(): NSScrollView;
  static scrollableTextView(): NSScrollView;
  acceptableDragTypes: string[];
  acceptsGlyphInfo: boolean;
  setAcceptsGlyphInfo(_: boolean);
  allowedInputSourceLocales: string[];
  setAllowedInputSourceLocales(_: string[]);
  allowsCharacterPickerTouchBarItem: boolean;
  setAllowsCharacterPickerTouchBarItem(_: boolean);
  allowsDocumentBackgroundColorChange: boolean;
  setAllowsDocumentBackgroundColorChange(_: boolean);
  allowsImageEditing: boolean;
  setAllowsImageEditing(_: boolean);
  allowsUndo: boolean;
  setAllowsUndo(_: boolean);
  isAutomaticDashSubstitutionEnabled: boolean;
  setAutomaticDashSubstitutionEnabled(_: boolean);
  isAutomaticDataDetectionEnabled: boolean;
  setAutomaticDataDetectionEnabled(_: boolean);
  isAutomaticLinkDetectionEnabled: boolean;
  setAutomaticLinkDetectionEnabled(_: boolean);
  isAutomaticQuoteSubstitutionEnabled: boolean;
  setAutomaticQuoteSubstitutionEnabled(_: boolean);
  isAutomaticSpellingCorrectionEnabled: boolean;
  setAutomaticSpellingCorrectionEnabled(_: boolean);
  isAutomaticTextCompletionEnabled: boolean;
  setAutomaticTextCompletionEnabled(_: boolean);
  isAutomaticTextReplacementEnabled: boolean;
  setAutomaticTextReplacementEnabled(_: boolean);
  isCoalescingUndo: boolean;
  isContinuousSpellCheckingEnabled: boolean;
  setContinuousSpellCheckingEnabled(_: boolean);
  defaultParagraphStyle: NSParagraphStyle;
  setDefaultParagraphStyle(_: NSParagraphStyle);
  delegate: any;
  setDelegate(_: any);
  displaysLinkToolTips: boolean;
  setDisplaysLinkToolTips(_: boolean);
  enabledTextCheckingTypes: number;
  setEnabledTextCheckingTypes(_: number);
  isGrammarCheckingEnabled: boolean;
  setGrammarCheckingEnabled(_: boolean);
  isIncrementalSearchingEnabled: boolean;
  setIncrementalSearchingEnabled(_: boolean);
  insertionPointColor: NSColor;
  setInsertionPointColor(_: NSColor);
  layoutManager: NSLayoutManager;
  linkTextAttributes: Map<string, any>;
  setLinkTextAttributes(_: Map<string, any>);
  markedTextAttributes: Map<string, any>;
  setMarkedTextAttributes(_: Map<string, any>);
  rangeForUserCharacterAttributeChange: NSRange;
  rangeForUserCompletion: NSRange;
  rangeForUserParagraphAttributeChange: NSRange;
  rangeForUserTextChange: NSRange;
  rangesForUserCharacterAttributeChange: NSValue[];
  rangesForUserParagraphAttributeChange: NSValue[];
  rangesForUserTextChange: NSValue[];
  readablePasteboardTypes: string[];
  isRulerVisible: boolean;
  setRulerVisible(_: boolean);
  selectedRanges: NSValue[];
  setSelectedRanges(_: NSValue[]);
  selectedTextAttributes: Map<string, any>;
  setSelectedTextAttributes(_: Map<string, any>);
  selectionAffinity: NSTextView.NSSelectionAffinity;
  selectionGranularity: NSTextView.NSSelectionGranularity;
  setSelectionGranularity(_: NSTextView.NSSelectionGranularity);
  shouldDrawInsertionPoint: boolean;
  smartInsertDeleteEnabled: boolean;
  setSmartInsertDeleteEnabled(_: boolean);
  spellCheckerDocumentTag: number;
  textContainer: NSTextContainer;
  setTextContainer(_: NSTextContainer);
  textContainerInset: CGSize;
  setTextContainerInset(_: CGSize);
  textContainerOrigin: CGPoint;
  textStorage: NSTextStorage;
  typingAttributes: Map<string, any>;
  setTypingAttributes(_: Map<string, any>);
  usesAdaptiveColorMappingForDarkAppearance: boolean;
  setUsesAdaptiveColorMappingForDarkAppearance(_: boolean);
  usesFindBar: boolean;
  setUsesFindBar(_: boolean);
  usesFindPanel: boolean;
  setUsesFindPanel(_: boolean);
  usesInspectorBar: boolean;
  setUsesInspectorBar(_: boolean);
  usesRolloverButtonForSelection: boolean;
  setUsesRolloverButtonForSelection(_: boolean);
  usesRuler: boolean;
  setUsesRuler(_: boolean);
  writablePasteboardTypes: string[];
  static stronglyReferencesTextStorage: boolean;
  alignJustified(_?: any): void;
  breakUndoCoalescing(): void;
  changeAttributes(_?: any): void;
  changeDocumentBackgroundColor(_?: any): void;
  changeLayoutOrientation(_?: any): void;
  characterIndexForInsertionAtPoint(at: CGPoint): number;
  checkTextInDocument(_?: any): void;
  checkTextInRangeTypesOptions(in_: NSRange, types: number, options: Map<string, any>): void;
  checkTextInSelection(_?: any): void;
  cleanUpAfterDragOperation(): void;
  clickedOnLinkAtIndex(onLink: any, at: number): void;
  completionsForPartialWordRangeIndexOfSelectedItem(forPartialWordRange: NSRange, indexOfSelectedItem: number): string[];
  didChangeText(): void;
  dragImageForSelectionWithEventOrigin(with_: NSEvent, origin?: CGPoint): NSImage;
  dragOperationForDraggingInfoType(for_: any, type: string): NSDragging.NSDragOperation;
  dragSelectionWithEventOffsetSlideBack(with_: NSEvent, offset: CGSize, slideBack: boolean): boolean;
  drawInsertionPointInRectColorTurnedOn(in_: CGRect, color: NSColor, turnedOn: boolean): void;
  drawViewBackgroundInRect(in_: CGRect): void;
  handleTextCheckingResultsForRangeTypesOptionsOrthographyWordCount(_: NSTextCheckingResult[], forRange: NSRange, types: number, options: Map<string, any>, orthography: NSOrthography, wordCount: number): void;
  static initWithFrameTextContainer(_: CGRect, textContainer?: NSTextContainer): NSTextView;
  insertCompletionForPartialWordRangeMovementIsFinal(_: string, forPartialWordRange: NSRange, movement: number, isFinal: boolean): void;
  invalidateTextContainerOrigin(): void;
  loosenKerning(_?: any): void;
  lowerBaseline(_?: any): void;
  orderFrontLinkPanel(_?: any): void;
  orderFrontListPanel(_?: any): void;
  orderFrontSharingServicePicker(_?: any): void;
  orderFrontSpacingPanel(_?: any): void;
  orderFrontSubstitutionsPanel(_?: any): void;
  orderFrontTablePanel(_?: any): void;
  outline(_?: any): void;
  pasteAsPlainText(_?: any): void;
  pasteAsRichText(_?: any): void;
  performFindPanelAction(_?: any): void;
  performValidatedReplacementInRangeWithAttributedString(in_: NSRange, with_: NSAttributedString): boolean;
  preferredPasteboardTypeFromArrayRestrictedToTypesFromArray(from: string[], restrictedToTypesFrom?: string[]): string;
  raiseBaseline(_?: any): void;
  readSelectionFromPasteboard(from: NSPasteboard): boolean;
  readSelectionFromPasteboardType(from: NSPasteboard, type: string): boolean;
  replaceTextContainer(_: NSTextContainer): void;
  selectionRangeForProposedRangeGranularity(forProposedRange: NSRange, granularity: NSTextView.NSSelectionGranularity): NSRange;
  setAlignmentRange(_: NSText.NSTextAlignment, range: NSRange): void;
  setBaseWritingDirectionRange(_: NSText.NSWritingDirection, range: NSRange): void;
  setConstrainedFrameSize(_: CGSize): void;
  setLayoutOrientation(_: NSLayoutManager.TextLayoutOrientation): void;
  setNeedsDisplayInRectAvoidAdditionalLayout(_: CGRect, avoidAdditionalLayout: boolean): void;
  setSelectedRange(_: NSRange): void;
  setSelectedRangeAffinityStillSelecting(_: NSRange, affinity: NSTextView.NSSelectionAffinity, stillSelecting: boolean): void;
  setSelectedRangesAffinityStillSelecting(_: NSValue[], affinity: NSTextView.NSSelectionAffinity, stillSelecting: boolean): void;
  setSpellingStateRange(_: number, range: NSRange): void;
  shouldChangeTextInRangeReplacementString(in_: NSRange, replacementString?: string): boolean;
  shouldChangeTextInRangesReplacementStrings(inRanges: NSValue[], replacementStrings?: string[]): boolean;
  showFindIndicatorForRange(for_: NSRange): void;
  smartDeleteRangeForProposedRange(forProposedRange: NSRange): NSRange;
  smartInsertAfterStringForStringReplacingRange(afterStringFor: string, replacing: NSRange): string;
  smartInsertBeforeStringForStringReplacingRange(beforeStringFor: string, replacing: NSRange): string;
  smartInsertForStringReplacingRangeBeforeStringAfterString(for_: string, replacing: NSRange, before?: string, after?: string): void;
  startSpeaking(_?: any): void;
  stopSpeaking(_?: any): void;
  tightenKerning(_?: any): void;
  toggleAutomaticDashSubstitution(_?: any): void;
  toggleAutomaticDataDetection(_?: any): void;
  toggleAutomaticLinkDetection(_?: any): void;
  toggleAutomaticQuoteSubstitution(_?: any): void;
  toggleAutomaticSpellingCorrection(_?: any): void;
  toggleAutomaticTextCompletion(_?: any): void;
  toggleAutomaticTextReplacement(_?: any): void;
  toggleContinuousSpellChecking(_?: any): void;
  toggleGrammarChecking(_?: any): void;
  toggleQuickLookPreviewPanel(_?: any): void;
  toggleSmartInsertDelete(_?: any): void;
  turnOffKerning(_?: any): void;
  turnOffLigatures(_?: any): void;
  updateCandidates(): void;
  updateDragTypeRegistration(): void;
  updateFontPanel(): void;
  updateInsertionPointStateAndRestartTimer(_: boolean): void;
  updateQuickLookPreviewPanel(): void;
  updateRuler(): void;
  updateTextTouchBarItems(): void;
  updateTouchBarItemIdentifiers(): void;
  useAllLigatures(_?: any): void;
  useStandardKerning(_?: any): void;
  useStandardLigatures(_?: any): void;
  writeSelectionToPasteboardType(to: NSPasteboard, type: string): boolean;
  writeSelectionToPasteboardTypes(to: NSPasteboard, types: string[]): boolean;
}

interface NSTextViewDelegate {
  textViewClickedOnLinkAtIndex(_: NSTextView, clickedOnLink: any, at: number): boolean;
  textViewClickedOnCellInRectAtIndex(_: NSTextView, clickedOn: any, in_: CGRect, at: number): void;
  textViewDoubleClickedOnCellInRectAtIndex(_: NSTextView, doubleClickedOn: any, in_: CGRect, at: number): void;
  textViewDraggedCellInRectEventAtIndex(_: NSTextView, draggedCell: any, in_: CGRect, event: NSEvent, at: number): void;
  textViewWritablePasteboardTypesForCellAtIndex(_: NSTextView, writablePasteboardTypesFor: any, at: number): string[];
  textViewWriteCellAtIndexToPasteboardType(_: NSTextView, write: any, at: number, to: NSPasteboard, type: string): boolean;
  textViewWillChangeSelectionFromCharacterRangeToCharacterRange(_: NSTextView, willChangeSelectionFromCharacterRange: NSRange, toCharacterRange: NSRange): NSRange;
  textViewWillChangeSelectionFromCharacterRangesToCharacterRanges(_: NSTextView, willChangeSelectionFromCharacterRanges: NSValue[], toCharacterRanges: NSValue[]): NSValue[];
  textViewShouldChangeTextInRangesReplacementStrings(_: NSTextView, shouldChangeTextInRanges: NSValue[], replacementStrings?: string[]): boolean;
  textViewShouldChangeTypingAttributesToAttributes(_: NSTextView, shouldChangeTypingAttributes: Map<string, any>, toAttributes: Map<string, any>): Map<string, any>;
  textViewWillDisplayToolTipForCharacterAtIndex(_: NSTextView, willDisplayToolTip: string, forCharacterAt: number): string;
  textViewCompletionsForPartialWordRangeIndexOfSelectedItem(_: NSTextView, completions: string[], forPartialWordRange: NSRange, indexOfSelectedItem?: number): string[];
  textViewShouldChangeTextInRangeReplacementString(_: NSTextView, shouldChangeTextIn: NSRange, replacementString?: string): boolean;
  textViewDoCommandBySelector(_: NSTextView, doCommandBy: string): boolean;
  textViewShouldSetSpellingStateRange(_: NSTextView, shouldSetSpellingState: number, range: NSRange): number;
  textViewMenuForEventAtIndex(_: NSTextView, menu: NSMenu, for_: NSEvent, at: number): NSMenu;
  textViewWillCheckTextInRangeOptionsTypes(_: NSTextView, willCheckTextIn: NSRange, options: Map<string, any>, types: number): Map<string, any>;
  textViewDidCheckTextInRangeTypesOptionsResultsOrthographyWordCount(_: NSTextView, didCheckTextIn: NSRange, types: number, options: Map<string, any>, results: NSTextCheckingResult[], orthography: NSOrthography, wordCount: number): NSTextCheckingResult[];
  textViewURLForContentsOfTextAttachmentAtIndex(_: NSTextView, urlForContentsOf: NSTextAttachment, at: number): URL;
  textViewWillShowSharingServicePickerForItems(_: NSTextView, willShow: NSSharingServicePicker, forItems: any[]): NSSharingServicePicker;
  textViewShouldUpdateTouchBarItemIdentifiers(_: NSTextView, shouldUpdateTouchBarItemIdentifiers: string[]): string[];
  textViewCandidatesForSelectedRange(_: NSTextView, candidatesForSelectedRange: NSRange): any[];
  textViewCandidatesForSelectedRange(_: NSTextView, candidates: NSTextCheckingResult[], forSelectedRange: NSRange): NSTextCheckingResult[];
  textViewShouldSelectCandidateAtIndex(_: NSTextView, shouldSelectCandidateAt: number): boolean;
  textViewDidChangeSelection(_: Notification): void;
  textViewDidChangeTypingAttributes(_: Notification): void;
  undoManagerForTextView(for_: NSTextView): UndoManager;
}

export class NSTitlebarAccessoryViewController extends NSViewController {
  fullScreenMinHeight: number;
  setFullScreenMinHeight(_: number);
  isHidden: boolean;
  setHidden(_: boolean);
  layoutAttribute: NSLayoutConstraint.Attribute;
  setLayoutAttribute(_: NSLayoutConstraint.Attribute);
}

export class NSTokenField extends NSTextField {
  completionDelay: number;
  setCompletionDelay(_: number);
  delegate: any;
  setDelegate(_: any);
  tokenStyle: NSTokenFieldCell.NSTokenField.TokenStyle;
  setTokenStyle(_: NSTokenFieldCell.NSTokenField.TokenStyle);
  tokenizingCharacterSet: CharacterSet;
  setTokenizingCharacterSet(_: CharacterSet);
  static defaultCompletionDelay: number;
  static defaultTokenizingCharacterSet: CharacterSet;
}

export class NSTokenFieldCell extends NSTextFieldCell {
  completionDelay: number;
  setCompletionDelay(_: number);
  delegate: any;
  setDelegate(_: any);
  tokenStyle: NSTokenFieldCell.NSTokenField.TokenStyle;
  setTokenStyle(_: NSTokenFieldCell.NSTokenField.TokenStyle);
  tokenizingCharacterSet: CharacterSet;
  setTokenizingCharacterSet(_: CharacterSet);
  static defaultCompletionDelay: number;
  static defaultTokenizingCharacterSet: CharacterSet;
}

interface NSTokenFieldCellDelegate {
  tokenFieldCellCompletionsForSubstringIndexOfTokenIndexOfSelectedItem(_: NSTokenFieldCell, completionsForSubstring: string, indexOfToken: number, indexOfSelectedItem: number): any[];
  tokenFieldCellShouldAddObjectsAtIndex(_: NSTokenFieldCell, shouldAdd: any[], at: number): any[];
  tokenFieldCellDisplayStringForRepresentedObject(_: NSTokenFieldCell, displayStringForRepresentedObject: any): string;
  tokenFieldCellEditingStringForRepresentedObject(_: NSTokenFieldCell, editingStringForRepresentedObject: any): string;
  tokenFieldCellRepresentedObjectForEditingString(_: NSTokenFieldCell, representedObjectForEditing: string): any;
  tokenFieldCellWriteRepresentedObjectsToPasteboard(_: NSTokenFieldCell, writeRepresentedObjects: any[], to: NSPasteboard): boolean;
  tokenFieldCellReadFromPasteboard(_: NSTokenFieldCell, readFrom: NSPasteboard): any[];
  tokenFieldCellMenuForRepresentedObject(_: NSTokenFieldCell, menuForRepresentedObject: any): NSMenu;
  tokenFieldCellHasMenuForRepresentedObject(_: NSTokenFieldCell, hasMenuForRepresentedObject: any): boolean;
  tokenFieldCellStyleForRepresentedObject(_: NSTokenFieldCell, styleForRepresentedObject: any): NSTokenFieldCell.NSTokenField.TokenStyle;
}

interface NSTokenFieldDelegate {
  tokenFieldCompletionsForSubstringIndexOfTokenIndexOfSelectedItem(_: NSTokenField, completionsForSubstring: string, indexOfToken: number, indexOfSelectedItem?: number): any[];
  tokenFieldShouldAddObjectsAtIndex(_: NSTokenField, shouldAdd: any[], at: number): any[];
  tokenFieldDisplayStringForRepresentedObject(_: NSTokenField, displayStringForRepresentedObject: any): string;
  tokenFieldEditingStringForRepresentedObject(_: NSTokenField, editingStringForRepresentedObject: any): string;
  tokenFieldRepresentedObjectForEditingString(_: NSTokenField, representedObjectForEditing: string): any;
  tokenFieldWriteRepresentedObjectsToPasteboard(_: NSTokenField, writeRepresentedObjects: any[], to: NSPasteboard): boolean;
  tokenFieldReadFromPasteboard(_: NSTokenField, readFrom: NSPasteboard): any[];
  tokenFieldMenuForRepresentedObject(_: NSTokenField, menuForRepresentedObject: any): NSMenu;
  tokenFieldHasMenuForRepresentedObject(_: NSTokenField, hasMenuForRepresentedObject: any): boolean;
  tokenFieldStyleForRepresentedObject(_: NSTokenField, styleForRepresentedObject: any): NSTokenFieldCell.NSTokenField.TokenStyle;
}

export class NSToolbar extends NSObject {
  allowsExtensionItems: boolean;
  setAllowsExtensionItems(_: boolean);
  allowsUserCustomization: boolean;
  setAllowsUserCustomization(_: boolean);
  autosavesConfiguration: boolean;
  setAutosavesConfiguration(_: boolean);
  centeredItemIdentifier: string;
  setCenteredItemIdentifier(_: string);
  configurationDictionary: Map<string, any>;
  customizationPaletteIsRunning: boolean;
  delegate: any;
  setDelegate(_: any);
  displayMode: NSToolbar.DisplayMode;
  setDisplayMode(_: NSToolbar.DisplayMode);
  identifier: string;
  items: NSToolbarItem[];
  selectedItemIdentifier: string;
  setSelectedItemIdentifier(_: string);
  showsBaselineSeparator: boolean;
  setShowsBaselineSeparator(_: boolean);
  sizeMode: NSToolbar.SizeMode;
  setSizeMode(_: NSToolbar.SizeMode);
  isVisible: boolean;
  setVisible(_: boolean);
  visibleItems: NSToolbarItem[];
  static initWithIdentifier(_: string): NSToolbar;
  insertItemWithItemIdentifierAtIndex(withItemIdentifier: string, at: number): void;
  removeItemAtIndex(at: number): void;
  runCustomizationPalette(_?: any): void;
  setConfigurationFromDictionary(_: Map<string, any>): void;
  validateVisibleItems(): void;
}

interface NSToolbarDelegate {
  toolbarItemForItemIdentifierWillBeInsertedIntoToolbar(_: NSToolbar, itemForItemIdentifier: string, willBeInsertedIntoToolbar: boolean): NSToolbarItem;
  toolbarAllowedItemIdentifiers(_: NSToolbar): string[];
  toolbarDefaultItemIdentifiers(_: NSToolbar): string[];
  toolbarDidRemoveItem(_: Notification): void;
  toolbarSelectableItemIdentifiers(_: NSToolbar): string[];
  toolbarWillAddItem(_: Notification): void;
}

export class NSToolbarItem extends NSObject {
  action: string;
  setAction(_: string);
  allowsDuplicatesInToolbar: boolean;
  autovalidates: boolean;
  setAutovalidates(_: boolean);
  isBordered: boolean;
  setBordered(_: boolean);
  isEnabled: boolean;
  setEnabled(_: boolean);
  image: NSImage;
  setImage(_: NSImage);
  itemIdentifier: string;
  label: string;
  setLabel(_: string);
  maxSize: CGSize;
  setMaxSize(_: CGSize);
  menuFormRepresentation: NSMenuItem;
  setMenuFormRepresentation(_: NSMenuItem);
  minSize: CGSize;
  setMinSize(_: CGSize);
  paletteLabel: string;
  setPaletteLabel(_: string);
  tag: number;
  setTag(_: number);
  target: any;
  setTarget(_: any);
  title: string;
  setTitle(_: string);
  toolTip: string;
  setToolTip(_: string);
  toolbar: NSToolbar;
  visibilityPriority: number;
  setVisibilityPriority(_: number);
  static initWithItemIdentifier(_: string): NSToolbarItem;
  validate(): void;
}

export class NSToolbarItemGroup extends NSToolbarItem {
  controlRepresentation: NSToolbarItemGroup.ControlRepresentation;
  setControlRepresentation(_: NSToolbarItemGroup.ControlRepresentation);
  selectedIndex: number;
  setSelectedIndex(_: number);
  selectionMode: NSToolbarItemGroup.SelectionMode;
  setSelectionMode(_: NSToolbarItemGroup.SelectionMode);
  subitems: NSToolbarItem[];
  setSubitems(_: NSToolbarItem[]);
  isSelectedAtIndex(at: number): boolean;
  setSelectedAtIndex(_: boolean, at: number): void;
}

interface NSToolbarItemValidation {
  validateToolbarItem(_: NSToolbarItem): boolean;
}

export class NSTouch extends NSObject {
  device: any;
  deviceSize: CGSize;
  identity: any;
  normalizedPosition: CGPoint;
  phase: NSTouch.Phase;
  isResting: boolean;
  type: NSTouch.TouchType;
  locationInView(in_?: NSView): CGPoint;
  previousLocationInView(in_?: NSView): CGPoint;
}

export class NSTouchBar extends NSObject {
  customizationAllowedItemIdentifiers: string[];
  setCustomizationAllowedItemIdentifiers(_: string[]);
  customizationIdentifier: string;
  setCustomizationIdentifier(_: string);
  customizationRequiredItemIdentifiers: string[];
  setCustomizationRequiredItemIdentifiers(_: string[]);
  defaultItemIdentifiers: string[];
  setDefaultItemIdentifiers(_: string[]);
  delegate: any;
  setDelegate(_: any);
  escapeKeyReplacementItemIdentifier: string;
  setEscapeKeyReplacementItemIdentifier(_: string);
  itemIdentifiers: string[];
  principalItemIdentifier: string;
  setPrincipalItemIdentifier(_: string);
  templateItems: Set<any>;
  setTemplateItems(_: Set<any>);
  isVisible: boolean;
  static isAutomaticCustomizeTouchBarMenuItemEnabled: boolean;
  setAutomaticCustomizeTouchBarMenuItemEnabled(_: boolean);
  itemForIdentifier(forIdentifier: string): NSTouchBarItem;
}

interface NSTouchBarDelegate {
  touchBarMakeItemForIdentifier(_: NSTouchBar, makeItemForIdentifier: string): NSTouchBarItem;
}

export class NSTouchBarItem extends NSObject {
  customizationLabel: string;
  identifier: string;
  viewController: NSViewController;
  visibilityPriority: number;
  setVisibilityPriority(_: number);
  isVisible: boolean;
  static initWithIdentifier(_: string): NSTouchBarItem;
}

interface NSTouchBarProvider {
  touchBar: NSTouchBar;
}

export class NSTrackingArea extends NSObject {
  options: NSTrackingArea.Options;
  owner: any;
  rect: CGRect;
  userInfo: Map<any, any>;
  static initWithRectOptionsOwnerUserInfo(_: CGRect, options: NSTrackingArea.Options, owner?: any, userInfo?: Map<any, any>): NSTrackingArea;
}

export class NSTreeController extends NSObjectController {
  alwaysUsesMultipleValuesMarker: boolean;
  setAlwaysUsesMultipleValuesMarker(_: boolean);
  arrangedObjects: NSTreeNode;
  avoidsEmptySelection: boolean;
  setAvoidsEmptySelection(_: boolean);
  canAddChild: boolean;
  canInsert: boolean;
  canInsertChild: boolean;
  childrenKeyPath: string;
  setChildrenKeyPath(_: string);
  countKeyPath: string;
  setCountKeyPath(_: string);
  leafKeyPath: string;
  setLeafKeyPath(_: string);
  preservesSelection: boolean;
  setPreservesSelection(_: boolean);
  selectedNodes: NSTreeNode[];
  selectionIndexPath: IndexPath;
  selectionIndexPaths: IndexPath[];
  selectsInsertedObjects: boolean;
  setSelectsInsertedObjects(_: boolean);
  sortDescriptors: NSSortDescriptor[];
  setSortDescriptors(_: NSSortDescriptor[]);
  addChild(_?: any): void;
  addSelectionIndexPaths(_: IndexPath[]): boolean;
  // dupe name w instance property   childrenKeyPathForNode(for_: NSTreeNode): string;
  // dupe name w instance property   countKeyPathForNode(for_: NSTreeNode): string;
  insert(_?: any): void;
  insertChild(_?: any): void;
  insertObjectAtArrangedObjectIndexPath(_?: any, atArrangedObjectIndexPath?: IndexPath): void;
  insertObjectsAtArrangedObjectIndexPaths(_: any[], atArrangedObjectIndexPaths: IndexPath[]): void;
  // dupe name w instance property   leafKeyPathForNode(for_: NSTreeNode): string;
  moveNodeToIndexPath(_: NSTreeNode, to: IndexPath): void;
  moveNodesToIndexPath(_: NSTreeNode[], to: IndexPath): void;
  rearrangeObjects(): void;
  removeObjectAtArrangedObjectIndexPath(atArrangedObjectIndexPath: IndexPath): void;
  removeObjectsAtArrangedObjectIndexPaths(atArrangedObjectIndexPaths: IndexPath[]): void;
  removeSelectionIndexPaths(_: IndexPath[]): boolean;
  setSelectionIndexPath(_?: IndexPath): boolean;
  setSelectionIndexPaths(_: IndexPath[]): boolean;
}

export class NSTreeNode extends NSObject {
  childNodes: NSTreeNode[];
  indexPath: IndexPath;
  isLeaf: boolean;
  mutableChildNodes: NSTreeNode[];
  parentNode: NSTreeNode;
  representedObject: any;
  descendantNodeAtIndexPath(at: IndexPath): NSTreeNode;
  static initWithRepresentedObject(_?: any): NSTreeNode;
  sortWithSortDescriptorsRecursively(with_: NSSortDescriptor[], recursively: boolean): void;
}

export class NSTypesetter extends NSObject {
  static printingAdjustmentInLayoutManagerForNominallySpacedGlyphRangePackedGlyphsCount(in_: NSLayoutManager, forNominallySpacedGlyphRange: NSRange, packedGlyphs: string, count: number): CGSize;
  //  static sharedSystemTypesetterForBehavior(for_: NSLayoutManager.TypesetterBehavior): any;
  attributedString: NSAttributedString;
  setAttributedString(_: NSAttributedString);
  attributesForExtraLineFragment: Map<string, any>;
  bidiProcessingEnabled: boolean;
  setBidiProcessingEnabled(_: boolean);
  currentParagraphStyle: NSParagraphStyle;
  currentTextContainer: NSTextContainer;
  hyphenationFactor: number;
  setHyphenationFactor(_: number);
  layoutManager: NSLayoutManager;
  lineFragmentPadding: number;
  setLineFragmentPadding(_: number);
  paragraphCharacterRange: NSRange;
  paragraphGlyphRange: NSRange;
  paragraphSeparatorCharacterRange: NSRange;
  paragraphSeparatorGlyphRange: NSRange;
  textContainers: NSTextContainer[];
  typesetterBehavior: NSLayoutManager.TypesetterBehavior;
  setTypesetterBehavior(_: NSLayoutManager.TypesetterBehavior);
  usesFontLeading: boolean;
  setUsesFontLeading(_: boolean);
  static defaultTypesetterBehavior: NSLayoutManager.TypesetterBehavior;
  static sharedSystemTypesetter: NSTypesetter;
  actionForControlCharacterAtIndex(at: number): NSTypesetter.NSTypesetterControlCharacterAction;
  baselineOffsetInLayoutManagerGlyphIndex(in_: NSLayoutManager, glyphIndex: number): number;
  beginLineWithGlyphAtIndex(withGlyphAt: number): void;
  beginParagraph(): void;
  boundingBoxForControlGlyphAtIndexForTextContainerProposedLineFragmentGlyphPositionCharacterIndex(forControlGlyphAt: number, for_: NSTextContainer, proposedLineFragment: CGRect, glyphPosition: CGPoint, characterIndex: number): CGRect;
  characterRangeForGlyphRangeActualGlyphRange(forGlyphRange: NSRange, actualGlyphRange?: NSRange): NSRange;
  endLineWithGlyphRange(withGlyphRange: NSRange): void;
  endParagraph(): void;
  getLineFragmentRectUsedRectForParagraphSeparatorGlyphRangeAtProposedOrigin(_: CGRect, usedRect: CGRect, forParagraphSeparatorGlyphRange: NSRange, atProposedOrigin: CGPoint): void;
  getLineFragmentRectUsedRectRemainingRectForStartingGlyphAtIndexProposedRectLineSpacingParagraphSpacingBeforeParagraphSpacingAfter(_: CGRect, usedRect: CGRect, remaining: CGRect, forStartingGlyphAt: number, proposedRect: CGRect, lineSpacing: number, paragraphSpacingBefore: number, paragraphSpacingAfter: number): void;
  glyphRangeForCharacterRangeActualCharacterRange(forCharacterRange: NSRange, actualCharacterRange?: NSRange): NSRange;
  hyphenCharacterForGlyphAtIndex(forGlyphAt: number): number;
  // dupe name w instance property   hyphenationFactorForGlyphAtIndex(forGlyphAt: number): number;
  layoutCharactersInRangeForLayoutManagerMaximumNumberOfLineFragments(in_: NSRange, for_: NSLayoutManager, maximumNumberOfLineFragments: number): NSRange;
  layoutGlyphsInLayoutManagerStartingAtGlyphIndexMaxNumberOfLineFragmentsNextGlyphIndex(in_: NSLayoutManager, startingAtGlyphIndex: number, maxNumberOfLineFragments: number, nextGlyphIndex: number): void;
  layoutParagraphAtPoint(at: CGPoint): number;
  lineSpacingAfterGlyphAtIndexWithProposedLineFragmentRect(afterGlyphAt: number, withProposedLineFragmentRect: CGRect): number;
  paragraphSpacingAfterGlyphAtIndexWithProposedLineFragmentRect(afterGlyphAt: number, withProposedLineFragmentRect: CGRect): number;
  paragraphSpacingBeforeGlyphAtIndexWithProposedLineFragmentRect(beforeGlyphAt: number, withProposedLineFragmentRect: CGRect): number;
  setAttachmentSizeForGlyphRange(_: CGSize, forGlyphRange: NSRange): void;
  setBidiLevelsForGlyphRange(_: string, forGlyphRange: NSRange): void;
  setDrawsOutsideLineFragmentForGlyphRange(_: boolean, forGlyphRange: NSRange): void;
  setHardInvalidationForGlyphRange(_: boolean, forGlyphRange: NSRange): void;
  setLineFragmentRectForGlyphRangeUsedRectBaselineOffset(_: CGRect, forGlyphRange: NSRange, usedRect: CGRect, baselineOffset: number): void;
  setLocationWithAdvancementsForStartOfGlyphRange(_: CGPoint, withAdvancements: number, forStartOfGlyphRange: NSRange): void;
  setNotShownAttributeForGlyphRange(_: boolean, forGlyphRange: NSRange): void;
  setParagraphGlyphRangeSeparatorGlyphRange(_: NSRange, separatorGlyphRange: NSRange): void;
  shouldBreakLineByHyphenatingBeforeCharacterAtIndex(byHyphenatingBeforeCharacterAt: number): boolean;
  shouldBreakLineByWordBeforeCharacterAtIndex(byWordBeforeCharacterAt: number): boolean;
  substituteFontForFont(for_: NSFont): NSFont;
  textTabForGlyphLocationWritingDirectionMaxLocation(forGlyphLocation: number, writingDirection: NSText.NSWritingDirection, maxLocation: number): NSTextTab;
  willSetLineFragmentRectForGlyphRangeUsedRectBaselineOffset(_: CGRect, forGlyphRange: NSRange, usedRect: CGRect, baselineOffset: number): void;
}

// export function NSUnregisterServicesProvider(name: string): void;

// export function NSUpdateDynamicServices(): void;

interface NSUserActivityRestoring {
  restoreUserActivityState(_: NSUserActivity): void;
}

export class NSUserDefaultsController extends NSController {
  appliesImmediately: boolean;
  setAppliesImmediately(_: boolean);
  defaults: UserDefaults;
  hasUnappliedChanges: boolean;
  initialValues: Map<string, any>;
  setInitialValues(_: Map<string, any>);
  values: any;
  static sharedUserDefaultsController: NSUserDefaultsController;
  static initWithDefaultsInitialValues(_?: UserDefaults, initialValues?: Map<string, any>): NSUserDefaultsController;
  revert(_?: any): void;
  revertToInitialValues(_?: any): void;
  save(_?: any): void;
}

interface NSUserInterfaceCompression {
  activeCompressionOptions: NSUserInterfaceCompressionOptions;
  compressWithPrioritizedCompressionOptions(withPrioritizedCompressionOptions: NSUserInterfaceCompressionOptions[]): void;
  minimumSizeWithPrioritizedCompressionOptions(withPrioritizedCompressionOptions: NSUserInterfaceCompressionOptions[]): CGSize;
}

export class NSUserInterfaceCompressionOptions extends NSObject {
  isEmpty: boolean;
  static breakEqualWidthsOption: NSUserInterfaceCompressionOptions;
  static hideImagesOption: NSUserInterfaceCompressionOptions;
  static hideTextOption: NSUserInterfaceCompressionOptions;
  static reduceMetricsOption: NSUserInterfaceCompressionOptions;
  static standardOptions: NSUserInterfaceCompressionOptions;
  containsOptions(_: NSUserInterfaceCompressionOptions): boolean;
  static initWithIdentifier(_: string): NSUserInterfaceCompressionOptions;
  intersectsOptions(_: NSUserInterfaceCompressionOptions): boolean;
  optionsByAddingOptions(_: NSUserInterfaceCompressionOptions): NSUserInterfaceCompressionOptions;
  optionsByRemovingOptions(_: NSUserInterfaceCompressionOptions): NSUserInterfaceCompressionOptions;
}

interface NSUserInterfaceItemIdentification {
  identifier: string;
  setIdentifier(_: string);
}

interface NSUserInterfaceItemSearching {
  localizedTitlesForItem(forItem: any): string[];
  performActionForItem(forItem: any): void;
  searchForItemsWithSearchStringResultLimitMatchedItemHandler(withSearch: string, resultLimit: number, matchedItemHandler: (p1: any[]) => void): void;
  showAllHelpTopicsForSearchString(forSearch: string): void;
}

interface NSUserInterfaceValidations {
  validateUserInterfaceItem(_: any): boolean;
}

interface NSValidatedUserInterfaceItem {
  action: string;
  tag: number;
}

export class NSView extends NSResponder implements NSUserInterfaceItemIdentification {
  alignmentRectInsets: NSEdgeInsets;
  allowedTouchTypes: NSTouch.TouchTypeMask;
  setAllowedTouchTypes(_: NSTouch.TouchTypeMask);
  allowsVibrancy: boolean;
  alphaValue: number;
  setAlphaValue(_: number);
  autoresizesSubviews: boolean;
  setAutoresizesSubviews(_: boolean);
  autoresizingMask: NSView.AutoresizingMask;
  setAutoresizingMask(_: NSView.AutoresizingMask);
  backgroundFilters: CIFilter[];
  setBackgroundFilters(_: CIFilter[]);
  baselineOffsetFromBottom: number;
  bottomAnchor: NSLayoutYAxisAnchor;
  bounds: CGRect;
  setBounds(_: CGRect);
  boundsRotation: number;
  setBoundsRotation(_: number);
  canBecomeKeyView: boolean;
  canDrawConcurrently: boolean;
  setCanDrawConcurrently(_: boolean);
  canDrawSubviewsIntoLayer: boolean;
  setCanDrawSubviewsIntoLayer(_: boolean);
  candidateListTouchBarItem: NSCandidateListTouchBarItem<any>;
  centerXAnchor: NSLayoutXAxisAnchor;
  centerYAnchor: NSLayoutYAxisAnchor;
  compositingFilter: CIFilter;
  setCompositingFilter(_: CIFilter);
  constraints: NSLayoutConstraint[];
  contentFilters: CIFilter[];
  setContentFilters(_: CIFilter[]);
  isDrawingFindIndicator: boolean;
  enclosingMenuItem: NSMenuItem;
  enclosingScrollView: NSScrollView;
  firstBaselineAnchor: NSLayoutYAxisAnchor;
  firstBaselineOffsetFromTop: number;
  fittingSize: CGSize;
  isFlipped: boolean;
  focusRingMaskBounds: CGRect;
  focusRingType: NSGraphics.NSFocusRingType;
  setFocusRingType(_: NSGraphics.NSFocusRingType);
  frame: CGRect;
  setFrame(_: CGRect);
  frameCenterRotation: number;
  setFrameCenterRotation(_: number);
  frameRotation: number;
  setFrameRotation(_: number);
  gestureRecognizers: NSGestureRecognizer[];
  setGestureRecognizers(_: NSGestureRecognizer[]);
  hasAmbiguousLayout: boolean;
  heightAdjustLimit: number;
  heightAnchor: NSLayoutDimension;
  isHidden: boolean;
  setHidden(_: boolean);
  isHiddenOrHasHiddenAncestor: boolean;
  isHorizontalContentSizeConstraintActive: boolean;
  setHorizontalContentSizeConstraintActive(_: boolean);
  isInFullScreenMode: boolean;
  inLiveResize: boolean;
  inputContext: NSTextInputContext;
  intrinsicContentSize: CGSize;
  lastBaselineAnchor: NSLayoutYAxisAnchor;
  lastBaselineOffsetFromBottom: number;
  layerContentsPlacement: NSView.LayerContentsPlacement;
  setLayerContentsPlacement(_: NSView.LayerContentsPlacement);
  layerContentsRedrawPolicy: NSView.LayerContentsRedrawPolicy;
  setLayerContentsRedrawPolicy(_: NSView.LayerContentsRedrawPolicy);
  layerUsesCoreImageFilters: boolean;
  setLayerUsesCoreImageFilters(_: boolean);
  layoutGuides: NSLayoutGuide[];
  leadingAnchor: NSLayoutXAxisAnchor;
  leftAnchor: NSLayoutXAxisAnchor;
  mouseDownCanMoveWindow: boolean;
  needsDisplay: boolean;
  setNeedsDisplay(_: boolean);
  needsLayout: boolean;
  setNeedsLayout(_: boolean);
  needsPanelToBecomeKey: boolean;
  needsUpdateConstraints: boolean;
  setNeedsUpdateConstraints(_: boolean);
  nextKeyView: NSView;
  setNextKeyView(_: NSView);
  nextValidKeyView: NSView;
  isOpaque: boolean;
  opaqueAncestor: NSView;
  pageFooter: NSAttributedString;
  pageHeader: NSAttributedString;
  postsBoundsChangedNotifications: boolean;
  setPostsBoundsChangedNotifications(_: boolean);
  postsFrameChangedNotifications: boolean;
  setPostsFrameChangedNotifications(_: boolean);
  preparedContentRect: CGRect;
  setPreparedContentRect(_: CGRect);
  preservesContentDuringLiveResize: boolean;
  pressureConfiguration: NSPressureConfiguration;
  setPressureConfiguration(_: NSPressureConfiguration);
  previousKeyView: NSView;
  previousValidKeyView: NSView;
  printJobTitle: string;
  rectPreservedDuringLiveResize: CGRect;
  registeredDraggedTypes: string[];
  rightAnchor: NSLayoutXAxisAnchor;
  isRotatedFromBase: boolean;
  isRotatedOrScaledFromBase: boolean;
  shadow: NSShadow;
  setShadow(_: NSShadow);
  subviews: NSView[];
  setSubviews(_: NSView[]);
  superview: NSView;
  tag: number;
  toolTip: string;
  setToolTip(_: string);
  topAnchor: NSLayoutYAxisAnchor;
  trackingAreas: NSTrackingArea[];
  trailingAnchor: NSLayoutXAxisAnchor;
  translatesAutoresizingMaskIntoConstraints: boolean;
  setTranslatesAutoresizingMaskIntoConstraints(_: boolean);
  userInterfaceLayoutDirection: NSUserInterfaceLayout.NSUserInterfaceLayoutDirection;
  setUserInterfaceLayoutDirection(_: NSUserInterfaceLayout.NSUserInterfaceLayoutDirection);
  isVerticalContentSizeConstraintActive: boolean;
  setVerticalContentSizeConstraintActive(_: boolean);
  visibleRect: CGRect;
  wantsDefaultClipping: boolean;
  wantsLayer: boolean;
  setWantsLayer(_: boolean);
  wantsRestingTouches: boolean;
  setWantsRestingTouches(_: boolean);
  wantsUpdateLayer: boolean;
  widthAdjustLimit: number;
  widthAnchor: NSLayoutDimension;
  window: NSWindow;
  static isCompatibleWithResponsiveScrolling: boolean;
  static defaultFocusRingType: NSGraphics.NSFocusRingType;
  static defaultMenu: NSMenu;
  static focusView: NSView;
  static requiresConstraintBasedLayout: boolean;
  identifier: string;
  setIdentifier(_: string);
  acceptsFirstMouse(for_?: NSEvent): boolean;
  addConstraint(_: NSLayoutConstraint): void;
  addConstraints(_: NSLayoutConstraint[]): void;
  addCursorRectCursor(_: CGRect, cursor: NSCursor): void;
  addGestureRecognizer(_: NSGestureRecognizer): void;
  addLayoutGuide(_: NSLayoutGuide): void;
  addSubview(_: NSView): void;
  addSubviewPositionedRelativeTo(_: NSView, positioned: NSGraphics.NSWindow.OrderingMode, relativeTo?: NSView): void;
  addToolTipRectOwnerUserData(_: CGRect, owner: any, userData?: any): number;
  addTrackingArea(_: NSTrackingArea): void;
  addTrackingRectOwnerUserDataAssumeInside(_: CGRect, owner: any, userData?: any, assumeInside?: boolean): number;
  adjustPageHeightNewTopBottomLimit(_: number, top: number, bottom: number, limit: number): void;
  adjustPageWidthNewLeftRightLimit(_: number, left: number, right: number, limit: number): void;
  adjustScroll(_: CGRect): CGRect;
  alignmentRectForFrame(forFrame: CGRect): CGRect;
  ancestorSharedWithView(with_: NSView): NSView;
  autoscroll(with_: NSEvent): boolean;
  backingAlignedRectOptions(_: CGRect, options: NSGeometry.AlignmentOptions): CGRect;
  beginDocument(): void;
  beginDraggingSessionWithItemsEventSource(with_: NSDraggingItem[], event: NSEvent, source: any): NSDraggingSession;
  beginPageInRectAtPlacement(in_: CGRect, atPlacement: CGPoint): void;
  bitmapImageRepForCachingDisplayInRect(in_: CGRect): NSBitmapImageRep;
  cacheDisplayInRectToBitmapImageRep(in_: CGRect, to: NSBitmapImageRep): void;
  centerScanRect(_: CGRect): CGRect;
  constraintsAffectingLayoutForOrientation(for_: NSLayoutConstraint.Orientation): NSLayoutConstraint[];
  contentCompressionResistancePriorityForOrientation(for_: NSLayoutConstraint.Orientation): number;
  contentHuggingPriorityForOrientation(for_: NSLayoutConstraint.Orientation): number;
  convertPointFromView(_: CGPoint, from?: NSView): CGPoint;
  convertPointToView(_: CGPoint, to?: NSView): CGPoint;
  convertPointFromBacking(_: CGPoint): CGPoint;
  convertPointFromLayer(_: CGPoint): CGPoint;
  convertPointToBacking(_: CGPoint): CGPoint;
  convertPointToLayer(_: CGPoint): CGPoint;
  convertRectFromView(_: CGRect, from?: NSView): CGRect;
  convertRectToView(_: CGRect, to?: NSView): CGRect;
  convertRectFromBacking(_: CGRect): CGRect;
  convertRectFromLayer(_: CGRect): CGRect;
  convertRectToBacking(_: CGRect): CGRect;
  convertRectToLayer(_: CGRect): CGRect;
  convertSizeFromView(_: CGSize, from?: NSView): CGSize;
  convertSizeToView(_: CGSize, to?: NSView): CGSize;
  convertSizeFromBacking(_: CGSize): CGSize;
  convertSizeFromLayer(_: CGSize): CGSize;
  convertSizeToBacking(_: CGSize): CGSize;
  convertSizeToLayer(_: CGSize): CGSize;
  dataWithEPSInsideRect(inside: CGRect): Data;
  dataWithPDFInsideRect(inside: CGRect): Data;
  didAddSubview(_: NSView): void;
  didCloseMenuWithEvent(_: NSMenu, with_?: NSEvent): void;
  discardCursorRects(): void;
  display(): void;
  displayIfNeeded(): void;
  displayIfNeededIgnoringOpacity(): void;
  displayIfNeededInRect(_: CGRect): void;
  displayIfNeededInRectIgnoringOpacity(_: CGRect): void;
  displayRect(_: CGRect): void;
  displayRectIgnoringOpacity(_: CGRect): void;
  displayRectIgnoringOpacityInContext(_: CGRect, in_: NSGraphicsContext): void;
  drawFocusRingMask(): void;
  drawPageBorderWithSize(with_: CGSize): void;
  drawRect(_: CGRect): void;
  endDocument(): void;
  endPage(): void;
  enterFullScreenModeWithOptions(_: NSScreen, withOptions?: Map<string, any>): boolean;
  exerciseAmbiguityInLayout(): void;
  exitFullScreenModeWithOptions(options?: Map<string, any>): void;
  // dupe name w instance property   frameForAlignmentRect(forAlignmentRect: CGRect): CGRect;
  getRectsBeingDrawnCount(_?: CGRect, count?: number): void;
  getRectsExposedDuringLiveResizeCount(_: CGRect, count: number): void;
  hitTest(_: CGPoint): NSView;
  static initWithFrame(_: CGRect): NSView;
  invalidateIntrinsicContentSize(): void;
  isDescendantOf(of: NSView): boolean;
  knowsPageRange(_: NSRange): boolean;
  layout(): void;
  layoutSubtreeIfNeeded(): void;
  locationOfPrintRect(_: CGRect): CGPoint;
  makeBackingLayer(): CALayer;
  mouseInRect(_: CGPoint, in_: CGRect): boolean;
  needsToDrawRect(_: CGRect): boolean;
  noteFocusRingMaskChanged(): void;
  prepareContentInRect(in_: CGRect): void;
  prepareForReuse(): void;
  print(_?: any): void;
  rectForPage(_: number): CGRect;
  rectForSmartMagnificationAtPointInRect(at: CGPoint, in_: CGRect): CGRect;
  reflectScrolledClipView(_: NSClipView): void;
  registerForDraggedTypes(_: string[]): void;
  removeAllToolTips(): void;
  removeConstraint(_: NSLayoutConstraint): void;
  removeConstraints(_: NSLayoutConstraint[]): void;
  removeCursorRectCursor(_: CGRect, cursor: NSCursor): void;
  removeFromSuperview(): void;
  removeFromSuperviewWithoutNeedingDisplay(): void;
  removeGestureRecognizer(_: NSGestureRecognizer): void;
  removeLayoutGuide(_: NSLayoutGuide): void;
  removeToolTip(_: number): void;
  removeTrackingArea(_: NSTrackingArea): void;
  removeTrackingRect(_: number): void;
  replaceSubviewWith(_: NSView, with_: NSView): void;
  resetCursorRects(): void;
  resizeSubviewsWithOldSize(withOldSize: CGSize): void;
  resizeWithOldSuperviewSize(withOldSuperviewSize: CGSize): void;
  rotateByAngle(byDegrees: number): void;
  rulerViewDidAddMarker(_: NSRulerView, didAdd: NSRulerMarker): void;
  rulerViewDidMoveMarker(_: NSRulerView, didMove: NSRulerMarker): void;
  rulerViewDidRemoveMarker(_: NSRulerView, didRemove: NSRulerMarker): void;
  rulerViewHandleMouseDown(_: NSRulerView, handleMouseDownWith: NSEvent): void;
  rulerViewLocationForPoint(_: NSRulerView, locationFor: CGPoint): number;
  rulerViewPointForLocation(_: NSRulerView, pointForLocation: number): CGPoint;
  rulerViewShouldAddMarker(_: NSRulerView, shouldAdd: NSRulerMarker): boolean;
  rulerViewShouldMoveMarker(_: NSRulerView, shouldMove: NSRulerMarker): boolean;
  rulerViewShouldRemoveMarker(_: NSRulerView, shouldRemove: NSRulerMarker): boolean;
  rulerViewWillAddMarkerAtLocation(_: NSRulerView, willAdd: NSRulerMarker, atLocation: number): number;
  rulerViewWillMoveMarkerToLocation(_: NSRulerView, willMove: NSRulerMarker, toLocation: number): number;
  rulerViewWillSetClientView(_: NSRulerView, willSetClientView: NSView): void;
  scaleUnitSquareToSize(to: CGSize): void;
  scrollClipViewToPoint(_: NSClipView, to: CGPoint): void;
  scrollPoint(_: CGPoint): void;
  scrollRectToVisible(_: CGRect): boolean;
  setBoundsOrigin(_: CGPoint): void;
  setBoundsSize(_: CGSize): void;
  setContentCompressionResistancePriorityForOrientation(_: number, for_: NSLayoutConstraint.Orientation): void;
  setContentHuggingPriorityForOrientation(_: number, for_: NSLayoutConstraint.Orientation): void;
  setFrameOrigin(_: CGPoint): void;
  setFrameSize(_: CGSize): void;
  setKeyboardFocusRingNeedsDisplayInRect(_: CGRect): void;
  setNeedsDisplayInRect(_: CGRect): void;
  shouldDelayWindowOrderingForEvent(for_: NSEvent): boolean;
  showDefinitionForAttributedStringAtPoint(for_?: NSAttributedString, at?: CGPoint): void;
  showDefinitionForAttributedStringRangeOptionsBaselineOriginProvider(for_?: NSAttributedString, range?: NSRange, options?: Map<string, any>, baselineOriginProvider?: (p1: NSRange) => CGPoint): void;
  sortSubviewsUsingFunctionContext(_?: (p1: NSView, p2: NSView, p3: any) => NSObjCRuntime.ComparisonResult, context?: any): void;
  translateOriginToPoint(to: CGPoint): void;
  translateRectsNeedingDisplayInRectBy(in_: CGRect, by: CGSize): void;
  unregisterDraggedTypes(): void;
  updateConstraints(): void;
  updateConstraintsForSubtreeIfNeeded(): void;
  updateLayer(): void;
  updateTrackingAreas(): void;
  viewDidChangeBackingProperties(): void;
  viewDidChangeEffectiveAppearance(): void;
  viewDidEndLiveResize(): void;
  viewDidHide(): void;
  viewDidMoveToSuperview(): void;
  viewDidMoveToWindow(): void;
  viewDidUnhide(): void;
  viewWillDraw(): void;
  viewWillMoveToSuperview(toSuperview?: NSView): void;
  viewWillMoveToWindow(toWindow?: NSWindow): void;
  viewWillStartLiveResize(): void;
  viewWithTag(_: number): NSView;
  willOpenMenuWithEvent(_: NSMenu, with_: NSEvent): void;
  willRemoveSubview(_: NSView): void;
  writeEPSInsideRectToPasteboard(inside: CGRect, to: NSPasteboard): void;
  writePDFInsideRectToPasteboard(inside: CGRect, to: NSPasteboard): void;
}

export class NSViewAnimation extends NSAnimation {
  viewAnimations: Map<string, any>[];
  setViewAnimations(_: Map<string, any>[]);
  static initWithViewAnimations(_: Map<string, any>[]): NSViewAnimation;
}

export class NSViewController extends NSResponder implements NSUserInterfaceItemIdentification {
  childViewControllers: NSViewController[];
  setChildViewControllers(_: NSViewController[]);
  extensionContext: NSExtensionContext;
  nibBundle: Bundle;
  nibName: string;
  parentViewController: NSViewController;
  preferredContentSize: CGSize;
  setPreferredContentSize(_: CGSize);
  preferredMaximumSize: CGSize;
  preferredMinimumSize: CGSize;
  preferredScreenOrigin: CGPoint;
  setPreferredScreenOrigin(_: CGPoint);
  presentedViewControllers: NSViewController[];
  presentingViewController: NSViewController;
  representedObject: any;
  setRepresentedObject(_: any);
  sourceItemView: NSView;
  setSourceItemView(_: NSView);
  storyboard: NSStoryboard;
  title: string;
  setTitle(_: string);
  isViewLoaded: boolean;
  identifier: string;
  setIdentifier(_: string);
  addChildViewController(_: NSViewController): void;
  dismissController(_?: any): void;
  dismissViewController(_: NSViewController): void;
  static initWithNibNameBundle(_?: string, bundle?: Bundle): NSViewController;
  insertChildViewControllerAtIndex(_: NSViewController, at: number): void;
  loadView(): void;
  preferredContentSizeDidChangeForViewController(for_: NSViewController): void;
  presentViewControllerAnimator(_: NSViewController, animator: any): void;
  presentViewControllerAsPopoverRelativeToRectOfViewPreferredEdgeBehavior(_: NSViewController, asPopoverRelativeTo: CGRect, of: NSView, preferredEdge: NSGeometry.NSRectEdge, behavior: NSPopover.Behavior): void;
  presentViewControllerAsModalWindow(_: NSViewController): void;
  presentViewControllerAsSheet(_: NSViewController): void;
  removeChildViewControllerAtIndex(at: number): void;
  removeFromParentViewController(): void;
  transitionFromViewControllerToViewControllerOptionsCompletionHandler(from: NSViewController, to: NSViewController, options: NSViewController.TransitionOptions, completionHandler?: () => void): void;
  updateViewConstraints(): void;
  viewDidAppear(): void;
  viewDidDisappear(): void;
  viewDidLayout(): void;
  viewDidLoad(): void;
  viewWillAppear(): void;
  viewWillDisappear(): void;
  viewWillLayout(): void;
  viewWillTransitionToSize(to: CGSize): void;
}

interface NSViewControllerPresentationAnimator {
  animateDismissalOfViewControllerFromViewController(of: NSViewController, from: NSViewController): void;
  animatePresentationOfViewControllerFromViewController(of: NSViewController, from: NSViewController): void;
}

interface NSViewLayerContentScaleDelegate {
  layerShouldInheritContentsScaleFromWindow(_: CALayer, shouldInheritContentsScale: number, from: NSWindow): boolean;
}

interface NSViewToolTipOwner {
  viewStringForToolTipPointUserData(_: NSView, stringForToolTip: number, point: CGPoint, userData?: any): string;
}

export class NSVisualEffectView extends NSView {
  blendingMode: NSVisualEffectView.BlendingMode;
  setBlendingMode(_: NSVisualEffectView.BlendingMode);
  isEmphasized: boolean;
  setEmphasized(_: boolean);
  interiorBackgroundStyle: NSCell.NSView.BackgroundStyle;
  maskImage: NSImage;
  setMaskImage(_: NSImage);
  material: NSVisualEffectView.Material;
  setMaterial(_: NSVisualEffectView.Material);
  state: NSVisualEffectView.State;
  setState(_: NSVisualEffectView.State);
}

export class NSWindow extends NSResponder implements NSUserInterfaceItemIdentification {
  static contentRectForFrameRectStyleMask(forFrameRect: CGRect, styleMask: NSWindow.StyleMask): CGRect;
  static frameRectForContentRectStyleMask(forContentRect: CGRect, styleMask: NSWindow.StyleMask): CGRect;
  static minFrameWidthWithTitleStyleMask(withTitle: string, styleMask: NSWindow.StyleMask): number;
  static removeFrameUsingName(usingName: string): void;
  static standardWindowButtonForStyleMask(_: NSWindow.ButtonType, for_: NSWindow.StyleMask): NSButton;
  //  static windowNumberAtPointBelowWindowWithWindowNumber(at: CGPoint, belowWindowWithWindowNumber: number): number;
  static windowNumbersWithOptions(options: NSWindow.NumberListOptions): number[];
  acceptsMouseMovedEvents: boolean;
  setAcceptsMouseMovedEvents(_: boolean);
  allowsConcurrentViewDrawing: boolean;
  setAllowsConcurrentViewDrawing(_: boolean);
  allowsToolTipsWhenApplicationIsInactive: boolean;
  setAllowsToolTipsWhenApplicationIsInactive(_: boolean);
  alphaValue: number;
  setAlphaValue(_: number);
  animationBehavior: NSWindow.AnimationBehavior;
  setAnimationBehavior(_: NSWindow.AnimationBehavior);
  appearanceSource: NSObject;
  setAppearanceSource(_: NSObject);
  areCursorRectsEnabled: boolean;
  aspectRatio: CGSize;
  setAspectRatio(_: CGSize);
  attachedSheet: NSWindow;
  autorecalculatesKeyViewLoop: boolean;
  setAutorecalculatesKeyViewLoop(_: boolean);
  backgroundColor: NSColor;
  setBackgroundColor(_: NSColor);
  backingScaleFactor: number;
  backingType: NSGraphics.NSWindow.BackingStoreType;
  setBackingType(_: NSGraphics.NSWindow.BackingStoreType);
  canBecomeKeyWindow: boolean;
  canBecomeMainWindow: boolean;
  canBecomeVisibleWithoutLogin: boolean;
  setCanBecomeVisibleWithoutLogin(_: boolean);
  canHide: boolean;
  setCanHide(_: boolean);
  childWindows: NSWindow[];
  collectionBehavior: NSWindow.CollectionBehavior;
  setCollectionBehavior(_: NSWindow.CollectionBehavior);
  colorSpace: NSColorSpace;
  setColorSpace(_: NSColorSpace);
  contentAspectRatio: CGSize;
  setContentAspectRatio(_: CGSize);
  contentLayoutGuide: any;
  contentLayoutRect: CGRect;
  contentMaxSize: CGSize;
  setContentMaxSize(_: CGSize);
  contentMinSize: CGSize;
  setContentMinSize(_: CGSize);
  contentResizeIncrements: CGSize;
  setContentResizeIncrements(_: CGSize);
  contentView: NSView;
  setContentView(_: NSView);
  contentViewController: NSViewController;
  setContentViewController(_: NSViewController);
  currentEvent: NSEvent;
  deepestScreen: NSScreen;
  defaultButtonCell: NSButtonCell;
  setDefaultButtonCell(_: NSButtonCell);
  delegate: any;
  setDelegate(_: any);
  depthLimit: NSGraphics.NSWindow.Depth;
  setDepthLimit(_: NSGraphics.NSWindow.Depth);
  deviceDescription: Map<string, any>;
  displaysWhenScreenProfileChanges: boolean;
  setDisplaysWhenScreenProfileChanges(_: boolean);
  dockTile: NSDockTile;
  isDocumentEdited: boolean;
  setDocumentEdited(_: boolean);
  isExcludedFromWindowsMenu: boolean;
  setExcludedFromWindowsMenu(_: boolean);
  firstResponder: NSResponder;
  isFloatingPanel: boolean;
  frame: CGRect;
  frameAutosaveName: string;
  hasCloseBox: boolean;
  hasDynamicDepthLimit: boolean;
  hasShadow: boolean;
  setHasShadow(_: boolean);
  hasTitleBar: boolean;
  hidesOnDeactivate: boolean;
  setHidesOnDeactivate(_: boolean);
  ignoresMouseEvents: boolean;
  setIgnoresMouseEvents(_: boolean);
  inLiveResize: boolean;
  initialFirstResponder: NSView;
  setInitialFirstResponder(_: NSView);
  keyViewSelectionDirection: NSWindow.SelectionDirection;
  isKeyWindow: boolean;
  level: number;
  setLevel(_: number);
  isMainWindow: boolean;
  maxFullScreenContentSize: CGSize;
  setMaxFullScreenContentSize(_: CGSize);
  maxSize: CGSize;
  setMaxSize(_: CGSize);
  minFullScreenContentSize: CGSize;
  setMinFullScreenContentSize(_: CGSize);
  minSize: CGSize;
  setMinSize(_: CGSize);
  isMiniaturizable: boolean;
  isMiniaturized: boolean;
  miniwindowImage: NSImage;
  setMiniwindowImage(_: NSImage);
  miniwindowTitle: string;
  setMiniwindowTitle(_: string);
  isModalPanel: boolean;
  mouseLocationOutsideOfEventStream: CGPoint;
  isMovable: boolean;
  setMovable(_: boolean);
  isMovableByWindowBackground: boolean;
  setMovableByWindowBackground(_: boolean);
  occlusionState: NSWindow.OcclusionState;
  isOnActiveSpace: boolean;
  isOpaque: boolean;
  setOpaque(_: boolean);
  orderedIndex: number;
  setOrderedIndex(_: number);
  parentWindow: NSWindow;
  setParentWindow(_: NSWindow);
  preservesContentDuringLiveResize: boolean;
  setPreservesContentDuringLiveResize(_: boolean);
  preventsApplicationTerminationWhenModal: boolean;
  setPreventsApplicationTerminationWhenModal(_: boolean);
  isReleasedWhenClosed: boolean;
  setReleasedWhenClosed(_: boolean);
  representedFilename: string;
  setRepresentedFilename(_: string);
  representedURL: URL;
  setRepresentedURL(_: URL);
  isResizable: boolean;
  resizeFlags: NSEvent.ModifierFlags;
  resizeIncrements: CGSize;
  setResizeIncrements(_: CGSize);
  isRestorable: boolean;
  setRestorable(_: boolean);
  restorationClass: typeof NSObject;
  setRestorationClass(_: typeof NSObject);
  screen: NSScreen;
  sharingType: NSWindow.SharingType;
  setSharingType(_: NSWindow.SharingType);
  isSheet: boolean;
  sheetParent: NSWindow;
  sheets: NSWindow[];
  showsResizeIndicator: boolean;
  setShowsResizeIndicator(_: boolean);
  showsToolbarButton: boolean;
  setShowsToolbarButton(_: boolean);
  stringWithSavedFrame: string;
  styleMask: NSWindow.StyleMask;
  setStyleMask(_: NSWindow.StyleMask);
  tab: NSWindowTab;
  tabGroup: NSWindowTabGroup;
  tabbedWindows: NSWindow[];
  tabbingIdentifier: string;
  setTabbingIdentifier(_: string);
  tabbingMode: NSWindow.TabbingMode;
  setTabbingMode(_: NSWindow.TabbingMode);
  title: string;
  setTitle(_: string);
  titleVisibility: NSWindow.TitleVisibility;
  setTitleVisibility(_: NSWindow.TitleVisibility);
  titlebarAccessoryViewControllers: NSTitlebarAccessoryViewController[];
  setTitlebarAccessoryViewControllers(_: NSTitlebarAccessoryViewController[]);
  titlebarAppearsTransparent: boolean;
  setTitlebarAppearsTransparent(_: boolean);
  toolbar: NSToolbar;
  setToolbar(_: NSToolbar);
  viewsNeedDisplay: boolean;
  setViewsNeedDisplay(_: boolean);
  isVisible: boolean;
  windowController: NSWindowController;
  setWindowController(_: NSWindowController);
  windowNumber: number;
  windowRef: any;
  windowTitlebarLayoutDirection: NSUserInterfaceLayout.NSUserInterfaceLayoutDirection;
  worksWhenModal: boolean;
  isZoomable: boolean;
  isZoomed: boolean;
  static allowsAutomaticWindowTabbing: boolean;
  setAllowsAutomaticWindowTabbing(_: boolean);
  static defaultDepthLimit: NSGraphics.NSWindow.Depth;
  static userTabbingPreference: NSWindow.UserTabbingPreference;
  identifier: string;
  setIdentifier(_: string);
  addChildWindowOrdered(_: NSWindow, ordered: NSGraphics.NSWindow.OrderingMode): void;
  addTabbedWindowOrdered(_: NSWindow, ordered: NSGraphics.NSWindow.OrderingMode): void;
  addTitlebarAccessoryViewController(_: NSTitlebarAccessoryViewController): void;
  anchorAttributeForOrientation(for_: NSLayoutConstraint.Orientation): NSLayoutConstraint.Attribute;
  animationResizeTime(_: CGRect): number;
  autorecalculatesContentBorderThicknessForEdge(for_: NSGeometry.NSRectEdge): boolean;
  backingAlignedRectOptions(_: CGRect, options: NSGeometry.AlignmentOptions): CGRect;
  becomeKeyWindow(): void;
  becomeMainWindow(): void;
  beginCriticalSheetCompletionHandler(_: NSWindow, completionHandler?: (p1: number) => void): void;
  beginSheetCompletionHandler(_: NSWindow, completionHandler?: (p1: number) => void): void;
  canRepresentDisplayGamut(_: NSGraphics.NSDisplayGamut): boolean;
  cascadeTopLeftFromPoint(from: CGPoint): CGPoint;
  center(): void;
  close(): void;
  constrainFrameRectToScreen(_: CGRect, to?: NSScreen): CGRect;
  contentBorderThicknessForEdge(for_: NSGeometry.NSRectEdge): number;
  contentRectForFrameRect(forFrameRect: CGRect): CGRect;
  convertPointFromBacking(_: CGPoint): CGPoint;
  convertPointFromScreen(fromScreen: CGPoint): CGPoint;
  convertPointToBacking(_: CGPoint): CGPoint;
  convertPointToScreen(toScreen: CGPoint): CGPoint;
  convertRectFromBacking(_: CGRect): CGRect;
  convertRectFromScreen(_: CGRect): CGRect;
  convertRectToBacking(_: CGRect): CGRect;
  convertRectToScreen(_: CGRect): CGRect;
  dataWithEPSInsideRect(inside: CGRect): Data;
  dataWithPDFInsideRect(inside: CGRect): Data;
  deminiaturize(_?: any): void;
  disableCursorRects(): void;
  disableKeyEquivalentForDefaultButtonCell(): void;
  disableScreenUpdatesUntilFlush(): void;
  disableSnapshotRestoration(): void;
  discardCursorRects(): void;
  discardEventsMatchingMaskBeforeEvent(matching: NSEvent.EventTypeMask, before?: NSEvent): void;
  display(): void;
  displayIfNeeded(): void;
  dragImageAtOffsetEventPasteboardSourceSlideBack(_: NSImage, at: CGPoint, offset: CGSize, event: NSEvent, pasteboard: NSPasteboard, source: any, slideBack: boolean): void;
  enableCursorRects(): void;
  enableKeyEquivalentForDefaultButtonCell(): void;
  enableSnapshotRestoration(): void;
  endEditingFor(for_?: any): void;
  endSheet(_: NSWindow): void;
  endSheetReturnCode(_: NSWindow, returnCode: number): void;
  fieldEditorForObject(_: boolean, for_?: any): NSText;
  frameRectForContentRect(forContentRect: CGRect): CGRect;
  handleCloseScriptCommand(_: NSCloseCommand): any;
  handlePrintScriptCommand(_: NSScriptCommand): any;
  handleSaveScriptCommand(_: NSScriptCommand): any;
  static initWithContentRectStyleMaskBackingDefer(_: CGRect, styleMask: NSWindow.StyleMask, backing: NSGraphics.NSWindow.BackingStoreType, defer: boolean): NSWindow;
  static initWithContentRectStyleMaskBackingDeferScreen(_: CGRect, styleMask: NSWindow.StyleMask, backing: NSGraphics.NSWindow.BackingStoreType, defer: boolean, screen?: NSScreen): NSWindow;
  static initWithWindowRef(_: any): NSWindow;
  insertTitlebarAccessoryViewControllerAtIndex(_: NSTitlebarAccessoryViewController, at: number): void;
  invalidateCursorRectsForView(for_: NSView): void;
  invalidateShadow(): void;
  layoutIfNeeded(): void;
  makeFirstResponder(_?: NSResponder): boolean;
  makeKeyAndOrderFront(_?: any): void;
  makeKeyWindow(): void;
  makeMainWindow(): void;
  mergeAllWindows(_?: any): void;
  miniaturize(_?: any): void;
  moveTabToNewWindow(_?: any): void;
  nextEventMatchingMask(matching: NSEvent.EventTypeMask): NSEvent;
  nextEventMatchingMaskUntilDateInModeDequeue(matching: NSEvent.EventTypeMask, until?: Date, inMode?: string, dequeue?: boolean): NSEvent;
  orderBack(_?: any): void;
  orderFront(_?: any): void;
  orderFrontRegardless(): void;
  orderOut(_?: any): void;
  orderWindowRelativeTo(_: NSGraphics.NSWindow.OrderingMode, relativeTo: number): void;
  performClose(_?: any): void;
  performMiniaturize(_?: any): void;
  performWindowDragWithEvent(with_: NSEvent): void;
  performZoom(_?: any): void;
  postEventAtStart(_: NSEvent, atStart: boolean): void;
  print(_?: any): void;
  recalculateKeyViewLoop(): void;
  registerForDraggedTypes(_: string[]): void;
  removeChildWindow(_: NSWindow): void;
  removeTitlebarAccessoryViewControllerAtIndex(at: number): void;
  resetCursorRects(): void;
  resignKeyWindow(): void;
  resignMainWindow(): void;
  runToolbarCustomizationPalette(_?: any): void;
  saveFrameUsingName(usingName: string): void;
  selectKeyViewFollowingView(following: NSView): void;
  selectKeyViewPrecedingView(preceding: NSView): void;
  selectNextKeyView(_?: any): void;
  selectNextTab(_?: any): void;
  selectPreviousKeyView(_?: any): void;
  selectPreviousTab(_?: any): void;
  sendEvent(_: NSEvent): void;
  setAnchorAttributeForOrientation(_: NSLayoutConstraint.Attribute, for_: NSLayoutConstraint.Orientation): void;
  setAutorecalculatesContentBorderThicknessForEdge(_: boolean, for_: NSGeometry.NSRectEdge): void;
  setContentBorderThicknessForEdge(_: number, for_: NSGeometry.NSRectEdge): void;
  setContentSize(_: CGSize): void;
  setDynamicDepthLimit(_: boolean): void;
  setFrameDisplay(_: CGRect, display: boolean): void;
  setFrameDisplayAnimate(_: CGRect, display: boolean, animate: boolean): void;
  setFrameAutosaveName(_: string): boolean;
  setFrameFromString(from: string): void;
  setFrameOrigin(_: CGPoint): void;
  setFrameTopLeftPoint(_: CGPoint): void;
  setFrameUsingName(_: string): boolean;
  setFrameUsingNameForce(_: string, force: boolean): boolean;
  setIsMiniaturized(_: boolean): void;
  setIsVisible(_: boolean): void;
  setIsZoomed(_: boolean): void;
  setTitleWithRepresentedFilename(_: string): void;
  standardWindowButton(_: NSWindow.ButtonType): NSButton;
  toggleFullScreen(_?: any): void;
  toggleTabBar(_?: any): void;
  toggleTabOverview(_?: any): void;
  toggleToolbarShown(_?: any): void;
  trackEventsMatchingMaskTimeoutModeHandler(matching: NSEvent.EventTypeMask, timeout: number, mode: string, handler?: (p1: NSEvent, p2: boolean) => void): void;
  unregisterDraggedTypes(): void;
  update(): void;
  updateConstraintsIfNeeded(): void;
  visualizeConstraints(_?: NSLayoutConstraint[]): void;
  zoom(_?: any): void;
}

export class NSWindowController extends NSResponder {
  contentViewController: NSViewController;
  setContentViewController(_: NSViewController);
  document: any;
  setDocument(_: any);
  owner: any;
  shouldCascadeWindows: boolean;
  setShouldCascadeWindows(_: boolean);
  shouldCloseDocument: boolean;
  setShouldCloseDocument(_: boolean);
  storyboard: NSStoryboard;
  window: NSWindow;
  setWindow(_: NSWindow);
  windowFrameAutosaveName: string;
  setWindowFrameAutosaveName(_: string);
  isWindowLoaded: boolean;
  windowNibName: string;
  windowNibPath: string;
  close(): void;
  dismissController(_?: any): void;
  static initWithWindow(_?: NSWindow): NSWindowController;
  static initWithWindowNibName(_: string): NSWindowController;
  static initWithWindowNibNameOwner(_: string, owner: any): NSWindowController;
  static initWithWindowNibPathOwner(_: string, owner: any): NSWindowController;
  loadWindow(): void;
  setDocumentEdited(_: boolean): void;
  showWindow(_?: any): void;
  synchronizeWindowTitleWithDocumentName(): void;
  windowDidLoad(): void;
  windowTitleForDocumentDisplayName(forDocumentDisplayName: string): string;
  windowWillLoad(): void;
}

interface NSWindowDelegate {
  customWindowsToEnterFullScreenForWindow(for_: NSWindow): NSWindow[];
  customWindowsToEnterFullScreenForWindowOnScreen(for_: NSWindow, on: NSScreen): NSWindow[];
  customWindowsToExitFullScreenForWindow(for_: NSWindow): NSWindow[];
  windowStartCustomAnimationToExitFullScreenWithDuration(_: NSWindow, startCustomAnimationToExitFullScreenWithDuration: number): void;
  windowDidDecodeRestorableState(_: NSWindow, didDecodeRestorableState: NSCoder): void;
  windowWillEncodeRestorableState(_: NSWindow, willEncodeRestorableState: NSCoder): void;
  windowWillPositionSheetUsingRect(_: NSWindow, willPositionSheet: NSWindow, using: CGRect): CGRect;
  windowShouldPopUpDocumentPathMenu(_: NSWindow, shouldPopUpDocumentPathMenu: NSMenu): boolean;
  windowShouldDragDocumentWithEventFromWithPasteboard(_: NSWindow, shouldDragDocumentWith: NSEvent, from: CGPoint, with_: NSPasteboard): boolean;
  windowWillUseFullScreenContentSize(_: NSWindow, willUseFullScreenContentSize: CGSize): CGSize;
  windowWillUseFullScreenPresentationOptions(_: NSWindow, willUseFullScreenPresentationOptions: NSApplication.PresentationOptions): NSApplication.PresentationOptions;
  windowStartCustomAnimationToEnterFullScreenWithDuration(_: NSWindow, startCustomAnimationToEnterFullScreenWithDuration: number): void;
  windowWillResizeForVersionBrowserWithMaxPreferredSizeMaxAllowedSize(_: NSWindow, willResizeForVersionBrowserWithMaxPreferredSize: CGSize, maxAllowedSize: CGSize): CGSize;
  windowStartCustomAnimationToEnterFullScreenOnScreenWithDuration(_: NSWindow, startCustomAnimationToEnterFullScreenOn: NSScreen, withDuration: number): void;
  windowDidBecomeKey(_: Notification): void;
  windowDidBecomeMain(_: Notification): void;
  windowDidChangeBackingProperties(_: Notification): void;
  windowDidChangeOcclusionState(_: Notification): void;
  windowDidChangeScreen(_: Notification): void;
  windowDidChangeScreenProfile(_: Notification): void;
  windowDidDeminiaturize(_: Notification): void;
  windowDidEndLiveResize(_: Notification): void;
  windowDidEndSheet(_: Notification): void;
  windowDidEnterFullScreen(_: Notification): void;
  windowDidEnterVersionBrowser(_: Notification): void;
  windowDidExitFullScreen(_: Notification): void;
  windowDidExitVersionBrowser(_: Notification): void;
  windowDidExpose(_: Notification): void;
  windowDidFailToEnterFullScreen(_: NSWindow): void;
  windowDidFailToExitFullScreen(_: NSWindow): void;
  windowDidMiniaturize(_: Notification): void;
  windowDidMove(_: Notification): void;
  windowDidResignKey(_: Notification): void;
  windowDidResignMain(_: Notification): void;
  windowDidResize(_: Notification): void;
  windowDidUpdate(_: Notification): void;
  windowShouldClose(_: NSWindow): boolean;
  windowShouldZoomToFrame(_: NSWindow, toFrame: CGRect): boolean;
  windowWillBeginSheet(_: Notification): void;
  windowWillClose(_: Notification): void;
  windowWillEnterFullScreen(_: Notification): void;
  windowWillEnterVersionBrowser(_: Notification): void;
  windowWillExitFullScreen(_: Notification): void;
  windowWillExitVersionBrowser(_: Notification): void;
  windowWillMiniaturize(_: Notification): void;
  windowWillMove(_: Notification): void;
  windowWillResizeToSize(_: NSWindow, to: CGSize): CGSize;
  windowWillReturnFieldEditorToObject(_: NSWindow, to?: any): any;
  windowWillReturnUndoManager(_: NSWindow): UndoManager;
  windowWillStartLiveResize(_: Notification): void;
  windowWillUseStandardFrameDefaultFrame(_: NSWindow, defaultFrame: CGRect): CGRect;
}

interface NSWindowRestoration {
}

export class NSWindowTab extends NSObject {
  accessoryView: NSView;
  setAccessoryView(_: NSView);
  attributedTitle: NSAttributedString;
  setAttributedTitle(_: NSAttributedString);
  title: string;
  setTitle(_: string);
  toolTip: string;
  setToolTip(_: string);
}

export class NSWindowTabGroup extends NSObject {
  identifier: string;
  isOverviewVisible: boolean;
  setOverviewVisible(_: boolean);
  selectedWindow: NSWindow;
  setSelectedWindow(_: NSWindow);
  isTabBarVisible: boolean;
  windows: NSWindow[];
  addWindow(_: NSWindow): void;
  insertWindowAtIndex(_: NSWindow, at: number): void;
  removeWindow(_: NSWindow): void;
}

export class NSWorkspace extends NSObject {
  accessibilityDisplayShouldDifferentiateWithoutColor: boolean;
  accessibilityDisplayShouldIncreaseContrast: boolean;
  accessibilityDisplayShouldInvertColors: boolean;
  accessibilityDisplayShouldReduceMotion: boolean;
  accessibilityDisplayShouldReduceTransparency: boolean;
  fileLabelColors: NSColor[];
  fileLabels: string[];
  frontmostApplication: NSRunningApplication;
  menuBarOwningApplication: NSRunningApplication;
  notificationCenter: NotificationCenter;
  runningApplications: NSRunningApplication[];
  isSwitchControlEnabled: boolean;
  isVoiceOverEnabled: boolean;
  static sharedWorkspace: NSWorkspace;
  uRLForApplicationToOpenURL(toOpen: URL): URL;
  uRLForApplicationWithBundleIdentifier(withBundleIdentifier: string): URL;
  activateFileViewerSelectingURLs(_: URL[]): void;
  desktopImageOptionsForScreen(for_: NSScreen): Map<string, any>;
  desktopImageURLForScreen(for_: NSScreen): URL;
  duplicateURLsCompletionHandler(_: URL[], completionHandler?: (p1: Map<URL, URL>, p2: Error) => void): void;
  extendPowerOffBy(by: number): number;
  filenameExtensionIsValidForType(_: string, isValidForType: string): boolean;
  getFileSystemInfoForPathIsRemovableIsWritableIsUnmountableDescriptionType(forPath: string, isRemovable?: boolean, isWritable?: boolean, isUnmountable?: boolean, description?: string, type?: string): boolean;
  getInfoForFileApplicationType(_: string, application?: string, type?: string): boolean;
  hideOtherApplications(): void;
  iconForFile(forFile: string): NSImage;
  iconForFileType(forFileType: string): NSImage;
  iconForFiles(forFiles: string[]): NSImage;
  isFilePackageAtPath(atPath: string): boolean;
  launchApplicationAtURLOptionsConfiguration(options: URL, configuration: NSWorkspace.LaunchOptions, error: Map<string, any>): NSRunningApplication;
  localizedDescriptionForType(forType: string): string;
  noteFileSystemChanged(_: string): void;
  openApplicationAtURLConfigurationCompletionHandler(at: URL, configuration: NSWorkspace.OpenConfiguration, completionHandler?: (p1: NSRunningApplication, p2: Error) => void): void;
  openURL(_: URL): boolean;
  openURLConfigurationCompletionHandler(_: URL, configuration: NSWorkspace.OpenConfiguration, completionHandler?: (p1: NSRunningApplication, p2: Error) => void): void;
  openURLOptionsConfiguration(options: URL, configuration: NSWorkspace.LaunchOptions, error: Map<string, any>): NSRunningApplication;
  openURLsWithApplicationAtURLConfigurationCompletionHandler(_: URL[], withApplicationAt: URL, configuration: NSWorkspace.OpenConfiguration, completionHandler?: (p1: NSRunningApplication, p2: Error) => void): void;
  openURLsWithApplicationAtURLOptionsConfiguration(withApplicationAtURL: URL[], options: URL, configuration: NSWorkspace.LaunchOptions, error: Map<string, any>): NSRunningApplication;
  preferredFilenameExtensionForType(forType: string): string;
  recycleURLsCompletionHandler(_: URL[], completionHandler?: (p1: Map<URL, URL>, p2: Error) => void): void;
  requestAuthorizationOfTypeCompletionHandler(to: NSWorkspace.AuthorizationType, completionHandler?: (p1: NSWorkspace.Authorization, p2: Error) => void): void;
  selectFileInFileViewerRootedAtPath(_?: string, inFileViewerRootedAtPath?: string): boolean;
  setDesktopImageURLForScreenOptions(forScreen: URL, options: NSScreen, error: Map<string, any>): boolean;
  setIconForFileOptions(_?: NSImage, forFile?: string, options?: NSWorkspace.IconCreationOptions): boolean;
  showSearchResultsForQueryString(forQueryString: string): boolean;
  typeConformsToType(_: string, conformsToType: string): boolean;
  typeOfFile(error: string): string;
  unmountAndEjectDeviceAtPath(atPath: string): boolean;
  unmountAndEjectDeviceAtURL(error: URL): boolean;
}

export class CKAcceptSharesOperation extends CKOperation {
  acceptSharesCompletionBlock: (p1: Error) => void;
  setAcceptSharesCompletionBlock(_: (p1: Error) => void);
  perShareCompletionBlock: (p1: CKShare.Metadata, p2: CKShare, p3: Error) => void;
  setPerShareCompletionBlock(_: (p1: CKShare.Metadata, p2: CKShare, p3: Error) => void);
  shareMetadatas: CKShare.Metadata[];
  setShareMetadatas(_: CKShare.Metadata[]);
  static initWithShareMetadatas(_: CKShare.Metadata[]): CKAcceptSharesOperation;
}

export class CKAsset extends NSObject {
  fileURL: URL;
  static initWithFileURL(_: URL): CKAsset;
}

export class CKContainer extends NSObject {
  static defaultContainer(): CKContainer;
  containerIdentifier: string;
  privateCloudDatabase: CKDatabase;
  publicCloudDatabase: CKDatabase;
  sharedCloudDatabase: CKDatabase;
  acceptShareMetadataCompletionHandler(_: CKShare.Metadata, completionHandler?: (p1: CKShare, p2: Error) => void): void;
  accountStatusWithCompletionHandler(completionHandler?: (p1: CKContainer.CKAccountStatus, p2: Error) => void): void;
  addOperation(_: CKOperation): void;
  databaseWithDatabaseScope(with_: CKDatabase.Scope): CKDatabase;
  discoverAllIdentitiesWithCompletionHandler(completionHandler?: (p1: CKUserIdentity[], p2: Error) => void): void;
  discoverUserIdentityWithEmailAddressCompletionHandler(withEmailAddress: string, completionHandler?: (p1: CKUserIdentity, p2: Error) => void): void;
  discoverUserIdentityWithPhoneNumberCompletionHandler(withPhoneNumber: string, completionHandler?: (p1: CKUserIdentity, p2: Error) => void): void;
  discoverUserIdentityWithUserRecordIDCompletionHandler(withUserRecordID: CKRecord.ID, completionHandler?: (p1: CKUserIdentity, p2: Error) => void): void;
  fetchAllLongLivedOperationIDsWithCompletionHandler(_?: (p1: string[], p2: Error) => void): void;
  fetchLongLivedOperationWithIDCompletionHandler(_: string, completionHandler?: (p1: CKOperation, p2: Error) => void): void;
  fetchShareMetadataWithURLCompletionHandler(with_: URL, completionHandler?: (p1: CKShare.Metadata, p2: Error) => void): void;
  fetchShareParticipantWithEmailAddressCompletionHandler(withEmailAddress: string, completionHandler?: (p1: CKShare.Participant, p2: Error) => void): void;
  fetchShareParticipantWithPhoneNumberCompletionHandler(withPhoneNumber: string, completionHandler?: (p1: CKShare.Participant, p2: Error) => void): void;
  fetchShareParticipantWithUserRecordIDCompletionHandler(withUserRecordID: CKRecord.ID, completionHandler?: (p1: CKShare.Participant, p2: Error) => void): void;
  fetchUserRecordIDWithCompletionHandler(completionHandler?: (p1: CKRecord.ID, p2: Error) => void): void;
  requestApplicationPermissionCompletionHandler(_: CKContainer.CKContainer_Application_Permissions, completionHandler: (p1: CKContainer.CKContainer_Application_PermissionStatus, p2: Error) => void): void;
  statusForApplicationPermissionCompletionHandler(forApplicationPermission: CKContainer.CKContainer_Application_Permissions, completionHandler: (p1: CKContainer.CKContainer_Application_PermissionStatus, p2: Error) => void): void;
}

export class CKDatabase extends NSObject {
  databaseScope: CKDatabase.Scope;
  addOperation(_: CKDatabaseOperation): void;
  deleteRecordWithIDCompletionHandler(withRecordID: CKRecord.ID, completionHandler?: (p1: CKRecord.ID, p2: Error) => void): void;
  deleteRecordZoneWithIDCompletionHandler(withRecordZoneID: CKRecordZone.ID, completionHandler?: (p1: CKRecordZone.ID, p2: Error) => void): void;
  deleteSubscriptionWithIDCompletionHandler(withSubscriptionID: string, completionHandler?: (p1: string, p2: Error) => void): void;
  fetchAllRecordZonesWithCompletionHandler(completionHandler?: (p1: CKRecordZone[], p2: Error) => void): void;
  fetchAllSubscriptionsWithCompletionHandler(completionHandler?: (p1: CKSubscription[], p2: Error) => void): void;
  fetchRecordWithIDCompletionHandler(withRecordID: CKRecord.ID, completionHandler?: (p1: CKRecord, p2: Error) => void): void;
  fetchRecordZoneWithIDCompletionHandler(withRecordZoneID: CKRecordZone.ID, completionHandler?: (p1: CKRecordZone, p2: Error) => void): void;
  fetchSubscriptionWithIDCompletionHandler(withSubscriptionID: string, completionHandler?: (p1: CKSubscription, p2: Error) => void): void;
  performQueryInZoneWithIDCompletionHandler(_: CKQuery, inZoneWith?: CKRecordZone.ID, completionHandler?: (p1: CKRecord[], p2: Error) => void): void;
  saveRecordCompletionHandler(_: CKRecord, completionHandler?: (p1: CKRecord, p2: Error) => void): void;
  saveRecordZoneCompletionHandler(_: CKRecordZone, completionHandler?: (p1: CKRecordZone, p2: Error) => void): void;
  saveSubscriptionCompletionHandler(_: CKSubscription, completionHandler?: (p1: CKSubscription, p2: Error) => void): void;
}

export class CKDatabaseNotification extends CKNotification {
  databaseScope: CKDatabase.Scope;
}

export class CKDatabaseOperation extends CKOperation {
  database: CKDatabase;
  setDatabase(_: CKDatabase);
}

export class CKDatabaseSubscription extends CKSubscription {
  recordType: string;
  setRecordType(_: string);
  static initWithSubscriptionID(_: string): CKDatabaseSubscription;
}

export class CKDiscoverAllUserIdentitiesOperation extends CKOperation {
  discoverAllUserIdentitiesCompletionBlock: (p1: Error) => void;
  setDiscoverAllUserIdentitiesCompletionBlock(_: (p1: Error) => void);
  userIdentityDiscoveredBlock: (p1: CKUserIdentity) => void;
  setUserIdentityDiscoveredBlock(_: (p1: CKUserIdentity) => void);
}

export class CKDiscoverUserIdentitiesOperation extends CKOperation {
  discoverUserIdentitiesCompletionBlock: (p1: Error) => void;
  setDiscoverUserIdentitiesCompletionBlock(_: (p1: Error) => void);
  userIdentityDiscoveredBlock: (p1: CKUserIdentity, p2: CKUserIdentity.LookupInfo) => void;
  setUserIdentityDiscoveredBlock(_: (p1: CKUserIdentity, p2: CKUserIdentity.LookupInfo) => void);
  userIdentityLookupInfos: CKUserIdentity.LookupInfo[];
  setUserIdentityLookupInfos(_: CKUserIdentity.LookupInfo[]);
  static initWithUserIdentityLookupInfos(_: CKUserIdentity.LookupInfo[]): CKDiscoverUserIdentitiesOperation;
}

export class CKFetchDatabaseChangesOperation extends CKDatabaseOperation {
  changeTokenUpdatedBlock: (p1: CKServerChangeToken) => void;
  setChangeTokenUpdatedBlock(_: (p1: CKServerChangeToken) => void);
  fetchAllChanges: boolean;
  setFetchAllChanges(_: boolean);
  fetchDatabaseChangesCompletionBlock: (p1: CKServerChangeToken, p2: boolean, p3: Error) => void;
  setFetchDatabaseChangesCompletionBlock(_: (p1: CKServerChangeToken, p2: boolean, p3: Error) => void);
  previousServerChangeToken: CKServerChangeToken;
  setPreviousServerChangeToken(_: CKServerChangeToken);
  recordZoneWithIDChangedBlock: (p1: CKRecordZone.ID) => void;
  setRecordZoneWithIDChangedBlock(_: (p1: CKRecordZone.ID) => void);
  recordZoneWithIDWasDeletedBlock: (p1: CKRecordZone.ID) => void;
  setRecordZoneWithIDWasDeletedBlock(_: (p1: CKRecordZone.ID) => void);
  recordZoneWithIDWasPurgedBlock: (p1: CKRecordZone.ID) => void;
  setRecordZoneWithIDWasPurgedBlock(_: (p1: CKRecordZone.ID) => void);
  resultsLimit: number;
  setResultsLimit(_: number);
  static initWithPreviousServerChangeToken(_?: CKServerChangeToken): CKFetchDatabaseChangesOperation;
}

export class CKFetchRecordZoneChangesOperation extends CKDatabaseOperation {
  configurationsByRecordZoneID: Map<CKRecordZone.ID, CKFetchRecordZoneChangesOperation.ZoneConfiguration>;
  setConfigurationsByRecordZoneID(_: Map<CKRecordZone.ID, CKFetchRecordZoneChangesOperation.ZoneConfiguration>);
  fetchAllChanges: boolean;
  setFetchAllChanges(_: boolean);
  fetchRecordZoneChangesCompletionBlock: (p1: Error) => void;
  setFetchRecordZoneChangesCompletionBlock(_: (p1: Error) => void);
  recordChangedBlock: (p1: CKRecord) => void;
  setRecordChangedBlock(_: (p1: CKRecord) => void);
  recordWithIDWasDeletedBlock: (p1: CKRecord.ID, p2: string) => void;
  setRecordWithIDWasDeletedBlock(_: (p1: CKRecord.ID, p2: string) => void);
  recordZoneChangeTokensUpdatedBlock: (p1: CKRecordZone.ID, p2: CKServerChangeToken, p3: Data) => void;
  setRecordZoneChangeTokensUpdatedBlock(_: (p1: CKRecordZone.ID, p2: CKServerChangeToken, p3: Data) => void);
  recordZoneFetchCompletionBlock: (p1: CKRecordZone.ID, p2: CKServerChangeToken, p3: Data, p4: boolean, p5: Error) => void;
  setRecordZoneFetchCompletionBlock(_: (p1: CKRecordZone.ID, p2: CKServerChangeToken, p3: Data, p4: boolean, p5: Error) => void);
  recordZoneIDs: CKRecordZone.ID[];
  setRecordZoneIDs(_: CKRecordZone.ID[]);
  static initWithRecordZoneIDsConfigurationsByRecordZoneID(_: CKRecordZone.ID[], configurationsByRecordZoneID?: Map<CKRecordZone.ID, CKFetchRecordZoneChangesOperation.ZoneConfiguration>): CKFetchRecordZoneChangesOperation;
}

export class CKFetchRecordZonesOperation extends CKDatabaseOperation {
  static fetchAllRecordZonesOperation(): CKFetchRecordZonesOperation;
  fetchRecordZonesCompletionBlock: (p1: Map<CKRecordZone.ID, CKRecordZone>, p2: Error) => void;
  setFetchRecordZonesCompletionBlock(_: (p1: Map<CKRecordZone.ID, CKRecordZone>, p2: Error) => void);
  recordZoneIDs: CKRecordZone.ID[];
  setRecordZoneIDs(_: CKRecordZone.ID[]);
  static initWithRecordZoneIDs(_: CKRecordZone.ID[]): CKFetchRecordZonesOperation;
}

export class CKFetchRecordsOperation extends CKDatabaseOperation {
  static fetchCurrentUserRecordOperation(): CKFetchRecordsOperation;
  desiredKeys: string[];
  setDesiredKeys(_: string[]);
  fetchRecordsCompletionBlock: (p1: Map<CKRecord.ID, CKRecord>, p2: Error) => void;
  setFetchRecordsCompletionBlock(_: (p1: Map<CKRecord.ID, CKRecord>, p2: Error) => void);
  perRecordCompletionBlock: (p1: CKRecord, p2: CKRecord.ID, p3: Error) => void;
  setPerRecordCompletionBlock(_: (p1: CKRecord, p2: CKRecord.ID, p3: Error) => void);
  perRecordProgressBlock: (p1: CKRecord.ID, p2: number) => void;
  setPerRecordProgressBlock(_: (p1: CKRecord.ID, p2: number) => void);
  recordIDs: CKRecord.ID[];
  setRecordIDs(_: CKRecord.ID[]);
  static initWithRecordIDs(_: CKRecord.ID[]): CKFetchRecordsOperation;
}

export class CKFetchShareMetadataOperation extends CKOperation {
  fetchShareMetadataCompletionBlock: (p1: Error) => void;
  setFetchShareMetadataCompletionBlock(_: (p1: Error) => void);
  perShareMetadataBlock: (p1: URL, p2: CKShare.Metadata, p3: Error) => void;
  setPerShareMetadataBlock(_: (p1: URL, p2: CKShare.Metadata, p3: Error) => void);
  rootRecordDesiredKeys: string[];
  setRootRecordDesiredKeys(_: string[]);
  shareURLs: URL[];
  setShareURLs(_: URL[]);
  shouldFetchRootRecord: boolean;
  setShouldFetchRootRecord(_: boolean);
}

export class CKFetchShareParticipantsOperation extends CKOperation {
  fetchShareParticipantsCompletionBlock: (p1: Error) => void;
  setFetchShareParticipantsCompletionBlock(_: (p1: Error) => void);
  shareParticipantFetchedBlock: (p1: CKShare.Participant) => void;
  setShareParticipantFetchedBlock(_: (p1: CKShare.Participant) => void);
  userIdentityLookupInfos: CKUserIdentity.LookupInfo[];
  setUserIdentityLookupInfos(_: CKUserIdentity.LookupInfo[]);
  static initWithUserIdentityLookupInfos(_: CKUserIdentity.LookupInfo[]): CKFetchShareParticipantsOperation;
}

export class CKFetchSubscriptionsOperation extends CKDatabaseOperation {
  static fetchAllSubscriptionsOperation(): CKFetchSubscriptionsOperation;
  fetchSubscriptionCompletionBlock: (p1: Map<string, CKSubscription>, p2: Error) => void;
  setFetchSubscriptionCompletionBlock(_: (p1: Map<string, CKSubscription>, p2: Error) => void);
  subscriptionIDs: string[];
  setSubscriptionIDs(_: string[]);
  static initWithSubscriptionIDs(_: string[]): CKFetchSubscriptionsOperation;
}

export class CKFetchWebAuthTokenOperation extends CKDatabaseOperation {
  APIToken: string;
  setAPIToken(_: string);
  fetchWebAuthTokenCompletionBlock: (p1: string, p2: Error) => void;
  setFetchWebAuthTokenCompletionBlock(_: (p1: string, p2: Error) => void);
  static initWithAPIToken(_: string): CKFetchWebAuthTokenOperation;
}

export class CKLocationSortDescriptor extends NSSortDescriptor {
  relativeLocation: CLLocation;
  static initWithKeyRelativeLocation(_: string, relativeLocation: CLLocation): CKLocationSortDescriptor;
}

export class CKModifyRecordZonesOperation extends CKDatabaseOperation {
  modifyRecordZonesCompletionBlock: (p1: CKRecordZone[], p2: CKRecordZone.ID[], p3: Error) => void;
  setModifyRecordZonesCompletionBlock(_: (p1: CKRecordZone[], p2: CKRecordZone.ID[], p3: Error) => void);
  recordZoneIDsToDelete: CKRecordZone.ID[];
  setRecordZoneIDsToDelete(_: CKRecordZone.ID[]);
  recordZonesToSave: CKRecordZone[];
  setRecordZonesToSave(_: CKRecordZone[]);
  static initWithRecordZonesToSaveRecordZoneIDsToDelete(_?: CKRecordZone[], recordZoneIDsToDelete?: CKRecordZone.ID[]): CKModifyRecordZonesOperation;
}

export class CKModifyRecordsOperation extends CKDatabaseOperation {
  atomic: boolean;
  setAtomic(_: boolean);
  clientChangeTokenData: Data;
  setClientChangeTokenData(_: Data);
  modifyRecordsCompletionBlock: (p1: CKRecord[], p2: CKRecord.ID[], p3: Error) => void;
  setModifyRecordsCompletionBlock(_: (p1: CKRecord[], p2: CKRecord.ID[], p3: Error) => void);
  perRecordCompletionBlock: (p1: CKRecord, p2: Error) => void;
  setPerRecordCompletionBlock(_: (p1: CKRecord, p2: Error) => void);
  perRecordProgressBlock: (p1: CKRecord, p2: number) => void;
  setPerRecordProgressBlock(_: (p1: CKRecord, p2: number) => void);
  recordIDsToDelete: CKRecord.ID[];
  setRecordIDsToDelete(_: CKRecord.ID[]);
  recordsToSave: CKRecord[];
  setRecordsToSave(_: CKRecord[]);
  savePolicy: CKModifyRecordsOperation.RecordSavePolicy;
  setSavePolicy(_: CKModifyRecordsOperation.RecordSavePolicy);
  static initWithRecordsToSaveRecordIDsToDelete(_?: CKRecord[], recordIDsToDelete?: CKRecord.ID[]): CKModifyRecordsOperation;
}

export class CKModifySubscriptionsOperation extends CKDatabaseOperation {
  modifySubscriptionsCompletionBlock: (p1: CKSubscription[], p2: string[], p3: Error) => void;
  setModifySubscriptionsCompletionBlock(_: (p1: CKSubscription[], p2: string[], p3: Error) => void);
  subscriptionIDsToDelete: string[];
  setSubscriptionIDsToDelete(_: string[]);
  subscriptionsToSave: CKSubscription[];
  setSubscriptionsToSave(_: CKSubscription[]);
  static initWithSubscriptionsToSaveSubscriptionIDsToDelete(_?: CKSubscription[], subscriptionIDsToDelete?: string[]): CKModifySubscriptionsOperation;
}

export class CKNotification extends NSObject {
  alertActionLocalizationKey: string;
  alertBody: string;
  alertLaunchImage: string;
  alertLocalizationArgs: string[];
  alertLocalizationKey: string;
  badge: number;
  category: string;
  containerIdentifier: string;
  isPruned: boolean;
  notificationID: CKNotification.ID;
  notificationType: CKNotification.NotificationType;
  soundName: string;
  subscriptionID: string;
  subtitle: string;
  subtitleLocalizationArgs: string[];
  subtitleLocalizationKey: string;
  title: string;
  titleLocalizationArgs: string[];
  titleLocalizationKey: string;
}

export class CKOperation extends Operation {
  configuration: CKOperation.Configuration;
  setConfiguration(_: CKOperation.Configuration);
  group: CKOperationGroup;
  setGroup(_: CKOperationGroup);
  longLivedOperationWasPersistedBlock: () => void;
  setLongLivedOperationWasPersistedBlock(_: () => void);
  operationID: string;
}

export class CKOperationGroup extends NSObject {
  defaultConfiguration: CKOperation.Configuration;
  setDefaultConfiguration(_: CKOperation.Configuration);
  expectedReceiveSize: CKOperationGroup.TransferSize;
  setExpectedReceiveSize(_: CKOperationGroup.TransferSize);
  expectedSendSize: CKOperationGroup.TransferSize;
  setExpectedSendSize(_: CKOperationGroup.TransferSize);
  name: string;
  setName(_: string);
  operationGroupID: string;
  quantity: number;
  setQuantity(_: number);
}

export class CKQuery extends NSObject {
  predicate: NSPredicate;
  recordType: string;
  sortDescriptors: NSSortDescriptor[];
  setSortDescriptors(_: NSSortDescriptor[]);
  static initWithRecordTypePredicate(_: string, predicate: NSPredicate): CKQuery;
}

export class CKQueryNotification extends CKNotification {
  databaseScope: CKDatabase.Scope;
  queryNotificationReason: CKNotification.CKQueryNotification.Reason;
  recordFields: Map<string, any>;
  recordID: CKRecord.ID;
}

export class CKQueryOperation extends CKDatabaseOperation {
  cursor: CKQueryOperation.Cursor;
  setCursor(_: CKQueryOperation.Cursor);
  desiredKeys: string[];
  setDesiredKeys(_: string[]);
  query: CKQuery;
  setQuery(_: CKQuery);
  queryCompletionBlock: (p1: CKQueryOperation.Cursor, p2: Error) => void;
  setQueryCompletionBlock(_: (p1: CKQueryOperation.Cursor, p2: Error) => void);
  recordFetchedBlock: (p1: CKRecord) => void;
  setRecordFetchedBlock(_: (p1: CKRecord) => void);
  resultsLimit: number;
  setResultsLimit(_: number);
  zoneID: CKRecordZone.ID;
  setZoneID(_: CKRecordZone.ID);
  static initWithCursor(_: CKQueryOperation.Cursor): CKQueryOperation;
  static initWithQuery(_: CKQuery): CKQueryOperation;
}

export class CKQuerySubscription extends CKSubscription {
  predicate: NSPredicate;
  querySubscriptionOptions: CKSubscription.CKQuerySubscription.Options;
  recordType: string;
  zoneID: CKRecordZone.ID;
  setZoneID(_: CKRecordZone.ID);
  static initWithRecordTypePredicateOptions(_: string, predicate: NSPredicate, options: CKSubscription.CKQuerySubscription.Options): CKQuerySubscription;
  static initWithRecordTypePredicateSubscriptionIDOptions(_: string, predicate: NSPredicate, subscriptionID: string, options: CKSubscription.CKQuerySubscription.Options): CKQuerySubscription;
}

export class CKRecord extends NSObject {
  creationDate: Date;
  creatorUserRecordID: CKRecord.ID;
  lastModifiedUserRecordID: CKRecord.ID;
  modificationDate: Date;
  parent: CKRecord.Reference;
  setParent(_: CKRecord.Reference);
  recordChangeTag: string;
  recordID: CKRecord.ID;
  recordType: string;
  share: CKRecord.Reference;
  allTokens(): string[];
  encodeSystemFieldsWithCoder(with_: NSCoder): void;
  static initWithRecordType(_: string): CKRecord;
  static initWithRecordTypeRecordID(_: string, recordID: CKRecord.ID): CKRecord;
  static initWithRecordTypeZoneID(_: string, zoneID: CKRecordZone.ID): CKRecord;
  setParentReferenceFromRecord(_?: CKRecord): void;
  setParentReferenceFromRecordID(_?: CKRecord.ID): void;
}

interface CKRecordKeyValueSetting {
  allKeys(): string[];
  changedKeys(): string[];
  objectForKey(forKey: string): any;
  objectForKeyedSubscript(_: string): any;
  setObjectForKey(_?: any, forKey?: string): void;
  setObjectForKeyedSubscript(_?: any, forKeyedSubscript?: string): void;
}

export class CKRecordZone extends NSObject {
  static defaultRecordZone(): CKRecordZone;
  capabilities: CKRecordZone.Capabilities;
  zoneID: CKRecordZone.ID;
  static initWithZoneID(_: CKRecordZone.ID): CKRecordZone;
  static initWithZoneName(_: string): CKRecordZone;
}

export class CKRecordZoneNotification extends CKNotification {
  databaseScope: CKDatabase.Scope;
  recordZoneID: CKRecordZone.ID;
}

export class CKRecordZoneSubscription extends CKSubscription {
  recordType: string;
  setRecordType(_: string);
  zoneID: CKRecordZone.ID;
  static initWithZoneID(_: CKRecordZone.ID): CKRecordZoneSubscription;
  static initWithZoneIDSubscriptionID(_: CKRecordZone.ID, subscriptionID: string): CKRecordZoneSubscription;
}

export class CKServerChangeToken extends NSObject {
}

export class CKShare extends CKRecord {
  URL: URL;
  currentUserParticipant: CKShare.Participant;
  owner: CKShare.Participant;
  participants: CKShare.Participant[];
  publicPermission: CKShare.Participant.CKShare_Participant_Permission;
  setPublicPermission(_: CKShare.Participant.CKShare_Participant_Permission);
  addParticipant(_: CKShare.Participant): void;
  static initWithRootRecord(_: CKRecord): CKShare;
  removeParticipant(_: CKShare.Participant): void;
}

export class CKSubscription extends NSObject {
  notificationInfo: CKSubscription.NotificationInfo;
  setNotificationInfo(_: CKSubscription.NotificationInfo);
  subscriptionID: string;
  subscriptionType: CKSubscription.SubscriptionType;
}

export class CKUserIdentity extends NSObject {
  contactIdentifiers: string[];
  hasiCloudAccount: boolean;
  lookupInfo: CKUserIdentity.LookupInfo;
  nameComponents: PersonNameComponents;
  userRecordID: CKRecord.ID;
}

interface __CKRecordObjCValue {
}

export class NSAsynchronousFetchRequest<ResultType> extends NSPersistentStoreRequest {
  completionBlock: (p1: NSAsynchronousFetchResult<any>) => void;
  estimatedResultCount: number;
  setEstimatedResultCount(_: number);
  fetchRequest: NSFetchRequest<any>;
}

export class NSAsynchronousFetchResult<ResultType> extends NSPersistentStoreAsynchronousResult {
  fetchRequest: NSAsynchronousFetchRequest<any>;
  finalResult: ResultType[];
}

export class NSAtomicStore extends NSPersistentStore {
  addCacheNodes(_: Set<any>): void;
  cacheNodeForObjectID(for_: NSManagedObjectID): NSAtomicStoreCacheNode;
  cacheNodes(): Set<any>;
  // dupe name w inherited static method  load(): boolean;
  newCacheNodeForManagedObject(for_: NSManagedObject): NSAtomicStoreCacheNode;
  newReferenceObjectForManagedObject(for_: NSManagedObject): any;
  objectIDForEntityReferenceObject(for_: NSEntityDescription, withReferenceObject: any): NSManagedObjectID;
  referenceObjectForObjectID(for_: NSManagedObjectID): any;
  save(): boolean;
  updateCacheNodeFromManagedObject(_: NSAtomicStoreCacheNode, from: NSManagedObject): void;
  willRemoveCacheNodes(_: Set<any>): void;
}

export class NSAtomicStoreCacheNode extends NSObject {
  objectID: NSManagedObjectID;
  propertyCache: Map<string, any>;
  setPropertyCache(_: Map<string, any>);
  static initWithObjectID(_: NSManagedObjectID): NSAtomicStoreCacheNode;
}

export class NSAttributeDescription extends NSPropertyDescription {
  allowsExternalBinaryDataStorage: boolean;
  setAllowsExternalBinaryDataStorage(_: boolean);
  attributeType: NSAttributeDescription.NSAttributeType;
  setAttributeType(_: NSAttributeDescription.NSAttributeType);
  attributeValueClassName: string;
  setAttributeValueClassName(_: string);
  defaultValue: any;
  setDefaultValue(_: any);
  preservesValueInHistoryOnDeletion: boolean;
  setPreservesValueInHistoryOnDeletion(_: boolean);
  valueTransformerName: string;
  setValueTransformerName(_: string);
}

export class NSBatchDeleteRequest extends NSPersistentStoreRequest {
  fetchRequest: NSFetchRequest<any>;
  resultType: NSPersistentStoreResult.NSBatchDeleteRequestResultType;
  setResultType(_: NSPersistentStoreResult.NSBatchDeleteRequestResultType);
  static initWithFetchRequest(_: NSFetchRequest<any>): NSBatchDeleteRequest;
  static initWithObjectIDs(_: NSManagedObjectID[]): NSBatchDeleteRequest;
}

export class NSBatchDeleteResult extends NSPersistentStoreResult {
  result: any;
  resultType: NSPersistentStoreResult.NSBatchDeleteRequestResultType;
}

export class NSBatchInsertRequest extends NSPersistentStoreRequest {
  entity: NSEntityDescription;
  entityName: string;
  objectsToInsert: Map<string, any>[];
  setObjectsToInsert(_: Map<string, any>[]);
  resultType: NSPersistentStoreResult.NSBatchInsertRequestResultType;
  setResultType(_: NSPersistentStoreResult.NSBatchInsertRequestResultType);
  static initWithEntityObjects(_: NSEntityDescription, objects: Map<string, any>[]): NSBatchInsertRequest;
  static initWithEntityNameObjects(_: string, objects: Map<string, any>[]): NSBatchInsertRequest;
}

export class NSBatchInsertResult extends NSPersistentStoreResult {
  result: any;
  resultType: NSPersistentStoreResult.NSBatchInsertRequestResultType;
}

export class NSBatchUpdateRequest extends NSPersistentStoreRequest {
  entity: NSEntityDescription;
  entityName: string;
  includesSubentities: boolean;
  setIncludesSubentities(_: boolean);
  predicate: NSPredicate;
  setPredicate(_: NSPredicate);
  propertiesToUpdate: Map<any, any>;
  setPropertiesToUpdate(_: Map<any, any>);
  resultType: NSPersistentStoreResult.NSBatchUpdateRequestResultType;
  setResultType(_: NSPersistentStoreResult.NSBatchUpdateRequestResultType);
  static initWithEntity(_: NSEntityDescription): NSBatchUpdateRequest;
  static initWithEntityName(_: string): NSBatchUpdateRequest;
}

export class NSBatchUpdateResult extends NSPersistentStoreResult {
  result: any;
  resultType: NSPersistentStoreResult.NSBatchUpdateRequestResultType;
}

export class NSConstraintConflict extends NSObject {
  conflictingObjects: NSManagedObject[];
  conflictingSnapshots: Map<any, any>[];
  constraint: string[];
  constraintValues: Map<string, any>;
  databaseObject: NSManagedObject;
  databaseSnapshot: Map<string, any>;
}

export class NSCoreDataCoreSpotlightDelegate extends NSObject {
  attributeSetForObject(_: NSManagedObject): CSSearchableItemAttributeSet;
  domainIdentifier(): string;
  indexName(): string;
  static initForStoreWithDescriptionModel(_: NSPersistentStoreDescription, model: NSManagedObjectModel): NSCoreDataCoreSpotlightDelegate;
  searchableIndexReindexAllSearchableItemsWithAcknowledgementHandler(_: CSSearchableIndex, reindexAllSearchableItemsWithAcknowledgementHandler: () => void): void;
  searchableIndexReindexSearchableItemsWithIdentifiersAcknowledgementHandler(_: CSSearchableIndex, reindexSearchableItemsWithIdentifiers: string[], acknowledgementHandler: () => void): void;
}

export class NSDerivedAttributeDescription extends NSAttributeDescription {
  derivationExpression: NSExpression;
  setDerivationExpression(_: NSExpression);
}

export class NSEntityDescription extends NSObject {
  static entityForNameInManagedObjectContext(forEntityName: string, in_: NSManagedObjectContext): NSEntityDescription;
  static insertNewObjectForEntityForNameInManagedObjectContext(forEntityName: string, into: NSManagedObjectContext): NSManagedObject;
  isAbstract: boolean;
  setAbstract(_: boolean);
  attributesByName: Map<string, NSAttributeDescription>;
  coreSpotlightDisplayNameExpression: NSExpression;
  setCoreSpotlightDisplayNameExpression(_: NSExpression);
  indexes: NSFetchIndexDescription[];
  setIndexes(_: NSFetchIndexDescription[]);
  managedObjectClassName: string;
  setManagedObjectClassName(_: string);
  managedObjectModel: NSManagedObjectModel;
  name: string;
  setName(_: string);
  properties: NSPropertyDescription[];
  setProperties(_: NSPropertyDescription[]);
  propertiesByName: Map<string, NSPropertyDescription>;
  relationshipsByName: Map<string, NSRelationshipDescription>;
  renamingIdentifier: string;
  setRenamingIdentifier(_: string);
  subentities: NSEntityDescription[];
  setSubentities(_: NSEntityDescription[]);
  subentitiesByName: Map<string, NSEntityDescription>;
  superentity: NSEntityDescription;
  uniquenessConstraints: any[][];
  setUniquenessConstraints(_: any[][]);
  userInfo: Map<any, any>;
  setUserInfo(_: Map<any, any>);
  versionHash: Data;
  versionHashModifier: string;
  setVersionHashModifier(_: string);
  isKindOfEntity(entity: NSEntityDescription): boolean;
  relationshipsWithDestinationEntity(forDestination: NSEntityDescription): NSRelationshipDescription[];
}

export class NSEntityMapping extends NSObject {
  attributeMappings: NSPropertyMapping[];
  setAttributeMappings(_: NSPropertyMapping[]);
  destinationEntityName: string;
  setDestinationEntityName(_: string);
  destinationEntityVersionHash: Data;
  setDestinationEntityVersionHash(_: Data);
  entityMigrationPolicyClassName: string;
  setEntityMigrationPolicyClassName(_: string);
  mappingType: NSEntityMapping.NSEntityMappingType;
  setMappingType(_: NSEntityMapping.NSEntityMappingType);
  name: string;
  setName(_: string);
  relationshipMappings: NSPropertyMapping[];
  setRelationshipMappings(_: NSPropertyMapping[]);
  sourceEntityName: string;
  setSourceEntityName(_: string);
  sourceEntityVersionHash: Data;
  setSourceEntityVersionHash(_: Data);
  sourceExpression: NSExpression;
  setSourceExpression(_: NSExpression);
  userInfo: Map<any, any>;
  setUserInfo(_: Map<any, any>);
}

export class NSEntityMigrationPolicy extends NSObject {
  beginEntityMappingManager(_: NSEntityMapping, with_: NSMigrationManager): boolean;
  createDestinationInstancesForSourceInstanceEntityMappingManager(forSource: NSManagedObject, in_: NSEntityMapping, manager: NSMigrationManager): boolean;
  createRelationshipsForDestinationInstanceEntityMappingManager(forDestination: NSManagedObject, in_: NSEntityMapping, manager: NSMigrationManager): boolean;
  endEntityMappingManager(manager: NSEntityMapping, error: NSMigrationManager): boolean;
  endInstanceCreationForEntityMappingManager(forMapping: NSEntityMapping, manager: NSMigrationManager): boolean;
  endRelationshipCreationForEntityMappingManager(forMapping: NSEntityMapping, manager: NSMigrationManager): boolean;
  performCustomValidationForEntityMappingManager(forMapping: NSEntityMapping, manager: NSMigrationManager): boolean;
}

export class NSExpressionDescription extends NSPropertyDescription {
  expression: NSExpression;
  setExpression(_: NSExpression);
  expressionResultType: NSAttributeDescription.NSAttributeType;
  setExpressionResultType(_: NSAttributeDescription.NSAttributeType);
}

export class NSFetchIndexDescription extends NSObject {
  elements: NSFetchIndexElementDescription[];
  setElements(_: NSFetchIndexElementDescription[]);
  entity: NSEntityDescription;
  name: string;
  setName(_: string);
  partialIndexPredicate: NSPredicate;
  setPartialIndexPredicate(_: NSPredicate);
  static initWithNameElements(_: string, elements?: NSFetchIndexElementDescription[]): NSFetchIndexDescription;
}

export class NSFetchIndexElementDescription extends NSObject {
  isAscending: boolean;
  setAscending(_: boolean);
  collationType: NSFetchIndexElementDescription.NSFetchIndexElementType;
  setCollationType(_: NSFetchIndexElementDescription.NSFetchIndexElementType);
  indexDescription: NSFetchIndexDescription;
  property: NSPropertyDescription;
  propertyName: string;
  static initWithPropertyCollationType(_: NSPropertyDescription, collationType: NSFetchIndexElementDescription.NSFetchIndexElementType): NSFetchIndexElementDescription;
}

export class NSFetchRequest<ResultType> extends NSPersistentStoreRequest {
  entity: NSEntityDescription;
  setEntity(_: NSEntityDescription);
  entityName: string;
  fetchBatchSize: number;
  setFetchBatchSize(_: number);
  fetchLimit: number;
  setFetchLimit(_: number);
  fetchOffset: number;
  setFetchOffset(_: number);
  havingPredicate: NSPredicate;
  setHavingPredicate(_: NSPredicate);
  includesPendingChanges: boolean;
  setIncludesPendingChanges(_: boolean);
  includesPropertyValues: boolean;
  setIncludesPropertyValues(_: boolean);
  includesSubentities: boolean;
  setIncludesSubentities(_: boolean);
  predicate: NSPredicate;
  setPredicate(_: NSPredicate);
  propertiesToFetch: any[];
  setPropertiesToFetch(_: any[]);
  propertiesToGroupBy: any[];
  setPropertiesToGroupBy(_: any[]);
  relationshipKeyPathsForPrefetching: string[];
  setRelationshipKeyPathsForPrefetching(_: string[]);
  resultType: NSFetchRequest.NSFetchRequestResultType;
  setResultType(_: NSFetchRequest.NSFetchRequestResultType);
  returnsDistinctResults: boolean;
  setReturnsDistinctResults(_: boolean);
  returnsObjectsAsFaults: boolean;
  setReturnsObjectsAsFaults(_: boolean);
  shouldRefreshRefetchedObjects: boolean;
  setShouldRefreshRefetchedObjects(_: boolean);
  sortDescriptors: NSSortDescriptor[];
  setSortDescriptors(_: NSSortDescriptor[]);
  execute(): ResultType[];
}

export class NSFetchRequestExpression extends NSExpression {
  static expressionForFetchContextCountOnly(forFetch: NSExpression, context: NSExpression, countOnly: boolean): NSExpression;
  contextExpression: NSExpression;
  isCountOnlyRequest: boolean;
  requestExpression: NSExpression;
}

interface NSFetchRequestResult {
}

export class NSFetchedPropertyDescription extends NSPropertyDescription {
  fetchRequest: NSFetchRequest<any>;
  setFetchRequest(_: NSFetchRequest<any>);
}

export class NSFetchedResultsController<ResultType> extends NSObject {
  static deleteCacheWithName(withName?: string): void;
  cacheName: string;
  delegate: any;
  setDelegate(_: any);
  fetchRequest: NSFetchRequest<any>;
  fetchedObjects: ResultType[];
  managedObjectContext: NSManagedObjectContext;
  sectionIndexTitles: string[];
  sectionNameKeyPath: string;
  sections: any[];
  indexPathForObject(forObject: ResultType): IndexPath;
  objectAtIndexPath(at: IndexPath): ResultType;
  performFetch(): boolean;
  sectionForSectionIndexTitleAtIndex(forSectionIndexTitle: string, at: number): number;
  sectionIndexTitleForSectionName(forSectionName: string): string;
}

interface NSFetchedResultsControllerDelegate {
  controllerDidChangeContentWithSnapshot(_: NSFetchedResultsController<any>, didChangeContentWith: NSDiffableDataSourceSnapshotReference<string, NSManagedObjectID>): void;
  controllerDidChangeContentWithDifference(_: NSFetchedResultsController<any>, didChangeContentWith: CollectionDifference<any>): void;
  controllerDidChangeObjectAtIndexPathForChangeTypeNewIndexPath(_: NSFetchedResultsController<any>, didChange: any, at?: IndexPath, for_?: NSFetchedResultsController.NSFetchedResultsChangeType, newIndexPath?: IndexPath): void;
  controllerDidChangeSectionAtIndexForChangeType(_: NSFetchedResultsController<any>, didChange: any, atSectionIndex: number, for_: NSFetchedResultsController.NSFetchedResultsChangeType): void;
  controllerSectionIndexTitleForSectionName(_: NSFetchedResultsController<any>, sectionIndexTitleForSectionName: string): string;
  controllerDidChangeContent(_: NSFetchedResultsController<any>): void;
  controllerWillChangeContent(_: NSFetchedResultsController<any>): void;
}

interface NSFetchedResultsSectionInfo {
  indexTitle: string;
  name: string;
  numberOfObjects: number;
  objects: any[];
}

export class NSIncrementalStore extends NSPersistentStore {
  static identifierForNewStoreAtURL(at: URL): any;
  executeRequestWithContext(withContext: NSPersistentStoreRequest, error?: NSManagedObjectContext): any;
  managedObjectContextDidRegisterObjectsWithIDs(with_: NSManagedObjectID[]): void;
  managedObjectContextDidUnregisterObjectsWithIDs(with_: NSManagedObjectID[]): void;
  newObjectIDForEntityReferenceObject(for_: NSEntityDescription, referenceObject: any): NSManagedObjectID;
  newValueForRelationshipForObjectWithIDWithContext(forObjectWithID: NSRelationshipDescription, withContext: NSManagedObjectID, error?: NSManagedObjectContext): any;
  newValuesForObjectWithIDWithContext(withContext: NSManagedObjectID, error: NSManagedObjectContext): NSIncrementalStoreNode;
  obtainPermanentIDsForObjects(error: NSManagedObject[]): NSManagedObjectID[];
  referenceObjectForObjectID(for_: NSManagedObjectID): any;
}

export class NSIncrementalStoreNode extends NSObject {
  objectID: NSManagedObjectID;
  //   version: number;
  static initWithObjectIDWithValuesVersion(_: NSManagedObjectID, withValues: Map<string, any>, version: number): NSIncrementalStoreNode;
  updateWithValuesVersion(withValues: Map<string, any>, version: number): void;
  valueForPropertyDescription(for_: NSPropertyDescription): any;
}

export class NSManagedObject extends NSObject {
  //  static entity(): NSEntityDescription;
  static fetchRequest(): NSFetchRequest<any>;
  isDeleted: boolean;
  //   entity: NSEntityDescription;
  isFault: boolean;
  faultingState: number;
  hasChanges: boolean;
  hasPersistentChangedValues: boolean;
  isInserted: boolean;
  managedObjectContext: NSManagedObjectContext;
  objectID: NSManagedObjectID;
  isUpdated: boolean;
  static contextShouldIgnoreUnmodeledPropertyChanges: boolean;
  awakeFromFetch(): void;
  awakeFromInsert(): void;
  awakeFromSnapshotEvents(fromSnapshotEvents: NSManagedObject.NSSnapshotEventType): void;
  changedValues(): Map<string, any>;
  changedValuesForCurrentEvent(): Map<string, any>;
  committedValuesForKeys(forKeys?: string[]): Map<string, any>;
  didAccessValueForKey(forKey?: string): void;
  didSave(): void;
  didTurnIntoFault(): void;
  hasFaultForRelationshipNamed(forRelationshipNamed: string): boolean;
  static initWithContext(_: NSManagedObjectContext): NSManagedObject;
  static initWithEntityInsertIntoManagedObjectContext(_: NSEntityDescription, insertIntoManagedObjectContext?: NSManagedObjectContext): NSManagedObject;
  objectIDsForRelationshipNamed(forRelationshipNamed: string): NSManagedObjectID[];
  prepareForDeletion(): void;
  primitiveValueForKey(forKey: string): any;
  setObservationInfo(_?: any): void;
  setPrimitiveValueForKey(_?: any, forKey?: string): void;
  validateForDelete(): boolean;
  validateForInsert(): boolean;
  validateForUpdate(): boolean;
  willAccessValueForKey(forKey?: string): void;
  willSave(): void;
  willTurnIntoFault(): void;
}

export class NSManagedObjectContext extends NSObject {
  static mergeChangesFromRemoteContextSaveIntoContexts(fromRemoteContextSave: Map<any, any>, into: NSManagedObjectContext[]): void;
  automaticallyMergesChangesFromParent: boolean;
  setAutomaticallyMergesChangesFromParent(_: boolean);
  concurrencyType: NSManagedObjectContext.NSManagedObjectContextConcurrencyType;
  deletedObjects: Set<any>;
  hasChanges: boolean;
  insertedObjects: Set<any>;
  mergePolicy: any;
  setMergePolicy(_: any);
  name: string;
  setName(_: string);
  parentContext: NSManagedObjectContext;
  setParentContext(_: NSManagedObjectContext);
  persistentStoreCoordinator: NSPersistentStoreCoordinator;
  setPersistentStoreCoordinator(_: NSPersistentStoreCoordinator);
  propagatesDeletesAtEndOfEvent: boolean;
  setPropagatesDeletesAtEndOfEvent(_: boolean);
  queryGenerationToken: NSQueryGenerationToken;
  registeredObjects: Set<any>;
  retainsRegisteredObjects: boolean;
  setRetainsRegisteredObjects(_: boolean);
  shouldDeleteInaccessibleFaults: boolean;
  setShouldDeleteInaccessibleFaults(_: boolean);
  stalenessInterval: number;
  setStalenessInterval(_: number);
  transactionAuthor: string;
  setTransactionAuthor(_: string);
  undoManager: UndoManager;
  setUndoManager(_: UndoManager);
  updatedObjects: Set<any>;
  userInfo: Map<any, any>;
  assignObjectToPersistentStore(_: any, to: NSPersistentStore): void;
  countForFetchRequest(error: NSFetchRequest<any>): number;
  deleteObject(_: NSManagedObject): void;
  detectConflictsForObject(for_: NSManagedObject): void;
  executeFetchRequest(_: NSFetchRequest<any>): any[];
  executeRequest(error: NSPersistentStoreRequest): NSPersistentStoreResult;
  existingObjectWithID(error: NSManagedObjectID): NSManagedObject;
  static initWithConcurrencyType(_: NSManagedObjectContext.NSManagedObjectContextConcurrencyType): NSManagedObjectContext;
  insertObject(_: NSManagedObject): void;
  mergeChangesFromContextDidSaveNotification(fromContextDidSave: Notification): void;
  objectRegisteredForID(for_: NSManagedObjectID): NSManagedObject;
  objectWithID(with_: NSManagedObjectID): NSManagedObject;
  obtainPermanentIDsForObjects(error: NSManagedObject[]): boolean;
  performBlock(_: () => void): void;
  performBlockAndWait(_: () => void): void;
  processPendingChanges(): void;
  redo(): void;
  refreshAllObjects(): void;
  refreshObjectMergeChanges(_: NSManagedObject, mergeChanges: boolean): void;
  reset(): void;
  rollback(): void;
  save(): boolean;
  setQueryGenerationFromToken(error?: NSQueryGenerationToken): boolean;
  shouldHandleInaccessibleFaultForObjectIDTriggeredByProperty(_: NSManagedObject, for_: NSManagedObjectID, triggeredByProperty?: NSPropertyDescription): boolean;
  undo(): void;
}

export class NSManagedObjectID extends NSObject {
  entity: NSEntityDescription;
  persistentStore: NSPersistentStore;
  isTemporaryID: boolean;
  uRIRepresentation(): URL;
}

export class NSManagedObjectModel extends NSObject {
  static mergedModelFromBundles(from?: Bundle[]): NSManagedObjectModel;
  static mergedModelFromBundlesForStoreMetadata(from?: Bundle[], forStoreMetadata?: Map<string, any>): NSManagedObjectModel;
  configurations: string[];
  entities: NSEntityDescription[];
  setEntities(_: NSEntityDescription[]);
  entitiesByName: Map<string, NSEntityDescription>;
  entityVersionHashesByName: Map<string, Data>;
  fetchRequestTemplatesByName: Map<string, NSFetchRequest<any>>;
  localizationDictionary: Map<string, string>;
  setLocalizationDictionary(_: Map<string, string>);
  versionIdentifiers: Set<any>;
  setVersionIdentifiers(_: Set<any>);
  // dupe name w instance property   entitiesForConfiguration(forConfigurationName?: string): NSEntityDescription[];
  fetchRequestFromTemplateWithNameSubstitutionVariables(withName: string, substitutionVariables: Map<string, any>): NSFetchRequest<any>;
  fetchRequestTemplateForName(forName: string): NSFetchRequest<any>;
  static initWithContentsOfURL(_: URL): NSManagedObjectModel;
  isConfigurationCompatibleWithStoreMetadata(withName?: string, compatibleWithStoreMetadata?: Map<string, any>): boolean;
  setEntitiesForConfiguration(_: NSEntityDescription[], forConfigurationName: string): void;
  setFetchRequestTemplateForName(_?: NSFetchRequest<any>, forName?: string): void;
}

export class NSMappingModel extends NSObject {
  static inferredMappingModelForSourceModelDestinationModel(destinationModel: NSManagedObjectModel, error: NSManagedObjectModel): NSMappingModel;
  entityMappings: NSEntityMapping[];
  setEntityMappings(_: NSEntityMapping[]);
  entityMappingsByName: Map<string, NSEntityMapping>;
  static initWithContentsOfURL(_?: URL): NSMappingModel;
}

export class NSMergeConflict extends NSObject {
  cachedSnapshot: Map<string, any>;
  newVersionNumber: number;
  objectSnapshot: Map<string, any>;
  oldVersionNumber: number;
  persistedSnapshot: Map<string, any>;
  sourceObject: NSManagedObject;
  static initWithSourceNewVersionOldVersionCachedSnapshotPersistedSnapshot(_: NSManagedObject, newVersion: number, oldVersion: number, cachedSnapshot?: Map<string, any>, persistedSnapshot?: Map<string, any>): NSMergeConflict;
}

export class NSMergePolicy extends NSObject {
  mergeType: NSMergePolicy.NSMergePolicyType;
  static errorMergePolicy: NSMergePolicy;
  static mergeByPropertyObjectTrumpMergePolicy: NSMergePolicy;
  static mergeByPropertyStoreTrumpMergePolicy: NSMergePolicy;
  static overwriteMergePolicy: NSMergePolicy;
  static rollbackMergePolicy: NSMergePolicy;
  static initWithMergeType(_: NSMergePolicy.NSMergePolicyType): NSMergePolicy;
  resolveConflicts(mergeConflicts: any[]): boolean;
  resolveConstraintConflicts(constraintConflicts: NSConstraintConflict[]): boolean;
  resolveOptimisticLockingVersionConflicts(optimisticLockingConflicts: NSMergeConflict[]): boolean;
}

export class NSMigrationManager extends NSObject {
  currentEntityMapping: NSEntityMapping;
  destinationContext: NSManagedObjectContext;
  destinationModel: NSManagedObjectModel;
  mappingModel: NSMappingModel;
  migrationProgress: number;
  sourceContext: NSManagedObjectContext;
  sourceModel: NSManagedObjectModel;
  userInfo: Map<any, any>;
  setUserInfo(_: Map<any, any>);
  usesStoreSpecificMigrationManager: boolean;
  setUsesStoreSpecificMigrationManager(_: boolean);
  associateSourceInstanceWithDestinationInstanceForEntityMapping(sourceInstance: NSManagedObject, withDestinationInstance: NSManagedObject, for_: NSEntityMapping): void;
  cancelMigrationWithError(_: Error): void;
  destinationEntityForEntityMapping(for_: NSEntityMapping): NSEntityDescription;
  destinationInstancesForEntityMappingNamedSourceInstances(forEntityMappingName: string, sourceInstances?: NSManagedObject[]): NSManagedObject[];
  static initWithSourceModelDestinationModel(_: NSManagedObjectModel, destinationModel: NSManagedObjectModel): NSMigrationManager;
  migrateStoreFromURLTypeOptionsWithMappingModelToDestinationURLDestinationTypeDestinationOptions(from: URL, sourceType: string, options?: Map<any, any>, with_?: NSMappingModel, toDestinationURL?: URL, destinationType?: string, destinationOptions?: Map<any, any>): boolean;
  reset(): void;
  sourceEntityForEntityMapping(for_: NSEntityMapping): NSEntityDescription;
  sourceInstancesForEntityMappingNamedDestinationInstances(forEntityMappingName: string, destinationInstances?: NSManagedObject[]): NSManagedObject[];
}

export class NSPersistentCloudKitContainer extends NSPersistentContainer {
  initializeCloudKitSchemaWithOptions(error: NSPersistentCloudKitContainer.NSPersistentCloudKitContainerSchemaInitializationOptions): boolean;
  recordForManagedObjectID(for_: NSManagedObjectID): CKRecord;
  recordIDForManagedObjectID(for_: NSManagedObjectID): CKRecord.ID;
  recordIDsForManagedObjectIDs(for_: NSManagedObjectID[]): Map<NSManagedObjectID, CKRecord.ID>;
  recordsForManagedObjectIDs(for_: NSManagedObjectID[]): Map<NSManagedObjectID, CKRecord>;
}

export class NSPersistentCloudKitContainerOptions extends NSObject {
  containerIdentifier: string;
  static initWithContainerIdentifier(_: string): NSPersistentCloudKitContainerOptions;
}

export class NSPersistentContainer extends NSObject {
  static defaultDirectoryURL(): URL;
  managedObjectModel: NSManagedObjectModel;
  name: string;
  persistentStoreCoordinator: NSPersistentStoreCoordinator;
  persistentStoreDescriptions: NSPersistentStoreDescription[];
  setPersistentStoreDescriptions(_: NSPersistentStoreDescription[]);
  viewContext: NSManagedObjectContext;
  static initWithName(_: string): NSPersistentContainer;
  static initWithNameManagedObjectModel(_: string, managedObjectModel: NSManagedObjectModel): NSPersistentContainer;
  loadPersistentStoresWithCompletionHandler(completionHandler?: (p1: NSPersistentStoreDescription, p2: Error) => void): void;
  newBackgroundContext(): NSManagedObjectContext;
  performBackgroundTask(_: (p1: NSManagedObjectContext) => void): void;
}

export class NSPersistentHistoryChange extends NSObject {
  //  static entityDescriptionWithContext(with_: NSManagedObjectContext): NSEntityDescription;
  changeID: number;
  changeType: NSPersistentHistoryChange.NSPersistentHistoryChangeType;
  changedObjectID: NSManagedObjectID;
  tombstone: Map<any, any>;
  transaction: NSPersistentHistoryTransaction;
  updatedProperties: Set<any>;
  static entityDescription: NSEntityDescription;
  static fetchRequest: NSFetchRequest<any>;
}

export class NSPersistentHistoryChangeRequest extends NSPersistentStoreRequest {
  static deleteHistoryBeforeDate(before: Date): NSPersistentHistoryChangeRequest;
  static deleteHistoryBeforeToken(before?: NSPersistentHistoryToken): NSPersistentHistoryChangeRequest;
  static deleteHistoryBeforeTransaction(before?: NSPersistentHistoryTransaction): NSPersistentHistoryChangeRequest;
  static fetchHistoryAfterDate(after: Date): NSPersistentHistoryChangeRequest;
  static fetchHistoryAfterToken(after?: NSPersistentHistoryToken): NSPersistentHistoryChangeRequest;
  static fetchHistoryAfterTransaction(after?: NSPersistentHistoryTransaction): NSPersistentHistoryChangeRequest;
  static fetchHistoryWithFetchRequest(withFetch: NSFetchRequest<any>): NSPersistentHistoryChangeRequest;
  fetchRequest: NSFetchRequest<any>;
  setFetchRequest(_: NSFetchRequest<any>);
  resultType: NSPersistentStoreResult.NSPersistentHistoryResultType;
  setResultType(_: NSPersistentStoreResult.NSPersistentHistoryResultType);
  token: NSPersistentHistoryToken;
}

export class NSPersistentHistoryResult extends NSPersistentStoreResult {
  result: any;
  resultType: NSPersistentStoreResult.NSPersistentHistoryResultType;
}

export class NSPersistentHistoryToken extends NSObject {
}

export class NSPersistentHistoryTransaction extends NSObject {
  //  static entityDescriptionWithContext(with_: NSManagedObjectContext): NSEntityDescription;
  author: string;
  bundleID: string;
  changes: NSPersistentHistoryChange[];
  contextName: string;
  processID: string;
  storeID: string;
  timestamp: Date;
  token: NSPersistentHistoryToken;
  transactionNumber: number;
  static entityDescription: NSEntityDescription;
  static fetchRequest: NSFetchRequest<any>;
  objectIDNotification(): Notification;
}

export class NSPersistentStore extends NSObject {
  static metadataForPersistentStoreWithURL(error: URL): Map<string, any>;
  static migrationManagerClass(): typeof NSObject;
  static setMetadataForPersistentStoreWithURL(_?: Map<string, any>, forPersistentStoreAt?: URL): boolean;
  URL: URL;
  setURL(_: URL);
  configurationName: string;
  coreSpotlightExporter: NSCoreDataCoreSpotlightDelegate;
  identifier: string;
  setIdentifier(_: string);
  metadata: Map<string, any>;
  setMetadata(_: Map<string, any>);
  options: Map<any, any>;
  persistentStoreCoordinator: NSPersistentStoreCoordinator;
  isReadOnly: boolean;
  setReadOnly(_: boolean);
  type: string;
  didAddToPersistentStoreCoordinator(to: NSPersistentStoreCoordinator): void;
  loadMetadata(): boolean;
  willRemoveFromPersistentStoreCoordinator(from?: NSPersistentStoreCoordinator): void;
}

export class NSPersistentStoreAsynchronousResult extends NSPersistentStoreResult {
  managedObjectContext: NSManagedObjectContext;
  operationError: Error;
  progress: Progress;
  cancel(): void;
}

export class NSPersistentStoreCoordinator extends NSObject {
  static elementsDerivedFromExternalRecordURL(fromExternalRecordAt: URL): Map<any, any>;
  static metadataForPersistentStoreOfTypeURLOptions(ofType: string, at: URL, options?: Map<any, any>): Map<string, any>;
  static registerStoreClassForStoreType(_?: typeof NSObject, forStoreType?: string): void;
  static setMetadataForPersistentStoreOfTypeURLOptions(_?: Map<string, any>, forPersistentStoreOfType?: string, at?: URL, options?: Map<any, any>): boolean;
  managedObjectModel: NSManagedObjectModel;
  name: string;
  setName(_: string);
  persistentStores: NSPersistentStore[];
  static registeredStoreTypes: Map<string, NSValue>;
  uRLForPersistentStore(for_: NSPersistentStore): URL;
  addPersistentStoreWithDescriptionCompletionHandler(with_: NSPersistentStoreDescription, completionHandler?: (p1: NSPersistentStoreDescription, p2: Error) => void): void;
  addPersistentStoreWithTypeConfigurationURLOptions(ofType: string, configurationName?: string, at?: URL, options?: Map<any, any>): NSPersistentStore;
  currentPersistentHistoryTokenFromStores(fromStores?: any[]): NSPersistentHistoryToken;
  destroyPersistentStoreAtURLWithTypeOptions(at: URL, ofType: string, options?: Map<any, any>): boolean;
  executeRequestWithContext(withContext: NSPersistentStoreRequest, error: NSManagedObjectContext): any;
  importStoreWithIdentifierFromExternalRecordsDirectoryToURLOptionsWithType(withIdentifier?: string, fromExternalRecordsDirectoryAt?: URL, to?: URL, options?: Map<any, any>, ofType?: string): NSPersistentStore;
  static initWithManagedObjectModel(_: NSManagedObjectModel): NSPersistentStoreCoordinator;
  managedObjectIDForURIRepresentation(forURIRepresentation: URL): NSManagedObjectID;
  metadataForPersistentStore(for_: NSPersistentStore): Map<string, any>;
  migratePersistentStoreToURLOptionsWithType(toURL: NSPersistentStore, options: URL, withType?: Map<any, any>, error?: string): NSPersistentStore;
  performBlock(_: () => void): void;
  performBlockAndWait(_: () => void): void;
  persistentStoreForURL(for_: URL): NSPersistentStore;
  removePersistentStore(_: NSPersistentStore): boolean;
  replacePersistentStoreAtURLDestinationOptionsWithPersistentStoreFromURLSourceOptionsStoreType(at: URL, destinationOptions?: Map<any, any>, withPersistentStoreFrom?: URL, sourceOptions?: Map<any, any>, ofType?: string): boolean;
  setMetadataForPersistentStore(_?: Map<string, any>, for_?: NSPersistentStore): void;
  setURLForPersistentStore(_: URL, for_: NSPersistentStore): boolean;
}

export class NSPersistentStoreDescription extends NSObject {
  URL: URL;
  setURL(_: URL);
  cloudKitContainerOptions: NSPersistentCloudKitContainerOptions;
  setCloudKitContainerOptions(_: NSPersistentCloudKitContainerOptions);
  configuration: string;
  setConfiguration(_: string);
  options: Map<string, NSObject>;
  isReadOnly: boolean;
  setReadOnly(_: boolean);
  shouldAddStoreAsynchronously: boolean;
  setShouldAddStoreAsynchronously(_: boolean);
  shouldInferMappingModelAutomatically: boolean;
  setShouldInferMappingModelAutomatically(_: boolean);
  shouldMigrateStoreAutomatically: boolean;
  setShouldMigrateStoreAutomatically(_: boolean);
  sqlitePragmas: Map<string, NSObject>;
  timeout: number;
  setTimeout(_: number);
  type: string;
  setType(_: string);
  static initWithURL(_: URL): NSPersistentStoreDescription;
  setOptionForKey(_?: NSObject, forKey?: string): void;
  setValueForPragmaNamed(_?: NSObject, forPragmaNamed?: string): void;
}

export class NSPersistentStoreRequest extends NSObject {
  affectedStores: NSPersistentStore[];
  setAffectedStores(_: NSPersistentStore[]);
  requestType: NSPersistentStoreRequest.NSPersistentStoreRequestType;
}

export class NSPersistentStoreResult extends NSObject {
}

export class NSPropertyDescription extends NSObject {
  entity: NSEntityDescription;
  isIndexedBySpotlight: boolean;
  setIndexedBySpotlight(_: boolean);
  name: string;
  setName(_: string);
  isOptional: boolean;
  setOptional(_: boolean);
  renamingIdentifier: string;
  setRenamingIdentifier(_: string);
  isTransient: boolean;
  setTransient(_: boolean);
  userInfo: Map<any, any>;
  setUserInfo(_: Map<any, any>);
  validationPredicates: NSPredicate[];
  validationWarnings: any[];
  versionHash: Data;
  versionHashModifier: string;
  setVersionHashModifier(_: string);
  setValidationPredicatesWithValidationWarnings(_?: NSPredicate[], withValidationWarnings?: string[]): void;
}

export class NSPropertyMapping extends NSObject {
  name: string;
  setName(_: string);
  userInfo: Map<any, any>;
  setUserInfo(_: Map<any, any>);
  valueExpression: NSExpression;
  setValueExpression(_: NSExpression);
}

export class NSQueryGenerationToken extends NSObject {
  static currentQueryGenerationToken: NSQueryGenerationToken;
}

export class NSRelationshipDescription extends NSPropertyDescription {
  deleteRule: NSRelationshipDescription.NSDeleteRule;
  setDeleteRule(_: NSRelationshipDescription.NSDeleteRule);
  destinationEntity: NSEntityDescription;
  setDestinationEntity(_: NSEntityDescription);
  inverseRelationship: NSRelationshipDescription;
  setInverseRelationship(_: NSRelationshipDescription);
  maxCount: number;
  setMaxCount(_: number);
  minCount: number;
  setMinCount(_: number);
  isOrdered: boolean;
  setOrdered(_: boolean);
  isToMany: boolean;
}

export class NSSaveChangesRequest extends NSPersistentStoreRequest {
  deletedObjects: Set<any>;
  insertedObjects: Set<any>;
  lockedObjects: Set<any>;
  updatedObjects: Set<any>;
}

// export function CFAbsoluteTimeGetCurrent(): number;

// export function CFAllocatorAllocate(allocator: any, size: number, hint: number): any;

// export function CFAllocatorCreate(allocator: any, context: CFAllocatorContext): any;

// export function CFAllocatorDeallocate(allocator: any, ptr: any): void;

// export function CFAllocatorGetContext(allocator: any, context: CFAllocatorContext): void;

// export function CFAllocatorGetDefault(): any;

// export function CFAllocatorGetPreferredSizeForSize(allocator: any, size: number, hint: number): number;

// export function CFAllocatorGetTypeID(): number;

// export function CFAllocatorReallocate(allocator: any, ptr: any, newsize: number, hint: number): any;

// export function CFAllocatorSetDefault(allocator: any): void;

// export function CFArrayAppendArray(theArray: any[], otherArray: any[], otherRange: CFRange): void;

// export function CFArrayAppendValue(theArray: any[], value: any): void;

// export function CFArrayApplyFunction(theArray: any[], range: CFRange, applier: (p1: any, p2: any) => void, context: any): void;

// export function CFArrayBSearchValues(theArray: any[], range: CFRange, value: any, comparator: (p1: any, p2: any, p3: any) => CFBase.CFComparisonResult, context: any): number;

// export function CFArrayContainsValue(theArray: any[], range: CFRange, value: any): boolean;

// export function CFArrayCreate(allocator: any, values: any, numValues: number, callBacks: CFArrayCallBacks): any[];

// export function CFArrayCreateCopy(allocator: any, theArray: any[]): any[];

// export function CFArrayCreateMutable(allocator: any, capacity: number, callBacks: CFArrayCallBacks): any[];

// export function CFArrayCreateMutableCopy(allocator: any, capacity: number, theArray: any[]): any[];

// export function CFArrayExchangeValuesAtIndices(theArray: any[], idx1: number, idx2: number): void;

// export function CFArrayGetCount(theArray: any[]): number;

// export function CFArrayGetCountOfValue(theArray: any[], range: CFRange, value: any): number;

// export function CFArrayGetFirstIndexOfValue(theArray: any[], range: CFRange, value: any): number;

// export function CFArrayGetLastIndexOfValue(theArray: any[], range: CFRange, value: any): number;

// export function CFArrayGetTypeID(): number;

// export function CFArrayGetValueAtIndex(theArray: any[], idx: number): any;

// export function CFArrayGetValues(theArray: any[], range: CFRange, values: any): void;

// export function CFArrayInsertValueAtIndex(theArray: any[], idx: number, value: any): void;

// export function CFArrayRemoveAllValues(theArray: any[]): void;

// export function CFArrayRemoveValueAtIndex(theArray: any[], idx: number): void;

// export function CFArrayReplaceValues(theArray: any[], range: CFRange, newValues: any, newCount: number): void;

// export function CFArraySetValueAtIndex(theArray: any[], idx: number, value: any): void;

// export function CFArraySortValues(theArray: any[], range: CFRange, comparator: (p1: any, p2: any, p3: any) => CFBase.CFComparisonResult, context: any): void;

// export function CFAttributedStringBeginEditing(aStr: NSAttributedString): void;

// export function CFAttributedStringCreate(alloc: any, str: string, attributes: Map<any, any>): NSAttributedString;

// export function CFAttributedStringCreateCopy(alloc: any, aStr: NSAttributedString): NSAttributedString;

// export function CFAttributedStringCreateMutable(alloc: any, maxLength: number): NSAttributedString;

// export function CFAttributedStringCreateMutableCopy(alloc: any, maxLength: number, aStr: NSAttributedString): NSAttributedString;

// export function CFAttributedStringCreateWithSubstring(alloc: any, aStr: NSAttributedString, range: CFRange): NSAttributedString;

// export function CFAttributedStringEndEditing(aStr: NSAttributedString): void;

// export function CFAttributedStringGetAttribute(aStr: NSAttributedString, loc: number, attrName: string, effectiveRange: CFRange): any;

// export function CFAttributedStringGetAttributeAndLongestEffectiveRange(aStr: NSAttributedString, loc: number, attrName: string, inRange: CFRange, longestEffectiveRange: CFRange): any;

// export function CFAttributedStringGetAttributes(aStr: NSAttributedString, loc: number, effectiveRange: CFRange): Map<any, any>;

// export function CFAttributedStringGetAttributesAndLongestEffectiveRange(aStr: NSAttributedString, loc: number, inRange: CFRange, longestEffectiveRange: CFRange): Map<any, any>;

// export function CFAttributedStringGetLength(aStr: NSAttributedString): number;

// export function CFAttributedStringGetMutableString(aStr: NSAttributedString): string;

// export function CFAttributedStringGetString(aStr: NSAttributedString): string;

// export function CFAttributedStringGetTypeID(): number;

// export function CFAttributedStringRemoveAttribute(aStr: NSAttributedString, range: CFRange, attrName: string): void;

// export function CFAttributedStringReplaceAttributedString(aStr: NSAttributedString, range: CFRange, replacement: NSAttributedString): void;

// export function CFAttributedStringReplaceString(aStr: NSAttributedString, range: CFRange, replacement: string): void;

// export function CFAttributedStringSetAttribute(aStr: NSAttributedString, range: CFRange, attrName: string, value: any): void;

// export function CFAttributedStringSetAttributes(aStr: NSAttributedString, range: CFRange, replacement: Map<any, any>, clearOtherAttributes: boolean): void;

// export function CFAutorelease(arg: any): any;

// export function CFBagAddValue(theBag: any, value: any): void;

// export function CFBagApplyFunction(theBag: any, applier: (p1: any, p2: any) => void, context: any): void;

// export function CFBagContainsValue(theBag: any, value: any): boolean;

// export function CFBagCreate(allocator: any, values: any, numValues: number, callBacks: CFBagCallBacks): any;

// export function CFBagCreateCopy(allocator: any, theBag: any): any;

// export function CFBagCreateMutable(allocator: any, capacity: number, callBacks: CFBagCallBacks): any;

// export function CFBagCreateMutableCopy(allocator: any, capacity: number, theBag: any): any;

// export function CFBagGetCount(theBag: any): number;

// export function CFBagGetCountOfValue(theBag: any, value: any): number;

// export function CFBagGetTypeID(): number;

// export function CFBagGetValue(theBag: any, value: any): any;

// export function CFBagGetValueIfPresent(theBag: any, candidate: any, value: any): boolean;

// export function CFBagGetValues(theBag: any, values: any): void;

// export function CFBagRemoveAllValues(theBag: any): void;

// export function CFBagRemoveValue(theBag: any, value: any): void;

// export function CFBagReplaceValue(theBag: any, value: any): void;

// export function CFBagSetValue(theBag: any, value: any): void;

// export function CFBinaryHeapAddValue(heap: any, value: any): void;

// export function CFBinaryHeapApplyFunction(heap: any, applier: (p1: any, p2: any) => void, context: any): void;

// export function CFBinaryHeapContainsValue(heap: any, value: any): boolean;

// export function CFBinaryHeapCreate(allocator: any, capacity: number, callBacks: CFBinaryHeapCallBacks, compareContext: CFBinaryHeapCompareContext): any;

// export function CFBinaryHeapCreateCopy(allocator: any, capacity: number, heap: any): any;

// export function CFBinaryHeapGetCount(heap: any): number;

// export function CFBinaryHeapGetCountOfValue(heap: any, value: any): number;

// export function CFBinaryHeapGetMinimum(heap: any): any;

// export function CFBinaryHeapGetMinimumIfPresent(heap: any, value: any): boolean;

// export function CFBinaryHeapGetTypeID(): number;

// export function CFBinaryHeapGetValues(heap: any, values: any): void;

// export function CFBinaryHeapRemoveAllValues(heap: any): void;

// export function CFBinaryHeapRemoveMinimumValue(heap: any): void;

// export function CFBitVectorContainsBit(bv: any, range: CFRange, value: number): boolean;

// export function CFBitVectorCreate(allocator: any, bytes: string | any, numBits: number): any;

// export function CFBitVectorCreateCopy(allocator: any, bv: any): any;

// export function CFBitVectorCreateMutable(allocator: any, capacity: number): any;

// export function CFBitVectorCreateMutableCopy(allocator: any, capacity: number, bv: any): any;

// export function CFBitVectorFlipBitAtIndex(bv: any, idx: number): void;

// export function CFBitVectorFlipBits(bv: any, range: CFRange): void;

// export function CFBitVectorGetBitAtIndex(bv: any, idx: number): number;

// export function CFBitVectorGetBits(bv: any, range: CFRange, bytes: string | any): void;

// export function CFBitVectorGetCount(bv: any): number;

// export function CFBitVectorGetCountOfBit(bv: any, range: CFRange, value: number): number;

// export function CFBitVectorGetFirstIndexOfBit(bv: any, range: CFRange, value: number): number;

// export function CFBitVectorGetLastIndexOfBit(bv: any, range: CFRange, value: number): number;

// export function CFBitVectorGetTypeID(): number;

// export function CFBitVectorSetAllBits(bv: any, value: number): void;

// export function CFBitVectorSetBitAtIndex(bv: any, idx: number, value: number): void;

// export function CFBitVectorSetBits(bv: any, range: CFRange, value: number): void;

// export function CFBitVectorSetCount(bv: any, count: number): void;

// export function CFBooleanGetTypeID(): number;

// export function CFBooleanGetValue(boolean: number): boolean;

// export function CFBundleCopyAuxiliaryExecutableURL(bundle: any, executableName: string): URL;

// export function CFBundleCopyBuiltInPlugInsURL(bundle: any): URL;

// export function CFBundleCopyBundleLocalizations(bundle: any): any[];

// export function CFBundleCopyBundleURL(bundle: any): URL;

// export function CFBundleCopyExecutableArchitectures(bundle: any): any[];

// export function CFBundleCopyExecutableArchitecturesForURL(url: URL): any[];

// export function CFBundleCopyExecutableURL(bundle: any): URL;

// export function CFBundleCopyInfoDictionaryForURL(url: URL): Map<any, any>;

// export function CFBundleCopyInfoDictionaryInDirectory(bundleURL: URL): Map<any, any>;

// export function CFBundleCopyLocalizationsForPreferences(locArray: any[], prefArray: any[]): any[];

// export function CFBundleCopyLocalizationsForURL(url: URL): any[];

// export function CFBundleCopyLocalizedString(bundle: any, key: string, value: string, tableName: string): string;

// export function CFBundleCopyPreferredLocalizationsFromArray(locArray: any[]): any[];

// export function CFBundleCopyPrivateFrameworksURL(bundle: any): URL;

// export function CFBundleCopyResourceURL(bundle: any, resourceName: string, resourceType: string, subDirName: string): URL;

// export function CFBundleCopyResourceURLForLocalization(bundle: any, resourceName: string, resourceType: string, subDirName: string, localizationName: string): URL;

// export function CFBundleCopyResourceURLInDirectory(bundleURL: URL, resourceName: string, resourceType: string, subDirName: string): URL;

// export function CFBundleCopyResourceURLsOfType(bundle: any, resourceType: string, subDirName: string): any[];

// export function CFBundleCopyResourceURLsOfTypeForLocalization(bundle: any, resourceType: string, subDirName: string, localizationName: string): any[];

// export function CFBundleCopyResourceURLsOfTypeInDirectory(bundleURL: URL, resourceType: string, subDirName: string): any[];

// export function CFBundleCopyResourcesDirectoryURL(bundle: any): URL;

// export function CFBundleCopySharedFrameworksURL(bundle: any): URL;

// export function CFBundleCopySharedSupportURL(bundle: any): URL;

// export function CFBundleCopySupportFilesDirectoryURL(bundle: any): URL;

// export function CFBundleCreate(allocator: any, bundleURL: URL): any;

// export function CFBundleCreateBundlesFromDirectory(allocator: any, directoryURL: URL, bundleType: string): any[];

// export function CFBundleGetAllBundles(): any[];

// export function CFBundleGetBundleWithIdentifier(bundleID: string): any;

// export function CFBundleGetDataPointerForName(bundle: any, symbolName: string): any;

// export function CFBundleGetDataPointersForNames(bundle: any, symbolNames: any[], stbl: any): void;

// export function CFBundleGetDevelopmentRegion(bundle: any): string;

// export function CFBundleGetFunctionPointerForName(bundle: any, functionName: string): any;

// export function CFBundleGetFunctionPointersForNames(bundle: any, functionNames: any[], ftbl: any): void;

// export function CFBundleGetIdentifier(bundle: any): string;

// export function CFBundleGetInfoDictionary(bundle: any): Map<any, any>;

// export function CFBundleGetLocalInfoDictionary(bundle: any): Map<any, any>;

// export function CFBundleGetMainBundle(): any;

// export function CFBundleGetPackageInfo(bundle: any, packageType: number, packageCreator: number): void;

// export function CFBundleGetPackageInfoInDirectory(url: URL, packageType: number, packageCreator: number): boolean;

// export function CFBundleGetPlugIn(bundle: any): any;

// export function CFBundleGetTypeID(): number;

// export function CFBundleGetValueForInfoDictionaryKey(bundle: any, key: string): any;

// export function CFBundleGetVersionNumber(bundle: any): number;

// export function CFBundleIsExecutableLoaded(bundle: any): boolean;

// export function CFBundleLoadExecutable(bundle: any): boolean;

// export function CFBundleLoadExecutableAndReturnError(bundle: any, error: Error): boolean;

// export function CFBundlePreflightExecutable(bundle: any, error: Error): boolean;

// export function CFBundleUnloadExecutable(bundle: any): void;

// export function CFCalendarCopyCurrent(): Calendar;

// export function CFCalendarCopyLocale(calendar: Calendar): Locale;

// export function CFCalendarCopyTimeZone(calendar: Calendar): TimeZone;

// export function CFCalendarCreateWithIdentifier(allocator: any, identifier: any): Calendar;

// export function CFCalendarGetFirstWeekday(calendar: Calendar): number;

// export function CFCalendarGetIdentifier(calendar: Calendar): any;

// export function CFCalendarGetMaximumRangeOfUnit(calendar: Calendar, unit: CFCalendar.CFCalendarUnit): CFRange;

// export function CFCalendarGetMinimumDaysInFirstWeek(calendar: Calendar): number;

// export function CFCalendarGetMinimumRangeOfUnit(calendar: Calendar, unit: CFCalendar.CFCalendarUnit): CFRange;

// export function CFCalendarGetOrdinalityOfUnit(calendar: Calendar, smallerUnit: CFCalendar.CFCalendarUnit, biggerUnit: CFCalendar.CFCalendarUnit, at: number): number;

// export function CFCalendarGetRangeOfUnit(calendar: Calendar, smallerUnit: CFCalendar.CFCalendarUnit, biggerUnit: CFCalendar.CFCalendarUnit, at: number): CFRange;

// export function CFCalendarGetTimeRangeOfUnit(calendar: Calendar, unit: CFCalendar.CFCalendarUnit, at: number, startp: number, tip: number): boolean;

// export function CFCalendarGetTypeID(): number;

// export function CFCalendarSetFirstWeekday(calendar: Calendar, wkdy: number): void;

// export function CFCalendarSetLocale(calendar: Calendar, locale: Locale): void;

// export function CFCalendarSetMinimumDaysInFirstWeek(calendar: Calendar, mwd: number): void;

// export function CFCalendarSetTimeZone(calendar: Calendar, tz: TimeZone): void;

// export function CFCharacterSetAddCharactersInRange(theSet: CharacterSet, theRange: CFRange): void;

// export function CFCharacterSetAddCharactersInString(theSet: CharacterSet, theString: string): void;

// export function CFCharacterSetCreateBitmapRepresentation(alloc: any, theSet: CharacterSet): Data;

// export function CFCharacterSetCreateCopy(alloc: any, theSet: CharacterSet): CharacterSet;

// export function CFCharacterSetCreateInvertedSet(alloc: any, theSet: CharacterSet): CharacterSet;

// export function CFCharacterSetCreateMutable(alloc: any): CharacterSet;

// export function CFCharacterSetCreateMutableCopy(alloc: any, theSet: CharacterSet): CharacterSet;

// export function CFCharacterSetCreateWithBitmapRepresentation(alloc: any, theData: Data): CharacterSet;

// export function CFCharacterSetCreateWithCharactersInRange(alloc: any, theRange: CFRange): CharacterSet;

// export function CFCharacterSetCreateWithCharactersInString(alloc: any, theString: string): CharacterSet;

// export function CFCharacterSetGetPredefined(theSetIdentifier: CFCharacterSet.CFCharacterSetPredefinedSet): CharacterSet;

// export function CFCharacterSetGetTypeID(): number;

// export function CFCharacterSetHasMemberInPlane(theSet: CharacterSet, thePlane: number): boolean;

// export function CFCharacterSetIntersect(theSet: CharacterSet, theOtherSet: CharacterSet): void;

// export function CFCharacterSetInvert(theSet: CharacterSet): void;

// export function CFCharacterSetIsCharacterMember(theSet: CharacterSet, theChar: number): boolean;

// export function CFCharacterSetIsLongCharacterMember(theSet: CharacterSet, theChar: number): boolean;

// export function CFCharacterSetIsSupersetOfSet(theSet: CharacterSet, theOtherset: CharacterSet): boolean;

// export function CFCharacterSetRemoveCharactersInRange(theSet: CharacterSet, theRange: CFRange): void;

// export function CFCharacterSetRemoveCharactersInString(theSet: CharacterSet, theString: string): void;

// export function CFCharacterSetUnion(theSet: CharacterSet, theOtherSet: CharacterSet): void;

// export function CFCopyDescription(cf: any): string;

// export function CFCopyHomeDirectoryURL(): URL;

// export function CFCopyTypeIDDescription(type_id: number): string;

// export function CFDataAppendBytes(theData: Data, bytes: string | any, length: number): void;

// export function CFDataCreate(allocator: any, bytes: string | any, length: number): Data;

// export function CFDataCreateCopy(allocator: any, theData: Data): Data;

// export function CFDataCreateMutable(allocator: any, capacity: number): Data;

// export function CFDataCreateMutableCopy(allocator: any, capacity: number, theData: Data): Data;

// export function CFDataCreateWithBytesNoCopy(allocator: any, bytes: string | any, length: number, bytesDeallocator: any): Data;

// export function CFDataDeleteBytes(theData: Data, range: CFRange): void;

// export function CFDataFind(theData: Data, dataToFind: Data, searchRange: CFRange, compareOptions: CFData.CFDataSearchFlags): CFRange;

// export function CFDataGetBytePtr(theData: Data): string;

// export function CFDataGetBytes(theData: Data, range: CFRange, buffer: string | any): void;

// export function CFDataGetLength(theData: Data): number;

// export function CFDataGetMutableBytePtr(theData: Data): string;

// export function CFDataGetTypeID(): number;

// export function CFDataIncreaseLength(theData: Data, extraLength: number): void;

// export function CFDataReplaceBytes(theData: Data, range: CFRange, newBytes: string | any, newLength: number): void;

// export function CFDataSetLength(theData: Data, length: number): void;

// export function CFDateCompare(theDate: Date, otherDate: Date, context: any): CFBase.CFComparisonResult;

// export function CFDateCreate(allocator: any, at: number): Date;

// export function CFDateFormatterCopyProperty(formatter: any, key: any): any;

// export function CFDateFormatterCreate(allocator: any, locale: Locale, dateStyle: CFDateFormatter.CFDateFormatterStyle, timeStyle: CFDateFormatter.CFDateFormatterStyle): any;

// export function CFDateFormatterCreateDateFormatFromTemplate(allocator: any, tmplate: string, options: number, locale: Locale): string;

// export function CFDateFormatterCreateDateFromString(allocator: any, formatter: any, string: string, rangep: CFRange): Date;

// export function CFDateFormatterCreateISO8601Formatter(allocator: any, formatOptions: CFDateFormatter.CFISO8601DateFormatOptions): any;

// export function CFDateFormatterCreateStringWithAbsoluteTime(allocator: any, formatter: any, at: number): string;

// export function CFDateFormatterCreateStringWithDate(allocator: any, formatter: any, date: Date): string;

// export function CFDateFormatterGetAbsoluteTimeFromString(formatter: any, string: string, rangep: CFRange, atp: number): boolean;

// export function CFDateFormatterGetDateStyle(formatter: any): CFDateFormatter.CFDateFormatterStyle;

// export function CFDateFormatterGetFormat(formatter: any): string;

// export function CFDateFormatterGetLocale(formatter: any): Locale;

// export function CFDateFormatterGetTimeStyle(formatter: any): CFDateFormatter.CFDateFormatterStyle;

// export function CFDateFormatterGetTypeID(): number;

// export function CFDateFormatterSetFormat(formatter: any, formatString: string): void;

// export function CFDateFormatterSetProperty(formatter: any, key: string, value: any): void;

// export function CFDateGetAbsoluteTime(theDate: Date): number;

// export function CFDateGetTimeIntervalSinceDate(theDate: Date, otherDate: Date): number;

// export function CFDateGetTypeID(): number;

// export function CFDictionaryAddValue(theDict: Map<any, any>, key: any, value: any): void;

// export function CFDictionaryApplyFunction(theDict: Map<any, any>, applier: (p1: any, p2: any, p3: any) => void, context: any): void;

// export function CFDictionaryContainsKey(theDict: Map<any, any>, key: any): boolean;

// export function CFDictionaryContainsValue(theDict: Map<any, any>, value: any): boolean;

// export function CFDictionaryCreate(allocator: any, keys: any, values: any, numValues: number, keyCallBacks: CFDictionaryKeyCallBacks, valueCallBacks: CFDictionaryValueCallBacks): Map<any, any>;

// export function CFDictionaryCreateCopy(allocator: any, theDict: Map<any, any>): Map<any, any>;

// export function CFDictionaryCreateMutable(allocator: any, capacity: number, keyCallBacks: CFDictionaryKeyCallBacks, valueCallBacks: CFDictionaryValueCallBacks): Map<any, any>;

// export function CFDictionaryCreateMutableCopy(allocator: any, capacity: number, theDict: Map<any, any>): Map<any, any>;

// export function CFDictionaryGetCount(theDict: Map<any, any>): number;

// export function CFDictionaryGetCountOfKey(theDict: Map<any, any>, key: any): number;

// export function CFDictionaryGetCountOfValue(theDict: Map<any, any>, value: any): number;

// export function CFDictionaryGetKeysAndValues(theDict: Map<any, any>, keys: any, values: any): void;

// export function CFDictionaryGetTypeID(): number;

// export function CFDictionaryGetValue(theDict: Map<any, any>, key: any): any;

// export function CFDictionaryGetValueIfPresent(theDict: Map<any, any>, key: any, value: any): boolean;

// export function CFDictionaryRemoveAllValues(theDict: Map<any, any>): void;

// export function CFDictionaryRemoveValue(theDict: Map<any, any>, key: any): void;

// export function CFDictionaryReplaceValue(theDict: Map<any, any>, key: any, value: any): void;

// export function CFDictionarySetValue(theDict: Map<any, any>, key: any, value: any): void;

// export function CFEqual(cf1: any, cf2: any): boolean;

// export function CFErrorCopyDescription(err: Error): string;

// export function CFErrorCopyFailureReason(err: Error): string;

// export function CFErrorCopyRecoverySuggestion(err: Error): string;

// export function CFErrorCopyUserInfo(err: Error): Map<any, any>;

// export function CFErrorCreate(allocator: any, domain: any, code: number, userInfo: Map<any, any>): Error;

// export function CFErrorCreateWithUserInfoKeysAndValues(allocator: any, domain: any, code: number, userInfoKeys: any, userInfoValues: any, numUserInfoValues: number): Error;

// export function CFErrorGetCode(err: Error): number;

// export function CFErrorGetDomain(err: Error): any;

// export function CFErrorGetTypeID(): number;

// export function CFFileDescriptorCreate(allocator: any, fd: number, closeOnInvalidate: boolean, callout: (p1: any, p2: number, p3: any) => void, context: CFFileDescriptorContext): any;

// export function CFFileDescriptorCreateRunLoopSource(allocator: any, f: any, order: number): any;

// export function CFFileDescriptorDisableCallBacks(f: any, callBackTypes: number): void;

// export function CFFileDescriptorEnableCallBacks(f: any, callBackTypes: number): void;

// export function CFFileDescriptorGetContext(f: any, context: CFFileDescriptorContext): void;

// export function CFFileDescriptorGetNativeDescriptor(f: any): number;

// export function CFFileDescriptorGetTypeID(): number;

// export function CFFileDescriptorInvalidate(f: any): void;

// export function CFFileDescriptorIsValid(f: any): boolean;

// export function CFFileSecurityClearProperties(fileSec: NSFileSecurity, clearPropertyMask: CFFileSecurity.CFFileSecurityClearOptions): boolean;

// export function CFFileSecurityCopyAccessControlList(fileSec: NSFileSecurity, accessControlList: any): boolean;

// export function CFFileSecurityCopyGroupUUID(fileSec: NSFileSecurity, groupUUID: any): boolean;

// export function CFFileSecurityCopyOwnerUUID(fileSec: NSFileSecurity, ownerUUID: any): boolean;

// export function CFFileSecurityCreate(allocator: any): NSFileSecurity;

// export function CFFileSecurityCreateCopy(allocator: any, fileSec: NSFileSecurity): NSFileSecurity;

// export function CFFileSecurityGetGroup(fileSec: NSFileSecurity, group: number): boolean;

// export function CFFileSecurityGetMode(fileSec: NSFileSecurity, mode: number): boolean;

// export function CFFileSecurityGetOwner(fileSec: NSFileSecurity, owner: number): boolean;

// export function CFFileSecurityGetTypeID(): number;

// export function CFFileSecuritySetAccessControlList(fileSec: NSFileSecurity, accessControlList: any): boolean;

// export function CFFileSecuritySetGroup(fileSec: NSFileSecurity, group: number): boolean;

// export function CFFileSecuritySetGroupUUID(fileSec: NSFileSecurity, groupUUID: any): boolean;

// export function CFFileSecuritySetMode(fileSec: NSFileSecurity, mode: number): boolean;

// export function CFFileSecuritySetOwner(fileSec: NSFileSecurity, owner: number): boolean;

// export function CFFileSecuritySetOwnerUUID(fileSec: NSFileSecurity, ownerUUID: any): boolean;

// export function CFGetAllocator(cf: any): any;

// export function CFGetRetainCount(cf: any): number;

// export function CFGetTypeID(cf: any): number;

// export function CFHash(cf: any): number;

// export function CFLocaleCopyAvailableLocaleIdentifiers(): any[];

// export function CFLocaleCopyCommonISOCurrencyCodes(): any[];

// export function CFLocaleCopyCurrent(): Locale;

// export function CFLocaleCopyDisplayNameForPropertyValue(displayLocale: Locale, key: any, value: string): string;

// export function CFLocaleCopyISOCountryCodes(): any[];

// export function CFLocaleCopyISOCurrencyCodes(): any[];

// export function CFLocaleCopyISOLanguageCodes(): any[];

// export function CFLocaleCopyPreferredLanguages(): any[];

// export function CFLocaleCreate(allocator: any, localeIdentifier: any): Locale;

// export function CFLocaleCreateCanonicalLanguageIdentifierFromString(allocator: any, localeIdentifier: string): any;

// export function CFLocaleCreateCanonicalLocaleIdentifierFromScriptManagerCodes(allocator: any, lcode: number, rcode: number): any;

// export function CFLocaleCreateCanonicalLocaleIdentifierFromString(allocator: any, localeIdentifier: string): any;

// export function CFLocaleCreateComponentsFromLocaleIdentifier(allocator: any, localeID: any): Map<any, any>;

// export function CFLocaleCreateCopy(allocator: any, locale: Locale): Locale;

// export function CFLocaleCreateLocaleIdentifierFromComponents(allocator: any, dictionary: Map<any, any>): any;

// export function CFLocaleCreateLocaleIdentifierFromWindowsLocaleCode(allocator: any, lcid: number): any;

// export function CFLocaleGetIdentifier(locale: Locale): any;

// export function CFLocaleGetLanguageCharacterDirection(isoLangCode: string): CFLocale.CFLocaleLanguageDirection;

// export function CFLocaleGetLanguageLineDirection(isoLangCode: string): CFLocale.CFLocaleLanguageDirection;

// export function CFLocaleGetSystem(): Locale;

// export function CFLocaleGetTypeID(): number;

// export function CFLocaleGetValue(locale: Locale, key: any): any;

// export function CFLocaleGetWindowsLocaleCodeFromLocaleIdentifier(localeIdentifier: any): number;

// export function CFMachPortCreate(allocator: any, callout: (p1: NSMachPort, p2: any, p3: number, p4: any) => void, context: CFMachPortContext, shouldFreeInfo: string | any): NSMachPort;

// export function CFMachPortCreateRunLoopSource(allocator: any, port: NSMachPort, order: number): any;

// export function CFMachPortCreateWithPort(allocator: any, portNum: number, callout: (p1: NSMachPort, p2: any, p3: number, p4: any) => void, context: CFMachPortContext, shouldFreeInfo: string | any): NSMachPort;

// export function CFMachPortGetContext(port: NSMachPort, context: CFMachPortContext): void;

// export function CFMachPortGetInvalidationCallBack(port: NSMachPort): (p1: NSMachPort, p2: any) => void;

// export function CFMachPortGetPort(port: NSMachPort): number;

// export function CFMachPortGetTypeID(): number;

// export function CFMachPortInvalidate(port: NSMachPort): void;

// export function CFMachPortIsValid(port: NSMachPort): boolean;

// export function CFMachPortSetInvalidationCallBack(port: NSMachPort, callout: (p1: NSMachPort, p2: any) => void): void;

// export function CFMakeCollectable(cf: any): any;

// export function CFMessagePortCreateLocal(allocator: any, name: string, callout: (p1: MessagePort, p2: number, p3: Data, p4: any) => Data, context: CFMessagePortContext, shouldFreeInfo: string | any): MessagePort;

// export function CFMessagePortCreateRemote(allocator: any, name: string): MessagePort;

// export function CFMessagePortCreateRunLoopSource(allocator: any, local: MessagePort, order: number): any;

// export function CFMessagePortGetContext(ms: MessagePort, context: CFMessagePortContext): void;

// export function CFMessagePortGetInvalidationCallBack(ms: MessagePort): (p1: MessagePort, p2: any) => void;

// export function CFMessagePortGetName(ms: MessagePort): string;

// export function CFMessagePortGetTypeID(): number;

// export function CFMessagePortInvalidate(ms: MessagePort): void;

// export function CFMessagePortIsRemote(ms: MessagePort): boolean;

// export function CFMessagePortIsValid(ms: MessagePort): boolean;

// export function CFMessagePortSendRequest(remote: MessagePort, msgid: number, data: Data, sendTimeout: number, rcvTimeout: number, replyMode: string, returnData: Data): number;

// export function CFMessagePortSetDispatchQueue(ms: MessagePort, queue: NSObject): void;

// export function CFMessagePortSetInvalidationCallBack(ms: MessagePort, callout: (p1: MessagePort, p2: any) => void): void;

// export function CFMessagePortSetName(ms: MessagePort, newName: string): boolean;

// export function CFNotificationCenterAddObserver(center: any, observer: any, callBack: (p1: any, p2: any, p3: any, p4: any, p5: Map<any, any>) => void, name: string, object_: any, suspensionBehavior: CFNotificationCenter.CFNotificationSuspensionBehavior): void;

// export function CFNotificationCenterGetDarwinNotifyCenter(): any;

// export function CFNotificationCenterGetDistributedCenter(): any;

// export function CFNotificationCenterGetLocalCenter(): any;

// export function CFNotificationCenterGetTypeID(): number;

// export function CFNotificationCenterPostNotification(center: any, name: any, object_: any, userInfo: Map<any, any>, deliverImmediately: boolean): void;

// export function CFNotificationCenterPostNotificationWithOptions(center: any, name: any, object_: any, userInfo: Map<any, any>, options: number): void;

// export function CFNotificationCenterRemoveEveryObserver(center: any, observer: any): void;

// export function CFNotificationCenterRemoveObserver(center: any, observer: any, name: any, object_: any): void;

// export function CFNullGetTypeID(): number;

// export function CFNumberCompare(number: number, otherNumber: number, context: any): CFBase.CFComparisonResult;

// export function CFNumberCreate(allocator: any, theType: CFNumber.CFNumberType, valuePtr: any): number;

// export function CFNumberFormatterCopyProperty(formatter: any, key: any): any;

// export function CFNumberFormatterCreate(allocator: any, locale: Locale, style: CFNumberFormatter.CFNumberFormatterStyle): any;

// export function CFNumberFormatterCreateNumberFromString(allocator: any, formatter: any, string: string, rangep: CFRange, options: number): number;

// export function CFNumberFormatterCreateStringWithNumber(allocator: any, formatter: any, number: number): string;

// export function CFNumberFormatterCreateStringWithValue(allocator: any, formatter: any, numberType: CFNumber.CFNumberType, valuePtr: any): string;

// export function CFNumberFormatterGetDecimalInfoForCurrencyCode(currencyCode: string, defaultFractionDigits: number, roundingIncrement: number): boolean;

// export function CFNumberFormatterGetFormat(formatter: any): string;

// export function CFNumberFormatterGetLocale(formatter: any): Locale;

// export function CFNumberFormatterGetStyle(formatter: any): CFNumberFormatter.CFNumberFormatterStyle;

// export function CFNumberFormatterGetTypeID(): number;

// export function CFNumberFormatterGetValueFromString(formatter: any, string: string, rangep: CFRange, numberType: CFNumber.CFNumberType, valuePtr: any): boolean;

// export function CFNumberFormatterSetFormat(formatter: any, formatString: string): void;

// export function CFNumberFormatterSetProperty(formatter: any, key: any, value: any): void;

// export function CFNumberGetByteSize(number: number): number;

// export function CFNumberGetType(number: number): CFNumber.CFNumberType;

// export function CFNumberGetTypeID(): number;

// export function CFNumberGetValue(number: number, theType: CFNumber.CFNumberType, valuePtr: any): boolean;

// export function CFNumberIsFloatType(number: number): boolean;

// export function CFPlugInAddInstanceForFactory(factoryID: any): void;

// export function CFPlugInCreate(allocator: any, plugInURL: URL): any;

// export function CFPlugInFindFactoriesForPlugInType(typeUUID: any): any[];

// export function CFPlugInFindFactoriesForPlugInTypeInPlugIn(typeUUID: any, plugIn: any): any[];

// export function CFPlugInGetBundle(plugIn: any): any;

// export function CFPlugInGetTypeID(): number;

// export function CFPlugInInstanceCreate(allocator: any, factoryUUID: any, typeUUID: any): any;

// export function CFPlugInInstanceCreateWithInstanceDataSize(allocator: any, instanceDataSize: number, deallocateInstanceFunction: (p1: any) => void, factoryName: string, getInterfaceFunction: (p1: any, p2: string, p3: any) => boolean): any;

// export function CFPlugInInstanceGetFactoryName(instance: any): string;

// export function CFPlugInInstanceGetInstanceData(instance: any): any;

// export function CFPlugInInstanceGetInterfaceFunctionTable(instance: any, interfaceName: string, ftbl: any): boolean;

// export function CFPlugInInstanceGetTypeID(): number;

// export function CFPlugInIsLoadOnDemand(plugIn: any): boolean;

// export function CFPlugInRegisterFactoryFunction(factoryUUID: any, func: (p1: any, p2: any) => any): boolean;

// export function CFPlugInRegisterFactoryFunctionByName(factoryUUID: any, plugIn: any, functionName: string): boolean;

// export function CFPlugInRegisterPlugInType(factoryUUID: any, typeUUID: any): boolean;

// export function CFPlugInRemoveInstanceForFactory(factoryID: any): void;

// export function CFPlugInSetLoadOnDemand(plugIn: any, flag: boolean): void;

// export function CFPlugInUnregisterFactory(factoryUUID: any): boolean;

// export function CFPlugInUnregisterPlugInType(factoryUUID: any, typeUUID: any): boolean;

// export function CFPreferencesAddSuitePreferencesToApp(applicationID: string, suiteID: string): void;

// export function CFPreferencesAppSynchronize(applicationID: string): boolean;

// export function CFPreferencesAppValueIsForced(key: string, applicationID: string): boolean;

// export function CFPreferencesCopyAppValue(key: string, applicationID: string): any;

// export function CFPreferencesCopyKeyList(applicationID: string, userName: string, hostName: string): any[];

// export function CFPreferencesCopyMultiple(keysToFetch: any[], applicationID: string, userName: string, hostName: string): Map<any, any>;

// export function CFPreferencesCopyValue(key: string, applicationID: string, userName: string, hostName: string): any;

// export function CFPreferencesGetAppBooleanValue(key: string, applicationID: string, keyExistsAndHasValidFormat: string | any): boolean;

// export function CFPreferencesGetAppIntegerValue(key: string, applicationID: string, keyExistsAndHasValidFormat: string | any): number;

// export function CFPreferencesRemoveSuitePreferencesFromApp(applicationID: string, suiteID: string): void;

// export function CFPreferencesSetAppValue(key: string, value: any, applicationID: string): void;

// export function CFPreferencesSetMultiple(keysToSet: Map<any, any>, keysToRemove: any[], applicationID: string, userName: string, hostName: string): void;

// export function CFPreferencesSetValue(key: string, value: any, applicationID: string, userName: string, hostName: string): void;

// export function CFPreferencesSynchronize(applicationID: string, userName: string, hostName: string): boolean;

// export function CFPropertyListCreateData(allocator: any, propertyList: any, format: CFPropertyList.CFPropertyListFormat, options: number, error: Error): Data;

// export function CFPropertyListCreateDeepCopy(allocator: any, propertyList: any, mutabilityOption: number): any;

// export function CFPropertyListCreateWithData(allocator: any, data: Data, options: number, format: CFPropertyList.CFPropertyListFormat, error: Error): any;

// export function CFPropertyListCreateWithStream(allocator: any, stream: InputStream, streamLength: number, options: number, format: CFPropertyList.CFPropertyListFormat, error: Error): any;

// export function CFPropertyListIsValid(plist: any, format: CFPropertyList.CFPropertyListFormat): boolean;

// export function CFPropertyListWrite(propertyList: any, stream: OutputStream, format: CFPropertyList.CFPropertyListFormat, options: number, error: Error): number;

// export function CFReadStreamClose(stream: InputStream): void;

// export function CFReadStreamCopyDispatchQueue(stream: InputStream): NSObject;

// export function CFReadStreamCopyError(stream: InputStream): Error;

// export function CFReadStreamCopyProperty(stream: InputStream, propertyName: any): any;

// export function CFReadStreamCreateWithBytesNoCopy(alloc: any, bytes: string | any, length: number, bytesDeallocator: any): InputStream;

// export function CFReadStreamCreateWithFile(alloc: any, fileURL: URL): InputStream;

// export function CFReadStreamGetBuffer(stream: InputStream, maxBytesToRead: number, numBytesRead: number): string;

// export function CFReadStreamGetError(stream: InputStream): CFStreamError;

// export function CFReadStreamGetStatus(stream: InputStream): CFStream.CFStreamStatus;

// export function CFReadStreamGetTypeID(): number;

// export function CFReadStreamHasBytesAvailable(stream: InputStream): boolean;

// export function CFReadStreamOpen(stream: InputStream): boolean;

// export function CFReadStreamRead(stream: InputStream, buffer: string | any, bufferLength: number): number;

// export function CFReadStreamScheduleWithRunLoop(stream: InputStream, runLoop: any, runLoopMode: any): void;

// export function CFReadStreamSetClient(stream: InputStream, streamEvents: number, clientCB: (p1: InputStream, p2: CFStream.CFStreamEventType, p3: any) => void, clientContext: CFStreamClientContext): boolean;

// export function CFReadStreamSetDispatchQueue(stream: InputStream, q: NSObject): void;

// export function CFReadStreamSetProperty(stream: InputStream, propertyName: any, propertyValue: any): boolean;

// export function CFReadStreamUnscheduleFromRunLoop(stream: InputStream, runLoop: any, runLoopMode: any): void;

// export function CFRelease(cf: any): void;

// export function CFRetain(cf: any): any;

// export function CFRunLoopAddCommonMode(rl: any, mode: any): void;

// export function CFRunLoopAddObserver(rl: any, observer: any, mode: any): void;

// export function CFRunLoopAddSource(rl: any, source: any, mode: any): void;

// export function CFRunLoopAddTimer(rl: any, timer: Timer, mode: any): void;

// export function CFRunLoopContainsObserver(rl: any, observer: any, mode: any): boolean;

// export function CFRunLoopContainsSource(rl: any, source: any, mode: any): boolean;

// export function CFRunLoopContainsTimer(rl: any, timer: Timer, mode: any): boolean;

// export function CFRunLoopCopyAllModes(rl: any): any[];

// export function CFRunLoopCopyCurrentMode(rl: any): any;

// export function CFRunLoopGetCurrent(): any;

// export function CFRunLoopGetMain(): any;

// export function CFRunLoopGetNextTimerFireDate(rl: any, mode: any): number;

// export function CFRunLoopGetTypeID(): number;

// export function CFRunLoopIsWaiting(rl: any): boolean;

// export function CFRunLoopObserverCreate(allocator: any, activities: number, repeats: boolean, order: number, callout: (p1: any, p2: CFRunLoop.CFRunLoopActivity, p3: any) => void, context: CFRunLoopObserverContext): any;

// export function CFRunLoopObserverCreateWithHandler(allocator: any, activities: number, repeats: boolean, order: number, block: (p1: any, p2: CFRunLoop.CFRunLoopActivity) => void): any;

// export function CFRunLoopObserverDoesRepeat(observer: any): boolean;

// export function CFRunLoopObserverGetActivities(observer: any): number;

// export function CFRunLoopObserverGetContext(observer: any, context: CFRunLoopObserverContext): void;

// export function CFRunLoopObserverGetOrder(observer: any): number;

// export function CFRunLoopObserverGetTypeID(): number;

// export function CFRunLoopObserverInvalidate(observer: any): void;

// export function CFRunLoopObserverIsValid(observer: any): boolean;

// export function CFRunLoopPerformBlock(rl: any, mode: any, block: () => void): void;

// export function CFRunLoopRemoveObserver(rl: any, observer: any, mode: any): void;

// export function CFRunLoopRemoveSource(rl: any, source: any, mode: any): void;

// export function CFRunLoopRemoveTimer(rl: any, timer: Timer, mode: any): void;

// export function CFRunLoopRun(): void;

// export function CFRunLoopRunInMode(mode: any, seconds: number, returnAfterSourceHandled: boolean): CFRunLoop.CFRunLoopRunResult;

// export function CFRunLoopSourceCreate(allocator: any, order: number, context: CFRunLoopSourceContext): any;

// export function CFRunLoopSourceGetContext(source: any, context: CFRunLoopSourceContext): void;

// export function CFRunLoopSourceGetOrder(source: any): number;

// export function CFRunLoopSourceGetTypeID(): number;

// export function CFRunLoopSourceInvalidate(source: any): void;

// export function CFRunLoopSourceIsValid(source: any): boolean;

// export function CFRunLoopSourceSignal(source: any): void;

// export function CFRunLoopStop(rl: any): void;

// export function CFRunLoopTimerCreate(allocator: any, fireDate: number, interval: number, flags: number, order: number, callout: (p1: Timer, p2: any) => void, context: CFRunLoopTimerContext): Timer;

// export function CFRunLoopTimerCreateWithHandler(allocator: any, fireDate: number, interval: number, flags: number, order: number, block: (p1: Timer) => void): Timer;

// export function CFRunLoopTimerDoesRepeat(timer: Timer): boolean;

// export function CFRunLoopTimerGetContext(timer: Timer, context: CFRunLoopTimerContext): void;

// export function CFRunLoopTimerGetInterval(timer: Timer): number;

// export function CFRunLoopTimerGetNextFireDate(timer: Timer): number;

// export function CFRunLoopTimerGetOrder(timer: Timer): number;

// export function CFRunLoopTimerGetTolerance(timer: Timer): number;

// export function CFRunLoopTimerGetTypeID(): number;

// export function CFRunLoopTimerInvalidate(timer: Timer): void;

// export function CFRunLoopTimerIsValid(timer: Timer): boolean;

// export function CFRunLoopTimerSetNextFireDate(timer: Timer, fireDate: number): void;

// export function CFRunLoopTimerSetTolerance(timer: Timer, tolerance: number): void;

// export function CFRunLoopWakeUp(rl: any): void;

// export function CFSetAddValue(theSet: Set<any>, value: any): void;

// export function CFSetApplyFunction(theSet: Set<any>, applier: (p1: any, p2: any) => void, context: any): void;

// export function CFSetContainsValue(theSet: Set<any>, value: any): boolean;

// export function CFSetCreate(allocator: any, values: any, numValues: number, callBacks: CFSetCallBacks): Set<any>;

// export function CFSetCreateCopy(allocator: any, theSet: Set<any>): Set<any>;

// export function CFSetCreateMutable(allocator: any, capacity: number, callBacks: CFSetCallBacks): Set<any>;

// export function CFSetCreateMutableCopy(allocator: any, capacity: number, theSet: Set<any>): Set<any>;

// export function CFSetGetCount(theSet: Set<any>): number;

// export function CFSetGetCountOfValue(theSet: Set<any>, value: any): number;

// export function CFSetGetTypeID(): number;

// export function CFSetGetValue(theSet: Set<any>, value: any): any;

// export function CFSetGetValueIfPresent(theSet: Set<any>, candidate: any, value: any): boolean;

// export function CFSetGetValues(theSet: Set<any>, values: any): void;

// export function CFSetRemoveAllValues(theSet: Set<any>): void;

// export function CFSetRemoveValue(theSet: Set<any>, value: any): void;

// export function CFSetReplaceValue(theSet: Set<any>, value: any): void;

// export function CFSetSetValue(theSet: Set<any>, value: any): void;

// export function CFShow(obj: any): void;

// export function CFShowStr(str: string): void;

// export function CFSocketConnectToAddress(s: any, address: Data, timeout: number): CFSocket.CFSocketError;

// export function CFSocketCopyAddress(s: any): Data;

// export function CFSocketCopyPeerAddress(s: any): Data;

// export function CFSocketCopyRegisteredSocketSignature(nameServerSignature: CFSocketSignature, timeout: number, name: string, signature: CFSocketSignature, nameServerAddress: Data): CFSocket.CFSocketError;

// export function CFSocketCopyRegisteredValue(nameServerSignature: CFSocketSignature, timeout: number, name: string, value: any, nameServerAddress: Data): CFSocket.CFSocketError;

// export function CFSocketCreate(allocator: any, protocolFamily: number, socketType: number, protocol: number, callBackTypes: number, callout: (p1: any, p2: CFSocket.CFSocketCallBackType, p3: Data, p4: any, p5: any) => void, context: CFSocketContext): any;

// export function CFSocketCreateConnectedToSocketSignature(allocator: any, signature: CFSocketSignature, callBackTypes: number, callout: (p1: any, p2: CFSocket.CFSocketCallBackType, p3: Data, p4: any, p5: any) => void, context: CFSocketContext, timeout: number): any;

// export function CFSocketCreateRunLoopSource(allocator: any, s: any, order: number): any;

// export function CFSocketCreateWithNative(allocator: any, sock: number, callBackTypes: number, callout: (p1: any, p2: CFSocket.CFSocketCallBackType, p3: Data, p4: any, p5: any) => void, context: CFSocketContext): any;

// export function CFSocketCreateWithSocketSignature(allocator: any, signature: CFSocketSignature, callBackTypes: number, callout: (p1: any, p2: CFSocket.CFSocketCallBackType, p3: Data, p4: any, p5: any) => void, context: CFSocketContext): any;

// export function CFSocketDisableCallBacks(s: any, callBackTypes: number): void;

// export function CFSocketEnableCallBacks(s: any, callBackTypes: number): void;

// export function CFSocketGetContext(s: any, context: CFSocketContext): void;

// export function CFSocketGetDefaultNameRegistryPortNumber(): number;

// export function CFSocketGetNative(s: any): number;

// export function CFSocketGetSocketFlags(s: any): number;

// export function CFSocketGetTypeID(): number;

// export function CFSocketInvalidate(s: any): void;

// export function CFSocketIsValid(s: any): boolean;

// export function CFSocketRegisterSocketSignature(nameServerSignature: CFSocketSignature, timeout: number, name: string, signature: CFSocketSignature): CFSocket.CFSocketError;

// export function CFSocketRegisterValue(nameServerSignature: CFSocketSignature, timeout: number, name: string, value: any): CFSocket.CFSocketError;

// export function CFSocketSendData(s: any, address: Data, data: Data, timeout: number): CFSocket.CFSocketError;

// export function CFSocketSetAddress(s: any, address: Data): CFSocket.CFSocketError;

// export function CFSocketSetDefaultNameRegistryPortNumber(port: number): void;

// export function CFSocketSetSocketFlags(s: any, flags: number): void;

// export function CFSocketUnregister(nameServerSignature: CFSocketSignature, timeout: number, name: string): CFSocket.CFSocketError;

// export function CFStreamCreateBoundPair(alloc: any, readStream: InputStream, writeStream: OutputStream, transferBufferSize: number): void;

// export function CFStreamCreatePairWithPeerSocketSignature(alloc: any, signature: CFSocketSignature, readStream: InputStream, writeStream: OutputStream): void;

// export function CFStreamCreatePairWithSocket(alloc: any, sock: number, readStream: InputStream, writeStream: OutputStream): void;

// export function CFStreamCreatePairWithSocketToHost(alloc: any, host: string, port: number, readStream: InputStream, writeStream: OutputStream): void;

// export function CFStringAppend(theString: string, appendedString: string): void;

// export function CFStringAppendCString(theString: string, cStr: string | any, encoding: number): void;

// export function CFStringAppendCharacters(theString: string, chars: number, numChars: number): void;

// export function CFStringAppendPascalString(theString: string, pStr: string | any, encoding: number): void;

// export function CFStringCapitalize(theString: string, locale: Locale): void;

// export function CFStringCompare(theString1: string, theString2: string, compareOptions: CFString.CFStringCompareFlags): CFBase.CFComparisonResult;

// export function CFStringCompareWithOptions(theString1: string, theString2: string, rangeToCompare: CFRange, compareOptions: CFString.CFStringCompareFlags): CFBase.CFComparisonResult;

// export function CFStringCompareWithOptionsAndLocale(theString1: string, theString2: string, rangeToCompare: CFRange, compareOptions: CFString.CFStringCompareFlags, locale: Locale): CFBase.CFComparisonResult;

// export function CFStringConvertEncodingToIANACharSetName(encoding: number): string;

// export function CFStringConvertEncodingToNSStringEncoding(encoding: number): number;

// export function CFStringConvertEncodingToWindowsCodepage(encoding: number): number;

// export function CFStringConvertIANACharSetNameToEncoding(theString: string): number;

// export function CFStringConvertNSStringEncodingToEncoding(encoding: number): number;

// export function CFStringConvertWindowsCodepageToEncoding(codepage: number): number;

// export function CFStringCreateArrayBySeparatingStrings(alloc: any, theString: string, separatorString: string): any[];

// export function CFStringCreateArrayWithFindResults(alloc: any, theString: string, stringToFind: string, rangeToSearch: CFRange, compareOptions: CFString.CFStringCompareFlags): any[];

// export function CFStringCreateByCombiningStrings(alloc: any, theArray: any[], separatorString: string): string;

// export function CFStringCreateCopy(alloc: any, theString: string): string;

// export function CFStringCreateExternalRepresentation(alloc: any, theString: string, encoding: number, lossByte: number): Data;

// export function CFStringCreateFromExternalRepresentation(alloc: any, data: Data, encoding: number): string;

// export function CFStringCreateMutable(alloc: any, maxLength: number): string;

// export function CFStringCreateMutableCopy(alloc: any, maxLength: number, theString: string): string;

// export function CFStringCreateMutableWithExternalCharactersNoCopy(alloc: any, chars: number, numChars: number, capacity: number, externalCharactersAllocator: any): string;

// export function CFStringCreateWithBytes(alloc: any, bytes: string | any, numBytes: number, encoding: number, isExternalRepresentation: boolean): string;

// export function CFStringCreateWithBytesNoCopy(alloc: any, bytes: string | any, numBytes: number, encoding: number, isExternalRepresentation: boolean, contentsDeallocator: any): string;

// export function CFStringCreateWithCString(alloc: any, cStr: string | any, encoding: number): string;

// export function CFStringCreateWithCStringNoCopy(alloc: any, cStr: string | any, encoding: number, contentsDeallocator: any): string;

// export function CFStringCreateWithCharacters(alloc: any, chars: number, numChars: number): string;

// export function CFStringCreateWithCharactersNoCopy(alloc: any, chars: number, numChars: number, contentsDeallocator: any): string;

// export function CFStringCreateWithFileSystemRepresentation(alloc: any, buffer: string | any): string;

// export function CFStringCreateWithPascalString(alloc: any, pStr: string | any, encoding: number): string;

// export function CFStringCreateWithPascalStringNoCopy(alloc: any, pStr: string | any, encoding: number, contentsDeallocator: any): string;

// export function CFStringCreateWithSubstring(alloc: any, str: string, range: CFRange): string;

// export function CFStringDelete(theString: string, range: CFRange): void;

// export function CFStringFind(theString: string, stringToFind: string, compareOptions: CFString.CFStringCompareFlags): CFRange;

// export function CFStringFindAndReplace(theString: string, stringToFind: string, replacementString: string, rangeToSearch: CFRange, compareOptions: CFString.CFStringCompareFlags): number;

// export function CFStringFindCharacterFromSet(theString: string, theSet: CharacterSet, rangeToSearch: CFRange, searchOptions: CFString.CFStringCompareFlags, result: CFRange): boolean;

// export function CFStringFindWithOptions(theString: string, stringToFind: string, rangeToSearch: CFRange, searchOptions: CFString.CFStringCompareFlags, result: CFRange): boolean;

// export function CFStringFindWithOptionsAndLocale(theString: string, stringToFind: string, rangeToSearch: CFRange, searchOptions: CFString.CFStringCompareFlags, locale: Locale, result: CFRange): boolean;

// export function CFStringFold(theString: string, theFlags: CFString.CFStringCompareFlags, theLocale: Locale): void;

// export function CFStringGetBytes(theString: string, range: CFRange, encoding: number, lossByte: number, isExternalRepresentation: boolean, buffer: string | any, maxBufLen: number, usedBufLen: number): number;

// export function CFStringGetCString(theString: string, buffer: string | any, bufferSize: number, encoding: number): boolean;

// export function CFStringGetCStringPtr(theString: string, encoding: number): string;

// export function CFStringGetCharacterAtIndex(theString: string, idx: number): number;

// export function CFStringGetCharacters(theString: string, range: CFRange, buffer: number): void;

// export function CFStringGetCharactersPtr(theString: string): number;

// export function CFStringGetDoubleValue(str: string): number;

// export function CFStringGetFastestEncoding(theString: string): number;

// export function CFStringGetFileSystemRepresentation(string: string, buffer: string | any, maxBufLen: number): boolean;

// export function CFStringGetHyphenationLocationBeforeIndex(string: string, location: number, limitRange: CFRange, options: number, locale: Locale, character: number): number;

// export function CFStringGetIntValue(str: string): number;

// export function CFStringGetLength(theString: string): number;

// export function CFStringGetLineBounds(theString: string, range: CFRange, lineBeginIndex: number, lineEndIndex: number, contentsEndIndex: number): void;

// export function CFStringGetListOfAvailableEncodings(): number;

// export function CFStringGetMaximumSizeForEncoding(length: number, encoding: number): number;

// export function CFStringGetMaximumSizeOfFileSystemRepresentation(string: string): number;

// export function CFStringGetMostCompatibleMacStringEncoding(encoding: number): number;

// export function CFStringGetNameOfEncoding(encoding: number): string;

// export function CFStringGetParagraphBounds(string: string, range: CFRange, parBeginIndex: number, parEndIndex: number, contentsEndIndex: number): void;

// export function CFStringGetPascalString(theString: string, buffer: string | any, bufferSize: number, encoding: number): boolean;

// export function CFStringGetPascalStringPtr(theString: string, encoding: number): string;

// export function CFStringGetRangeOfComposedCharactersAtIndex(theString: string, theIndex: number): CFRange;

// export function CFStringGetSmallestEncoding(theString: string): number;

// export function CFStringGetSystemEncoding(): number;

// export function CFStringGetTypeID(): number;

// export function CFStringHasPrefix(theString: string, prefix: string): boolean;

// export function CFStringHasSuffix(theString: string, suffix: string): boolean;

// export function CFStringInsert(str: string, idx: number, insertedStr: string): void;

// export function CFStringIsEncodingAvailable(encoding: number): boolean;

// export function CFStringIsHyphenationAvailableForLocale(locale: Locale): boolean;

// export function CFStringLowercase(theString: string, locale: Locale): void;

// export function CFStringNormalize(theString: string, theForm: CFString.CFStringNormalizationForm): void;

// export function CFStringPad(theString: string, padString: string, length: number, indexIntoPad: number): void;

// export function CFStringReplace(theString: string, range: CFRange, replacement: string): void;

// export function CFStringReplaceAll(theString: string, replacement: string): void;

// export function CFStringSetExternalCharactersNoCopy(theString: string, chars: number, length: number, capacity: number): void;

// export function CFStringTokenizerAdvanceToNextToken(tokenizer: any): CFStringTokenizer.CFStringTokenizerTokenType;

// export function CFStringTokenizerCopyBestStringLanguage(string: string, range: CFRange): string;

// export function CFStringTokenizerCopyCurrentTokenAttribute(tokenizer: any, attribute: number): any;

// export function CFStringTokenizerCreate(alloc: any, string: string, range: CFRange, options: number, locale: Locale): any;

// export function CFStringTokenizerGetCurrentSubTokens(tokenizer: any, ranges: CFRange, maxRangeLength: number, derivedSubTokens: any[]): number;

// export function CFStringTokenizerGetCurrentTokenRange(tokenizer: any): CFRange;

// export function CFStringTokenizerGetTypeID(): number;

// export function CFStringTokenizerGoToTokenAtIndex(tokenizer: any, index: number): CFStringTokenizer.CFStringTokenizerTokenType;

// export function CFStringTokenizerSetString(tokenizer: any, string: string, range: CFRange): void;

// export function CFStringTransform(string: string, range: CFRange, transform: string, reverse: boolean): boolean;

// export function CFStringTrim(theString: string, trimString: string): void;

// export function CFStringTrimWhitespace(theString: string): void;

// export function CFStringUppercase(theString: string, locale: Locale): void;

// export function CFTimeZoneCopyAbbreviation(tz: TimeZone, at: number): string;

// export function CFTimeZoneCopyAbbreviationDictionary(): Map<any, any>;

// export function CFTimeZoneCopyDefault(): TimeZone;

// export function CFTimeZoneCopyKnownNames(): any[];

// export function CFTimeZoneCopyLocalizedName(tz: TimeZone, style: CFTimeZone.CFTimeZoneNameStyle, locale: Locale): string;

// export function CFTimeZoneCopySystem(): TimeZone;

// export function CFTimeZoneCreate(allocator: any, name: string, data: Data): TimeZone;

// export function CFTimeZoneCreateWithName(allocator: any, name: string, tryAbbrev: boolean): TimeZone;

// export function CFTimeZoneCreateWithTimeIntervalFromGMT(allocator: any, ti: number): TimeZone;

// export function CFTimeZoneGetData(tz: TimeZone): Data;

// export function CFTimeZoneGetDaylightSavingTimeOffset(tz: TimeZone, at: number): number;

// export function CFTimeZoneGetName(tz: TimeZone): string;

// export function CFTimeZoneGetNextDaylightSavingTimeTransition(tz: TimeZone, at: number): number;

// export function CFTimeZoneGetSecondsFromGMT(tz: TimeZone, at: number): number;

// export function CFTimeZoneGetTypeID(): number;

// export function CFTimeZoneIsDaylightSavingTime(tz: TimeZone, at: number): boolean;

// export function CFTimeZoneResetSystem(): void;

// export function CFTimeZoneSetAbbreviationDictionary(dict: Map<any, any>): void;

// export function CFTimeZoneSetDefault(tz: TimeZone): void;

// export function CFTreeAppendChild(tree: any, newChild: any): void;

// export function CFTreeApplyFunctionToChildren(tree: any, applier: (p1: any, p2: any) => void, context: any): void;

// export function CFTreeCreate(allocator: any, context: CFTreeContext): any;

// export function CFTreeFindRoot(tree: any): any;

// export function CFTreeGetChildAtIndex(tree: any, idx: number): any;

// export function CFTreeGetChildCount(tree: any): number;

// export function CFTreeGetChildren(tree: any, children: any): void;

// export function CFTreeGetContext(tree: any, context: CFTreeContext): void;

// export function CFTreeGetFirstChild(tree: any): any;

// export function CFTreeGetNextSibling(tree: any): any;

// export function CFTreeGetParent(tree: any): any;

// export function CFTreeGetTypeID(): number;

// export function CFTreeInsertSibling(tree: any, newSibling: any): void;

// export function CFTreePrependChild(tree: any, newChild: any): void;

// export function CFTreeRemove(tree: any): void;

// export function CFTreeRemoveAllChildren(tree: any): void;

// export function CFTreeSetContext(tree: any, context: CFTreeContext): void;

// export function CFTreeSortChildren(tree: any, comparator: (p1: any, p2: any, p3: any) => CFBase.CFComparisonResult, context: any): void;

// export function CFURLCanBeDecomposed(anURL: URL): boolean;

// export function CFURLClearResourcePropertyCache(url: URL): void;

// export function CFURLClearResourcePropertyCacheForKey(url: URL, key: string): void;

// export function CFURLCopyAbsoluteURL(relativeURL: URL): URL;

// export function CFURLCopyFileSystemPath(anURL: URL, pathStyle: CFURL.CFURLPathStyle): string;

// export function CFURLCopyFragment(anURL: URL, charactersToLeaveEscaped: string): string;

// export function CFURLCopyHostName(anURL: URL): string;

// export function CFURLCopyLastPathComponent(url: URL): string;

// export function CFURLCopyNetLocation(anURL: URL): string;

// export function CFURLCopyPassword(anURL: URL): string;

// export function CFURLCopyPath(anURL: URL): string;

// export function CFURLCopyPathExtension(url: URL): string;

// export function CFURLCopyQueryString(anURL: URL, charactersToLeaveEscaped: string): string;

// export function CFURLCopyResourcePropertiesForKeys(url: URL, keys: any[], error: Error): Map<any, any>;

// export function CFURLCopyResourcePropertyForKey(url: URL, key: string, propertyValueTypeRefPtr: any, error: Error): boolean;

// export function CFURLCopyResourceSpecifier(anURL: URL): string;

// export function CFURLCopyScheme(anURL: URL): string;

// export function CFURLCopyStrictPath(anURL: URL, isAbsolute: string | any): string;

// export function CFURLCopyUserName(anURL: URL): string;

// export function CFURLCreateAbsoluteURLWithBytes(alloc: any, relativeURLBytes: string | any, length: number, encoding: number, baseURL: URL, useCompatibilityMode: boolean): URL;

// export function CFURLCreateBookmarkData(allocator: any, url: URL, options: CFURL.CFURLBookmarkCreationOptions, resourcePropertiesToInclude: any[], relativeToURL: URL, error: Error): Data;

// export function CFURLCreateBookmarkDataFromAliasRecord(allocatorRef: any, aliasRecordDataRef: Data): Data;

// export function CFURLCreateBookmarkDataFromFile(allocator: any, fileURL: URL, errorRef: Error): Data;

// export function CFURLCreateByResolvingBookmarkData(allocator: any, bookmark: Data, options: CFURL.CFURLBookmarkResolutionOptions, relativeToURL: URL, resourcePropertiesToInclude: any[], isStale: string | any, error: Error): URL;

// export function CFURLCreateCopyAppendingPathComponent(allocator: any, url: URL, pathComponent: string, isDirectory: boolean): URL;

// export function CFURLCreateCopyAppendingPathExtension(allocator: any, url: URL, extension: string): URL;

// export function CFURLCreateCopyDeletingLastPathComponent(allocator: any, url: URL): URL;

// export function CFURLCreateCopyDeletingPathExtension(allocator: any, url: URL): URL;

// export function CFURLCreateData(allocator: any, url: URL, encoding: number, escapeWhitespace: boolean): Data;

// export function CFURLCreateFilePathURL(allocator: any, url: URL, error: Error): URL;

// export function CFURLCreateFileReferenceURL(allocator: any, url: URL, error: Error): URL;

// export function CFURLCreateFromFileSystemRepresentation(allocator: any, buffer: string | any, bufLen: number, isDirectory: boolean): URL;

// export function CFURLCreateFromFileSystemRepresentationRelativeToBase(allocator: any, buffer: string | any, bufLen: number, isDirectory: boolean, baseURL: URL): URL;

// export function CFURLCreateResourcePropertiesForKeysFromBookmarkData(allocator: any, resourcePropertiesToReturn: any[], bookmark: Data): Map<any, any>;

// export function CFURLCreateResourcePropertyForKeyFromBookmarkData(allocator: any, resourcePropertyKey: string, bookmark: Data): any;

// export function CFURLCreateStringByReplacingPercentEscapes(allocator: any, originalString: string, charactersToLeaveEscaped: string): string;

// export function CFURLCreateWithBytes(allocator: any, URLBytes: string | any, length: number, encoding: number, baseURL: URL): URL;

// export function CFURLCreateWithFileSystemPath(allocator: any, filePath: string, pathStyle: CFURL.CFURLPathStyle, isDirectory: boolean): URL;

// export function CFURLCreateWithFileSystemPathRelativeToBase(allocator: any, filePath: string, pathStyle: CFURL.CFURLPathStyle, isDirectory: boolean, baseURL: URL): URL;

// export function CFURLCreateWithString(allocator: any, URLString: string, baseURL: URL): URL;

// export function CFURLEnumeratorCreateForDirectoryURL(alloc: any, directoryURL: URL, option: CFURLEnumerator.CFURLEnumeratorOptions, propertyKeys: any[]): any;

// export function CFURLEnumeratorCreateForMountedVolumes(alloc: any, option: CFURLEnumerator.CFURLEnumeratorOptions, propertyKeys: any[]): any;

// export function CFURLEnumeratorGetDescendentLevel(enumerator: any): number;

// export function CFURLEnumeratorGetNextURL(enumerator: any, url: URL, error: Error): CFURLEnumerator.CFURLEnumeratorResult;

// export function CFURLEnumeratorGetTypeID(): number;

// export function CFURLEnumeratorSkipDescendents(enumerator: any): void;

// export function CFURLGetBaseURL(anURL: URL): URL;

// export function CFURLGetByteRangeForComponent(url: URL, component: CFURL.CFURLComponentType, rangeIncludingSeparators: CFRange): CFRange;

// export function CFURLGetBytes(url: URL, buffer: string | any, bufferLength: number): number;

// export function CFURLGetFileSystemRepresentation(url: URL, resolveAgainstBase: boolean, buffer: string | any, maxBufLen: number): boolean;

// export function CFURLGetPortNumber(anURL: URL): number;

// export function CFURLGetString(anURL: URL): string;

// export function CFURLGetTypeID(): number;

// export function CFURLHasDirectoryPath(anURL: URL): boolean;

// export function CFURLIsFileReferenceURL(url: URL): boolean;

// export function CFURLResourceIsReachable(url: URL, error: Error): boolean;

// export function CFURLSetResourcePropertiesForKeys(url: URL, keyedPropertyValues: Map<any, any>, error: Error): boolean;

// export function CFURLSetResourcePropertyForKey(url: URL, key: string, propertyValue: any, error: Error): boolean;

// export function CFURLSetTemporaryResourcePropertyForKey(url: URL, key: string, propertyValue: any): void;

// export function CFURLStartAccessingSecurityScopedResource(url: URL): boolean;

// export function CFURLStopAccessingSecurityScopedResource(url: URL): void;

// export function CFURLWriteBookmarkDataToFile(bookmarkRef: Data, fileURL: URL, options: number, errorRef: Error): boolean;

// export function CFUUIDCreate(alloc: any): any;

// export function CFUUIDCreateFromString(alloc: any, uuidStr: string): any;

// export function CFUUIDCreateFromUUIDBytes(alloc: any, bytes: CFUUIDBytes): any;

// export function CFUUIDCreateString(alloc: any, uuid: any): string;

// export function CFUUIDCreateWithBytes(alloc: any, byte0: number, byte1: number, byte2: number, byte3: number, byte4: number, byte5: number, byte6: number, byte7: number, byte8: number, byte9: number, byte10: number, byte11: number, byte12: number, byte13: number, byte14: number, byte15: number): any;

// export function CFUUIDGetConstantUUIDWithBytes(alloc: any, byte0: number, byte1: number, byte2: number, byte3: number, byte4: number, byte5: number, byte6: number, byte7: number, byte8: number, byte9: number, byte10: number, byte11: number, byte12: number, byte13: number, byte14: number, byte15: number): any;

// export function CFUUIDGetTypeID(): number;

// export function CFUUIDGetUUIDBytes(uuid: any): CFUUIDBytes;

// export function CFUserNotificationCancel(userNotification: any): number;

// export function CFUserNotificationCreate(allocator: any, timeout: number, flags: number, error: number, dictionary: Map<any, any>): any;

// export function CFUserNotificationCreateRunLoopSource(allocator: any, userNotification: any, callout: (p1: any, p2: number) => void, order: number): any;

// export function CFUserNotificationDisplayAlert(timeout: number, flags: number, iconURL: URL, soundURL: URL, localizationURL: URL, alertHeader: string, alertMessage: string, defaultButtonTitle: string, alternateButtonTitle: string, otherButtonTitle: string, responseFlags: number): number;

// export function CFUserNotificationDisplayNotice(timeout: number, flags: number, iconURL: URL, soundURL: URL, localizationURL: URL, alertHeader: string, alertMessage: string, defaultButtonTitle: string): number;

// export function CFUserNotificationGetResponseDictionary(userNotification: any): Map<any, any>;

// export function CFUserNotificationGetResponseValue(userNotification: any, key: string, idx: number): string;

// export function CFUserNotificationGetTypeID(): number;

// export function CFUserNotificationReceiveResponse(userNotification: any, timeout: number, responseFlags: number): number;

// export function CFUserNotificationUpdate(userNotification: any, timeout: number, flags: number, dictionary: Map<any, any>): number;

// export function CFWriteStreamCanAcceptBytes(stream: OutputStream): boolean;

// export function CFWriteStreamClose(stream: OutputStream): void;

// export function CFWriteStreamCopyDispatchQueue(stream: OutputStream): NSObject;

// export function CFWriteStreamCopyError(stream: OutputStream): Error;

// export function CFWriteStreamCopyProperty(stream: OutputStream, propertyName: any): any;

// export function CFWriteStreamCreateWithAllocatedBuffers(alloc: any, bufferAllocator: any): OutputStream;

// export function CFWriteStreamCreateWithBuffer(alloc: any, buffer: string | any, bufferCapacity: number): OutputStream;

// export function CFWriteStreamCreateWithFile(alloc: any, fileURL: URL): OutputStream;

// export function CFWriteStreamGetError(stream: OutputStream): CFStreamError;

// export function CFWriteStreamGetStatus(stream: OutputStream): CFStream.CFStreamStatus;

// export function CFWriteStreamGetTypeID(): number;

// export function CFWriteStreamOpen(stream: OutputStream): boolean;

// export function CFWriteStreamScheduleWithRunLoop(stream: OutputStream, runLoop: any, runLoopMode: any): void;

// export function CFWriteStreamSetClient(stream: OutputStream, streamEvents: number, clientCB: (p1: OutputStream, p2: CFStream.CFStreamEventType, p3: any) => void, clientContext: CFStreamClientContext): boolean;

// export function CFWriteStreamSetDispatchQueue(stream: OutputStream, q: NSObject): void;

// export function CFWriteStreamSetProperty(stream: OutputStream, propertyName: any, propertyValue: any): boolean;

// export function CFWriteStreamUnscheduleFromRunLoop(stream: OutputStream, runLoop: any, runLoopMode: any): void;

// export function CFWriteStreamWrite(stream: OutputStream, buffer: string | any, bufferLength: number): number;

// export function CFXMLCreateStringByEscapingEntities(allocator: any, string: string, entitiesDictionary: Map<any, any>): string;

// export function CFXMLCreateStringByUnescapingEntities(allocator: any, string: string, entitiesDictionary: Map<any, any>): string;

// export function __CFRangeMake(loc: number, len: number): CFRange;

// export function __CFStringMakeConstantString(cStr: string | any): string;

// export function CGAcquireDisplayFadeReservation(seconds: number, token: number): CGError.CGError;

// export function CGAffineTransformConcat(t1: CGAffineTransform, t2: CGAffineTransform): CGAffineTransform;

// export function CGAffineTransformEqualToTransform(t1: CGAffineTransform, t2: CGAffineTransform): boolean;

// export function CGAffineTransformInvert(t: CGAffineTransform): CGAffineTransform;

// export function CGAffineTransformIsIdentity(t: CGAffineTransform): boolean;

// export function CGAffineTransformMake(a: number, b: number, c: number, d: number, tx: number, ty: number): CGAffineTransform;

// export function CGAffineTransformMakeRotation(angle: number): CGAffineTransform;

// export function CGAffineTransformMakeScale(sx: number, sy: number): CGAffineTransform;

// export function CGAffineTransformMakeTranslation(tx: number, ty: number): CGAffineTransform;

// export function CGAffineTransformRotate(t: CGAffineTransform, angle: number): CGAffineTransform;

// export function CGAffineTransformScale(t: CGAffineTransform, sx: number, sy: number): CGAffineTransform;

// export function CGAffineTransformTranslate(t: CGAffineTransform, tx: number, ty: number): CGAffineTransform;

// export function CGAssociateMouseAndMouseCursorPosition(connected: number): CGError.CGError;

// export function CGBeginDisplayConfiguration(config: any): CGError.CGError;

// export function CGBitmapContextCreate(data: any, width: number, height: number, bitsPerComponent: number, bytesPerRow: number, space: any, bitmapInfo: number): any;

// export function CGBitmapContextCreateImage(context: any): any;

// export function CGBitmapContextCreateWithData(data: any, width: number, height: number, bitsPerComponent: number, bytesPerRow: number, space: any, bitmapInfo: number, releaseCallback: (p1: any, p2: any) => void, releaseInfo: any): any;

// export function CGBitmapContextGetAlphaInfo(context: any): CGImage.CGImageAlphaInfo;

// export function CGBitmapContextGetBitmapInfo(context: any): CGImage.CGBitmapInfo;

// export function CGBitmapContextGetBitsPerComponent(context: any): number;

// export function CGBitmapContextGetBitsPerPixel(context: any): number;

// export function CGBitmapContextGetBytesPerRow(context: any): number;

// export function CGBitmapContextGetColorSpace(context: any): any;

// export function CGBitmapContextGetData(context: any): any;

// export function CGBitmapContextGetHeight(context: any): number;

// export function CGBitmapContextGetWidth(context: any): number;

// export function CGCancelDisplayConfiguration(config: any): CGError.CGError;

// export function CGCaptureAllDisplays(): CGError.CGError;

// export function CGCaptureAllDisplaysWithOptions(options: CGDirectDisplay.CGCaptureOptions): CGError.CGError;

// export function CGColorConversionInfoCreate(src: any, dst: any): any;

// export function CGColorConversionInfoCreateWithOptions(src: any, dst: any, options: Map<any, any>): any;

// export function CGColorCreate(space: any, components: number): any;

// export function CGColorCreateCopy(color: any): any;

// export function CGColorCreateCopyByMatchingToColorSpace(p1: any, intent: CGColorSpace.CGColorRenderingIntent, color: any, options: Map<any, any>): any;

// export function CGColorCreateCopyWithAlpha(color: any, alpha: number): any;

// export function CGColorCreateGenericCMYK(cyan: number, magenta: number, yellow: number, black: number, alpha: number): any;

// export function CGColorCreateGenericGray(gray: number, alpha: number): any;

// export function CGColorCreateGenericGrayGamma2_2(gray: number, alpha: number): any;

// export function CGColorCreateGenericRGB(red: number, green: number, blue: number, alpha: number): any;

// export function CGColorCreateSRGB(red: number, green: number, blue: number, alpha: number): any;

// export function CGColorCreateWithPattern(space: any, pattern: any, components: number): any;

// export function CGColorEqualToColor(color1: any, color2: any): boolean;

// export function CGColorGetAlpha(color: any): number;

// export function CGColorGetColorSpace(color: any): any;

// export function CGColorGetComponents(color: any): number;

// export function CGColorGetConstantColor(colorName: string): any;

// export function CGColorGetNumberOfComponents(color: any): number;

// export function CGColorGetPattern(color: any): any;

// export function CGColorRelease(color: any): void;

// export function CGColorRetain(color: any): any;

// export function CGColorSpaceCopyICCData(space: any): Data;

// export function CGColorSpaceCopyName(space: any): string;

// export function CGColorSpaceCopyPropertyList(space: any): any;

// export function CGColorSpaceCreateCalibratedGray(whitePoint: number, blackPoint: number, gamma: number): any;

// export function CGColorSpaceCreateCalibratedRGB(whitePoint: number, blackPoint: number, gamma: number, matrix: number): any;

// export function CGColorSpaceCreateDeviceCMYK(): any;

// export function CGColorSpaceCreateDeviceGray(): any;

// export function CGColorSpaceCreateDeviceRGB(): any;

// export function CGColorSpaceCreateICCBased(nComponents: number, range: number, profile: any, alternate: any): any;

// export function CGColorSpaceCreateIndexed(baseSpace: any, lastIndex: number, colorTable: string | any): any;

// export function CGColorSpaceCreateLab(whitePoint: number, blackPoint: number, range: number): any;

// export function CGColorSpaceCreatePattern(baseSpace: any): any;

// export function CGColorSpaceCreateWithICCData(data: any): any;

// export function CGColorSpaceCreateWithName(name: string): any;

// export function CGColorSpaceCreateWithPlatformColorSpace(ref: any): any;

// export function CGColorSpaceCreateWithPropertyList(plist: any): any;

// export function CGColorSpaceGetBaseColorSpace(space: any): any;

// export function CGColorSpaceGetColorTable(space: any, table: string | any): void;

// export function CGColorSpaceGetColorTableCount(space: any): number;

// export function CGColorSpaceGetModel(space: any): CGColorSpace.CGColorSpaceModel;

// export function CGColorSpaceGetName(space: any): string;

// export function CGColorSpaceGetNumberOfComponents(space: any): number;

// export function CGColorSpaceIsWideGamutRGB(p1: any): boolean;

// export function CGColorSpaceRelease(space: any): void;

// export function CGColorSpaceRetain(space: any): any;

// export function CGColorSpaceSupportsOutput(space: any): boolean;

// export function CGCompleteDisplayConfiguration(config: any, option: CGDisplayConfiguration.CGConfigureOption): CGError.CGError;

// export function CGConfigureDisplayFadeEffect(config: any, fadeOutSeconds: number, fadeInSeconds: number, fadeRed: number, fadeGreen: number, fadeBlue: number): CGError.CGError;

// export function CGConfigureDisplayMirrorOfDisplay(config: any, display: number, master: number): CGError.CGError;

// export function CGConfigureDisplayOrigin(config: any, display: number, x: number, y: number): CGError.CGError;

// export function CGConfigureDisplayStereoOperation(config: any, display: number, stereo: number, forceBlueLine: number): CGError.CGError;

// export function CGConfigureDisplayWithDisplayMode(config: any, display: number, mode: any, options: Map<any, any>): CGError.CGError;

// export function CGContextAddArc(c: any, x: number, y: number, radius: number, startAngle: number, endAngle: number, clockwise: number): void;

// export function CGContextAddArcToPoint(c: any, x1: number, y1: number, x2: number, y2: number, radius: number): void;

// export function CGContextAddCurveToPoint(c: any, cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number): void;

// export function CGContextAddEllipseInRect(c: any, rect: CGRect): void;

// export function CGContextAddLineToPoint(c: any, x: number, y: number): void;

// export function CGContextAddLines(c: any, points: CGPoint, count: number): void;

// export function CGContextAddPath(c: any, path: any): void;

// export function CGContextAddQuadCurveToPoint(c: any, cpx: number, cpy: number, x: number, y: number): void;

// export function CGContextAddRect(c: any, rect: CGRect): void;

// export function CGContextAddRects(c: any, rects: CGRect, count: number): void;

// export function CGContextBeginPage(c: any, mediaBox: CGRect): void;

// export function CGContextBeginPath(c: any): void;

// export function CGContextBeginTransparencyLayer(c: any, auxiliaryInfo: Map<any, any>): void;

// export function CGContextBeginTransparencyLayerWithRect(c: any, rect: CGRect, auxInfo: Map<any, any>): void;

// export function CGContextClearRect(c: any, rect: CGRect): void;

// export function CGContextClip(c: any): void;

// export function CGContextClipToMask(c: any, rect: CGRect, mask: any): void;

// export function CGContextClipToRect(c: any, rect: CGRect): void;

// export function CGContextClipToRects(c: any, rects: CGRect, count: number): void;

// export function CGContextClosePath(c: any): void;

// export function CGContextConcatCTM(c: any, transform: CGAffineTransform): void;

// export function CGContextConvertPointToDeviceSpace(c: any, point: CGPoint): CGPoint;

// export function CGContextConvertPointToUserSpace(c: any, point: CGPoint): CGPoint;

// export function CGContextConvertRectToDeviceSpace(c: any, rect: CGRect): CGRect;

// export function CGContextConvertRectToUserSpace(c: any, rect: CGRect): CGRect;

// export function CGContextConvertSizeToDeviceSpace(c: any, size: CGSize): CGSize;

// export function CGContextConvertSizeToUserSpace(c: any, size: CGSize): CGSize;

// export function CGContextCopyPath(c: any): any;

// export function CGContextDrawImage(c: any, rect: CGRect, image: any): void;

// export function CGContextDrawLayerAtPoint(context: any, point: CGPoint, layer: any): void;

// export function CGContextDrawLayerInRect(context: any, rect: CGRect, layer: any): void;

// export function CGContextDrawLinearGradient(c: any, gradient: any, startPoint: CGPoint, endPoint: CGPoint, options: CGGradient.CGGradientDrawingOptions): void;

// export function CGContextDrawPDFPage(c: any, page: any): void;

// export function CGContextDrawPath(c: any, mode: CGContext.CGPathDrawingMode): void;

// export function CGContextDrawRadialGradient(c: any, gradient: any, startCenter: CGPoint, startRadius: number, endCenter: CGPoint, endRadius: number, options: CGGradient.CGGradientDrawingOptions): void;

// export function CGContextDrawShading(c: any, shading: any): void;

// export function CGContextDrawTiledImage(c: any, rect: CGRect, image: any): void;

// export function CGContextEOClip(c: any): void;

// export function CGContextEOFillPath(c: any): void;

// export function CGContextEndPage(c: any): void;

// export function CGContextEndTransparencyLayer(c: any): void;

// export function CGContextFillEllipseInRect(c: any, rect: CGRect): void;

// export function CGContextFillPath(c: any): void;

// export function CGContextFillRect(c: any, rect: CGRect): void;

// export function CGContextFillRects(c: any, rects: CGRect, count: number): void;

// export function CGContextFlush(c: any): void;

// export function CGContextGetCTM(c: any): CGAffineTransform;

// export function CGContextGetClipBoundingBox(c: any): CGRect;

// export function CGContextGetInterpolationQuality(c: any): CGContext.CGInterpolationQuality;

// export function CGContextGetPathBoundingBox(c: any): CGRect;

// export function CGContextGetPathCurrentPoint(c: any): CGPoint;

// export function CGContextGetTextMatrix(c: any): CGAffineTransform;

// export function CGContextGetTextPosition(c: any): CGPoint;

// export function CGContextGetUserSpaceToDeviceSpaceTransform(c: any): CGAffineTransform;

// export function CGContextIsPathEmpty(c: any): boolean;

// export function CGContextMoveToPoint(c: any, x: number, y: number): void;

// export function CGContextPathContainsPoint(c: any, point: CGPoint, mode: CGContext.CGPathDrawingMode): boolean;

// export function CGContextRelease(c: any): void;

// export function CGContextReplacePathWithStrokedPath(c: any): void;

// export function CGContextResetClip(c: any): void;

// export function CGContextRestoreGState(c: any): void;

// export function CGContextRetain(c: any): any;

// export function CGContextRotateCTM(c: any, angle: number): void;

// export function CGContextSaveGState(c: any): void;

// export function CGContextScaleCTM(c: any, sx: number, sy: number): void;

// export function CGContextSetAllowsAntialiasing(c: any, allowsAntialiasing: boolean): void;

// export function CGContextSetAllowsFontSmoothing(c: any, allowsFontSmoothing: boolean): void;

// export function CGContextSetAllowsFontSubpixelPositioning(c: any, allowsFontSubpixelPositioning: boolean): void;

// export function CGContextSetAllowsFontSubpixelQuantization(c: any, allowsFontSubpixelQuantization: boolean): void;

// export function CGContextSetAlpha(c: any, alpha: number): void;

// export function CGContextSetBlendMode(c: any, mode: CGContext.CGBlendMode): void;

// export function CGContextSetCMYKFillColor(c: any, cyan: number, magenta: number, yellow: number, black: number, alpha: number): void;

// export function CGContextSetCMYKStrokeColor(c: any, cyan: number, magenta: number, yellow: number, black: number, alpha: number): void;

// export function CGContextSetCharacterSpacing(c: any, spacing: number): void;

// export function CGContextSetFillColor(c: any, components: number): void;

// export function CGContextSetFillColorSpace(c: any, space: any): void;

// export function CGContextSetFillColorWithColor(c: any, color: any): void;

// export function CGContextSetFillPattern(c: any, pattern: any, components: number): void;

// export function CGContextSetFlatness(c: any, flatness: number): void;

// export function CGContextSetFont(c: any, font: any): void;

// export function CGContextSetFontSize(c: any, size: number): void;

// export function CGContextSetGrayFillColor(c: any, gray: number, alpha: number): void;

// export function CGContextSetGrayStrokeColor(c: any, gray: number, alpha: number): void;

// export function CGContextSetInterpolationQuality(c: any, quality: CGContext.CGInterpolationQuality): void;

// export function CGContextSetLineCap(c: any, cap: CGPath.CGLineCap): void;

// export function CGContextSetLineDash(c: any, phase: number, lengths: number, count: number): void;

// export function CGContextSetLineJoin(c: any, join: CGPath.CGLineJoin): void;

// export function CGContextSetLineWidth(c: any, width: number): void;

// export function CGContextSetMiterLimit(c: any, limit: number): void;

// export function CGContextSetPatternPhase(c: any, phase: CGSize): void;

// export function CGContextSetRGBFillColor(c: any, red: number, green: number, blue: number, alpha: number): void;

// export function CGContextSetRGBStrokeColor(c: any, red: number, green: number, blue: number, alpha: number): void;

// export function CGContextSetRenderingIntent(c: any, intent: CGColorSpace.CGColorRenderingIntent): void;

// export function CGContextSetShadow(c: any, offset: CGSize, blur: number): void;

// export function CGContextSetShadowWithColor(c: any, offset: CGSize, blur: number, color: any): void;

// export function CGContextSetShouldAntialias(c: any, shouldAntialias: boolean): void;

// export function CGContextSetShouldSmoothFonts(c: any, shouldSmoothFonts: boolean): void;

// export function CGContextSetShouldSubpixelPositionFonts(c: any, shouldSubpixelPositionFonts: boolean): void;

// export function CGContextSetShouldSubpixelQuantizeFonts(c: any, shouldSubpixelQuantizeFonts: boolean): void;

// export function CGContextSetStrokeColor(c: any, components: number): void;

// export function CGContextSetStrokeColorSpace(c: any, space: any): void;

// export function CGContextSetStrokeColorWithColor(c: any, color: any): void;

// export function CGContextSetStrokePattern(c: any, pattern: any, components: number): void;

// export function CGContextSetTextDrawingMode(c: any, mode: CGContext.CGTextDrawingMode): void;

// export function CGContextSetTextMatrix(c: any, t: CGAffineTransform): void;

// export function CGContextSetTextPosition(c: any, x: number, y: number): void;

// export function CGContextShowGlyphsAtPositions(c: any, glyphs: number, Lpositions: CGPoint, count: number): void;

// export function CGContextStrokeEllipseInRect(c: any, rect: CGRect): void;

// export function CGContextStrokeLineSegments(c: any, points: CGPoint, count: number): void;

// export function CGContextStrokePath(c: any): void;

// export function CGContextStrokeRect(c: any, rect: CGRect): void;

// export function CGContextStrokeRectWithWidth(c: any, rect: CGRect, width: number): void;

// export function CGContextSynchronize(c: any): void;

// export function CGContextTranslateCTM(c: any, tx: number, ty: number): void;

// export function CGDataConsumerCreate(info: any, cbks: CGDataConsumerCallbacks): any;

// export function CGDataConsumerCreateWithCFData(data: Data): any;

// export function CGDataConsumerCreateWithURL(url: URL): any;

// export function CGDataConsumerRelease(consumer: any): void;

// export function CGDataConsumerRetain(consumer: any): any;

// export function CGDataProviderCopyData(provider: any): Data;

// export function CGDataProviderCreateDirect(info: any, size: number, callbacks: CGDataProviderDirectCallbacks): any;

// export function CGDataProviderCreateSequential(info: any, callbacks: CGDataProviderSequentialCallbacks): any;

// export function CGDataProviderCreateWithCFData(data: Data): any;

// export function CGDataProviderCreateWithData(info: any, data: any, size: number, releaseData: (p1: any, p2: any, p3: number) => void): any;

// export function CGDataProviderCreateWithFilename(filename: string | any): any;

// export function CGDataProviderCreateWithURL(url: URL): any;

// export function CGDataProviderGetInfo(provider: any): any;

// export function CGDataProviderRelease(provider: any): void;

// export function CGDataProviderRetain(provider: any): any;

// export function CGDirectDisplayCopyCurrentMetalDevice(display: number): any;

// export function CGDisplayBounds(display: number): CGRect;

// export function CGDisplayCapture(display: number): CGError.CGError;

// export function CGDisplayCaptureWithOptions(display: number, options: CGDirectDisplay.CGCaptureOptions): CGError.CGError;

// export function CGDisplayCopyAllDisplayModes(display: number, options: Map<any, any>): any[];

// export function CGDisplayCopyColorSpace(display: number): any;

// export function CGDisplayCopyDisplayMode(display: number): any;

// export function CGDisplayCreateImage(displayID: number): any;

// export function CGDisplayCreateImageForRect(display: number, rect: CGRect): any;

// export function CGDisplayFade(token: number, duration: number, startBlend: number, endBlend: number, redBlend: number, greenBlend: number, blueBlend: number, synchronous: number): CGError.CGError;

// export function CGDisplayGammaTableCapacity(display: number): number;

// export function CGDisplayGetDrawingContext(display: number): any;

// export function CGDisplayHideCursor(display: number): CGError.CGError;

// export function CGDisplayIDToOpenGLDisplayMask(display: number): number;

// export function CGDisplayIsActive(display: number): number;

// export function CGDisplayIsAlwaysInMirrorSet(display: number): number;

// export function CGDisplayIsAsleep(display: number): number;

// export function CGDisplayIsBuiltin(display: number): number;

// export function CGDisplayIsInHWMirrorSet(display: number): number;

// export function CGDisplayIsInMirrorSet(display: number): number;

// export function CGDisplayIsMain(display: number): number;

// export function CGDisplayIsOnline(display: number): number;

// export function CGDisplayIsStereo(display: number): number;

// export function CGDisplayMirrorsDisplay(display: number): number;

// export function CGDisplayModeGetHeight(mode: any): number;

// export function CGDisplayModeGetIODisplayModeID(mode: any): number;

// export function CGDisplayModeGetIOFlags(mode: any): number;

// export function CGDisplayModeGetPixelHeight(mode: any): number;

// export function CGDisplayModeGetPixelWidth(mode: any): number;

// export function CGDisplayModeGetRefreshRate(mode: any): number;

// export function CGDisplayModeGetWidth(mode: any): number;

// export function CGDisplayModeIsUsableForDesktopGUI(mode: any): boolean;

// export function CGDisplayModeRelease(mode: any): void;

// export function CGDisplayModeRetain(mode: any): any;

// export function CGDisplayModelNumber(display: number): number;

// export function CGDisplayMoveCursorToPoint(display: number, point: CGPoint): CGError.CGError;

// export function CGDisplayPixelsHigh(display: number): number;

// export function CGDisplayPixelsWide(display: number): number;

// export function CGDisplayPrimaryDisplay(display: number): number;

// export function CGDisplayRegisterReconfigurationCallback(callback: (p1: number, p2: CGDisplayConfiguration.CGDisplayChangeSummaryFlags, p3: any) => void, userInfo: any): CGError.CGError;

// export function CGDisplayRelease(display: number): CGError.CGError;

// export function CGDisplayRemoveReconfigurationCallback(callback: (p1: number, p2: CGDisplayConfiguration.CGDisplayChangeSummaryFlags, p3: any) => void, userInfo: any): CGError.CGError;

// export function CGDisplayRestoreColorSyncSettings(): void;

// export function CGDisplayRotation(display: number): number;

// export function CGDisplayScreenSize(display: number): CGSize;

// export function CGDisplaySerialNumber(display: number): number;

// export function CGDisplaySetDisplayMode(display: number, mode: any, options: Map<any, any>): CGError.CGError;

// export function CGDisplaySetStereoOperation(display: number, stereo: number, forceBlueLine: number, option: CGDisplayConfiguration.CGConfigureOption): CGError.CGError;

// export function CGDisplayShowCursor(display: number): CGError.CGError;

// export function CGDisplayStreamCreate(display: number, outputWidth: number, outputHeight: number, pixelFormat: number, properties: Map<any, any>, handler: (p1: CGDisplayStream.CGDisplayStreamFrameStatus, p2: number, p3: any, p4: any) => void): any;

// export function CGDisplayStreamCreateWithDispatchQueue(display: number, outputWidth: number, outputHeight: number, pixelFormat: number, properties: Map<any, any>, queue: NSObject, handler: (p1: CGDisplayStream.CGDisplayStreamFrameStatus, p2: number, p3: any, p4: any) => void): any;

// export function CGDisplayStreamGetRunLoopSource(displayStream: any): any;

// export function CGDisplayStreamStart(displayStream: any): CGError.CGError;

// export function CGDisplayStreamStop(displayStream: any): CGError.CGError;

// export function CGDisplayStreamUpdateCreateMergedUpdate(firstUpdate: any, secondUpdate: any): any;

// export function CGDisplayStreamUpdateGetDropCount(updateRef: any): number;

// export function CGDisplayStreamUpdateGetMovedRectsDelta(updateRef: any, dx: number, dy: number): void;

// export function CGDisplayStreamUpdateGetRects(updateRef: any, rectType: CGDisplayStream.CGDisplayStreamUpdateRectType, rectCount: number): CGRect;

// export function CGDisplayUnitNumber(display: number): number;

// export function CGDisplayUsesOpenGLAcceleration(display: number): number;

// export function CGDisplayVendorNumber(display: number): number;

// export function CGEventCreate(source: any): any;

// export function CGEventCreateCopy(event: any): any;

// export function CGEventCreateData(allocator: any, event: any): Data;

// export function CGEventCreateFromData(allocator: any, data: Data): any;

// export function CGEventCreateKeyboardEvent(source: any, virtualKey: number, keyDown: boolean): any;

// export function CGEventCreateMouseEvent(source: any, mouseType: CGEventTypes.CGEventType, mouseCursorPosition: CGPoint, mouseButton: CGEventTypes.CGMouseButton): any;

// export function CGEventCreateScrollWheelEvent2(source: any, units: CGEventTypes.CGScrollEventUnit, wheelCount: number, wheel1: number, wheel2: number, wheel3: number): any;

// export function CGEventCreateSourceFromEvent(event: any): any;

// export function CGEventGetDoubleValueField(event: any, field: CGEventTypes.CGEventField): number;

// export function CGEventGetFlags(event: any): CGEventTypes.CGEventFlags;

// export function CGEventGetIntegerValueField(event: any, field: CGEventTypes.CGEventField): number;

// export function CGEventGetLocation(event: any): CGPoint;

// export function CGEventGetTimestamp(event: any): number;

// export function CGEventGetType(event: any): CGEventTypes.CGEventType;

// export function CGEventGetUnflippedLocation(event: any): CGPoint;

// export function CGEventKeyboardGetUnicodeString(event: any, maxStringLength: number, actualStringLength: number, unicodeString: number): void;

// export function CGEventKeyboardSetUnicodeString(event: any, stringLength: number, unicodeString: number): void;

// export function CGEventPost(tap: CGEventTypes.CGEventTapLocation, event: any): void;

// export function CGEventPostToPSN(processSerialNumber: any, event: any): void;

// export function CGEventPostToPid(pid: number, event: any): void;

// export function CGEventSetDoubleValueField(event: any, field: CGEventTypes.CGEventField, value: number): void;

// export function CGEventSetFlags(event: any, flags: CGEventTypes.CGEventFlags): void;

// export function CGEventSetIntegerValueField(event: any, field: CGEventTypes.CGEventField, value: number): void;

// export function CGEventSetLocation(event: any, location: CGPoint): void;

// export function CGEventSetSource(event: any, source: any): void;

// export function CGEventSetTimestamp(event: any, timestamp: number): void;

// export function CGEventSetType(event: any, type: CGEventTypes.CGEventType): void;

// export function CGEventSourceButtonState(stateID: CGEventTypes.CGEventSourceStateID, button: CGEventTypes.CGMouseButton): boolean;

// export function CGEventSourceCounterForEventType(stateID: CGEventTypes.CGEventSourceStateID, eventType: CGEventTypes.CGEventType): number;

// export function CGEventSourceCreate(stateID: CGEventTypes.CGEventSourceStateID): any;

// export function CGEventSourceFlagsState(stateID: CGEventTypes.CGEventSourceStateID): CGEventTypes.CGEventFlags;

// export function CGEventSourceGetKeyboardType(source: any): number;

// export function CGEventSourceGetLocalEventsFilterDuringSuppressionState(source: any, state: CGRemoteOperation.CGEventSuppressionState): CGRemoteOperation.CGEventFilterMask;

// export function CGEventSourceGetLocalEventsSuppressionInterval(source: any): number;

// export function CGEventSourceGetPixelsPerLine(source: any): number;

// export function CGEventSourceGetSourceStateID(source: any): CGEventTypes.CGEventSourceStateID;

// export function CGEventSourceGetUserData(source: any): number;

// export function CGEventSourceKeyState(stateID: CGEventTypes.CGEventSourceStateID, key: number): boolean;

// export function CGEventSourceSecondsSinceLastEventType(stateID: CGEventTypes.CGEventSourceStateID, eventType: CGEventTypes.CGEventType): number;

// export function CGEventSourceSetKeyboardType(source: any, keyboardType: number): void;

// export function CGEventSourceSetLocalEventsFilterDuringSuppressionState(source: any, filter: CGRemoteOperation.CGEventFilterMask, state: CGRemoteOperation.CGEventSuppressionState): void;

// export function CGEventSourceSetLocalEventsSuppressionInterval(source: any, seconds: number): void;

// export function CGEventSourceSetPixelsPerLine(source: any, pixelsPerLine: number): void;

// export function CGEventSourceSetUserData(source: any, userData: number): void;

// export function CGEventTapCreate(tap: CGEventTypes.CGEventTapLocation, place: CGEventTypes.CGEventTapPlacement, options: CGEventTypes.CGEventTapOptions, eventsOfInterest: number, callback: (p1: any, p2: CGEventTypes.CGEventType, p3: any, p4: any) => any, userInfo: any): NSMachPort;

// export function CGEventTapCreateForPSN(processSerialNumber: any, place: CGEventTypes.CGEventTapPlacement, options: CGEventTypes.CGEventTapOptions, eventsOfInterest: number, callback: (p1: any, p2: CGEventTypes.CGEventType, p3: any, p4: any) => any, userInfo: any): NSMachPort;

// export function CGEventTapCreateForPid(pid: number, place: CGEventTypes.CGEventTapPlacement, options: CGEventTypes.CGEventTapOptions, eventsOfInterest: number, callback: (p1: any, p2: CGEventTypes.CGEventType, p3: any, p4: any) => any, userInfo: any): NSMachPort;

// export function CGEventTapEnable(tap: NSMachPort, enable: boolean): void;

// export function CGEventTapIsEnabled(tap: NSMachPort): boolean;

// export function CGEventTapPostEvent(proxy: any, event: any): void;

// export function CGFontCanCreatePostScriptSubset(font: any, format: CGFont.CGFontPostScriptFormat): boolean;

// export function CGFontCopyFullName(font: any): string;

// export function CGFontCopyGlyphNameForGlyph(font: any, glyph: number): string;

// export function CGFontCopyPostScriptName(font: any): string;

// export function CGFontCopyTableForTag(font: any, tag: number): Data;

// export function CGFontCopyTableTags(font: any): any[];

// export function CGFontCopyVariationAxes(font: any): any[];

// export function CGFontCopyVariations(font: any): Map<any, any>;

// export function CGFontCreateCopyWithVariations(font: any, variations: Map<any, any>): any;

// export function CGFontCreatePostScriptEncoding(font: any, encoding: number): Data;

// export function CGFontCreatePostScriptSubset(font: any, subsetName: string, format: CGFont.CGFontPostScriptFormat, glyphs: number, count: number, encoding: number): Data;

// export function CGFontCreateWithDataProvider(provider: any): any;

// export function CGFontCreateWithFontName(name: string): any;

// export function CGFontGetAscent(font: any): number;

// export function CGFontGetCapHeight(font: any): number;

// export function CGFontGetDescent(font: any): number;

// export function CGFontGetFontBBox(font: any): CGRect;

// export function CGFontGetGlyphAdvances(font: any, glyphs: number, count: number, advances: number): boolean;

// export function CGFontGetGlyphBBoxes(font: any, glyphs: number, count: number, bboxes: CGRect): boolean;

// export function CGFontGetGlyphWithGlyphName(font: any, name: string): number;

// export function CGFontGetItalicAngle(font: any): number;

// export function CGFontGetLeading(font: any): number;

// export function CGFontGetNumberOfGlyphs(font: any): number;

// export function CGFontGetStemV(font: any): number;

// export function CGFontGetUnitsPerEm(font: any): number;

// export function CGFontGetXHeight(font: any): number;

// export function CGFontRelease(font: any): void;

// export function CGFontRetain(font: any): any;

// export function CGFunctionCreate(info: any, domainDimension: number, domain: number, rangeDimension: number, range: number, callbacks: CGFunctionCallbacks): any;

// export function CGFunctionRelease(function_: any): void;

// export function CGFunctionRetain(function_: any): any;

// export function CGGetActiveDisplayList(maxDisplays: number, activeDisplays: number, displayCount: number): CGError.CGError;

// export function CGGetDisplayTransferByFormula(display: number, redMin: number, redMax: number, redGamma: number, greenMin: number, greenMax: number, greenGamma: number, blueMin: number, blueMax: number, blueGamma: number): CGError.CGError;

// export function CGGetDisplayTransferByTable(display: number, capacity: number, redTable: number, greenTable: number, blueTable: number, sampleCount: number): CGError.CGError;

// export function CGGetDisplaysWithOpenGLDisplayMask(mask: number, maxDisplays: number, displays: number, matchingDisplayCount: number): CGError.CGError;

// export function CGGetDisplaysWithPoint(point: CGPoint, maxDisplays: number, displays: number, matchingDisplayCount: number): CGError.CGError;

// export function CGGetDisplaysWithRect(rect: CGRect, maxDisplays: number, displays: number, matchingDisplayCount: number): CGError.CGError;

// export function CGGetEventTapList(maxNumberOfTaps: number, tapList: __CGEventTapInformation, eventTapCount: number): CGError.CGError;

// export function CGGetLastMouseDelta(deltaX: number, deltaY: number): void;

// export function CGGetOnlineDisplayList(maxDisplays: number, onlineDisplays: number, displayCount: number): CGError.CGError;

// export function CGGradientCreateWithColorComponents(space: any, components: number, locations: number, count: number): any;

// export function CGGradientCreateWithColors(space: any, colors: any[], locations: number): any;

// export function CGGradientRelease(gradient: any): void;

// export function CGGradientRetain(gradient: any): any;

// export function CGImageCreate(width: number, height: number, bitsPerComponent: number, bitsPerPixel: number, bytesPerRow: number, space: any, bitmapInfo: CGImage.CGBitmapInfo, provider: any, decode: number, shouldInterpolate: boolean, intent: CGColorSpace.CGColorRenderingIntent): any;

// export function CGImageCreateCopy(image: any): any;

// export function CGImageCreateCopyWithColorSpace(image: any, space: any): any;

// export function CGImageCreateWithImageInRect(image: any, rect: CGRect): any;

// export function CGImageCreateWithJPEGDataProvider(source: any, decode: number, shouldInterpolate: boolean, intent: CGColorSpace.CGColorRenderingIntent): any;

// export function CGImageCreateWithMask(image: any, mask: any): any;

// export function CGImageCreateWithMaskingColors(image: any, components: number): any;

// export function CGImageCreateWithPNGDataProvider(source: any, decode: number, shouldInterpolate: boolean, intent: CGColorSpace.CGColorRenderingIntent): any;

// export function CGImageGetAlphaInfo(image: any): CGImage.CGImageAlphaInfo;

// export function CGImageGetBitmapInfo(image: any): CGImage.CGBitmapInfo;

// export function CGImageGetBitsPerComponent(image: any): number;

// export function CGImageGetBitsPerPixel(image: any): number;

// export function CGImageGetByteOrderInfo(image: any): CGImage.CGImageByteOrderInfo;

// export function CGImageGetBytesPerRow(image: any): number;

// export function CGImageGetColorSpace(image: any): any;

// export function CGImageGetDataProvider(image: any): any;

// export function CGImageGetDecode(image: any): number;

// export function CGImageGetHeight(image: any): number;

// export function CGImageGetPixelFormatInfo(image: any): CGImage.CGImagePixelFormatInfo;

// export function CGImageGetRenderingIntent(image: any): CGColorSpace.CGColorRenderingIntent;

// export function CGImageGetShouldInterpolate(image: any): boolean;

// export function CGImageGetUTType(image: any): string;

// export function CGImageGetWidth(image: any): number;

// export function CGImageIsMask(image: any): boolean;

// export function CGImageMaskCreate(width: number, height: number, bitsPerComponent: number, bitsPerPixel: number, bytesPerRow: number, provider: any, decode: number, shouldInterpolate: boolean): any;

// export function CGImageRelease(image: any): void;

// export function CGImageRetain(image: any): any;

// export function CGLayerCreateWithContext(context: any, size: CGSize, auxiliaryInfo: Map<any, any>): any;

// export function CGLayerGetContext(layer: any): any;

// export function CGLayerGetSize(layer: any): CGSize;

// export function CGLayerRelease(layer: any): void;

// export function CGLayerRetain(layer: any): any;

// export function CGMainDisplayID(): number;

// export function CGMutablePath.init(): any;

// export function CGOpenGLDisplayMaskToDisplayID(mask: number): number;

// export function CGPDFArrayApplyBlock(array: any, block: (p1: number, p2: any, p3: any) => boolean, info: any): void;

// export function CGPDFArrayGetArray(array: any, index: number, value: any): boolean;

// export function CGPDFArrayGetBoolean(array: any, index: number, value: string | any): boolean;

// export function CGPDFArrayGetCount(array: any): number;

// export function CGPDFArrayGetDictionary(array: any, index: number, value: any): boolean;

// export function CGPDFArrayGetInteger(array: any, index: number, value: number): boolean;

// export function CGPDFArrayGetName(array: any, index: number, value: string): boolean;

// export function CGPDFArrayGetNull(array: any, index: number): boolean;

// export function CGPDFArrayGetNumber(array: any, index: number, value: number): boolean;

// export function CGPDFArrayGetObject(array: any, index: number, value: any): boolean;

// export function CGPDFArrayGetStream(array: any, index: number, value: any): boolean;

// export function CGPDFArrayGetString(array: any, index: number, value: any): boolean;

// export function CGPDFContentStreamCreateWithPage(page: any): any;

// export function CGPDFContentStreamCreateWithStream(stream: any, streamResources: any, parent: any): any;

// export function CGPDFContentStreamGetResource(cs: any, category: string | any, name: string | any): any;

// export function CGPDFContentStreamGetStreams(cs: any): any[];

// export function CGPDFContentStreamRelease(cs: any): void;

// export function CGPDFContentStreamRetain(cs: any): any;

// export function CGPDFContextAddDestinationAtPoint(context: any, name: string, point: CGPoint): void;

// export function CGPDFContextAddDocumentMetadata(context: any, metadata: Data): void;

// export function CGPDFContextBeginPage(context: any, pageInfo: Map<any, any>): void;

// export function CGPDFContextBeginTag(context: any, tagType: CGPDFContext.CGPDFTagType, tagProperties: Map<any, any>): void;

// export function CGPDFContextClose(context: any): void;

// export function CGPDFContextCreate(consumer: any, mediaBox: CGRect, auxiliaryInfo: Map<any, any>): any;

// export function CGPDFContextCreateWithURL(url: URL, mediaBox: CGRect, auxiliaryInfo: Map<any, any>): any;

// export function CGPDFContextEndPage(context: any): void;

// export function CGPDFContextEndTag(context: any): void;

// export function CGPDFContextSetDestinationForRect(context: any, name: string, rect: CGRect): void;

// export function CGPDFContextSetOutline(context: any, outline: Map<any, any>): void;

// export function CGPDFContextSetURLForRect(context: any, url: URL, rect: CGRect): void;

// export function CGPDFDictionaryApplyBlock(dict: any, block: (p1: string, p2: any, p3: any) => boolean, info: any): void;

// export function CGPDFDictionaryApplyFunction(dict: any, function_: (p1: string, p2: any, p3: any) => void, info: any): void;

// export function CGPDFDictionaryGetArray(dict: any, key: string | any, value: any): boolean;

// export function CGPDFDictionaryGetBoolean(dict: any, key: string | any, value: string | any): boolean;

// export function CGPDFDictionaryGetCount(dict: any): number;

// export function CGPDFDictionaryGetDictionary(dict: any, key: string | any, value: any): boolean;

// export function CGPDFDictionaryGetInteger(dict: any, key: string | any, value: number): boolean;

// export function CGPDFDictionaryGetName(dict: any, key: string | any, value: string): boolean;

// export function CGPDFDictionaryGetNumber(dict: any, key: string | any, value: number): boolean;

// export function CGPDFDictionaryGetObject(dict: any, key: string | any, value: any): boolean;

// export function CGPDFDictionaryGetStream(dict: any, key: string | any, value: any): boolean;

// export function CGPDFDictionaryGetString(dict: any, key: string | any, value: any): boolean;

// export function CGPDFDocumentAllowsCopying(document: any): boolean;

// export function CGPDFDocumentAllowsPrinting(document: any): boolean;

// export function CGPDFDocumentCreateWithProvider(provider: any): any;

// export function CGPDFDocumentCreateWithURL(url: URL): any;

// export function CGPDFDocumentGetAccessPermissions(document: any): CGPDFDocument.CGPDFAccessPermissions;

// export function CGPDFDocumentGetCatalog(document: any): any;

// export function CGPDFDocumentGetID(document: any): any;

// export function CGPDFDocumentGetInfo(document: any): any;

// export function CGPDFDocumentGetNumberOfPages(document: any): number;

// export function CGPDFDocumentGetOutline(document: any): Map<any, any>;

// export function CGPDFDocumentGetPage(document: any, pageNumber: number): any;

// export function CGPDFDocumentGetVersion(document: any, majorVersion: number, minorVersion: number): void;

// export function CGPDFDocumentIsEncrypted(document: any): boolean;

// export function CGPDFDocumentIsUnlocked(document: any): boolean;

// export function CGPDFDocumentRelease(document: any): void;

// export function CGPDFDocumentRetain(document: any): any;

// export function CGPDFDocumentUnlockWithPassword(document: any, password: string | any): boolean;

// export function CGPDFObjectGetType(object_: any): CGPDFObject.CGPDFObjectType;

// export function CGPDFObjectGetValue(object_: any, type: CGPDFObject.CGPDFObjectType, value: any): boolean;

// export function CGPDFOperatorTableCreate(): any;

// export function CGPDFOperatorTableRelease(table: any): void;

// export function CGPDFOperatorTableRetain(table: any): any;

// export function CGPDFOperatorTableSetCallback(table: any, name: string | any, callback: (p1: any, p2: any) => void): void;

// export function CGPDFPageGetBoxRect(page: any, box: CGPDFPage.CGPDFBox): CGRect;

// export function CGPDFPageGetDictionary(page: any): any;

// export function CGPDFPageGetDocument(page: any): any;

// export function CGPDFPageGetDrawingTransform(page: any, box: CGPDFPage.CGPDFBox, rect: CGRect, rotate: number, preserveAspectRatio: boolean): CGAffineTransform;

// export function CGPDFPageGetPageNumber(page: any): number;

// export function CGPDFPageGetRotationAngle(page: any): number;

// export function CGPDFPageRelease(page: any): void;

// export function CGPDFPageRetain(page: any): any;

// export function CGPDFScannerCreate(cs: any, table: any, info: any): any;

// export function CGPDFScannerGetContentStream(scanner: any): any;

// export function CGPDFScannerPopArray(scanner: any, value: any): boolean;

// export function CGPDFScannerPopBoolean(scanner: any, value: string | any): boolean;

// export function CGPDFScannerPopDictionary(scanner: any, value: any): boolean;

// export function CGPDFScannerPopInteger(scanner: any, value: number): boolean;

// export function CGPDFScannerPopName(scanner: any, value: string): boolean;

// export function CGPDFScannerPopNumber(scanner: any, value: number): boolean;

// export function CGPDFScannerPopObject(scanner: any, value: any): boolean;

// export function CGPDFScannerPopStream(scanner: any, value: any): boolean;

// export function CGPDFScannerPopString(scanner: any, value: any): boolean;

// export function CGPDFScannerRelease(scanner: any): void;

// export function CGPDFScannerRetain(scanner: any): any;

// export function CGPDFScannerScan(scanner: any): boolean;

// export function CGPDFStreamCopyData(stream: any, format: CGPDFStream.CGPDFDataFormat): Data;

// export function CGPDFStreamGetDictionary(stream: any): any;

// export function CGPDFStringCopyDate(string: any): Date;

// export function CGPDFStringCopyTextString(string: any): string;

// export function CGPDFStringGetBytePtr(string: any): string;

// export function CGPDFStringGetLength(string: any): number;

// export function CGPDFTagTypeGetName(tagType: CGPDFContext.CGPDFTagType): string;

// export function CGPSConverterAbort(converter: any): boolean;

// export function CGPSConverterConvert(converter: any, provider: any, consumer: any, options: Map<any, any>): boolean;

// export function CGPSConverterCreate(info: any, callbacks: CGPSConverterCallbacks, options: Map<any, any>): any;

// export function CGPSConverterIsConverting(converter: any): boolean;

// export function CGPath.apply(path: any, info: any, function_: (p1: any, p2: CGPathElement) => void): void;

// export function CGPathAddArc(path: any, m: CGAffineTransform, x: number, y: number, radius: number, startAngle: number, endAngle: number, clockwise: boolean): void;

// export function CGPathAddArcToPoint(path: any, m: CGAffineTransform, x1: number, y1: number, x2: number, y2: number, radius: number): void;

// export function CGPathAddCurveToPoint(path: any, m: CGAffineTransform, cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number): void;

// export function CGPathAddEllipseInRect(path: any, m: CGAffineTransform, rect: CGRect): void;

// export function CGPathAddLineToPoint(path: any, m: CGAffineTransform, x: number, y: number): void;

// export function CGPathAddLines(path: any, m: CGAffineTransform, points: CGPoint, count: number): void;

// export function CGPathAddPath(path1: any, m: CGAffineTransform, path2: any): void;

// export function CGPathAddQuadCurveToPoint(path: any, m: CGAffineTransform, cpx: number, cpy: number, x: number, y: number): void;

// export function CGPathAddRect(path: any, m: CGAffineTransform, rect: CGRect): void;

// export function CGPathAddRects(path: any, m: CGAffineTransform, rects: CGRect, count: number): void;

// export function CGPathAddRelativeArc(path: any, matrix: CGAffineTransform, x: number, y: number, radius: number, startAngle: number, delta: number): void;

// export function CGPathAddRoundedRect(path: any, transform: CGAffineTransform, rect: CGRect, cornerWidth: number, cornerHeight: number): void;

// export function CGPathApplyWithBlock(path: any, block: (p1: CGPathElement) => void): void;

// export function CGPathCloseSubpath(path: any): void;

// export function CGPathContainsPoint(path: any, m: CGAffineTransform, point: CGPoint, eoFill: boolean): boolean;

// export function CGPathCreateCopy(path: any): any;

// export function CGPathCreateCopyByDashingPath(path: any, transform: CGAffineTransform, phase: number, lengths: number, count: number): any;

// export function CGPathCreateCopyByStrokingPath(path: any, transform: CGAffineTransform, lineWidth: number, lineCap: CGPath.CGLineCap, lineJoin: CGPath.CGLineJoin, miterLimit: number): any;

// export function CGPathCreateCopyByTransformingPath(path: any, transform: CGAffineTransform): any;

// export function CGPathCreateMutableCopy(path: any): any;

// export function CGPathCreateMutableCopyByTransformingPath(path: any, transform: CGAffineTransform): any;

// export function CGPathCreateWithEllipseInRect(rect: CGRect, transform: CGAffineTransform): any;

// export function CGPathCreateWithRect(rect: CGRect, transform: CGAffineTransform): any;

// export function CGPathCreateWithRoundedRect(rect: CGRect, cornerWidth: number, cornerHeight: number, transform: CGAffineTransform): any;

// export function CGPathEqualToPath(path1: any, path2: any): boolean;

// export function CGPathGetBoundingBox(path: any): CGRect;

// export function CGPathGetCurrentPoint(path: any): CGPoint;

// export function CGPathGetPathBoundingBox(path: any): CGRect;

// export function CGPathIsEmpty(path: any): boolean;

// export function CGPathIsRect(path: any, rect: CGRect): boolean;

// export function CGPathMoveToPoint(path: any, m: CGAffineTransform, x: number, y: number): void;

// export function CGPathRelease(path: any): void;

// export function CGPathRetain(path: any): any;

// export function CGPatternCreate(info: any, bounds: CGRect, matrix: CGAffineTransform, xStep: number, yStep: number, tiling: CGPattern.CGPatternTiling, isColored: boolean, callbacks: CGPatternCallbacks): any;

// export function CGPatternRelease(pattern: any): void;

// export function CGPatternRetain(pattern: any): any;

// export function CGPointApplyAffineTransform(point: CGPoint, t: CGAffineTransform): CGPoint;

// export function CGPointCreateDictionaryRepresentation(point: CGPoint): Map<any, any>;

// export function CGPointEqualToPoint(point1: CGPoint, point2: CGPoint): boolean;

// export function CGPointMake(x: number, y: number): CGPoint;

// export function CGPointMakeWithDictionaryRepresentation(dict: Map<any, any>, point: CGPoint): boolean;

// export function CGRectApplyAffineTransform(rect: CGRect, t: CGAffineTransform): CGRect;

// export function CGRectContainsPoint(rect: CGRect, point: CGPoint): boolean;

// export function CGRectContainsRect(rect1: CGRect, rect2: CGRect): boolean;

// export function CGRectCreateDictionaryRepresentation(p1: CGRect): Map<any, any>;

// export function CGRectDivide(rect: CGRect, slice: CGRect, remainder: CGRect, amount: number, edge: CGGeometry.CGRectEdge): void;

// export function CGRectEqualToRect(rect1: CGRect, rect2: CGRect): boolean;

// export function CGRectGetHeight(rect: CGRect): number;

// export function CGRectGetMaxX(rect: CGRect): number;

// export function CGRectGetMaxY(rect: CGRect): number;

// export function CGRectGetMidX(rect: CGRect): number;

// export function CGRectGetMidY(rect: CGRect): number;

// export function CGRectGetMinX(rect: CGRect): number;

// export function CGRectGetMinY(rect: CGRect): number;

// export function CGRectGetWidth(rect: CGRect): number;

// export function CGRectInset(rect: CGRect, dx: number, dy: number): CGRect;

// export function CGRectIntegral(rect: CGRect): CGRect;

// export function CGRectIntersection(r1: CGRect, r2: CGRect): CGRect;

// export function CGRectIntersectsRect(rect1: CGRect, rect2: CGRect): boolean;

// export function CGRectIsEmpty(rect: CGRect): boolean;

// export function CGRectIsInfinite(rect: CGRect): boolean;

// export function CGRectIsNull(rect: CGRect): boolean;

// export function CGRectMake(x: number, y: number, width: number, height: number): CGRect;

// export function CGRectMakeWithDictionaryRepresentation(dict: Map<any, any>, rect: CGRect): boolean;

// export function CGRectOffset(rect: CGRect, dx: number, dy: number): CGRect;

// export function CGRectStandardize(rect: CGRect): CGRect;

// export function CGRectUnion(r1: CGRect, r2: CGRect): CGRect;

// export function CGReleaseAllDisplays(): CGError.CGError;

// export function CGReleaseDisplayFadeReservation(token: number): CGError.CGError;

// export function CGRestorePermanentDisplayConfiguration(): void;

// export function CGSessionCopyCurrentDictionary(): Map<any, any>;

// export function CGSetDisplayTransferByByteTable(display: number, tableSize: number, redTable: string | any, greenTable: string | any, blueTable: string | any): CGError.CGError;

// export function CGSetDisplayTransferByFormula(display: number, redMin: number, redMax: number, redGamma: number, greenMin: number, greenMax: number, greenGamma: number, blueMin: number, blueMax: number, blueGamma: number): CGError.CGError;

// export function CGSetDisplayTransferByTable(display: number, tableSize: number, redTable: number, greenTable: number, blueTable: number): CGError.CGError;

// export function CGShadingCreateAxial(space: any, start: CGPoint, end: CGPoint, function_: any, extendStart: boolean, extendEnd: boolean): any;

// export function CGShadingCreateRadial(space: any, start: CGPoint, startRadius: number, end: CGPoint, endRadius: number, function_: any, extendStart: boolean, extendEnd: boolean): any;

// export function CGShadingRelease(shading: any): void;

// export function CGShadingRetain(shading: any): any;

// export function CGShieldingWindowID(display: number): number;

// export function CGShieldingWindowLevel(): number;

// export function CGSizeApplyAffineTransform(size: CGSize, t: CGAffineTransform): CGSize;

// export function CGSizeCreateDictionaryRepresentation(size: CGSize): Map<any, any>;

// export function CGSizeEqualToSize(size1: CGSize, size2: CGSize): boolean;

// export function CGSizeMake(width: number, height: number): CGSize;

// export function CGSizeMakeWithDictionaryRepresentation(dict: Map<any, any>, size: CGSize): boolean;

// export function CGVectorMake(dx: number, dy: number): CGVector;

// export function CGWarpMouseCursorPosition(newCursorPosition: CGPoint): CGError.CGError;

// export function CGWindowLevelForKey(key: CGWindowLevel.CGWindowLevelKey): number;

// export function CGWindowListCopyWindowInfo(option: CGWindow.CGWindowListOption, relativeToWindow: number): any[];

// export function CGWindowListCreate(option: CGWindow.CGWindowListOption, relativeToWindow: number): any[];

// export function CGWindowListCreateDescriptionFromArray(windowArray: any[]): any[];

// export function CGWindowListCreateImage(screenBounds: CGRect, listOption: CGWindow.CGWindowListOption, windowID: number, imageOption: CGWindow.CGWindowImageOption): any;

// export function CGWindowListCreateImageFromArray(screenBounds: CGRect, windowArray: any[], imageOption: CGWindow.CGWindowImageOption): any;

// export function CGWindowServerCreateServerPort(): NSMachPort;

// export function getter(): number;

// export function getterFunction(): number;

// export function getterFunction10(): number;

// export function getterFunction11(): number;

// export function getterFunction12(): number;

// export function getterFunction13(): number;

// export function getterFunction14(): number;

// export function getterFunction15(): number;

// export function getterFunction16(): number;

// export function getterFunction17(): number;

// export function getterFunction18(): number;

// export function getterFunction19(): number;

// export function getterFunction2(): number;

// export function getterFunction20(): number;

// export function getterFunction21(): number;

// export function getterFunction3(): number;

// export function getterFunction4(): number;

// export function getterFunction5(): number;

// export function getterFunction6(): number;

// export function getterFunction7(): number;

// export function getterFunction8(): number;

// export function getterFunction9(): number;

interface CIAccordionFoldTransition {
  bottomHeight: number;
  setBottomHeight(_: number);
  foldShadowAmount: number;
  setFoldShadowAmount(_: number);
  numberOfFolds: number;
  setNumberOfFolds(_: number);
}

interface CIAffineClamp {
  inputImage: CIImage;
  setInputImage(_: CIImage);
  transform: CGAffineTransform;
  setTransform(_: CGAffineTransform);
}

interface CIAffineTile {
  inputImage: CIImage;
  setInputImage(_: CIImage);
  transform: CGAffineTransform;
  setTransform(_: CGAffineTransform);
}

interface CIAttributedTextImageGenerator {
  scaleFactor: number;
  setScaleFactor(_: number);
  text: NSAttributedString;
  setText(_: NSAttributedString);
}

export class CIAztecCodeDescriptor extends CIBarcodeDescriptor {
  dataCodewordCount: number;
  errorCorrectedPayload: Data;
  isCompact: boolean;
  layerCount: number;
  static initWithPayloadIsCompactLayerCountDataCodewordCount(_: Data, isCompact: boolean, layerCount: number, dataCodewordCount: number): CIAztecCodeDescriptor;
}

interface CIAztecCodeGenerator {
  compactStyle: number;
  setCompactStyle(_: number);
  correctionLevel: number;
  setCorrectionLevel(_: number);
  layers: number;
  setLayers(_: number);
  message: Data;
  setMessage(_: Data);
}

export class CIBarcodeDescriptor extends NSObject {
}

interface CIBarcodeGenerator {
  barcodeDescriptor: CIBarcodeDescriptor;
  setBarcodeDescriptor(_: CIBarcodeDescriptor);
}

interface CIBarsSwipeTransition {
  angle: number;
  setAngle(_: number);
  barOffset: number;
  setBarOffset(_: number);
  width: number;
  setWidth(_: number);
}

interface CIBicubicScaleTransform {
  aspectRatio: number;
  setAspectRatio(_: number);
  inputImage: CIImage;
  setInputImage(_: CIImage);
  parameterB: number;
  setParameterB(_: number);
  parameterC: number;
  setParameterC(_: number);
  scale: number;
  setScale(_: number);
}

export class CIBlendKernel extends CIColorKernel {
  //  static kernelWithFunctionNameFromMetalLibraryData(fromMetalLibraryData: string, error: Data): CIBlendKernel;
  //  static kernelWithFunctionNameFromMetalLibraryDataOutputPixelFormat(fromMetalLibraryData: string, outputPixelFormat: Data, error: number): CIBlendKernel;
  static clear: CIBlendKernel;
  static color: CIBlendKernel;
  static colorBurn: CIBlendKernel;
  static colorDodge: CIBlendKernel;
  static componentAdd: CIBlendKernel;
  static componentMax: CIBlendKernel;
  static componentMin: CIBlendKernel;
  static componentMultiply: CIBlendKernel;
  static darken: CIBlendKernel;
  static darkerColor: CIBlendKernel;
  static destination: CIBlendKernel;
  static destinationAtop: CIBlendKernel;
  static destinationIn: CIBlendKernel;
  static destinationOut: CIBlendKernel;
  static destinationOver: CIBlendKernel;
  static difference: CIBlendKernel;
  static divide: CIBlendKernel;
  static exclusion: CIBlendKernel;
  static exclusiveOr: CIBlendKernel;
  static hardLight: CIBlendKernel;
  static hardMix: CIBlendKernel;
  static hue: CIBlendKernel;
  static lighten: CIBlendKernel;
  static lighterColor: CIBlendKernel;
  static linearBurn: CIBlendKernel;
  static linearDodge: CIBlendKernel;
  static linearLight: CIBlendKernel;
  static luminosity: CIBlendKernel;
  static multiply: CIBlendKernel;
  static overlay: CIBlendKernel;
  static pinLight: CIBlendKernel;
  static saturation: CIBlendKernel;
  static screen: CIBlendKernel;
  static softLight: CIBlendKernel;
  static source: CIBlendKernel;
  static sourceAtop: CIBlendKernel;
  static sourceIn: CIBlendKernel;
  static sourceOut: CIBlendKernel;
  static sourceOver: CIBlendKernel;
  static subtract: CIBlendKernel;
  static vividLight: CIBlendKernel;
  applyWithForegroundBackground(foreground: CIImage, background: CIImage): CIImage;
  applyWithForegroundBackgroundColorSpace(foreground: CIImage, background: CIImage, colorSpace: any): CIImage;
}

interface CIBlendWithMask {
  backgroundImage: CIImage;
  setBackgroundImage(_: CIImage);
  inputImage: CIImage;
  setInputImage(_: CIImage);
  maskImage: CIImage;
  setMaskImage(_: CIImage);
}

interface CIBloom {
  inputImage: CIImage;
  setInputImage(_: CIImage);
  intensity: number;
  setIntensity(_: number);
  radius: number;
  setRadius(_: number);
}

interface CIBokehBlur {
  inputImage: CIImage;
  setInputImage(_: CIImage);
  radius: number;
  setRadius(_: number);
  ringAmount: number;
  setRingAmount(_: number);
  ringSize: number;
  setRingSize(_: number);
  softness: number;
  setSoftness(_: number);
}

interface CIBoxBlur {
  inputImage: CIImage;
  setInputImage(_: CIImage);
  radius: number;
  setRadius(_: number);
}

interface CICMYKHalftone {
  angle: number;
  setAngle(_: number);
  center: CGPoint;
  setCenter(_: CGPoint);
  grayComponentReplacement: number;
  setGrayComponentReplacement(_: number);
  inputImage: CIImage;
  setInputImage(_: CIImage);
  sharpness: number;
  setSharpness(_: number);
  underColorRemoval: number;
  setUnderColorRemoval(_: number);
  width: number;
  setWidth(_: number);
}

interface CICheckerboardGenerator {
  center: CGPoint;
  setCenter(_: CGPoint);
  color0: CIColor;
  setColor0(_: CIColor);
  color1: CIColor;
  setColor1(_: CIColor);
  sharpness: number;
  setSharpness(_: number);
  width: number;
  setWidth(_: number);
}

interface CICircularScreen {
  center: CGPoint;
  setCenter(_: CGPoint);
  inputImage: CIImage;
  setInputImage(_: CIImage);
  sharpness: number;
  setSharpness(_: number);
  width: number;
  setWidth(_: number);
}

interface CICode128BarcodeGenerator {
  barcodeHeight: number;
  setBarcodeHeight(_: number);
  message: Data;
  setMessage(_: Data);
  quietSpace: number;
  setQuietSpace(_: number);
}

export class CIColor extends NSObject {
  alpha: number;
  blue: number;
  colorSpace: any;
  components: number;
  green: number;
  numberOfComponents: number;
  red: number;
  stringRepresentation: string;
  static blackColor: CIColor;
  static blueColor: CIColor;
  static clearColor: CIColor;
  static cyanColor: CIColor;
  static grayColor: CIColor;
  static greenColor: CIColor;
  static magentaColor: CIColor;
  static redColor: CIColor;
  static whiteColor: CIColor;
  static yellowColor: CIColor;
  static initWithCGColor(_: any): CIColor;
  static initWithColor(_: NSColor): CIColor;
  static initWithRedGreenBlue(_: number, green: number, blue: number): CIColor;
  static initWithRedGreenBlueAlpha(_: number, green: number, blue: number, alpha: number): CIColor;
  static initWithRedGreenBlueAlphaColorSpace(_: number, green: number, blue: number, alpha: number, colorSpace: any): CIColor;
  static initWithRedGreenBlueColorSpace(_: number, green: number, blue: number, colorSpace: any): CIColor;
}

interface CIColorClamp {
  inputImage: CIImage;
  setInputImage(_: CIImage);
  maxComponents: CIVector;
  setMaxComponents(_: CIVector);
  minComponents: CIVector;
  setMinComponents(_: CIVector);
}

interface CIColorControls {
  brightness: number;
  setBrightness(_: number);
  contrast: number;
  setContrast(_: number);
  inputImage: CIImage;
  setInputImage(_: CIImage);
  saturation: number;
  setSaturation(_: number);
}

interface CIColorCrossPolynomial {
  blueCoefficients: CIVector;
  setBlueCoefficients(_: CIVector);
  greenCoefficients: CIVector;
  setGreenCoefficients(_: CIVector);
  inputImage: CIImage;
  setInputImage(_: CIImage);
  redCoefficients: CIVector;
  setRedCoefficients(_: CIVector);
}

interface CIColorCube {
  cubeData: Data;
  setCubeData(_: Data);
  cubeDimension: number;
  setCubeDimension(_: number);
  inputImage: CIImage;
  setInputImage(_: CIImage);
}

interface CIColorCubeWithColorSpace {
  colorSpace: any;
  setColorSpace(_: any);
  cubeData: Data;
  setCubeData(_: Data);
  cubeDimension: number;
  setCubeDimension(_: number);
  inputImage: CIImage;
  setInputImage(_: CIImage);
}

interface CIColorCubesMixedWithMask {
  colorSpace: any;
  setColorSpace(_: any);
  cube0Data: Data;
  setCube0Data(_: Data);
  cube1Data: Data;
  setCube1Data(_: Data);
  cubeDimension: number;
  setCubeDimension(_: number);
  inputImage: CIImage;
  setInputImage(_: CIImage);
  maskImage: CIImage;
  setMaskImage(_: CIImage);
}

interface CIColorCurves {
  colorSpace: any;
  setColorSpace(_: any);
  curvesData: Data;
  setCurvesData(_: Data);
  curvesDomain: CIVector;
  setCurvesDomain(_: CIVector);
  inputImage: CIImage;
  setInputImage(_: CIImage);
}

interface CIColorInvert {
  inputImage: CIImage;
  setInputImage(_: CIImage);
}

export class CIColorKernel extends CIKernel {
  //  static kernelWithFunctionNameFromMetalLibraryData(fromMetalLibraryData: string, error: Data): CIColorKernel;
  //  static kernelWithFunctionNameFromMetalLibraryDataOutputPixelFormat(fromMetalLibraryData: string, outputPixelFormat: Data, error: number): CIColorKernel;
  applyWithExtentArguments(extent: CGRect, arguments_?: any[]): CIImage;
}

interface CIColorMap {
  gradientImage: CIImage;
  setGradientImage(_: CIImage);
  inputImage: CIImage;
  setInputImage(_: CIImage);
}

interface CIColorMatrix {
  AVector: CIVector;
  setAVector(_: CIVector);
  biasVector: CIVector;
  setBiasVector(_: CIVector);
  BVector: CIVector;
  setBVector(_: CIVector);
  GVector: CIVector;
  setGVector(_: CIVector);
  inputImage: CIImage;
  setInputImage(_: CIImage);
  RVector: CIVector;
  setRVector(_: CIVector);
}

interface CIColorMonochrome {
  color: CIColor;
  setColor(_: CIColor);
  inputImage: CIImage;
  setInputImage(_: CIImage);
  intensity: number;
  setIntensity(_: number);
}

interface CIColorPolynomial {
  alphaCoefficients: CIVector;
  setAlphaCoefficients(_: CIVector);
  blueCoefficients: CIVector;
  setBlueCoefficients(_: CIVector);
  greenCoefficients: CIVector;
  setGreenCoefficients(_: CIVector);
  inputImage: CIImage;
  setInputImage(_: CIImage);
  redCoefficients: CIVector;
  setRedCoefficients(_: CIVector);
}

interface CIColorPosterize {
  inputImage: CIImage;
  setInputImage(_: CIImage);
  levels: number;
  setLevels(_: number);
}

interface CIComicEffect {
  inputImage: CIImage;
  setInputImage(_: CIImage);
}

interface CICompositeOperation {
  backgroundImage: CIImage;
  setBackgroundImage(_: CIImage);
  inputImage: CIImage;
  setInputImage(_: CIImage);
}

export class CIContext extends NSObject {
  static offlineGPUCount(): number;
  workingColorSpace: any;
  workingFormat: number;
  hEIFRepresentationOfImageFormatColorSpaceOptions(of: CIImage, format: number, colorSpace: any, options: Map<string, any>): Data;
  jPEGRepresentationOfImageColorSpaceOptions(of: CIImage, colorSpace: any, options: Map<string, any>): Data;
  pNGRepresentationOfImageFormatColorSpaceOptions(of: CIImage, format: number, colorSpace: any, options: Map<string, any>): Data;
  tIFFRepresentationOfImageFormatColorSpaceOptions(of: CIImage, format: number, colorSpace: any, options: Map<string, any>): Data;
  clearCaches(): void;
  createCGImageFromRect(_: CIImage, from: CGRect): any;
  createCGImageFromRectFormatColorSpace(_: CIImage, from: CGRect, format: number, colorSpace?: any): any;
  createCGImageFromRectFormatColorSpaceDeferred(_: CIImage, from: CGRect, format: number, colorSpace?: any, deferred?: boolean): any;
  depthBlurEffectFilterForImageDisparityImagePortraitEffectsMatteHairSemanticSegmentationOrientationOptions(for_: CIImage, disparityImage: CIImage, portraitEffectsMatte?: CIImage, hairSemanticSegmentation?: CIImage, orientation?: CGImageProperties.CGImagePropertyOrientation, options?: Map<any, any>): CIFilter;
  depthBlurEffectFilterForImageDisparityImagePortraitEffectsMatteOrientationOptions(for_: CIImage, disparityImage: CIImage, portraitEffectsMatte?: CIImage, orientation?: CGImageProperties.CGImagePropertyOrientation, options?: Map<any, any>): CIFilter;
  depthBlurEffectFilterForImageDataOptions(forImageData: Data, options?: Map<any, any>): CIFilter;
  depthBlurEffectFilterForImageURLOptions(forImageURL: URL, options?: Map<any, any>): CIFilter;
  drawImageInRectFromRect(_: CIImage, in_: CGRect, from: CGRect): void;
  static initWithOptions(_?: Map<string, any>): CIContext;
  prepareRenderFromRectToDestinationAtPoint(fromRect: CIImage, toDestination: CGRect, atPoint: CIRenderDestination, error: CGPoint): boolean;
  reclaimResources(): void;
  renderToBitmapRowBytesBoundsFormatColorSpace(_: CIImage, toBitmap: any, rowBytes: number, bounds: CGRect, format: number, colorSpace?: any): void;
  renderToCVPixelBuffer(_: CIImage, to: any): void;
  renderToCVPixelBufferBoundsColorSpace(_: CIImage, to: any, bounds: CGRect, colorSpace?: any): void;
  renderToIOSurfaceBoundsColorSpace(_: CIImage, to: any, bounds: CGRect, colorSpace?: any): void;
  renderToMTLTextureCommandBufferBoundsColorSpace(_: CIImage, to: any, commandBuffer?: any, bounds?: CGRect, colorSpace?: any): void;
  startTaskToClear(error: CIRenderDestination): CIRenderTask;
  startTaskToRenderFromRectToDestinationAtPoint(fromRect: CIImage, toDestination: CGRect, atPoint: CIRenderDestination, error: CGPoint): CIRenderTask;
  startTaskToRenderToDestination(toDestination: CIImage, error: CIRenderDestination): CIRenderTask;
  writeHEIFRepresentationOfImageToURLFormatColorSpaceOptions(toURL: CIImage, format: URL, colorSpace: number, options: any, error: Map<string, any>): boolean;
  writeJPEGRepresentationOfImageToURLColorSpaceOptions(toURL: CIImage, colorSpace: URL, options: any, error: Map<string, any>): boolean;
  writePNGRepresentationOfImageToURLFormatColorSpaceOptions(toURL: CIImage, format: URL, colorSpace: number, options: any, error: Map<string, any>): boolean;
  writeTIFFRepresentationOfImageToURLFormatColorSpaceOptions(toURL: CIImage, format: URL, colorSpace: number, options: any, error: Map<string, any>): boolean;
}

interface CIConvolution {
  bias: number;
  setBias(_: number);
  inputImage: CIImage;
  setInputImage(_: CIImage);
  weights: CIVector;
  setWeights(_: CIVector);
}

interface CICopyMachineTransition {
  angle: number;
  setAngle(_: number);
  color: CIColor;
  setColor(_: CIColor);
  extent: CGRect;
  setExtent(_: CGRect);
  opacity: number;
  setOpacity(_: number);
  width: number;
  setWidth(_: number);
}

interface CICoreMLModel {
  headIndex: number;
  setHeadIndex(_: number);
  inputImage: CIImage;
  setInputImage(_: CIImage);
  model: MLModel;
  setModel(_: MLModel);
  softmaxNormalization: boolean;
  setSoftmaxNormalization(_: boolean);
}

interface CICrystallize {
  center: CGPoint;
  setCenter(_: CGPoint);
  inputImage: CIImage;
  setInputImage(_: CIImage);
  radius: number;
  setRadius(_: number);
}

export class CIDataMatrixCodeDescriptor extends CIBarcodeDescriptor {
  columnCount: number;
  eccVersion: CIBarcodeDescriptor.CIDataMatrixCodeECCVersion;
  errorCorrectedPayload: Data;
  rowCount: number;
  static initWithPayloadRowCountColumnCountEccVersion(_: Data, rowCount: number, columnCount: number, eccVersion: CIBarcodeDescriptor.CIDataMatrixCodeECCVersion): CIDataMatrixCodeDescriptor;
}

interface CIDepthOfField {
  inputImage: CIImage;
  setInputImage(_: CIImage);
  point0: CGPoint;
  setPoint0(_: CGPoint);
  point1: CGPoint;
  setPoint1(_: CGPoint);
  radius: number;
  setRadius(_: number);
  saturation: number;
  setSaturation(_: number);
  unsharpMaskIntensity: number;
  setUnsharpMaskIntensity(_: number);
  unsharpMaskRadius: number;
  setUnsharpMaskRadius(_: number);
}

interface CIDepthToDisparity {
  inputImage: CIImage;
  setInputImage(_: CIImage);
}

export class CIDetector extends NSObject {
  featuresInImage(in_: CIImage): CIFeature[];
  featuresInImageOptions(in_: CIImage, options?: Map<string, any>): CIFeature[];
}

interface CIDiscBlur {
  inputImage: CIImage;
  setInputImage(_: CIImage);
  radius: number;
  setRadius(_: number);
}

interface CIDisintegrateWithMaskTransition {
  maskImage: CIImage;
  setMaskImage(_: CIImage);
  shadowDensity: number;
  setShadowDensity(_: number);
  shadowOffset: CGPoint;
  setShadowOffset(_: CGPoint);
  shadowRadius: number;
  setShadowRadius(_: number);
}

interface CIDisparityToDepth {
  inputImage: CIImage;
  setInputImage(_: CIImage);
}

interface CIDissolveTransition {
}

interface CIDither {
  inputImage: CIImage;
  setInputImage(_: CIImage);
  intensity: number;
  setIntensity(_: number);
}

interface CIDocumentEnhancer {
  amount: number;
  setAmount(_: number);
  inputImage: CIImage;
  setInputImage(_: CIImage);
}

interface CIDotScreen {
  angle: number;
  setAngle(_: number);
  center: CGPoint;
  setCenter(_: CGPoint);
  inputImage: CIImage;
  setInputImage(_: CIImage);
  sharpness: number;
  setSharpness(_: number);
  width: number;
  setWidth(_: number);
}

interface CIEdgePreserveUpsample {
  inputImage: CIImage;
  setInputImage(_: CIImage);
  lumaSigma: number;
  setLumaSigma(_: number);
  smallImage: CIImage;
  setSmallImage(_: CIImage);
  spatialSigma: number;
  setSpatialSigma(_: number);
}

interface CIEdgeWork {
  inputImage: CIImage;
  setInputImage(_: CIImage);
  radius: number;
  setRadius(_: number);
}

interface CIEdges {
  inputImage: CIImage;
  setInputImage(_: CIImage);
  intensity: number;
  setIntensity(_: number);
}

interface CIEightfoldReflectedTile {
  angle: number;
  setAngle(_: number);
  center: CGPoint;
  setCenter(_: CGPoint);
  inputImage: CIImage;
  setInputImage(_: CIImage);
  width: number;
  setWidth(_: number);
}

interface CIExposureAdjust {
  EV: number;
  setEV(_: number);
  inputImage: CIImage;
  setInputImage(_: CIImage);
}

export class CIFaceFeature extends CIFeature {
  faceAngle: number;
  hasFaceAngle: boolean;
  hasLeftEyePosition: boolean;
  hasMouthPosition: boolean;
  hasRightEyePosition: boolean;
  hasSmile: boolean;
  hasTrackingFrameCount: boolean;
  hasTrackingID: boolean;
  leftEyeClosed: boolean;
  leftEyePosition: CGPoint;
  mouthPosition: CGPoint;
  rightEyeClosed: boolean;
  rightEyePosition: CGPoint;
  trackingFrameCount: number;
  trackingID: number;
}

interface CIFalseColor {
  color0: CIColor;
  setColor0(_: CIColor);
  color1: CIColor;
  setColor1(_: CIColor);
  inputImage: CIImage;
  setInputImage(_: CIImage);
}

export class CIFeature extends NSObject {
  bounds: CGRect;
  type: string;
}

export class CIFilter extends NSObject {
  static cMYKHalftone(): CIFilter;
  static labDeltaE(): CIFilter;
  static pDF417BarcodeGenerator(): CIFilter;
  static qRCodeGenerator(): CIFilter;
  static accordionFoldTransitionFilter(): CIFilter;
  static additionCompositingFilter(): CIFilter;
  static affineClampFilter(): CIFilter;
  static affineTileFilter(): CIFilter;
  static attributedTextImageGeneratorFilter(): CIFilter;
  static aztecCodeGeneratorFilter(): CIFilter;
  static barcodeGeneratorFilter(): CIFilter;
  static barsSwipeTransitionFilter(): CIFilter;
  static bicubicScaleTransformFilter(): CIFilter;
  static blendWithAlphaMaskFilter(): CIFilter;
  static blendWithBlueMaskFilter(): CIFilter;
  static blendWithMaskFilter(): CIFilter;
  static blendWithRedMaskFilter(): CIFilter;
  static bloomFilter(): CIFilter;
  static bokehBlurFilter(): CIFilter;
  static boxBlurFilter(): CIFilter;
  static checkerboardGeneratorFilter(): CIFilter;
  static circularScreenFilter(): CIFilter;
  static code128BarcodeGeneratorFilter(): CIFilter;
  static colorBlendModeFilter(): CIFilter;
  static colorBurnBlendModeFilter(): CIFilter;
  static colorClampFilter(): CIFilter;
  static colorControlsFilter(): CIFilter;
  static colorCrossPolynomialFilter(): CIFilter;
  static colorCubeFilter(): CIFilter;
  static colorCubeWithColorSpaceFilter(): CIFilter;
  static colorCubesMixedWithMaskFilter(): CIFilter;
  static colorCurvesFilter(): CIFilter;
  static colorDodgeBlendModeFilter(): CIFilter;
  static colorInvertFilter(): CIFilter;
  static colorMapFilter(): CIFilter;
  static colorMatrixFilter(): CIFilter;
  static colorMonochromeFilter(): CIFilter;
  static colorPolynomialFilter(): CIFilter;
  static colorPosterizeFilter(): CIFilter;
  static comicEffectFilter(): CIFilter;
  static convolution3X3Filter(): CIFilter;
  static convolution5X5Filter(): CIFilter;
  static convolution7X7Filter(): CIFilter;
  static convolution9HorizontalFilter(): CIFilter;
  static convolution9VerticalFilter(): CIFilter;
  static copyMachineTransitionFilter(): CIFilter;
  static coreMLModelFilter(): CIFilter;
  static crystallizeFilter(): CIFilter;
  static darkenBlendModeFilter(): CIFilter;
  static depthOfFieldFilter(): CIFilter;
  static depthToDisparityFilter(): CIFilter;
  static differenceBlendModeFilter(): CIFilter;
  static discBlurFilter(): CIFilter;
  static disintegrateWithMaskTransitionFilter(): CIFilter;
  static disparityToDepthFilter(): CIFilter;
  static dissolveTransitionFilter(): CIFilter;
  static ditherFilter(): CIFilter;
  static divideBlendModeFilter(): CIFilter;
  static documentEnhancerFilter(): CIFilter;
  static dotScreenFilter(): CIFilter;
  static edgePreserveUpsampleFilter(): CIFilter;
  static edgeWorkFilter(): CIFilter;
  static edgesFilter(): CIFilter;
  static eightfoldReflectedTileFilter(): CIFilter;
  static exclusionBlendModeFilter(): CIFilter;
  static exposureAdjustFilter(): CIFilter;
  static falseColorFilter(): CIFilter;
  static filterArrayFromSerializedXMPInputImageExtent(fromSerializedXMP: Data, inputImageExtent: CGRect): CIFilter[];
  static filterNamesInCategories(inCategories?: string[]): string[];
  static filterNamesInCategory(inCategory?: string): string[];
  static flashTransitionFilter(): CIFilter;
  static fourfoldReflectedTileFilter(): CIFilter;
  static fourfoldRotatedTileFilter(): CIFilter;
  static fourfoldTranslatedTileFilter(): CIFilter;
  static gaborGradientsFilter(): CIFilter;
  static gammaAdjustFilter(): CIFilter;
  static gaussianBlurFilter(): CIFilter;
  static gaussianGradientFilter(): CIFilter;
  static glideReflectedTileFilter(): CIFilter;
  static gloomFilter(): CIFilter;
  static hardLightBlendModeFilter(): CIFilter;
  static hatchedScreenFilter(): CIFilter;
  static heightFieldFromMaskFilter(): CIFilter;
  static hexagonalPixellateFilter(): CIFilter;
  static highlightShadowAdjustFilter(): CIFilter;
  static hueAdjustFilter(): CIFilter;
  static hueBlendModeFilter(): CIFilter;
  static hueSaturationValueGradientFilter(): CIFilter;
  static kaleidoscopeFilter(): CIFilter;
  static keystoneCorrectionCombinedFilter(): CIFilter;
  static keystoneCorrectionHorizontalFilter(): CIFilter;
  static keystoneCorrectionVerticalFilter(): CIFilter;
  static lanczosScaleTransformFilter(): CIFilter;
  static lenticularHaloGeneratorFilter(): CIFilter;
  static lightenBlendModeFilter(): CIFilter;
  static lineOverlayFilter(): CIFilter;
  static lineScreenFilter(): CIFilter;
  static linearBurnBlendModeFilter(): CIFilter;
  static linearDodgeBlendModeFilter(): CIFilter;
  static linearGradientFilter(): CIFilter;
  static linearToSRGBToneCurveFilter(): CIFilter;
  static localizedDescriptionForFilterName(forFilterName: string): string;
  static localizedNameForCategory(forCategory: string): string;
  static localizedNameForFilterName(forFilterName: string): string;
  static localizedReferenceDocumentationForFilterName(forFilterName: string): URL;
  static luminosityBlendModeFilter(): CIFilter;
  static maskToAlphaFilter(): CIFilter;
  static maskedVariableBlurFilter(): CIFilter;
  static maximumComponentFilter(): CIFilter;
  static maximumCompositingFilter(): CIFilter;
  static medianFilter(): CIFilter;
  static meshGeneratorFilter(): CIFilter;
  static minimumComponentFilter(): CIFilter;
  static minimumCompositingFilter(): CIFilter;
  static mixFilter(): CIFilter;
  static modTransitionFilter(): CIFilter;
  static morphologyGradientFilter(): CIFilter;
  static morphologyMaximumFilter(): CIFilter;
  static morphologyMinimumFilter(): CIFilter;
  static morphologyRectangleMaximumFilter(): CIFilter;
  static morphologyRectangleMinimumFilter(): CIFilter;
  static motionBlurFilter(): CIFilter;
  static multiplyBlendModeFilter(): CIFilter;
  static multiplyCompositingFilter(): CIFilter;
  static noiseReductionFilter(): CIFilter;
  static opTileFilter(): CIFilter;
  static overlayBlendModeFilter(): CIFilter;
  static pageCurlTransitionFilter(): CIFilter;
  static pageCurlWithShadowTransitionFilter(): CIFilter;
  static paletteCentroidFilter(): CIFilter;
  static palettizeFilter(): CIFilter;
  static parallelogramTileFilter(): CIFilter;
  static perspectiveCorrectionFilter(): CIFilter;
  static perspectiveRotateFilter(): CIFilter;
  static perspectiveTileFilter(): CIFilter;
  static perspectiveTransformFilter(): CIFilter;
  static perspectiveTransformWithExtentFilter(): CIFilter;
  static photoEffectChromeFilter(): CIFilter;
  static photoEffectFadeFilter(): CIFilter;
  static photoEffectInstantFilter(): CIFilter;
  static photoEffectMonoFilter(): CIFilter;
  static photoEffectNoirFilter(): CIFilter;
  static photoEffectProcessFilter(): CIFilter;
  static photoEffectTonalFilter(): CIFilter;
  static photoEffectTransferFilter(): CIFilter;
  static pinLightBlendModeFilter(): CIFilter;
  static pixellateFilter(): CIFilter;
  static pointillizeFilter(): CIFilter;
  static radialGradientFilter(): CIFilter;
  static randomGeneratorFilter(): CIFilter;
  static registerFilterNameConstructorClassAttributes(_: string, constructor: any, classAttributes: Map<string, any>): void;
  static rippleTransitionFilter(): CIFilter;
  static roundedRectangleGeneratorFilter(): CIFilter;
  static sRGBToneCurveToLinearFilter(): CIFilter;
  static saliencyMapFilter(): CIFilter;
  static saturationBlendModeFilter(): CIFilter;
  static screenBlendModeFilter(): CIFilter;
  static sepiaToneFilter(): CIFilter;
  static serializedXMPFromFiltersInputImageExtent(from: CIFilter[], inputImageExtent: CGRect): Data;
  static shadedMaterialFilter(): CIFilter;
  static sharpenLuminanceFilter(): CIFilter;
  static sixfoldReflectedTileFilter(): CIFilter;
  static sixfoldRotatedTileFilter(): CIFilter;
  static smoothLinearGradientFilter(): CIFilter;
  static softLightBlendModeFilter(): CIFilter;
  static sourceAtopCompositingFilter(): CIFilter;
  static sourceInCompositingFilter(): CIFilter;
  static sourceOutCompositingFilter(): CIFilter;
  static sourceOverCompositingFilter(): CIFilter;
  static spotColorFilter(): CIFilter;
  static spotLightFilter(): CIFilter;
  static starShineGeneratorFilter(): CIFilter;
  static straightenFilter(): CIFilter;
  static stripesGeneratorFilter(): CIFilter;
  static subtractBlendModeFilter(): CIFilter;
  static sunbeamsGeneratorFilter(): CIFilter;
  static supportedRawCameraModels(): string[];
  static swipeTransitionFilter(): CIFilter;
  static temperatureAndTintFilter(): CIFilter;
  static textImageGeneratorFilter(): CIFilter;
  static thermalFilter(): CIFilter;
  static toneCurveFilter(): CIFilter;
  static triangleKaleidoscopeFilter(): CIFilter;
  static triangleTileFilter(): CIFilter;
  static twelvefoldReflectedTileFilter(): CIFilter;
  static unsharpMaskFilter(): CIFilter;
  static vibranceFilter(): CIFilter;
  static vignetteEffectFilter(): CIFilter;
  static vignetteFilter(): CIFilter;
  static whitePointAdjustFilter(): CIFilter;
  static xRayFilter(): CIFilter;
  static zoomBlurFilter(): CIFilter;
  attributes: Map<string, any>;
  isEnabled: boolean;
  setEnabled(_: boolean);
  inputKeys: string[];
  //   //   name: string;
  setName(_: string);
  outputImage: CIImage;
  outputKeys: string[];
  applyArgumentsOptions(_: CIKernel, arguments_?: any[], options?: Map<string, any>): CIImage;
  // dupe name w instance property   name(): string;
  setDefaults(): void;
  setName(_: string): void;
  viewForUIConfigurationExcludedKeys(_: Map<any, any>, excludedKeys: any[]): IKFilterUIView;
}

interface CIFilterConstructor {
  filterWithName(withName: string): CIFilter;
}

export class CIFilterGenerator extends NSObject {
  classAttributes: Map<any, any>;
  setClassAttributes(_: Map<any, any>);
  exportedKeys: Map<any, any>;
  connectObjectWithKeyToObjectWithKey(_: any, withKey?: string, to?: any, withKey2?: string): void;
  disconnectObjectWithKeyToObjectWithKey(_: any, withKey: string, to: any, withKey2: string): void;
  exportKeyFromObjectWithName(_: string, from: any, withName?: string): void;
  filter(): CIFilter;
  static initWithContentsOfURL(_: URL): CIFilterGenerator;
  registerFilterName(_: string): void;
  removeExportedKey(_: string): void;
  setAttributesForExportedKey(_: Map<any, any>, forExportedKey: string): void;
  writeToURLAtomically(to: URL, atomically: boolean): boolean;
}

interface CIFilterProtocol {
  outputImage: CIImage;
}

export class CIFilterShape extends NSObject {
  extent: CGRect;
  static initWithRect(_: CGRect): CIFilterShape;
  insetByXY(x: number, y: number): CIFilterShape;
  intersectWith(with_: CIFilterShape): CIFilterShape;
  intersectWithRect(with_: CGRect): CIFilterShape;
  transformByInterior(by: CGAffineTransform, interior: boolean): CIFilterShape;
  unionWith(with_: CIFilterShape): CIFilterShape;
  unionWithRect(with_: CGRect): CIFilterShape;
}

interface CIFlashTransition {
  center: CGPoint;
  setCenter(_: CGPoint);
  color: CIColor;
  setColor(_: CIColor);
  extent: CGRect;
  setExtent(_: CGRect);
  fadeThreshold: number;
  setFadeThreshold(_: number);
  maxStriationRadius: number;
  setMaxStriationRadius(_: number);
  striationContrast: number;
  setStriationContrast(_: number);
  striationStrength: number;
  setStriationStrength(_: number);
}

interface CIFourCoordinateGeometryFilter {
  bottomLeft: CGPoint;
  setBottomLeft(_: CGPoint);
  bottomRight: CGPoint;
  setBottomRight(_: CGPoint);
  inputImage: CIImage;
  setInputImage(_: CIImage);
  topLeft: CGPoint;
  setTopLeft(_: CGPoint);
  topRight: CGPoint;
  setTopRight(_: CGPoint);
}

interface CIFourfoldReflectedTile {
  acuteAngle: number;
  setAcuteAngle(_: number);
  angle: number;
  setAngle(_: number);
  center: CGPoint;
  setCenter(_: CGPoint);
  inputImage: CIImage;
  setInputImage(_: CIImage);
  width: number;
  setWidth(_: number);
}

interface CIFourfoldRotatedTile {
  angle: number;
  setAngle(_: number);
  center: CGPoint;
  setCenter(_: CGPoint);
  inputImage: CIImage;
  setInputImage(_: CIImage);
  width: number;
  setWidth(_: number);
}

interface CIFourfoldTranslatedTile {
  acuteAngle: number;
  setAcuteAngle(_: number);
  angle: number;
  setAngle(_: number);
  center: CGPoint;
  setCenter(_: CGPoint);
  inputImage: CIImage;
  setInputImage(_: CIImage);
  width: number;
  setWidth(_: number);
}

interface CIGaborGradients {
  inputImage: CIImage;
  setInputImage(_: CIImage);
}

interface CIGammaAdjust {
  inputImage: CIImage;
  setInputImage(_: CIImage);
}

interface CIGaussianBlur {
  inputImage: CIImage;
  setInputImage(_: CIImage);
  radius: number;
  setRadius(_: number);
}

interface CIGaussianGradient {
  center: CGPoint;
  setCenter(_: CGPoint);
  color0: CIColor;
  setColor0(_: CIColor);
  color1: CIColor;
  setColor1(_: CIColor);
  radius: number;
  setRadius(_: number);
}

interface CIGlideReflectedTile {
  angle: number;
  setAngle(_: number);
  center: CGPoint;
  setCenter(_: CGPoint);
  inputImage: CIImage;
  setInputImage(_: CIImage);
  width: number;
  setWidth(_: number);
}

interface CIGloom {
  inputImage: CIImage;
  setInputImage(_: CIImage);
  intensity: number;
  setIntensity(_: number);
  radius: number;
  setRadius(_: number);
}

interface CIHatchedScreen {
  angle: number;
  setAngle(_: number);
  center: CGPoint;
  setCenter(_: CGPoint);
  inputImage: CIImage;
  setInputImage(_: CIImage);
  sharpness: number;
  setSharpness(_: number);
  width: number;
  setWidth(_: number);
}

interface CIHeightFieldFromMask {
  inputImage: CIImage;
  setInputImage(_: CIImage);
  radius: number;
  setRadius(_: number);
}

interface CIHexagonalPixellate {
  center: CGPoint;
  setCenter(_: CGPoint);
  inputImage: CIImage;
  setInputImage(_: CIImage);
  scale: number;
  setScale(_: number);
}

interface CIHighlightShadowAdjust {
  highlightAmount: number;
  setHighlightAmount(_: number);
  inputImage: CIImage;
  setInputImage(_: CIImage);
  radius: number;
  setRadius(_: number);
  shadowAmount: number;
  setShadowAmount(_: number);
}

interface CIHueAdjust {
  angle: number;
  setAngle(_: number);
  inputImage: CIImage;
  setInputImage(_: CIImage);
}

interface CIHueSaturationValueGradient {
  colorSpace: any;
  setColorSpace(_: any);
  dither: number;
  setDither(_: number);
  radius: number;
  setRadius(_: number);
  softness: number;
  setSoftness(_: number);
  value: number;
  setValue(_: number);
}

export class CIImage extends NSObject {
  static emptyImage(): CIImage;
  static imageWithDepthData(_: AVDepthData): CIImage;
  static imageWithDepthDataOptions(_: AVDepthData, options?: Map<string, any>): CIImage;
  static imageWithImageProviderSizeFormatColorSpaceOptions(_: any, _2: number, size: number, format: number, colorSpace?: any, options?: Map<string, any>): CIImage;
  static imageWithPortaitEffectsMatte(_: AVPortraitEffectsMatte): CIImage;
  static imageWithPortaitEffectsMatteOptions(_: AVPortraitEffectsMatte, options?: Map<string, any>): CIImage;
  static imageWithSemanticSegmentationMatte(_: AVSemanticSegmentationMatte): CIImage;
  static imageWithSemanticSegmentationMatteOptions(_: AVSemanticSegmentationMatte, options?: Map<string, any>): CIImage;
  CGImage: any;
  colorSpace: any;
  definition: CIFilterShape;
  depthData: AVDepthData;
  extent: CGRect;
  pixelBuffer: any;
  portraitEffectsMatte: AVPortraitEffectsMatte;
  properties: Map<string, any>;
  semanticSegmentationMatte: AVSemanticSegmentationMatte;
  url: URL;
  static blackImage: CIImage;
  static blueImage: CIImage;
  static clearImage: CIImage;
  static cyanImage: CIImage;
  static grayImage: CIImage;
  static greenImage: CIImage;
  static magentaImage: CIImage;
  static redImage: CIImage;
  static whiteImage: CIImage;
  static yellowImage: CIImage;
  autoAdjustmentFilters(): CIFilter[];
  autoAdjustmentFiltersWithOptions(options?: Map<string, any>): CIFilter[];
  drawAtPointFromRectOperationFraction(at: CGPoint, from: CGRect, operation: NSGraphics.NSCompositingOperation, fraction: number): void;
  drawInRectFromRectOperationFraction(in_: CGRect, from: CGRect, operation: NSGraphics.NSCompositingOperation, fraction: number): void;
  imageByApplyingCGOrientation(_: CGImageProperties.CGImagePropertyOrientation): CIImage;
  imageByApplyingFilter(_: string): CIImage;
  imageByApplyingFilterWithInputParameters(_: string, parameters?: Map<string, any>): CIImage;
  imageByApplyingGaussianBlurWithSigma(sigma: number): CIImage;
  imageByApplyingOrientation(forExifOrientation: number): CIImage;
  imageByApplyingTransform(by: CGAffineTransform): CIImage;
  imageByApplyingTransformHighQualityDownsample(by: CGAffineTransform, highQualityDownsample: boolean): CIImage;
  imageByClampingToExtent(): CIImage;
  imageByClampingToRect(to: CGRect): CIImage;
  imageByColorMatchingColorSpaceToWorkingSpace(from: any): CIImage;
  imageByColorMatchingWorkingSpaceToColorSpace(to: any): CIImage;
  imageByCompositingOverImage(over: CIImage): CIImage;
  imageByCroppingToRect(to: CGRect): CIImage;
  imageByInsertingIntermediate(): CIImage;
  imageByInsertingIntermediate(cache: boolean): CIImage;
  imageByPremultiplyingAlpha(): CIImage;
  imageBySamplingLinear(): CIImage;
  imageBySamplingNearest(): CIImage;
  imageBySettingAlphaOneInExtent(in_: CGRect): CIImage;
  imageBySettingProperties(_: Map<any, any>): CIImage;
  imageByUnpremultiplyingAlpha(): CIImage;
  imageTransformForCGOrientation(for_: CGImageProperties.CGImagePropertyOrientation): CGAffineTransform;
  imageTransformForOrientation(forExifOrientation: number): CGAffineTransform;
  static initWithBitmapDataBytesPerRowSizeFormatColorSpace(_: Data, bytesPerRow: number, size: CGSize, format: number, colorSpace?: any): CIImage;
  static initWithBitmapImageRep(_: NSBitmapImageRep): CIImage;
  static initWithCGImage(_: any): CIImage;
  static initWithCGImageOptions(_: any, options?: Map<string, any>): CIImage;
  static initWithCGImageSourceIndexOptions(_: any, index: number, options?: Map<string, any>): CIImage;
  static initWithCVImageBuffer(_: any): CIImage;
  static initWithCVImageBufferOptions(_: any, options?: Map<string, any>): CIImage;
  static initWithCVPixelBuffer(_: any): CIImage;
  static initWithCVPixelBufferOptions(_: any, options?: Map<string, any>): CIImage;
  static initWithColor(_: CIColor): CIImage;
  static initWithContentsOfURL(_: URL): CIImage;
  static initWithContentsOfURLOptions(_: URL, options?: Map<string, any>): CIImage;
  static initWithData(_: Data): CIImage;
  static initWithDataOptions(_: Data, options?: Map<string, any>): CIImage;
  static initWithDepthData(_: AVDepthData): CIImage;
  static initWithDepthDataOptions(_: AVDepthData, options?: Map<string, any>): CIImage;
  static initWithIOSurface(_: any): CIImage;
  static initWithIOSurfaceOptions(_: any, options?: Map<string, any>): CIImage;
  static initWithImageProviderSizeFormatColorSpaceOptions(_: any, _2: number, size: number, format: number, colorSpace?: any, options?: Map<string, any>): CIImage;
  static initWithMTLTextureOptions(_: any, options?: Map<string, any>): CIImage;
  static initWithPortaitEffectsMatte(_: AVPortraitEffectsMatte): CIImage;
  static initWithPortaitEffectsMatteOptions(_: AVPortraitEffectsMatte, options?: Map<string, any>): CIImage;
  static initWithSemanticSegmentationMatte(_: AVSemanticSegmentationMatte): CIImage;
  static initWithSemanticSegmentationMatteOptions(_: AVSemanticSegmentationMatte, options?: Map<string, any>): CIImage;
  regionOfInterestForImageInRect(for_: CIImage, in_: CGRect): CGRect;
}

export class CIImageAccumulator extends NSObject {
  extent: CGRect;
  format: number;
  clear(): void;
  image(): CIImage;
  static initWithExtentFormat(_: CGRect, format: number): CIImageAccumulator;
  static initWithExtentFormatColorSpace(_: CGRect, format: number, colorSpace: any): CIImageAccumulator;
  setImage(_: CIImage): void;
  setImageDirtyRect(_: CIImage, dirtyRect: CGRect): void;
}

interface CIImageProcessorInput {
  baseAddress: any;
  bytesPerRow: number;
  format: number;
  metalTexture: any;
  pixelBuffer: any;
  region: CGRect;
  surface: any;
}

export class CIImageProcessorKernel extends NSObject {
  static applyWithExtentInputsArguments(inputs: CGRect, arguments_?: CIImage[], error?: Map<string, any>): CIImage;
  static formatForInputAtIndex(at: number): number;
  static processWithInputsArgumentsOutput(arguments_?: any[], output?: Map<string, any>, error?: any): boolean;
  static roiForInputArgumentsOutputRect(forInput: number, arguments_?: Map<string, any>, outputRect?: CGRect): CGRect;
  static outputFormat: number;
  static outputIsOpaque: boolean;
  static synchronizeInputs: boolean;
}

interface CIImageProcessorOutput {
  baseAddress: any;
  bytesPerRow: number;
  format: number;
  metalCommandBuffer: any;
  metalTexture: any;
  pixelBuffer: any;
  region: CGRect;
  surface: any;
}

interface CIKaleidoscope {
  angle: number;
  setAngle(_: number);
  center: CGPoint;
  setCenter(_: CGPoint);
  count: number;
  setCount(_: number);
  inputImage: CIImage;
  setInputImage(_: CIImage);
}

export class CIKernel extends NSObject {
  static kernelWithFunctionNameFromMetalLibraryData(fromMetalLibraryData: string, error: Data): CIKernel;
  static kernelWithFunctionNameFromMetalLibraryDataOutputPixelFormat(fromMetalLibraryData: string, outputPixelFormat: Data, error: number): CIKernel;
  name: string;
  applyWithExtentRoiCallbackArguments(extent: CGRect, roiCallback: (p1: number, p2: CGRect) => CGRect, arguments_?: any[]): CIImage;
  setROISelector(_: string): void;
}

interface CIKeystoneCorrectionCombined {
  focalLength: number;
  setFocalLength(_: number);
}

interface CIKeystoneCorrectionHorizontal {
  focalLength: number;
  setFocalLength(_: number);
}

interface CIKeystoneCorrectionVertical {
  focalLength: number;
  setFocalLength(_: number);
}

interface CILabDeltaE {
  image2: CIImage;
  setImage2(_: CIImage);
  inputImage: CIImage;
  setInputImage(_: CIImage);
}

interface CILanczosScaleTransform {
  aspectRatio: number;
  setAspectRatio(_: number);
  inputImage: CIImage;
  setInputImage(_: CIImage);
  scale: number;
  setScale(_: number);
}

interface CILenticularHaloGenerator {
  center: CGPoint;
  setCenter(_: CGPoint);
  color: CIColor;
  setColor(_: CIColor);
  haloOverlap: number;
  setHaloOverlap(_: number);
  haloRadius: number;
  setHaloRadius(_: number);
  haloWidth: number;
  setHaloWidth(_: number);
  striationContrast: number;
  setStriationContrast(_: number);
  striationStrength: number;
  setStriationStrength(_: number);
  time: number;
  setTime(_: number);
}

interface CILineOverlay {
  contrast: number;
  setContrast(_: number);
  edgeIntensity: number;
  setEdgeIntensity(_: number);
  inputImage: CIImage;
  setInputImage(_: CIImage);
  NRNoiseLevel: number;
  setNRNoiseLevel(_: number);
  NRSharpness: number;
  setNRSharpness(_: number);
  threshold: number;
  setThreshold(_: number);
}

interface CILineScreen {
  angle: number;
  setAngle(_: number);
  center: CGPoint;
  setCenter(_: CGPoint);
  inputImage: CIImage;
  setInputImage(_: CIImage);
  sharpness: number;
  setSharpness(_: number);
  width: number;
  setWidth(_: number);
}

interface CILinearGradient {
  color0: CIColor;
  setColor0(_: CIColor);
  color1: CIColor;
  setColor1(_: CIColor);
  point0: CGPoint;
  setPoint0(_: CGPoint);
  point1: CGPoint;
  setPoint1(_: CGPoint);
}

interface CILinearToSRGBToneCurve {
  inputImage: CIImage;
  setInputImage(_: CIImage);
}

interface CIMaskToAlpha {
  inputImage: CIImage;
  setInputImage(_: CIImage);
}

interface CIMaskedVariableBlur {
  inputImage: CIImage;
  setInputImage(_: CIImage);
  mask: CIImage;
  setMask(_: CIImage);
  radius: number;
  setRadius(_: number);
}

interface CIMaximumComponent {
  inputImage: CIImage;
  setInputImage(_: CIImage);
}

interface CIMedian {
  inputImage: CIImage;
  setInputImage(_: CIImage);
}

interface CIMeshGenerator {
  color: CIColor;
  setColor(_: CIColor);
  mesh: any[];
  setMesh(_: any[]);
  width: number;
  setWidth(_: number);
}

interface CIMinimumComponent {
  inputImage: CIImage;
  setInputImage(_: CIImage);
}

interface CIMix {
  amount: number;
  setAmount(_: number);
  backgroundImage: CIImage;
  setBackgroundImage(_: CIImage);
  inputImage: CIImage;
  setInputImage(_: CIImage);
}

interface CIModTransition {
  angle: number;
  setAngle(_: number);
  center: CGPoint;
  setCenter(_: CGPoint);
  compression: number;
  setCompression(_: number);
  radius: number;
  setRadius(_: number);
}

interface CIMorphologyGradient {
  inputImage: CIImage;
  setInputImage(_: CIImage);
  radius: number;
  setRadius(_: number);
}

interface CIMorphologyMaximum {
  inputImage: CIImage;
  setInputImage(_: CIImage);
  radius: number;
  setRadius(_: number);
}

interface CIMorphologyMinimum {
  inputImage: CIImage;
  setInputImage(_: CIImage);
  radius: number;
  setRadius(_: number);
}

interface CIMorphologyRectangleMaximum {
  height: number;
  setHeight(_: number);
  inputImage: CIImage;
  setInputImage(_: CIImage);
  width: number;
  setWidth(_: number);
}

interface CIMorphologyRectangleMinimum {
  height: number;
  setHeight(_: number);
  inputImage: CIImage;
  setInputImage(_: CIImage);
  width: number;
  setWidth(_: number);
}

interface CIMotionBlur {
  angle: number;
  setAngle(_: number);
  inputImage: CIImage;
  setInputImage(_: CIImage);
  radius: number;
  setRadius(_: number);
}

interface CINoiseReduction {
  inputImage: CIImage;
  setInputImage(_: CIImage);
  noiseLevel: number;
  setNoiseLevel(_: number);
  sharpness: number;
  setSharpness(_: number);
}

interface CIOpTile {
  angle: number;
  setAngle(_: number);
  center: CGPoint;
  setCenter(_: CGPoint);
  inputImage: CIImage;
  setInputImage(_: CIImage);
  scale: number;
  setScale(_: number);
  width: number;
  setWidth(_: number);
}

interface CIPDF417BarcodeGenerator {
  alwaysSpecifyCompaction: number;
  setAlwaysSpecifyCompaction(_: number);
  compactionMode: number;
  setCompactionMode(_: number);
  compactStyle: number;
  setCompactStyle(_: number);
  correctionLevel: number;
  setCorrectionLevel(_: number);
  dataColumns: number;
  setDataColumns(_: number);
  maxHeight: number;
  setMaxHeight(_: number);
  maxWidth: number;
  setMaxWidth(_: number);
  message: Data;
  setMessage(_: Data);
  minHeight: number;
  setMinHeight(_: number);
  minWidth: number;
  setMinWidth(_: number);
  preferredAspectRatio: number;
  setPreferredAspectRatio(_: number);
  rows: number;
  setRows(_: number);
}

export class CIPDF417CodeDescriptor extends CIBarcodeDescriptor {
  columnCount: number;
  errorCorrectedPayload: Data;
  isCompact: boolean;
  rowCount: number;
  static initWithPayloadIsCompactRowCountColumnCount(_: Data, isCompact: boolean, rowCount: number, columnCount: number): CIPDF417CodeDescriptor;
}

interface CIPageCurlTransition {
  angle: number;
  setAngle(_: number);
  backsideImage: CIImage;
  setBacksideImage(_: CIImage);
  extent: CGRect;
  setExtent(_: CGRect);
  radius: number;
  setRadius(_: number);
  shadingImage: CIImage;
  setShadingImage(_: CIImage);
}

interface CIPageCurlWithShadowTransition {
  angle: number;
  setAngle(_: number);
  backsideImage: CIImage;
  setBacksideImage(_: CIImage);
  extent: CGRect;
  setExtent(_: CGRect);
  radius: number;
  setRadius(_: number);
  shadowAmount: number;
  setShadowAmount(_: number);
  shadowExtent: CGRect;
  setShadowExtent(_: CGRect);
  shadowSize: number;
  setShadowSize(_: number);
}

interface CIPaletteCentroid {
  inputImage: CIImage;
  setInputImage(_: CIImage);
  paletteImage: CIImage;
  setPaletteImage(_: CIImage);
  perceptual: boolean;
  setPerceptual(_: boolean);
}

interface CIPalettize {
  inputImage: CIImage;
  setInputImage(_: CIImage);
  paletteImage: CIImage;
  setPaletteImage(_: CIImage);
  perceptual: boolean;
  setPerceptual(_: boolean);
}

interface CIParallelogramTile {
  acuteAngle: number;
  setAcuteAngle(_: number);
  angle: number;
  setAngle(_: number);
  center: CGPoint;
  setCenter(_: CGPoint);
  inputImage: CIImage;
  setInputImage(_: CIImage);
  width: number;
  setWidth(_: number);
}

interface CIPerspectiveCorrection {
  crop: boolean;
  setCrop(_: boolean);
}

interface CIPerspectiveRotate {
  focalLength: number;
  setFocalLength(_: number);
  inputImage: CIImage;
  setInputImage(_: CIImage);
  pitch: number;
  setPitch(_: number);
  roll: number;
  setRoll(_: number);
  yaw: number;
  setYaw(_: number);
}

interface CIPerspectiveTile {
  bottomLeft: CGPoint;
  setBottomLeft(_: CGPoint);
  bottomRight: CGPoint;
  setBottomRight(_: CGPoint);
  inputImage: CIImage;
  setInputImage(_: CIImage);
  topLeft: CGPoint;
  setTopLeft(_: CGPoint);
  topRight: CGPoint;
  setTopRight(_: CGPoint);
}

interface CIPerspectiveTransform {
}

interface CIPerspectiveTransformWithExtent {
  extent: CGRect;
  setExtent(_: CGRect);
}

interface CIPhotoEffect {
  inputImage: CIImage;
  setInputImage(_: CIImage);
}

interface CIPixellate {
  center: CGPoint;
  setCenter(_: CGPoint);
  inputImage: CIImage;
  setInputImage(_: CIImage);
  scale: number;
  setScale(_: number);
}

export class CIPlugIn extends NSObject {
  static loadNonExecutablePlugIn(_: URL): void;
  static loadNonExecutablePlugIns(): void;
}

interface CIPlugInRegistration {
  load(_: any): boolean;
}

interface CIPointillize {
  center: CGPoint;
  setCenter(_: CGPoint);
  inputImage: CIImage;
  setInputImage(_: CIImage);
  radius: number;
  setRadius(_: number);
}

export class CIQRCodeDescriptor extends CIBarcodeDescriptor {
  errorCorrectedPayload: Data;
  errorCorrectionLevel: CIBarcodeDescriptor.CIQRCodeErrorCorrectionLevel;
  maskPattern: number;
  symbolVersion: number;
  static initWithPayloadSymbolVersionMaskPatternErrorCorrectionLevel(_: Data, symbolVersion: number, maskPattern: number, errorCorrectionLevel: CIBarcodeDescriptor.CIQRCodeErrorCorrectionLevel): CIQRCodeDescriptor;
}

export class CIQRCodeFeature extends CIFeature {
  bottomLeft: CGPoint;
  bottomRight: CGPoint;
  messageString: string;
  symbolDescriptor: CIQRCodeDescriptor;
  topLeft: CGPoint;
  topRight: CGPoint;
}

interface CIQRCodeGenerator {
  correctionLevel: string;
  setCorrectionLevel(_: string);
  message: Data;
  setMessage(_: Data);
}

interface CIRadialGradient {
  center: CGPoint;
  setCenter(_: CGPoint);
  color0: CIColor;
  setColor0(_: CIColor);
  color1: CIColor;
  setColor1(_: CIColor);
  radius0: number;
  setRadius0(_: number);
  radius1: number;
  setRadius1(_: number);
}

interface CIRandomGenerator {
}

export class CIRectangleFeature extends CIFeature {
  bottomLeft: CGPoint;
  bottomRight: CGPoint;
  topLeft: CGPoint;
  topRight: CGPoint;
}

export class CIRenderDestination extends NSObject {
  alphaMode: CIRenderDestination.CIRenderDestinationAlphaMode;
  setAlphaMode(_: CIRenderDestination.CIRenderDestinationAlphaMode);
  blendKernel: CIBlendKernel;
  setBlendKernel(_: CIBlendKernel);
  blendsInDestinationColorSpace: boolean;
  setBlendsInDestinationColorSpace(_: boolean);
  isClamped: boolean;
  setClamped(_: boolean);
  colorSpace: any;
  setColorSpace(_: any);
  isDithered: boolean;
  setDithered(_: boolean);
  isFlipped: boolean;
  setFlipped(_: boolean);
  height: number;
  width: number;
  static initWithBitmapDataWidthHeightBytesPerRowFormat(_: any, width: number, height: number, bytesPerRow: number, format: number): CIRenderDestination;
  static initWithGLTextureTargetWidthHeight(_: number, target: number, width: number, height: number): CIRenderDestination;
  static initWithIOSurface(_: IOSurface): CIRenderDestination;
  static initWithMTLTextureCommandBuffer(_: any, commandBuffer?: any): CIRenderDestination;
  static initWithPixelBuffer(_: any): CIRenderDestination;
  static initWithWidthHeightPixelFormatCommandBufferMtlTextureProvider(_: number, height: number, pixelFormat: MTLPixelFormat.MTLPixelFormat, commandBuffer?: any, mtlTextureProvider?: () => any): CIRenderDestination;
}

export class CIRenderInfo extends NSObject {
  kernelExecutionTime: number;
  passCount: number;
  pixelsProcessed: number;
}

export class CIRenderTask extends NSObject {
  waitUntilCompletedAndReturnError(): CIRenderInfo;
}

interface CIRippleTransition {
  center: CGPoint;
  setCenter(_: CGPoint);
  extent: CGRect;
  setExtent(_: CGRect);
  scale: number;
  setScale(_: number);
  shadingImage: CIImage;
  setShadingImage(_: CIImage);
  width: number;
  setWidth(_: number);
}

interface CIRoundedRectangleGenerator {
  color: CIColor;
  setColor(_: CIColor);
  extent: CGRect;
  setExtent(_: CGRect);
  radius: number;
  setRadius(_: number);
}

interface CISRGBToneCurveToLinear {
  inputImage: CIImage;
  setInputImage(_: CIImage);
}

interface CISaliencyMap {
  inputImage: CIImage;
  setInputImage(_: CIImage);
}

export class CISampler extends NSObject {
  static samplerWithImageKeysAndValues(_: CIImage, keysAndValues: any): CISampler;
  definition: CIFilterShape;
  extent: CGRect;
  static initWithImage(_: CIImage): CISampler;
  static initWithImageOptions(_: CIImage, options?: Map<any, any>): CISampler;
}

interface CISepiaTone {
  inputImage: CIImage;
  setInputImage(_: CIImage);
  intensity: number;
  setIntensity(_: number);
}

interface CIShadedMaterial {
  inputImage: CIImage;
  setInputImage(_: CIImage);
  scale: number;
  setScale(_: number);
  shadingImage: CIImage;
  setShadingImage(_: CIImage);
}

interface CISharpenLuminance {
  inputImage: CIImage;
  setInputImage(_: CIImage);
  radius: number;
  setRadius(_: number);
  sharpness: number;
  setSharpness(_: number);
}

interface CISixfoldReflectedTile {
  angle: number;
  setAngle(_: number);
  center: CGPoint;
  setCenter(_: CGPoint);
  inputImage: CIImage;
  setInputImage(_: CIImage);
  width: number;
  setWidth(_: number);
}

interface CISixfoldRotatedTile {
  angle: number;
  setAngle(_: number);
  center: CGPoint;
  setCenter(_: CGPoint);
  inputImage: CIImage;
  setInputImage(_: CIImage);
  width: number;
  setWidth(_: number);
}

interface CISmoothLinearGradient {
  color0: CIColor;
  setColor0(_: CIColor);
  color1: CIColor;
  setColor1(_: CIColor);
  point0: CGPoint;
  setPoint0(_: CGPoint);
  point1: CGPoint;
  setPoint1(_: CGPoint);
}

interface CISpotColor {
  centerColor1: CIColor;
  setCenterColor1(_: CIColor);
  centerColor2: CIColor;
  setCenterColor2(_: CIColor);
  centerColor3: CIColor;
  setCenterColor3(_: CIColor);
  closeness1: number;
  setCloseness1(_: number);
  closeness2: number;
  setCloseness2(_: number);
  closeness3: number;
  setCloseness3(_: number);
  contrast1: number;
  setContrast1(_: number);
  contrast2: number;
  setContrast2(_: number);
  contrast3: number;
  setContrast3(_: number);
  inputImage: CIImage;
  setInputImage(_: CIImage);
  replacementColor1: CIColor;
  setReplacementColor1(_: CIColor);
  replacementColor2: CIColor;
  setReplacementColor2(_: CIColor);
  replacementColor3: CIColor;
  setReplacementColor3(_: CIColor);
}

interface CISpotLight {
  brightness: number;
  setBrightness(_: number);
  color: CIColor;
  setColor(_: CIColor);
  concentration: number;
  setConcentration(_: number);
  inputImage: CIImage;
  setInputImage(_: CIImage);
  lightPointsAt: CIVector;
  setLightPointsAt(_: CIVector);
  lightPosition: CIVector;
  setLightPosition(_: CIVector);
}

interface CIStarShineGenerator {
  center: CGPoint;
  setCenter(_: CGPoint);
  color: CIColor;
  setColor(_: CIColor);
  crossAngle: number;
  setCrossAngle(_: number);
  crossOpacity: number;
  setCrossOpacity(_: number);
  crossScale: number;
  setCrossScale(_: number);
  crossWidth: number;
  setCrossWidth(_: number);
  epsilon: number;
  setEpsilon(_: number);
  radius: number;
  setRadius(_: number);
}

interface CIStraighten {
  angle: number;
  setAngle(_: number);
  inputImage: CIImage;
  setInputImage(_: CIImage);
}

interface CIStripesGenerator {
  center: CGPoint;
  setCenter(_: CGPoint);
  color0: CIColor;
  setColor0(_: CIColor);
  color1: CIColor;
  setColor1(_: CIColor);
  sharpness: number;
  setSharpness(_: number);
  width: number;
  setWidth(_: number);
}

interface CISunbeamsGenerator {
  center: CGPoint;
  setCenter(_: CGPoint);
  color: CIColor;
  setColor(_: CIColor);
  maxStriationRadius: number;
  setMaxStriationRadius(_: number);
  striationContrast: number;
  setStriationContrast(_: number);
  striationStrength: number;
  setStriationStrength(_: number);
  sunRadius: number;
  setSunRadius(_: number);
  time: number;
  setTime(_: number);
}

interface CISwipeTransition {
  angle: number;
  setAngle(_: number);
  color: CIColor;
  setColor(_: CIColor);
  extent: CGRect;
  setExtent(_: CGRect);
  opacity: number;
  setOpacity(_: number);
  width: number;
  setWidth(_: number);
}

interface CITemperatureAndTint {
  inputImage: CIImage;
  setInputImage(_: CIImage);
  neutral: CIVector;
  setNeutral(_: CIVector);
  targetNeutral: CIVector;
  setTargetNeutral(_: CIVector);
}

export class CITextFeature extends CIFeature {
  bottomLeft: CGPoint;
  bottomRight: CGPoint;
  subFeatures: any[];
  topLeft: CGPoint;
  topRight: CGPoint;
}

interface CITextImageGenerator {
  fontName: string;
  setFontName(_: string);
  fontSize: number;
  setFontSize(_: number);
  scaleFactor: number;
  setScaleFactor(_: number);
  text: string;
  setText(_: string);
}

interface CIThermal {
  inputImage: CIImage;
  setInputImage(_: CIImage);
}

interface CIToneCurve {
  inputImage: CIImage;
  setInputImage(_: CIImage);
  point0: CGPoint;
  setPoint0(_: CGPoint);
  point1: CGPoint;
  setPoint1(_: CGPoint);
  point2: CGPoint;
  setPoint2(_: CGPoint);
  point3: CGPoint;
  setPoint3(_: CGPoint);
  point4: CGPoint;
  setPoint4(_: CGPoint);
}

interface CITransitionFilter {
  inputImage: CIImage;
  setInputImage(_: CIImage);
  targetImage: CIImage;
  setTargetImage(_: CIImage);
  time: number;
  setTime(_: number);
}

interface CITriangleKaleidoscope {
  decay: number;
  setDecay(_: number);
  inputImage: CIImage;
  setInputImage(_: CIImage);
  point: CGPoint;
  setPoint(_: CGPoint);
  rotation: number;
  setRotation(_: number);
  size: number;
  setSize(_: number);
}

interface CITriangleTile {
  angle: number;
  setAngle(_: number);
  center: CGPoint;
  setCenter(_: CGPoint);
  inputImage: CIImage;
  setInputImage(_: CIImage);
  width: number;
  setWidth(_: number);
}

interface CITwelvefoldReflectedTile {
  angle: number;
  setAngle(_: number);
  center: CGPoint;
  setCenter(_: CGPoint);
  inputImage: CIImage;
  setInputImage(_: CIImage);
  width: number;
  setWidth(_: number);
}

interface CIUnsharpMask {
  inputImage: CIImage;
  setInputImage(_: CIImage);
  intensity: number;
  setIntensity(_: number);
  radius: number;
  setRadius(_: number);
}

export class CIVector extends NSObject {
  CGAffineTransformValue: CGAffineTransform;
  CGPointValue: CGPoint;
  CGRectValue: CGRect;
  W: number;
  X: number;
  Y: number;
  Z: number;
  count: number;
  stringRepresentation: string;
  static initWithCGAffineTransform(_: CGAffineTransform): CIVector;
  static initWithCGPoint(_: CGPoint): CIVector;
  static initWithCGRect(_: CGRect): CIVector;
  static initWithString(_: string): CIVector;
  static initWithValuesCount(_: number, count: number): CIVector;
  static initWithX(_: number): CIVector;
  static initWithXY(_: number, Y: number): CIVector;
  static initWithXYZ(_: number, Y: number, Z: number): CIVector;
  static initWithXYZW(_: number, Y: number, Z: number, W: number): CIVector;
  valueAtIndex(at: number): number;
}

interface CIVibrance {
  amount: number;
  setAmount(_: number);
  inputImage: CIImage;
  setInputImage(_: CIImage);
}

interface CIVignette {
  inputImage: CIImage;
  setInputImage(_: CIImage);
  intensity: number;
  setIntensity(_: number);
  radius: number;
  setRadius(_: number);
}

interface CIVignetteEffect {
  center: CGPoint;
  setCenter(_: CGPoint);
  falloff: number;
  setFalloff(_: number);
  inputImage: CIImage;
  setInputImage(_: CIImage);
  intensity: number;
  setIntensity(_: number);
  radius: number;
  setRadius(_: number);
}

export class CIWarpKernel extends CIKernel {
  //  static kernelWithFunctionNameFromMetalLibraryData(fromMetalLibraryData: string, error: Data): CIWarpKernel;
  //  static kernelWithFunctionNameFromMetalLibraryDataOutputPixelFormat(fromMetalLibraryData: string, outputPixelFormat: Data, error: number): CIWarpKernel;
  applyWithExtentRoiCallbackInputImageArguments(extent: CGRect, roiCallback: (p1: number, p2: CGRect) => CGRect, image: CIImage, arguments_?: any[]): CIImage;
}

interface CIWhitePointAdjust {
  color: CIColor;
  setColor(_: CIColor);
  inputImage: CIImage;
  setInputImage(_: CIImage);
}

interface CIXRay {
  inputImage: CIImage;
  setInputImage(_: CIImage);
}

interface CIZoomBlur {
  amount: number;
  setAmount(_: number);
  center: CGPoint;
  setCenter(_: CGPoint);
  inputImage: CIImage;
  setInputImage(_: CIImage);
}

// export function CMAudioClockCreate(allocator: any, clockOut: any): number;

// export function CMAudioDeviceClockCreate(allocator: any, deviceUID: string, clockOut: any): number;

// export function CMAudioDeviceClockCreateFromAudioDeviceID(allocator: any, deviceID: number, clockOut: any): number;

// export function CMAudioDeviceClockGetAudioDevice(clock: any, deviceUIDOut: string, deviceIDOut: number, trackingDefaultDeviceOut: string | any): number;

// export function CMAudioDeviceClockSetAudioDeviceID(clock: any, deviceID: number): number;

// export function CMAudioDeviceClockSetAudioDeviceUID(clock: any, deviceUID: string): number;

// export function CMAudioFormatDescriptionCopyAsBigEndianSoundDescriptionBlockBuffer(allocator: any, audioFormatDescription: any, flavor: any, blockBufferOut: any): number;

// export function CMAudioFormatDescriptionCreate(allocator: any, asbd: AudioStreamBasicDescription, layoutSize: number, layout: AudioChannelLayout, magicCookieSize: number, magicCookie: any, extensions: Map<any, any>, formatDescriptionOut: any): number;

// export function CMAudioFormatDescriptionCreateFromBigEndianSoundDescriptionBlockBuffer(allocator: any, soundDescriptionBlockBuffer: any, flavor: any, formatDescriptionOut: any): number;

// export function CMAudioFormatDescriptionCreateFromBigEndianSoundDescriptionData(allocator: any, soundDescriptionData: string | any, size: number, flavor: any, formatDescriptionOut: any): number;

// export function CMAudioFormatDescriptionCreateSummary(allocator: any, formatDescriptionArray: any[], flags: number, formatDescriptionOut: any): number;

// export function CMAudioFormatDescriptionEqual(formatDescription: any, otherFormatDescription: any, equalityMask: number, equalityMaskOut: number): boolean;

// export function CMAudioFormatDescriptionGetChannelLayout(desc: any, sizeOut: number): AudioChannelLayout;

// export function CMAudioFormatDescriptionGetFormatList(desc: any, sizeOut: number): AudioFormatListItem;

// export function CMAudioFormatDescriptionGetMagicCookie(desc: any, sizeOut: number): any;

// export function CMAudioFormatDescriptionGetMostCompatibleFormat(desc: any): AudioFormatListItem;

// export function CMAudioFormatDescriptionGetRichestDecodableFormat(desc: any): AudioFormatListItem;

// export function CMAudioFormatDescriptionGetStreamBasicDescription(desc: any): AudioStreamBasicDescription;

// export function CMAudioSampleBufferCreateReadyWithPacketDescriptions(allocator: any, dataBuffer: any, formatDescription: any, numSamples: number, presentationTimeStamp: CMTime, packetDescriptions: AudioStreamPacketDescription, sampleBufferOut: any): number;

// export function CMAudioSampleBufferCreateWithPacketDescriptions(allocator: any, dataBuffer: any, dataReady: boolean, makeDataReadyCallback: (p1: any, p2: any) => number, makeDataReadyRefcon: any, formatDescription: any, numSamples: number, presentationTimeStamp: CMTime, packetDescriptions: AudioStreamPacketDescription, sampleBufferOut: any): number;

// export function CMAudioSampleBufferCreateWithPacketDescriptionsAndMakeDataReadyHandler(allocator: any, dataBuffer: any, dataReady: boolean, formatDescription: any, numSamples: number, presentationTimeStamp: CMTime, packetDescriptions: AudioStreamPacketDescription, sampleBufferOut: any, makeDataReadyHandler: (p1: any) => number): number;

// export function CMBlockBufferAccessDataBytes(theBuffer: any, offset: number, length: number, temporaryBlock: any, returnedPointerOut: string): number;

// export function CMBlockBufferAppendBufferReference(theBuffer: any, targetBBuf: any, offsetToData: number, dataLength: number, flags: number): number;

// export function CMBlockBufferAppendMemoryBlock(theBuffer: any, memoryBlock: any, blockLength: number, blockAllocator: any, customBlockSource: CMBlockBufferCustomBlockSource, offsetToData: number, dataLength: number, flags: number): number;

// export function CMBlockBufferAssureBlockMemory(theBuffer: any): number;

// export function CMBlockBufferCopyDataBytes(theSourceBuffer: any, offsetToData: number, dataLength: number, destination: any): number;

// export function CMBlockBufferCreateContiguous(structureAllocator: any, sourceBuffer: any, blockAllocator: any, customBlockSource: CMBlockBufferCustomBlockSource, offsetToData: number, dataLength: number, flags: number, blockBufferOut: any): number;

// export function CMBlockBufferCreateEmpty(structureAllocator: any, subBlockCapacity: number, flags: number, blockBufferOut: any): number;

// export function CMBlockBufferCreateWithBufferReference(structureAllocator: any, bufferReference: any, offsetToData: number, dataLength: number, flags: number, blockBufferOut: any): number;

// export function CMBlockBufferCreateWithMemoryBlock(structureAllocator: any, memoryBlock: any, blockLength: number, blockAllocator: any, customBlockSource: CMBlockBufferCustomBlockSource, offsetToData: number, dataLength: number, flags: number, blockBufferOut: any): number;

// export function CMBlockBufferFillDataBytes(fillByte: number, destinationBuffer: any, offsetIntoDestination: number, dataLength: number): number;

// export function CMBlockBufferGetDataLength(theBuffer: any): number;

// export function CMBlockBufferGetDataPointer(theBuffer: any, offset: number, lengthAtOffsetOut: number, totalLengthOut: number, dataPointerOut: string): number;

// export function CMBlockBufferGetTypeID(): number;

// export function CMBlockBufferIsEmpty(theBuffer: any): boolean;

// export function CMBlockBufferIsRangeContiguous(theBuffer: any, offset: number, length: number): boolean;

// export function CMBlockBufferReplaceDataBytes(sourceBytes: any, destinationBuffer: any, offsetIntoDestination: number, dataLength: number): number;

// export function CMBufferQueueCallForEachBuffer(queue: any, callback: (p1: any, p2: any) => number, refcon: any): number;

// export function CMBufferQueueContainsEndOfData(queue: any): boolean;

// export function CMBufferQueueCreate(allocator: any, capacity: number, callbacks: CMBufferCallbacks, queueOut: any): number;

// export function CMBufferQueueCreateWithHandlers(allocator: any, capacity: number, handlers: CMBufferHandlers, queueOut: any): number;

// export function CMBufferQueueDequeueAndRetain(queue: any): any;

// export function CMBufferQueueDequeueIfDataReadyAndRetain(queue: any): any;

// export function CMBufferQueueEnqueue(queue: any, buf: any): number;

// export function CMBufferQueueGetBufferCount(queue: any): number;

// export function CMBufferQueueGetCallbacksForSampleBuffersSortedByOutputPTS(): CMBufferCallbacks;

// export function CMBufferQueueGetCallbacksForUnsortedSampleBuffers(): CMBufferCallbacks;

// export function CMBufferQueueGetDuration(queue: any): CMTime;

// export function CMBufferQueueGetEndPresentationTimeStamp(queue: any): CMTime;

// export function CMBufferQueueGetFirstDecodeTimeStamp(queue: any): CMTime;

// export function CMBufferQueueGetFirstPresentationTimeStamp(queue: any): CMTime;

// export function CMBufferQueueGetHead(queue: any): any;

// export function CMBufferQueueGetMaxPresentationTimeStamp(queue: any): CMTime;

// export function CMBufferQueueGetMinDecodeTimeStamp(queue: any): CMTime;

// export function CMBufferQueueGetMinPresentationTimeStamp(queue: any): CMTime;

// export function CMBufferQueueGetTotalSize(queue: any): number;

// export function CMBufferQueueGetTypeID(): number;

// export function CMBufferQueueInstallTrigger(queue: any, callback: (p1: any, p2: any) => void, refcon: any, condition: number, time: CMTime, triggerTokenOut: any): number;

// export function CMBufferQueueInstallTriggerHandler(queue: any, condition: number, time: CMTime, triggerTokenOut: any, handler: (p1: any) => void): number;

// export function CMBufferQueueInstallTriggerHandlerWithIntegerThreshold(queue: any, condition: number, threshold: number, triggerTokenOut: any, handler: (p1: any) => void): number;

// export function CMBufferQueueInstallTriggerWithIntegerThreshold(queue: any, callback: (p1: any, p2: any) => void, refcon: any, condition: number, threshold: number, triggerTokenOut: any): number;

// export function CMBufferQueueIsAtEndOfData(queue: any): boolean;

// export function CMBufferQueueIsEmpty(queue: any): boolean;

// export function CMBufferQueueMarkEndOfData(queue: any): number;

// export function CMBufferQueueRemoveTrigger(queue: any, triggerToken: any): number;

// export function CMBufferQueueReset(queue: any): number;

// export function CMBufferQueueResetWithCallback(queue: any, callback: (p1: any, p2: any) => void, refcon: any): number;

// export function CMBufferQueueSetValidationCallback(queue: any, callback: (p1: any, p2: any, p3: any) => number, refcon: any): number;

// export function CMBufferQueueSetValidationHandler(queue: any, handler: (p1: any, p2: any) => number): number;

// export function CMBufferQueueTestTrigger(queue: any, triggerToken: any): boolean;

// export function CMClockConvertHostTimeToSystemUnits(hostTime: CMTime): number;

// export function CMClockGetAnchorTime(clock: any, clockTimeOut: CMTime, referenceClockTimeOut: CMTime): number;

// export function CMClockGetHostTimeClock(): any;

// export function CMClockGetTime(clock: any): CMTime;

// export function CMClockGetTypeID(): number;

// export function CMClockInvalidate(clock: any): void;

// export function CMClockMakeHostTimeFromSystemUnits(hostTime: number): CMTime;

// export function CMClockMightDrift(clock: any, otherClock: any): boolean;

// export function CMClosedCaptionFormatDescriptionCopyAsBigEndianClosedCaptionDescriptionBlockBuffer(allocator: any, closedCaptionFormatDescription: any, flavor: any, blockBufferOut: any): number;

// export function CMClosedCaptionFormatDescriptionCreateFromBigEndianClosedCaptionDescriptionBlockBuffer(allocator: any, closedCaptionDescriptionBlockBuffer: any, flavor: any, formatDescriptionOut: any): number;

// export function CMClosedCaptionFormatDescriptionCreateFromBigEndianClosedCaptionDescriptionData(allocator: any, closedCaptionDescriptionData: string | any, size: number, flavor: any, formatDescriptionOut: any): number;

// export function CMCopyDictionaryOfAttachments(allocator: any, target: any, attachmentMode: number): Map<any, any>;

// export function CMDoesBigEndianSoundDescriptionRequireLegacyCBRSampleTableLayout(soundDescriptionBlockBuffer: any, flavor: any): boolean;

// export function CMFormatDescriptionCreate(allocator: any, mediaType: number, mediaSubType: number, extensions: Map<any, any>, formatDescriptionOut: any): number;

// export function CMFormatDescriptionEqual(formatDescription: any, otherFormatDescription: any): boolean;

// export function CMFormatDescriptionEqualIgnoringExtensionKeys(formatDescription: any, otherFormatDescription: any, formatDescriptionExtensionKeysToIgnore: any, sampleDescriptionExtensionAtomKeysToIgnore: any): boolean;

// export function CMFormatDescriptionGetExtension(desc: any, extensionKey: string): any;

// export function CMFormatDescriptionGetExtensions(desc: any): Map<any, any>;

// export function CMFormatDescriptionGetMediaSubType(desc: any): number;

// export function CMFormatDescriptionGetMediaType(desc: any): number;

// export function CMFormatDescriptionGetTypeID(): number;

// export function CMGetAttachment(target: any, key: string, attachmentModeOut: number): any;

// export function CMMemoryPoolCreate(options: Map<any, any>): any;

// export function CMMemoryPoolFlush(pool: any): void;

// export function CMMemoryPoolGetAllocator(pool: any): any;

// export function CMMemoryPoolGetTypeID(): number;

// export function CMMemoryPoolInvalidate(pool: any): void;

// export function CMMetadataCreateIdentifierForKeyAndKeySpace(allocator: any, key: any, keySpace: string, identifierOut: string): number;

// export function CMMetadataCreateKeyFromIdentifier(allocator: any, identifier: string, keyOut: any): number;

// export function CMMetadataCreateKeyFromIdentifierAsCFData(allocator: any, identifier: string, keyOut: Data): number;

// export function CMMetadataCreateKeySpaceFromIdentifier(allocator: any, identifier: string, keySpaceOut: string): number;

// export function CMMetadataDataTypeRegistryDataTypeConformsToDataType(dataType: string, conformsToDataType: string): boolean;

// export function CMMetadataDataTypeRegistryDataTypeIsBaseDataType(dataType: string): boolean;

// export function CMMetadataDataTypeRegistryDataTypeIsRegistered(dataType: string): boolean;

// export function CMMetadataDataTypeRegistryGetBaseDataTypeForConformingDataType(dataType: string): string;

// export function CMMetadataDataTypeRegistryGetBaseDataTypes(): any[];

// export function CMMetadataDataTypeRegistryGetConformingDataTypes(dataType: string): any[];

// export function CMMetadataDataTypeRegistryGetDataTypeDescription(dataType: string): string;

// export function CMMetadataDataTypeRegistryRegisterDataType(dataType: string, description: string, conformingDataTypes: any[]): number;

// export function CMMetadataFormatDescriptionCopyAsBigEndianMetadataDescriptionBlockBuffer(allocator: any, metadataFormatDescription: any, flavor: any, blockBufferOut: any): number;

// export function CMMetadataFormatDescriptionCreateByMergingMetadataFormatDescriptions(allocator: any, sourceDescription: any, otherSourceDescription: any, formatDescriptionOut: any): number;

// export function CMMetadataFormatDescriptionCreateFromBigEndianMetadataDescriptionBlockBuffer(allocator: any, metadataDescriptionBlockBuffer: any, flavor: any, formatDescriptionOut: any): number;

// export function CMMetadataFormatDescriptionCreateFromBigEndianMetadataDescriptionData(allocator: any, metadataDescriptionData: string | any, size: number, flavor: any, formatDescriptionOut: any): number;

// export function CMMetadataFormatDescriptionCreateWithKeys(allocator: any, metadataType: number, keys: any[], formatDescriptionOut: any): number;

// export function CMMetadataFormatDescriptionCreateWithMetadataFormatDescriptionAndMetadataSpecifications(allocator: any, sourceDescription: any, metadataSpecifications: any[], formatDescriptionOut: any): number;

// export function CMMetadataFormatDescriptionCreateWithMetadataSpecifications(allocator: any, metadataType: number, metadataSpecifications: any[], formatDescriptionOut: any): number;

// export function CMMetadataFormatDescriptionGetIdentifiers(desc: any): any[];

// export function CMMetadataFormatDescriptionGetKeyWithLocalID(desc: any, localKeyID: number): Map<any, any>;

// export function CMMuxedFormatDescriptionCreate(allocator: any, muxType: number, extensions: Map<any, any>, formatDescriptionOut: any): number;

// export function CMPropagateAttachments(source: any, destination: any): void;

// export function CMRemoveAllAttachments(target: any): void;

// export function CMRemoveAttachment(target: any, key: string): void;

// export function CMSampleBufferCallBlockForEachSample(sbuf: any, handler: (p1: any, p2: number) => number): number;

// export function CMSampleBufferCallForEachSample(sbuf: any, callback: (p1: any, p2: number, p3: any) => number, refcon: any): number;

// export function CMSampleBufferCopyPCMDataIntoAudioBufferList(sbuf: any, frameOffset: number, numFrames: number, bufferList: AudioBufferList): number;

// export function CMSampleBufferCopySampleBufferForRange(allocator: any, sbuf: any, sampleRange: CFRange, sampleBufferOut: any): number;

// export function CMSampleBufferCreate(allocator: any, dataBuffer: any, dataReady: boolean, makeDataReadyCallback: (p1: any, p2: any) => number, makeDataReadyRefcon: any, formatDescription: any, numSamples: number, numSampleTimingEntries: number, sampleTimingArray: CMSampleTimingInfo, numSampleSizeEntries: number, sampleSizeArray: number, sampleBufferOut: any): number;

// export function CMSampleBufferCreateCopy(allocator: any, sbuf: any, sampleBufferOut: any): number;

// export function CMSampleBufferCreateCopyWithNewTiming(allocator: any, originalSBuf: any, numSampleTimingEntries: number, sampleTimingArray: CMSampleTimingInfo, sampleBufferOut: any): number;

// export function CMSampleBufferCreateForImageBuffer(allocator: any, imageBuffer: any, dataReady: boolean, makeDataReadyCallback: (p1: any, p2: any) => number, makeDataReadyRefcon: any, formatDescription: any, sampleTiming: CMSampleTimingInfo, sampleBufferOut: any): number;

// export function CMSampleBufferCreateForImageBufferWithMakeDataReadyHandler(allocator: any, imageBuffer: any, dataReady: boolean, formatDescription: any, sampleTiming: CMSampleTimingInfo, sampleBufferOut: any, makeDataReadyHandler: (p1: any) => number): number;

// export function CMSampleBufferCreateReady(allocator: any, dataBuffer: any, formatDescription: any, numSamples: number, numSampleTimingEntries: number, sampleTimingArray: CMSampleTimingInfo, numSampleSizeEntries: number, sampleSizeArray: number, sampleBufferOut: any): number;

// export function CMSampleBufferCreateReadyWithImageBuffer(allocator: any, imageBuffer: any, formatDescription: any, sampleTiming: CMSampleTimingInfo, sampleBufferOut: any): number;

// export function CMSampleBufferCreateWithMakeDataReadyHandler(allocator: any, dataBuffer: any, dataReady: boolean, formatDescription: any, numSamples: number, numSampleTimingEntries: number, sampleTimingArray: CMSampleTimingInfo, numSampleSizeEntries: number, sampleSizeArray: number, sampleBufferOut: any, makeDataReadyHandler: (p1: any) => number): number;

// export function CMSampleBufferDataIsReady(sbuf: any): boolean;

// export function CMSampleBufferGetAudioBufferListWithRetainedBlockBuffer(sbuf: any, bufferListSizeNeededOut: number, bufferListOut: AudioBufferList, bufferListSize: number, blockBufferStructureAllocator: any, blockBufferBlockAllocator: any, flags: number, blockBufferOut: any): number;

// export function CMSampleBufferGetAudioStreamPacketDescriptions(sbuf: any, packetDescriptionsSize: number, packetDescriptionsOut: AudioStreamPacketDescription, packetDescriptionsSizeNeededOut: number): number;

// export function CMSampleBufferGetAudioStreamPacketDescriptionsPtr(sbuf: any, packetDescriptionsPointerOut: AudioStreamPacketDescription, packetDescriptionsSizeOut: number): number;

// export function CMSampleBufferGetDataBuffer(sbuf: any): any;

// export function CMSampleBufferGetDecodeTimeStamp(sbuf: any): CMTime;

// export function CMSampleBufferGetDuration(sbuf: any): CMTime;

// export function CMSampleBufferGetFormatDescription(sbuf: any): any;

// export function CMSampleBufferGetImageBuffer(sbuf: any): any;

// export function CMSampleBufferGetNumSamples(sbuf: any): number;

// export function CMSampleBufferGetOutputDecodeTimeStamp(sbuf: any): CMTime;

// export function CMSampleBufferGetOutputDuration(sbuf: any): CMTime;

// export function CMSampleBufferGetOutputPresentationTimeStamp(sbuf: any): CMTime;

// export function CMSampleBufferGetOutputSampleTimingInfoArray(sbuf: any, timingArrayEntries: number, timingArrayOut: CMSampleTimingInfo, timingArrayEntriesNeededOut: number): number;

// export function CMSampleBufferGetPresentationTimeStamp(sbuf: any): CMTime;

// export function CMSampleBufferGetSampleAttachmentsArray(sbuf: any, createIfNecessary: boolean): any[];

// export function CMSampleBufferGetSampleSize(sbuf: any, sampleIndex: number): number;

// export function CMSampleBufferGetSampleSizeArray(sbuf: any, sizeArrayEntries: number, sizeArrayOut: number, sizeArrayEntriesNeededOut: number): number;

// export function CMSampleBufferGetSampleTimingInfo(sbuf: any, sampleIndex: number, timingInfoOut: CMSampleTimingInfo): number;

// export function CMSampleBufferGetSampleTimingInfoArray(sbuf: any, numSampleTimingEntries: number, timingArrayOut: CMSampleTimingInfo, timingArrayEntriesNeededOut: number): number;

// export function CMSampleBufferGetTotalSampleSize(sbuf: any): number;

// export function CMSampleBufferGetTypeID(): number;

// export function CMSampleBufferHasDataFailed(sbuf: any, statusOut: number): boolean;

// export function CMSampleBufferInvalidate(sbuf: any): number;

// export function CMSampleBufferIsValid(sbuf: any): boolean;

// export function CMSampleBufferMakeDataReady(sbuf: any): number;

// export function CMSampleBufferSetDataBuffer(sbuf: any, dataBuffer: any): number;

// export function CMSampleBufferSetDataBufferFromAudioBufferList(sbuf: any, blockBufferStructureAllocator: any, blockBufferBlockAllocator: any, flags: number, bufferList: AudioBufferList): number;

// export function CMSampleBufferSetDataFailed(sbuf: any, status: number): number;

// export function CMSampleBufferSetDataReady(sbuf: any): number;

// export function CMSampleBufferSetInvalidateCallback(sbuf: any, invalidateCallback: (p1: any, p2: number) => void, invalidateRefCon: number): number;

// export function CMSampleBufferSetInvalidateHandler(sbuf: any, invalidateHandler: (p1: any) => void): number;

// export function CMSampleBufferSetOutputPresentationTimeStamp(sbuf: any, outputPresentationTimeStamp: CMTime): number;

// export function CMSampleBufferTrackDataReadiness(sbuf: any, sampleBufferToTrack: any): number;

// export function CMSetAttachment(target: any, key: string, value: any, attachmentMode: number): void;

// export function CMSetAttachments(target: any, theAttachments: Map<any, any>, attachmentMode: number): void;

// export function CMSimpleQueueCreate(allocator: any, capacity: number, queueOut: any): number;

// export function CMSimpleQueueDequeue(queue: any): any;

// export function CMSimpleQueueEnqueue(queue: any, element: any): number;

// export function CMSimpleQueueGetCapacity(queue: any): number;

// export function CMSimpleQueueGetCount(queue: any): number;

// export function CMSimpleQueueGetHead(queue: any): any;

// export function CMSimpleQueueGetTypeID(): number;

// export function CMSimpleQueueReset(queue: any): number;

// export function CMSwapBigEndianClosedCaptionDescriptionToHost(closedCaptionDescriptionData: string | any, closedCaptionDescriptionSize: number): number;

// export function CMSwapBigEndianImageDescriptionToHost(imageDescriptionData: string | any, imageDescriptionSize: number): number;

// export function CMSwapBigEndianMetadataDescriptionToHost(metadataDescriptionData: string | any, metadataDescriptionSize: number): number;

// export function CMSwapBigEndianSoundDescriptionToHost(soundDescriptionData: string | any, soundDescriptionSize: number): number;

// export function CMSwapBigEndianTextDescriptionToHost(textDescriptionData: string | any, textDescriptionSize: number): number;

// export function CMSwapBigEndianTimeCodeDescriptionToHost(timeCodeDescriptionData: string | any, timeCodeDescriptionSize: number): number;

// export function CMSwapHostEndianClosedCaptionDescriptionToBig(closedCaptionDescriptionData: string | any, closedCaptionDescriptionSize: number): number;

// export function CMSwapHostEndianImageDescriptionToBig(imageDescriptionData: string | any, imageDescriptionSize: number): number;

// export function CMSwapHostEndianMetadataDescriptionToBig(metadataDescriptionData: string | any, metadataDescriptionSize: number): number;

// export function CMSwapHostEndianSoundDescriptionToBig(soundDescriptionData: string | any, soundDescriptionSize: number): number;

// export function CMSwapHostEndianTextDescriptionToBig(textDescriptionData: string | any, textDescriptionSize: number): number;

// export function CMSwapHostEndianTimeCodeDescriptionToBig(timeCodeDescriptionData: string | any, timeCodeDescriptionSize: number): number;

// export function CMSyncConvertTime(time: CMTime, fromClockOrTimebase: any, toClockOrTimebase: any): CMTime;

// export function CMSyncGetRelativeRate(ofClockOrTimebase: any, relativeToClockOrTimebase: any): number;

// export function CMSyncGetRelativeRateAndAnchorTime(ofClockOrTimebase: any, relativeToClockOrTimebase: any, outRelativeRate: number, outOfClockOrTimebaseAnchorTime: CMTime, outRelativeToClockOrTimebaseAnchorTime: CMTime): number;

// export function CMSyncGetTime(clockOrTimebase: any): CMTime;

// export function CMSyncMightDrift(clockOrTimebase1: any, clockOrTimebase2: any): boolean;

// export function CMTextFormatDescriptionCopyAsBigEndianTextDescriptionBlockBuffer(allocator: any, textFormatDescription: any, flavor: any, blockBufferOut: any): number;

// export function CMTextFormatDescriptionCreateFromBigEndianTextDescriptionBlockBuffer(allocator: any, textDescriptionBlockBuffer: any, flavor: any, mediaType: number, formatDescriptionOut: any): number;

// export function CMTextFormatDescriptionCreateFromBigEndianTextDescriptionData(allocator: any, textDescriptionData: string | any, size: number, flavor: any, mediaType: number, formatDescriptionOut: any): number;

// export function CMTextFormatDescriptionGetDefaultStyle(desc: any, localFontIDOut: number, boldOut: string | any, italicOut: string | any, underlineOut: string | any, fontSizeOut: number, colorComponentsOut: number): number;

// export function CMTextFormatDescriptionGetDefaultTextBox(desc: any, originIsAtTopLeft: boolean, heightOfTextTrack: number, defaultTextBoxOut: CGRect): number;

// export function CMTextFormatDescriptionGetDisplayFlags(desc: any, displayFlagsOut: number): number;

// export function CMTextFormatDescriptionGetFontName(desc: any, localFontID: number, fontNameOut: string): number;

// export function CMTextFormatDescriptionGetJustification(desc: any, horizontaJustificationlOut: number, verticalJustificationOut: number): number;

// export function CMTimeAbsoluteValue(time: CMTime): CMTime;

// export function CMTimeAdd(lhs: CMTime, rhs: CMTime): CMTime;

// export function CMTimeClampToRange(time: CMTime, range: CMTimeRange): CMTime;

// export function CMTimeCodeFormatDescriptionCopyAsBigEndianTimeCodeDescriptionBlockBuffer(allocator: any, timeCodeFormatDescription: any, flavor: any, blockBufferOut: any): number;

// export function CMTimeCodeFormatDescriptionCreate(allocator: any, timeCodeFormatType: number, frameDuration: CMTime, frameQuanta: number, flags: number, extensions: Map<any, any>, formatDescriptionOut: any): number;

// export function CMTimeCodeFormatDescriptionCreateFromBigEndianTimeCodeDescriptionBlockBuffer(allocator: any, timeCodeDescriptionBlockBuffer: any, flavor: any, formatDescriptionOut: any): number;

// export function CMTimeCodeFormatDescriptionCreateFromBigEndianTimeCodeDescriptionData(allocator: any, timeCodeDescriptionData: string | any, size: number, flavor: any, formatDescriptionOut: any): number;

// export function CMTimeCodeFormatDescriptionGetFrameDuration(timeCodeFormatDescription: any): CMTime;

// export function CMTimeCodeFormatDescriptionGetFrameQuanta(timeCodeFormatDescription: any): number;

// export function CMTimeCodeFormatDescriptionGetTimeCodeFlags(desc: any): number;

// export function CMTimeCompare(time1: CMTime, time2: CMTime): number;

// export function CMTimeConvertScale(time: CMTime, newTimescale: number, method: CMTime.CMTimeRoundingMethod): CMTime;

// export function CMTimeCopyAsDictionary(time: CMTime, allocator: any): Map<any, any>;

// export function CMTimeCopyDescription(allocator: any, time: CMTime): string;

// export function CMTimeFoldIntoRange(time: CMTime, foldRange: CMTimeRange): CMTime;

// export function CMTimeGetSeconds(time: CMTime): number;

// export function CMTimeMake(value: number, timescale: number): CMTime;

// export function CMTimeMakeFromDictionary(dictionaryRepresentation: Map<any, any>): CMTime;

// export function CMTimeMakeWithEpoch(value: number, timescale: number, epoch: number): CMTime;

// export function CMTimeMakeWithSeconds(seconds: number, preferredTimescale: number): CMTime;

// export function CMTimeMapDurationFromRangeToRange(dur: CMTime, fromRange: CMTimeRange, toRange: CMTimeRange): CMTime;

// export function CMTimeMapTimeFromRangeToRange(t: CMTime, fromRange: CMTimeRange, toRange: CMTimeRange): CMTime;

// export function CMTimeMappingCopyAsDictionary(mapping: CMTimeMapping, allocator: any): Map<any, any>;

// export function CMTimeMappingCopyDescription(allocator: any, mapping: CMTimeMapping): string;

// export function CMTimeMappingMake(source: CMTimeRange, target: CMTimeRange): CMTimeMapping;

// export function CMTimeMappingMakeEmpty(target: CMTimeRange): CMTimeMapping;

// export function CMTimeMappingMakeFromDictionary(dictionaryRepresentation: Map<any, any>): CMTimeMapping;

// export function CMTimeMappingShow(mapping: CMTimeMapping): void;

// export function CMTimeMaximum(time1: CMTime, time2: CMTime): CMTime;

// export function CMTimeMinimum(time1: CMTime, time2: CMTime): CMTime;

// export function CMTimeMultiply(time: CMTime, multiplier: number): CMTime;

// export function CMTimeMultiplyByFloat64(time: CMTime, multiplier: number): CMTime;

// export function CMTimeMultiplyByRatio(time: CMTime, multiplier: number, divisor: number): CMTime;

// export function CMTimeRangeContainsTime(range: CMTimeRange, time: CMTime): boolean;

// export function CMTimeRangeContainsTimeRange(range: CMTimeRange, otherRange: CMTimeRange): boolean;

// export function CMTimeRangeCopyAsDictionary(range: CMTimeRange, allocator: any): Map<any, any>;

// export function CMTimeRangeCopyDescription(allocator: any, range: CMTimeRange): string;

// export function CMTimeRangeEqual(range1: CMTimeRange, range2: CMTimeRange): boolean;

// export function CMTimeRangeFromTimeToTime(start: CMTime, end: CMTime): CMTimeRange;

// export function CMTimeRangeGetEnd(range: CMTimeRange): CMTime;

// export function CMTimeRangeGetIntersection(range: CMTimeRange, otherRange: CMTimeRange): CMTimeRange;

// export function CMTimeRangeGetUnion(range: CMTimeRange, otherRange: CMTimeRange): CMTimeRange;

// export function CMTimeRangeMake(start: CMTime, duration: CMTime): CMTimeRange;

// export function CMTimeRangeMakeFromDictionary(dictionaryRepresentation: Map<any, any>): CMTimeRange;

// export function CMTimeRangeShow(range: CMTimeRange): void;

// export function CMTimeShow(time: CMTime): void;

// export function CMTimeSubtract(lhs: CMTime, rhs: CMTime): CMTime;

// export function CMTimebaseAddTimer(timebase: any, timer: Timer, runloop: any): number;

// export function CMTimebaseAddTimerDispatchSource(timebase: any, timerSource: NSObject): number;

// export function CMTimebaseCopyMaster(timebase: any): any;

// export function CMTimebaseCopyMasterClock(timebase: any): any;

// export function CMTimebaseCopyMasterTimebase(timebase: any): any;

// export function CMTimebaseCopyUltimateMasterClock(timebase: any): any;

// export function CMTimebaseCreateWithMasterClock(allocator: any, masterClock: any, timebaseOut: any): number;

// export function CMTimebaseCreateWithMasterTimebase(allocator: any, masterTimebase: any, timebaseOut: any): number;

// export function CMTimebaseGetEffectiveRate(timebase: any): number;

// export function CMTimebaseGetRate(timebase: any): number;

// export function CMTimebaseGetTime(timebase: any): CMTime;

// export function CMTimebaseGetTimeAndRate(timebase: any, timeOut: CMTime, rateOut: number): number;

// export function CMTimebaseGetTimeWithTimeScale(timebase: any, timescale: number, method: CMTime.CMTimeRoundingMethod): CMTime;

// export function CMTimebaseGetTypeID(): number;

// export function CMTimebaseNotificationBarrier(timebase: any): number;

// export function CMTimebaseRemoveTimer(timebase: any, timer: Timer): number;

// export function CMTimebaseRemoveTimerDispatchSource(timebase: any, timerSource: NSObject): number;

// export function CMTimebaseSetAnchorTime(timebase: any, timebaseTime: CMTime, immediateMasterTime: CMTime): number;

// export function CMTimebaseSetMasterClock(timebase: any, newMasterClock: any): number;

// export function CMTimebaseSetMasterTimebase(timebase: any, newMasterTimebase: any): number;

// export function CMTimebaseSetRate(timebase: any, rate: number): number;

// export function CMTimebaseSetRateAndAnchorTime(timebase: any, rate: number, timebaseTime: CMTime, immediateMasterTime: CMTime): number;

// export function CMTimebaseSetTime(timebase: any, time: CMTime): number;

// export function CMTimebaseSetTimerDispatchSourceNextFireTime(timebase: any, timerSource: NSObject, fireTime: CMTime, flags: number): number;

// export function CMTimebaseSetTimerDispatchSourceToFireImmediately(timebase: any, timerSource: NSObject): number;

// export function CMTimebaseSetTimerNextFireTime(timebase: any, timer: Timer, fireTime: CMTime, flags: number): number;

// export function CMTimebaseSetTimerToFireImmediately(timebase: any, timer: Timer): number;

// export function CMVideoFormatDescriptionCopyAsBigEndianImageDescriptionBlockBuffer(allocator: any, videoFormatDescription: any, stringEncoding: number, flavor: any, blockBufferOut: any): number;

// export function CMVideoFormatDescriptionCreate(allocator: any, codecType: number, width: number, height: number, extensions: Map<any, any>, formatDescriptionOut: any): number;

// export function CMVideoFormatDescriptionCreateForImageBuffer(allocator: any, imageBuffer: any, formatDescriptionOut: any): number;

// export function CMVideoFormatDescriptionCreateFromBigEndianImageDescriptionBlockBuffer(allocator: any, imageDescriptionBlockBuffer: any, stringEncoding: number, flavor: any, formatDescriptionOut: any): number;

// export function CMVideoFormatDescriptionCreateFromBigEndianImageDescriptionData(allocator: any, imageDescriptionData: string | any, size: number, stringEncoding: number, flavor: any, formatDescriptionOut: any): number;

// export function CMVideoFormatDescriptionCreateFromH264ParameterSets(allocator: any, parameterSetCount: number, parameterSetPointers: string, parameterSetSizes: number, NALUnitHeaderLength: number, formatDescriptionOut: any): number;

// export function CMVideoFormatDescriptionCreateFromHEVCParameterSets(allocator: any, parameterSetCount: number, parameterSetPointers: string, parameterSetSizes: number, NALUnitHeaderLength: number, extensions: Map<any, any>, formatDescriptionOut: any): number;

// export function CMVideoFormatDescriptionGetCleanAperture(videoDesc: any, originIsAtTopLeft: boolean): CGRect;

// export function CMVideoFormatDescriptionGetDimensions(videoDesc: any): CMVideoDimensions;

// export function CMVideoFormatDescriptionGetExtensionKeysCommonWithImageBuffers(): any[];

// export function CMVideoFormatDescriptionGetH264ParameterSetAtIndex(videoDesc: any, parameterSetIndex: number, parameterSetPointerOut: string, parameterSetSizeOut: number, parameterSetCountOut: number, NALUnitHeaderLengthOut: number): number;

// export function CMVideoFormatDescriptionGetHEVCParameterSetAtIndex(videoDesc: any, parameterSetIndex: number, parameterSetPointerOut: string, parameterSetSizeOut: number, parameterSetCountOut: number, NALUnitHeaderLengthOut: number): number;

// export function CMVideoFormatDescriptionGetPresentationDimensions(videoDesc: any, usePixelAspectRatio: boolean, useCleanAperture: boolean): CGSize;

// export function CMVideoFormatDescriptionMatchesImageBuffer(desc: any, imageBuffer: any): boolean;

// export function CMIODeviceProcessAVCCommand(deviceID: number, ioAVCCommand: CMIODeviceAVCCommand): number;

// export function CMIODeviceProcessRS422Command(deviceID: number, ioRS422Command: CMIODeviceRS422Command): number;

// export function CMIODeviceStartStream(deviceID: number, streamID: number): number;

// export function CMIODeviceStopStream(deviceID: number, streamID: number): number;

// export function CMIOObjectAddPropertyListener(objectID: number, address: CMIOObjectPropertyAddress, listener: (p1: number, p2: number, p3: CMIOObjectPropertyAddress, p4: any) => number, clientData: any): number;

// export function CMIOObjectAddPropertyListenerBlock(objectID: number, address: CMIOObjectPropertyAddress, dispatchQueue: NSObject, listener: (p1: number, p2: CMIOObjectPropertyAddress) => void): number;

// export function CMIOObjectCreate(owningPlugIn: CMIOHardwarePlugInInterface, owningObjectID: number, classID: number, objectID: number): number;

// export function CMIOObjectGetPropertyData(objectID: number, address: CMIOObjectPropertyAddress, qualifierDataSize: number, qualifierData: any, dataSize: number, dataUsed: number, data: any): number;

// export function CMIOObjectGetPropertyDataSize(objectID: number, address: CMIOObjectPropertyAddress, qualifierDataSize: number, qualifierData: any, dataSize: number): number;

// export function CMIOObjectHasProperty(objectID: number, address: CMIOObjectPropertyAddress): boolean;

// export function CMIOObjectIsPropertySettable(objectID: number, address: CMIOObjectPropertyAddress, isSettable: string | any): number;

// export function CMIOObjectPropertiesChanged(owningPlugIn: CMIOHardwarePlugInInterface, objectID: number, numberAddresses: number, addresses: CMIOObjectPropertyAddress): number;

// export function CMIOObjectRemovePropertyListener(objectID: number, address: CMIOObjectPropertyAddress, listener: (p1: number, p2: number, p3: CMIOObjectPropertyAddress, p4: any) => number, clientData: any): number;

// export function CMIOObjectRemovePropertyListenerBlock(objectID: number, address: CMIOObjectPropertyAddress, dispatchQueue: NSObject, listener: (p1: number, p2: CMIOObjectPropertyAddress) => void): number;

// export function CMIOObjectSetPropertyData(objectID: number, address: CMIOObjectPropertyAddress, qualifierDataSize: number, qualifierData: any, dataSize: number, data: any): number;

// export function CMIOObjectShow(objectID: number): void;

// export function CMIOObjectsPublishedAndDied(owningPlugIn: CMIOHardwarePlugInInterface, owningObjectID: number, numberPublishedCMIOObjects: number, publishedCMIOObjects: number, numberDeadCMIOObjects: number, deadCMIOObjects: number): number;

// export function CMIOSampleBufferCopyNonRequiredAttachments(sourceSBuf: any, destSBuf: any, attachmentMode: number): number;

// export function CMIOSampleBufferCopySampleAttachments(sourceSBuf: any, destSBuf: any): number;

// export function CMIOSampleBufferCreate(allocator: any, dataBuffer: any, formatDescription: any, numSamples: number, numSampleTimingEntries: number, sampleTimingArray: CMSampleTimingInfo, numSampleSizeEntries: number, sampleSizeArray: number, sequenceNumber: number, discontinuityFlags: number, sBufOut: any): number;

// export function CMIOSampleBufferCreateForImageBuffer(allocator: any, imageBuffer: any, formatDescription: any, sampleTiming: CMSampleTimingInfo, sequenceNumber: number, discontinuityFlags: number, sBufOut: any): number;

// export function CMIOSampleBufferCreateNoDataMarker(allocator: any, noDataEvent: number, formatDescription: any, sequenceNumber: number, discontinuityFlags: number, sBufOut: any): number;

// export function CMIOSampleBufferGetDiscontinuityFlags(sbuf: any): number;

// export function CMIOSampleBufferGetSequenceNumber(sbuf: any): number;

// export function CMIOSampleBufferSetDiscontinuityFlags(allocator: any, sbuf: any, discontinuityFlags: number): void;

// export function CMIOSampleBufferSetSequenceNumber(allocator: any, sbuf: any, sequenceNumber: number): void;

// export function CMIOStreamClockConvertHostTimeToDeviceTime(hostTime: number, clock: any): CMTime;

// export function CMIOStreamClockCreate(allocator: any, clockName: string, sourceIdentifier: any, getTimeCallMinimumInterval: CMTime, numberOfEventsForRateSmoothing: number, numberOfAveragesForRateSmoothing: number, clock: any): number;

// export function CMIOStreamClockInvalidate(clock: any): number;

// export function CMIOStreamClockPostTimingEvent(eventTime: CMTime, hostTime: number, resynchronize: boolean, clock: any): number;

// export function CMIOStreamCopyBufferQueue(streamID: number, queueAlteredProc: (p1: number, p2: any, p3: any) => void, queueAlteredRefCon: any, queue: any): number;

// export function CMIOStreamDeckCueTo(streamID: number, frameNumber: number, playOnCue: boolean): number;

// export function CMIOStreamDeckJog(streamID: number, speed: number): number;

// export function CMIOStreamDeckPlay(streamID: number): number;

// export function CMIOStreamDeckStop(streamID: number): number;

export class AffineTransform extends NSObject {
  transformStruct: NSAffineTransformStruct;
  setTransformStruct(_: NSAffineTransformStruct);
  appendTransform(_: AffineTransform): void;
  concat(): void;
  static initWithTransform(_: AffineTransform): AffineTransform;
  invert(): void;
  prependTransform(_: AffineTransform): void;
  rotateByDegrees(byDegrees: number): void;
  rotateByRadians(byRadians: number): void;
  scaleBy(by: number): void;
  scaleXByYBy(by: number, yBy: number): void;
  set(): void;
  transformBezierPath(_: NSBezierPath): NSBezierPath;
  transformPoint(_: CGPoint): CGPoint;
  transformSize(_: CGSize): CGSize;
  translateXByYBy(by: number, yBy: number): void;
}

// @ts-ignore
export class Array<ObjectType> extends NSObject {
  static array<ObjectType>(): Array<ObjectType>;
  static arrayWithArray<ObjectType>(_: ObjectType[]): Array<ObjectType>;
  static arrayWithContentsOfFile<ObjectType>(_: string): ObjectType[];
  static arrayWithContentsOfURL<ObjectType>(_: URL): ObjectType[];
  static arrayWithObject<ObjectType>(_: ObjectType): Array<ObjectType>;
  static arrayWithObjects<ObjectType>(_: ObjectType): Array<ObjectType>;
  static arrayWithObjectsCount<ObjectType>(_: ObjectType, count: number): Array<ObjectType>;
  count: number;
  firstObject: ObjectType;
  lastObject: ObjectType;
  sortedArrayHint: Data;
  addObserverToObjectsAtIndexesForKeyPathOptionsContext(_: NSObject, toObjectsAtIndexes: IndexSet, forKeyPath: string, options: NSKeyValueObserving.NSKeyValueObservingOptions, context?: any): void;
  arrayByAddingObject(_: ObjectType): ObjectType[];
  arrayByAddingObjectsFromArray(_: ObjectType[]): ObjectType[];
  arrayByApplyingDifference(_: CollectionDifference<any>): ObjectType[];
  componentsJoinedByString(_: string): string;
  containsObject(_: ObjectType): boolean;
  descriptionWithLocale(_?: any): string;
  descriptionWithLocaleIndent(_?: any, indent?: number): string;
  differenceFromArray(_: ObjectType[]): CollectionDifference<any>;
  differenceFromArrayWithOptions(_: ObjectType[], withOptions: CollectionDifference.NSOrderedCollectionDifferenceCalculationOptions): CollectionDifference<any>;
  differenceFromArrayWithOptionsUsingEquivalenceTest(_: ObjectType[], withOptions: CollectionDifference.NSOrderedCollectionDifferenceCalculationOptions, usingEquivalenceTest: (p1: ObjectType, p2: ObjectType) => boolean): CollectionDifference<any>;
  enumerateObjectsAtIndexesOptionsUsingBlock(_: IndexSet, options: NSObjCRuntime.NSEnumerationOptions, usingBlock: (p1: ObjectType, p2: number, p3: boolean) => void): void;
  enumerateObjectsUsingBlock(_: (p1: ObjectType, p2: number, p3: boolean) => void): void;
  enumerateObjectsWithOptionsUsingBlock(_: NSObjCRuntime.NSEnumerationOptions, usingBlock: (p1: ObjectType, p2: number, p3: boolean) => void): void;
  filteredArrayUsingPredicate(_: NSPredicate): ObjectType[];
  firstObjectCommonWithArray(_: ObjectType[]): ObjectType;
  indexOfObject(_: ObjectType): number;
  indexOfObjectInRange(_: ObjectType, inRange: NSRange): number;
  indexOfObjectInSortedRangeOptionsUsingComparator(_: ObjectType, inSortedRange: NSRange, options: Array.NSBinarySearchingOptions, usingComparator: (p1: any, p2: any) => NSObjCRuntime.ComparisonResult): number;
  indexOfObjectAtIndexesOptionsPassingTest(_: IndexSet, options: NSObjCRuntime.NSEnumerationOptions, passingTest: (p1: ObjectType, p2: number, p3: boolean) => boolean): number;
  indexOfObjectIdenticalTo(_: ObjectType): number;
  indexOfObjectIdenticalToInRange(_: ObjectType, inRange: NSRange): number;
  indexOfObjectPassingTest(_: (p1: ObjectType, p2: number, p3: boolean) => boolean): number;
  indexOfObjectWithOptionsPassingTest(_: NSObjCRuntime.NSEnumerationOptions, passingTest: (p1: ObjectType, p2: number, p3: boolean) => boolean): number;
  indexesOfObjectsAtIndexesOptionsPassingTest(_: IndexSet, options: NSObjCRuntime.NSEnumerationOptions, passingTest: (p1: ObjectType, p2: number, p3: boolean) => boolean): IndexSet;
  indexesOfObjectsPassingTest(_: (p1: ObjectType, p2: number, p3: boolean) => boolean): IndexSet;
  indexesOfObjectsWithOptionsPassingTest(_: NSObjCRuntime.NSEnumerationOptions, passingTest: (p1: ObjectType, p2: number, p3: boolean) => boolean): IndexSet;
  isEqualToArray(_: ObjectType[]): boolean;
  objectAtIndex(_: number): ObjectType;
  objectAtIndexedSubscript(_: number): ObjectType;
  objectEnumerator(): NSEnumerator<any>;
  objectsAtIndexes(_: IndexSet): ObjectType[];
  pathsMatchingExtensions(_: string[]): string[];
  removeObserverFromObjectsAtIndexesForKeyPath(_: NSObject, fromObjectsAtIndexes: IndexSet, forKeyPath: string): void;
  removeObserverFromObjectsAtIndexesForKeyPathContext(_: NSObject, fromObjectsAtIndexes: IndexSet, forKeyPath: string, context?: any): void;
  reverseObjectEnumerator(): NSEnumerator<any>;
  sortedArrayUsingComparator(_: (p1: any, p2: any) => NSObjCRuntime.ComparisonResult): ObjectType[];
  sortedArrayUsingDescriptors(_: NSSortDescriptor[]): ObjectType[];
  sortedArrayUsingFunctionContext(_?: (p1: ObjectType, p2: ObjectType, p3: any) => number, context?: any): ObjectType[];
  sortedArrayUsingFunctionContextHint(_?: (p1: ObjectType, p2: ObjectType, p3: any) => number, context?: any, hint?: Data): ObjectType[];
  sortedArrayUsingSelector(_: string): ObjectType[];
  sortedArrayWithOptionsUsingComparator(_: NSObjCRuntime.NSSortOptions, usingComparator: (p1: any, p2: any) => NSObjCRuntime.ComparisonResult): ObjectType[];
  subarrayWithRange(_: NSRange): ObjectType[];
  writeToFileAtomically(_: string, atomically: boolean): boolean;
  writeToURLAtomically(_: URL, atomically: boolean): boolean;
  writeToURL(error: URL): boolean;
}

export class BlockOperation extends Operation {
  executionBlocks: () => void[];
  addExecutionBlock(_: () => void): void;
}

export class Bundle extends NSObject {
  static uRLForResourceWithExtensionSubdirectoryInBundleWithURL(forResource?: string, withExtension?: string, subdirectory?: string, in_?: URL): URL;
  static uRLsForResourcesWithExtensionSubdirectoryInBundleWithURL(forResourcesWithExtension?: string, subdirectory?: string, in_?: URL): URL[];
  //  static pathForResourceOfTypeInDirectory(forResource?: string, ofType?: string, inDirectory?: string): string;
  //  static pathsForResourcesOfTypeInDirectory(forResourcesOfType?: string, inDirectory?: string): string[];
  //  static preferredLocalizationsFromArray(from: string[]): string[];
  //  static preferredLocalizationsFromArrayForPreferences(from: string[], forPreferences?: string[]): string[];
  appStoreReceiptURL: URL;
  builtInPlugInsPath: string;
  builtInPlugInsURL: URL;
  bundleIdentifier: string;
  bundlePath: string;
  bundleURL: URL;
  developmentLocalization: string;
  executableArchitectures: number[];
  executablePath: string;
  executableURL: URL;
  infoDictionary: Map<string, any>;
  isLoaded: boolean;
  localizations: string[];
  localizedInfoDictionary: Map<string, any>;
  preferredLocalizations: string[];
  principalClass: typeof NSObject;
  privateFrameworksPath: string;
  privateFrameworksURL: URL;
  resourcePath: string;
  resourceURL: URL;
  sharedFrameworksPath: string;
  sharedFrameworksURL: URL;
  sharedSupportPath: string;
  sharedSupportURL: URL;
  static allBundles: Bundle[];
  static allFrameworks: Bundle[];
  static mainBundle: Bundle;
  uRLForAuxiliaryExecutable(forAuxiliaryExecutable: string): URL;
  uRLForImageResource(_: string): URL;
  uRLForResourceWithExtension(forResource?: string, withExtension?: string): URL;
  uRLForResourceWithExtensionSubdirectory(forResource?: string, withExtension?: string, subdirectory?: string): URL;
  uRLForResourceWithExtensionSubdirectoryLocalization(forResource?: string, withExtension?: string, subdirectory?: string, localization?: string): URL;
  uRLsForResourcesWithExtensionSubdirectory(forResourcesWithExtension?: string, subdirectory?: string): URL[];
  uRLsForResourcesWithExtensionSubdirectoryLocalization(forResourcesWithExtension?: string, subdirectory?: string, localization?: string): URL[];
  classNamed(_: string): typeof NSObject;
  contextHelpForKey(forKey: string): NSAttributedString;
  imageForResource(forResource: string): NSImage;
  static initWithPath(_: string): Bundle;
  static initWithURL(_: URL): Bundle;
  // dupe name w inherited static method  load(): boolean;
  loadAndReturnError(): boolean;
  loadNibNamedOwnerTopLevelObjects(_: string, owner?: any, topLevelObjects?: any[]): boolean;
  localizedStringForKeyValueTable(forKey: string, value?: string, table?: string): string;
  objectForInfoDictionaryKey(forInfoDictionaryKey: string): any;
  pathForAuxiliaryExecutable(forAuxiliaryExecutable: string): string;
  pathForImageResource(_: string): string;
  pathForResourceOfType(forResource?: string, ofType?: string): string;
  pathForResourceOfTypeInDirectory(forResource?: string, ofType?: string, inDirectory?: string): string;
  pathForResourceOfTypeInDirectoryForLocalization(forResource?: string, ofType?: string, inDirectory?: string, forLocalization?: string): string;
  pathForSoundResource(forSoundResource: string): string;
  pathsForResourcesOfTypeInDirectory(forResourcesOfType?: string, inDirectory?: string): string[];
  pathsForResourcesOfTypeInDirectoryForLocalization(forResourcesOfType?: string, inDirectory?: string, forLocalization?: string): string[];
  preflightAndReturnError(): boolean;
  unload(): boolean;
}

export class ByteCountFormatter extends Formatter {
  isAdaptive: boolean;
  setAdaptive(_: boolean);
  allowedUnits: ByteCountFormatter.Units;
  setAllowedUnits(_: ByteCountFormatter.Units);
  allowsNonnumericFormatting: boolean;
  setAllowsNonnumericFormatting(_: boolean);
  countStyle: ByteCountFormatter.CountStyle;
  setCountStyle(_: ByteCountFormatter.CountStyle);
  formattingContext: Formatter.Context;
  setFormattingContext(_: Formatter.Context);
  includesActualByteCount: boolean;
  setIncludesActualByteCount(_: boolean);
  includesCount: boolean;
  setIncludesCount(_: boolean);
  includesUnit: boolean;
  setIncludesUnit(_: boolean);
  zeroPadsFractionDigits: boolean;
  setZeroPadsFractionDigits(_: boolean);
}

export class CachedURLResponse extends NSObject {
  data: Data;
  response: URLResponse;
  storagePolicy: URLCache.StoragePolicy;
  userInfo: Map<any, any>;
  static initWithResponseData(_: URLResponse, data: Data): CachedURLResponse;
  static initWithResponseDataUserInfoStoragePolicy(_: URLResponse, data: Data, userInfo?: Map<any, any>, storagePolicy?: URLCache.StoragePolicy): CachedURLResponse;
}

export class Calendar extends NSObject {
  static calendarWithIdentifier(_: string): Calendar;
  AMSymbol: string;
  PMSymbol: string;
  calendarIdentifier: string;
  eraSymbols: string[];
  firstWeekday: number;
  setFirstWeekday(_: number);
  locale: Locale;
  setLocale(_: Locale);
  longEraSymbols: string[];
  minimumDaysInFirstWeek: number;
  setMinimumDaysInFirstWeek(_: number);
  monthSymbols: string[];
  quarterSymbols: string[];
  shortMonthSymbols: string[];
  shortQuarterSymbols: string[];
  shortStandaloneMonthSymbols: string[];
  shortStandaloneQuarterSymbols: string[];
  shortStandaloneWeekdaySymbols: string[];
  shortWeekdaySymbols: string[];
  standaloneMonthSymbols: string[];
  standaloneQuarterSymbols: string[];
  standaloneWeekdaySymbols: string[];
  timeZone: TimeZone;
  setTimeZone(_: TimeZone);
  veryShortMonthSymbols: string[];
  veryShortStandaloneMonthSymbols: string[];
  veryShortStandaloneWeekdaySymbols: string[];
  veryShortWeekdaySymbols: string[];
  weekdaySymbols: string[];
  static autoupdatingCurrentCalendar: Calendar;
  static currentCalendar: Calendar;
  compareDateToDateToUnitGranularity(_: Date, toDate: Date, toUnitGranularity: Calendar.Unit): NSObjCRuntime.ComparisonResult;
  componentFromDate(_: Calendar.Unit, fromDate: Date): number;
  componentsFromDate(_: Calendar.Unit, fromDate: Date): DateComponents;
  componentsFromDateToDateOptions(_: Calendar.Unit, fromDate: Date, toDate: Date, options: Calendar.Options): DateComponents;
  componentsFromDateComponentsToDateComponentsOptions(_: Calendar.Unit, fromDateComponents: DateComponents, toDateComponents: DateComponents, options: Calendar.Options): DateComponents;
  componentsInTimeZoneFromDate(_: TimeZone, fromDate: Date): DateComponents;
  dateMatchesComponents(_: Date, matchesComponents: DateComponents): boolean;
  dateByAddingComponentsToDateOptions(_: DateComponents, toDate: Date, options: Calendar.Options): Date;
  dateByAddingUnitValueToDateOptions(_: Calendar.Unit, value: number, toDate: Date, options: Calendar.Options): Date;
  dateBySettingHourMinuteSecondOfDateOptions(_: number, minute: number, second: number, ofDate: Date, options: Calendar.Options): Date;
  dateBySettingUnitValueOfDateOptions(_: Calendar.Unit, value: number, ofDate: Date, options: Calendar.Options): Date;
  dateFromComponents(_: DateComponents): Date;
  dateWithEraYearMonthDayHourMinuteSecondNanosecond(_: number, year: number, month: number, day: number, hour: number, minute: number, second: number, nanosecond: number): Date;
  dateWithEraYearForWeekOfYearWeekOfYearWeekdayHourMinuteSecondNanosecond(_: number, yearForWeekOfYear: number, weekOfYear: number, weekday: number, hour: number, minute: number, second: number, nanosecond: number): Date;
  enumerateDatesStartingAfterDateMatchingComponentsOptionsUsingBlock(_: Date, matchingComponents: DateComponents, options: Calendar.Options, usingBlock?: (p1: Date, p2: boolean, p3: boolean) => void): void;
  getEraYearMonthDayFromDate(_?: number, year?: number, month?: number, day?: number, fromDate?: Date): void;
  getEraYearForWeekOfYearWeekOfYearWeekdayFromDate(_?: number, yearForWeekOfYear?: number, weekOfYear?: number, weekday?: number, fromDate?: Date): void;
  getHourMinuteSecondNanosecondFromDate(_?: number, minute?: number, second?: number, nanosecond?: number, fromDate?: Date): void;
  static initWithCalendarIdentifier(_: string): Calendar;
  isDateEqualToDateToUnitGranularity(_: Date, equalToDate: Date, toUnitGranularity: Calendar.Unit): boolean;
  isDateInSameDayAsDate(_: Date, inSameDayAsDate: Date): boolean;
  isDateInToday(_: Date): boolean;
  isDateInTomorrow(_: Date): boolean;
  isDateInWeekend(_: Date): boolean;
  isDateInYesterday(_: Date): boolean;
  maximumRangeOfUnit(_: Calendar.Unit): NSRange;
  minimumRangeOfUnit(_: Calendar.Unit): NSRange;
  nextDateAfterDateMatchingComponentsOptions(_: Date, matchingComponents: DateComponents, options: Calendar.Options): Date;
  nextDateAfterDateMatchingHourMinuteSecondOptions(_: Date, matchingHour: number, minute: number, second: number, options: Calendar.Options): Date;
  nextDateAfterDateMatchingUnitValueOptions(_: Date, matchingUnit: Calendar.Unit, value: number, options: Calendar.Options): Date;
  nextWeekendStartDateIntervalOptionsAfterDate(_?: Date, interval?: number, options?: Calendar.Options, afterDate?: Date): boolean;
  ordinalityOfUnitInUnitForDate(_: Calendar.Unit, inUnit: Calendar.Unit, forDate: Date): number;
  rangeOfUnitInUnitForDate(_: Calendar.Unit, inUnit: Calendar.Unit, forDate: Date): NSRange;
  rangeOfUnitStartDateIntervalForDate(_: Calendar.Unit, startDate?: Date, interval?: number, forDate?: Date): boolean;
  rangeOfWeekendStartDateIntervalContainingDate(_?: Date, interval?: number, containingDate?: Date): boolean;
  startOfDayForDate(_: Date): Date;
}

export class CharacterSet extends NSObject {
  static characterSetWithBitmapRepresentation(_: Data): CharacterSet;
  static characterSetWithCharactersInString(_: string): CharacterSet;
  static characterSetWithContentsOfFile(_: string): CharacterSet;
  static characterSetWithRange(_: NSRange): CharacterSet;
  bitmapRepresentation: Data;
  invertedSet: CharacterSet;
  static URLFragmentAllowedCharacterSet: CharacterSet;
  static URLHostAllowedCharacterSet: CharacterSet;
  static URLPasswordAllowedCharacterSet: CharacterSet;
  static URLPathAllowedCharacterSet: CharacterSet;
  static URLQueryAllowedCharacterSet: CharacterSet;
  static URLUserAllowedCharacterSet: CharacterSet;
  static alphanumericCharacterSet: CharacterSet;
  static capitalizedLetterCharacterSet: CharacterSet;
  static controlCharacterSet: CharacterSet;
  static decimalDigitCharacterSet: CharacterSet;
  static decomposableCharacterSet: CharacterSet;
  static illegalCharacterSet: CharacterSet;
  static letterCharacterSet: CharacterSet;
  static lowercaseLetterCharacterSet: CharacterSet;
  static newlineCharacterSet: CharacterSet;
  static nonBaseCharacterSet: CharacterSet;
  static punctuationCharacterSet: CharacterSet;
  static symbolCharacterSet: CharacterSet;
  static uppercaseLetterCharacterSet: CharacterSet;
  static whitespaceAndNewlineCharacterSet: CharacterSet;
  static whitespaceCharacterSet: CharacterSet;
  characterIsMember(_: string): boolean;
  hasMemberInPlane(_: number): boolean;
  isSupersetOfSet(_: CharacterSet): boolean;
  longCharacterIsMember(_: number): boolean;
}

export class CollectionDifference<ObjectType> extends NSObject {
  hasChanges: boolean;
  insertions: NSOrderedCollectionChange<any>[];
  removals: NSOrderedCollectionChange<any>[];
  differenceByTransformingChangesWithBlock(_: (p1: NSOrderedCollectionChange<any>) => NSOrderedCollectionChange<any>): CollectionDifference<any>;
  inverseDifference(): CollectionDifference<ObjectType>;
}

export class Data extends NSObject {
  static data(): Data;
  static dataWithBytesLength(_?: any, length?: number): Data;
  static dataWithBytesNoCopyLength(_: any, length: number): Data;
  static dataWithBytesNoCopyLengthFreeWhenDone(_: any, length: number, freeWhenDone: boolean): Data;
  static dataWithContentsOfFile(_: string): Data;
  static dataWithContentsOfFileOptions(options: string, error: Data.ReadingOptions): Data;
  static dataWithContentsOfURL(_: URL): Data;
  static dataWithContentsOfURLOptions(options: URL, error: Data.ReadingOptions): Data;
  static dataWithData(_: Data): Data;
  bytes: any;
  length: number;
  base64EncodedDataWithOptions(_: Data.Base64EncodingOptions): Data;
  base64EncodedStringWithOptions(_: Data.Base64EncodingOptions): string;
  compressedDataUsingAlgorithm(error: Data.CompressionAlgorithm): Data;
  decompressedDataUsingAlgorithm(error: Data.CompressionAlgorithm): Data;
  enumerateByteRangesUsingBlock(_: (p1: any, p2: NSRange, p3: boolean) => void): void;
  static initWithBase64EncodedDataOptions(_: Data, options: Data.Base64DecodingOptions): Data;
  static initWithBase64EncodedStringOptions(_: string, options: Data.Base64DecodingOptions): Data;
  static initWithBytesLength(_?: any, length?: number): Data;
  static initWithBytesNoCopyLength(_: any, length: number): Data;
  static initWithBytesNoCopyLengthDeallocator(_: any, length: number, deallocator?: (p1: any, p2: number) => void): Data;
  static initWithBytesNoCopyLengthFreeWhenDone(_: any, length: number, freeWhenDone: boolean): Data;
  static initWithContentsOfFile(_: string): Data;
  static initWithContentsOfFileOptions(options: string, error: Data.ReadingOptions): Data;
  static initWithContentsOfURL(_: URL): Data;
  static initWithContentsOfURLOptions(options: URL, error: Data.ReadingOptions): Data;
  static initWithData(_: Data): Data;
  isEqualToData(_: Data): boolean;
  rangeOfDataOptionsRange(_: Data, options: Data.SearchOptions, range: NSRange): NSRange;
  subdataWithRange(_: NSRange): Data;
  writeToFileAtomically(_: string, atomically: boolean): boolean;
  writeToFileOptions(options: string, error: Data.WritingOptions): boolean;
  writeToURLAtomically(_: URL, atomically: boolean): boolean;
  writeToURLOptions(options: URL, error: Data.WritingOptions): boolean;
}

// @ts-ignore
type Date = NSDate
export class NSDate extends NSObject {
  static date(): Date;
  static dateWithTimeIntervalSinceDate(_: number, sinceDate: Date): Date;
  static dateWithTimeIntervalSince1970(_: number): Date;
  static dateWithTimeIntervalSinceNow(_: number): Date;
  static dateWithTimeIntervalSinceReferenceDate(_: number): Date;
  timeIntervalSince1970: number;
  timeIntervalSinceNow: number;
  timeIntervalSinceReferenceDate: number;
  static distantFuture: Date;
  static distantPast: Date;
  static now: Date;
  //   static timeIntervalSinceReferenceDate: number;
  compare(_: Date): NSObjCRuntime.ComparisonResult;
  dateByAddingTimeInterval(_: number): Date;
  descriptionWithLocale(_?: any): string;
  earlierDate(_: Date): Date;
  static initWithTimeIntervalSinceDate(_: number, sinceDate: Date): Date;
  static initWithTimeIntervalSince1970(_: number): Date;
  static initWithTimeIntervalSinceNow(_: number): Date;
  static initWithTimeIntervalSinceReferenceDate(_: number): Date;
  isEqualToDate(_: Date): boolean;
  laterDate(_: Date): Date;
  timeIntervalSinceDate(_: Date): number;
}

export class DateComponents extends NSObject {
  calendar: Calendar;
  setCalendar(_: Calendar);
  date: Date;
  day: number;
  setDay(_: number);
  era: number;
  setEra(_: number);
  hour: number;
  setHour(_: number);
  isLeapMonth: boolean;
  setLeapMonth(_: boolean);
  minute: number;
  setMinute(_: number);
  month: number;
  setMonth(_: number);
  nanosecond: number;
  setNanosecond(_: number);
  quarter: number;
  setQuarter(_: number);
  second: number;
  setSecond(_: number);
  timeZone: TimeZone;
  setTimeZone(_: TimeZone);
  isValidDate: boolean;
  weekOfMonth: number;
  setWeekOfMonth(_: number);
  weekOfYear: number;
  setWeekOfYear(_: number);
  weekday: number;
  setWeekday(_: number);
  weekdayOrdinal: number;
  setWeekdayOrdinal(_: number);
  year: number;
  setYear(_: number);
  yearForWeekOfYear: number;
  setYearForWeekOfYear(_: number);
  isValidDateInCalendar(_: Calendar): boolean;
  setValueForComponent(_: number, forComponent: Calendar.Unit): void;
  valueForComponent(_: Calendar.Unit): number;
}

export class DateComponentsFormatter extends Formatter {
  static localizedStringFromDateComponentsUnitsStyle(from: DateComponents, unitsStyle: DateComponentsFormatter.UnitsStyle): string;
  allowedUnits: Calendar.Unit;
  setAllowedUnits(_: Calendar.Unit);
  allowsFractionalUnits: boolean;
  setAllowsFractionalUnits(_: boolean);
  calendar: Calendar;
  setCalendar(_: Calendar);
  collapsesLargestUnit: boolean;
  setCollapsesLargestUnit(_: boolean);
  formattingContext: Formatter.Context;
  setFormattingContext(_: Formatter.Context);
  includesApproximationPhrase: boolean;
  setIncludesApproximationPhrase(_: boolean);
  includesTimeRemainingPhrase: boolean;
  setIncludesTimeRemainingPhrase(_: boolean);
  maximumUnitCount: number;
  setMaximumUnitCount(_: number);
  referenceDate: Date;
  setReferenceDate(_: Date);
  unitsStyle: DateComponentsFormatter.UnitsStyle;
  setUnitsStyle(_: DateComponentsFormatter.UnitsStyle);
  zeroFormattingBehavior: DateComponentsFormatter.ZeroFormattingBehavior;
  setZeroFormattingBehavior(_: DateComponentsFormatter.ZeroFormattingBehavior);
}

export class DateFormatter extends Formatter {
  //  static dateFormatFromTemplateOptionsLocale(fromTemplate: string, options: number, locale?: Locale): string;
  static localizedStringFromDateDateStyleTimeStyle(from: Date, dateStyle: DateFormatter.Style, timeStyle: DateFormatter.Style): string;
  AMSymbol: string;
  setAMSymbol(_: string);
  PMSymbol: string;
  setPMSymbol(_: string);
  calendar: Calendar;
  setCalendar(_: Calendar);
  dateFormat: string;
  setDateFormat(_: string);
  dateStyle: DateFormatter.Style;
  setDateStyle(_: DateFormatter.Style);
  defaultDate: Date;
  setDefaultDate(_: Date);
  doesRelativeDateFormatting: boolean;
  setDoesRelativeDateFormatting(_: boolean);
  eraSymbols: string[];
  setEraSymbols(_: string[]);
  formatterBehavior: DateFormatter.Behavior;
  setFormatterBehavior(_: DateFormatter.Behavior);
  formattingContext: Formatter.Context;
  setFormattingContext(_: Formatter.Context);
  generatesCalendarDates: boolean;
  setGeneratesCalendarDates(_: boolean);
  gregorianStartDate: Date;
  setGregorianStartDate(_: Date);
  isLenient: boolean;
  setLenient(_: boolean);
  locale: Locale;
  setLocale(_: Locale);
  longEraSymbols: string[];
  setLongEraSymbols(_: string[]);
  monthSymbols: string[];
  setMonthSymbols(_: string[]);
  quarterSymbols: string[];
  setQuarterSymbols(_: string[]);
  shortMonthSymbols: string[];
  setShortMonthSymbols(_: string[]);
  shortQuarterSymbols: string[];
  setShortQuarterSymbols(_: string[]);
  shortStandaloneMonthSymbols: string[];
  setShortStandaloneMonthSymbols(_: string[]);
  shortStandaloneQuarterSymbols: string[];
  setShortStandaloneQuarterSymbols(_: string[]);
  shortStandaloneWeekdaySymbols: string[];
  setShortStandaloneWeekdaySymbols(_: string[]);
  shortWeekdaySymbols: string[];
  setShortWeekdaySymbols(_: string[]);
  standaloneMonthSymbols: string[];
  setStandaloneMonthSymbols(_: string[]);
  standaloneQuarterSymbols: string[];
  setStandaloneQuarterSymbols(_: string[]);
  standaloneWeekdaySymbols: string[];
  setStandaloneWeekdaySymbols(_: string[]);
  timeStyle: DateFormatter.Style;
  setTimeStyle(_: DateFormatter.Style);
  timeZone: TimeZone;
  setTimeZone(_: TimeZone);
  twoDigitStartDate: Date;
  setTwoDigitStartDate(_: Date);
  veryShortMonthSymbols: string[];
  setVeryShortMonthSymbols(_: string[]);
  veryShortStandaloneMonthSymbols: string[];
  setVeryShortStandaloneMonthSymbols(_: string[]);
  veryShortStandaloneWeekdaySymbols: string[];
  setVeryShortStandaloneWeekdaySymbols(_: string[]);
  veryShortWeekdaySymbols: string[];
  setVeryShortWeekdaySymbols(_: string[]);
  weekdaySymbols: string[];
  setWeekdaySymbols(_: string[]);
  static defaultFormatterBehavior: DateFormatter.Behavior;
  setDefaultFormatterBehavior(_: DateFormatter.Behavior);
  dateFromString(from: string): Date;
  getObjectValueForStringRange(forString?: any, range?: string, error?: NSRange): boolean;
  setLocalizedDateFormatFromTemplate(_: string): void;
}

export class DateInterval extends NSObject {
  duration: number;
  endDate: Date;
  startDate: Date;
  compare(_: DateInterval): NSObjCRuntime.ComparisonResult;
  containsDate(_: Date): boolean;
  static initWithStartDateDuration(_: Date, duration: number): DateInterval;
  static initWithStartDateEndDate(_: Date, endDate: Date): DateInterval;
  intersectionWithDateInterval(_: DateInterval): DateInterval;
  intersectsDateInterval(_: DateInterval): boolean;
  isEqualToDateInterval(_: DateInterval): boolean;
}

export class DateIntervalFormatter extends Formatter {
  calendar: Calendar;
  setCalendar(_: Calendar);
  dateStyle: DateIntervalFormatter.Style;
  setDateStyle(_: DateIntervalFormatter.Style);
  dateTemplate: string;
  setDateTemplate(_: string);
  locale: Locale;
  setLocale(_: Locale);
  timeStyle: DateIntervalFormatter.Style;
  setTimeStyle(_: DateIntervalFormatter.Style);
  timeZone: TimeZone;
  setTimeZone(_: TimeZone);
}

export class Decimal extends NSNumber {
  static decimalNumberWithDecimal(_: DecimalStruct): Decimal;
  static decimalNumberWithMantissaExponentIsNegative(_: number, exponent: number, isNegative: boolean): Decimal;
  static decimalNumberWithString(_?: string): Decimal;
  static decimalNumberWithStringLocale(_?: string, locale?: any): Decimal;
  static defaultBehavior: any;
  setDefaultBehavior(_: any);
  static maximumDecimalNumber: number;
  static minimumDecimalNumber: number;
  static notANumber: number;
  static one: number;
  static zero: number;
  decimalNumberByAdding(_: number): Decimal;
  decimalNumberByAddingWithBehavior(_: number, withBehavior?: any): Decimal;
  decimalNumberByDividingBy(_: number): Decimal;
  decimalNumberByDividingByWithBehavior(_: number, withBehavior?: any): Decimal;
  decimalNumberByMultiplyingBy(_: number): Decimal;
  decimalNumberByMultiplyingByWithBehavior(_: number, withBehavior?: any): Decimal;
  decimalNumberByMultiplyingByPowerOf10(_: number): Decimal;
  decimalNumberByMultiplyingByPowerOf10WithBehavior(_: number, withBehavior?: any): Decimal;
  decimalNumberByRaisingToPower(_: number): Decimal;
  decimalNumberByRaisingToPowerWithBehavior(_: number, withBehavior?: any): Decimal;
  decimalNumberByRoundingAccordingToBehavior(_?: any): Decimal;
  decimalNumberBySubtracting(_: number): Decimal;
  decimalNumberBySubtractingWithBehavior(_: number, withBehavior?: any): Decimal;
  static initWithDecimal(_: DecimalStruct): Decimal;
  static initWithMantissaExponentIsNegative(_: number, exponent: number, isNegative: boolean): Decimal;
  static initWithString(_?: string): Decimal;
  static initWithStringLocale(_?: string, locale?: any): Decimal;
}

export class Dictionary<KeyType, ObjectType> extends NSObject {
  static dictionary<KeyType, ObjectType>(): Dictionary<KeyType, ObjectType>;
  static dictionaryWithContentsOfFile<KeyType, ObjectType>(_: string): Map<KeyType, ObjectType>;
  static dictionaryWithContentsOfURL<KeyType, ObjectType>(_: URL): Map<KeyType, ObjectType>;
  static dictionaryWithDictionary<KeyType, ObjectType>(_: Map<KeyType, ObjectType>): Dictionary<KeyType, ObjectType>;
  static dictionaryWithObjectForKey<KeyType, ObjectType>(_: ObjectType, forKey: KeyType): Dictionary<KeyType, ObjectType>;
  static dictionaryWithObjectsForKeys<KeyType, ObjectType>(_: ObjectType[], forKeys: KeyType[]): Dictionary<KeyType, ObjectType>;
  static dictionaryWithObjectsForKeysCount<KeyType, ObjectType>(_?: ObjectType, forKeys?: KeyType, count?: number): Dictionary<KeyType, ObjectType>;
  static sharedKeySetForKeys<KeyType>(_: KeyType[]): any;
  allKeys: KeyType[];
  allValues: ObjectType[];
  count: number;
  descriptionInStringsFileFormat: string;
  allKeysForObject(_: ObjectType): KeyType[];
  countByEnumeratingWithStateObjectsCount(_: NSFastEnumerationState, objects?: K, count?: number): number;
  descriptionWithLocale(_?: any): string;
  descriptionWithLocaleIndent(_?: any, indent?: number): string;
  enumerateKeysAndObjectsUsingBlock(_: (p1: KeyType, p2: ObjectType, p3: boolean) => void): void;
  enumerateKeysAndObjectsWithOptionsUsingBlock(_: NSObjCRuntime.NSEnumerationOptions, usingBlock: (p1: KeyType, p2: ObjectType, p3: boolean) => void): void;
  fileCreationDate(): Date;
  fileExtensionHidden(): boolean;
  fileGroupOwnerAccountID(): number;
  fileGroupOwnerAccountName(): string;
  fileHFSCreatorCode(): number;
  fileHFSTypeCode(): number;
  fileIsAppendOnly(): boolean;
  fileIsImmutable(): boolean;
  fileModificationDate(): Date;
  fileOwnerAccountID(): number;
  fileOwnerAccountName(): string;
  filePosixPermissions(): number;
  fileSize(): number;
  fileSystemFileNumber(): number;
  fileSystemNumber(): number;
  fileType(): string;
  isEqualToDictionary(_: Map<KeyType, ObjectType>): boolean;
  keyEnumerator(): NSEnumerator<any>;
  keysOfEntriesPassingTest(_: (p1: KeyType, p2: ObjectType, p3: boolean) => boolean): Set<any>;
  keysOfEntriesWithOptionsPassingTest(_: NSObjCRuntime.NSEnumerationOptions, passingTest: (p1: KeyType, p2: ObjectType, p3: boolean) => boolean): Set<any>;
  keysSortedByValueUsingComparator(_: (p1: any, p2: any) => NSObjCRuntime.ComparisonResult): KeyType[];
  keysSortedByValueUsingSelector(_: string): KeyType[];
  keysSortedByValueWithOptionsUsingComparator(_: NSObjCRuntime.NSSortOptions, usingComparator: (p1: any, p2: any) => NSObjCRuntime.ComparisonResult): KeyType[];
  objectEnumerator(): NSEnumerator<any>;
  objectForKey(_: KeyType): ObjectType;
  objectForKeyedSubscript(_: KeyType): ObjectType;
  objectsForKeysNotFoundMarker(_: KeyType[], notFoundMarker: ObjectType): ObjectType[];
  valueForKey(_: string): ObjectType;
  writeToFileAtomically(_: string, atomically: boolean): boolean;
  writeToURLAtomically(_: URL, atomically: boolean): boolean;
  writeToURL(error: URL): boolean;
}

export class Dimension extends Unit {
  static baseUnit(): Dimension;
  converter: UnitConverter;
  static initWithSymbolConverter(_: string, converter: UnitConverter): Dimension;
}

export class DistributedNotificationCenter extends NotificationCenter {
  suspended: boolean;
  setSuspended(_: boolean);
  addObserverSelectorNameObject(_: any, selector: string, name?: string, object_?: string): void;
  addObserverSelectorNameObjectSuspensionBehavior(_: any, selector: string, name?: string, object_?: string, suspensionBehavior?: DistributedNotificationCenter.SuspensionBehavior): void;
  postNotificationNameObject(name: string, object_?: string): void;
  postNotificationNameObjectUserInfo(name: string, object_?: string, userInfo?: Map<any, any>): void;
  postNotificationNameObjectUserInfoDeliverImmediately(_: string, object_?: string, userInfo?: Map<any, any>, deliverImmediately?: boolean): void;
  postNotificationNameObjectUserInfoOptions(_: string, object_?: string, userInfo?: Map<any, any>, options?: DistributedNotificationCenter.Options): void;
  removeObserverNameObject(_: any, name?: string, object_?: string): void;
}

export class EnergyFormatter extends Formatter {
  isForFoodEnergyUse: boolean;
  setForFoodEnergyUse(_: boolean);
  numberFormatter: NumberFormatter;
  setNumberFormatter(_: NumberFormatter);
  unitStyle: Formatter.UnitStyle;
  setUnitStyle(_: Formatter.UnitStyle);
  unitStringFromJoulesUsedUnit(fromJoules: number, usedUnit?: EnergyFormatter.Unit): string;
  unitStringFromValueUnit(fromValue: number, unit: EnergyFormatter.Unit): string;
}

// @ts-ignore
type Error = NSError
export class NSError extends NSObject {
  static errorWithDomainCodeUserInfo(_: string, code: number, userInfo?: Map<string, any>): Error;
  static setUserInfoValueProviderForDomainProvider(_: string, provider?: (p1: Error, p2: string) => any): void;
  static userInfoValueProviderForDomain(_: string): (p1: Error, p2: string) => any;
  code: number;
  domain: string;
  helpAnchor: string;
  localizedDescription: string;
  localizedFailureReason: string;
  localizedRecoveryOptions: string[];
  localizedRecoverySuggestion: string;
  recoveryAttempter: any;
  userInfo: Map<string, any>;
  static initWithDomainCodeUserInfo(_: string, code: number, userInfo?: Map<string, any>): Error;
}

export class FileHandle extends NSObject {
  static fileHandleForReadingFromURL(error: URL): FileHandle;
  static fileHandleForUpdatingURL(error: URL): FileHandle;
  static fileHandleForWritingToURL(error: URL): FileHandle;
  availableData: Data;
  fileDescriptor: number;
  offsetInFile: number;
  readabilityHandler: (p1: FileHandle) => void;
  setReadabilityHandler(_: (p1: FileHandle) => void);
  writeabilityHandler: (p1: FileHandle) => void;
  setWriteabilityHandler(_: (p1: FileHandle) => void);
  static fileHandleWithNullDevice: FileHandle;
  static fileHandleWithStandardError: FileHandle;
  static fileHandleWithStandardInput: FileHandle;
  static fileHandleWithStandardOutput: FileHandle;
  acceptConnectionInBackgroundAndNotify(): void;
  acceptConnectionInBackgroundAndNotifyForModes(forModes?: string[]): void;
  closeAndReturnError(): boolean;
  closeFile(): void;
  getOffset(error: number): boolean;
  static initWithFileDescriptor(_: number): FileHandle;
  static initWithFileDescriptorCloseOnDealloc(_: number, closeOnDealloc: boolean): FileHandle;
  readDataOfLength(ofLength: number): Data;
  readDataToEndOfFile(): Data;
  readDataToEndOfFileAndReturnError(): Data;
  readDataUpToLength(error: number): Data;
  readInBackgroundAndNotify(): void;
  readInBackgroundAndNotifyForModes(forModes?: string[]): void;
  readToEndOfFileInBackgroundAndNotify(): void;
  readToEndOfFileInBackgroundAndNotifyForModes(forModes?: string[]): void;
  seekToEndOfFile(): number;
  seekToEndReturningOffset(error?: number): boolean;
  seekToFileOffset(toFileOffset: number): void;
  seekToOffset(error: number): boolean;
  synchronizeAndReturnError(): boolean;
  synchronizeFile(): void;
  truncateAtOffset(error: number): boolean;
  truncateFileAtOffset(atOffset: number): void;
  waitForDataInBackgroundAndNotify(): void;
  waitForDataInBackgroundAndNotifyForModes(forModes?: string[]): void;
  writeData(_: Data): void;
  writeData(error: Data): boolean;
}

export class FileManager extends NSObject {
  currentDirectoryPath: string;
  delegate: any;
  setDelegate(_: any);
  homeDirectoryForCurrentUser: URL;
  temporaryDirectory: URL;
  ubiquityIdentityToken: any;
  static defaultManager: FileManager;
  uRLForDirectoryInDomainAppropriateForURLCreate(inDomain: NSPathUtilities.FileManager.SearchPathDirectory, appropriateForURL: NSPathUtilities.FileManager.SearchPathDomainMask, create?: URL, error?: boolean): URL;
  uRLForPublishingUbiquitousItemAtURLExpirationDate(expirationDate: URL, error?: Date): URL;
  uRLForUbiquityContainerIdentifier(forUbiquityContainerIdentifier?: string): URL;
  uRLsForDirectoryInDomains(for_: NSPathUtilities.FileManager.SearchPathDirectory, in_: NSPathUtilities.FileManager.SearchPathDomainMask): URL[];
  attributesOfFileSystemForPath(error: string): Map<string, any>;
  attributesOfItemAtPath(error: string): Map<string, any>;
  changeCurrentDirectoryPath(_: string): boolean;
  componentsToDisplayForPath(forPath: string): string[];
  containerURLForSecurityApplicationGroupIdentifier(forSecurityApplicationGroupIdentifier: string): URL;
  contentsAtPath(atPath: string): Data;
  contentsEqualAtPathAndPath(atPath: string, andPath: string): boolean;
  contentsOfDirectoryAtPath(error: string): string[];
  contentsOfDirectoryAtURLIncludingPropertiesForKeysOptions(includingPropertiesForKeys: URL, options?: string[], error?: FileManager.DirectoryEnumerationOptions): URL[];
  copyItemAtPathToPath(toPath: string, error: string): boolean;
  copyItemAtURLToURL(toURL: URL, error: URL): boolean;
  createDirectoryAtPathWithIntermediateDirectoriesAttributes(withIntermediateDirectories: string, attributes: boolean, error?: Map<string, any>): boolean;
  createDirectoryAtURLWithIntermediateDirectoriesAttributes(withIntermediateDirectories: URL, attributes: boolean, error?: Map<string, any>): boolean;
  createFileAtPathContentsAttributes(atPath: string, contents?: Data, attributes?: Map<string, any>): boolean;
  createSymbolicLinkAtPathWithDestinationPath(withDestinationPath: string, error: string): boolean;
  createSymbolicLinkAtURLWithDestinationURL(withDestinationURL: URL, error: URL): boolean;
  destinationOfSymbolicLinkAtPath(error: string): string;
  displayNameAtPath(atPath: string): string;
  enumeratorAtPath(atPath: string): FileManager.DirectoryEnumerator<any>;
  enumeratorAtURLIncludingPropertiesForKeysOptionsErrorHandler(_: URL, includingPropertiesForKeys?: string[], options?: FileManager.DirectoryEnumerationOptions, errorHandler?: (p1: URL, p2: Error) => boolean): FileManager.DirectoryEnumerator<any>;
  evictUbiquitousItemAtURL(error: URL): boolean;
  fileExistsAtPath(atPath: string): boolean;
  fileExistsAtPathIsDirectory(atPath: string, isDirectory?: boolean): boolean;
  fileSystemRepresentationWithPath(withPath: string): string;
  getFileProviderServicesForItemAtURLCompletionHandler(at: URL, completionHandler?: (p1: Map<string, NSFileProviderService>, p2: Error) => void): void;
  getRelationshipOfDirectoryInDomainToItemAtURL(ofDirectory: FileManager.URLRelationship, inDomain: NSPathUtilities.FileManager.SearchPathDirectory, toItemAtURL: NSPathUtilities.FileManager.SearchPathDomainMask, error: URL): boolean;
  getRelationshipOfDirectoryAtURLToItemAtURL(ofDirectoryAtURL: FileManager.URLRelationship, toItemAtURL: URL, error: URL): boolean;
  homeDirectoryForUser(forUser: string): URL;
  isDeletableFileAtPath(atPath: string): boolean;
  isExecutableFileAtPath(atPath: string): boolean;
  isReadableFileAtPath(atPath: string): boolean;
  isUbiquitousItemAtURL(at: URL): boolean;
  isWritableFileAtPath(atPath: string): boolean;
  linkItemAtPathToPath(toPath: string, error: string): boolean;
  linkItemAtURLToURL(toURL: URL, error: URL): boolean;
  mountedVolumeURLsIncludingResourceValuesForKeysOptions(includingResourceValuesForKeys?: string[], options?: FileManager.VolumeEnumerationOptions): URL[];
  moveItemAtPathToPath(toPath: string, error: string): boolean;
  moveItemAtURLToURL(toURL: URL, error: URL): boolean;
  removeItemAtPath(error: string): boolean;
  removeItemAtURL(error: URL): boolean;
  replaceItemAtURLWithItemAtURLBackupItemNameOptionsResultingItemURL(withItemAtURL: URL, backupItemName: URL, options?: string, resultingItemURL?: FileManager.ItemReplacementOptions, error?: URL): boolean;
  setAttributesOfItemAtPath(ofItemAtPath: Map<string, any>, error: string): boolean;
  setUbiquitousItemAtURLDestinationURL(itemAtURL: boolean, destinationURL: URL, error: URL): boolean;
  startDownloadingUbiquitousItemAtURL(error: URL): boolean;
  subpathsAtPath(atPath: string): string[];
  subpathsOfDirectoryAtPath(error: string): string[];
  trashItemAtURLResultingItemURL(resultingItemURL: URL, error?: URL): boolean;
  unmountVolumeAtURLOptionsCompletionHandler(at: URL, options: FileManager.UnmountOptions, completionHandler?: (p1: Error) => void): void;
}

interface FileManagerDelegate {
  fileManagerShouldCopyItemAtPathToPath(_: FileManager, shouldCopyItemAtPath: string, toPath: string): boolean;
  fileManagerShouldCopyItemAtURLToURL(_: FileManager, shouldCopyItemAt: URL, to: URL): boolean;
  fileManagerShouldProceedAfterErrorCopyingItemAtPathToPath(_: FileManager, shouldProceedAfterError: Error, copyingItemAtPath: string, toPath: string): boolean;
  fileManagerShouldProceedAfterErrorCopyingItemAtURLToURL(_: FileManager, shouldProceedAfterError: Error, copyingItemAt: URL, to: URL): boolean;
  fileManagerShouldMoveItemAtPathToPath(_: FileManager, shouldMoveItemAtPath: string, toPath: string): boolean;
  fileManagerShouldMoveItemAtURLToURL(_: FileManager, shouldMoveItemAt: URL, to: URL): boolean;
  fileManagerShouldProceedAfterErrorMovingItemAtPathToPath(_: FileManager, shouldProceedAfterError: Error, movingItemAtPath: string, toPath: string): boolean;
  fileManagerShouldProceedAfterErrorMovingItemAtURLToURL(_: FileManager, shouldProceedAfterError: Error, movingItemAt: URL, to: URL): boolean;
  fileManagerShouldLinkItemAtPathToPath(_: FileManager, shouldLinkItemAtPath: string, toPath: string): boolean;
  fileManagerShouldLinkItemAtURLToURL(_: FileManager, shouldLinkItemAt: URL, to: URL): boolean;
  fileManagerShouldProceedAfterErrorLinkingItemAtPathToPath(_: FileManager, shouldProceedAfterError: Error, linkingItemAtPath: string, toPath: string): boolean;
  fileManagerShouldProceedAfterErrorLinkingItemAtURLToURL(_: FileManager, shouldProceedAfterError: Error, linkingItemAt: URL, to: URL): boolean;
  fileManagerShouldRemoveItemAtPath(_: FileManager, shouldRemoveItemAtPath: string): boolean;
  fileManagerShouldRemoveItemAtURL(_: FileManager, shouldRemoveItemAt: URL): boolean;
  fileManagerShouldProceedAfterErrorRemovingItemAtPath(_: FileManager, shouldProceedAfterError: Error, removingItemAtPath: string): boolean;
  fileManagerShouldProceedAfterErrorRemovingItemAtURL(_: FileManager, shouldProceedAfterError: Error, removingItemAt: URL): boolean;
}

export class FileWrapper extends NSObject {
  isDirectory: boolean;
  fileAttributes: Map<string, any>;
  setFileAttributes(_: Map<string, any>);
  fileWrappers: Map<string, FileWrapper>;
  filename: string;
  setFilename(_: string);
  icon: NSImage;
  setIcon(_: NSImage);
  preferredFilename: string;
  setPreferredFilename(_: string);
  isRegularFile: boolean;
  regularFileContents: Data;
  serializedRepresentation: Data;
  isSymbolicLink: boolean;
  symbolicLinkDestinationURL: URL;
  addFileWrapper(_: FileWrapper): string;
  addRegularFileWithContentsPreferredFilename(withContents: Data, preferredFilename: string): string;
  static initDirectoryWithFileWrappers(_: Map<string, FileWrapper>): FileWrapper;
  static initRegularFileWithContents(_: Data): FileWrapper;
  static initSymbolicLinkWithDestinationURL(_: URL): FileWrapper;
  static initWithSerializedRepresentation(_: Data): FileWrapper;
  static initWithURLOptions(options: URL, error: FileWrapper.ReadingOptions): FileWrapper;
  keyForFileWrapper(_: FileWrapper): string;
  matchesContentsOfURL(of: URL): boolean;
  readFromURLOptions(options: URL, error: FileWrapper.ReadingOptions): boolean;
  removeFileWrapper(_: FileWrapper): void;
  writeToURLOptionsOriginalContentsURL(options: URL, originalContentsURL: FileWrapper.WritingOptions, error?: URL): boolean;
}

export class Formatter extends NSObject {
  attributedStringForObjectValueWithDefaultAttributes(for_: any, withDefaultAttributes?: Map<string, any>): NSAttributedString;
  editingStringForObjectValue(for_: any): string;
  getObjectValueForStringErrorDescription(_?: any, for_?: string, errorDescription?: string): boolean;
  isPartialStringValidNewEditingStringErrorDescription(_: string, newEditingString?: string, errorDescription?: string): boolean;
  isPartialStringValidProposedSelectedRangeOriginalStringOriginalSelectedRangeErrorDescription(_: string, proposedSelectedRange?: NSRange, originalString?: string, originalSelectedRange?: NSRange, errorDescription?: string): boolean;
}

export class HTTPCookie extends NSObject {
  static cookiesWithResponseHeaderFieldsForURL(withResponseHeaderFields: Map<string, string>, for_: URL): HTTPCookie[];
  static requestHeaderFieldsWithCookies(with_: HTTPCookie[]): Map<string, string>;
  isHTTPOnly: boolean;
  comment: string;
  commentURL: URL;
  domain: string;
  expiresDate: Date;
  name: string;
  path: string;
  portList: number[];
  properties: Map<string, any>;
  sameSitePolicy: string;
  isSecure: boolean;
  isSessionOnly: boolean;
  //   version: number;
  static initWithProperties(_: Map<string, any>): HTTPCookie;
}

export class HTTPCookieStorage extends NSObject {
  static sharedCookieStorageForGroupContainerIdentifier(forGroupContainerIdentifier: string): HTTPCookieStorage;
  cookieAcceptPolicy: HTTPCookieStorage.HTTPCookie.AcceptPolicy;
  setCookieAcceptPolicy(_: HTTPCookieStorage.HTTPCookie.AcceptPolicy);
  cookies: HTTPCookie[];
  static sharedHTTPCookieStorage: HTTPCookieStorage;
  // dupe name w instance property   cookiesForURL(for_: URL): HTTPCookie[];
  deleteCookie(_: HTTPCookie): void;
  getCookiesForTaskCompletionHandler(_: URLSessionTask, completionHandler?: (p1: HTTPCookie[]) => void): void;
  removeCookiesSinceDate(since: Date): void;
  setCookie(_: HTTPCookie): void;
  setCookiesForURLMainDocumentURL(_: HTTPCookie[], for_?: URL, mainDocumentURL?: URL): void;
  sortedCookiesUsingDescriptors(using: NSSortDescriptor[]): HTTPCookie[];
  storeCookiesForTask(_: HTTPCookie[], for_: URLSessionTask): void;
}

export class HTTPURLResponse extends URLResponse {
  static localizedStringForStatusCode(forStatusCode: number): string;
  allHeaderFields: Map<any, any>;
  statusCode: number;
  static initWithURLStatusCodeHTTPVersionHeaderFields(_: URL, statusCode: number, HTTPVersion?: string, headerFields?: Map<string, string>): HTTPURLResponse;
  valueForHTTPHeaderField(forHTTPHeaderField: string): string;
}

export class Host extends NSObject {
  static currentHost(): Host;
  address: string;
  addresses: string[];
  localizedName: string;
  name: string;
  names: string[];
  isEqualToHost(to: Host): boolean;
}

export class ISO8601DateFormatter extends Formatter {
  formatOptions: ISO8601DateFormatter.Options;
  setFormatOptions(_: ISO8601DateFormatter.Options);
  timeZone: TimeZone;
  setTimeZone(_: TimeZone);
  dateFromString(from: string): Date;
}

export class IndexPath extends NSObject {
  static indexPathForItemInSection(_: number, inSection: number): IndexPath;
  static indexPathWithIndex(_: number): IndexPath;
  static indexPathWithIndexesLength(_?: number, length?: number): IndexPath;
  item: number;
  length: number;
  section: number;
  compare(_: IndexPath): NSObjCRuntime.ComparisonResult;
  getIndexes(_: number): void;
  getIndexesRange(_: number, range: NSRange): void;
  indexAtPosition(_: number): number;
  indexPathByAddingIndex(_: number): IndexPath;
  indexPathByRemovingLastIndex(): IndexPath;
  static initWithIndex(_: number): IndexPath;
  static initWithIndexesLength(_?: number, length?: number): IndexPath;
}

export class IndexSet extends NSObject {
  static indexSet(): IndexSet;
  static indexSetWithIndex(_: number): IndexSet;
  static indexSetWithIndexesInRange(_: NSRange): IndexSet;
  count: number;
  firstIndex: number;
  lastIndex: number;
  containsIndex(_: number): boolean;
  containsIndexes(_: IndexSet): boolean;
  containsIndexesInRange(_: NSRange): boolean;
  countOfIndexesInRange(_: NSRange): number;
  enumerateIndexesInRangeOptionsUsingBlock(_: NSRange, options: NSObjCRuntime.NSEnumerationOptions, usingBlock: (p1: number, p2: boolean) => void): void;
  enumerateIndexesUsingBlock(_: (p1: number, p2: boolean) => void): void;
  enumerateIndexesWithOptionsUsingBlock(_: NSObjCRuntime.NSEnumerationOptions, usingBlock: (p1: number, p2: boolean) => void): void;
  enumerateRangesInRangeOptionsUsingBlock(_: NSRange, options: NSObjCRuntime.NSEnumerationOptions, usingBlock: (p1: NSRange, p2: boolean) => void): void;
  enumerateRangesUsingBlock(_: (p1: NSRange, p2: boolean) => void): void;
  enumerateRangesWithOptionsUsingBlock(_: NSObjCRuntime.NSEnumerationOptions, usingBlock: (p1: NSRange, p2: boolean) => void): void;
  getIndexesMaxCountInIndexRange(_: number, maxCount: number, inIndexRange?: NSRange): number;
  indexGreaterThanIndex(_: number): number;
  indexGreaterThanOrEqualToIndex(_: number): number;
  indexInRangeOptionsPassingTest(_: NSRange, options: NSObjCRuntime.NSEnumerationOptions, passingTest: (p1: number, p2: boolean) => boolean): number;
  indexLessThanIndex(_: number): number;
  indexLessThanOrEqualToIndex(_: number): number;
  indexPassingTest(_: (p1: number, p2: boolean) => boolean): number;
  indexWithOptionsPassingTest(_: NSObjCRuntime.NSEnumerationOptions, passingTest: (p1: number, p2: boolean) => boolean): number;
  indexesInRangeOptionsPassingTest(_: NSRange, options: NSObjCRuntime.NSEnumerationOptions, passingTest: (p1: number, p2: boolean) => boolean): IndexSet;
  indexesPassingTest(_: (p1: number, p2: boolean) => boolean): IndexSet;
  indexesWithOptionsPassingTest(_: NSObjCRuntime.NSEnumerationOptions, passingTest: (p1: number, p2: boolean) => boolean): IndexSet;
  static initWithIndex(_: number): IndexSet;
  static initWithIndexSet(_: IndexSet): IndexSet;
  static initWithIndexesInRange(_: NSRange): IndexSet;
  intersectsIndexesInRange(_: NSRange): boolean;
  isEqualToIndexSet(_: IndexSet): boolean;
}

export class InputStream extends Stream {
  hasBytesAvailable: boolean;
  getBufferLength(_?: string, length?: number): boolean;
  static initWithData(_: Data): InputStream;
  static initWithFileAtPath(_: string): InputStream;
  static initWithURL(_: URL): InputStream;
  readMaxLength(_: string, maxLength: number): number;
}

export class JSONSerialization extends NSObject {
  static jSONObjectWithDataOptions(options: Data, error: JSONSerialization.ReadingOptions): any;
  static jSONObjectWithStreamOptions(options: InputStream, error: JSONSerialization.ReadingOptions): any;
  static dataWithJSONObjectOptions(options: any, error: JSONSerialization.WritingOptions): Data;
  static isValidJSONObject(_: any): boolean;
  static writeJSONObjectToStreamOptions(_: any, to: OutputStream, options: JSONSerialization.WritingOptions): number;
}

export class LengthFormatter extends Formatter {
  isForPersonHeightUse: boolean;
  setForPersonHeightUse(_: boolean);
  numberFormatter: NumberFormatter;
  setNumberFormatter(_: NumberFormatter);
  unitStyle: Formatter.UnitStyle;
  setUnitStyle(_: Formatter.UnitStyle);
  unitStringFromMetersUsedUnit(fromMeters: number, usedUnit?: LengthFormatter.Unit): string;
  unitStringFromValueUnit(fromValue: number, unit: LengthFormatter.Unit): string;
}

export class ListFormatter extends Formatter {
  static localizedStringByJoiningStrings(byJoining: string[]): string;
  itemFormatter: Formatter;
  setItemFormatter(_: Formatter);
  locale: Locale;
  setLocale(_: Locale);
}

export class Locale extends NSObject {
  static canonicalLanguageIdentifierFromString(_: string): string;
  static canonicalLocaleIdentifierFromString(_: string): string;
  static characterDirectionForLanguage(_: string): Locale.LanguageDirection;
  static componentsFromLocaleIdentifier(_: string): Map<string, string>;
  static lineDirectionForLanguage(_: string): Locale.LanguageDirection;
  static localeIdentifierFromComponents(_: Map<string, string>): string;
  static localeIdentifierFromWindowsLocaleCode(_: number): string;
  static localeWithLocaleIdentifier(_: string): Locale;
  static windowsLocaleCodeFromLocaleIdentifier(_: string): number;
  alternateQuotationBeginDelimiter: string;
  alternateQuotationEndDelimiter: string;
  calendarIdentifier: string;
  collationIdentifier: string;
  collatorIdentifier: string;
  countryCode: string;
  currencyCode: string;
  currencySymbol: string;
  decimalSeparator: string;
  exemplarCharacterSet: CharacterSet;
  groupingSeparator: string;
  languageCode: string;
  localeIdentifier: string;
  quotationBeginDelimiter: string;
  quotationEndDelimiter: string;
  scriptCode: string;
  usesMetricSystem: boolean;
  variantCode: string;
  static ISOCountryCodes: string[];
  static ISOCurrencyCodes: string[];
  static ISOLanguageCodes: string[];
  static autoupdatingCurrentLocale: Locale;
  static availableLocaleIdentifiers: string[];
  static commonISOCurrencyCodes: string[];
  static currentLocale: Locale;
  static preferredLanguages: string[];
  static systemLocale: Locale;
  displayNameForKeyValue(_: string, value: any): string;
  static initWithLocaleIdentifier(_: string): Locale;
  localizedStringForCalendarIdentifier(_: string): string;
  localizedStringForCollationIdentifier(_: string): string;
  localizedStringForCollatorIdentifier(_: string): string;
  localizedStringForCountryCode(_: string): string;
  localizedStringForCurrencyCode(_: string): string;
  localizedStringForLanguageCode(_: string): string;
  localizedStringForLocaleIdentifier(_: string): string;
  localizedStringForScriptCode(_: string): string;
  localizedStringForVariantCode(_: string): string;
  objectForKey(_: string): any;
}

export class MassFormatter extends Formatter {
  isForPersonMassUse: boolean;
  setForPersonMassUse(_: boolean);
  numberFormatter: NumberFormatter;
  setNumberFormatter(_: NumberFormatter);
  unitStyle: Formatter.UnitStyle;
  setUnitStyle(_: Formatter.UnitStyle);
  unitStringFromKilogramsUsedUnit(fromKilograms: number, usedUnit?: MassFormatter.Unit): string;
  unitStringFromValueUnit(fromValue: number, unit: MassFormatter.Unit): string;
}

export class Measurement<UnitType> extends NSObject {
  doubleValue: number;
  unit: UnitType;
  canBeConvertedToUnit(_: Unit): boolean;
  measurementByAddingMeasurement(_: Measurement<any>): Measurement<any>;
  measurementByConvertingToUnit(_: Unit): Measurement<any>;
  measurementBySubtractingMeasurement(_: Measurement<any>): Measurement<any>;
}

export class MeasurementFormatter extends Formatter {
  locale: Locale;
  setLocale(_: Locale);
  numberFormatter: NumberFormatter;
  setNumberFormatter(_: NumberFormatter);
  unitOptions: MeasurementFormatter.UnitOptions;
  setUnitOptions(_: MeasurementFormatter.UnitOptions);
  unitStyle: Formatter.UnitStyle;
  setUnitStyle(_: Formatter.UnitStyle);
}

export class MessagePort extends Port {
}

// export function NSAllHashTableObjects(table: NSHashTable<any>): any[];

// export function NSAllMapTableKeys(table: NSMapTable<any, any>): any[];

// export function NSAllMapTableValues(table: NSMapTable<any, any>): any[];

// export function NSAllocateCollectable(size: number, options: number): any;

// export function NSAllocateMemoryPages(bytes: number): any;

// export function NSAllocateObject(aClass: typeof NSObject, extraBytes: number, zone: any): any;

export class NSAppleEventDescriptor extends NSObject {
  static appleEventWithEventClassEventIDTargetDescriptorReturnIDTransactionID(withEventClass: number, eventID: number, targetDescriptor?: NSAppleEventDescriptor, returnID?: number, transactionID?: number): NSAppleEventDescriptor;
  static currentProcessDescriptor(): NSAppleEventDescriptor;
  static listDescriptor(): NSAppleEventDescriptor;
  static nullDescriptor(): NSAppleEventDescriptor;
  static recordDescriptor(): NSAppleEventDescriptor;
  aeDesc: AEDesc;
  booleanValue: boolean;
  data: Data;
  dateValue: Date;
  descriptorType: number;
  doubleValue: number;
  enumCodeValue: number;
  eventClass: number;
  eventID: number;
  fileURLValue: URL;
  int32Value: number;
  isRecordDescriptor: boolean;
  numberOfItems: number;
  returnID: number;
  stringValue: string;
  transactionID: number;
  typeCodeValue: number;
  attributeDescriptorForKeyword(forKeyword: number): NSAppleEventDescriptor;
  coerceToDescriptorType(toDescriptorType: number): NSAppleEventDescriptor;
  descriptorAtIndex(_: number): NSAppleEventDescriptor;
  descriptorForKeyword(_: number): NSAppleEventDescriptor;
  static initListDescriptor(): NSAppleEventDescriptor;
  static initRecordDescriptor(): NSAppleEventDescriptor;
  static initWithAEDescNoCopy(_: AEDesc): NSAppleEventDescriptor;
  static initWithDescriptorTypeBytesLength(_: number, bytes?: any, length?: number): NSAppleEventDescriptor;
  static initWithDescriptorTypeData(_: number, data?: Data): NSAppleEventDescriptor;
  static initWithEventClassEventIDTargetDescriptorReturnIDTransactionID(_: number, eventID: number, targetDescriptor?: NSAppleEventDescriptor, returnID?: number, transactionID?: number): NSAppleEventDescriptor;
  insertDescriptorAtIndex(_: NSAppleEventDescriptor, at: number): void;
  keywordForDescriptorAtIndex(at: number): number;
  paramDescriptorForKeyword(forKeyword: number): NSAppleEventDescriptor;
  removeDescriptorAtIndex(at: number): void;
  removeDescriptorWithKeyword(withKeyword: number): void;
  removeParamDescriptorWithKeyword(withKeyword: number): void;
  sendEventWithOptionsTimeout(timeout: NSAppleEventDescriptor.SendOptions, error: number): NSAppleEventDescriptor;
  setAttributeDescriptorForKeyword(_: NSAppleEventDescriptor, forKeyword: number): void;
  setDescriptorForKeyword(_: NSAppleEventDescriptor, forKeyword: number): void;
  setParamDescriptorForKeyword(_: NSAppleEventDescriptor, forKeyword: number): void;
}

export class NSAppleEventManager extends NSObject {
  static sharedAppleEventManager(): NSAppleEventManager;
  currentAppleEvent: NSAppleEventDescriptor;
  currentReplyAppleEvent: NSAppleEventDescriptor;
  appleEventForSuspensionID(forSuspensionID: any): NSAppleEventDescriptor;
  dispatchRawAppleEventWithRawReplyHandlerRefCon(_: AEDesc, withRawReply: AEDesc, handlerRefCon: any): number;
  removeEventHandlerForEventClassAndEventID(forEventClass: number, andEventID: number): void;
  replyAppleEventForSuspensionID(forSuspensionID: any): NSAppleEventDescriptor;
  resumeWithSuspensionID(withSuspensionID: any): void;
  setCurrentAppleEventAndReplyEventWithSuspensionID(_: any): void;
  setEventHandlerAndSelectorForEventClassAndEventID(_: any, andSelector: string, forEventClass: number, andEventID: number): void;
  suspendCurrentAppleEvent(): any;
}

export class NSAppleScript extends NSObject {
  isCompiled: boolean;
  richTextSource: NSAttributedString;
  source: string;
  compileAndReturnError(_?: Map<string, any>): boolean;
  executeAndReturnError(_?: Map<string, any>): NSAppleEventDescriptor;
  executeAppleEventError(_: NSAppleEventDescriptor, error?: Map<string, any>): NSAppleEventDescriptor;
  static initWithContentsOfURLError(_: URL, error?: Map<string, any>): NSAppleScript;
  static initWithSource(_: string): NSAppleScript;
}

export class NSAssertionHandler extends NSObject {
  static currentHandler: NSAssertionHandler;
}

export class NSAttributedString extends NSObject {
  containsAttachments: boolean;
  length: number;
  static textTypes: string[];
  static textUnfilteredTypes: string[];
  rTFDFileWrapperFromRangeDocumentAttributes(from: NSRange, documentAttributes: Map<string, any>): FileWrapper;
  rTFDFromRangeDocumentAttributes(from: NSRange, documentAttributes: Map<string, any>): Data;
  rTFFromRangeDocumentAttributes(from: NSRange, documentAttributes: Map<string, any>): Data;
  attributeAtIndexEffectiveRange(_: string, at: number, effectiveRange?: NSRange): any;
  attributeAtIndexLongestEffectiveRangeInRange(_: string, at: number, longestEffectiveRange?: NSRange, in_?: NSRange): any;
  attributedSubstringFromRange(from: NSRange): NSAttributedString;
  attributesAtIndexEffectiveRange(at: number, effectiveRange?: NSRange): Map<string, any>;
  attributesAtIndexLongestEffectiveRangeInRange(at: number, longestEffectiveRange?: NSRange, in_?: NSRange): Map<string, any>;
  boundingRectWithSizeOptions(with_: CGSize, options: NSStringDrawing.String.DrawingOptions): CGRect;
  boundingRectWithSizeOptionsContext(with_: CGSize, options: NSStringDrawing.String.DrawingOptions, context?: NSStringDrawingContext): CGRect;
  // dupe name w instance property   containsAttachmentsInRange(in_: NSRange): boolean;
  dataFromRangeDocumentAttributes(documentAttributes: NSRange, error: Map<string, any>): Data;
  docFormatFromRangeDocumentAttributes(from: NSRange, documentAttributes: Map<string, any>): Data;
  doubleClickAtIndex(at: number): NSRange;
  drawAtPoint(at: CGPoint): void;
  drawInRect(in_: CGRect): void;
  drawWithRectOptions(with_: CGRect, options: NSStringDrawing.String.DrawingOptions): void;
  drawWithRectOptionsContext(with_: CGRect, options: NSStringDrawing.String.DrawingOptions, context?: NSStringDrawingContext): void;
  enumerateAttributeInRangeOptionsUsingBlock(_: string, in_: NSRange, options: NSAttributedString.EnumerationOptions, using?: (p1: any, p2: NSRange, p3: boolean) => void): void;
  enumerateAttributesInRangeOptionsUsingBlock(in_: NSRange, options: NSAttributedString.EnumerationOptions, using: (p1: Map<string, any>, p2: NSRange, p3: boolean) => void): void;
  fileWrapperFromRangeDocumentAttributes(documentAttributes: NSRange, error: Map<string, any>): FileWrapper;
  fontAttributesInRange(in_: NSRange): Map<string, any>;
  static initWithAttributedString(_: NSAttributedString): NSAttributedString;
  static initWithDataOptionsDocumentAttributes(options: Data, documentAttributes: Map<string, any>, error?: Map<string, any>): NSAttributedString;
  static initWithDocFormatDocumentAttributes(_: Data, documentAttributes?: Map<string, any>): NSAttributedString;
  static initWithHTMLBaseURLDocumentAttributes(_: Data, baseURL: URL, documentAttributes?: Map<string, any>): NSAttributedString;
  static initWithHTMLDocumentAttributes(_: Data, documentAttributes?: Map<string, any>): NSAttributedString;
  static initWithHTMLOptionsDocumentAttributes(_: Data, options: Map<string, any>, documentAttributes?: Map<string, any>): NSAttributedString;
  static initWithRTFDocumentAttributes(_: Data, documentAttributes?: Map<string, any>): NSAttributedString;
  static initWithRTFDDocumentAttributes(_: Data, documentAttributes?: Map<string, any>): NSAttributedString;
  static initWithRTFDFileWrapperDocumentAttributes(_: FileWrapper, documentAttributes?: Map<string, any>): NSAttributedString;
  static initWithString(_: string): NSAttributedString;
  static initWithStringAttributes(_: string, attributes?: Map<string, any>): NSAttributedString;
  static initWithURLOptionsDocumentAttributes(options: URL, documentAttributes: Map<string, any>, error?: Map<string, any>): NSAttributedString;
  isEqualToAttributedString(to: NSAttributedString): boolean;
  itemNumberInTextListAtIndex(in_: NSTextList, at: number): number;
  lineBreakBeforeIndexWithinRange(before: number, within: NSRange): number;
  lineBreakByHyphenatingBeforeIndexWithinRange(before: number, within: NSRange): number;
  nextWordFromIndexForward(from: number, forward: boolean): number;
  rangeOfTextBlockAtIndex(of: NSTextBlock, at: number): NSRange;
  rangeOfTextListAtIndex(of: NSTextList, at: number): NSRange;
  rangeOfTextTableAtIndex(of: NSTextTable, at: number): NSRange;
  rulerAttributesInRange(in_: NSRange): Map<string, any>;
  size(): CGSize;
}

export class NSAutoreleasePool extends NSObject {
  //  static addObject(_: any): void;
  static showPools(): void;
  addObject(_: any): void;
  drain(): void;
}

export class NSBackgroundActivityScheduler extends NSObject {
  identifier: string;
  interval: number;
  setInterval(_: number);
  qualityOfService: NSObjCRuntime.QualityOfService;
  setQualityOfService(_: NSObjCRuntime.QualityOfService);
  repeats: boolean;
  setRepeats(_: boolean);
  shouldDefer: boolean;
  tolerance: number;
  setTolerance(_: number);
  static initWithIdentifier(_: string): NSBackgroundActivityScheduler;
  invalidate(): void;
  scheduleWithBlock(_: (p1: (p1: NSBackgroundActivityScheduler.Result) => void) => void): void;
}

export class NSBundleResourceRequest extends NSObject {
  bundle: Bundle;
  loadingPriority: number;
  setLoadingPriority(_: number);
  tags: Set<any>;
  beginAccessingResourcesWithCompletionHandler(completionHandler?: (p1: Error) => void): void;
  conditionallyBeginAccessingResourcesWithCompletionHandler(completionHandler: (p1: boolean) => void): void;
  endAccessingResources(): void;
  static initWithTags(_: Set<any>): NSBundleResourceRequest;
  static initWithTagsBundle(_: Set<any>, bundle: Bundle): NSBundleResourceRequest;
}

export class NSCache<KeyType, ObjectType> extends NSObject {
  countLimit: number;
  setCountLimit(_: number);
  delegate: any;
  setDelegate(_: any);
  evictsObjectsWithDiscardedContent: boolean;
  setEvictsObjectsWithDiscardedContent(_: boolean);
  name: string;
  setName(_: string);
  totalCostLimit: number;
  setTotalCostLimit(_: number);
  objectForKey(forKey: KeyType): ObjectType;
  removeAllObjects(): void;
  removeObjectForKey(forKey: KeyType): void;
  setObjectForKey(_: ObjectType, forKey: KeyType): void;
  setObjectForKeyCost(_: ObjectType, forKey: KeyType, cost: number): void;
}

interface NSCacheDelegate {
  cacheWillEvictObject(_: NSCache<any, any>, willEvictObject: any): void;
}

export class NSCalendarDate extends Date {
  //  static date(): NSCalendarDate;
  //  static dateWithTimeIntervalSinceDate(_: number, sinceDate: Date): NSCalendarDate;
  //  static dateWithTimeIntervalSince1970(_: number): NSCalendarDate;
  //  static dateWithTimeIntervalSinceNow(_: number): NSCalendarDate;
  //  static dateWithTimeIntervalSinceReferenceDate(_: number): NSCalendarDate;
}

export class NSClassDescription extends NSObject {
  static invalidateClassDescriptionCache(): void;
  static registerClassDescriptionForClass(_: NSClassDescription, for_: typeof NSObject): void;
}

// export function NSClassFromString(aClassName: string): typeof NSObject;

export class NSCloneCommand extends NSScriptCommand {
  keySpecifier: NSScriptObjectSpecifier;
  setReceiversSpecifier(_?: NSScriptObjectSpecifier): void;
}

export class NSCloseCommand extends NSScriptCommand {
}

export class NSCoder extends NSObject {
  allowedClasses: Set<any>;
  allowsKeyedCoding: boolean;
  decodingFailurePolicy: NSCoder.DecodingFailurePolicy;
  error: Error;
  requiresSecureCoding: boolean;
  systemVersion: number;
  containsValueForKey(forKey: string): boolean;
  decodeArrayOfObjCTypeCountAt(ofObjCType: string, count: number, at: any): void;
  decodeBoolForKey(forKey: string): boolean;
  decodeBytesForKeyReturnedLength(forKey: string, returnedLength?: number): string;
  decodeBytesWithReturnedLength(withReturnedLength: number): any;
  decodeCMTimeForKey(forKey: string): CMTime;
  decodeCMTimeMappingForKey(forKey: string): CMTimeMapping;
  decodeCMTimeRangeForKey(forKey: string): CMTimeRange;
  decodeDataObject(): Data;
  decodeDoubleForKey(forKey: string): number;
  decodeFloatForKey(forKey: string): number;
  decodeInt32ForKey(forKey: string): number;
  decodeInt64ForKey(forKey: string): number;
  decodeIntForKey(forKey: string): number;
  decodeIntegerForKey(forKey: string): number;
  decodeObject(): any;
  decodeObjectForKey(forKey: string): any;
  decodePoint(): CGPoint;
  decodePointForKey(forKey: string): CGPoint;
  decodePropertyList(): any;
  decodePropertyListForKey(forKey: string): any;
  decodeRect(): CGRect;
  decodeRectForKey(forKey: string): CGRect;
  decodeSize(): CGSize;
  decodeSizeForKey(forKey: string): CGSize;
  decodeValueOfObjCTypeAt(ofObjCType: string, at: any): void;
  decodeValueOfObjCTypeAtSize(ofObjCType: string, at: any, size: number): void;
  encodeArrayOfObjCTypeCountAt(ofObjCType: string, count: number, at: any): void;
  encodeBoolForKey(_: boolean, forKey: string): void;
  encodeBycopyObject(_?: any): void;
  encodeByrefObject(_?: any): void;
  encodeBytesLength(_?: any, length?: number): void;
  encodeBytesLengthForKey(_?: string, length?: number, forKey?: string): void;
  encodeCMTimeForKey(_: CMTime, forKey: string): void;
  encodeCMTimeMappingForKey(_: CMTimeMapping, forKey: string): void;
  encodeCMTimeRangeForKey(_: CMTimeRange, forKey: string): void;
  encodeConditionalObject(_?: any): void;
  encodeConditionalObjectForKey(_?: any, forKey?: string): void;
  encodeDataObject(_: Data): void;
  encodeDoubleForKey(_: number, forKey: string): void;
  encodeFloatForKey(_: number, forKey: string): void;
  encodeInt32ForKey(_: number, forKey: string): void;
  encodeInt64ForKey(_: number, forKey: string): void;
  encodeIntForKey(_: number, forKey: string): void;
  encodeIntegerForKey(_: number, forKey: string): void;
  encodeObject(_?: any): void;
  encodeObjectForKey(_?: any, forKey?: string): void;
  encodePoint(_: CGPoint): void;
  encodePointForKey(_: CGPoint, forKey: string): void;
  encodePropertyList(_: any): void;
  encodeRect(_: CGRect): void;
  encodeRectForKey(_: CGRect, forKey: string): void;
  encodeRootObject(_: any): void;
  encodeSize(_: CGSize): void;
  encodeSizeForKey(_: CGSize, forKey: string): void;
  encodeValueOfObjCTypeAt(ofObjCType: string, at: any): void;
  failWithError(_: Error): void;
  // dupe name w inherited static method  versionForClassName(forClassName: string): number;
}

interface NSCoding {
  encodeWithCoder(with_: NSCoder): void;
}

// export function NSCompareHashTables(table1: NSHashTable<any>, table2: NSHashTable<any>): boolean;

// export function NSCompareMapTables(table1: NSMapTable<any, any>, table2: NSMapTable<any, any>): boolean;

export class NSComparisonPredicate extends NSPredicate {
  comparisonPredicateModifier: NSComparisonPredicate.Modifier;
  customSelector: string;
  leftExpression: NSExpression;
  options: NSComparisonPredicate.Options;
  predicateOperatorType: NSComparisonPredicate.Operator;
  rightExpression: NSExpression;
  static initWithLeftExpressionRightExpressionCustomSelector(_: NSExpression, rightExpression: NSExpression, customSelector: string): NSComparisonPredicate;
  static initWithLeftExpressionRightExpressionModifierTypeOptions(_: NSExpression, rightExpression: NSExpression, modifier: NSComparisonPredicate.Modifier, type: NSComparisonPredicate.Operator, options: NSComparisonPredicate.Options): NSComparisonPredicate;
}

export class NSCompoundPredicate extends NSPredicate {
  compoundPredicateType: NSCompoundPredicate.LogicalType;
  subpredicates: any[];
  static initWithTypeSubpredicates(_: NSCompoundPredicate.LogicalType, subpredicates: NSPredicate[]): NSCompoundPredicate;
}

export class NSCondition extends NSObject {
  name: string;
  setName(_: string);
  broadcast(): void;
  signal(): void;
  wait(): void;
  waitUntilDate(until: Date): boolean;
}

export class NSConditionLock extends NSObject {
  condition: number;
  name: string;
  setName(_: string);
  static initWithCondition(_: number): NSConditionLock;
  lockBeforeDate(before: Date): boolean;
  lockWhenCondition(whenCondition: number): void;
  lockWhenConditionBeforeDate(whenCondition: number, before: Date): boolean;
  tryLock(): boolean;
  tryLockWhenCondition(whenCondition: number): boolean;
  unlockWithCondition(withCondition: number): void;
}

export class NSConnection extends NSObject {
  static allConnections(): NSConnection[];
  static currentConversation(): any;
  static rootProxyForConnectionWithRegisteredNameHost(withRegisteredName: string, host?: string): NSDistantObject;
  static rootProxyForConnectionWithRegisteredNameHostUsingNameServer(withRegisteredName: string, host?: string, using?: NSPortNameServer): NSDistantObject;
  static serviceConnectionWithNameRootObject(withName: string, rootObject: any): NSConnection;
  static serviceConnectionWithNameRootObjectUsingNameServer(withName: string, rootObject: any, using: NSPortNameServer): NSConnection;
  delegate: any;
  setDelegate(_: any);
  independentConversationQueueing: boolean;
  setIndependentConversationQueueing(_: boolean);
  localObjects: any[];
  multipleThreadsEnabled: boolean;
  receivePort: Port;
  remoteObjects: any[];
  replyTimeout: number;
  setReplyTimeout(_: number);
  requestModes: string[];
  requestTimeout: number;
  setRequestTimeout(_: number);
  rootObject: any;
  setRootObject(_: any);
  rootProxy: NSDistantObject;
  sendPort: Port;
  statistics: Map<string, number>;
  isValid: boolean;
  addRequestMode(_: string): void;
  addRunLoop(_: RunLoop): void;
  dispatchWithComponents(withComponents: any[]): void;
  enableMultipleThreads(): void;
  static initWithReceivePortSendPort(_?: Port, sendPort?: Port): NSConnection;
  invalidate(): void;
  registerName(_?: string): boolean;
  registerNameWithNameServer(_?: string, with_?: NSPortNameServer): boolean;
  removeRequestMode(_: string): void;
  removeRunLoop(_: RunLoop): void;
  runInNewThread(): void;
}

interface NSConnectionDelegate {
  authenticateComponentsWithData(_: any[], with_: Data): boolean;
  authenticationDataForComponents(forComponents: any[]): Data;
  connectionShouldMakeNewConnection(_: NSConnection, shouldMakeNewConnection: NSConnection): boolean;
  connectionHandleRequest(_: NSConnection, handle: NSDistantObjectRequest): boolean;
  createConversationForConnection(for_: NSConnection): any;
  makeNewConnectionSender(_: NSConnection, sender: NSConnection): boolean;
}

export class NSConstantString extends NSSimpleCString {
  //  static objectWithItemProviderDataTypeIdentifier(typeIdentifier: Data, error: string): NSConstantString;
  //  static stringWithCStringEncoding(_: string, encoding: number): NSConstantString;
  //  static stringWithCharactersLength(_: string, length: number): NSConstantString;
  //  static stringWithContentsOfFileEncoding(encoding: string, error: number): NSConstantString;
  //  static stringWithContentsOfFileUsedEncoding(usedEncoding: string, error?: number): NSConstantString;
  //  static stringWithContentsOfURLEncoding(encoding: URL, error: number): NSConstantString;
  //  static stringWithContentsOfURLUsedEncoding(usedEncoding: URL, error?: number): NSConstantString;
  //  static stringWithString(_: string): NSConstantString;
  //  static stringWithUTF8String(_: string): NSConstantString;
}

// export function NSContainsRect(aRect: CGRect, bRect: CGRect): boolean;

// export function NSCopyHashTableWithZone(table: NSHashTable<any>, zone: any): NSHashTable<any>;

// export function NSCopyMapTableWithZone(table: NSMapTable<any, any>, zone: any): NSMapTable<any, any>;

// export function NSCopyMemoryPages(source: any, dest: any, bytes: number): void;

interface NSCopying {
  copyWithZone(with_?: any): any;
}

export class NSCountCommand extends NSScriptCommand {
}

// export function NSCountFrames(): number;

// export function NSCountHashTable(table: NSHashTable<any>): number;

// export function NSCountMapTable(table: NSMapTable<any, any>): number;

export class NSCountedSet<ObjectType> extends NSMutableSet<ObjectType> {
  //  static set<ObjectType>(): NSCountedSet<ObjectType>;
  //  static setWithArray<ObjectType>(_: ObjectType[]): NSCountedSet<ObjectType>;
  //  static setWithCollectionViewIndexPath<ObjectType>(_: IndexPath): NSCountedSet<ObjectType>;
  //  static setWithCollectionViewIndexPaths<ObjectType>(_: IndexPath[]): NSCountedSet<ObjectType>;
  //  static setWithObject<ObjectType>(_: ObjectType): NSCountedSet<ObjectType>;
  //  static setWithObjects<ObjectType>(_: ObjectType): NSCountedSet<ObjectType>;
  //  static setWithObjectsCount<ObjectType>(_: ObjectType, count: number): NSCountedSet<ObjectType>;
  //  static setWithSet<ObjectType>(_: Set<any>): NSCountedSet<ObjectType>;
}

export class NSCreateCommand extends NSScriptCommand {
  createClassDescription: NSScriptClassDescription;
  resolvedKeyDictionary: Map<string, any>;
}

// export function NSCreateHashTable(callBacks: NSHashTableCallBacks, capacity: number): NSHashTable<any>;

// export function NSCreateHashTableWithZone(callBacks: NSHashTableCallBacks, capacity: number, zone: any): NSHashTable<any>;

// export function NSCreateMapTable(keyCallBacks: NSMapTableKeyCallBacks, valueCallBacks: NSMapTableValueCallBacks, capacity: number): NSMapTable<any, any>;

// export function NSCreateMapTableWithZone(keyCallBacks: NSMapTableKeyCallBacks, valueCallBacks: NSMapTableValueCallBacks, capacity: number, zone: any): NSMapTable<any, any>;

// export function NSCreateZone(startSize: number, granularity: number, canFree: boolean): any;

export class NSDataDetector extends NSRegularExpression {
  static dataDetectorWithTypes(error: number): NSDataDetector;
  checkingTypes: number;
  static initWithTypes(error: number): NSDataDetector;
}

// export function NSDeallocateMemoryPages(ptr: any, bytes: number): void;

// export function NSDeallocateObject(object_: any): void;

// export function NSDecimalAdd(result: DecimalStruct, leftOperand: DecimalStruct, rightOperand: DecimalStruct, roundingMode: Decimal.RoundingMode): Decimal.CalculationError;

// export function NSDecimalCompact(number: DecimalStruct): void;

// export function NSDecimalCompare(leftOperand: DecimalStruct, rightOperand: DecimalStruct): NSObjCRuntime.ComparisonResult;

// export function NSDecimalCopy(destination: DecimalStruct, source: DecimalStruct): void;

// export function NSDecimalDivide(result: DecimalStruct, leftOperand: DecimalStruct, rightOperand: DecimalStruct, roundingMode: Decimal.RoundingMode): Decimal.CalculationError;

// export function NSDecimalMultiply(result: DecimalStruct, leftOperand: DecimalStruct, rightOperand: DecimalStruct, roundingMode: Decimal.RoundingMode): Decimal.CalculationError;

// export function NSDecimalMultiplyByPowerOf10(result: DecimalStruct, number: DecimalStruct, power: number, roundingMode: Decimal.RoundingMode): Decimal.CalculationError;

// export function NSDecimalNormalize(number1: DecimalStruct, number2: DecimalStruct, roundingMode: Decimal.RoundingMode): Decimal.CalculationError;

interface NSDecimalNumberBehaviors {
  exceptionDuringOperationErrorLeftOperandRightOperand(_: string, error: Decimal.CalculationError, leftOperand: number, rightOperand?: number): Decimal;
  roundingMode(): Decimal.RoundingMode;
  scale(): number;
}

export class NSDecimalNumberHandler extends NSObject {
  static defaultDecimalNumberHandler: NSDecimalNumberHandler;
  static initWithRoundingModeScaleRaiseOnExactnessRaiseOnOverflowRaiseOnUnderflowRaiseOnDivideByZero(_: Decimal.RoundingMode, scale: number, raiseOnExactness: boolean, raiseOnOverflow: boolean, raiseOnUnderflow: boolean, raiseOnDivideByZero: boolean): NSDecimalNumberHandler;
}

// export function NSDecimalPower(result: DecimalStruct, number: DecimalStruct, power: number, roundingMode: Decimal.RoundingMode): Decimal.CalculationError;

// export function NSDecimalRound(result: DecimalStruct, number: DecimalStruct, scale: number, roundingMode: Decimal.RoundingMode): void;

// export function NSDecimalString(dcm: DecimalStruct, locale: any): string;

// export function NSDecimalSubtract(result: DecimalStruct, leftOperand: DecimalStruct, rightOperand: DecimalStruct, roundingMode: Decimal.RoundingMode): Decimal.CalculationError;

// export function NSDecrementExtraRefCountWasZero(object_: any): boolean;

// export function NSDefaultMallocZone(): any;

export class NSDeleteCommand extends NSScriptCommand {
  keySpecifier: NSScriptObjectSpecifier;
  setReceiversSpecifier(_?: NSScriptObjectSpecifier): void;
}

interface NSDiscardableContent {
  beginContentAccess(): boolean;
  discardContentIfPossible(): void;
  endContentAccess(): void;
  isContentDiscarded(): boolean;
}

export class NSDistantObject extends NSProxy {
  //  static alloc(): NSDistantObject;
  //  static allocWithZone(with_?: any): NSDistantObject;
  static proxyWithLocalConnection(withLocal: any, connection: NSConnection): any;
  static proxyWithTargetConnection(withTarget: any, connection: NSConnection): any;
  connectionForProxy: NSConnection;
  static initWithLocalConnection(_: any, connection: NSConnection): NSDistantObject;
  static initWithTargetConnection(_: any, connection: NSConnection): NSDistantObject;
  setProtocolForProxy(_?: any /* Protocol */): void;
}

export class NSDistantObjectRequest extends NSObject {
  connection: NSConnection;
  conversation: any;
  invocation: NSInvocation;
  replyWithException(with_?: NSException): void;
}

export class NSDistributedLock extends NSObject {
  lockDate: Date;
  breakLock(): void;
  static initWithPath(_: string): NSDistributedLock;
  tryLock(): boolean;
  unlock(): void;
}

// export function NSDivideRect(inRect: CGRect, slice: CGRect, rem: CGRect, amount: number, edge: NSGeometry.NSRectEdge): void;

// export function NSEdgeInsetsEqual(aInsets: NSEdgeInsets, bInsets: NSEdgeInsets): boolean;

// export function NSEndHashTableEnumeration(enumerator: NSHashEnumerator): void;

// export function NSEndMapTableEnumeration(enumerator: NSMapEnumerator): void;

// export function NSEnumerateHashTable(table: NSHashTable<any>): NSHashEnumerator;

// export function NSEnumerateMapTable(table: NSMapTable<any, any>): NSMapEnumerator;

export class NSEnumerator<ObjectType> extends NSObject {
  allObjects: ObjectType[];
  nextObject(): ObjectType;
}

// export function NSEqualPoints(aPoint: CGPoint, bPoint: CGPoint): boolean;

// export function NSEqualRects(aRect: CGRect, bRect: CGRect): boolean;

// export function NSEqualSizes(aSize: CGSize, bSize: CGSize): boolean;

export class NSException extends NSObject {
  callStackReturnAddresses: number[];
  callStackSymbols: string[];
  name: string;
  reason: string;
  userInfo: Map<any, any>;
  static initWithNameReasonUserInfo(_: string, reason?: string, userInfo?: Map<any, any>): NSException;
  raise(): void;
}

export class NSExistsCommand extends NSScriptCommand {
}

export class NSExpression extends NSObject {
  static expressionForAnyKey(): NSExpression;
  static expressionForEvaluatedObject(): NSExpression;
  arguments: NSExpression[];
  collection: any;
  constantValue: any;
  expressionBlock: (p1: any, p2: NSExpression[], p3: Map<any, any>) => any;
  expressionType: NSExpression.ExpressionType;
  falseExpression: NSExpression;
  function: string;
  keyPath: string;
  leftExpression: NSExpression;
  operand: NSExpression;
  predicate: NSPredicate;
  rightExpression: NSExpression;
  trueExpression: NSExpression;
  variable: string;
  allowEvaluation(): void;
  expressionValueWithObjectContext(with_?: any, context?: Map<any, any>): any;
  static initWithExpressionType(_: NSExpression.ExpressionType): NSExpression;
}

export class NSExtensionContext extends NSObject {
  inputItems: any[];
  cancelRequestWithError(withError: Error): void;
  completeRequestReturningItemsCompletionHandler(returningItems?: any[], completionHandler?: (p1: boolean) => void): void;
  openURLCompletionHandler(_: URL, completionHandler?: (p1: boolean) => void): void;
}

export class NSExtensionItem extends NSObject {
  attachments: NSItemProvider[];
  setAttachments(_: NSItemProvider[]);
  attributedContentText: NSAttributedString;
  setAttributedContentText(_: NSAttributedString);
  attributedTitle: NSAttributedString;
  setAttributedTitle(_: NSAttributedString);
  userInfo: Map<any, any>;
  setUserInfo(_: Map<any, any>);
}

interface NSExtensionRequestHandling {
  beginRequestWithExtensionContext(with_: NSExtensionContext): void;
}

// export function NSExtraRefCount(object_: any): number;

interface NSFastEnumeration {
  countByEnumeratingWithStateObjectsCount(with_: NSFastEnumerationState, objects?: any, count?: number): number;
}

export class NSFileAccessIntent extends NSObject {
  static readingIntentWithURLOptions(with_: URL, options: NSFileCoordinator.ReadingOptions): NSFileAccessIntent;
  static writingIntentWithURLOptions(with_: URL, options: NSFileCoordinator.WritingOptions): NSFileAccessIntent;
  URL: URL;
}

export class NSFileCoordinator extends NSObject {
  static addFilePresenter(_: any): void;
  static removeFilePresenter(_: any): void;
  purposeIdentifier: string;
  setPurposeIdentifier(_: string);
  static filePresenters: any[];
  cancel(): void;
  coordinateAccessWithIntentsQueueByAccessor(with_: NSFileAccessIntent[], queue: OperationQueue, byAccessor?: (p1: Error) => void): void;
  coordinateReadingItemAtURLOptionsErrorByAccessor(readingItemAt: URL, options: NSFileCoordinator.ReadingOptions, error?: Error, byAccessor?: (p1: URL) => void): void;
  coordinateReadingItemAtURLOptionsWritingItemAtURLOptionsErrorByAccessor(readingItemAt: URL, options: NSFileCoordinator.ReadingOptions, writingItemAt: URL, options2: NSFileCoordinator.WritingOptions, error?: Error, byAccessor?: (p1: URL, p2: URL) => void): void;
  coordinateWritingItemAtURLOptionsErrorByAccessor(writingItemAt: URL, options: NSFileCoordinator.WritingOptions, error?: Error, byAccessor?: (p1: URL) => void): void;
  coordinateWritingItemAtURLOptionsWritingItemAtURLOptionsErrorByAccessor(writingItemAt: URL, options: NSFileCoordinator.WritingOptions, writingItemAt2: URL, options2: NSFileCoordinator.WritingOptions, error?: Error, byAccessor?: (p1: URL, p2: URL) => void): void;
  static initWithFilePresenter(_?: any): NSFileCoordinator;
  itemAtURLDidChangeUbiquityAttributes(at: URL, didChangeUbiquityAttributes: Set<any>): void;
  itemAtURLDidMoveToURL(at: URL, didMoveTo: URL): void;
  itemAtURLWillMoveToURL(at: URL, willMoveTo: URL): void;
  prepareForReadingItemsAtURLsOptionsWritingItemsAtURLsOptionsErrorByAccessor(forReadingItemsAt: URL[], options: NSFileCoordinator.ReadingOptions, writingItemsAt: URL[], options2: NSFileCoordinator.WritingOptions, error?: Error, byAccessor?: (p1: () => void) => void): void;
}

interface NSFilePresenter {
  observedPresentedItemUbiquityAttributes?: Set<any>;
  presentedItemOperationQueue: OperationQueue;
  presentedItemURL: URL;
  primaryPresentedItemURL?: URL;
  accommodatePresentedItemDeletionWithCompletionHandler(completionHandler?: (p1: Error) => void): void;
  accommodatePresentedSubitemDeletionAtURLCompletionHandler(at: URL, completionHandler?: (p1: Error) => void): void;
  presentedItemDidChange(): void;
  presentedItemDidChangeUbiquityAttributes(_: Set<any>): void;
  presentedItemDidGainVersion(_: NSFileVersion): void;
  presentedItemDidLoseVersion(_: NSFileVersion): void;
  presentedItemDidMoveToURL(to: URL): void;
  presentedItemDidResolveConflictVersion(_: NSFileVersion): void;
  presentedSubitemAtURLDidMoveToURL(at: URL, didMoveTo: URL): void;
  presentedSubitemAtURLDidGainVersion(at: URL, didGain: NSFileVersion): void;
  presentedSubitemAtURLDidLoseVersion(at: URL, didLose: NSFileVersion): void;
  presentedSubitemAtURLDidResolveConflictVersion(at: URL, didResolve: NSFileVersion): void;
  presentedSubitemDidAppearAtURL(at: URL): void;
  presentedSubitemDidChangeAtURL(at: URL): void;
  relinquishPresentedItemToReader(toReader?: (p1: () => void) => void): void;
  relinquishPresentedItemToWriter(toWriter?: (p1: () => void) => void): void;
  savePresentedItemChangesWithCompletionHandler(completionHandler?: (p1: Error) => void): void;
}

export class NSFileProviderService extends NSObject {
  name: string;
  getFileProviderConnectionWithCompletionHandler(completionHandler?: (p1: NSXPCConnection, p2: Error) => void): void;
}

export class NSFileSecurity extends NSObject {
}

// export function NSFileTypeForHFSTypeCode(hfsFileTypeCode: number): string;

export class NSFileVersion extends NSObject {
  static addVersionOfItemAtURLWithContentsOfURLOptions(withContentsOfURL: URL, options: URL, error: NSFileVersion.AddingOptions): NSFileVersion;
  static currentVersionOfItemAtURL(at: URL): NSFileVersion;
  static getNonlocalVersionsOfItemAtURLCompletionHandler(at: URL, completionHandler?: (p1: NSFileVersion[], p2: Error) => void): void;
  static otherVersionsOfItemAtURL(at: URL): NSFileVersion[];
  static removeOtherVersionsOfItemAtURL(error: URL): boolean;
  static temporaryDirectoryURLForNewVersionOfItemAtURL(at: URL): URL;
  static unresolvedConflictVersionsOfItemAtURL(at: URL): NSFileVersion[];
  URL: URL;
  isConflict: boolean;
  isDiscardable: boolean;
  setDiscardable(_: boolean);
  hasLocalContents: boolean;
  hasThumbnail: boolean;
  localizedName: string;
  localizedNameOfSavingComputer: string;
  modificationDate: Date;
  originatorNameComponents: PersonNameComponents;
  persistentIdentifier: any;
  isResolved: boolean;
  setResolved(_: boolean);
  removeAndReturnError(): boolean;
  replaceItemAtURLOptions(options: URL, error: NSFileVersion.ReplacingOptions): URL;
}

// export function NSFrameAddress(frame: number): any;

// export function NSFreeHashTable(table: NSHashTable<any>): void;

// export function NSFreeMapTable(table: NSMapTable<any, any>): void;

// export function NSFullUserName(): string;

export class NSGarbageCollector extends NSObject {
  static defaultCollector(): any;
  collectExhaustively(): void;
  collectIfNeeded(): void;
  disable(): void;
  disableCollectorForPointer(forPointer: any): void;
  enable(): void;
  enableCollectorForPointer(forPointer: any): void;
  isEnabled(): boolean;
}

export class NSGetCommand extends NSScriptCommand {
}

// export function NSGetSizeAndAlignment(typePtr: string | any, sizep: number, alignp: number): string;

// export function NSGetUncaughtExceptionHandler(): (p1: NSException) => void;

// export function NSHFSTypeCodeFromFileType(fileTypeString: string): number;

// export function NSHFSTypeOfFile(fullFilePath: string): string;

// export function NSHashGet(table: NSHashTable<any>, pointer: any): any;

// export function NSHashInsert(table: NSHashTable<any>, pointer: any): void;

// export function NSHashInsertIfAbsent(table: NSHashTable<any>, pointer: any): any;

// export function NSHashInsertKnownAbsent(table: NSHashTable<any>, pointer: any): void;

// export function NSHashRemove(table: NSHashTable<any>, pointer: any): void;

export class NSHashTable<ObjectType> extends NSObject {
  static weakObjectsHashTable<ObjectType>(): NSHashTable<any>;
  allObjects: ObjectType[];
  anyObject: ObjectType;
  count: number;
  pointerFunctions: NSPointerFunctions;
  setRepresentation: Set<any>;
  addObject(_?: ObjectType): void;
  containsObject(_?: ObjectType): boolean;
  intersectHashTable(_: NSHashTable<any>): void;
  intersectsHashTable(_: NSHashTable<any>): boolean;
  isEqualToHashTable(to: NSHashTable<any>): boolean;
  isSubsetOfHashTable(of: NSHashTable<any>): boolean;
  member(_?: ObjectType): ObjectType;
  minusHashTable(_: NSHashTable<any>): void;
  objectEnumerator(): NSEnumerator<any>;
  removeAllObjects(): void;
  removeObject(_?: ObjectType): void;
  unionHashTable(_: NSHashTable<any>): void;
}

// export function NSHomeDirectory(): string;

// export function NSHomeDirectoryForUser(userName: string): string;

// export function NSIncrementExtraRefCount(object_: any): void;

export class NSIndexSpecifier extends NSScriptObjectSpecifier {
  index: number;
  setIndex(_: number);
  static initWithContainerClassDescriptionContainerSpecifierKeyIndex(_: NSScriptClassDescription, containerSpecifier?: NSScriptObjectSpecifier, key?: string, index?: number): NSIndexSpecifier;
}

// export function NSInsetRect(aRect: CGRect, dX: number, dY: number): CGRect;

// export function NSIntegralRect(aRect: CGRect): CGRect;

// export function NSIntegralRectWithOptions(aRect: CGRect, opts: NSGeometry.AlignmentOptions): CGRect;

// export function NSIntersectionRange(range1: NSRange, range2: NSRange): NSRange;

// export function NSIntersectionRect(aRect: CGRect, bRect: CGRect): CGRect;

// export function NSIntersectsRect(aRect: CGRect, bRect: CGRect): boolean;

export class NSInvocation extends NSObject {
  argumentsRetained: boolean;
  methodSignature: NSMethodSignature;
  selector: string;
  setSelector(_: string);
  target: any;
  setTarget(_: any);
  getArgumentAtIndex(_: any, at: number): void;
  getReturnValue(_: any): void;
  invoke(): void;
  invokeWithTarget(withTarget: any): void;
  retainArguments(): void;
  setArgumentAtIndex(_: any, at: number): void;
  setReturnValue(_: any): void;
}

export class NSInvocationOperation extends Operation {
  invocation: NSInvocation;
  result: any;
  static initWithInvocation(_: NSInvocation): NSInvocationOperation;
  static initWithTargetSelectorObject(_: any, selector: string, object_?: any): NSInvocationOperation;
}

// export function NSIsEmptyRect(aRect: CGRect): boolean;

// export function NSIsFreedObject(anObject: any): boolean;

export class NSItemProvider extends NSObject {
  containerFrame: CGRect;
  preferredPresentationSize: CGSize;
  previewImageHandler: (p1: (p1: any, p2: Error) => void, p2: typeof NSObject, p3: Map<any, any>) => void;
  setPreviewImageHandler(_: (p1: (p1: any, p2: Error) => void, p2: typeof NSObject, p3: Map<any, any>) => void);
  registeredTypeIdentifiers: string[];
  sourceFrame: CGRect;
  suggestedName: string;
  setSuggestedName(_: string);
  canLoadObjectOfClass(ofClass: typeof NSObject): boolean;
  hasItemConformingToTypeIdentifier(_: string): boolean;
  hasRepresentationConformingToTypeIdentifierFileOptions(toTypeIdentifier: string, fileOptions: NSItemProvider.NSItemProviderFileOptions): boolean;
  static initWithContentsOfURL(_: URL): NSItemProvider;
  static initWithItemTypeIdentifier(_?: any, typeIdentifier?: string): NSItemProvider;
  static initWithObject(_: any): NSItemProvider;
  loadDataRepresentationForTypeIdentifierCompletionHandler(forTypeIdentifier: string, completionHandler?: (p1: Data, p2: Error) => void): Progress;
  loadFileRepresentationForTypeIdentifierCompletionHandler(forTypeIdentifier: string, completionHandler?: (p1: URL, p2: Error) => void): Progress;
  loadInPlaceFileRepresentationForTypeIdentifierCompletionHandler(forTypeIdentifier: string, completionHandler?: (p1: URL, p2: boolean, p3: Error) => void): Progress;
  loadItemForTypeIdentifierOptionsCompletionHandler(forTypeIdentifier: string, options?: Map<any, any>, completionHandler?: (p1: any, p2: Error) => void): void;
  loadObjectOfClassCompletionHandler(ofClass: typeof NSObject, completionHandler?: (p1: any, p2: Error) => void): Progress;
  loadPreviewImageWithOptionsCompletionHandler(options: Map<any, any>, completionHandler: (p1: any, p2: Error) => void): void;
  registerCloudKitShareContainer(_: CKShare, container: CKContainer): void;
  registerCloudKitShareWithPreparationHandler(preparationHandler?: (p1: (p1: CKShare, p2: CKContainer, p3: Error) => void) => void): void;
  registerDataRepresentationForTypeIdentifierVisibilityLoadHandler(forTypeIdentifier: string, visibility: NSItemProvider.NSItemProviderRepresentationVisibility, loadHandler?: (p1: (p1: Data, p2: Error) => void) => Progress): void;
  registerFileRepresentationForTypeIdentifierFileOptionsVisibilityLoadHandler(forTypeIdentifier: string, fileOptions: NSItemProvider.NSItemProviderFileOptions, visibility: NSItemProvider.NSItemProviderRepresentationVisibility, loadHandler?: (p1: (p1: URL, p2: boolean, p3: Error) => void) => Progress): void;
  registerItemForTypeIdentifierLoadHandler(forTypeIdentifier: string, loadHandler: (p1: (p1: any, p2: Error) => void, p2: typeof NSObject, p3: Map<any, any>) => void): void;
  registerObjectVisibility(_: any, visibility: NSItemProvider.NSItemProviderRepresentationVisibility): void;
  registerObjectOfClassVisibilityLoadHandler(ofClass: typeof NSObject, visibility: NSItemProvider.NSItemProviderRepresentationVisibility, loadHandler?: (p1: (p1: any, p2: Error) => void) => Progress): void;
  // dupe name w instance property   registeredTypeIdentifiersWithFileOptions(fileOptions: NSItemProvider.NSItemProviderFileOptions): string[];
}

interface NSItemProviderReading {
}

interface NSItemProviderWriting {
  writableTypeIdentifiersForItemProvider?: string[];
  itemProviderVisibilityForRepresentationWithTypeIdentifier(withTypeIdentifier: string): NSItemProvider.NSItemProviderRepresentationVisibility;
  loadDataWithTypeIdentifierForItemProviderCompletionHandler(withTypeIdentifier: string, forItemProviderCompletionHandler?: (p1: Data, p2: Error) => void): Progress;
}

export class NSKeyedArchiver extends NSCoder {
  static archivedDataWithRootObjectRequiringSecureCoding(requiringSecureCoding: any, error: boolean): Data;
  //  static classNameForClass(for_: typeof NSObject): string;
  //  static setClassNameForClass(_?: string, for_?: typeof NSObject): void;
  delegate: any;
  setDelegate(_: any);
  encodedData: Data;
  outputFormat: NSPropertyList.PropertyListSerialization.PropertyListFormat;
  setOutputFormat(_: NSPropertyList.PropertyListSerialization.PropertyListFormat);
  requiresSecureCoding: boolean;
  setRequiresSecureCoding(_: boolean);
  finishEncoding(): void;
  static initRequiringSecureCoding(_: boolean): NSKeyedArchiver;
  setClassNameForClass(_?: string, for_?: typeof NSObject): void;
}

interface NSKeyedArchiverDelegate {
  archiverWillEncodeObject(_: NSKeyedArchiver, willEncode: any): any;
  archiverDidEncodeObject(_: NSKeyedArchiver, didEncode?: any): void;
  archiverWillReplaceObjectWithObject(_: NSKeyedArchiver, willReplace?: any, with_?: any): void;
  archiverDidFinish(_: NSKeyedArchiver): void;
  archiverWillFinish(_: NSKeyedArchiver): void;
}

export class NSKeyedUnarchiver extends NSCoder {
  //  static classForClassName(forClassName: string): typeof NSObject;
  //  static setClassForClassName(_?: typeof NSObject, forClassName?: string): void;
  static unarchivedObjectOfClassFromData(fromData: typeof NSObject, error: Data): any;
  static unarchivedObjectOfClassesFromData(fromData: Set<any>, error: Data): any;
  decodingFailurePolicy: NSCoder.DecodingFailurePolicy;
  setDecodingFailurePolicy(_: NSCoder.DecodingFailurePolicy);
  delegate: any;
  setDelegate(_: any);
  requiresSecureCoding: boolean;
  setRequiresSecureCoding(_: boolean);
  classForClassName(forClassName: string): typeof NSObject;
  finishDecoding(): void;
  static initForReadingFromData(error: Data): NSKeyedUnarchiver;
  setClassForClassName(_?: typeof NSObject, forClassName?: string): void;
}

interface NSKeyedUnarchiverDelegate {
  unarchiverCannotDecodeObjectOfClassNameOriginalClasses(_: NSKeyedUnarchiver, cannotDecodeObjectOfClassName: string, originalClasses: string[]): typeof NSObject;
  unarchiverDidDecodeObject(_: NSKeyedUnarchiver, didDecode?: any): any;
  unarchiverWillReplaceObjectWithObject(_: NSKeyedUnarchiver, willReplace: any, with_: any): void;
  unarchiverDidFinish(_: NSKeyedUnarchiver): void;
  unarchiverWillFinish(_: NSKeyedUnarchiver): void;
}

export class NSLinguisticTagger extends NSObject {
  static availableTagSchemesForLanguage(forLanguage: string): string[];
  static availableTagSchemesForUnitLanguage(for_: NSLinguisticTagger.NSLinguisticTaggerUnit, language: string): string[];
  //  static dominantLanguageForString(for_: string): string;
  static enumerateTagsForStringRangeUnitSchemeOptionsOrthographyUsingBlock(for_: string, range: NSRange, unit: NSLinguisticTagger.NSLinguisticTaggerUnit, scheme: string, options: NSLinguisticTagger.Options, orthography?: NSOrthography, using?: (p1: string, p2: NSRange, p3: boolean) => void): void;
  static tagForStringAtIndexUnitSchemeOrthographyTokenRange(for_: string, at: number, unit: NSLinguisticTagger.NSLinguisticTaggerUnit, scheme: string, orthography?: NSOrthography, tokenRange?: NSRange): string;
  static tagsForStringRangeUnitSchemeOptionsOrthographyTokenRanges(for_: string, range: NSRange, unit: NSLinguisticTagger.NSLinguisticTaggerUnit, scheme: string, options: NSLinguisticTagger.Options, orthography?: NSOrthography, tokenRanges?: NSValue[]): string[];
  dominantLanguage: string;
  tagSchemes: string[];
  enumerateTagsInRangeSchemeOptionsUsingBlock(in_: NSRange, scheme: string, options: NSLinguisticTagger.Options, using?: (p1: string, p2: NSRange, p3: NSRange, p4: boolean) => void): void;
  enumerateTagsInRangeUnitSchemeOptionsUsingBlock(in_: NSRange, unit: NSLinguisticTagger.NSLinguisticTaggerUnit, scheme: string, options: NSLinguisticTagger.Options, using?: (p1: string, p2: NSRange, p3: boolean) => void): void;
  static initWithTagSchemesOptions(_: string[], options: number): NSLinguisticTagger;
  orthographyAtIndexEffectiveRange(at: number, effectiveRange?: NSRange): NSOrthography;
  possibleTagsAtIndexSchemeTokenRangeSentenceRangeScores(at: number, scheme: string, tokenRange?: NSRange, sentenceRange?: NSRange, scores?: NSValue[]): string[];
  sentenceRangeForRange(for_: NSRange): NSRange;
  setOrthographyRange(_?: NSOrthography, range?: NSRange): void;
  stringEditedInRangeChangeInLength(in_: NSRange, changeInLength: number): void;
  tagAtIndexSchemeTokenRangeSentenceRange(at: number, scheme: string, tokenRange?: NSRange, sentenceRange?: NSRange): string;
  tagAtIndexUnitSchemeTokenRange(at: number, unit: NSLinguisticTagger.NSLinguisticTaggerUnit, scheme: string, tokenRange?: NSRange): string;
  tagsInRangeSchemeOptionsTokenRanges(in_: NSRange, scheme: string, options: NSLinguisticTagger.Options, tokenRanges?: NSValue[]): string[];
  tagsInRangeUnitSchemeOptionsTokenRanges(in_: NSRange, unit: NSLinguisticTagger.NSLinguisticTaggerUnit, scheme: string, options: NSLinguisticTagger.Options, tokenRanges?: NSValue[]): string[];
  tokenRangeAtIndexUnit(at: number, unit: NSLinguisticTagger.NSLinguisticTaggerUnit): NSRange;
}

export class NSLock extends NSObject {
  name: string;
  setName(_: string);
  lockBeforeDate(before: Date): boolean;
  tryLock(): boolean;
}

interface NSLocking {
  lock(): void;
  unlock(): void;
}

// export function NSLogPageSize(): number;

export class NSLogicalTest extends NSScriptWhoseTest {
  static initAndTestWithTests(_: NSSpecifierTest[]): NSLogicalTest;
  static initNotTestWithTest(_: NSScriptWhoseTest): NSLogicalTest;
  static initOrTestWithTests(_: NSSpecifierTest[]): NSLogicalTest;
}

export class NSMachBootstrapServer extends NSPortNameServer {
  static sharedInstance(): any;
  servicePortWithName(withName: string): Port;
}

export class NSMachPort extends Port {
  static portWithMachPort(withMachPort: number): Port;
  static portWithMachPortOptions(withMachPort: number, options: Port.NSMachPort.Options): Port;
  machPort: number;
  delegate(): any;
  static initWithMachPort(_: number): NSMachPort;
  static initWithMachPortOptions(_: number, options: Port.NSMachPort.Options): NSMachPort;
  setDelegate(_?: any): void;
}

interface NSMachPortDelegate {
  handleMachMessage(_: any): void;
}

// export function NSMakeCollectable(cf: any): any;

// export function NSMapGet(table: NSMapTable<any, any>, key: any): any;

// export function NSMapInsert(table: NSMapTable<any, any>, key: any, value: any): void;

// export function NSMapInsertIfAbsent(table: NSMapTable<any, any>, key: any, value: any): any;

// export function NSMapInsertKnownAbsent(table: NSMapTable<any, any>, key: any, value: any): void;

// export function NSMapMember(table: NSMapTable<any, any>, key: any, originalKey: any, value: any): boolean;

// export function NSMapRemove(table: NSMapTable<any, any>, key: any): void;

export class NSMapTable<KeyType, ObjectType> extends NSObject {
  static strongToStrongObjectsMapTable<KeyType, ObjectType>(): NSMapTable<KeyType, ObjectType>;
  static strongToWeakObjectsMapTable<KeyType, ObjectType>(): NSMapTable<KeyType, ObjectType>;
  static weakToStrongObjectsMapTable<KeyType, ObjectType>(): NSMapTable<KeyType, ObjectType>;
  static weakToWeakObjectsMapTable<KeyType, ObjectType>(): NSMapTable<KeyType, ObjectType>;
  count: number;
  keyPointerFunctions: NSPointerFunctions;
  valuePointerFunctions: NSPointerFunctions;
  dictionaryRepresentation(): Map<KeyType, ObjectType>;
  keyEnumerator(): NSEnumerator<any>;
  objectEnumerator(): NSEnumerator<any>;
  objectForKey(forKey?: KeyType): ObjectType;
  removeAllObjects(): void;
  removeObjectForKey(forKey?: KeyType): void;
  setObjectForKey(_?: ObjectType, forKey?: KeyType): void;
}

export class NSMessagePortNameServer extends NSPortNameServer {
  static sharedInstance(): any;
}

export class NSMetadataItem extends NSObject {
  attributes: string[];
  static initWithURL(_: URL): NSMetadataItem;
  valueForAttribute(forAttribute: string): any;
  valuesForAttributes(forAttributes: string[]): Map<string, any>;
}

export class NSMetadataQuery extends NSObject {
  delegate: any;
  setDelegate(_: any);
  isGathering: boolean;
  groupedResults: NSMetadataQueryResultGroup[];
  groupingAttributes: string[];
  setGroupingAttributes(_: string[]);
  notificationBatchingInterval: number;
  setNotificationBatchingInterval(_: number);
  operationQueue: OperationQueue;
  setOperationQueue(_: OperationQueue);
  predicate: NSPredicate;
  setPredicate(_: NSPredicate);
  resultCount: number;
  results: any[];
  searchItems: any[];
  setSearchItems(_: any[]);
  searchScopes: any[];
  setSearchScopes(_: any[]);
  sortDescriptors: NSSortDescriptor[];
  setSortDescriptors(_: NSSortDescriptor[]);
  isStarted: boolean;
  isStopped: boolean;
  valueListAttributes: string[];
  setValueListAttributes(_: string[]);
  valueLists: Map<string, NSMetadataQueryAttributeValueTuple[]>;
  disableUpdates(): void;
  enableUpdates(): void;
  enumerateResultsUsingBlock(_: (p1: any, p2: number, p3: boolean) => void): void;
  enumerateResultsWithOptionsUsingBlock(options: NSObjCRuntime.NSEnumerationOptions, using: (p1: any, p2: number, p3: boolean) => void): void;
  indexOfResult(ofResult: any): number;
  resultAtIndex(at: number): any;
  startQuery(): boolean;
  stopQuery(): void;
  valueOfAttributeForResultAtIndex(ofAttribute: string, forResultAt: number): any;
}

export class NSMetadataQueryAttributeValueTuple extends NSObject {
  attribute: string;
  count: number;
}

interface NSMetadataQueryDelegate {
  metadataQueryReplacementObjectForResultObject(_: NSMetadataQuery, replacementObjectForResultObject: NSMetadataItem): any;
  metadataQueryReplacementValueForAttributeValue(_: NSMetadataQuery, replacementValueForAttribute: string, value: any): any;
}

export class NSMetadataQueryResultGroup extends NSObject {
  attribute: string;
  resultCount: number;
  results: any[];
  subgroups: NSMetadataQueryResultGroup[];
  resultAtIndex(at: number): any;
}

export class NSMethodSignature extends NSObject {
  frameLength: number;
  methodReturnLength: number;
  methodReturnType: string;
  numberOfArguments: number;
  getArgumentTypeAtIndex(at: number): string;
  isOneway(): boolean;
}

export class NSMiddleSpecifier extends NSScriptObjectSpecifier {
}

// export function NSMouseInRect(aPoint: CGPoint, aRect: CGRect, flipped: boolean): boolean;

export class NSMoveCommand extends NSScriptCommand {
  keySpecifier: NSScriptObjectSpecifier;
  setReceiversSpecifier(_?: NSScriptObjectSpecifier): void;
}

export class NSMutableArray<ObjectType> extends Array<ObjectType> {
  //  static array<ObjectType>(): NSMutableArray<ObjectType>;
  //  static arrayWithArray<ObjectType>(_: ObjectType[]): NSMutableArray<ObjectType>;
  //  static arrayWithObject<ObjectType>(_: ObjectType): NSMutableArray<ObjectType>;
  //  static arrayWithObjects<ObjectType>(_: ObjectType): NSMutableArray<ObjectType>;
  //  static arrayWithObjectsCount<ObjectType>(_: ObjectType, count: number): NSMutableArray<ObjectType>;
  addObject(_: ObjectType): void;
  addObjectsFromArray(from: ObjectType[]): void;
  applyDifference(_: CollectionDifference<any>): void;
  exchangeObjectAtIndexWithObjectAtIndex(at: number, withObjectAt: number): void;
  filterUsingPredicate(using: NSPredicate): void;
  insertObjectAtIndex(_: ObjectType, at: number): void;
  insertObjectsAtIndexes(_: ObjectType[], at: IndexSet): void;
  removeAllObjects(): void;
  removeLastObject(): void;
  removeObject(_: ObjectType): void;
  removeObjectInRange(_: ObjectType, in_: NSRange): void;
  removeObjectAtIndex(at: number): void;
  removeObjectIdenticalTo(identicalTo: ObjectType): void;
  removeObjectIdenticalToInRange(identicalTo: ObjectType, in_: NSRange): void;
  removeObjectsAtIndexes(at: IndexSet): void;
  removeObjectsInArray(in_: ObjectType[]): void;
  removeObjectsInRange(in_: NSRange): void;
  replaceObjectAtIndexWithObject(at: number, with_: ObjectType): void;
  replaceObjectsAtIndexesWithObjects(at: IndexSet, with_: ObjectType[]): void;
  replaceObjectsInRangeWithObjectsFromArray(in_: NSRange, withObjectsFrom: ObjectType[]): void;
  replaceObjectsInRangeWithObjectsFromArrayRange(in_: NSRange, withObjectsFrom: ObjectType[], range: NSRange): void;
  setArray(_: ObjectType[]): void;
  sortUsingComparator(comparator: (p1: any, p2: any) => NSObjCRuntime.ComparisonResult): void;
  sortUsingDescriptors(using: NSSortDescriptor[]): void;
  sortUsingFunctionContext(_?: (p1: ObjectType, p2: ObjectType, p3: any) => number, context?: any): void;
  sortUsingSelector(using: string): void;
  sortWithOptionsUsingComparator(options: NSObjCRuntime.NSSortOptions, usingComparator: (p1: any, p2: any) => NSObjCRuntime.ComparisonResult): void;
}

export class NSMutableAttributedString extends NSAttributedString {
  mutableString: NSMutableString;
  addAttributeValueRange(_: string, value: any, range: NSRange): void;
  addAttributesRange(_: Map<string, any>, range: NSRange): void;
  appendAttributedString(_: NSAttributedString): void;
  applyFontTraitsRange(_: NSFontManager.NSFontTraitMask, range: NSRange): void;
  beginEditing(): void;
  deleteCharactersInRange(in_: NSRange): void;
  endEditing(): void;
  fixAttachmentAttributeInRange(in_: NSRange): void;
  fixAttributesInRange(in_: NSRange): void;
  fixFontAttributeInRange(in_: NSRange): void;
  fixParagraphStyleAttributeInRange(in_: NSRange): void;
  insertAttributedStringAtIndex(_: NSAttributedString, at: number): void;
  readFromDataOptionsDocumentAttributes(from: Data, options: Map<string, any>, documentAttributes?: Map<string, any>): boolean;
  readFromURLOptionsDocumentAttributes(from: URL, options: Map<string, any>, documentAttributes?: Map<string, any>): boolean;
  removeAttributeRange(_: string, range: NSRange): void;
  replaceCharactersInRangeWithAttributedString(in_: NSRange, with_: NSAttributedString): void;
  replaceCharactersInRangeWithString(in_: NSRange, with_: string): void;
  setAlignmentRange(_: NSText.NSTextAlignment, range: NSRange): void;
  setAttributedString(_: NSAttributedString): void;
  setAttributesRange(_?: Map<string, any>, range?: NSRange): void;
  setBaseWritingDirectionRange(_: NSText.NSWritingDirection, range: NSRange): void;
  subscriptRange(_: NSRange): void;
  superscriptRange(_: NSRange): void;
  unscriptRange(_: NSRange): void;
  updateAttachmentsFromPath(fromPath: string): void;
}

export class NSMutableCharacterSet extends CharacterSet {
  addCharactersInRange(in_: NSRange): void;
  addCharactersInString(in_: string): void;
  formIntersectionWithCharacterSet(with_: CharacterSet): void;
  formUnionWithCharacterSet(with_: CharacterSet): void;
  invert(): void;
  removeCharactersInRange(in_: NSRange): void;
  removeCharactersInString(in_: string): void;
}

interface NSMutableCopying {
  mutableCopyWithZone(with_?: any): any;
}

export class NSMutableData extends Data {
  //  static data(): NSMutableData;
  //  static dataWithBytesLength(_?: any, length?: number): NSMutableData;
  //  static dataWithBytesNoCopyLength(_: any, length: number): NSMutableData;
  //  static dataWithBytesNoCopyLengthFreeWhenDone(_: any, length: number, freeWhenDone: boolean): NSMutableData;
  //  static dataWithContentsOfFile(_: string): NSMutableData;
  //  static dataWithContentsOfFileOptions(options: string, error: Data.ReadingOptions): NSMutableData;
  //  static dataWithContentsOfURL(_: URL): NSMutableData;
  //  static dataWithContentsOfURLOptions(options: URL, error: Data.ReadingOptions): NSMutableData;
  //  static dataWithData(_: Data): NSMutableData;
  length: number;
  setLength(_: number);
  mutableBytes: any;
  appendBytesLength(_: any, length: number): void;
  appendData(_: Data): void;
  compressUsingAlgorithm(error: Data.CompressionAlgorithm): boolean;
  decompressUsingAlgorithm(error: Data.CompressionAlgorithm): boolean;
  increaseLengthBy(by: number): void;
  static initWithCapacity(_: number): NSMutableData;
  static initWithLength(_: number): NSMutableData;
  replaceBytesInRangeWithBytes(in_: NSRange, withBytes: any): void;
  replaceBytesInRangeWithBytesLength(in_: NSRange, withBytes?: any, length?: number): void;
  resetBytesInRange(in_: NSRange): void;
  setData(_: Data): void;
}

export class NSMutableDictionary<KeyType, ObjectType> extends Dictionary<KeyType, ObjectType> {
  //  static dictionary<KeyType, ObjectType>(): NSMutableDictionary<KeyType, ObjectType>;
  //  static dictionaryWithDictionary<KeyType, ObjectType>(_: Map<KeyType, ObjectType>): NSMutableDictionary<KeyType, ObjectType>;
  //  static dictionaryWithObjectForKey<KeyType, ObjectType>(_: ObjectType, forKey: KeyType): NSMutableDictionary<KeyType, ObjectType>;
  //  static dictionaryWithObjectsForKeys<KeyType, ObjectType>(_: ObjectType[], forKeys: KeyType[]): NSMutableDictionary<KeyType, ObjectType>;
  //  static dictionaryWithObjectsForKeysCount<KeyType, ObjectType>(_?: ObjectType, forKeys?: KeyType, count?: number): NSMutableDictionary<KeyType, ObjectType>;
  addEntriesFromDictionary(from: Map<KeyType, ObjectType>): void;
  removeAllObjects(): void;
  removeObjectForKey(forKey: KeyType): void;
  removeObjectsForKeys(forKeys: KeyType[]): void;
  setDictionary(_: Map<KeyType, ObjectType>): void;
  setObjectForKey(_: ObjectType, forKey: KeyType): void;
  setValueForKey(_?: ObjectType, forKey?: string): void;
}

export class NSMutableIndexSet extends IndexSet {
  //  static indexSet(): NSMutableIndexSet;
  //  static indexSetWithIndex(_: number): NSMutableIndexSet;
  //  static indexSetWithIndexesInRange(_: NSRange): NSMutableIndexSet;
  addIndex(_: number): void;
  addIndexes(_: IndexSet): void;
  addIndexesInRange(in_: NSRange): void;
  removeAllIndexes(): void;
  removeIndex(_: number): void;
  removeIndexes(_: IndexSet): void;
  removeIndexesInRange(in_: NSRange): void;
  shiftIndexesStartingAtIndexBy(at: number, by: number): void;
}

export class NSMutableOrderedSet<ObjectType> extends NSOrderedSet<ObjectType> {
  //  static orderedSetWithObjects<ObjectType>(_: ObjectType): NSMutableOrderedSet<ObjectType>;
  addObject(_: ObjectType): void;
  addObjectsCount(_?: ObjectType, count?: number): void;
  addObjectsFromArray(from: ObjectType[]): void;
  applyDifference(_: CollectionDifference<any>): void;
  exchangeObjectAtIndexWithObjectAtIndex(at: number, withObjectAt: number): void;
  filterUsingPredicate(using: NSPredicate): void;
  insertObjectAtIndex(_: ObjectType, at: number): void;
  insertObjectsAtIndexes(_: ObjectType[], at: IndexSet): void;
  intersectOrderedSet(_: NSOrderedSet<any>): void;
  intersectSet(_: Set<any>): void;
  minusOrderedSet(_: NSOrderedSet<any>): void;
  minusSet(_: Set<any>): void;
  moveObjectsAtIndexesToIndex(at: IndexSet, to: number): void;
  removeAllObjects(): void;
  removeObject(_: ObjectType): void;
  removeObjectAtIndex(at: number): void;
  removeObjectsAtIndexes(at: IndexSet): void;
  removeObjectsInArray(in_: ObjectType[]): void;
  removeObjectsInRange(in_: NSRange): void;
  replaceObjectAtIndexWithObject(at: number, with_: ObjectType): void;
  replaceObjectsAtIndexesWithObjects(at: IndexSet, with_: ObjectType[]): void;
  replaceObjectsInRangeWithObjectsCount(in_: NSRange, with_?: ObjectType, count?: number): void;
  setObjectAtIndex(_: ObjectType, at: number): void;
  sortRangeOptionsUsingComparator(_: NSRange, options: NSObjCRuntime.NSSortOptions, usingComparator: (p1: any, p2: any) => NSObjCRuntime.ComparisonResult): void;
  sortUsingComparator(comparator: (p1: any, p2: any) => NSObjCRuntime.ComparisonResult): void;
  sortUsingDescriptors(using: NSSortDescriptor[]): void;
  sortWithOptionsUsingComparator(options: NSObjCRuntime.NSSortOptions, usingComparator: (p1: any, p2: any) => NSObjCRuntime.ComparisonResult): void;
  unionOrderedSet(_: NSOrderedSet<any>): void;
  unionSet(_: Set<any>): void;
}

export class NSMutableSet<ObjectType> extends Set<ObjectType> {
  //  static set<ObjectType>(): NSMutableSet<ObjectType>;
  //  static setWithArray<ObjectType>(_: ObjectType[]): NSMutableSet<ObjectType>;
  //  static setWithCollectionViewIndexPath<ObjectType>(_: IndexPath): NSMutableSet<ObjectType>;
  //  static setWithCollectionViewIndexPaths<ObjectType>(_: IndexPath[]): NSMutableSet<ObjectType>;
  //  static setWithObject<ObjectType>(_: ObjectType): NSMutableSet<ObjectType>;
  //  static setWithObjects<ObjectType>(_: ObjectType): NSMutableSet<ObjectType>;
  //  static setWithObjectsCount<ObjectType>(_: ObjectType, count: number): NSMutableSet<ObjectType>;
  //  static setWithSet<ObjectType>(_: Set<any>): NSMutableSet<ObjectType>;
  addObject(_: ObjectType): void;
  addObjectsFromArray(from: ObjectType[]): void;
  filterUsingPredicate(using: NSPredicate): void;
  intersectSet(_: Set<any>): void;
  minusSet(_: Set<any>): void;
  removeAllObjects(): void;
  removeObject(_: ObjectType): void;
  setSet(_: Set<any>): void;
  unionSet(_: Set<any>): void;
}

// @ts-ignore
export class NSMutableString extends String {
  //  static objectWithItemProviderDataTypeIdentifier(typeIdentifier: Data, error: string): NSMutableString;
  //  static stringWithCStringEncoding(_: string, encoding: number): NSMutableString;
  //  static stringWithCharactersLength(_: string, length: number): NSMutableString;
  //  static stringWithContentsOfFileEncoding(encoding: string, error: number): NSMutableString;
  //  static stringWithContentsOfFileUsedEncoding(usedEncoding: string, error?: number): NSMutableString;
  //  static stringWithContentsOfURLEncoding(encoding: URL, error: number): NSMutableString;
  //  static stringWithContentsOfURLUsedEncoding(usedEncoding: URL, error?: number): NSMutableString;
  //  static stringWithString(_: string): NSMutableString;
  //  static stringWithUTF8String(_: string): NSMutableString;
  appendString(_: string): void;
  applyTransformReverseRangeUpdatedRange(_: string, reverse: boolean, range: NSRange, updatedRange?: NSRange): boolean;
  deleteCharactersInRange(in_: NSRange): void;
  static initWithCapacity(_: number): NSMutableString;
  insertStringAtIndex(_: string, at: number): void;
  replaceCharactersInRangeWithString(in_: NSRange, with_: string): void;
  replaceOccurrencesOfStringWithStringOptionsRange(of: string, with_: string, options: String.CompareOptions, range: NSRange): number;
  setString(_: string): void;
}

export class NSMutableURLRequest extends URLRequest {
  //  static requestWithURL(_: URL): NSMutableURLRequest;
  //  static requestWithURLCachePolicyTimeoutInterval(_: URL, cachePolicy: URLRequest.CachePolicy, timeoutInterval: number): NSMutableURLRequest;
  HTTPBody: Data;
  setHTTPBody(_: Data);
  HTTPBodyStream: InputStream;
  setHTTPBodyStream(_: InputStream);
  HTTPMethod: string;
  setHTTPMethod(_: string);
  HTTPShouldHandleCookies: boolean;
  setHTTPShouldHandleCookies(_: boolean);
  HTTPShouldUsePipelining: boolean;
  setHTTPShouldUsePipelining(_: boolean);
  URL: URL;
  setURL(_: URL);
  allHTTPHeaderFields: Map<string, string>;
  setAllHTTPHeaderFields(_: Map<string, string>);
  allowsCellularAccess: boolean;
  setAllowsCellularAccess(_: boolean);
  allowsConstrainedNetworkAccess: boolean;
  setAllowsConstrainedNetworkAccess(_: boolean);
  allowsExpensiveNetworkAccess: boolean;
  setAllowsExpensiveNetworkAccess(_: boolean);
  cachePolicy: URLRequest.CachePolicy;
  setCachePolicy(_: URLRequest.CachePolicy);
  mainDocumentURL: URL;
  setMainDocumentURL(_: URL);
  networkServiceType: URLRequest.NetworkServiceType;
  setNetworkServiceType(_: URLRequest.NetworkServiceType);
  timeoutInterval: number;
  setTimeoutInterval(_: number);
  addValueForHTTPHeaderField(_: string, forHTTPHeaderField: string): void;
  setValueForHTTPHeaderField(_?: string, forHTTPHeaderField?: string): void;
}

export class NSNameSpecifier extends NSScriptObjectSpecifier {
  name: string;
  setName(_: string);
  static initWithContainerClassDescriptionContainerSpecifierKeyName(_: NSScriptClassDescription, containerSpecifier?: NSScriptObjectSpecifier, key?: string, name?: string): NSNameSpecifier;
}

// export function NSNextHashEnumeratorItem(enumerator: NSHashEnumerator): any;

// export function NSNextMapEnumeratorPair(enumerator: NSMapEnumerator, key: any, value: any): boolean;

export class NSNull extends NSObject {
}

export class NSNumber extends NSValue {
  boolValue: boolean;
  charValue: number;
  decimalValue: DecimalStruct;
  doubleValue: number;
  floatValue: number;
  intValue: number;
  integerValue: number;
  longLongValue: number;
  shortValue: number;
  stringValue: string;
  unsignedCharValue: number;
  unsignedIntValue: number;
  unsignedIntegerValue: number;
  unsignedLongLongValue: number;
  unsignedShortValue: number;
  compare(_: number): NSObjCRuntime.ComparisonResult;
  // dupe name w inherited static method  descriptionWithLocale(withLocale?: any): string;
  static initWithLong(_: number): NSNumber;
  static initWithUnsignedLong(_: number): NSNumber;
  isEqualToNumber(to: number): boolean;
}

// export function NSOffsetRect(aRect: CGRect, dX: number, dY: number): CGRect;

// export function NSOpenStepRootDirectory(): string;

export class NSOrderedCollectionChange<ObjectType> extends NSObject {
  associatedIndex: number;
  changeType: NSOrderedCollectionChange.NSCollectionChangeType;
  index: number;
  object: ObjectType;
}

export class NSOrderedSet<ObjectType> extends NSObject {
  static orderedSetWithObjects<ObjectType>(_: ObjectType): NSOrderedSet<ObjectType>;
  array: ObjectType[];
  count: number;
  firstObject: ObjectType;
  lastObject: ObjectType;
  reversedOrderedSet: NSOrderedSet<any>;
  set: Set<any>;
  containsObject(_: ObjectType): boolean;
  // dupe name w inherited static method  descriptionWithLocale(withLocale?: any): string;
  // dupe name w inherited static method  descriptionWithLocaleIndent(withLocale?: any, indent?: number): string;
  differenceFromOrderedSet(from: NSOrderedSet<any>): CollectionDifference<any>;
  differenceFromOrderedSetWithOptions(from: NSOrderedSet<any>, with_: CollectionDifference.NSOrderedCollectionDifferenceCalculationOptions): CollectionDifference<any>;
  differenceFromOrderedSetWithOptionsUsingEquivalenceTest(from: NSOrderedSet<any>, with_: CollectionDifference.NSOrderedCollectionDifferenceCalculationOptions, usingEquivalenceTest: (p1: ObjectType, p2: ObjectType) => boolean): CollectionDifference<any>;
  enumerateObjectsAtIndexesOptionsUsingBlock(at: IndexSet, options: NSObjCRuntime.NSEnumerationOptions, using: (p1: ObjectType, p2: number, p3: boolean) => void): void;
  enumerateObjectsUsingBlock(_: (p1: ObjectType, p2: number, p3: boolean) => void): void;
  enumerateObjectsWithOptionsUsingBlock(options: NSObjCRuntime.NSEnumerationOptions, using: (p1: ObjectType, p2: number, p3: boolean) => void): void;
  filteredOrderedSetUsingPredicate(using: NSPredicate): NSOrderedSet<any>;
  indexOfObject(of: ObjectType): number;
  indexOfObjectInSortedRangeOptionsUsingComparator(of: ObjectType, inSortedRange: NSRange, options: Array.NSBinarySearchingOptions, usingComparator: (p1: any, p2: any) => NSObjCRuntime.ComparisonResult): number;
  indexOfObjectAtIndexesOptionsPassingTest(ofObjectAt: IndexSet, options: NSObjCRuntime.NSEnumerationOptions, passingTest: (p1: ObjectType, p2: number, p3: boolean) => boolean): number;
  indexOfObjectPassingTest(ofObjectPassingTest: (p1: ObjectType, p2: number, p3: boolean) => boolean): number;
  indexOfObjectWithOptionsPassingTest(_: NSObjCRuntime.NSEnumerationOptions, ofObjectPassingTest: (p1: ObjectType, p2: number, p3: boolean) => boolean): number;
  indexesOfObjectsAtIndexesOptionsPassingTest(ofObjectsAt: IndexSet, options: NSObjCRuntime.NSEnumerationOptions, passingTest: (p1: ObjectType, p2: number, p3: boolean) => boolean): IndexSet;
  indexesOfObjectsPassingTest(ofObjectsPassingTest: (p1: ObjectType, p2: number, p3: boolean) => boolean): IndexSet;
  indexesOfObjectsWithOptionsPassingTest(options: NSObjCRuntime.NSEnumerationOptions, ofObjectsPassingTest: (p1: ObjectType, p2: number, p3: boolean) => boolean): IndexSet;
  intersectsOrderedSet(_: NSOrderedSet<any>): boolean;
  intersectsSet(_: Set<any>): boolean;
  isEqualToOrderedSet(to: NSOrderedSet<any>): boolean;
  isSubsetOfOrderedSet(of: NSOrderedSet<any>): boolean;
  isSubsetOfSet(of: Set<any>): boolean;
  objectAtIndex(at: number): ObjectType;
  objectEnumerator(): NSEnumerator<any>;
  objectsAtIndexes(at: IndexSet): ObjectType[];
  orderedSetByApplyingDifference(_: CollectionDifference<any>): NSOrderedSet<any>;
  reverseObjectEnumerator(): NSEnumerator<any>;
  sortedArrayUsingComparator(comparator: (p1: any, p2: any) => NSObjCRuntime.ComparisonResult): ObjectType[];
  sortedArrayUsingDescriptors(using: NSSortDescriptor[]): ObjectType[];
  sortedArrayWithOptionsUsingComparator(options: NSObjCRuntime.NSSortOptions, usingComparator: (p1: any, p2: any) => NSObjCRuntime.ComparisonResult): ObjectType[];
}

export class NSOrthography extends NSObject {
  static defaultOrthographyForLanguage(forLanguage: string): NSOrthography;
  allLanguages: string[];
  allScripts: string[];
  dominantLanguage: string;
  dominantScript: string;
  languageMap: Map<string, string[]>;
  // dupe name w instance property   dominantLanguageForScript(forScript: string): string;
  static initWithDominantScriptLanguageMap(_: string, languageMap: Map<string, string[]>): NSOrthography;
  languagesForScript(forScript: string): string[];
}

// export function NSPageSize(): number;

// export function NSPointFromString(aString: string): CGPoint;

// export function NSPointInRect(aPoint: CGPoint, aRect: CGRect): boolean;

export class NSPointerArray extends NSObject {
  static strongObjectsPointerArray(): NSPointerArray;
  static weakObjectsPointerArray(): NSPointerArray;
  allObjects: any[];
  count: number;
  setCount(_: number);
  pointerFunctions: NSPointerFunctions;
  addPointer(_?: any): void;
  compact(): void;
  static initWithOptions(_: NSPointerFunctions.Options): NSPointerArray;
  static initWithPointerFunctions(_: NSPointerFunctions): NSPointerArray;
  insertPointerAtIndex(_?: any, at?: number): void;
  pointerAtIndex(at: number): any;
  removePointerAtIndex(at: number): void;
  replacePointerAtIndexWithPointer(at: number, withPointer?: any): void;
}

export class NSPointerFunctions extends NSObject {
  acquireFunction: (p1: any, p2: (p1: any) => number, p3: boolean) => any;
  setAcquireFunction(_: (p1: any, p2: (p1: any) => number, p3: boolean) => any);
  descriptionFunction: (p1: any) => string;
  setDescriptionFunction(_: (p1: any) => string);
  hashFunction: (p1: any, p2: (p1: any) => number) => number;
  setHashFunction(_: (p1: any, p2: (p1: any) => number) => number);
  isEqualFunction: (p1: any, p2: any, p3: (p1: any) => number) => boolean;
  setIsEqualFunction(_: (p1: any, p2: any, p3: (p1: any) => number) => boolean);
  relinquishFunction: (p1: any, p2: (p1: any) => number) => void;
  setRelinquishFunction(_: (p1: any, p2: (p1: any) => number) => void);
  sizeFunction: (p1: any) => number;
  setSizeFunction(_: (p1: any) => number);
  static initWithOptions(_: NSPointerFunctions.Options): NSPointerFunctions;
}

export class NSPortCoder extends NSCoder {
  decodePortObject(): Port;
  encodePortObject(_: Port): void;
  isBycopy(): boolean;
  isByref(): boolean;
}

export class NSPortNameServer extends NSObject {
  static systemDefaultPortNameServer(): NSPortNameServer;
  portForName(forName: string): Port;
  portForNameHost(forName: string, host?: string): Port;
  registerPortName(_: Port, name: string): boolean;
  removePortForName(forName: string): boolean;
}

export class NSPositionalSpecifier extends NSObject {
  insertionContainer: any;
  insertionIndex: number;
  insertionKey: string;
  insertionReplaces: boolean;
  position: NSScriptObjectSpecifiers.NSPositionalSpecifier.InsertionPosition;
  evaluate(): void;
  static initWithPositionObjectSpecifier(_: NSScriptObjectSpecifiers.NSPositionalSpecifier.InsertionPosition, objectSpecifier: NSScriptObjectSpecifier): NSPositionalSpecifier;
  setInsertionClassDescription(_: NSScriptClassDescription): void;
}

export class NSPredicate extends NSObject {
  predicateFormat: string;
  allowEvaluation(): void;
  evaluateWithObject(with_?: any): boolean;
  evaluateWithObjectSubstitutionVariables(with_?: any, substitutionVariables?: Map<string, any>): boolean;
  predicateWithSubstitutionVariables(_: Map<string, any>): NSPredicate;
}

export class NSPropertySpecifier extends NSScriptObjectSpecifier {
}

export class NSProtocolChecker extends NSProxy {
  //  static alloc(): NSProtocolChecker;
  //  static allocWithZone(with_?: any): NSProtocolChecker;
  protocol: any /* Protocol */;
  target: NSObject;
  static initWithTargetProtocol(_: NSObject, protocol: any /* Protocol */): NSProtocolChecker;
}

// export function NSProtocolFromString(namestr: string): any /* Protocol */;

export class NSProxy {
  static alloc(): NSProxy;
  static class(): typeof NSObject;
  static respondsToSelector(to: string): boolean;
  dealloc(): void;
  finalize(): void;
  forwardInvocation(_: NSInvocation): void;
}

export class NSPurgeableData extends NSMutableData {
  //  static data(): NSPurgeableData;
  //  static dataWithBytesLength(_?: any, length?: number): NSPurgeableData;
  //  static dataWithBytesNoCopyLength(_: any, length: number): NSPurgeableData;
  //  static dataWithBytesNoCopyLengthFreeWhenDone(_: any, length: number, freeWhenDone: boolean): NSPurgeableData;
  //  static dataWithContentsOfFile(_: string): NSPurgeableData;
  //  static dataWithContentsOfFileOptions(options: string, error: Data.ReadingOptions): NSPurgeableData;
  //  static dataWithContentsOfURL(_: URL): NSPurgeableData;
  //  static dataWithContentsOfURLOptions(options: URL, error: Data.ReadingOptions): NSPurgeableData;
  //  static dataWithData(_: Data): NSPurgeableData;
}

export class NSQuitCommand extends NSScriptCommand {
}

export class NSRandomSpecifier extends NSScriptObjectSpecifier {
}

// export function NSRangeFromString(aString: string): NSRange;

export class NSRangeSpecifier extends NSScriptObjectSpecifier {
  endSpecifier: NSScriptObjectSpecifier;
  setEndSpecifier(_: NSScriptObjectSpecifier);
  startSpecifier: NSScriptObjectSpecifier;
  setStartSpecifier(_: NSScriptObjectSpecifier);
  static initWithContainerClassDescriptionContainerSpecifierKeyStartSpecifierEndSpecifier(_: NSScriptClassDescription, containerSpecifier?: NSScriptObjectSpecifier, key?: string, startSpecifier?: NSScriptObjectSpecifier, endSpecifier?: NSScriptObjectSpecifier): NSRangeSpecifier;
}

// export function NSReallocateCollectable(ptr: any, size: number, options: number): any;

// export function NSRecordAllocationEvent(eventType: number, object_: any): void;

// export function NSRectFromString(aString: string): CGRect;

export class NSRecursiveLock extends NSObject {
  name: string;
  setName(_: string);
  lockBeforeDate(before: Date): boolean;
  tryLock(): boolean;
}

// export function NSRecycleZone(zone: any): void;

export class NSRegularExpression extends NSObject {
  static escapedPatternForString(for_: string): string;
  static escapedTemplateForString(for_: string): string;
  static regularExpressionWithPatternOptions(options: string, error: NSRegularExpression.Options): NSRegularExpression;
  numberOfCaptureGroups: number;
  options: NSRegularExpression.Options;
  pattern: string;
  enumerateMatchesInStringOptionsRangeUsingBlock(in_: string, options: NSRegularExpression.MatchingOptions, range: NSRange, using?: (p1: NSTextCheckingResult, p2: NSRegularExpression.MatchingFlags, p3: boolean) => void): void;
  firstMatchInStringOptionsRange(in_: string, options: NSRegularExpression.MatchingOptions, range: NSRange): NSTextCheckingResult;
  static initWithPatternOptions(options: string, error: NSRegularExpression.Options): NSRegularExpression;
  matchesInStringOptionsRange(in_: string, options: NSRegularExpression.MatchingOptions, range: NSRange): NSTextCheckingResult[];
  numberOfMatchesInStringOptionsRange(in_: string, options: NSRegularExpression.MatchingOptions, range: NSRange): number;
  rangeOfFirstMatchInStringOptionsRange(in_: string, options: NSRegularExpression.MatchingOptions, range: NSRange): NSRange;
  replaceMatchesInStringOptionsRangeWithTemplate(in_: NSMutableString, options: NSRegularExpression.MatchingOptions, range: NSRange, withTemplate: string): number;
  replacementStringForResultInStringOffsetTemplate(for_: NSTextCheckingResult, in_: string, offset: number, template: string): string;
  stringByReplacingMatchesInStringOptionsRangeWithTemplate(in_: string, options: NSRegularExpression.MatchingOptions, range: NSRange, withTemplate: string): string;
}

export class NSRelativeSpecifier extends NSScriptObjectSpecifier {
  baseSpecifier: NSScriptObjectSpecifier;
  setBaseSpecifier(_: NSScriptObjectSpecifier);
  relativePosition: NSScriptObjectSpecifiers.NSRelativeSpecifier.RelativePosition;
  setRelativePosition(_: NSScriptObjectSpecifiers.NSRelativeSpecifier.RelativePosition);
  static initWithContainerClassDescriptionContainerSpecifierKeyRelativePositionBaseSpecifier(_: NSScriptClassDescription, containerSpecifier?: NSScriptObjectSpecifier, key?: string, relativePosition?: NSScriptObjectSpecifiers.NSRelativeSpecifier.RelativePosition, baseSpecifier?: NSScriptObjectSpecifier): NSRelativeSpecifier;
}

// export function NSResetHashTable(table: NSHashTable<any>): void;

// export function NSResetMapTable(table: NSMapTable<any, any>): void;

// export function NSReturnAddress(frame: number): any;

// export function NSRoundDownToMultipleOfPageSize(bytes: number): number;

// export function NSRoundUpToMultipleOfPageSize(bytes: number): number;

export class NSScriptClassDescription extends NSClassDescription {
  appleEventCode: number;
  defaultSubcontainerAttributeKey: string;
  implementationClassName: string;
  suiteName: string;
  superclassDescription: NSScriptClassDescription;
  // dupe name w instance property   appleEventCodeForKey(forKey: string): number;
  classDescriptionForKey(_: string): NSScriptClassDescription;
  hasOrderedToManyRelationshipForKey(forKey: string): boolean;
  hasPropertyForKey(forKey: string): boolean;
  hasReadablePropertyForKey(forKey: string): boolean;
  hasWritablePropertyForKey(forKey: string): boolean;
  static initWithSuiteNameClassNameDictionary(_: string, className: string, dictionary?: Map<any, any>): NSScriptClassDescription;
  isLocationRequiredToCreateForKey(forKey: string): boolean;
  keyWithAppleEventCode(withAppleEventCode: number): string;
  matchesAppleEventCode(_: number): boolean;
  selectorForCommand(forCommand: NSScriptCommandDescription): string;
  supportsCommand(_: NSScriptCommandDescription): boolean;
  typeForKey(forKey: string): string;
}

export class NSScriptCoercionHandler extends NSObject {
  static sharedCoercionHandler(): NSScriptCoercionHandler;
  coerceValueToClass(_: any, to: typeof NSObject): any;
  registerCoercerSelectorToConvertFromClassToClass(_: any, selector: string, toConvertFrom: typeof NSObject, to: typeof NSObject): void;
}

export class NSScriptCommand extends NSObject {
  static currentCommand(): NSScriptCommand;
  appleEvent: NSAppleEventDescriptor;
  arguments: Map<string, any>;
  setArguments(_: Map<string, any>);
  commandDescription: NSScriptCommandDescription;
  directParameter: any;
  setDirectParameter(_: any);
  evaluatedArguments: Map<string, any>;
  evaluatedReceivers: any;
  receiversSpecifier: NSScriptObjectSpecifier;
  setReceiversSpecifier(_: NSScriptObjectSpecifier);
  scriptErrorExpectedTypeDescriptor: NSAppleEventDescriptor;
  setScriptErrorExpectedTypeDescriptor(_: NSAppleEventDescriptor);
  scriptErrorNumber: number;
  setScriptErrorNumber(_: number);
  scriptErrorOffendingObjectDescriptor: NSAppleEventDescriptor;
  setScriptErrorOffendingObjectDescriptor(_: NSAppleEventDescriptor);
  scriptErrorString: string;
  setScriptErrorString(_: string);
  isWellFormed: boolean;
  executeCommand(): any;
  static initWithCommandDescription(_: NSScriptCommandDescription): NSScriptCommand;
  performDefaultImplementation(): any;
  resumeExecutionWithResult(withResult?: any): void;
  suspendExecution(): void;
}

export class NSScriptCommandDescription extends NSObject {
  appleEventClassCode: number;
  appleEventCode: number;
  appleEventCodeForReturnType: number;
  argumentNames: string[];
  commandClassName: string;
  commandName: string;
  returnType: string;
  suiteName: string;
  appleEventCodeForArgumentWithName(withName: string): number;
  createCommandInstance(): NSScriptCommand;
  createCommandInstanceWithZone(with_?: any): NSScriptCommand;
  static initWithSuiteNameCommandNameDictionary(_: string, commandName: string, dictionary?: Map<any, any>): NSScriptCommandDescription;
  isOptionalArgumentWithName(withName: string): boolean;
  typeForArgumentWithName(withName: string): string;
}

export class NSScriptExecutionContext extends NSObject {
  static sharedScriptExecutionContext(): NSScriptExecutionContext;
  objectBeingTested: any;
  setObjectBeingTested(_: any);
  rangeContainerObject: any;
  setRangeContainerObject(_: any);
  topLevelObject: any;
  setTopLevelObject(_: any);
}

export class NSScriptObjectSpecifier extends NSObject {
  childSpecifier: NSScriptObjectSpecifier;
  setChildSpecifier(_: NSScriptObjectSpecifier);
  containerClassDescription: NSScriptClassDescription;
  setContainerClassDescription(_: NSScriptClassDescription);
  containerIsObjectBeingTested: boolean;
  setContainerIsObjectBeingTested(_: boolean);
  containerIsRangeContainerObject: boolean;
  setContainerIsRangeContainerObject(_: boolean);
  containerSpecifier: NSScriptObjectSpecifier;
  setContainerSpecifier(_: NSScriptObjectSpecifier);
  descriptor: NSAppleEventDescriptor;
  evaluationErrorNumber: number;
  setEvaluationErrorNumber(_: number);
  evaluationErrorSpecifier: NSScriptObjectSpecifier;
  key: string;
  setKey(_: string);
  keyClassDescription: NSScriptClassDescription;
  objectsByEvaluatingSpecifier: any;
  indicesOfObjectsByEvaluatingWithContainerCount(withContainer: any, count: number): number;
  static initWithContainerClassDescriptionContainerSpecifierKey(_: NSScriptClassDescription, containerSpecifier?: NSScriptObjectSpecifier, key?: string): NSScriptObjectSpecifier;
  static initWithContainerSpecifierKey(_: NSScriptObjectSpecifier, key: string): NSScriptObjectSpecifier;
  objectsByEvaluatingWithContainers(withContainers: any): any;
}

export class NSScriptSuiteRegistry extends NSObject {
  static setSharedScriptSuiteRegistry(_: NSScriptSuiteRegistry): void;
  static sharedScriptSuiteRegistry(): NSScriptSuiteRegistry;
  suiteNames: string[];
  aeteResource(_: string): Data;
  appleEventCodeForSuite(forSuite: string): number;
  bundleForSuite(forSuite: string): Bundle;
  classDescriptionsInSuite(inSuite: string): Map<string, NSScriptClassDescription>;
  commandDescriptionWithAppleEventClassAndAppleEventCode(withAppleEventClass: number, andAppleEventCode: number): NSScriptCommandDescription;
  commandDescriptionsInSuite(inSuite: string): Map<string, NSScriptCommandDescription>;
  loadSuiteWithDictionaryFromBundle(with_: Map<any, any>, from: Bundle): void;
  loadSuitesFromBundle(from: Bundle): void;
  registerClassDescription(_: NSScriptClassDescription): void;
  registerCommandDescription(_: NSScriptCommandDescription): void;
  suiteForAppleEventCode(forAppleEventCode: number): string;
}

export class NSScriptWhoseTest extends NSObject {
  isTrue(): boolean;
}

// export function NSSearchPathForDirectoriesInDomains(directory: NSPathUtilities.FileManager.SearchPathDirectory, domainMask: NSPathUtilities.FileManager.SearchPathDomainMask, expandTilde: boolean): string[];

interface NSSecureCoding {
}

export class NSSecureUnarchiveFromDataTransformer extends ValueTransformer {
  static allowedTopLevelClasses: typeof NSObject[];
}

// export function NSSelectorFromString(aSelectorName: string): string;

export class NSSetCommand extends NSScriptCommand {
  keySpecifier: NSScriptObjectSpecifier;
  setReceiversSpecifier(_?: NSScriptObjectSpecifier): void;
}

// export function NSSetUncaughtExceptionHandler(p1: (p1: NSException) => void): void;

// export function NSSetZoneName(zone: any, name: string): void;

// export function NSShouldRetainWithZone(anObject: any, requestedZone: any): boolean;

// @ts-ignore
export class NSSimpleCString extends String {
  //  static objectWithItemProviderDataTypeIdentifier(typeIdentifier: Data, error: string): NSSimpleCString;
  //  static stringWithCStringEncoding(_: string, encoding: number): NSSimpleCString;
  //  static stringWithCharactersLength(_: string, length: number): NSSimpleCString;
  //  static stringWithContentsOfFileEncoding(encoding: string, error: number): NSSimpleCString;
  //  static stringWithContentsOfFileUsedEncoding(usedEncoding: string, error?: number): NSSimpleCString;
  //  static stringWithContentsOfURLEncoding(encoding: URL, error: number): NSSimpleCString;
  //  static stringWithContentsOfURLUsedEncoding(usedEncoding: URL, error?: number): NSSimpleCString;
  //  static stringWithString(_: string): NSSimpleCString;
  //  static stringWithUTF8String(_: string): NSSimpleCString;
}

// export function NSSizeFromString(aString: string): CGSize;

export class NSSocketPortNameServer extends NSPortNameServer {
  static sharedInstance(): any;
  defaultNameServerPortNumber: number;
  setDefaultNameServerPortNumber(_: number);
  portForNameHostNameServerPortNumber(forName: string, host?: string, nameServerPortNumber?: number): Port;
  registerPortNameNameServerPortNumber(_: Port, name: string, nameServerPortNumber: number): boolean;
}

export class NSSortDescriptor extends NSObject {
  ascending: boolean;
  comparator: (p1: any, p2: any) => NSObjCRuntime.ComparisonResult;
  key: string;
  reversedSortDescriptor: any;
  selector: string;
  allowEvaluation(): void;
  compareObjectToObject(_: any, to: any): NSObjCRuntime.ComparisonResult;
  static initWithKeyAscending(_?: string, ascending?: boolean): NSSortDescriptor;
  static initWithKeyAscendingComparator(_?: string, ascending?: boolean, comparator?: (p1: any, p2: any) => NSObjCRuntime.ComparisonResult): NSSortDescriptor;
  static initWithKeyAscendingSelector(_?: string, ascending?: boolean, selector?: string): NSSortDescriptor;
}

export class NSSpecifierTest extends NSScriptWhoseTest {
  static initWithObjectSpecifierComparisonOperatorTestObject(_?: NSScriptObjectSpecifier, comparisonOperator?: NSScriptWhoseTests.NSSpecifierTest.TestComparisonOperation, testObject?: any): NSSpecifierTest;
}

export class NSSpellServer extends NSObject {
  delegate: any;
  setDelegate(_: any);
  isWordInUserDictionariesCaseSensitive(inUserDictionaries: string, caseSensitive: boolean): boolean;
  registerLanguageByVendor(_?: string, byVendor?: string): boolean;
  run(): void;
}

interface NSSpellServerDelegate {
  spellServerFindMisspelledWordInStringLanguageWordCountCountOnly(_: NSSpellServer, findMisspelledWordIn: string, language: string, wordCount: number, countOnly: boolean): NSRange;
  spellServerSuggestGuessesForWordInLanguage(_: NSSpellServer, suggestGuessesForWord: string, inLanguage: string): string[];
  spellServerDidLearnWordInLanguage(_: NSSpellServer, didLearnWord: string, inLanguage: string): void;
  spellServerDidForgetWordInLanguage(_: NSSpellServer, didForgetWord: string, inLanguage: string): void;
  spellServerSuggestCompletionsForPartialWordRangeInStringLanguage(_: NSSpellServer, suggestCompletionsForPartialWordRange: NSRange, in_: string, language: string): string[];
  spellServerCheckGrammarInStringLanguageDetails(_: NSSpellServer, checkGrammarIn: string, language?: string, details?: Map<string, any>[]): NSRange;
  spellServerCheckStringOffsetTypesOptionsOrthographyWordCount(_: NSSpellServer, check: string, offset: number, types: number, options?: Map<string, any>, orthography?: NSOrthography, wordCount?: number): NSTextCheckingResult[];
  spellServerRecordResponseToCorrectionForWordLanguage(_: NSSpellServer, recordResponse: number, toCorrection: string, forWord: string, language: string): void;
}

// export function NSStringFromClass(aClass: typeof NSObject): string;

// export function NSStringFromHashTable(table: NSHashTable<any>): string;

// export function NSStringFromMapTable(table: NSMapTable<any, any>): string;

// export function NSStringFromPoint(aPoint: CGPoint): string;

// export function NSStringFromProtocol(proto: any /* Protocol */): string;

// export function NSStringFromRange(range: NSRange): string;

// export function NSStringFromRect(aRect: CGRect): string;

// export function NSStringFromSelector(aSelector: string): string;

// export function NSStringFromSize(aSize: CGSize): string;

// export function NSTemporaryDirectory(): string;

export class NSTextCheckingResult extends NSObject {
  static addressCheckingResultWithRangeComponents(range: NSRange, components: Map<string, string>): NSTextCheckingResult;
  static correctionCheckingResultWithRangeReplacementString(range: NSRange, replacementString: string): NSTextCheckingResult;
  static correctionCheckingResultWithRangeReplacementStringAlternativeStrings(range: NSRange, replacementString: string, alternativeStrings: string[]): NSTextCheckingResult;
  static dashCheckingResultWithRangeReplacementString(range: NSRange, replacementString: string): NSTextCheckingResult;
  static dateCheckingResultWithRangeDate(range: NSRange, date: Date): NSTextCheckingResult;
  static dateCheckingResultWithRangeDateTimeZoneDuration(range: NSRange, date: Date, timeZone: TimeZone, duration: number): NSTextCheckingResult;
  static grammarCheckingResultWithRangeDetails(range: NSRange, details: Map<string, any>[]): NSTextCheckingResult;
  static linkCheckingResultWithRangeURL(range: NSRange, url: URL): NSTextCheckingResult;
  static orthographyCheckingResultWithRangeOrthography(range: NSRange, orthography: NSOrthography): NSTextCheckingResult;
  static phoneNumberCheckingResultWithRangePhoneNumber(range: NSRange, phoneNumber: string): NSTextCheckingResult;
  static quoteCheckingResultWithRangeReplacementString(range: NSRange, replacementString: string): NSTextCheckingResult;
  static regularExpressionCheckingResultWithRangesCountRegularExpression(ranges: NSRange, count: number, regularExpression: NSRegularExpression): NSTextCheckingResult;
  static replacementCheckingResultWithRangeReplacementString(range: NSRange, replacementString: string): NSTextCheckingResult;
  static spellCheckingResultWithRange(range: NSRange): NSTextCheckingResult;
  static transitInformationCheckingResultWithRangeComponents(range: NSRange, components: Map<string, string>): NSTextCheckingResult;
  URL: URL;
  addressComponents: Map<string, string>;
  alternativeStrings: string[];
  components: Map<string, string>;
  date: Date;
  duration: number;
  grammarDetails: Map<string, any>[];
  numberOfRanges: number;
  orthography: NSOrthography;
  phoneNumber: string;
  range: NSRange;
  regularExpression: NSRegularExpression;
  replacementString: string;
  resultType: NSTextCheckingResult.CheckingType;
  timeZone: TimeZone;
  // dupe name w instance property   rangeAtIndex(at: number): NSRange;
  // dupe name w instance property   rangeWithName(withName: string): NSRange;
  resultByAdjustingRangesWithOffset(offset: number): NSTextCheckingResult;
}

export class NSURLConnection extends NSObject {
  static canHandleRequest(_: URLRequest): boolean;
  currentRequest: URLRequest;
  originalRequest: URLRequest;
  cancel(): void;
  scheduleInRunLoopForMode(in_: RunLoop, forMode: string): void;
  setDelegateQueue(_?: OperationQueue): void;
  start(): void;
  unscheduleFromRunLoopForMode(from: RunLoop, forMode: string): void;
}

interface NSURLConnectionDataDelegate {
  connectionWillSendRequestRedirectResponse(_: NSURLConnection, willSend: URLRequest, redirectResponse?: URLResponse): URLRequest;
  connectionDidReceiveResponse(_: NSURLConnection, didReceive: URLResponse): void;
  connectionDidReceiveData(_: NSURLConnection, didReceive: Data): void;
  connectionNeedNewBodyStream(_: NSURLConnection, needNewBodyStream: URLRequest): InputStream;
  connectionDidSendBodyDataTotalBytesWrittenTotalBytesExpectedToWrite(_: NSURLConnection, didSendBodyData: number, totalBytesWritten: number, totalBytesExpectedToWrite: number): void;
  connectionWillCacheResponse(_: NSURLConnection, willCacheResponse: CachedURLResponse): CachedURLResponse;
  connectionDidFinishLoading(_: NSURLConnection): void;
}

interface NSURLConnectionDelegate {
  connectionDidFailWithError(_: NSURLConnection, didFailWithError: Error): void;
  connectionWillSendRequestForAuthenticationChallenge(_: NSURLConnection, willSendRequestFor: URLAuthenticationChallenge): void;
  connectionShouldUseCredentialStorage(_: NSURLConnection): boolean;
}

interface NSURLConnectionDownloadDelegate {
  connectionDidWriteDataTotalBytesWrittenExpectedTotalBytes(_: NSURLConnection, didWriteData: number, totalBytesWritten: number, expectedTotalBytes: number): void;
  connectionDidFinishDownloadingDestinationURL(_: NSURLConnection, destinationURL: URL): void;
  connectionDidResumeDownloadingTotalBytesWrittenExpectedTotalBytes(_: NSURLConnection, totalBytesWritten: number, expectedTotalBytes: number): void;
}

export class NSURLDownload extends NSObject {
  static canResumeDownloadDecodedWithEncodingMIMEType(withEncodingMIMEType: string): boolean;
  deletesFileUponFailure: boolean;
  setDeletesFileUponFailure(_: boolean);
  request: URLRequest;
  resumeData: Data;
  cancel(): void;
  setDestinationAllowOverwrite(_: string, allowOverwrite: boolean): void;
}

interface NSURLDownloadDelegate {
  downloadWillSendRequestRedirectResponse(_: NSURLDownload, willSend: URLRequest, redirectResponse?: URLResponse): URLRequest;
  downloadCanAuthenticateAgainstProtectionSpace(_: NSURLDownload, canAuthenticateAgainstProtectionSpace: URLProtectionSpace): boolean;
  downloadDidReceiveAuthenticationChallenge(_: NSURLDownload, didReceive: URLAuthenticationChallenge): void;
  downloadDidCancelAuthenticationChallenge(_: NSURLDownload, didCancel: URLAuthenticationChallenge): void;
  downloadDidReceiveResponse(_: NSURLDownload, didReceive: URLResponse): void;
  downloadWillResumeWithResponseFromByte(_: NSURLDownload, willResumeWith: URLResponse, fromByte: number): void;
  downloadDidReceiveDataOfLength(_: NSURLDownload, didReceiveDataOfLength: number): void;
  downloadShouldDecodeSourceDataOfMIMEType(_: NSURLDownload, shouldDecodeSourceDataOfMIMEType: string): boolean;
  downloadDecideDestinationWithSuggestedFilename(_: NSURLDownload, decideDestinationWithSuggestedFilename: string): void;
  downloadDidCreateDestination(_: NSURLDownload, didCreateDestination: string): void;
  downloadDidFailWithError(_: NSURLDownload, didFailWithError: Error): void;
  downloadDidBegin(_: NSURLDownload): void;
  downloadDidFinish(_: NSURLDownload): void;
  downloadShouldUseCredentialStorage(_: NSURLDownload): boolean;
}

export class NSURLHandle extends NSObject {
}

export class NSURLSessionWebSocketMessage extends NSObject {
  data: Data;
  type: URLSession.NSURLSessionWebSocketMessageType;
  static initWithData(_: Data): NSURLSessionWebSocketMessage;
  static initWithString(_: string): NSURLSessionWebSocketMessage;
}

export class NSUbiquitousKeyValueStore extends NSObject {
  dictionaryRepresentation: Map<string, any>;
  static defaultStore: NSUbiquitousKeyValueStore;
  arrayForKey(forKey: string): any[];
  boolForKey(forKey: string): boolean;
  dataForKey(forKey: string): Data;
  dictionaryForKey(forKey: string): Map<string, any>;
  doubleForKey(forKey: string): number;
  longLongForKey(forKey: string): number;
  objectForKey(forKey: string): any;
  removeObjectForKey(forKey: string): void;
  setArrayForKey(_?: any[], forKey?: string): void;
  setBoolForKey(_: boolean, forKey: string): void;
  setDataForKey(_?: Data, forKey?: string): void;
  setDictionaryForKey(_?: Map<string, any>, forKey?: string): void;
  setDoubleForKey(_: number, forKey: string): void;
  setLongLongForKey(_: number, forKey: string): void;
  setObjectForKey(_?: any, forKey?: string): void;
  setStringForKey(_?: string, forKey?: string): void;
  synchronize(): boolean;
}

// export function NSUnionRange(range1: NSRange, range2: NSRange): NSRange;

// export function NSUnionRect(aRect: CGRect, bRect: CGRect): CGRect;

export class NSUniqueIDSpecifier extends NSScriptObjectSpecifier {
  uniqueID: any;
  setUniqueID(_: any);
  static initWithContainerClassDescriptionContainerSpecifierKeyUniqueID(_: NSScriptClassDescription, containerSpecifier?: NSScriptObjectSpecifier, key?: string, uniqueID?: any): NSUniqueIDSpecifier;
}

export class NSUnitInformationStorage extends Dimension {
  //  static baseUnit(): NSUnitInformationStorage;
  static bits: NSUnitInformationStorage;
  static bytes: NSUnitInformationStorage;
  static exabits: NSUnitInformationStorage;
  static exabytes: NSUnitInformationStorage;
  static exbibits: NSUnitInformationStorage;
  static exbibytes: NSUnitInformationStorage;
  static gibibits: NSUnitInformationStorage;
  static gibibytes: NSUnitInformationStorage;
  static gigabits: NSUnitInformationStorage;
  static gigabytes: NSUnitInformationStorage;
  static kibibits: NSUnitInformationStorage;
  static kibibytes: NSUnitInformationStorage;
  static kilobits: NSUnitInformationStorage;
  static kilobytes: NSUnitInformationStorage;
  static mebibits: NSUnitInformationStorage;
  static mebibytes: NSUnitInformationStorage;
  static megabits: NSUnitInformationStorage;
  static megabytes: NSUnitInformationStorage;
  static nibbles: NSUnitInformationStorage;
  static pebibits: NSUnitInformationStorage;
  static pebibytes: NSUnitInformationStorage;
  static petabits: NSUnitInformationStorage;
  static petabytes: NSUnitInformationStorage;
  static tebibits: NSUnitInformationStorage;
  static tebibytes: NSUnitInformationStorage;
  static terabits: NSUnitInformationStorage;
  static terabytes: NSUnitInformationStorage;
  static yobibits: NSUnitInformationStorage;
  static yobibytes: NSUnitInformationStorage;
  static yottabits: NSUnitInformationStorage;
  static yottabytes: NSUnitInformationStorage;
  static zebibits: NSUnitInformationStorage;
  static zebibytes: NSUnitInformationStorage;
  static zettabits: NSUnitInformationStorage;
  static zettabytes: NSUnitInformationStorage;
}

export class NSUserActivity extends NSObject {
  activityType: string;
  delegate: any;
  setDelegate(_: any);
  detectedBarcodeDescriptor: CIBarcodeDescriptor;
  isEligibleForHandoff: boolean;
  setEligibleForHandoff(_: boolean);
  isEligibleForPublicIndexing: boolean;
  setEligibleForPublicIndexing(_: boolean);
  isEligibleForSearch: boolean;
  setEligibleForSearch(_: boolean);
  expirationDate: Date;
  setExpirationDate(_: Date);
  keywords: Set<any>;
  setKeywords(_: Set<any>);
  needsSave: boolean;
  setNeedsSave(_: boolean);
  referrerURL: URL;
  setReferrerURL(_: URL);
  requiredUserInfoKeys: Set<any>;
  setRequiredUserInfoKeys(_: Set<any>);
  supportsContinuationStreams: boolean;
  setSupportsContinuationStreams(_: boolean);
  targetContentIdentifier: string;
  setTargetContentIdentifier(_: string);
  title: string;
  setTitle(_: string);
  userInfo: Map<any, any>;
  setUserInfo(_: Map<any, any>);
  webpageURL: URL;
  setWebpageURL(_: URL);
  addUserInfoEntriesFromDictionary(from: Map<any, any>): void;
  becomeCurrent(): void;
  getContinuationStreamsWithCompletionHandler(completionHandler?: (p1: InputStream, p2: OutputStream, p3: Error) => void): void;
  static initWithActivityType(_: string): NSUserActivity;
  invalidate(): void;
  resignCurrent(): void;
}

interface NSUserActivityDelegate {
  userActivityDidReceiveInputStreamOutputStream(_: NSUserActivity, didReceive: InputStream, outputStream: OutputStream): void;
  userActivityWasContinued(_: NSUserActivity): void;
  userActivityWillSave(_: NSUserActivity): void;
}

export class NSUserAppleScriptTask extends NSUserScriptTask {
  executeWithAppleEventCompletionHandler(withAppleEvent?: NSAppleEventDescriptor, completionHandler?: (p1: NSAppleEventDescriptor, p2: Error) => void): void;
}

export class NSUserAutomatorTask extends NSUserScriptTask {
  variables: Map<string, any>;
  setVariables(_: Map<string, any>);
  executeWithInputCompletionHandler(withInput?: any, completionHandler?: (p1: any, p2: Error) => void): void;
}

// export function NSUserName(): string;

export class NSUserNotification extends NSObject {
  actionButtonTitle: string;
  setActionButtonTitle(_: string);
  activationType: NSUserNotification.ActivationType;
  actualDeliveryDate: Date;
  additionalActions: NSUserNotificationAction[];
  setAdditionalActions(_: NSUserNotificationAction[]);
  additionalActivationAction: NSUserNotificationAction;
  contentImage: NSImage;
  setContentImage(_: NSImage);
  deliveryDate: Date;
  setDeliveryDate(_: Date);
  deliveryRepeatInterval: DateComponents;
  setDeliveryRepeatInterval(_: DateComponents);
  deliveryTimeZone: TimeZone;
  setDeliveryTimeZone(_: TimeZone);
  hasActionButton: boolean;
  setHasActionButton(_: boolean);
  hasReplyButton: boolean;
  setHasReplyButton(_: boolean);
  identifier: string;
  setIdentifier(_: string);
  informativeText: string;
  setInformativeText(_: string);
  otherButtonTitle: string;
  setOtherButtonTitle(_: string);
  isPresented: boolean;
  isRemote: boolean;
  response: NSAttributedString;
  responsePlaceholder: string;
  setResponsePlaceholder(_: string);
  soundName: string;
  setSoundName(_: string);
  subtitle: string;
  setSubtitle(_: string);
  title: string;
  setTitle(_: string);
  userInfo: Map<string, any>;
  setUserInfo(_: Map<string, any>);
}

export class NSUserNotificationAction extends NSObject {
  identifier: string;
  title: string;
}

export class NSUserNotificationCenter extends NSObject {
  delegate: any;
  setDelegate(_: any);
  deliveredNotifications: NSUserNotification[];
  scheduledNotifications: NSUserNotification[];
  setScheduledNotifications(_: NSUserNotification[]);
  static defaultUserNotificationCenter: NSUserNotificationCenter;
  deliverNotification(_: NSUserNotification): void;
  removeAllDeliveredNotifications(): void;
  removeDeliveredNotification(_: NSUserNotification): void;
  removeScheduledNotification(_: NSUserNotification): void;
  scheduleNotification(_: NSUserNotification): void;
}

interface NSUserNotificationCenterDelegate {
  userNotificationCenterDidDeliverNotification(_: NSUserNotificationCenter, didDeliver: NSUserNotification): void;
  userNotificationCenterDidActivateNotification(_: NSUserNotificationCenter, didActivate: NSUserNotification): void;
  userNotificationCenterShouldPresentNotification(_: NSUserNotificationCenter, shouldPresent: NSUserNotification): boolean;
}

export class NSUserScriptTask extends NSObject {
  scriptURL: URL;
  executeWithCompletionHandler(completionHandler?: (p1: Error) => void): void;
  static initWithURL(error: URL): NSUserScriptTask;
}

export class NSUserUnixTask extends NSUserScriptTask {
  standardError: FileHandle;
  setStandardError(_: FileHandle);
  standardInput: FileHandle;
  setStandardInput(_: FileHandle);
  standardOutput: FileHandle;
  setStandardOutput(_: FileHandle);
  executeWithArgumentsCompletionHandler(withArguments?: string[], completionHandler?: (p1: Error) => void): void;
}

export class NSValue extends NSObject {
  CATransform3DValue: CATransform3D;
  CMTimeMappingValue: CMTimeMapping;
  CMTimeRangeValue: CMTimeRange;
  CMTimeValue: CMTime;
  edgeInsetsValue: NSEdgeInsets;
  nonretainedObjectValue: any;
  objCType: string;
  pointValue: CGPoint;
  pointerValue: any;
  rangeValue: NSRange;
  rectValue: CGRect;
  sizeValue: CGSize;
  getValue(_: any): void;
  getValueSize(_: any, size: number): void;
  static initWithBytesObjCType(_: any, objCType: string): NSValue;
  isEqualToValue(to: NSValue): boolean;
}

export class NSWhoseSpecifier extends NSScriptObjectSpecifier {
  endSubelementIdentifier: NSScriptObjectSpecifiers.NSWhoseSpecifier.SubelementIdentifier;
  setEndSubelementIdentifier(_: NSScriptObjectSpecifiers.NSWhoseSpecifier.SubelementIdentifier);
  endSubelementIndex: number;
  setEndSubelementIndex(_: number);
  startSubelementIdentifier: NSScriptObjectSpecifiers.NSWhoseSpecifier.SubelementIdentifier;
  setStartSubelementIdentifier(_: NSScriptObjectSpecifiers.NSWhoseSpecifier.SubelementIdentifier);
  startSubelementIndex: number;
  setStartSubelementIndex(_: number);
  test: NSScriptWhoseTest;
  setTest(_: NSScriptWhoseTest);
  static initWithContainerClassDescriptionContainerSpecifierKeyTest(_: NSScriptClassDescription, containerSpecifier?: NSScriptObjectSpecifier, key?: string, test?: NSScriptWhoseTest): NSWhoseSpecifier;
}

export class NSXPCCoder extends NSCoder {
  connection: NSXPCConnection;
  userInfo: any;
  setUserInfo(_: any);
  decodeXPCObjectOfTypeForKey(ofType: any, forKey: string): NSObject;
  encodeXPCObjectForKey(_: NSObject, forKey: string): void;
}

export class NSXPCConnection extends NSObject {
  static currentConnection(): NSXPCConnection;
  auditSessionIdentifier: number;
  effectiveGroupIdentifier: number;
  effectiveUserIdentifier: number;
  endpoint: NSXPCListenerEndpoint;
  exportedInterface: NSXPCInterface;
  setExportedInterface(_: NSXPCInterface);
  exportedObject: any;
  setExportedObject(_: any);
  interruptionHandler: () => void;
  setInterruptionHandler(_: () => void);
  invalidationHandler: () => void;
  setInvalidationHandler(_: () => void);
  processIdentifier: number;
  remoteObjectInterface: NSXPCInterface;
  setRemoteObjectInterface(_: NSXPCInterface);
  remoteObjectProxy: any;
  serviceName: string;
  static initWithListenerEndpoint(_: NSXPCListenerEndpoint): NSXPCConnection;
  static initWithMachServiceNameOptions(_: string, options: NSXPCConnection.Options): NSXPCConnection;
  static initWithServiceName(_: string): NSXPCConnection;
  invalidate(): void;
  resume(): void;
  scheduleSendBarrierBlock(_: () => void): void;
  suspend(): void;
}

export class NSXPCInterface extends NSObject {
  protocol: any /* Protocol */;
  setProtocol(_: any /* Protocol */);
  xPCTypeForSelectorArgumentIndexOfReply(for_: string, argumentIndex: number, ofReply: boolean): any;
  classesForSelectorArgumentIndexOfReply(for_: string, argumentIndex: number, ofReply: boolean): Set<any>;
  interfaceForSelectorArgumentIndexOfReply(_: string, argumentIndex: number, ofReply: boolean): NSXPCInterface;
  setClassesForSelectorArgumentIndexOfReply(_: Set<any>, for_: string, argumentIndex: number, ofReply: boolean): void;
  setInterfaceForSelectorArgumentIndexOfReply(_: NSXPCInterface, for_: string, argumentIndex: number, ofReply: boolean): void;
  setXPCTypeForSelectorArgumentIndexOfReply(_: any, for_: string, argumentIndex: number, ofReply: boolean): void;
}

export class NSXPCListener extends NSObject {
  static anonymousListener(): NSXPCListener;
  static serviceListener(): NSXPCListener;
  delegate: any;
  setDelegate(_: any);
  endpoint: NSXPCListenerEndpoint;
  static initWithMachServiceName(_: string): NSXPCListener;
  invalidate(): void;
  resume(): void;
  suspend(): void;
}

interface NSXPCListenerDelegate {
  listenerShouldAcceptNewConnection(_: NSXPCListener, shouldAcceptNewConnection: NSXPCConnection): boolean;
}

export class NSXPCListenerEndpoint extends NSObject {
}

interface NSXPCProxyCreating {
  remoteObjectProxy: any;
  remoteObjectProxyWithErrorHandler(_: (p1: Error) => void): any;
  synchronousRemoteObjectProxyWithErrorHandler(_: (p1: Error) => void): any;
}

// export function NSZoneCalloc(zone: any, numElems: number, byteSize: number): any;

// export function NSZoneFree(zone: any, ptr: any): void;

// export function NSZoneFromPointer(ptr: any): any;

// export function NSZoneMalloc(zone: any, size: number): any;

// export function NSZoneName(zone: any): string;

// export function NSZoneRealloc(zone: any, ptr: any, size: number): any;

export class NetService extends NSObject {
  static dataFromTXTRecordDictionary(fromTXTRecord: Map<string, Data>): Data;
  static dictionaryFromTXTRecordData(fromTXTRecord: Data): Map<string, Data>;
  addresses: Data[];
  delegate: any;
  setDelegate(_: any);
  domain: string;
  hostName: string;
  includesPeerToPeer: boolean;
  setIncludesPeerToPeer(_: boolean);
  name: string;
  port: number;
  type: string;
  tXTRecordData(): Data;
  getInputStreamOutputStream(_?: InputStream, outputStream?: OutputStream): boolean;
  static initWithDomainTypeName(_: string, type: string, name: string): NetService;
  static initWithDomainTypeNamePort(_: string, type: string, name: string, port: number): NetService;
  publish(): void;
  publishWithOptions(options: NSNetServices.NetService.Options): void;
  removeFromRunLoopForMode(from: RunLoop, forMode: string): void;
  resolveWithTimeout(withTimeout: number): void;
  scheduleInRunLoopForMode(in_: RunLoop, forMode: string): void;
  setTXTRecordData(_?: Data): boolean;
  startMonitoring(): void;
  stop(): void;
  stopMonitoring(): void;
}

export class NetServiceBrowser extends NSObject {
  delegate: any;
  setDelegate(_: any);
  includesPeerToPeer: boolean;
  setIncludesPeerToPeer(_: boolean);
  removeFromRunLoopForMode(from: RunLoop, forMode: string): void;
  scheduleInRunLoopForMode(in_: RunLoop, forMode: string): void;
  searchForBrowsableDomains(): void;
  searchForRegistrationDomains(): void;
  searchForServicesOfTypeInDomain(ofType: string, inDomain: string): void;
  stop(): void;
}

interface NetServiceBrowserDelegate {
  netServiceBrowserDidNotSearch(_: NetServiceBrowser, didNotSearch: Map<string, number>): void;
  netServiceBrowserDidFindDomainMoreComing(_: NetServiceBrowser, didFindDomain: string, moreComing: boolean): void;
  netServiceBrowserDidFindServiceMoreComing(_: NetServiceBrowser, didFind: NetService, moreComing: boolean): void;
  netServiceBrowserDidRemoveDomainMoreComing(_: NetServiceBrowser, didRemoveDomain: string, moreComing: boolean): void;
  netServiceBrowserDidRemoveServiceMoreComing(_: NetServiceBrowser, didRemove: NetService, moreComing: boolean): void;
  netServiceBrowserDidStopSearch(_: NetServiceBrowser): void;
  netServiceBrowserWillSearch(_: NetServiceBrowser): void;
}

interface NetServiceDelegate {
  netServiceDidNotPublish(_: NetService, didNotPublish: Map<string, number>): void;
  netServiceDidNotResolve(_: NetService, didNotResolve: Map<string, number>): void;
  netServiceDidUpdateTXTRecordData(_: NetService, didUpdateTXTRecord: Data): void;
  netServiceDidAcceptConnectionWithInputStreamOutputStream(_: NetService, didAcceptConnectionWith: InputStream, outputStream: OutputStream): void;
  netServiceDidPublish(_: NetService): void;
  netServiceDidResolveAddress(_: NetService): void;
  netServiceDidStop(_: NetService): void;
  netServiceWillPublish(_: NetService): void;
  netServiceWillResolve(_: NetService): void;
}

export class Notification extends NSObject {
  static notificationWithNameObject(_: string, object_?: any): Notification;
  static notificationWithNameObjectUserInfo(_: string, object_?: any, userInfo?: Map<any, any>): Notification;
  name: string;
  object: any;
  userInfo: Map<any, any>;
  static initWithNameObjectUserInfo(_: string, object_?: any, userInfo?: Map<any, any>): Notification;
}

export class NotificationCenter extends NSObject {
  static defaultCenter: NotificationCenter;
  addObserverSelectorNameObject(_: any, selector: string, name?: string, object_?: any): void;
  addObserverForNameObjectQueueUsingBlock(forName?: string, object_?: any, queue?: OperationQueue, using?: (p1: Notification) => void): any;
  postNotification(_: Notification): void;
  postNotificationNameObject(name: string, object_?: any): void;
  postNotificationNameObjectUserInfo(name: string, object_?: any, userInfo?: Map<any, any>): void;
  removeObserver(_: any): void;
  removeObserverNameObject(_: any, name?: string, object_?: any): void;
}

export class NotificationQueue extends NSObject {
  static defaultQueue: NotificationQueue;
  dequeueNotificationsMatchingCoalesceMask(matching: Notification, coalesceMask: number): void;
  enqueueNotificationPostingStyle(_: Notification, postingStyle: NotificationQueue.PostingStyle): void;
  enqueueNotificationPostingStyleCoalesceMaskForModes(_: Notification, postingStyle: NotificationQueue.PostingStyle, coalesceMask: NotificationQueue.NotificationCoalescing, forModes?: string[]): void;
  static initWithNotificationCenter(_: NotificationCenter): NotificationQueue;
}

export class NumberFormatter extends Formatter {
  static defaultFormatterBehavior(): NumberFormatter.Behavior;
  static localizedStringFromNumberNumberStyle(from: number, number: NumberFormatter.Style): string;
  static setDefaultFormatterBehavior(_: NumberFormatter.Behavior): void;
  allowsFloats: boolean;
  setAllowsFloats(_: boolean);
  alwaysShowsDecimalSeparator: boolean;
  setAlwaysShowsDecimalSeparator(_: boolean);
  attributedStringForNil: NSAttributedString;
  setAttributedStringForNil(_: NSAttributedString);
  attributedStringForNotANumber: NSAttributedString;
  setAttributedStringForNotANumber(_: NSAttributedString);
  attributedStringForZero: NSAttributedString;
  setAttributedStringForZero(_: NSAttributedString);
  currencyCode: string;
  setCurrencyCode(_: string);
  currencyDecimalSeparator: string;
  setCurrencyDecimalSeparator(_: string);
  currencyGroupingSeparator: string;
  setCurrencyGroupingSeparator(_: string);
  currencySymbol: string;
  setCurrencySymbol(_: string);
  decimalSeparator: string;
  setDecimalSeparator(_: string);
  exponentSymbol: string;
  setExponentSymbol(_: string);
  format: string;
  setFormat(_: string);
  formatWidth: number;
  setFormatWidth(_: number);
  formatterBehavior: NumberFormatter.Behavior;
  setFormatterBehavior(_: NumberFormatter.Behavior);
  formattingContext: Formatter.Context;
  setFormattingContext(_: Formatter.Context);
  generatesDecimalNumbers: boolean;
  setGeneratesDecimalNumbers(_: boolean);
  groupingSeparator: string;
  setGroupingSeparator(_: string);
  groupingSize: number;
  setGroupingSize(_: number);
  hasThousandSeparators: boolean;
  setHasThousandSeparators(_: boolean);
  internationalCurrencySymbol: string;
  setInternationalCurrencySymbol(_: string);
  isLenient: boolean;
  setLenient(_: boolean);
  locale: Locale;
  setLocale(_: Locale);
  localizesFormat: boolean;
  setLocalizesFormat(_: boolean);
  maximum: number;
  setMaximum(_: number);
  maximumFractionDigits: number;
  setMaximumFractionDigits(_: number);
  maximumIntegerDigits: number;
  setMaximumIntegerDigits(_: number);
  maximumSignificantDigits: number;
  setMaximumSignificantDigits(_: number);
  minimum: number;
  setMinimum(_: number);
  minimumFractionDigits: number;
  setMinimumFractionDigits(_: number);
  minimumIntegerDigits: number;
  setMinimumIntegerDigits(_: number);
  minimumSignificantDigits: number;
  setMinimumSignificantDigits(_: number);
  minusSign: string;
  setMinusSign(_: string);
  multiplier: number;
  setMultiplier(_: number);
  negativeFormat: string;
  setNegativeFormat(_: string);
  negativeInfinitySymbol: string;
  setNegativeInfinitySymbol(_: string);
  negativePrefix: string;
  setNegativePrefix(_: string);
  negativeSuffix: string;
  setNegativeSuffix(_: string);
  nilSymbol: string;
  setNilSymbol(_: string);
  notANumberSymbol: string;
  setNotANumberSymbol(_: string);
  numberStyle: NumberFormatter.Style;
  setNumberStyle(_: NumberFormatter.Style);
  paddingCharacter: string;
  setPaddingCharacter(_: string);
  paddingPosition: NumberFormatter.PadPosition;
  setPaddingPosition(_: NumberFormatter.PadPosition);
  isPartialStringValidationEnabled: boolean;
  setPartialStringValidationEnabled(_: boolean);
  perMillSymbol: string;
  setPerMillSymbol(_: string);
  percentSymbol: string;
  setPercentSymbol(_: string);
  plusSign: string;
  setPlusSign(_: string);
  positiveFormat: string;
  setPositiveFormat(_: string);
  positiveInfinitySymbol: string;
  setPositiveInfinitySymbol(_: string);
  positivePrefix: string;
  setPositivePrefix(_: string);
  positiveSuffix: string;
  setPositiveSuffix(_: string);
  roundingBehavior: NSDecimalNumberHandler;
  setRoundingBehavior(_: NSDecimalNumberHandler);
  roundingIncrement: number;
  setRoundingIncrement(_: number);
  roundingMode: NumberFormatter.RoundingMode;
  setRoundingMode(_: NumberFormatter.RoundingMode);
  secondaryGroupingSize: number;
  setSecondaryGroupingSize(_: number);
  textAttributesForNegativeInfinity: Map<string, any>;
  setTextAttributesForNegativeInfinity(_: Map<string, any>);
  textAttributesForNegativeValues: Map<string, any>;
  setTextAttributesForNegativeValues(_: Map<string, any>);
  textAttributesForNil: Map<string, any>;
  setTextAttributesForNil(_: Map<string, any>);
  textAttributesForNotANumber: Map<string, any>;
  setTextAttributesForNotANumber(_: Map<string, any>);
  textAttributesForPositiveInfinity: Map<string, any>;
  setTextAttributesForPositiveInfinity(_: Map<string, any>);
  textAttributesForPositiveValues: Map<string, any>;
  setTextAttributesForPositiveValues(_: Map<string, any>);
  textAttributesForZero: Map<string, any>;
  setTextAttributesForZero(_: Map<string, any>);
  thousandSeparator: string;
  setThousandSeparator(_: string);
  usesGroupingSeparator: boolean;
  setUsesGroupingSeparator(_: boolean);
  usesSignificantDigits: boolean;
  setUsesSignificantDigits(_: boolean);
  zeroSymbol: string;
  setZeroSymbol(_: string);
  getObjectValueForStringRange(forString?: any, range?: string, error?: NSRange): boolean;
  numberFromString(from: string): number;
}

export class Operation extends NSObject {
  isAsynchronous: boolean;
  isCancelled: boolean;
  completionBlock: () => void;
  setCompletionBlock(_: () => void);
  isConcurrent: boolean;
  dependencies: Operation[];
  isExecuting: boolean;
  isFinished: boolean;
  name: string;
  setName(_: string);
  qualityOfService: NSObjCRuntime.QualityOfService;
  setQualityOfService(_: NSObjCRuntime.QualityOfService);
  queuePriority: Operation.QueuePriority;
  setQueuePriority(_: Operation.QueuePriority);
  isReady: boolean;
  addDependency(_: Operation): void;
  cancel(): void;
  main(): void;
  removeDependency(_: Operation): void;
  start(): void;
  waitUntilFinished(): void;
}

export class OperationQueue extends NSObject {
  maxConcurrentOperationCount: number;
  setMaxConcurrentOperationCount(_: number);
  name: string;
  setName(_: string);
  operationCount: number;
  operations: Operation[];
  qualityOfService: NSObjCRuntime.QualityOfService;
  setQualityOfService(_: NSObjCRuntime.QualityOfService);
  isSuspended: boolean;
  setSuspended(_: boolean);
  underlyingQueue: NSObject;
  setUnderlyingQueue(_: NSObject);
  static currentQueue: OperationQueue;
  static mainQueue: OperationQueue;
  addBarrierBlock(_: () => void): void;
  addOperation(_: Operation): void;
  addOperationWithBlock(_: () => void): void;
  addOperationsWaitUntilFinished(_: Operation[], waitUntilFinished: boolean): void;
  cancelAllOperations(): void;
  waitUntilAllOperationsAreFinished(): void;
}

export class OutputStream extends Stream {
  static outputStreamToMemory(): OutputStream;
  hasSpaceAvailable: boolean;
  static initToBufferCapacity(_: string, capacity: number): OutputStream;
  static initToFileAtPathAppend(_: string, append: boolean): OutputStream;
  static initToMemory(): OutputStream;
  static initWithURLAppend(_: URL, append: boolean): OutputStream;
  writeMaxLength(_: string, maxLength: number): number;
}

export class PersonNameComponents extends NSObject {
  familyName: string;
  setFamilyName(_: string);
  givenName: string;
  setGivenName(_: string);
  middleName: string;
  setMiddleName(_: string);
  namePrefix: string;
  setNamePrefix(_: string);
  nameSuffix: string;
  setNameSuffix(_: string);
  nickname: string;
  setNickname(_: string);
  phoneticRepresentation: PersonNameComponents;
  setPhoneticRepresentation(_: PersonNameComponents);
}

export class PersonNameComponentsFormatter extends Formatter {
  static localizedStringFromPersonNameComponentsStyleOptions(from: PersonNameComponents, style: PersonNameComponentsFormatter.Style, options: PersonNameComponentsFormatter.Options): string;
  isPhonetic: boolean;
  setPhonetic(_: boolean);
  style: PersonNameComponentsFormatter.Style;
  setStyle(_: PersonNameComponentsFormatter.Style);
  annotatedStringFromPersonNameComponents(from: PersonNameComponents): NSAttributedString;
  personNameComponentsFromString(from: string): PersonNameComponents;
}

export class Pipe extends NSObject {
  fileHandleForReading: FileHandle;
  fileHandleForWriting: FileHandle;
}

export class Port extends NSObject {
  reservedSpaceLength: number;
  isValid: boolean;
  delegate(): any;
  invalidate(): void;
  removeFromRunLoopForMode(from: RunLoop, forMode: string): void;
  scheduleInRunLoopForMode(in_: RunLoop, forMode: string): void;
  sendBeforeDateComponentsFromReserved(before: Date, components?: any[], from?: Port, reserved?: number): boolean;
  sendBeforeDateMsgidComponentsFromReserved(before: Date, msgid: number, components?: any[], from?: Port, reserved?: number): boolean;
  setDelegate(_?: any): void;
}

interface PortDelegate {
  handlePortMessage(_: PortMessage): void;
}

export class PortMessage extends NSObject {
  components: any[];
  msgid: number;
  setMsgid(_: number);
  receivePort: Port;
  sendPort: Port;
  static initWithSendPortReceivePortComponents(_?: Port, receivePort?: Port, components?: any[]): PortMessage;
  sendBeforeDate(before: Date): boolean;
}

export class Process extends NSObject {
  static launchedTaskWithExecutableURLArgumentsErrorTerminationHandler(_: URL, arguments_: string[], error?: Error, terminationHandler?: (p1: Process) => void): Process;
  static launchedTaskWithLaunchPathArguments(launchPath: string, arguments_: string[]): Process;
  arguments: string[];
  setArguments(_: string[]);
  currentDirectoryPath: string;
  setCurrentDirectoryPath(_: string);
  currentDirectoryURL: URL;
  setCurrentDirectoryURL(_: URL);
  environment: Map<string, string>;
  setEnvironment(_: Map<string, string>);
  executableURL: URL;
  setExecutableURL(_: URL);
  launchPath: string;
  setLaunchPath(_: string);
  processIdentifier: number;
  qualityOfService: NSObjCRuntime.QualityOfService;
  setQualityOfService(_: NSObjCRuntime.QualityOfService);
  isRunning: boolean;
  standardError: any;
  setStandardError(_: any);
  standardInput: any;
  setStandardInput(_: any);
  standardOutput: any;
  setStandardOutput(_: any);
  terminationHandler: (p1: Process) => void;
  setTerminationHandler(_: (p1: Process) => void);
  terminationReason: Process.TerminationReason;
  terminationStatus: number;
  interrupt(): void;
  launch(): void;
  resume(): boolean;
  suspend(): boolean;
  terminate(): void;
  waitUntilExit(): void;
}

export class ProcessInfo extends NSObject {
  activeProcessorCount: number;
  arguments: string[];
  automaticTerminationSupportEnabled: boolean;
  setAutomaticTerminationSupportEnabled(_: boolean);
  environment: Map<string, string>;
  fullUserName: string;
  globallyUniqueString: string;
  hostName: string;
  isMacCatalystApp: boolean;
  operatingSystemVersion: OperatingSystemVersion;
  operatingSystemVersionString: string;
  physicalMemory: number;
  processIdentifier: number;
  processName: string;
  setProcessName(_: string);
  processorCount: number;
  systemUptime: number;
  thermalState: ProcessInfo.ThermalState;
  userName: string;
  static processInfo: ProcessInfo;
  beginActivityWithOptionsReason(options: ProcessInfo.ActivityOptions, reason: string): any;
  disableAutomaticTermination(_: string): void;
  disableSuddenTermination(): void;
  enableAutomaticTermination(_: string): void;
  enableSuddenTermination(): void;
  endActivity(_: any): void;
  isOperatingSystemAtLeastVersion(_: OperatingSystemVersion): boolean;
  performActivityWithOptionsReasonUsingBlock(options: ProcessInfo.ActivityOptions, reason: string, using: () => void): void;
}

export class Progress extends NSObject {
  static addSubscriberForFileURLWithPublishingHandler(forFileURL: URL, withPublishingHandler: (p1: Progress) => () => void): any;
  static currentProgress(): Progress;
  static discreteProgressWithTotalUnitCount(totalUnitCount: number): Progress;
  static removeSubscriber(_: any): void;
  isCancellable: boolean;
  setCancellable(_: boolean);
  cancellationHandler: () => void;
  setCancellationHandler(_: () => void);
  isCancelled: boolean;
  completedUnitCount: number;
  setCompletedUnitCount(_: number);
  estimatedTimeRemaining: number;
  setEstimatedTimeRemaining(_: number);
  fileCompletedCount: number;
  setFileCompletedCount(_: number);
  fileOperationKind: string;
  setFileOperationKind(_: string);
  fileTotalCount: number;
  setFileTotalCount(_: number);
  fileURL: URL;
  setFileURL(_: URL);
  isFinished: boolean;
  fractionCompleted: number;
  isIndeterminate: boolean;
  kind: string;
  setKind(_: string);
  localizedAdditionalDescription: string;
  setLocalizedAdditionalDescription(_: string);
  localizedDescription: string;
  setLocalizedDescription(_: string);
  isOld: boolean;
  isPausable: boolean;
  setPausable(_: boolean);
  isPaused: boolean;
  pausingHandler: () => void;
  setPausingHandler(_: () => void);
  resumingHandler: () => void;
  setResumingHandler(_: () => void);
  throughput: number;
  setThroughput(_: number);
  totalUnitCount: number;
  setTotalUnitCount(_: number);
  userInfo: Map<string, any>;
  addChildWithPendingUnitCount(_: Progress, withPendingUnitCount: number): void;
  becomeCurrentWithPendingUnitCount(withPendingUnitCount: number): void;
  cancel(): void;
  static initWithParentUserInfo(_?: Progress, userInfo?: Map<string, any>): Progress;
  pause(): void;
  performAsCurrentWithPendingUnitCountUsingBlock(_: number, usingBlock: () => void): void;
  publish(): void;
  resignCurrent(): void;
  resume(): void;
  setUserInfoObjectForKey(_?: any, forKey?: string): void;
  unpublish(): void;
}

interface ProgressReporting {
  progress: Progress;
}

export class PropertyListSerialization extends NSObject {
  static dataWithPropertyListFormatOptions(format: any, options: NSPropertyList.PropertyListSerialization.PropertyListFormat, error: number): Data;
  static propertyListIsValidForFormat(_: any, isValidFor: NSPropertyList.PropertyListSerialization.PropertyListFormat): boolean;
  static propertyListWithDataOptionsFormat(options: Data, format: NSPropertyList.PropertyListSerialization.MutabilityOptions, error?: NSPropertyList.PropertyListSerialization.PropertyListFormat): any;
  static propertyListWithStreamOptionsFormat(options: InputStream, format: NSPropertyList.PropertyListSerialization.MutabilityOptions, error?: NSPropertyList.PropertyListSerialization.PropertyListFormat): any;
  static writePropertyListToStreamFormatOptions(_: any, to: OutputStream, format: NSPropertyList.PropertyListSerialization.PropertyListFormat, options: number): number;
}

export class RelativeDateTimeFormatter extends Formatter {
  calendar: Calendar;
  setCalendar(_: Calendar);
  dateTimeStyle: RelativeDateTimeFormatter.DateTimeStyle;
  setDateTimeStyle(_: RelativeDateTimeFormatter.DateTimeStyle);
  formattingContext: Formatter.Context;
  setFormattingContext(_: Formatter.Context);
  locale: Locale;
  setLocale(_: Locale);
  unitsStyle: RelativeDateTimeFormatter.UnitsStyle;
  setUnitsStyle(_: RelativeDateTimeFormatter.UnitsStyle);
  localizedStringForDateRelativeToDate(for_: Date, relativeTo: Date): string;
  localizedStringFromDateComponents(from: DateComponents): string;
  localizedStringFromTimeInterval(fromTimeInterval: number): string;
}

export class RunLoop extends NSObject {
  currentMode: string;
  static currentRunLoop: RunLoop;
  static mainRunLoop: RunLoop;
  acceptInputForModeBeforeDate(forMode: string, before: Date): void;
  addPortForMode(_: Port, forMode: string): void;
  addTimerForMode(_: Timer, forMode: string): void;
  cancelPerformSelectorTargetArgument(_: string, target: any, argument?: any): void;
  cancelPerformSelectorsWithTarget(withTarget: any): void;
  getCFRunLoop(): any;
  limitDateForMode(forMode: string): Date;
  performBlock(_: () => void): void;
  performInModesBlock(inModes: string[], block: () => void): void;
  performSelectorTargetArgumentOrderModes(_: string, target: any, argument?: any, order?: number, modes?: string[]): void;
  removePortForMode(_: Port, forMode: string): void;
  run(): void;
  runModeBeforeDate(mode: string, before: Date): boolean;
  runUntilDate(until: Date): void;
}

export class Scanner extends NSObject {
  static localizedScannerWithString(with_: string): any;
  isAtEnd: boolean;
  caseSensitive: boolean;
  setCaseSensitive(_: boolean);
  charactersToBeSkipped: CharacterSet;
  setCharactersToBeSkipped(_: CharacterSet);
  locale: any;
  setLocale(_: any);
  static initWithString(_: string): Scanner;
  scanHexDouble(_?: number): boolean;
  scanHexFloat(_?: number): boolean;
  scanHexLongLong(_?: number): boolean;
  scanInt(_?: number): boolean;
  scanInteger(_?: number): boolean;
  scanLongLong(_?: number): boolean;
  scanUnsignedLongLong(_?: number): boolean;
}

export class SocketPort extends Port {
  address: Data;
  protocol: number;
  protocolFamily: number;
  socket: number;
  socketType: number;
  static initRemoteWithProtocolFamilySocketTypeProtocolAddress(_: number, socketType: number, protocol: number, address: Data): SocketPort;
  static initRemoteWithTCPPortHost(_: number, host?: string): SocketPort;
  static initWithProtocolFamilySocketTypeProtocolAddress(_: number, socketType: number, protocol: number, address: Data): SocketPort;
  static initWithProtocolFamilySocketTypeProtocolSocket(_: number, socketType: number, protocol: number, socket: number): SocketPort;
  static initWithTCPPort(_: number): SocketPort;
}

export class Stream extends NSObject {
  static getBoundStreamsWithBufferSizeInputStreamOutputStream(withBufferSize: number, inputStream?: InputStream, outputStream?: OutputStream): void;
  static getStreamsToHostWithNamePortInputStreamOutputStream(withName: string, port: number, inputStream?: InputStream, outputStream?: OutputStream): void;
  delegate: any;
  setDelegate(_: any);
  streamError: Error;
  streamStatus: Stream.Status;
  close(): void;
  open(): void;
  propertyForKey(forKey: string): any;
  removeFromRunLoopForMode(from: RunLoop, forMode: string): void;
  scheduleInRunLoopForMode(in_: RunLoop, forMode: string): void;
  setPropertyForKey(_?: any, forKey?: string): boolean;
}

interface StreamDelegate {
  streamHandleEvent(_: Stream, handle: Stream.Event): void;
}

export class Thread extends NSObject {
  static detachNewThreadSelectorToTargetWithObject(_: string, toTarget: any, with_?: any): void;
  static detachNewThreadWithBlock(_: () => void): void;
  static exit(): void;
  static isMultiThreaded(): boolean;
  static setThreadPriority(_: number): boolean;
  static sleepForTimeInterval(forTimeInterval: number): void;
  static sleepUntilDate(until: Date): void;
  //  static threadPriority(): number;
  isCancelled: boolean;
  isExecuting: boolean;
  isFinished: boolean;
  isMainThread: boolean;
  name: string;
  setName(_: string);
  qualityOfService: NSObjCRuntime.QualityOfService;
  setQualityOfService(_: NSObjCRuntime.QualityOfService);
  stackSize: number;
  setStackSize(_: number);
  threadDictionary: Map<any, any>;
  //   threadPriority: number;
  setThreadPriority(_: number);
  static callStackReturnAddresses: number[];
  static callStackSymbols: string[];
  static currentThread: Thread;
  //   static isMainThread: boolean;
  static mainThread: Thread;
  cancel(): void;
  static initWithBlock(_: () => void): Thread;
  static initWithTargetSelectorObject(_: any, selector: string, object_?: any): Thread;
  main(): void;
  start(): void;
}

export class TimeZone extends NSObject {
  //  static abbreviationDictionary(): Map<string, string>;
  static resetSystemTimeZone(): void;
  static timeZoneForSecondsFromGMT(_: number): TimeZone;
  static timeZoneWithAbbreviation(_: string): TimeZone;
  static timeZoneWithName(_: string): TimeZone;
  static timeZoneWithNameData(_: string, data?: Data): TimeZone;
  abbreviation: string;
  data: Data;
  isDaylightSavingTime: boolean;
  daylightSavingTimeOffset: number;
  name: string;
  nextDaylightSavingTimeTransition: Date;
  secondsFromGMT: number;
  //   static abbreviationDictionary: Map<string, string>;
  setAbbreviationDictionary(_: Map<string, string>);
  static defaultTimeZone: TimeZone;
  setDefaultTimeZone(_: TimeZone);
  static knownTimeZoneNames: string[];
  static localTimeZone: TimeZone;
  static systemTimeZone: TimeZone;
  static timeZoneDataVersion: string;
  abbreviationForDate(_: Date): string;
  daylightSavingTimeOffsetForDate(_: Date): number;
  static initWithName(_: string): TimeZone;
  static initWithNameData(_: string, data?: Data): TimeZone;
  isDaylightSavingTimeForDate(_: Date): boolean;
  isEqualToTimeZone(_: TimeZone): boolean;
  localizedNameLocale(_: TimeZone.NameStyle, locale?: Locale): string;
  nextDaylightSavingTimeTransitionAfterDate(_: Date): Date;
  secondsFromGMTForDate(_: Date): number;
}

export class Timer extends NSObject {
  static scheduledTimerWithTimeIntervalInvocationRepeats(timeInterval: number, invocation: NSInvocation, repeats: boolean): Timer;
  static scheduledTimerWithTimeIntervalRepeatsBlock(withTimeInterval: number, repeats: boolean, block: (p1: Timer) => void): Timer;
  static scheduledTimerWithTimeIntervalTargetSelectorUserInfoRepeats(timeInterval: number, target: any, selector: string, userInfo?: any, repeats?: boolean): Timer;
  fireDate: Date;
  setFireDate(_: Date);
  timeInterval: number;
  tolerance: number;
  setTolerance(_: number);
  userInfo: any;
  isValid: boolean;
  fire(): void;
  static initWithFireDateIntervalRepeatsBlock(_: Date, interval: number, repeats: boolean, block: (p1: Timer) => void): Timer;
  static initWithFireDateIntervalTargetSelectorUserInfoRepeats(_: Date, interval: number, target: any, selector: string, userInfo?: any, repeats?: boolean): Timer;
  invalidate(): void;
}

export class URL extends NSObject {
  static uRLByResolvingAliasFileAtURLOptions(options: URL, error: URL.BookmarkResolutionOptions): URL;
  static uRLByResolvingBookmarkDataOptionsRelativeToURLBookmarkDataIsStale(options: Data, relativeToURL: URL.BookmarkResolutionOptions, bookmarkDataIsStale?: URL, error?: boolean): URL;
  static uRLFromPasteboard(_: NSPasteboard): URL;
  static uRLWithDataRepresentationRelativeToURL(_: Data, relativeToURL?: URL): URL;
  static uRLWithString(_: string): URL;
  static uRLWithStringRelativeToURL(_: string, relativeToURL?: URL): URL;
  static absoluteURLWithDataRepresentationRelativeToURL(_: Data, relativeToURL?: URL): URL;
  static bookmarkDataWithContentsOfURL(error: URL): Data;
  static fileURLWithFileSystemRepresentationIsDirectoryRelativeToURL(_: string, isDirectory: boolean, relativeToURL?: URL): URL;
  static fileURLWithPath(_: string): URL;
  static fileURLWithPathIsDirectory(_: string, isDirectory: boolean): URL;
  static fileURLWithPathIsDirectoryRelativeToURL(_: string, isDirectory: boolean, relativeToURL?: URL): URL;
  static fileURLWithPathRelativeToURL(_: string, relativeToURL?: URL): URL;
  static fileURLWithPathComponents(_: string[]): URL;
  static resourceValuesForKeysFromBookmarkData(_: string[], fromBookmarkData: Data): Map<string, any>;
  static writeBookmarkDataToURLOptions(toURL: Data, options: URL, error: number): boolean;
  URLByDeletingLastPathComponent: URL;
  URLByDeletingPathExtension: URL;
  URLByResolvingSymlinksInPath: URL;
  URLByStandardizingPath: URL;
  absoluteString: string;
  absoluteURL: URL;
  baseURL: URL;
  dataRepresentation: Data;
  filePathURL: URL;
  fileSystemRepresentation: string;
  isFileURL: boolean;
  fragment: string;
  hasDirectoryPath: boolean;
  host: string;
  lastPathComponent: string;
  password: string;
  path: string;
  pathComponents: string[];
  pathExtension: string;
  port: number;
  query: string;
  relativePath: string;
  relativeString: string;
  resourceSpecifier: string;
  scheme: string;
  standardizedURL: URL;
  user: string;
  uRLByAppendingPathComponent(_: string): URL;
  uRLByAppendingPathComponentIsDirectory(_: string, isDirectory: boolean): URL;
  uRLByAppendingPathExtension(_: string): URL;
  bookmarkDataWithOptionsIncludingResourceValuesForKeysRelativeToURL(includingResourceValuesForKeys: URL.BookmarkCreationOptions, relativeToURL?: string[], error?: URL): Data;
  checkPromisedItemIsReachableAndReturnError(): boolean;
  checkResourceIsReachableAndReturnError(): boolean;
  fileReferenceURL(): URL;
  getFileSystemRepresentationMaxLength(_: string, maxLength: number): boolean;
  getPromisedItemResourceValueForKey(forKey?: any, error?: string): boolean;
  getResourceValueForKey(forKey?: any, error?: string): boolean;
  static initAbsoluteURLWithDataRepresentationRelativeToURL(_: Data, relativeToURL?: URL): URL;
  static initByResolvingBookmarkDataOptionsRelativeToURLBookmarkDataIsStale(options: Data, relativeToURL: URL.BookmarkResolutionOptions, bookmarkDataIsStale?: URL, error?: boolean): URL;
  static initFileURLWithFileSystemRepresentationIsDirectoryRelativeToURL(_: string, isDirectory: boolean, relativeToURL?: URL): URL;
  static initFileURLWithPath(_: string): URL;
  static initFileURLWithPathIsDirectory(_: string, isDirectory: boolean): URL;
  static initFileURLWithPathIsDirectoryRelativeToURL(_: string, isDirectory: boolean, relativeToURL?: URL): URL;
  static initFileURLWithPathRelativeToURL(_: string, relativeToURL?: URL): URL;
  static initWithDataRepresentationRelativeToURL(_: Data, relativeToURL?: URL): URL;
  static initWithString(_: string): URL;
  static initWithStringRelativeToURL(_: string, relativeToURL?: URL): URL;
  isFileReferenceURL(): boolean;
  promisedItemResourceValuesForKeys(error: string[]): Map<string, any>;
  removeAllCachedResourceValues(): void;
  removeCachedResourceValueForKey(_: string): void;
  resourceValuesForKeys(error: string[]): Map<string, any>;
  setResourceValueForKey(forKey?: any, error?: string): boolean;
  setResourceValues(error: Map<string, any>): boolean;
  setTemporaryResourceValueForKey(_?: any, forKey?: string): void;
  startAccessingSecurityScopedResource(): boolean;
  stopAccessingSecurityScopedResource(): void;
  writeToPasteboard(_: NSPasteboard): void;
}

export class URLAuthenticationChallenge extends NSObject {
  error: Error;
  failureResponse: URLResponse;
  previousFailureCount: number;
  proposedCredential: URLCredential;
  protectionSpace: URLProtectionSpace;
  sender: any;
  static initWithAuthenticationChallengeSender(_: URLAuthenticationChallenge, sender: any): URLAuthenticationChallenge;
  static initWithProtectionSpaceProposedCredentialPreviousFailureCountFailureResponseErrorSender(_: URLProtectionSpace, proposedCredential?: URLCredential, previousFailureCount?: number, failureResponse?: URLResponse, error?: Error, sender?: any): URLAuthenticationChallenge;
}

interface URLAuthenticationChallengeSender {
  cancelAuthenticationChallenge(_: URLAuthenticationChallenge): void;
  continueWithoutCredentialForAuthenticationChallenge(for_: URLAuthenticationChallenge): void;
  performDefaultHandlingForAuthenticationChallenge(for_: URLAuthenticationChallenge): void;
  rejectProtectionSpaceAndContinueWithChallenge(with_: URLAuthenticationChallenge): void;
  useCredentialForAuthenticationChallenge(_: URLCredential, for_: URLAuthenticationChallenge): void;
}

export class URLCache extends NSObject {
  currentDiskUsage: number;
  currentMemoryUsage: number;
  diskCapacity: number;
  setDiskCapacity(_: number);
  memoryCapacity: number;
  setMemoryCapacity(_: number);
  static sharedURLCache: URLCache;
  setSharedURLCache(_: URLCache);
  cachedResponseForRequest(for_: URLRequest): CachedURLResponse;
  getCachedResponseForDataTaskCompletionHandler(for_: URLSessionDataTask, completionHandler?: (p1: CachedURLResponse) => void): void;
  static initWithMemoryCapacityDiskCapacityDirectoryURL(_: number, diskCapacity: number, directoryURL?: URL): URLCache;
  static initWithMemoryCapacityDiskCapacityDiskPath(_: number, diskCapacity: number, diskPath?: string): URLCache;
  removeAllCachedResponses(): void;
  removeCachedResponseForDataTask(for_: URLSessionDataTask): void;
  removeCachedResponseForRequest(for_: URLRequest): void;
  removeCachedResponsesSinceDate(since: Date): void;
  storeCachedResponseForDataTask(_: CachedURLResponse, for_: URLSessionDataTask): void;
  storeCachedResponseForRequest(_: CachedURLResponse, for_: URLRequest): void;
}

export class URLComponents extends NSObject {
  static componentsWithString(_: string): URLComponents;
  static componentsWithURLResolvingAgainstBaseURL(_: URL, resolvingAgainstBaseURL: boolean): URLComponents;
  URL: URL;
  fragment: string;
  setFragment(_: string);
  host: string;
  setHost(_: string);
  password: string;
  setPassword(_: string);
  path: string;
  setPath(_: string);
  percentEncodedFragment: string;
  setPercentEncodedFragment(_: string);
  percentEncodedHost: string;
  setPercentEncodedHost(_: string);
  percentEncodedPassword: string;
  setPercentEncodedPassword(_: string);
  percentEncodedPath: string;
  setPercentEncodedPath(_: string);
  percentEncodedQuery: string;
  setPercentEncodedQuery(_: string);
  percentEncodedQueryItems: URLQueryItem[];
  setPercentEncodedQueryItems(_: URLQueryItem[]);
  percentEncodedUser: string;
  setPercentEncodedUser(_: string);
  port: number;
  setPort(_: number);
  query: string;
  setQuery(_: string);
  queryItems: URLQueryItem[];
  setQueryItems(_: URLQueryItem[]);
  rangeOfFragment: NSRange;
  rangeOfHost: NSRange;
  rangeOfPassword: NSRange;
  rangeOfPath: NSRange;
  rangeOfPort: NSRange;
  rangeOfQuery: NSRange;
  rangeOfScheme: NSRange;
  rangeOfUser: NSRange;
  scheme: string;
  setScheme(_: string);
  user: string;
  setUser(_: string);
  uRLRelativeToURL(_?: URL): URL;
  static initWithString(_: string): URLComponents;
  static initWithURLResolvingAgainstBaseURL(_: URL, resolvingAgainstBaseURL: boolean): URLComponents;
}

export class URLCredential extends NSObject {
  certificates: any[];
  hasPassword: boolean;
  identity: any;
  password: string;
  persistence: URLCredential.Persistence;
  user: string;
  static initWithIdentityCertificatesPersistence(_: any, certificates?: any[], persistence?: URLCredential.Persistence): URLCredential;
  static initWithTrust(_: any): URLCredential;
  static initWithUserPasswordPersistence(_: string, password: string, persistence: URLCredential.Persistence): URLCredential;
}

export class URLCredentialStorage extends NSObject {
  allCredentials: Map<URLProtectionSpace, Map<string, URLCredential>>;
  static sharedCredentialStorage: URLCredentialStorage;
  credentialsForProtectionSpace(for_: URLProtectionSpace): Map<string, URLCredential>;
  defaultCredentialForProtectionSpace(for_: URLProtectionSpace): URLCredential;
  getCredentialsForProtectionSpaceTaskCompletionHandler(for_: URLProtectionSpace, task: URLSessionTask, completionHandler?: (p1: Map<string, URLCredential>) => void): void;
  getDefaultCredentialForProtectionSpaceTaskCompletionHandler(for_: URLProtectionSpace, task: URLSessionTask, completionHandler?: (p1: URLCredential) => void): void;
  removeCredentialForProtectionSpace(_: URLCredential, for_: URLProtectionSpace): void;
  removeCredentialForProtectionSpaceOptions(_: URLCredential, for_: URLProtectionSpace, options?: Map<string, any>): void;
  removeCredentialForProtectionSpaceOptionsTask(_: URLCredential, for_: URLProtectionSpace, options?: Map<string, any>, task?: URLSessionTask): void;
  setCredentialForProtectionSpace(_: URLCredential, for_: URLProtectionSpace): void;
  setCredentialForProtectionSpaceTask(_: URLCredential, for_: URLProtectionSpace, task: URLSessionTask): void;
  setDefaultCredentialForProtectionSpace(_: URLCredential, for_: URLProtectionSpace): void;
  setDefaultCredentialForProtectionSpaceTask(_: URLCredential, for_: URLProtectionSpace, task: URLSessionTask): void;
}

export class URLProtectionSpace extends NSObject {
  authenticationMethod: string;
  distinguishedNames: Data[];
  host: string;
  isProxy: boolean;
  port: number;
  protocol: string;
  proxyType: string;
  realm: string;
  receivesCredentialSecurely: boolean;
  serverTrust: any;
  static initWithHostPortProtocolRealmAuthenticationMethod(_: string, port: number, protocol?: string, realm?: string, authenticationMethod?: string): URLProtectionSpace;
  static initWithProxyHostPortTypeRealmAuthenticationMethod(_: string, port: number, type?: string, realm?: string, authenticationMethod?: string): URLProtectionSpace;
}

export class URLProtocol extends NSObject {
  static canInitWithRequest(with_: URLRequest): boolean;
  static canInitWithTask(with_: URLSessionTask): boolean;
  static canonicalRequestForRequest(for_: URLRequest): URLRequest;
  static propertyForKeyInRequest(forKey: string, in_: URLRequest): any;
  static registerClass(_: typeof NSObject): boolean;
  static removePropertyForKeyInRequest(forKey: string, in_: NSMutableURLRequest): void;
  static requestIsCacheEquivalentToRequest(_: URLRequest, to: URLRequest): boolean;
  static setPropertyForKeyInRequest(_: any, forKey: string, in_: NSMutableURLRequest): void;
  static unregisterClass(_: typeof NSObject): void;
  cachedResponse: CachedURLResponse;
  client: any;
  request: URLRequest;
  task: URLSessionTask;
  static initWithRequestCachedResponseClient(_: URLRequest, cachedResponse?: CachedURLResponse, client?: any): URLProtocol;
  static initWithTaskCachedResponseClient(_: URLSessionTask, cachedResponse?: CachedURLResponse, client?: any): URLProtocol;
  startLoading(): void;
  stopLoading(): void;
}

interface URLProtocolClient {
  uRLProtocolWasRedirectedToRequestRedirectResponse(_: URLProtocol, wasRedirectedTo: URLRequest, redirectResponse: URLResponse): void;
  uRLProtocolCachedResponseIsValid(_: URLProtocol, cachedResponseIsValid: CachedURLResponse): void;
  uRLProtocolDidReceiveResponseCacheStoragePolicy(_: URLProtocol, didReceive: URLResponse, cacheStoragePolicy: URLCache.StoragePolicy): void;
  uRLProtocolDidLoadData(_: URLProtocol, didLoad: Data): void;
  uRLProtocolDidFailWithError(_: URLProtocol, didFailWithError: Error): void;
  uRLProtocolDidReceiveAuthenticationChallenge(_: URLProtocol, didReceive: URLAuthenticationChallenge): void;
  uRLProtocolDidCancelAuthenticationChallenge(_: URLProtocol, didCancel: URLAuthenticationChallenge): void;
  uRLProtocolDidFinishLoading(_: URLProtocol): void;
}

export class URLQueryItem extends NSObject {
  static queryItemWithNameValue(_: string, value?: string): URLQueryItem;
  name: string;
  static initWithNameValue(_: string, value?: string): URLQueryItem;
}

export class URLRequest extends NSObject {
  static requestWithURL(_: URL): URLRequest;
  static requestWithURLCachePolicyTimeoutInterval(_: URL, cachePolicy: URLRequest.CachePolicy, timeoutInterval: number): URLRequest;
  HTTPBody: Data;
  HTTPBodyStream: InputStream;
  HTTPMethod: string;
  HTTPShouldHandleCookies: boolean;
  HTTPShouldUsePipelining: boolean;
  URL: URL;
  allHTTPHeaderFields: Map<string, string>;
  allowsCellularAccess: boolean;
  allowsConstrainedNetworkAccess: boolean;
  allowsExpensiveNetworkAccess: boolean;
  cachePolicy: URLRequest.CachePolicy;
  mainDocumentURL: URL;
  networkServiceType: URLRequest.NetworkServiceType;
  timeoutInterval: number;
  static initWithURL(_: URL): URLRequest;
  static initWithURLCachePolicyTimeoutInterval(_: URL, cachePolicy: URLRequest.CachePolicy, timeoutInterval: number): URLRequest;
  valueForHTTPHeaderField(_: string): string;
}

export class URLResponse extends NSObject {
  MIMEType: string;
  URL: URL;
  expectedContentLength: number;
  suggestedFilename: string;
  textEncodingName: string;
  static initWithURLMIMETypeExpectedContentLengthTextEncodingName(_: URL, MIMEType?: string, expectedContentLength?: number, textEncodingName?: string): URLResponse;
}

export class URLSession extends NSObject {
  configuration: URLSessionConfiguration;
  delegate: any;
  delegateQueue: OperationQueue;
  sessionDescription: string;
  setSessionDescription(_: string);
  static sharedSession: URLSession;
  dataTaskWithRequest(with_: URLRequest): URLSessionDataTask;
  dataTaskWithRequestCompletionHandler(with_: URLRequest, completionHandler?: (p1: Data, p2: URLResponse, p3: Error) => void): URLSessionDataTask;
  dataTaskWithURL(with_: URL): URLSessionDataTask;
  dataTaskWithURLCompletionHandler(with_: URL, completionHandler?: (p1: Data, p2: URLResponse, p3: Error) => void): URLSessionDataTask;
  downloadTaskWithRequest(with_: URLRequest): URLSessionDownloadTask;
  downloadTaskWithRequestCompletionHandler(with_: URLRequest, completionHandler?: (p1: URL, p2: URLResponse, p3: Error) => void): URLSessionDownloadTask;
  downloadTaskWithResumeData(withResumeData: Data): URLSessionDownloadTask;
  downloadTaskWithResumeDataCompletionHandler(withResumeData: Data, completionHandler?: (p1: URL, p2: URLResponse, p3: Error) => void): URLSessionDownloadTask;
  downloadTaskWithURL(with_: URL): URLSessionDownloadTask;
  downloadTaskWithURLCompletionHandler(with_: URL, completionHandler?: (p1: URL, p2: URLResponse, p3: Error) => void): URLSessionDownloadTask;
  finishTasksAndInvalidate(): void;
  flushWithCompletionHandler(completionHandler: () => void): void;
  getAllTasksWithCompletionHandler(completionHandler: (p1: URLSessionTask[]) => void): void;
  getTasksWithCompletionHandler(_: (p1: URLSessionDataTask[], p2: URLSessionUploadTask[], p3: URLSessionDownloadTask[]) => void): void;
  invalidateAndCancel(): void;
  resetWithCompletionHandler(completionHandler: () => void): void;
  streamTaskWithHostNamePort(withHostName: string, port: number): URLSessionStreamTask;
  streamTaskWithNetService(with_: NetService): URLSessionStreamTask;
  uploadTaskWithRequestFromData(with_: URLRequest, from: Data): URLSessionUploadTask;
  uploadTaskWithRequestFromDataCompletionHandler(with_: URLRequest, from?: Data, completionHandler?: (p1: Data, p2: URLResponse, p3: Error) => void): URLSessionUploadTask;
  uploadTaskWithRequestFromFile(with_: URLRequest, fromFile: URL): URLSessionUploadTask;
  uploadTaskWithRequestFromFileCompletionHandler(with_: URLRequest, fromFile: URL, completionHandler?: (p1: Data, p2: URLResponse, p3: Error) => void): URLSessionUploadTask;
  uploadTaskWithStreamedRequest(withStreamedRequest: URLRequest): URLSessionUploadTask;
  webSocketTaskWithRequest(with_: URLRequest): URLSessionWebSocketTask;
  webSocketTaskWithURL(with_: URL): URLSessionWebSocketTask;
  webSocketTaskWithURLProtocols(with_: URL, protocols: string[]): URLSessionWebSocketTask;
}

export class URLSessionConfiguration extends NSObject {
  static backgroundSessionConfigurationWithIdentifier(withIdentifier: string): URLSessionConfiguration;
  HTTPAdditionalHeaders: Map<any, any>;
  setHTTPAdditionalHeaders(_: Map<any, any>);
  HTTPCookieAcceptPolicy: HTTPCookieStorage.HTTPCookie.AcceptPolicy;
  setHTTPCookieAcceptPolicy(_: HTTPCookieStorage.HTTPCookie.AcceptPolicy);
  HTTPCookieStorage: HTTPCookieStorage;
  setHTTPCookieStorage(_: HTTPCookieStorage);
  HTTPMaximumConnectionsPerHost: number;
  setHTTPMaximumConnectionsPerHost(_: number);
  HTTPShouldSetCookies: boolean;
  setHTTPShouldSetCookies(_: boolean);
  HTTPShouldUsePipelining: boolean;
  setHTTPShouldUsePipelining(_: boolean);
  TLSMaximumSupportedProtocol: SecProtocolTypes.SSLProtocol;
  setTLSMaximumSupportedProtocol(_: SecProtocolTypes.SSLProtocol);
  TLSMaximumSupportedProtocolVersion: SecProtocolTypes.tls_protocol_version_t;
  setTLSMaximumSupportedProtocolVersion(_: SecProtocolTypes.tls_protocol_version_t);
  TLSMinimumSupportedProtocol: SecProtocolTypes.SSLProtocol;
  setTLSMinimumSupportedProtocol(_: SecProtocolTypes.SSLProtocol);
  TLSMinimumSupportedProtocolVersion: SecProtocolTypes.tls_protocol_version_t;
  setTLSMinimumSupportedProtocolVersion(_: SecProtocolTypes.tls_protocol_version_t);
  URLCache: URLCache;
  setURLCache(_: URLCache);
  URLCredentialStorage: URLCredentialStorage;
  setURLCredentialStorage(_: URLCredentialStorage);
  allowsCellularAccess: boolean;
  setAllowsCellularAccess(_: boolean);
  allowsConstrainedNetworkAccess: boolean;
  setAllowsConstrainedNetworkAccess(_: boolean);
  allowsExpensiveNetworkAccess: boolean;
  setAllowsExpensiveNetworkAccess(_: boolean);
  connectionProxyDictionary: Map<any, any>;
  setConnectionProxyDictionary(_: Map<any, any>);
  isDiscretionary: boolean;
  setDiscretionary(_: boolean);
  identifier: string;
  networkServiceType: URLRequest.NetworkServiceType;
  setNetworkServiceType(_: URLRequest.NetworkServiceType);
  protocolClasses: typeof NSObject[];
  setProtocolClasses(_: typeof NSObject[]);
  requestCachePolicy: URLRequest.CachePolicy;
  setRequestCachePolicy(_: URLRequest.CachePolicy);
  sharedContainerIdentifier: string;
  setSharedContainerIdentifier(_: string);
  shouldUseExtendedBackgroundIdleMode: boolean;
  setShouldUseExtendedBackgroundIdleMode(_: boolean);
  timeoutIntervalForRequest: number;
  setTimeoutIntervalForRequest(_: number);
  timeoutIntervalForResource: number;
  setTimeoutIntervalForResource(_: number);
  waitsForConnectivity: boolean;
  setWaitsForConnectivity(_: boolean);
  static defaultSessionConfiguration: URLSessionConfiguration;
  static ephemeralSessionConfiguration: URLSessionConfiguration;
}

interface URLSessionDataDelegate {
  uRLSessionDataTaskDidReceiveResponseCompletionHandler(_: URLSession, dataTask: URLSessionDataTask, didReceive: URLResponse, completionHandler: (p1: URLSession.ResponseDisposition) => void): void;
  uRLSessionDataTaskDidBecomeDownloadTask(_: URLSession, dataTask: URLSessionDataTask, didBecome: URLSessionDownloadTask): void;
  uRLSessionDataTaskDidBecomeStreamTask(_: URLSession, dataTask: URLSessionDataTask, didBecome: URLSessionStreamTask): void;
  uRLSessionDataTaskDidReceiveData(_: URLSession, dataTask: URLSessionDataTask, didReceive: Data): void;
  uRLSessionDataTaskWillCacheResponseCompletionHandler(_: URLSession, dataTask: URLSessionDataTask, willCacheResponse: CachedURLResponse, completionHandler?: (p1: CachedURLResponse) => void): void;
}

export class URLSessionDataTask extends URLSessionTask {
}

interface URLSessionDelegate {
  uRLSessionDidBecomeInvalidWithError(_: URLSession, didBecomeInvalidWithError?: Error): void;
  uRLSessionDidReceiveChallengeCompletionHandler(_: URLSession, didReceive: URLAuthenticationChallenge, completionHandler?: (p1: URLSession.AuthChallengeDisposition, p2: URLCredential) => void): void;
}

interface URLSessionDownloadDelegate {
  uRLSessionDownloadTaskDidFinishDownloadingToURL(_: URLSession, downloadTask: URLSessionDownloadTask, didFinishDownloadingTo: URL): void;
  uRLSessionDownloadTaskDidWriteDataTotalBytesWrittenTotalBytesExpectedToWrite(_: URLSession, downloadTask: URLSessionDownloadTask, didWriteData: number, totalBytesWritten: number, totalBytesExpectedToWrite: number): void;
  uRLSessionDownloadTaskDidResumeAtOffsetExpectedTotalBytes(_: URLSession, downloadTask: URLSessionDownloadTask, didResumeAtOffset: number, expectedTotalBytes: number): void;
}

export class URLSessionDownloadTask extends URLSessionTask {
  cancelByProducingResumeData(byProducingResumeData?: (p1: Data) => void): void;
}

interface URLSessionStreamDelegate {
  uRLSessionReadClosedForStreamTask(_: URLSession, readClosedFor: URLSessionStreamTask): void;
  uRLSessionWriteClosedForStreamTask(_: URLSession, writeClosedFor: URLSessionStreamTask): void;
  uRLSessionBetterRouteDiscoveredForStreamTask(_: URLSession, betterRouteDiscoveredFor: URLSessionStreamTask): void;
  uRLSessionStreamTaskDidBecomeInputStreamOutputStream(_: URLSession, streamTask: URLSessionStreamTask, didBecome: InputStream, outputStream: OutputStream): void;
}

export class URLSessionStreamTask extends URLSessionTask {
  captureStreams(): void;
  closeRead(): void;
  closeWrite(): void;
  readDataOfMinLengthMaxLengthTimeoutCompletionHandler(ofMinLength: number, maxLength: number, timeout: number, completionHandler?: (p1: Data, p2: boolean, p3: Error) => void): void;
  startSecureConnection(): void;
  writeDataTimeoutCompletionHandler(_: Data, timeout: number, completionHandler?: (p1: Error) => void): void;
}

export class URLSessionTask extends NSObject {
  countOfBytesClientExpectsToReceive: number;
  setCountOfBytesClientExpectsToReceive(_: number);
  countOfBytesClientExpectsToSend: number;
  setCountOfBytesClientExpectsToSend(_: number);
  countOfBytesExpectedToReceive: number;
  countOfBytesExpectedToSend: number;
  countOfBytesReceived: number;
  countOfBytesSent: number;
  currentRequest: URLRequest;
  earliestBeginDate: Date;
  setEarliestBeginDate(_: Date);
  error: Error;
  originalRequest: URLRequest;
  priority: number;
  setPriority(_: number);
  response: URLResponse;
  state: URLSession.URLSessionTask.State;
  taskDescription: string;
  setTaskDescription(_: string);
  taskIdentifier: number;
  cancel(): void;
  resume(): void;
  suspend(): void;
}

interface URLSessionTaskDelegate {
  uRLSessionTaskWillBeginDelayedRequestCompletionHandler(_: URLSession, task: URLSessionTask, willBeginDelayedRequest: URLRequest, completionHandler?: (p1: URLSession.NSURLSessionDelayedRequestDisposition, p2: URLRequest) => void): void;
  uRLSessionTaskIsWaitingForConnectivity(_: URLSession, taskIsWaitingForConnectivity: URLSessionTask): void;
  uRLSessionTaskWillPerformHTTPRedirectionNewRequestCompletionHandler(_: URLSession, task: URLSessionTask, willPerformHTTPRedirection: HTTPURLResponse, newRequest: URLRequest, completionHandler?: (p1: URLRequest) => void): void;
  uRLSessionTaskDidReceiveChallengeCompletionHandler(_: URLSession, task: URLSessionTask, didReceive: URLAuthenticationChallenge, completionHandler?: (p1: URLSession.AuthChallengeDisposition, p2: URLCredential) => void): void;
  uRLSessionTaskNeedNewBodyStream(_: URLSession, task: URLSessionTask, needNewBodyStream?: (p1: InputStream) => void): void;
  uRLSessionTaskDidSendBodyDataTotalBytesSentTotalBytesExpectedToSend(_: URLSession, task: URLSessionTask, didSendBodyData: number, totalBytesSent: number, totalBytesExpectedToSend: number): void;
  uRLSessionTaskDidFinishCollectingMetrics(_: URLSession, task: URLSessionTask, didFinishCollecting: URLSessionTaskMetrics): void;
  uRLSessionTaskDidCompleteWithError(_: URLSession, task: URLSessionTask, didCompleteWithError?: Error): void;
}

export class URLSessionTaskMetrics extends NSObject {
  redirectCount: number;
  taskInterval: DateInterval;
  transactionMetrics: URLSessionTaskTransactionMetrics[];
}

export class URLSessionTaskTransactionMetrics extends NSObject {
  isCellular: boolean;
  connectEndDate: Date;
  connectStartDate: Date;
  isConstrained: boolean;
  countOfRequestBodyBytesBeforeEncoding: number;
  countOfRequestBodyBytesSent: number;
  countOfRequestHeaderBytesSent: number;
  countOfResponseBodyBytesAfterDecoding: number;
  countOfResponseBodyBytesReceived: number;
  countOfResponseHeaderBytesReceived: number;
  domainLookupEndDate: Date;
  domainLookupStartDate: Date;
  isExpensive: boolean;
  fetchStartDate: Date;
  localAddress: string;
  localPort: number;
  isMultipath: boolean;
  negotiatedTLSCipherSuite: number;
  negotiatedTLSProtocolVersion: number;
  networkProtocolName: string;
  isProxyConnection: boolean;
  remoteAddress: string;
  remotePort: number;
  request: URLRequest;
  requestEndDate: Date;
  requestStartDate: Date;
  resourceFetchType: URLSession.URLSessionTaskMetrics.ResourceFetchType;
  response: URLResponse;
  responseEndDate: Date;
  responseStartDate: Date;
  isReusedConnection: boolean;
  secureConnectionEndDate: Date;
  secureConnectionStartDate: Date;
}

export class URLSessionUploadTask extends URLSessionDataTask {
}

interface URLSessionWebSocketDelegate {
  uRLSessionWebSocketTaskDidOpenWithProtocol(_: URLSession, webSocketTask: URLSessionWebSocketTask, didOpenWithProtocol?: string): void;
  uRLSessionWebSocketTaskDidCloseWithCodeReason(_: URLSession, webSocketTask: URLSessionWebSocketTask, didCloseWith: URLSession.URLSessionWebSocketTask.CloseCode, reason?: Data): void;
}

export class URLSessionWebSocketTask extends URLSessionTask {
  closeCode: URLSession.URLSessionWebSocketTask.CloseCode;
  closeReason: Data;
  maximumMessageSize: number;
  setMaximumMessageSize(_: number);
  cancelWithCloseCodeReason(with_: URLSession.URLSessionWebSocketTask.CloseCode, reason?: Data): void;
  receiveMessageWithCompletionHandler(_?: (p1: NSURLSessionWebSocketMessage, p2: Error) => void): void;
  sendMessageCompletionHandler(_: NSURLSessionWebSocketMessage, completionHandler?: (p1: Error) => void): void;
  sendPingWithPongReceiveHandler(pongReceiveHandler?: (p1: Error) => void): void;
}

export class UUID extends NSObject {
  static uUID(): UUID;
  UUIDString: string;
  getUUIDBytes(_: number): void;
  static initWithUUIDBytes(_?: number): UUID;
  static initWithUUIDString(_: string): UUID;
}

export class UndoManager extends NSObject {
  canRedo: boolean;
  canUndo: boolean;
  groupingLevel: number;
  groupsByEvent: boolean;
  setGroupsByEvent(_: boolean);
  levelsOfUndo: number;
  setLevelsOfUndo(_: number);
  redoActionIsDiscardable: boolean;
  redoActionName: string;
  redoMenuItemTitle: string;
  isRedoing: boolean;
  runLoopModes: string[];
  setRunLoopModes(_: string[]);
  undoActionIsDiscardable: boolean;
  undoActionName: string;
  undoMenuItemTitle: string;
  isUndoRegistrationEnabled: boolean;
  isUndoing: boolean;
  beginUndoGrouping(): void;
  disableUndoRegistration(): void;
  enableUndoRegistration(): void;
  endUndoGrouping(): void;
  prepareWithInvocationTarget(withInvocationTarget: any): any;
  redo(): void;
  redoMenuTitleForUndoActionName(forUndoActionName: string): string;
  registerUndoWithTargetSelectorObject(withTarget: any, selector: string, object_?: any): void;
  removeAllActions(): void;
  removeAllActionsWithTarget(withTarget: any): void;
  setActionIsDiscardable(_: boolean): void;
  setActionName(_: string): void;
  undo(): void;
  undoMenuTitleForUndoActionName(forUndoActionName: string): string;
  undoNestedGroup(): void;
}

export class Unit extends NSObject {
  symbol: string;
  static initWithSymbol(_: string): Unit;
}

export class UnitAcceleration extends Dimension {
  //  static baseUnit(): UnitAcceleration;
  static gravity: UnitAcceleration;
  static metersPerSecondSquared: UnitAcceleration;
}

export class UnitAngle extends Dimension {
  //  static baseUnit(): UnitAngle;
  static arcMinutes: UnitAngle;
  static arcSeconds: UnitAngle;
  static degrees: UnitAngle;
  static gradians: UnitAngle;
  static radians: UnitAngle;
  static revolutions: UnitAngle;
}

export class UnitArea extends Dimension {
  //  static baseUnit(): UnitArea;
  static acres: UnitArea;
  static ares: UnitArea;
  static hectares: UnitArea;
  static squareCentimeters: UnitArea;
  static squareFeet: UnitArea;
  static squareInches: UnitArea;
  static squareKilometers: UnitArea;
  static squareMegameters: UnitArea;
  static squareMeters: UnitArea;
  static squareMicrometers: UnitArea;
  static squareMiles: UnitArea;
  static squareMillimeters: UnitArea;
  static squareNanometers: UnitArea;
  static squareYards: UnitArea;
}

export class UnitConcentrationMass extends Dimension {
  //  static baseUnit(): UnitConcentrationMass;
  static millimolesPerLiterWithGramsPerMole(withGramsPerMole: number): UnitConcentrationMass;
  static gramsPerLiter: UnitConcentrationMass;
  static milligramsPerDeciliter: UnitConcentrationMass;
}

export class UnitConverter extends NSObject {
  baseUnitValueFromValue(fromValue: number): number;
  valueFromBaseUnitValue(fromBaseUnitValue: number): number;
}

export class UnitConverterLinear extends UnitConverter {
  coefficient: number;
  constant: number;
  static initWithCoefficient(_: number): UnitConverterLinear;
  static initWithCoefficientConstant(_: number, constant: number): UnitConverterLinear;
}

export class UnitDispersion extends Dimension {
  //  static baseUnit(): UnitDispersion;
  static partsPerMillion: UnitDispersion;
}

export class UnitDuration extends Dimension {
  //  static baseUnit(): UnitDuration;
  static hours: UnitDuration;
  static microseconds: UnitDuration;
  static milliseconds: UnitDuration;
  static minutes: UnitDuration;
  static nanoseconds: UnitDuration;
  static picoseconds: UnitDuration;
  static seconds: UnitDuration;
}

export class UnitElectricCharge extends Dimension {
  //  static baseUnit(): UnitElectricCharge;
  static ampereHours: UnitElectricCharge;
  static coulombs: UnitElectricCharge;
  static kiloampereHours: UnitElectricCharge;
  static megaampereHours: UnitElectricCharge;
  static microampereHours: UnitElectricCharge;
  static milliampereHours: UnitElectricCharge;
}

export class UnitElectricCurrent extends Dimension {
  //  static baseUnit(): UnitElectricCurrent;
  static amperes: UnitElectricCurrent;
  static kiloamperes: UnitElectricCurrent;
  static megaamperes: UnitElectricCurrent;
  static microamperes: UnitElectricCurrent;
  static milliamperes: UnitElectricCurrent;
}

export class UnitElectricPotentialDifference extends Dimension {
  //  static baseUnit(): UnitElectricPotentialDifference;
  static kilovolts: UnitElectricPotentialDifference;
  static megavolts: UnitElectricPotentialDifference;
  static microvolts: UnitElectricPotentialDifference;
  static millivolts: UnitElectricPotentialDifference;
  static volts: UnitElectricPotentialDifference;
}

export class UnitElectricResistance extends Dimension {
  //  static baseUnit(): UnitElectricResistance;
  static kiloohms: UnitElectricResistance;
  static megaohms: UnitElectricResistance;
  static microohms: UnitElectricResistance;
  static milliohms: UnitElectricResistance;
  static ohms: UnitElectricResistance;
}

export class UnitEnergy extends Dimension {
  //  static baseUnit(): UnitEnergy;
  static calories: UnitEnergy;
  static joules: UnitEnergy;
  static kilocalories: UnitEnergy;
  static kilojoules: UnitEnergy;
  static kilowattHours: UnitEnergy;
}

export class UnitFrequency extends Dimension {
  //  static baseUnit(): UnitFrequency;
  static framesPerSecond: UnitFrequency;
  static gigahertz: UnitFrequency;
  static hertz: UnitFrequency;
  static kilohertz: UnitFrequency;
  static megahertz: UnitFrequency;
  static microhertz: UnitFrequency;
  static millihertz: UnitFrequency;
  static nanohertz: UnitFrequency;
  static terahertz: UnitFrequency;
}

export class UnitFuelEfficiency extends Dimension {
  //  static baseUnit(): UnitFuelEfficiency;
  static litersPer100Kilometers: UnitFuelEfficiency;
  static milesPerGallon: UnitFuelEfficiency;
  static milesPerImperialGallon: UnitFuelEfficiency;
}

export class UnitIlluminance extends Dimension {
  //  static baseUnit(): UnitIlluminance;
  static lux: UnitIlluminance;
}

export class UnitLength extends Dimension {
  //  static baseUnit(): UnitLength;
  static astronomicalUnits: UnitLength;
  static centimeters: UnitLength;
  static decameters: UnitLength;
  static decimeters: UnitLength;
  static fathoms: UnitLength;
  static feet: UnitLength;
  static furlongs: UnitLength;
  static hectometers: UnitLength;
  static inches: UnitLength;
  static kilometers: UnitLength;
  static lightyears: UnitLength;
  static megameters: UnitLength;
  static meters: UnitLength;
  static micrometers: UnitLength;
  static miles: UnitLength;
  static millimeters: UnitLength;
  static nanometers: UnitLength;
  static nauticalMiles: UnitLength;
  static parsecs: UnitLength;
  static picometers: UnitLength;
  static scandinavianMiles: UnitLength;
  static yards: UnitLength;
}

export class UnitMass extends Dimension {
  //  static baseUnit(): UnitMass;
  static carats: UnitMass;
  static centigrams: UnitMass;
  static decigrams: UnitMass;
  static grams: UnitMass;
  static kilograms: UnitMass;
  static metricTons: UnitMass;
  static micrograms: UnitMass;
  static milligrams: UnitMass;
  static nanograms: UnitMass;
  static ounces: UnitMass;
  static ouncesTroy: UnitMass;
  static picograms: UnitMass;
  static poundsMass: UnitMass;
  static shortTons: UnitMass;
  static slugs: UnitMass;
  static stones: UnitMass;
}

export class UnitPower extends Dimension {
  //  static baseUnit(): UnitPower;
  static femtowatts: UnitPower;
  static gigawatts: UnitPower;
  static horsepower: UnitPower;
  static kilowatts: UnitPower;
  static megawatts: UnitPower;
  static microwatts: UnitPower;
  static milliwatts: UnitPower;
  static nanowatts: UnitPower;
  static picowatts: UnitPower;
  static terawatts: UnitPower;
  static watts: UnitPower;
}

export class UnitPressure extends Dimension {
  //  static baseUnit(): UnitPressure;
  static bars: UnitPressure;
  static gigapascals: UnitPressure;
  static hectopascals: UnitPressure;
  static inchesOfMercury: UnitPressure;
  static kilopascals: UnitPressure;
  static megapascals: UnitPressure;
  static millibars: UnitPressure;
  static millimetersOfMercury: UnitPressure;
  static newtonsPerMetersSquared: UnitPressure;
  static poundsForcePerSquareInch: UnitPressure;
}

export class UnitSpeed extends Dimension {
  //  static baseUnit(): UnitSpeed;
  static kilometersPerHour: UnitSpeed;
  static knots: UnitSpeed;
  static metersPerSecond: UnitSpeed;
  static milesPerHour: UnitSpeed;
}

export class UnitTemperature extends Dimension {
  //  static baseUnit(): UnitTemperature;
  static celsius: UnitTemperature;
  static fahrenheit: UnitTemperature;
  static kelvin: UnitTemperature;
}

export class UnitVolume extends Dimension {
  //  static baseUnit(): UnitVolume;
  static acreFeet: UnitVolume;
  static bushels: UnitVolume;
  static centiliters: UnitVolume;
  static cubicCentimeters: UnitVolume;
  static cubicDecimeters: UnitVolume;
  static cubicFeet: UnitVolume;
  static cubicInches: UnitVolume;
  static cubicKilometers: UnitVolume;
  static cubicMeters: UnitVolume;
  static cubicMiles: UnitVolume;
  static cubicMillimeters: UnitVolume;
  static cubicYards: UnitVolume;
  static cups: UnitVolume;
  static deciliters: UnitVolume;
  static fluidOunces: UnitVolume;
  static gallons: UnitVolume;
  static imperialFluidOunces: UnitVolume;
  static imperialGallons: UnitVolume;
  static imperialPints: UnitVolume;
  static imperialQuarts: UnitVolume;
  static imperialTablespoons: UnitVolume;
  static imperialTeaspoons: UnitVolume;
  static kiloliters: UnitVolume;
  static liters: UnitVolume;
  static megaliters: UnitVolume;
  static metricCups: UnitVolume;
  static milliliters: UnitVolume;
  static pints: UnitVolume;
  static quarts: UnitVolume;
  static tablespoons: UnitVolume;
  static teaspoons: UnitVolume;
}

export class UserDefaults extends NSObject {
  static resetStandardUserDefaults(): void;
  volatileDomainNames: string[];
  static standardUserDefaults: UserDefaults;
  uRLForKey(forKey: string): URL;
  addSuiteNamed(named: string): void;
  arrayForKey(forKey: string): any[];
  boolForKey(forKey: string): boolean;
  dataForKey(forKey: string): Data;
  dictionaryForKey(forKey: string): Map<string, any>;
  dictionaryRepresentation(): Map<string, any>;
  doubleForKey(forKey: string): number;
  floatForKey(forKey: string): number;
  static initWithSuiteName(_?: string): UserDefaults;
  integerForKey(forKey: string): number;
  objectForKey(forKey: string): any;
  objectIsForcedForKey(forKey: string): boolean;
  objectIsForcedForKeyInDomain(forKey: string, inDomain: string): boolean;
  persistentDomainForName(forName: string): Map<string, any>;
  registerDefaults(defaults: Map<string, any>): void;
  removeObjectForKey(forKey: string): void;
  removePersistentDomainForName(forName: string): void;
  removeSuiteNamed(named: string): void;
  removeVolatileDomainForName(forName: string): void;
  setBoolForKey(_: boolean, forKey: string): void;
  setDoubleForKey(_: number, forKey: string): void;
  setFloatForKey(_: number, forKey: string): void;
  setIntegerForKey(_: number, forKey: string): void;
  setObjectForKey(_?: any, forKey?: string): void;
  setPersistentDomainForName(_: Map<string, any>, forName: string): void;
  setURLForKey(_?: URL, forKey?: string): void;
  setVolatileDomainForName(_: Map<string, any>, forName: string): void;
  stringArrayForKey(forKey: string): string[];
  synchronize(): boolean;
  volatileDomainForName(forName: string): Map<string, any>;
}

export class ValueTransformer extends NSObject {
  static allowsReverseTransformation(): boolean;
  static setValueTransformerForName(_?: ValueTransformer, forName?: string): void;
  static transformedValueClass(): typeof NSObject;
  static valueTransformerNames(): string[];
  reverseTransformedValue(_?: any): any;
  transformedValue(_?: any): any;
}

export class XMLDTD extends XMLNode {
  static predefinedEntityDeclarationForName(forName: string): XMLDTDNode;
  publicID: string;
  setPublicID(_: string);
  systemID: string;
  setSystemID(_: string);
  addChild(_: XMLNode): void;
  attributeDeclarationForNameElementName(forName: string, elementName: string): XMLDTDNode;
  elementDeclarationForName(forName: string): XMLDTDNode;
  entityDeclarationForName(forName: string): XMLDTDNode;
  static initWithContentsOfURLOptions(options: URL, error: XMLNode.Options): XMLDTD;
  static initWithDataOptions(options: Data, error: XMLNode.Options): XMLDTD;
  insertChildAtIndex(_: XMLNode, at: number): void;
  insertChildrenAtIndex(_: XMLNode[], at: number): void;
  notationDeclarationForName(forName: string): XMLDTDNode;
  removeChildAtIndex(at: number): void;
  replaceChildAtIndexWithNode(at: number, with_: XMLNode): void;
  setChildren(_?: XMLNode[]): void;
}

export class XMLDTDNode extends XMLNode {
  DTDKind: XMLDTDNode.DTDKind;
  setDTDKind(_: XMLDTDNode.DTDKind);
  isExternal: boolean;
  notationName: string;
  setNotationName(_: string);
  publicID: string;
  setPublicID(_: string);
  systemID: string;
  setSystemID(_: string);
  static initWithXMLString(_: string): XMLDTDNode;
}

export class XMLDocument extends XMLNode {
  static replacementClassForClass(for_: typeof NSObject): typeof NSObject;
  DTD: XMLDTD;
  setDTD(_: XMLDTD);
  MIMEType: string;
  setMIMEType(_: string);
  XMLData: Data;
  characterEncoding: string;
  setCharacterEncoding(_: string);
  documentContentKind: XMLDocument.ContentKind;
  setDocumentContentKind(_: XMLDocument.ContentKind);
  isStandalone: boolean;
  setStandalone(_: boolean);
  //   version: string;
  setVersion(_: string);
  xMLDataWithOptions(options: XMLNode.Options): Data;
  addChild(_: XMLNode): void;
  static initWithContentsOfURLOptions(options: URL, error: XMLNode.Options): XMLDocument;
  static initWithDataOptions(options: Data, error: XMLNode.Options): XMLDocument;
  static initWithRootElement(_?: XMLElement): XMLDocument;
  static initWithXMLStringOptions(options: string, error: XMLNode.Options): XMLDocument;
  insertChildAtIndex(_: XMLNode, at: number): void;
  insertChildrenAtIndex(_: XMLNode[], at: number): void;
  objectByApplyingXSLTArguments(arguments_: Data, error?: Map<string, string>): any;
  objectByApplyingXSLTAtURLArguments(arguments_: URL, error?: Map<string, string>): any;
  objectByApplyingXSLTStringArguments(arguments_: string, error?: Map<string, string>): any;
  removeChildAtIndex(at: number): void;
  replaceChildAtIndexWithNode(at: number, with_: XMLNode): void;
  rootElement(): XMLElement;
  setChildren(_?: XMLNode[]): void;
  setRootElement(_: XMLElement): void;
  validateAndReturnError(): boolean;
}

export class XMLElement extends XMLNode {
  attributes: XMLNode[];
  setAttributes(_: XMLNode[]);
  namespaces: XMLNode[];
  setNamespaces(_: XMLNode[]);
  addAttribute(_: XMLNode): void;
  addChild(_: XMLNode): void;
  addNamespace(_: XMLNode): void;
  attributeForLocalNameURI(forLocalName: string, uri?: string): XMLNode;
  attributeForName(forName: string): XMLNode;
  elementsForLocalNameURI(forLocalName: string, uri?: string): XMLElement[];
  elementsForName(forName: string): XMLElement[];
  static initWithName(_: string): XMLElement;
  static initWithNameURI(_: string, URI?: string): XMLElement;
  static initWithNameStringValue(_: string, stringValue?: string): XMLElement;
  static initWithXMLString(error: string): XMLElement;
  insertChildAtIndex(_: XMLNode, at: number): void;
  insertChildrenAtIndex(_: XMLNode[], at: number): void;
  namespaceForPrefix(forPrefix: string): XMLNode;
  normalizeAdjacentTextNodesPreservingCDATA(_: boolean): void;
  removeAttributeForName(forName: string): void;
  removeChildAtIndex(at: number): void;
  removeNamespaceForPrefix(forPrefix: string): void;
  replaceChildAtIndexWithNode(at: number, with_: XMLNode): void;
  resolveNamespaceForName(forName: string): XMLNode;
  resolvePrefixForNamespaceURI(forNamespaceURI: string): string;
  setAttributesAsDictionary(_: Map<any, any>): void;
  setAttributesWithDictionary(_: Map<string, string>): void;
  setChildren(_?: XMLNode[]): void;
}

export class XMLNode extends NSObject {
  static dTDNodeWithXMLString(withXMLString: string): any;
  static attributeWithNameURIStringValue(withName: string, uri: string, stringValue: string): any;
  static attributeWithNameStringValue(withName: string, stringValue: string): any;
  static commentWithStringValue(withStringValue: string): any;
  static document(): any;
  static documentWithRootElement(withRootElement: XMLElement): any;
  static elementWithName(withName: string): any;
  static elementWithNameURI(withName: string, uri: string): any;
  static elementWithNameChildrenAttributes(withName: string, children?: XMLNode[], attributes?: XMLNode[]): any;
  static elementWithNameStringValue(withName: string, stringValue: string): any;
  //  static localNameForName(forName: string): string;
  static namespaceWithNameStringValue(withName: string, stringValue: string): any;
  static predefinedNamespaceForPrefix(forPrefix: string): XMLNode;
  //  static prefixForName(forName: string): string;
  static processingInstructionWithNameStringValue(withName: string, stringValue: string): any;
  static textWithStringValue(withStringValue: string): any;
  URI: string;
  setURI(_: string);
  XMLString: string;
  XPath: string;
  childCount: number;
  children: XMLNode[];
  index: number;
  kind: XMLNode.Kind;
  level: number;
  localName: string;
  name: string;
  setName(_: string);
  nextNode: XMLNode;
  nextSibling: XMLNode;
  objectValue: any;
  setObjectValue(_: any);
  parent: XMLNode;
  prefix: string;
  previousNode: XMLNode;
  previousSibling: XMLNode;
  rootDocument: XMLDocument;
  stringValue: string;
  setStringValue(_: string);
  xMLStringWithOptions(options: XMLNode.Options): string;
  canonicalXMLStringPreservingComments(_: boolean): string;
  childAtIndex(at: number): XMLNode;
  detach(): void;
  static initWithKind(_: XMLNode.Kind): XMLNode;
  static initWithKindOptions(_: XMLNode.Kind, options: XMLNode.Options): XMLNode;
  nodesForXPath(error: string): XMLNode[];
  objectsForXQueryConstants(constants: string, error?: Map<string, any>): any[];
  objectsForXQuery(error: string): any[];
  setStringValueResolvingEntities(_: string, resolvingEntities: boolean): void;
}

export class XMLParser extends NSObject {
  allowedExternalEntityURLs: Set<any>;
  setAllowedExternalEntityURLs(_: Set<any>);
  columnNumber: number;
  delegate: any;
  setDelegate(_: any);
  externalEntityResolvingPolicy: XMLParser.ExternalEntityResolvingPolicy;
  setExternalEntityResolvingPolicy(_: XMLParser.ExternalEntityResolvingPolicy);
  lineNumber: number;
  parserError: Error;
  publicID: string;
  shouldProcessNamespaces: boolean;
  setShouldProcessNamespaces(_: boolean);
  shouldReportNamespacePrefixes: boolean;
  setShouldReportNamespacePrefixes(_: boolean);
  shouldResolveExternalEntities: boolean;
  setShouldResolveExternalEntities(_: boolean);
  systemID: string;
  abortParsing(): void;
  static initWithContentsOfURL(_: URL): XMLParser;
  static initWithData(_: Data): XMLParser;
  static initWithStream(_: InputStream): XMLParser;
  parse(): boolean;
}

interface XMLParserDelegate {
  parserFoundNotationDeclarationWithNamePublicIDSystemID(_: XMLParser, foundNotationDeclarationWithName: string, publicID?: string, systemID?: string): void;
  parserFoundUnparsedEntityDeclarationWithNamePublicIDSystemIDNotationName(_: XMLParser, foundUnparsedEntityDeclarationWithName: string, publicID?: string, systemID?: string, notationName?: string): void;
  parserFoundAttributeDeclarationWithNameForElementTypeDefaultValue(_: XMLParser, foundAttributeDeclarationWithName: string, forElement: string, type?: string, defaultValue?: string): void;
  parserFoundElementDeclarationWithNameModel(_: XMLParser, foundElementDeclarationWithName: string, model: string): void;
  parserFoundInternalEntityDeclarationWithNameValue(_: XMLParser, foundInternalEntityDeclarationWithName: string, value?: string): void;
  parserFoundExternalEntityDeclarationWithNamePublicIDSystemID(_: XMLParser, foundExternalEntityDeclarationWithName: string, publicID?: string, systemID?: string): void;
  parserDidStartElementNamespaceURIQualifiedNameAttributes(_: XMLParser, didStartElement: string, namespaceURI?: string, qualifiedName?: string, attributes?: Map<string, string>): void;
  parserDidEndElementNamespaceURIQualifiedName(_: XMLParser, didEndElement: string, namespaceURI?: string, qualifiedName?: string): void;
  parserDidStartMappingPrefixToURI(_: XMLParser, didStartMappingPrefix: string, toURI: string): void;
  parserDidEndMappingPrefix(_: XMLParser, didEndMappingPrefix: string): void;
  parserFoundCharacters(_: XMLParser, foundCharacters: string): void;
  parserFoundIgnorableWhitespace(_: XMLParser, foundIgnorableWhitespace: string): void;
  parserFoundProcessingInstructionWithTargetData(_: XMLParser, foundProcessingInstructionWithTarget: string, data?: string): void;
  parserFoundComment(_: XMLParser, foundComment: string): void;
  parserFoundCDATA(_: XMLParser, foundCDATA: Data): void;
  parserResolveExternalEntityNameSystemID(_: XMLParser, resolveExternalEntityName: string, systemID?: string): Data;
  parserParseErrorOccurred(_: XMLParser, parseErrorOccurred: Error): void;
  parserValidationErrorOccurred(_: XMLParser, validationErrorOccurred: Error): void;
  parserDidEndDocument(_: XMLParser): void;
  parserDidStartDocument(_: XMLParser): void;
}

interface NSObjectProtocol {
  debugDescription?: string;
  description: string;
  hash: number;
  superclass: typeof NSObject;
  isProxy: boolean;
  conformsToProtocol(to: any /* Protocol */): boolean;
  isEqual(_: any): boolean;
  isKindOfClass(_: typeof NSObject): boolean;
  isMemberOfClass(_: typeof NSObject): boolean;
  performSelector(_: string): any;
  performSelectorWithObject(_: string, withObject: any): any;
  performSelectorWithObjectWithObject(_: string, withObject: any, withObject2: any): any;
  respondsToSelector(_: string): boolean;
  retainCount(): number;
  self(): NSObjectProtocol;
}

// export function _objc_msgForward(): void;

// export function _objc_msgForward_stret(): void;

// export function _objc_realizeClassFromSwift(cls: typeof NSObject, previously: any): typeof NSObject;

// export function _objc_resolve_categories_for_class(cls: typeof NSObject): void;

// export function class_addIvar(cls: typeof NSObject, name: string | any, size: number, alignment: number, types: string | any): boolean;

// export function class_addMethod(cls: typeof NSObject, name: string, imp: () => void, types: string | any): boolean;

// export function class_addMethods(p1: typeof NSObject, p2: any): void;

// export function class_addProperty(cls: typeof NSObject, name: string | any, attributes: objc_property_attribute_t, attributeCount: number): boolean;

// export function class_addProtocol(cls: typeof NSObject, protocol: any /* Protocol */): boolean;

// export function class_conformsToProtocol(cls: typeof NSObject, protocol: any /* Protocol */): boolean;

// export function class_copyIvarList(cls: typeof NSObject, outCount: number): any;

// export function class_copyMethodList(cls: typeof NSObject, outCount: number): any;

// export function class_copyPropertyList(cls: typeof NSObject, outCount: number): any;

// export function class_copyProtocolList(cls: typeof NSObject, outCount: number): any /* Protocol */;

// export function class_createInstance(cls: typeof NSObject, extraBytes: number): any;

// export function class_createInstanceFunction(cls: typeof NSObject, extraBytes: number): any;

// export function class_getClassMethod(cls: typeof NSObject, name: string): any;

// export function class_getClassVariable(cls: typeof NSObject, name: string | any): any;

// export function class_getImageName(cls: typeof NSObject): string;

// export function class_getInstanceMethod(cls: typeof NSObject, name: string): any;

// export function class_getInstanceSize(cls: typeof NSObject): number;

// export function class_getInstanceVariable(cls: typeof NSObject, name: string | any): any;

// export function class_getIvarLayout(cls: typeof NSObject): string;

// export function class_getMethodImplementation(cls: typeof NSObject, name: string): () => void;

// export function class_getMethodImplementation_stret(cls: typeof NSObject, name: string): () => void;

// export function class_getName(cls: typeof NSObject): string;

// export function class_getProperty(cls: typeof NSObject, name: string | any): any;

// export function class_getSuperclass(cls: typeof NSObject): typeof NSObject;

// export function class_getVersion(cls: typeof NSObject): number;

// export function class_getWeakIvarLayout(cls: typeof NSObject): string;

// export function class_isMetaClass(cls: typeof NSObject): boolean;

// export function class_nextMethodList(p1: typeof NSObject, p2: any): any;

// export function class_poseAs(imposter: typeof NSObject, original: typeof NSObject): typeof NSObject;

// export function class_removeMethods(p1: typeof NSObject, p2: any): void;

// export function class_replaceMethod(cls: typeof NSObject, name: string, imp: () => void, types: string | any): () => void;

// export function class_replaceProperty(cls: typeof NSObject, name: string | any, attributes: objc_property_attribute_t, attributeCount: number): void;

// export function class_respondsToSelector(cls: typeof NSObject, sel: string): boolean;

// export function class_setIvarLayout(cls: typeof NSObject, layout: string | any): void;

// export function class_setVersion(cls: typeof NSObject, version: number): void;

// export function class_setWeakIvarLayout(cls: typeof NSObject, layout: string | any): void;

// export function imp_getBlock(anImp: () => void): any;

// export function imp_implementationWithBlock(block: any): () => void;

// export function imp_removeBlock(anImp: () => void): boolean;

// export function ivar_getName(v: any): string;

// export function ivar_getOffset(v: any): number;

// export function ivar_getTypeEncoding(v: any): string;

// export function method_copyArgumentType(m: any, index: number): string;

// export function method_copyReturnType(m: any): string;

// export function method_exchangeImplementations(m1: any, m2: any): void;

// export function method_getArgumentInfo(m: any, arg: number, type: string, offset: number): number;

// export function method_getArgumentType(m: any, index: number, dst: string | any, dst_len: number): void;

// export function method_getDescription(m: any): objc_method_description;

// export function method_getImplementation(m: any): () => void;

// export function method_getName(m: any): string;

// export function method_getNumberOfArguments(m: any): number;

// export function method_getReturnType(m: any, dst: string | any, dst_len: number): void;

// export function method_getSizeOfArguments(m: any): number;

// export function method_getTypeEncoding(m: any): string;

// export function method_invoke(): void;

// export function method_invoke_stret(): void;

// export function method_setImplementation(m: any, imp: () => void): () => void;

// export function objc_addClass(myClass: typeof NSObject): void;

// export function objc_addExceptionHandler(fn: (p1: any, p2: any) => void, context: any): number;

// export function objc_addLoadImageFunc(func: (p1: mach_header) => void): void;

// export function objc_allocateClassPair(superclass: typeof NSObject, name: string | any, extraBytes: number): typeof NSObject;

// export function objc_allocateProtocol(name: string | any): any /* Protocol */;

// export function objc_begin_catch(exc_buf: any): any;

// export function objc_constructInstance(cls: typeof NSObject, bytes: any): any;

// export function objc_copyClassList(outCount: number): typeof NSObject;

// export function objc_copyClassNamesForImage(image: string | any, outCount: number): string;

// export function objc_copyImageNames(outCount: number): string;

// export function objc_copyProtocolList(outCount: number): any /* Protocol */;

// export function objc_destructInstance(obj: any): any;

// export function objc_disposeClassPair(cls: typeof NSObject): void;

// export function objc_duplicateClass(original: typeof NSObject, name: string | any, extraBytes: number): typeof NSObject;

// export function objc_end_catch(): void;

// export function objc_enumerationMutation(obj: any): void;

// export function objc_exception_rethrow(): void;

// export function objc_exception_throw(exception: any): void;

// export function objc_getAssociatedObject(object_: any, key: any): any;

// export function objc_getClass(name: string | any): any;

// export function objc_getClassList(buffer: typeof NSObject, bufferCount: number): number;

// export function objc_getClasses(): any;

// export function objc_getFutureClass(name: string | any): typeof NSObject;

// export function objc_getMetaClass(name: string | any): any;

// export function objc_getOrigClass(name: string | any): typeof NSObject;

// export function objc_getProtocol(name: string | any): any /* Protocol */;

// export function objc_getRequiredClass(name: string | any): typeof NSObject;

// export function objc_loadModule(moduleName: string | any, class_callback: (p1: typeof NSObject, p2: any) => void, errorCode: number): number;

// export function objc_loadModules(modlist: string, errStream: any, class_callback: (p1: typeof NSObject, p2: any) => void, hdr_addr: mach_header, debug_file: string | any): number;

// export function objc_loadWeak(location: any): any;

// export function objc_lookUpClass(name: string | any): typeof NSObject;

// export function objc_msgSend(): void;

// export function objc_msgSendSuper(): void;

// export function objc_msgSendSuper_stret(): void;

// export function objc_msgSend_fp2ret(): void;

// export function objc_msgSend_fpret(): void;

// export function objc_msgSend_stret(): void;

// export function objc_msgSendv(self: any, op: string, arg_size: number, arg_frame: any): any;

// export function objc_msgSendv_stret(stretAddr: any, self: any, op: string, arg_size: number, arg_frame: any): void;

// export function objc_registerClassPair(cls: typeof NSObject): void;

// export function objc_registerProtocol(proto: any /* Protocol */): void;

// export function objc_removeAssociatedObjects(object_: any): void;

// export function objc_removeExceptionHandler(token: number): void;

// export function objc_retainedObject(obj: any): any;

// export function objc_setAssociatedObject(object_: any, key: any, value: any, policy: runtime.objc_AssociationPolicy): void;

// export function objc_setClassHandler(p1: (p1: string) => number): void;

// export function objc_setEnumerationMutationHandler(handler: (p1: any) => void): void;

// export function objc_setExceptionMatcher(fn: (p1: typeof NSObject, p2: any) => number): (p1: typeof NSObject, p2: any) => number;

// export function objc_setExceptionPreprocessor(fn: (p1: any) => any): (p1: any) => any;

// export function objc_setForwardHandler(fwd: any, fwd_stret: any): void;

// export function objc_setHook_getClass(newValue: (p1: string, p2: typeof NSObject) => boolean, outOldValue: (p1: string, p2: typeof NSObject) => boolean): void;

// export function objc_setHook_getImageName(newValue: (p1: typeof NSObject, p2: string) => boolean, outOldValue: (p1: typeof NSObject, p2: string) => boolean): void;

// export function objc_setHook_setAssociatedObject(newValue: (p1: any, p2: any, p3: any, p4: runtime.objc_AssociationPolicy) => void, outOldValue: (p1: any, p2: any, p3: any, p4: runtime.objc_AssociationPolicy) => void): void;

// export function objc_setMultithreaded(flag: boolean): void;

// export function objc_setUncaughtExceptionHandler(fn: (p1: any) => void): (p1: any) => void;

// export function objc_storeWeak(location: any, obj: any): any;

// export function objc_sync_enter(obj: any): number;

// export function objc_sync_exit(obj: any): number;

// export function objc_terminate(): void;

// export function objc_unloadModules(errorStream: any, unloadCallback: (p1: typeof NSObject, p2: any) => void): number;

// export function objc_unretainedObject(obj: any): any;

// export function objc_unretainedPointer(obj: any): any;

// export function object_copy(obj: any, size: number): any;

// export function object_dispose(obj: any): any;

// export function object_getClass(obj: any): typeof NSObject;

// export function object_getClassName(obj: any): string;

// export function object_getIndexedIvars(obj: any): any;

// export function object_getInstanceVariable(obj: any, name: string | any, outValue: any): any;

// export function object_getIvar(obj: any, ivar: any): any;

// export function object_isClass(obj: any): boolean;

// export function object_realloc(anObject: any, nBytes: number): any;

// export function object_reallocFromZone(anObject: any, nBytes: number, z: any): any;

// export function object_setClass(obj: any, cls: typeof NSObject): typeof NSObject;

// export function object_setInstanceVariable(obj: any, name: string | any, value: any): any;

// export function object_setInstanceVariableWithStrongDefault(obj: any, name: string | any, value: any): any;

// export function object_setIvar(obj: any, ivar: any, value: any): void;

// export function object_setIvarWithStrongDefault(obj: any, ivar: any, value: any): void;

// export function property_copyAttributeList(property: any, outCount: number): objc_property_attribute_t;

// export function property_copyAttributeValue(property: any, attributeName: string | any): string;

// export function property_getAttributes(property: any): string;

// export function property_getName(property: any): string;

// export function protocol_addMethodDescription(proto: any /* Protocol */, name: string, types: string | any, isRequiredMethod: boolean, isInstanceMethod: boolean): void;

// export function protocol_addProperty(proto: any /* Protocol */, name: string | any, attributes: objc_property_attribute_t, attributeCount: number, isRequiredProperty: boolean, isInstanceProperty: boolean): void;

// export function protocol_addProtocol(proto: any /* Protocol */, addition: any /* Protocol */): void;

// export function protocol_conformsToProtocol(proto: any /* Protocol */, other: any /* Protocol */): boolean;

// export function protocol_copyMethodDescriptionList(proto: any /* Protocol */, isRequiredMethod: boolean, isInstanceMethod: boolean, outCount: number): objc_method_description;

// export function protocol_copyPropertyList(proto: any /* Protocol */, outCount: number): any;

// export function protocol_copyPropertyList2(proto: any /* Protocol */, outCount: number, isRequiredProperty: boolean, isInstanceProperty: boolean): any;

// export function protocol_copyProtocolList(proto: any /* Protocol */, outCount: number): any /* Protocol */;

// export function protocol_getMethodDescription(proto: any /* Protocol */, aSel: string, isRequiredMethod: boolean, isInstanceMethod: boolean): objc_method_description;

// export function protocol_getName(proto: any /* Protocol */): string;

// export function protocol_getProperty(proto: any /* Protocol */, name: string | any, isRequiredProperty: boolean, isInstanceProperty: boolean): any;

// export function protocol_isEqual(proto: any /* Protocol */, other: any /* Protocol */): boolean;

// export function sel_getName(sel: string): string;

// export function sel_getNameFunction(sel: string): string;

// export function sel_getUid(str: string | any): string;

// export function sel_isEqual(lhs: string, rhs: string): boolean;

// export function sel_isMapped(sel: string): boolean;

// export function sel_registerName(str: string | any): string;

// export function sel_registerNameFunction(str: string | any): string;

export class IKCameraDeviceView extends NSView {
  cameraDevice: ICCameraDevice;
  setCameraDevice(_: ICCameraDevice);
  canDeleteSelectedItems: boolean;
  canDownloadSelectedItems: boolean;
  canRotateSelectedItemsLeft: boolean;
  canRotateSelectedItemsRight: boolean;
  delegate: any;
  setDelegate(_: any);
  displaysDownloadsDirectoryControl: boolean;
  setDisplaysDownloadsDirectoryControl(_: boolean);
  displaysPostProcessApplicationControl: boolean;
  setDisplaysPostProcessApplicationControl(_: boolean);
  downloadAllControlLabel: string;
  setDownloadAllControlLabel(_: string);
  downloadSelectedControlLabel: string;
  setDownloadSelectedControlLabel(_: string);
  downloadsDirectory: URL;
  setDownloadsDirectory(_: URL);
  hasDisplayModeIcon: boolean;
  setHasDisplayModeIcon(_: boolean);
  hasDisplayModeTable: boolean;
  setHasDisplayModeTable(_: boolean);
  iconSize: number;
  setIconSize(_: number);
  mode: IKCameraDeviceView.IKCameraDeviceViewDisplayMode;
  setMode(_: IKCameraDeviceView.IKCameraDeviceViewDisplayMode);
  postProcessApplication: URL;
  setPostProcessApplication(_: URL);
  transferMode: IKCameraDeviceView.IKCameraDeviceViewTransferMode;
  setTransferMode(_: IKCameraDeviceView.IKCameraDeviceViewTransferMode);
  deleteSelectedItems(_: any): void;
  downloadAllItems(_: any): void;
  downloadSelectedItems(_: any): void;
  rotateLeft(_: any): void;
  rotateRight(_: any): void;
  selectIndexesByExtendingSelection(_: IndexSet, byExtendingSelection: boolean): void;
  selectedIndexes(): IndexSet;
}

interface IKCameraDeviceViewDelegate {
  cameraDeviceViewDidDownloadFileLocationFileDataError(_: IKCameraDeviceView, didDownloadFile: ICCameraFile, location: URL, fileData: Data, error: Error): void;
  cameraDeviceViewDidEncounterError(_: IKCameraDeviceView, didEncounterError: Error): void;
  cameraDeviceViewSelectionDidChange(_: IKCameraDeviceView): void;
}

export class IKDeviceBrowserView extends NSView {
  delegate: any;
  setDelegate(_: any);
  displaysLocalCameras: boolean;
  setDisplaysLocalCameras(_: boolean);
  displaysLocalScanners: boolean;
  setDisplaysLocalScanners(_: boolean);
  displaysNetworkCameras: boolean;
  setDisplaysNetworkCameras(_: boolean);
  displaysNetworkScanners: boolean;
  setDisplaysNetworkScanners(_: boolean);
  mode: IKDeviceBrowserView.IKDeviceBrowserViewDisplayMode;
  setMode(_: IKDeviceBrowserView.IKDeviceBrowserViewDisplayMode);
  selectedDevice: ICDevice;
}

interface IKDeviceBrowserViewDelegate {
  deviceBrowserViewSelectionDidChange(_: IKDeviceBrowserView, selectionDidChange: ICDevice): void;
  deviceBrowserViewDidEncounterError(_: IKDeviceBrowserView, didEncounterError: Error): void;
}

export class IKFilterBrowserPanel extends NSPanel {
  static filterBrowserPanelWithStyleMask(withStyleMask: number): any;
  beginSheetWithOptionsModalForWindowModalDelegateDidEndSelectorContextInfo(options: Map<any, any>, modalFor: NSWindow, modalDelegate: any, didEnd: string, contextInfo: any): void;
  beginWithOptionsModelessDelegateDidEndSelectorContextInfo(options: Map<any, any>, modelessDelegate: any, didEnd: string, contextInfo: any): void;
  filterBrowserViewWithOptions(options: Map<any, any>): IKFilterBrowserView;
  filterName(): string;
  finish(_: any): void;
  runModalWithOptions(options: Map<any, any>): number;
}

export class IKFilterBrowserView extends NSView {
  filterName(): string;
  setPreviewState(_: boolean): void;
}

interface IKFilterCustomUIProvider {
  provideViewForUIConfigurationExcludedKeys(forUIConfiguration: Map<any, any>, excludedKeys: any[]): IKFilterUIView;
}

export class IKFilterUIView extends NSView {
  static viewWithFrameFilter(withFrame: CGRect, filter: CIFilter): any;
  filter(): CIFilter;
  static initWithFrameFilter(_: CGRect, filter: CIFilter): IKFilterUIView;
  objectController(): NSObjectController;
}

export class IKImageBrowserCell extends NSObject {
  cellState(): IKImageBrowserCell.IKImageBrowserCellState;
  frame(): CGRect;
  imageAlignment(): NSImageCell.NSImageAlignment;
  imageContainerFrame(): CGRect;
  imageFrame(): CGRect;
  indexOfRepresentedItem(): number;
  isSelected(): boolean;
  layerForType(forType: string): CALayer;
  opacity(): number;
  representedItem(): any;
  selectionFrame(): CGRect;
  subtitleFrame(): CGRect;
  titleFrame(): CGRect;
}

export class IKImageEditPanel extends NSPanel {
  static sharedImageEditPanel(): IKImageEditPanel;
  dataSource: any;
  setDataSource(_: any);
  filterArray: any[];
  reloadData(): void;
}

interface IKImageEditPanelDataSource {
  hasAdjustMode(): boolean;
  hasDetailsMode(): boolean;
  hasEffectsMode(): boolean;
  image(): any;
  imageProperties(): Map<any, any>;
  setImageImageProperties(_: any, imageProperties: Map<any, any>): void;
  thumbnailWithMaximumSize(withMaximumSize: CGSize): any;
}

export class IKImageView extends NSView {
  autohidesScrollers: boolean;
  setAutohidesScrollers(_: boolean);
  autoresizes: boolean;
  setAutoresizes(_: boolean);
  backgroundColor: NSColor;
  setBackgroundColor(_: NSColor);
  currentToolMode: string;
  setCurrentToolMode(_: string);
  delegate: any;
  setDelegate(_: any);
  doubleClickOpensImageEditPanel: boolean;
  setDoubleClickOpensImageEditPanel(_: boolean);
  editable: boolean;
  setEditable(_: boolean);
  hasHorizontalScroller: boolean;
  setHasHorizontalScroller(_: boolean);
  hasVerticalScroller: boolean;
  setHasVerticalScroller(_: boolean);
  imageCorrection: CIFilter;
  setImageCorrection(_: CIFilter);
  rotationAngle: number;
  setRotationAngle(_: number);
  supportsDragAndDrop: boolean;
  setSupportsDragAndDrop(_: boolean);
  zoomFactor: number;
  setZoomFactor(_: number);
  convertImagePointToViewPoint(toViewPoint: CGPoint): CGPoint;
  convertImageRectToViewRect(toViewRect: CGRect): CGRect;
  convertViewPointToImagePoint(toImagePoint: CGPoint): CGPoint;
  convertViewRectToImageRect(toImageRect: CGRect): CGRect;
  crop(_: any): void;
  flipImageHorizontal(_: any): void;
  flipImageVertical(_: any): void;
  image(): any;
  imageProperties(): Map<any, any>;
  imageSize(): CGSize;
  overlayForType(forType: string): CALayer;
  rotateImageLeft(_: any): void;
  rotateImageRight(_: any): void;
  scrollToPoint(to: CGPoint): void;
  scrollToRect(to: CGRect): void;
  setImageImageProperties(_: any, imageProperties: Map<any, any>): void;
  setImageWithURL(_: URL): void;
  setImageZoomFactorCenterPoint(_: number, center: CGPoint): void;
  setOverlayForType(_: CALayer, forType: string): void;
  setRotationAngleCenterPoint(_: number, center: CGPoint): void;
  zoomImageToActualSize(_: any): void;
  zoomImageToFit(_: any): void;
  zoomImageToRect(to: CGRect): void;
  zoomIn(_: any): void;
  zoomOut(_: any): void;
}

export class IKPictureTaker extends NSPanel {
  static pictureTaker(): IKPictureTaker;
  beginPictureTakerSheetForWindowWithDelegateDidEndSelectorContextInfo(for_: NSWindow, withDelegate: any, didEnd: string, contextInfo: any): void;
  beginPictureTakerWithDelegateDidEndSelectorContextInfo(withDelegate: any, didEnd: string, contextInfo: any): void;
  inputImage(): NSImage;
  mirroring(): boolean;
  outputImage(): NSImage;
  popUpRecentsMenuForViewWithDelegateDidEndSelectorContextInfo(for_: NSView, withDelegate: any, didEnd: string, contextInfo: any): void;
  runModal(): number;
  setInputImage(_: NSImage): void;
  setMirroring(_: boolean): void;
}

export class IKSaveOptions extends NSObject {
  delegate: any;
  setDelegate(_: any);
  imageProperties: Map<any, any>;
  imageUTType: string;
  userSelection: Map<any, any>;
  addSaveOptionsAccessoryViewToSavePanel(to: NSSavePanel): void;
  addSaveOptionsToView(to: NSView): void;
  static initWithImagePropertiesImageUTType(_: Map<any, any>, imageUTType: string): IKSaveOptions;
}

export class IKScannerDeviceView extends NSView {
  delegate: any;
  setDelegate(_: any);
  displaysDownloadsDirectoryControl: boolean;
  setDisplaysDownloadsDirectoryControl(_: boolean);
  displaysPostProcessApplicationControl: boolean;
  setDisplaysPostProcessApplicationControl(_: boolean);
  documentName: string;
  setDocumentName(_: string);
  downloadsDirectory: URL;
  setDownloadsDirectory(_: URL);
  hasDisplayModeAdvanced: boolean;
  setHasDisplayModeAdvanced(_: boolean);
  hasDisplayModeSimple: boolean;
  setHasDisplayModeSimple(_: boolean);
  mode: IKScannerDeviceView.IKScannerDeviceViewDisplayMode;
  setMode(_: IKScannerDeviceView.IKScannerDeviceViewDisplayMode);
  overviewControlLabel: string;
  setOverviewControlLabel(_: string);
  postProcessApplication: URL;
  setPostProcessApplication(_: URL);
  scanControlLabel: string;
  setScanControlLabel(_: string);
  scannerDevice: ICScannerDevice;
  setScannerDevice(_: ICScannerDevice);
  transferMode: IKScannerDeviceView.IKScannerDeviceViewTransferMode;
  setTransferMode(_: IKScannerDeviceView.IKScannerDeviceViewTransferMode);
}

interface IKScannerDeviceViewDelegate {
  scannerDeviceViewDidScanToURLFileDataError(_: IKScannerDeviceView, didScanTo: URL, fileData: Data, error: Error): void;
  scannerDeviceViewDidScanToURLError(_: IKScannerDeviceView, didScanTo: URL, error: Error): void;
  scannerDeviceViewDidScanToBandDataScanInfoError(_: IKScannerDeviceView, didScanTo: ICScannerBandData, scanInfo: Map<any, any>, error: Error): void;
  scannerDeviceViewDidEncounterError(_: IKScannerDeviceView, didEncounterError: Error): void;
}

export class IKSlideshow extends NSObject {
  static canExportToApplication(toApplication: string): boolean;
  static exportSlideshowItemToApplication(_: any, toApplication: string): void;
  static sharedSlideshow(): IKSlideshow;
  autoPlayDelay: number;
  setAutoPlayDelay(_: number);
  indexOfCurrentSlideshowItem(): number;
  reloadData(): void;
  reloadSlideshowItemAtIndex(at: number): void;
  runSlideshowWithDataSourceInModeOptions(with_: any, inMode: string, options: Map<any, any>): void;
  stopSlideshow(_: any): void;
}

interface IKSlideshowDataSource {
  canExportSlideshowItemAtIndexToApplication(at: number, toApplication: string): boolean;
  nameOfSlideshowItemAtIndex(at: number): string;
  numberOfSlideshowItems(): number;
  slideshowDidChangeCurrentIndex(_: number): void;
  slideshowDidStop(): void;
  slideshowItemAtIndex(at: number): any;
  slideshowWillStart(): void;
}

interface QLPreviewItem {
  previewItemDisplayState?: any;
  previewItemTitle?: string;
  previewItemURL: URL;
}

export class QLPreviewPanel extends NSPanel {
  static sharedPreviewPanel(): QLPreviewPanel;
  static sharedPreviewPanelExists(): boolean;
  currentController: any;
  currentPreviewItem: any;
  currentPreviewItemIndex: number;
  setCurrentPreviewItemIndex(_: number);
  dataSource: any;
  setDataSource(_: any);
  delegate: any;
  setDelegate(_: any);
  displayState: any;
  setDisplayState(_: any);
  isInFullScreenMode: boolean;
  enterFullScreenModeWithOptions(_: NSScreen, withOptions: Map<any, any>): boolean;
  exitFullScreenModeWithOptions(options: Map<any, any>): void;
  refreshCurrentPreviewItem(): void;
  reloadData(): void;
  updateController(): void;
}

interface QLPreviewPanelDataSource {
  numberOfPreviewItemsInPreviewPanel(in_: QLPreviewPanel): number;
  previewPanelPreviewItemAtIndex(_: QLPreviewPanel, previewItemAt: number): any;
}

interface QLPreviewPanelDelegate {
  previewPanelHandleEvent(_: QLPreviewPanel, handle: NSEvent): boolean;
  previewPanelSourceFrameOnScreenForPreviewItem(_: QLPreviewPanel, sourceFrameOnScreenFor: any): CGRect;
  previewPanelTransitionImageForPreviewItemContentRect(_: QLPreviewPanel, transitionImageFor: any, contentRect: CGRect): any;
}

export class QLPreviewView extends NSView {
  autostarts: boolean;
  setAutostarts(_: boolean);
  displayState: any;
  setDisplayState(_: any);
  previewItem: any;
  setPreviewItem(_: any);
  shouldCloseWithWindow: boolean;
  setShouldCloseWithWindow(_: boolean);
  close(): void;
  static initWithFrameStyle(_: CGRect, style: QLPreviewView.QLPreviewViewStyle): QLPreviewView;
  refreshPreviewItem(): void;
}

interface QLPreviewingController {
  preparePreviewOfFileAtURLCompletionHandler(at: URL, completionHandler?: (p1: Error) => void): void;
  preparePreviewOfSearchableItemWithIdentifierQueryStringCompletionHandler(identifier: string, queryString?: string, completionHandler?: (p1: Error) => void): void;
}

export class QuartzFilter extends NSObject {
  applyToContext(to: any): boolean;
  localizedName(): string;
  properties(): Map<any, any>;
  removeFromContext(from: any): void;
  url(): URL;
}

export class QuartzFilterManager extends NSObject {
  static filtersInDomains(inDomains: any[]): any[];
  delegate(): any;
  filterPanel(): NSPanel;
  filterView(): QuartzFilterView;
  importFilter(_: Map<any, any>): QuartzFilter;
  selectFilter(_: QuartzFilter): boolean;
  selectedFilter(): QuartzFilter;
  setDelegate(_: any): void;
}

export class QuartzFilterView extends NSView {
  sizeToFit(): void;
}

interface CAAction {
  runActionForKeyObjectArguments(forKey: string, object_: any, arguments_?: Map<any, any>): void;
}

export class CAAnimation extends NSObject {
  static defaultValueForKey(forKey: string): any;
  delegate: any;
  setDelegate(_: any);
  isRemovedOnCompletion: boolean;
  setRemovedOnCompletion(_: boolean);
  timingFunction: CAMediaTimingFunction;
  setTimingFunction(_: CAMediaTimingFunction);
  shouldArchiveValueForKey(forKey: string): boolean;
}

interface CAAnimationDelegate {
  animationDidStart(_: CAAnimation): void;
  animationDidStopFinished(_: CAAnimation, finished: boolean): void;
}

export class CAAnimationGroup extends CAAnimation {
  animations: CAAnimation[];
  setAnimations(_: CAAnimation[]);
}

export class CABasicAnimation extends CAPropertyAnimation {
  byValue: any;
  setByValue(_: any);
  fromValue: any;
  setFromValue(_: any);
  toValue: any;
  setToValue(_: any);
}

export class CAConstraint extends NSObject {
  attribute: CAConstraintLayoutManager.CAConstraintAttribute;
  offset: number;
  scale: number;
  sourceAttribute: CAConstraintLayoutManager.CAConstraintAttribute;
  sourceName: string;
  static initWithAttributeRelativeToAttributeScaleOffset(_: CAConstraintLayoutManager.CAConstraintAttribute, relativeTo: string, attribute: CAConstraintLayoutManager.CAConstraintAttribute, scale: number, offset: number): CAConstraint;
}

export class CAConstraintLayoutManager extends NSObject {
}

// export function CACurrentMediaTime(): number;

export class CADisplayLink extends NSObject {
  duration: number;
  frameInterval: number;
  setFrameInterval(_: number);
  isPaused: boolean;
  setPaused(_: boolean);
  preferredFramesPerSecond: number;
  setPreferredFramesPerSecond(_: number);
  targetTimestamp: number;
  timestamp: number;
  addToRunLoopForMode(to: RunLoop, forMode: string): void;
  invalidate(): void;
  removeFromRunLoopForMode(from: RunLoop, forMode: string): void;
}

export class CAEDRMetadata extends NSObject {
  static hDR10MetadataWithDisplayInfoContentInfoOpticalOutputScale(displayInfo?: Data, contentInfo?: Data, opticalOutputScale?: number): CAEDRMetadata;
  static hDR10MetadataWithMinLuminanceMaxLuminanceOpticalOutputScale(minLuminance: number, maxLuminance: number, opticalOutputScale: number): CAEDRMetadata;
  static HLGMetadata: CAEDRMetadata;
}

export class CAEmitterCell extends NSObject {
  static defaultValueForKey(forKey: string): any;
  alphaRange: number;
  setAlphaRange(_: number);
  alphaSpeed: number;
  setAlphaSpeed(_: number);
  birthRate: number;
  setBirthRate(_: number);
  blueRange: number;
  setBlueRange(_: number);
  blueSpeed: number;
  setBlueSpeed(_: number);
  color: any;
  setColor(_: any);
  contents: any;
  setContents(_: any);
  contentsRect: CGRect;
  setContentsRect(_: CGRect);
  contentsScale: number;
  setContentsScale(_: number);
  emissionLatitude: number;
  setEmissionLatitude(_: number);
  emissionLongitude: number;
  setEmissionLongitude(_: number);
  emissionRange: number;
  setEmissionRange(_: number);
  emitterCells: CAEmitterCell[];
  setEmitterCells(_: CAEmitterCell[]);
  isEnabled: boolean;
  setEnabled(_: boolean);
  greenRange: number;
  setGreenRange(_: number);
  greenSpeed: number;
  setGreenSpeed(_: number);
  lifetime: number;
  setLifetime(_: number);
  lifetimeRange: number;
  setLifetimeRange(_: number);
  magnificationFilter: string;
  setMagnificationFilter(_: string);
  minificationFilter: string;
  setMinificationFilter(_: string);
  minificationFilterBias: number;
  setMinificationFilterBias(_: number);
  name: string;
  setName(_: string);
  redRange: number;
  setRedRange(_: number);
  redSpeed: number;
  setRedSpeed(_: number);
  scale: number;
  setScale(_: number);
  scaleRange: number;
  setScaleRange(_: number);
  scaleSpeed: number;
  setScaleSpeed(_: number);
  spin: number;
  setSpin(_: number);
  spinRange: number;
  setSpinRange(_: number);
  style: Map<any, any>;
  setStyle(_: Map<any, any>);
  velocity: number;
  setVelocity(_: number);
  velocityRange: number;
  setVelocityRange(_: number);
  xAcceleration: number;
  setXAcceleration(_: number);
  yAcceleration: number;
  setYAcceleration(_: number);
  zAcceleration: number;
  setZAcceleration(_: number);
  shouldArchiveValueForKey(forKey: string): boolean;
}

export class CAEmitterLayer extends CALayer {
  birthRate: number;
  setBirthRate(_: number);
  emitterCells: CAEmitterCell[];
  setEmitterCells(_: CAEmitterCell[]);
  emitterDepth: number;
  setEmitterDepth(_: number);
  emitterMode: string;
  setEmitterMode(_: string);
  emitterPosition: CGPoint;
  setEmitterPosition(_: CGPoint);
  emitterShape: string;
  setEmitterShape(_: string);
  emitterSize: CGSize;
  setEmitterSize(_: CGSize);
  emitterZPosition: number;
  setEmitterZPosition(_: number);
  lifetime: number;
  setLifetime(_: number);
  preservesDepth: boolean;
  setPreservesDepth(_: boolean);
  renderMode: string;
  setRenderMode(_: string);
  scale: number;
  setScale(_: number);
  seed: number;
  setSeed(_: number);
  spin: number;
  setSpin(_: number);
  velocity: number;
  setVelocity(_: number);
}

export class CAGradientLayer extends CALayer {
  colors: any[];
  setColors(_: any[]);
  endPoint: CGPoint;
  setEndPoint(_: CGPoint);
  locations: number[];
  setLocations(_: number[]);
  startPoint: CGPoint;
  setStartPoint(_: CGPoint);
  type: string;
  setType(_: string);
}

export class CAKeyframeAnimation extends CAPropertyAnimation {
  biasValues: number[];
  setBiasValues(_: number[]);
  calculationMode: string;
  setCalculationMode(_: string);
  continuityValues: number[];
  setContinuityValues(_: number[]);
  keyTimes: number[];
  setKeyTimes(_: number[]);
  path: any;
  setPath(_: any);
  rotationMode: string;
  setRotationMode(_: string);
  tensionValues: number[];
  setTensionValues(_: number[]);
  timingFunctions: CAMediaTimingFunction[];
  setTimingFunctions(_: CAMediaTimingFunction[]);
  values: any[];
  setValues(_: any[]);
}

export class CALayer extends NSObject {
  static cornerCurveExpansionFactor(_: string): number;
  static defaultActionForKey(forKey: string): any;
  static defaultValueForKey(forKey: string): any;
  static needsDisplayForKey(forKey: string): boolean;
  actions: Map<string, any>;
  setActions(_: Map<string, any>);
  allowsEdgeAntialiasing: boolean;
  setAllowsEdgeAntialiasing(_: boolean);
  allowsGroupOpacity: boolean;
  setAllowsGroupOpacity(_: boolean);
  anchorPoint: CGPoint;
  setAnchorPoint(_: CGPoint);
  anchorPointZ: number;
  setAnchorPointZ(_: number);
  autoresizingMask: CALayer.CAAutoresizingMask;
  setAutoresizingMask(_: CALayer.CAAutoresizingMask);
  backgroundColor: any;
  setBackgroundColor(_: any);
  backgroundFilters: any[];
  setBackgroundFilters(_: any[]);
  borderColor: any;
  setBorderColor(_: any);
  borderWidth: number;
  setBorderWidth(_: number);
  bounds: CGRect;
  setBounds(_: CGRect);
  compositingFilter: any;
  setCompositingFilter(_: any);
  constraints: CAConstraint[];
  setConstraints(_: CAConstraint[]);
  contents: any;
  setContents(_: any);
  contentsCenter: CGRect;
  setContentsCenter(_: CGRect);
  contentsFormat: string;
  setContentsFormat(_: string);
  contentsGravity: string;
  setContentsGravity(_: string);
  contentsRect: CGRect;
  setContentsRect(_: CGRect);
  contentsScale: number;
  setContentsScale(_: number);
  cornerCurve: string;
  setCornerCurve(_: string);
  cornerRadius: number;
  setCornerRadius(_: number);
  delegate: any;
  setDelegate(_: any);
  isDoubleSided: boolean;
  setDoubleSided(_: boolean);
  drawsAsynchronously: boolean;
  setDrawsAsynchronously(_: boolean);
  edgeAntialiasingMask: CALayer.CAEdgeAntialiasingMask;
  setEdgeAntialiasingMask(_: CALayer.CAEdgeAntialiasingMask);
  filters: any[];
  setFilters(_: any[]);
  frame: CGRect;
  setFrame(_: CGRect);
  isGeometryFlipped: boolean;
  setGeometryFlipped(_: boolean);
  isHidden: boolean;
  setHidden(_: boolean);
  layoutManager: any;
  setLayoutManager(_: any);
  magnificationFilter: string;
  setMagnificationFilter(_: string);
  mask: CALayer;
  setMask(_: CALayer);
  maskedCorners: CALayer.CACornerMask;
  setMaskedCorners(_: CALayer.CACornerMask);
  masksToBounds: boolean;
  setMasksToBounds(_: boolean);
  minificationFilter: string;
  setMinificationFilter(_: string);
  minificationFilterBias: number;
  setMinificationFilterBias(_: number);
  name: string;
  setName(_: string);
  needsDisplayOnBoundsChange: boolean;
  setNeedsDisplayOnBoundsChange(_: boolean);
  opacity: number;
  setOpacity(_: number);
  isOpaque: boolean;
  setOpaque(_: boolean);
  position: CGPoint;
  setPosition(_: CGPoint);
  rasterizationScale: number;
  setRasterizationScale(_: number);
  shadowColor: any;
  setShadowColor(_: any);
  shadowOffset: CGSize;
  setShadowOffset(_: CGSize);
  shadowOpacity: number;
  setShadowOpacity(_: number);
  shadowPath: any;
  setShadowPath(_: any);
  shadowRadius: number;
  setShadowRadius(_: number);
  shouldRasterize: boolean;
  setShouldRasterize(_: boolean);
  style: Map<any, any>;
  setStyle(_: Map<any, any>);
  sublayerTransform: CATransform3D;
  setSublayerTransform(_: CATransform3D);
  sublayers: CALayer[];
  setSublayers(_: CALayer[]);
  superlayer: CALayer;
  transform: CATransform3D;
  setTransform(_: CATransform3D);
  visibleRect: CGRect;
  zPosition: number;
  setZPosition(_: number);
  actionForKey(forKey: string): any;
  addAnimationForKey(_: CAAnimation, forKey?: string): void;
  addConstraint(_: CAConstraint): void;
  addSublayer(_: CALayer): void;
  affineTransform(): CGAffineTransform;
  animationForKey(forKey: string): CAAnimation;
  animationKeys(): string[];
  containsPoint(_: CGPoint): boolean;
  contentsAreFlipped(): boolean;
  convertPointFromLayer(_: CGPoint, from?: CALayer): CGPoint;
  convertPointToLayer(_: CGPoint, to?: CALayer): CGPoint;
  convertRectFromLayer(_: CGRect, from?: CALayer): CGRect;
  convertRectToLayer(_: CGRect, to?: CALayer): CGRect;
  convertTimeFromLayer(_: number, from?: CALayer): number;
  convertTimeToLayer(_: number, to?: CALayer): number;
  display(): void;
  displayIfNeeded(): void;
  drawInContext(in_: any): void;
  hitTest(_: CGPoint): CALayer;
  static initWithLayer(_: any): CALayer;
  insertSublayerAbove(_: CALayer, above?: CALayer): void;
  insertSublayerAtIndex(_: CALayer, at: number): void;
  insertSublayerBelow(_: CALayer, below?: CALayer): void;
  layoutIfNeeded(): void;
  layoutSublayers(): void;
  modelLayer(): CALayer;
  needsDisplay(): boolean;
  needsLayout(): boolean;
  preferredFrameSize(): CGSize;
  presentationLayer(): CALayer;
  removeAllAnimations(): void;
  removeAnimationForKey(forKey: string): void;
  removeFromSuperlayer(): void;
  renderInContext(in_: any): void;
  replaceSublayerWith(_: CALayer, with_: CALayer): void;
  resizeSublayersWithOldSize(withOldSize: CGSize): void;
  resizeWithOldSuperlayerSize(withOldSuperlayerSize: CGSize): void;
  scrollPoint(_: CGPoint): void;
  scrollRectToVisible(_: CGRect): void;
  setAffineTransform(_: CGAffineTransform): void;
  setNeedsDisplay(): void;
  setNeedsDisplayInRect(_: CGRect): void;
  setNeedsLayout(): void;
  shouldArchiveValueForKey(forKey: string): boolean;
}

interface CALayerDelegate {
  actionForLayerForKey(for_: CALayer, forKey: string): any;
  displayLayer(_: CALayer): void;
  drawLayerInContext(_: CALayer, in_: any): void;
  layerWillDraw(_: CALayer): void;
  layoutSublayersOfLayer(of: CALayer): void;
}

interface CALayoutManager {
  invalidateLayoutOfLayer(of: CALayer): void;
  layoutSublayersOfLayer(of: CALayer): void;
  preferredSizeOfLayer(of: CALayer): CGSize;
}

interface CAMediaTiming {
  autoreverses: boolean;
  setAutoreverses(_: boolean);
  beginTime: number;
  setBeginTime(_: number);
  duration: number;
  setDuration(_: number);
  fillMode: string;
  setFillMode(_: string);
  repeatCount: number;
  setRepeatCount(_: number);
  repeatDuration: number;
  setRepeatDuration(_: number);
  speed: number;
  setSpeed(_: number);
  timeOffset: number;
  setTimeOffset(_: number);
}

export class CAMediaTimingFunction extends NSObject {
  static functionWithControlPoints(_: number, _2: number, _3: number, _4: number): CAMediaTimingFunction;
  getControlPointAtIndexValues(at: number, values: number): void;
  static initWithControlPoints(_: number, _2: number, _3: number, _4: number): CAMediaTimingFunction;
}

interface CAMetalDrawable {
  layer: CAMetalLayer;
  texture: any;
}

export class CAMetalLayer extends CALayer {
  EDRMetadata: CAEDRMetadata;
  setEDRMetadata(_: CAEDRMetadata);
  allowsNextDrawableTimeout: boolean;
  setAllowsNextDrawableTimeout(_: boolean);
  colorspace: any;
  setColorspace(_: any);
  device: any;
  setDevice(_: any);
  displaySyncEnabled: boolean;
  setDisplaySyncEnabled(_: boolean);
  drawableSize: CGSize;
  setDrawableSize(_: CGSize);
  framebufferOnly: boolean;
  setFramebufferOnly(_: boolean);
  maximumDrawableCount: number;
  setMaximumDrawableCount(_: number);
  pixelFormat: MTLPixelFormat.MTLPixelFormat;
  setPixelFormat(_: MTLPixelFormat.MTLPixelFormat);
  preferredDevice: any;
  presentsWithTransaction: boolean;
  setPresentsWithTransaction(_: boolean);
  wantsExtendedDynamicRangeContent: boolean;
  setWantsExtendedDynamicRangeContent(_: boolean);
  nextDrawable(): any;
}

export class CAPropertyAnimation extends CAAnimation {
  isAdditive: boolean;
  setAdditive(_: boolean);
  isCumulative: boolean;
  setCumulative(_: boolean);
  keyPath: string;
  setKeyPath(_: string);
  valueFunction: CAValueFunction;
  setValueFunction(_: CAValueFunction);
}

export class CARemoteLayerClient extends NSObject {
  clientId: number;
  static initWithServerPort(_: number): CARemoteLayerClient;
  invalidate(): void;
}

export class CARemoteLayerServer extends NSObject {
  static sharedServer(): CARemoteLayerServer;
  serverPort: number;
}

export class CARenderer extends NSObject {
  bounds: CGRect;
  setBounds(_: CGRect);
  addUpdateRect(_: CGRect): void;
  beginFrameAtTimeTimeStamp(atTime: number, timeStamp?: CVTimeStamp): void;
  endFrame(): void;
  nextFrameTime(): number;
  render(): void;
  setDestination(_: any): void;
  updateBounds(): CGRect;
}

export class CAReplicatorLayer extends CALayer {
  instanceAlphaOffset: number;
  setInstanceAlphaOffset(_: number);
  instanceBlueOffset: number;
  setInstanceBlueOffset(_: number);
  instanceColor: any;
  setInstanceColor(_: any);
  instanceCount: number;
  setInstanceCount(_: number);
  instanceDelay: number;
  setInstanceDelay(_: number);
  instanceGreenOffset: number;
  setInstanceGreenOffset(_: number);
  instanceRedOffset: number;
  setInstanceRedOffset(_: number);
  instanceTransform: CATransform3D;
  setInstanceTransform(_: CATransform3D);
  preservesDepth: boolean;
  setPreservesDepth(_: boolean);
}

export class CAScrollLayer extends CALayer {
  scrollMode: string;
  setScrollMode(_: string);
  scrollToPoint(to: CGPoint): void;
  scrollToRect(to: CGRect): void;
}

export class CAShapeLayer extends CALayer {
  fillColor: any;
  setFillColor(_: any);
  fillRule: string;
  setFillRule(_: string);
  lineCap: string;
  setLineCap(_: string);
  lineDashPattern: number[];
  setLineDashPattern(_: number[]);
  lineDashPhase: number;
  setLineDashPhase(_: number);
  lineJoin: string;
  setLineJoin(_: string);
  lineWidth: number;
  setLineWidth(_: number);
  miterLimit: number;
  setMiterLimit(_: number);
  path: any;
  setPath(_: any);
  strokeColor: any;
  setStrokeColor(_: any);
  strokeEnd: number;
  setStrokeEnd(_: number);
  strokeStart: number;
  setStrokeStart(_: number);
}

export class CASpringAnimation extends CABasicAnimation {
  damping: number;
  setDamping(_: number);
  initialVelocity: number;
  setInitialVelocity(_: number);
  mass: number;
  setMass(_: number);
  settlingDuration: number;
  stiffness: number;
  setStiffness(_: number);
}

export class CATextLayer extends CALayer {
  alignmentMode: string;
  setAlignmentMode(_: string);
  allowsFontSubpixelQuantization: boolean;
  setAllowsFontSubpixelQuantization(_: boolean);
  font: any;
  setFont(_: any);
  fontSize: number;
  setFontSize(_: number);
  foregroundColor: any;
  setForegroundColor(_: any);
  truncationMode: string;
  setTruncationMode(_: string);
  isWrapped: boolean;
  setWrapped(_: boolean);
}

export class CATiledLayer extends CALayer {
  static fadeDuration(): number;
  levelsOfDetail: number;
  setLevelsOfDetail(_: number);
  levelsOfDetailBias: number;
  setLevelsOfDetailBias(_: number);
  tileSize: CGSize;
  setTileSize(_: CGSize);
}

export class CATransaction extends NSObject {
  static animationDuration(): number;
  static animationTimingFunction(): CAMediaTimingFunction;
  static begin(): void;
  static commit(): void;
  static completionBlock(): () => void;
  static disableActions(): boolean;
  static flush(): void;
  static lock(): void;
  static setAnimationDuration(_: number): void;
  static setAnimationTimingFunction(_?: CAMediaTimingFunction): void;
  static setCompletionBlock(_?: () => void): void;
  static setDisableActions(_: boolean): void;
  static setValueForKey(_?: any, forKey?: string): void;
  static unlock(): void;
  static valueForKey(forKey: string): any;
}

// export function CATransform3DConcat(a: CATransform3D, b: CATransform3D): CATransform3D;

// export function CATransform3DEqualToTransform(a: CATransform3D, b: CATransform3D): boolean;

// export function CATransform3DGetAffineTransform(t: CATransform3D): CGAffineTransform;

// export function CATransform3DInvert(t: CATransform3D): CATransform3D;

// export function CATransform3DIsAffine(t: CATransform3D): boolean;

// export function CATransform3DIsIdentity(t: CATransform3D): boolean;

// export function CATransform3DMakeAffineTransform(m: CGAffineTransform): CATransform3D;

// export function CATransform3DMakeRotation(angle: number, x: number, y: number, z: number): CATransform3D;

// export function CATransform3DMakeScale(sx: number, sy: number, sz: number): CATransform3D;

// export function CATransform3DMakeTranslation(tx: number, ty: number, tz: number): CATransform3D;

// export function CATransform3DRotate(t: CATransform3D, angle: number, x: number, y: number, z: number): CATransform3D;

// export function CATransform3DScale(t: CATransform3D, sx: number, sy: number, sz: number): CATransform3D;

// export function CATransform3DTranslate(t: CATransform3D, tx: number, ty: number, tz: number): CATransform3D;

export class CATransformLayer extends CALayer {
}

export class CATransition extends CAAnimation {
  endProgress: number;
  setEndProgress(_: number);
  filter: any;
  setFilter(_: any);
  startProgress: number;
  setStartProgress(_: number);
  subtype: string;
  setSubtype(_: string);
  type: string;
  setType(_: string);
}

export class CAValueFunction extends NSObject {
  name: string;
}

namespace AE {
      export enum AEDataModel { }
      }
export namespace AVAnimation {
}

export namespace AVAsset {
  export enum AVAssetReferenceRestrictions {
    ForbidNone = 0,
    ForbidRemoteReferenceToLocal = 1,
    ForbidLocalReferenceToRemote = 2,
    ForbidCrossSiteReference = 4,
    ForbidLocalReferenceToLocal = 8,
    ForbidAll = 65535,
    DefaultPolicy = 2
  }

}

export namespace AVAssetCache {
}

export namespace AVAssetExportSession {
  export enum Status {
    Unknown = 0,
    Waiting = 1,
    Exporting = 2,
    Completed = 3,
    Failed = 4,
    Cancelled = 5
  }

}

export namespace AVAssetImageGenerator {
  export enum Result {
    Succeeded = 0,
    Failed = 1,
    Cancelled = 2
  }

}

export namespace AVAssetReader {
  export enum Status {
    Unknown = 0,
    Reading = 1,
    Completed = 2,
    Failed = 3,
    Cancelled = 4
  }

}

export namespace AVAssetReaderOutput {
}

export namespace AVAssetResourceLoader {
}

export namespace AVAssetTrack {
}

export namespace AVAssetTrackGroup {
}

export namespace AVAssetTrackSegment {
}

export namespace AVAssetWriter {
  export enum Status {
    Unknown = 0,
    Writing = 1,
    Completed = 2,
    Failed = 3,
    Cancelled = 4
  }

}

export namespace AVAssetWriterInput {
}

export namespace AVAsynchronousKeyValueLoading {
  export enum AVKeyValueStatus {
    Unknown = 0,
    Loading = 1,
    Loaded = 2,
    Failed = 3,
    Cancelled = 4
  }

}

export namespace AVAudioBuffer {
}

export namespace AVAudioChannelLayout {
}

export namespace AVAudioConnectionPoint {
}

export namespace AVAudioConverter {
  export enum AVAudioConverterInputStatus {
    _HaveData = 0,
    _NoDataNow = 1,
    _EndOfStream = 2
  }

  export enum AVAudioConverterOutputStatus {
    _HaveData = 0,
    _InputRanDry = 1,
    _EndOfStream = 2,
    _Error = 3
  }

  export enum AVAudioConverterPrimeMethod {
    _Pre = 0,
    _Normal = 1,
    _None = 2
  }

}

export namespace AVAudioEngine {
  export enum AVAudioEngineManualRenderingError {
    InvalidMode = -80800,
    Initialized = -80801,
    NotRunning = -80802
  }

  export enum AVAudioEngineManualRenderingMode {
    Offline = 0,
    Realtime = 1
  }

  export enum AVAudioEngineManualRenderingStatus {
    Error = -1,
    Success = 0,
    InsufficientDataFromInputNode = 1,
    CannotDoInCurrentContext = 2
  }

}

export namespace AVAudioEnvironmentNode {
  export enum AVAudioEnvironmentDistanceAttenuationModel {
    Exponential = 1,
    Inverse = 2,
    Linear = 3
  }

  export enum AVAudioEnvironmentOutputType {
    Auto = 0,
    Headphones = 1,
    BuiltInSpeakers = 2,
    ExternalSpeakers = 3
  }

}

export namespace AVAudioFile {
}

export namespace AVAudioFormat {
  export enum AVAudioCommonFormat {
    OtherFormat = 0,
    PCMFormatFloat32 = 1,
    PCMFormatFloat64 = 2,
    PCMFormatInt16 = 3,
    PCMFormatInt32 = 4
  }

}

export namespace AVAudioIONode {
}

export namespace AVAudioMix {
}

export namespace AVAudioMixerNode {
}

export namespace AVAudioMixing {
  export enum AVAudio3DMixingPointSourceInHeadMode {
    eMono = 0,
    eBypass = 1
  }

  export enum AVAudio3DMixingRenderingAlgorithm {
    mEqualPowerPanning = 0,
    mSphericalHead = 1,
    mHRTF = 2,
    mSoundField = 3,
    mStereoPassThrough = 5,
    mHRTFHQ = 6,
    mAuto = 7
  }

  export enum AVAudio3DMixingSourceMode {
    eSpatializeIfMono = 0,
    eBypass = 1,
    ePointSource = 2,
    eAmbienceBed = 3
  }

}

export namespace AVAudioNode {
}

export namespace AVAudioPlayer {
}

export namespace AVAudioPlayerNode {
  export enum AVAudioPlayerNodeBufferOptions {
    Loops = 1,
    Interrupts = 2,
    InterruptsAtLoop = 4
  }

  export enum AVAudioPlayerNodeCompletionCallbackType {
    Consumed = 0,
    Rendered = 1,
    PlayedBack = 2
  }

}

export namespace AVAudioProcessingSettings {
}

export namespace AVAudioRecorder {
}

export namespace AVAudioSequencer {
  export enum AVMusicSequenceLoadOptions {
    _PreserveTracks = 0,
    _ChannelsToTracks = 1
  }

  export enum AVMusicTrackLoopCount {
    AVMusicTrackLoopCountForever = -1
  }

}

export namespace AVAudioSession {
  export enum AVAudioSessionActivationOptions {
    AVAudioSessionActivationOptionNone = 0
  }

  export enum CategoryOptions {
    MixWithOthers = 1,
    DuckOthers = 2,
    AllowBluetooth = 4,
    DefaultToSpeaker = 8,
    InterruptSpokenAudioAndMixWithOthers = 17,
    AllowBluetoothA2DP = 32,
    AllowAirPlay = 64
  }

  export enum IOType {
    NotSpecified = 0,
    Aggregated = 1
  }

  export enum InterruptionOptions {
    AVAudioSessionInterruptionOptionShouldResume = 1
  }

  export enum InterruptionType {
    Began = 1,
    Ended = 0
  }

  export enum PortOverride {
    None = 0,
    Speaker = 1936747378
  }

  export enum PromptStyle {
    None = 1852796517,
    Short = 1936224884,
    Normal = 1852992876
  }

  export enum RecordPermission {
    Undetermined = 1970168948,
    Denied = 1684369017,
    Granted = 1735552628
  }

  export enum RouteChangeReason {
    Unknown = 0,
    NewDeviceAvailable = 1,
    OldDeviceUnavailable = 2,
    CategoryChange = 3,
    Override = 4,
    WakeFromSleep = 6,
    NoSuitableRouteForCategory = 7,
    RouteConfigurationChange = 8
  }

  export enum RouteSharingPolicy {
    Default = 0,
    LongFormAudio = 1,
    LongForm = 1,
    Independent = 2,
    LongFormVideo = 3
  }

  export enum SetActiveOptions {
    AVAudioSessionSetActiveOptionNotifyOthersOnDeactivation = 1
  }

  export enum SilenceSecondaryAudioHintType {
    Begin = 1,
    End = 0
  }

}

export namespace AVAudioSettings {
  export enum AVAudioQuality {
    Min = 0,
    Low = 32,
    Medium = 64,
    High = 96,
    Max = 127
  }

}

export namespace AVAudioTime {
}

export namespace AVAudioUnit {
}

export namespace AVAudioUnitComponent {
}

export namespace AVAudioUnitDelay {
}

export namespace AVAudioUnitDistortion {
  export enum AVAudioUnitDistortionPreset {
    DrumsBitBrush = 0,
    DrumsBufferBeats = 1,
    DrumsLoFi = 2,
    MultiBrokenSpeaker = 3,
    MultiCellphoneConcert = 4,
    MultiDecimated1 = 5,
    MultiDecimated2 = 6,
    MultiDecimated3 = 7,
    MultiDecimated4 = 8,
    MultiDistortedFunk = 9,
    MultiDistortedCubed = 10,
    MultiDistortedSquared = 11,
    MultiEcho1 = 12,
    MultiEcho2 = 13,
    MultiEchoTight1 = 14,
    MultiEchoTight2 = 15,
    MultiEverythingIsBroken = 16,
    SpeechAlienChatter = 17,
    SpeechCosmicInterference = 18,
    SpeechGoldenPi = 19,
    SpeechRadioTower = 20,
    SpeechWaves = 21
  }

}

export namespace AVAudioUnitEQ {
  export enum AVAudioUnitEQFilterType {
    Parametric = 0,
    LowPass = 1,
    HighPass = 2,
    ResonantLowPass = 3,
    ResonantHighPass = 4,
    BandPass = 5,
    BandStop = 6,
    LowShelf = 7,
    HighShelf = 8,
    ResonantLowShelf = 9,
    ResonantHighShelf = 10
  }

}

export namespace AVAudioUnitEffect {
}

export namespace AVAudioUnitGenerator {
}

export namespace AVAudioUnitMIDIInstrument {
}

export namespace AVAudioUnitReverb {
  export enum AVAudioUnitReverbPreset {
    SmallRoom = 0,
    MediumRoom = 1,
    LargeRoom = 2,
    MediumHall = 3,
    LargeHall = 4,
    Plate = 5,
    MediumChamber = 6,
    LargeChamber = 7,
    Cathedral = 8,
    LargeRoom2 = 9,
    MediumHall2 = 10,
    MediumHall3 = 11,
    LargeHall2 = 12
  }

}

export namespace AVAudioUnitSampler {
}

export namespace AVAudioUnitTimeEffect {
}

export namespace AVAudioUnitTimePitch {
}

export namespace AVAudioUnitVarispeed {
}

export namespace AVCameraCalibrationData {
}

export namespace AVCaptureAudioDataOutput {
}

export namespace AVCaptureAudioPreviewOutput {
}

export namespace AVCaptureDataOutputSynchronizer {
}

export namespace AVCaptureDepthDataOutput {
}

export namespace AVCaptureDevice {
  export class DiscoverySession extends NSObject {
    static discoverySessionWithDeviceTypesMediaTypePosition(_: string[], mediaType?: string, position?: AVCaptureDevice.Position): AVCaptureDevice.DiscoverySession;
    devices: AVCaptureDevice[];
  }
  
  export class Format extends NSObject {
    autoFocusSystem: AVCaptureDevice.Format.AutoFocusSystem;
    formatDescription: any;
    mediaType: string;
    supportedColorSpaces: number[];
    videoSupportedFrameRateRanges: AVFrameRateRange[];
  }
  
  export class InputSource extends NSObject {
    inputSourceID: string;
    localizedName: string;
  }
  
  export class SystemPressureState extends NSObject {
    factors: AVCaptureDevice.SystemPressureState.Factors;
    level: string;
  }
  
  export namespace Format {
    export enum AutoFocusSystem {
      None = 0,
      ContrastDetection = 1,
      PhaseDetection = 2
    }
  }

  export namespace SystemPressureState {
    export enum Factors {
      None = 0,
      SystemTemperature = 1,
      PeakPower = 2,
      DepthModuleTemperature = 4
    }
  }

  export enum AVAuthorizationStatus {
    NotDetermined = 0,
    Restricted = 1,
    Denied = 2,
    Authorized = 3
  }

  export enum AVCaptureColorSpace {
    _sRGB = 0,
    _P3_D65 = 1
  }

  export enum AVCaptureVideoStabilizationMode {
    Off = 0,
    Standard = 1,
    Cinematic = 2,
    CinematicExtended = 3,
    Auto = -1
  }

  export enum AutoFocusRangeRestriction {
    None = 0,
    Near = 1,
    Far = 2
  }

  export enum ExposureMode {
    Locked = 0,
    AutoExpose = 1,
    ContinuousAutoExposure = 2,
    Custom = 3
  }

  export enum FlashMode {
    Off = 0,
    On = 1,
    Auto = 2
  }

  export enum FocusMode {
    Locked = 0,
    AutoFocus = 1,
    ContinuousAutoFocus = 2
  }

  export enum LensStabilizationStatus {
    Unsupported = 0,
    Off = 1,
    Active = 2,
    OutOfRange = 3,
    Unavailable = 4
  }

  export enum Position {
    Unspecified = 0,
    Back = 1,
    Front = 2
  }

  export enum TorchMode {
    Off = 0,
    On = 1,
    Auto = 2
  }

  export enum TransportControlsPlaybackMode {
    NotPlayingMode = 0,
    PlayingMode = 1
  }

  export enum WhiteBalanceMode {
    Locked = 0,
    AutoWhiteBalance = 1,
    ContinuousAutoWhiteBalance = 2
  }

}

export namespace AVCaptureFileOutput {
}

export namespace AVCaptureInput {
  export class Port extends NSObject {
    clock: any;
    isEnabled: boolean;
    setEnabled(_: boolean);
    formatDescription: any;
    input: AVCaptureInput;
    mediaType: string;
  }
  
}

export namespace AVCaptureMetadataOutput {
}

export namespace AVCaptureOutputBase {
  export namespace AVCaptureOutput {
    export enum DataDroppedReason {
      None = 0,
      LateData = 1,
      OutOfBuffers = 2,
      Discontinuity = 3
    }
  }

}

export namespace AVCapturePhotoOutput {
  export namespace AVCaptureDevice {
    export enum LensStabilizationStatus {
      Unsupported = 0,
      Off = 1,
      Active = 2,
      OutOfRange = 3,
      Unavailable = 4
    }
  }

  export enum QualityPrioritization {
    Speed = 1,
    Balanced = 2,
    Quality = 3
  }

}

export namespace AVCaptureSession {
  export enum AVCaptureVideoOrientation {
    Portrait = 1,
    PortraitUpsideDown = 2,
    LandscapeRight = 3,
    LandscapeLeft = 4
  }

  export enum AVVideoFieldMode {
    Both = 0,
    TopOnly = 1,
    BottomOnly = 2,
    Deinterlace = 3
  }

  export enum InterruptionReason {
    VideoDeviceNotAvailableInBackground = 1,
    AudioDeviceInUseByAnotherClient = 2,
    VideoDeviceInUseByAnotherClient = 3,
    VideoDeviceNotAvailableWithMultipleForegroundApps = 4,
    VideoDeviceNotAvailableDueToSystemPressure = 5
  }

}

export namespace AVCaptureSystemPressure {
}

export namespace AVCaptureVideoDataOutput {
}

export namespace AVCaptureVideoPreviewLayer {
}

export namespace AVCaptureView {
  export enum AVCaptureViewControlsStyle {
    Inline = 0,
    Floating = 1,
    InlineDeviceSelection = 2,
    Default = 0
  }

}

export namespace AVComposition {
}

export namespace AVCompositionTrack {
}

export namespace AVCompositionTrackSegment {
}

export namespace AVContentKeySession {
  export namespace AVContentKeyRequest {
    export enum Status {
      RequestingResponse = 0,
      ReceivedResponse = 1,
      Renewed = 2,
      Retried = 3,
      Cancelled = 4,
      Failed = 5
    }
  }

}

export namespace AVDepthData {
  export enum Accuracy {
    Relative = 0,
    Absolute = 1
  }

  export enum Quality {
    Low = 0,
    High = 1
  }

}

export namespace AVError {
  export enum AVError {
    Unknown = -11800,
    OutOfMemory = -11801,
    SessionNotRunning = -11803,
    DeviceAlreadyUsedByAnotherSession = -11804,
    NoDataCaptured = -11805,
    SessionConfigurationChanged = -11806,
    DiskFull = -11807,
    DeviceWasDisconnected = -11808,
    MediaChanged = -11809,
    MaximumDurationReached = -11810,
    MaximumFileSizeReached = -11811,
    MediaDiscontinuity = -11812,
    MaximumNumberOfSamplesForFileFormatReached = -11813,
    DeviceNotConnected = -11814,
    DeviceInUseByAnotherApplication = -11815,
    DeviceLockedForConfigurationByAnotherProcess = -11817,
    ExportFailed = -11820,
    DecodeFailed = -11821,
    InvalidSourceMedia = -11822,
    FileAlreadyExists = -11823,
    CompositionTrackSegmentsNotContiguous = -11824,
    InvalidCompositionTrackSegmentDuration = -11825,
    InvalidCompositionTrackSegmentSourceStartTime = -11826,
    InvalidCompositionTrackSegmentSourceDuration = -11827,
    FileFormatNotRecognized = -11828,
    FileFailedToParse = -11829,
    MaximumStillImageCaptureRequestsExceeded = -11830,
    ContentIsProtected = -11831,
    NoImageAtTime = -11832,
    DecoderNotFound = -11833,
    EncoderNotFound = -11834,
    ContentIsNotAuthorized = -11835,
    ApplicationIsNotAuthorized = -11836,
    OperationNotSupportedForAsset = -11838,
    DecoderTemporarilyUnavailable = -11839,
    EncoderTemporarilyUnavailable = -11840,
    InvalidVideoComposition = -11841,
    ReferenceForbiddenByReferencePolicy = -11842,
    InvalidOutputURLPathExtension = -11843,
    ScreenCaptureFailed = -11844,
    DisplayWasDisabled = -11845,
    TorchLevelUnavailable = -11846,
    IncompatibleAsset = -11848,
    FailedToLoadMediaData = -11849,
    ServerIncorrectlyConfigured = -11850,
    ApplicationIsNotAuthorizedToUseDevice = -11852,
    FailedToParse = -11853,
    FileTypeDoesNotSupportSampleReferences = -11854,
    UndecodableMediaData = -11855,
    AirPlayControllerRequiresInternet = -11856,
    AirPlayReceiverRequiresInternet = -11857,
    VideoCompositorFailed = -11858,
    CreateContentKeyRequestFailed = -11860,
    UnsupportedOutputSettings = -11861,
    OperationNotAllowed = -11862,
    ContentIsUnavailable = -11863,
    FormatUnsupported = -11864,
    MalformedDepth = -11865,
    ContentNotUpdated = -11866,
    NoLongerPlayable = -11867,
    NoCompatibleAlternatesForExternalDisplay = -11868,
    NoSourceTrack = -11869,
    ExternalPlaybackNotSupportedForAsset = -11870,
    OperationNotSupportedForPreset = -11871,
    SessionHardwareCostOverage = -11872,
    UnsupportedDeviceActiveFormat = -11873
  }

}

export namespace AVMIDIPlayer {
}

export namespace AVMediaFormat {
}

export namespace AVMediaSelection {
}

export namespace AVMediaSelectionGroup {
}

export namespace AVMetadataFormat {
}

export namespace AVMetadataIdentifiers {
}

export namespace AVMetadataItem {
}

export namespace AVMetadataObject {
}

export namespace AVMovie {
  export enum AVMovieWritingOptions {
    AddMovieHeaderToDestination = 0,
    TruncateDestinationToMovieHeaderOnly = 1
  }

}

export namespace AVMovieTrack {
}

export namespace AVOutputSettingsAssistant {
}

export namespace AVPictureInPictureController {
}

export namespace AVPlayer {
  export enum ActionAtItemEnd {
    Advance = 0,
    Pause = 1,
    None = 2
  }

  export enum HDRMode {
    HLG = 1,
    HDR10 = 2,
    DolbyVision = 4
  }

  export enum Status {
    Unknown = 0,
    ReadyToPlay = 1,
    Failed = 2
  }

  export enum TimeControlStatus {
    Paused = 0,
    WaitingToPlayAtSpecifiedRate = 1,
    Playing = 2
  }

}

export namespace AVPlayerItem {
  export enum Status {
    Unknown = 0,
    ReadyToPlay = 1,
    Failed = 2
  }

}

export namespace AVPlayerItemOutput {
}

export namespace AVPlayerItemProtectedContentAdditions {
  export enum AVContentAuthorizationStatus {
    Unknown = 0,
    Completed = 1,
    Cancelled = 2,
    TimedOut = 3,
    Busy = 4,
    NotAvailable = 5,
    NotPossible = 6
  }

}

export namespace AVPlayerItemTrack {
}

export namespace AVPlayerLayer {
}

export namespace AVPlayerLooper {
  export enum Status {
    Unknown = 0,
    Ready = 1,
    Failed = 2,
    Cancelled = 3
  }

}

export namespace AVPlayerMediaSelectionCriteria {
}

export namespace AVPlayerView {
  export enum AVPlayerViewControlsStyle {
    None = 0,
    Inline = 1,
    Floating = 2,
    Minimal = 3,
    Default = 1
  }

  export enum AVPlayerViewTrimResult {
    OKButton = 0,
    CancelButton = 1
  }

}

export namespace AVPortraitEffectsMatte {
}

export namespace AVQueuedSampleBufferRendering {
  export enum AVQueuedSampleBufferRenderingStatus {
    Unknown = 0,
    Rendering = 1,
    Failed = 2
  }

}

export namespace AVRouteDetector {
}

export namespace AVRoutePickerView {
  export enum AVRoutePickerViewButtonState {
    Normal = 0,
    NormalHighlighted = 1,
    Active = 2,
    ActiveHighlighted = 3
  }

}

export namespace AVSampleBufferAudioRenderer {
}

export namespace AVSampleBufferDisplayLayer {
}

export namespace AVSampleBufferGenerator {
  export namespace AVSampleBufferRequest {
    export enum Direction {
      Forward = 1,
      None = 0,
      Reverse = -1
    }
    export enum Mode {
      Immediate = 0,
      Scheduled = 1,
      Opportunistic = 2
    }
  }

}

export namespace AVSampleBufferRenderSynchronizer {
}

export namespace AVSampleCursor {
}

export namespace AVSemanticSegmentationMatte {
}

export namespace AVSpeechSynthesis {
  export enum AVSpeechBoundary {
    Immediate = 0,
    Word = 1
  }

  export enum AVSpeechSynthesisVoiceGender {
    Unspecified = 0,
    Male = 1,
    Female = 2
  }

  export enum AVSpeechSynthesisVoiceQuality {
    Default = 1,
    Enhanced = 2
  }

}

export namespace AVSynchronizedLayer {
}

export namespace AVTextStyleRule {
}

export namespace AVTimedMetadataGroup {
}

export namespace AVVideoCompositing {
}

export namespace AVVideoComposition {
}

export namespace AVVideoSettings {
}

// @ts-ignore
export namespace Array {
  export enum NSBinarySearchingOptions {
    FirstEqual = 256,
    LastEqual = 512,
    InsertionIndex = 1024
  }

}

export namespace ByteCountFormatter {
  export enum CountStyle {
    File = 0,
    Memory = 1,
    Decimal = 2,
    Binary = 3
  }

  export enum Units {
    Default = 0,
    Bytes = 1,
    KB = 2,
    MB = 4,
    GB = 8,
    TB = 16,
    PB = 32,
    EB = 64,
    ZB = 128,
    YBOrHigher = 65280,
    All = 65535
  }

}

export namespace CAAnimation {
}

export namespace CAConstraintLayoutManager {
  export enum CAConstraintAttribute {
    MinX = 0,
    MidX = 1,
    MaxX = 2,
    Width = 3,
    MinY = 4,
    MidY = 5,
    MaxY = 6,
    Height = 7
  }

}

export namespace CADisplayLink {
}

export namespace CAEDRMetadata {
}

export namespace CAEmitterCell {
}

export namespace CAEmitterLayer {
}

export namespace CAGradientLayer {
}

export namespace CALayer {
  export enum CAAutoresizingMask {
    NotSizable = 0,
    MinXMargin = 1,
    WidthSizable = 2,
    MaxXMargin = 4,
    MinYMargin = 8,
    HeightSizable = 16,
    MaxYMargin = 32
  }

  export enum CACornerMask {
    inXMinYCorner = 1,
    axXMinYCorner = 2,
    inXMaxYCorner = 4,
    axXMaxYCorner = 8
  }

  export enum CAEdgeAntialiasingMask {
    LeftEdge = 1,
    RightEdge = 2,
    BottomEdge = 4,
    TopEdge = 8
  }

}

export namespace CAMediaTiming {
}

export namespace CAMediaTimingFunction {
}

export namespace CAMetalLayer {
}

export namespace CARemoteLayerClient {
}

export namespace CARemoteLayerServer {
}

export namespace CARenderer {
}

export namespace CAReplicatorLayer {
}

export namespace CAScrollLayer {
}

export namespace CAShapeLayer {
}

export namespace CATextLayer {
}

export namespace CATiledLayer {
}

export namespace CATransaction {
}

export namespace CATransform3D {
}

export namespace CAValueFunction {
}

export namespace CFArray {
}

export namespace CFBag {
}

export namespace CFBase {
  export enum CFComparisonResult {
    LessThan = -1,
    EqualTo = 0,
    GreaterThan = 1
  }

}

export namespace CFBinaryHeap {
}

export namespace CFBundle {
}

export namespace CFByteOrder {
  export enum __CFByteOrder {
    Unknown = 0,
    LittleEndian = 1,
    BigEndian = 2
  }

}

export namespace CFCalendar {
  export enum CFCalendarUnit {
    Era = 2,
    Year = 4,
    Month = 8,
    Day = 16,
    Hour = 32,
    Minute = 64,
    Second = 128,
    Week = 256,
    Weekday = 512,
    WeekdayOrdinal = 1024,
    Quarter = 2048,
    WeekOfMonth = 4096,
    WeekOfYear = 8192,
    YearForWeekOfYear = 16384
  }

}

export namespace CFCharacterSet {
  export enum CFCharacterSetPredefinedSet {
    Control = 1,
    Whitespace = 2,
    WhitespaceAndNewline = 3,
    DecimalDigit = 4,
    Letter = 5,
    LowercaseLetter = 6,
    UppercaseLetter = 7,
    NonBase = 8,
    Decomposable = 9,
    AlphaNumeric = 10,
    Punctuation = 11,
    CapitalizedLetter = 13,
    Symbol = 14,
    Newline = 15,
    Illegal = 12
  }

}

export namespace CFData {
  export enum CFDataSearchFlags {
    Backwards = 1,
    Anchored = 2
  }

}

export namespace CFDate {
  export enum CFGregorianUnitFlags {
    UnitsYears = 1,
    UnitsMonths = 2,
    UnitsDays = 4,
    UnitsHours = 8,
    UnitsMinutes = 16,
    UnitsSeconds = 32,
    AllUnits = 16777215
  }

}

export namespace CFDateFormatter {
  export enum CFDateFormatterStyle {
    NoStyle = 0,
    ShortStyle = 1,
    MediumStyle = 2,
    LongStyle = 3,
    FullStyle = 4
  }

  export enum CFISO8601DateFormatOptions {
    WithYear = 1,
    WithMonth = 2,
    WithWeekOfYear = 4,
    WithDay = 16,
    WithTime = 32,
    WithTimeZone = 64,
    WithSpaceBetweenDateAndTime = 128,
    WithDashSeparatorInDate = 256,
    WithColonSeparatorInTime = 512,
    WithColonSeparatorInTimeZone = 1024,
    WithFractionalSeconds = 2048,
    WithFullDate = 275,
    WithFullTime = 1632,
    WithInternetDateTime = 1907
  }

}

export namespace CFDictionary {
}

export namespace CFError {
}

export namespace CFFileSecurity {
  export enum CFFileSecurityClearOptions {
    Owner = 1,
    Group = 2,
    Mode = 4,
    OwnerUUID = 8,
    GroupUUID = 16,
    AccessControlList = 32
  }

}

export namespace CFLocale {
  export enum CFLocaleLanguageDirection {
    Unknown = 0,
    LeftToRight = 1,
    RightToLeft = 2,
    TopToBottom = 3,
    BottomToTop = 4
  }

}

export namespace CFNotificationCenter {
  export enum CFNotificationSuspensionBehavior {
    Drop = 1,
    Coalesce = 2,
    Hold = 3,
    DeliverImmediately = 4
  }

}

export namespace CFNumber {
  export enum CFNumberType {
    SInt8Type = 1,
    SInt16Type = 2,
    SInt32Type = 3,
    SInt64Type = 4,
    Float32Type = 5,
    Float64Type = 6,
    CharType = 7,
    ShortType = 8,
    IntType = 9,
    LongType = 10,
    LongLongType = 11,
    FloatType = 12,
    DoubleType = 13,
    CFIndexType = 14,
    NSIntegerType = 15,
    CGFloatType = 16,
    MaxType = 16
  }

}

export namespace CFNumberFormatter {
  export enum CFNumberFormatterOptionFlags {
    kCFNumberFormatterParseIntegersOnly = 1
  }

  export enum CFNumberFormatterPadPosition {
    BeforePrefix = 0,
    AfterPrefix = 1,
    BeforeSuffix = 2,
    AfterSuffix = 3
  }

  export enum CFNumberFormatterRoundingMode {
    Ceiling = 0,
    Floor = 1,
    Down = 2,
    Up = 3,
    HalfEven = 4,
    HalfDown = 5,
    HalfUp = 6
  }

  export enum CFNumberFormatterStyle {
    NoStyle = 0,
    DecimalStyle = 1,
    CurrencyStyle = 2,
    PercentStyle = 3,
    ScientificStyle = 4,
    SpellOutStyle = 5,
    OrdinalStyle = 6,
    CurrencyISOCodeStyle = 8,
    CurrencyPluralStyle = 9,
    CurrencyAccountingStyle = 10
  }

}

export namespace CFPlugIn {
}

export namespace CFPreferences {
}

export namespace CFPropertyList {
  export enum CFPropertyListFormat {
    OpenStepFormat = 1,
    XMLFormat_v1_0 = 100,
    BinaryFormat_v1_0 = 200
  }

  export enum CFPropertyListMutabilityOptions {
    Immutable = 0,
    MutableContainers = 1,
    MutableContainersAndLeaves = 2
  }

}

export namespace CFRunLoop {
  export enum CFRunLoopActivity {
    Entry = 1,
    BeforeTimers = 2,
    BeforeSources = 4,
    BeforeWaiting = 32,
    AfterWaiting = 64,
    Exit = 128,
    AllActivities = 268435455
  }

  export enum CFRunLoopRunResult {
    Finished = 1,
    Stopped = 2,
    TimedOut = 3,
    HandledSource = 4
  }

}

export namespace CFSet {
}

export namespace CFSocket {
  export enum CFSocketCallBackType {
    NoCallBack = 0,
    ReadCallBack = 1,
    AcceptCallBack = 2,
    DataCallBack = 3,
    ConnectCallBack = 4,
    WriteCallBack = 8
  }

  export enum CFSocketError {
    Success = 0,
    Error = -1,
    Timeout = -2
  }

}

export namespace CFStream {
  export enum CFStreamErrorDomain {
    Custom = -1,
    POSIX = 1,
    MacOSStatus = 2
  }

  export enum CFStreamEventType {
    None = 0,
    OpenCompleted = 1,
    HasBytesAvailable = 2,
    CanAcceptBytes = 4,
    ErrorOccurred = 8,
    EndEncountered = 16
  }

  export enum CFStreamStatus {
    NotOpen = 0,
    Opening = 1,
    Open = 2,
    Reading = 3,
    Writing = 4,
    AtEnd = 5,
    Closed = 6,
    Error = 7
  }

}

export namespace CFString {
  export enum CFStringBuiltInEncodings {
    MacRoman = 0,
    WindowsLatin1 = 1280,
    ISOLatin1 = 513,
    NextStepLatin = 2817,
    ASCII = 1536,
    Unicode = 256,
    UTF8 = 134217984,
    NonLossyASCII = 3071,
    UTF16 = 256,
    UTF16BE = 268435712,
    UTF16LE = 335544576,
    UTF32 = 201326848,
    UTF32BE = 402653440,
    UTF32LE = 469762304
  }

  export enum CFStringCompareFlags {
    CaseInsensitive = 1,
    Backwards = 4,
    Anchored = 8,
    Nonliteral = 16,
    Localized = 32,
    Numerically = 64,
    DiacriticInsensitive = 128,
    WidthInsensitive = 256,
    ForcedOrdering = 512
  }

  export enum CFStringNormalizationForm {
    D = 0,
    KD = 1,
    C = 2,
    KC = 3
  }

}

export namespace CFStringEncodingExt {
  export enum CFStringEncodings {
    MacJapanese = 1,
    MacChineseTrad = 2,
    MacKorean = 3,
    MacArabic = 4,
    MacHebrew = 5,
    MacGreek = 6,
    MacCyrillic = 7,
    MacDevanagari = 9,
    MacGurmukhi = 10,
    MacGujarati = 11,
    MacOriya = 12,
    MacBengali = 13,
    MacTamil = 14,
    MacTelugu = 15,
    MacKannada = 16,
    MacMalayalam = 17,
    MacSinhalese = 18,
    MacBurmese = 19,
    MacKhmer = 20,
    MacThai = 21,
    MacLaotian = 22,
    MacGeorgian = 23,
    MacArmenian = 24,
    MacChineseSimp = 25,
    MacTibetan = 26,
    MacMongolian = 27,
    MacEthiopic = 28,
    MacCentralEurRoman = 29,
    MacVietnamese = 30,
    MacExtArabic = 31,
    MacSymbol = 33,
    MacDingbats = 34,
    MacTurkish = 35,
    MacCroatian = 36,
    MacIcelandic = 37,
    MacRomanian = 38,
    MacCeltic = 39,
    MacGaelic = 40,
    MacFarsi = 140,
    MacUkrainian = 152,
    MacInuit = 236,
    MacVT100 = 252,
    MacHFS = 255,
    ISOLatin2 = 514,
    ISOLatin3 = 515,
    ISOLatin4 = 516,
    ISOLatinCyrillic = 517,
    ISOLatinArabic = 518,
    ISOLatinGreek = 519,
    ISOLatinHebrew = 520,
    ISOLatin5 = 521,
    ISOLatin6 = 522,
    ISOLatinThai = 523,
    ISOLatin7 = 525,
    ISOLatin8 = 526,
    ISOLatin9 = 527,
    ISOLatin10 = 528,
    DOSLatinUS = 1024,
    DOSGreek = 1029,
    DOSBalticRim = 1030,
    DOSLatin1 = 1040,
    DOSGreek1 = 1041,
    DOSLatin2 = 1042,
    DOSCyrillic = 1043,
    DOSTurkish = 1044,
    DOSPortuguese = 1045,
    DOSIcelandic = 1046,
    DOSHebrew = 1047,
    DOSCanadianFrench = 1048,
    DOSArabic = 1049,
    DOSNordic = 1050,
    DOSRussian = 1051,
    DOSGreek2 = 1052,
    DOSThai = 1053,
    DOSJapanese = 1056,
    DOSChineseSimplif = 1057,
    DOSKorean = 1058,
    DOSChineseTrad = 1059,
    WindowsLatin2 = 1281,
    WindowsCyrillic = 1282,
    WindowsGreek = 1283,
    WindowsLatin5 = 1284,
    WindowsHebrew = 1285,
    WindowsArabic = 1286,
    WindowsBalticRim = 1287,
    WindowsVietnamese = 1288,
    WindowsKoreanJohab = 1296,
    ANSEL = 1537,
    JIS_X0201_76 = 1568,
    JIS_X0208_83 = 1569,
    JIS_X0208_90 = 1570,
    JIS_X0212_90 = 1571,
    JIS_C6226_78 = 1572,
    ShiftJIS_X0213 = 1576,
    ShiftJIS_X0213_MenKuTen = 1577,
    GB_2312_80 = 1584,
    GBK_95 = 1585,
    GB_18030_2000 = 1586,
    KSC_5601_87 = 1600,
    KSC_5601_92_Johab = 1601,
    CNS_11643_92_P1 = 1617,
    CNS_11643_92_P2 = 1618,
    CNS_11643_92_P3 = 1619,
    ISO_2022_JP = 2080,
    ISO_2022_JP_2 = 2081,
    ISO_2022_JP_1 = 2082,
    ISO_2022_JP_3 = 2083,
    ISO_2022_CN = 2096,
    ISO_2022_CN_EXT = 2097,
    ISO_2022_KR = 2112,
    EUC_JP = 2336,
    EUC_CN = 2352,
    EUC_TW = 2353,
    EUC_KR = 2368,
    ShiftJIS = 2561,
    KOI8_R = 2562,
    Big5 = 2563,
    MacRomanLatin1 = 2564,
    HZ_GB_2312 = 2565,
    Big5_HKSCS_1999 = 2566,
    VISCII = 2567,
    KOI8_U = 2568,
    Big5_E = 2569,
    NextStepJapanese = 2818,
    EBCDIC_US = 3073,
    EBCDIC_CP037 = 3074,
    UTF7 = 67109120,
    UTF7_IMAP = 2576,
    ShiftJIS_X0213_00 = 1576
  }

}

export namespace CFStringTokenizer {
  export enum CFStringTokenizerTokenType {
    None = 0,
    Normal = 1,
    HasSubTokensMask = 2,
    HasDerivedSubTokensMask = 4,
    HasHasNumbersMask = 8,
    HasNonLettersMask = 16,
    IsCJWordMask = 32
  }

}

export namespace CFTimeZone {
  export enum CFTimeZoneNameStyle {
    Standard = 0,
    ShortStandard = 1,
    DaylightSaving = 2,
    ShortDaylightSaving = 3,
    Generic = 4,
    ShortGeneric = 5
  }

}

export namespace CFURL {
  export enum CFURLBookmarkCreationOptions {
    MinimalBookmarkMask = 512,
    SuitableForBookmarkFile = 1024,
    WithSecurityScope = 2048,
    SecurityScopeAllowOnlyReadAccess = 4096,
    PreferFileIDResolutionMask = 256
  }

  export enum CFURLBookmarkResolutionOptions {
    URLBookmarkResolutionWithoutUIMask = 256,
    URLBookmarkResolutionWithoutMountingMask = 512,
    URLBookmarkResolutionWithSecurityScope = 1024,
    BookmarkResolutionWithoutUIMask = 256,
    BookmarkResolutionWithoutMountingMask = 512
  }

  export enum CFURLComponentType {
    Scheme = 1,
    NetLocation = 2,
    Path = 3,
    ResourceSpecifier = 4,
    User = 5,
    Password = 6,
    UserInfo = 7,
    Host = 8,
    Port = 9,
    ParameterString = 10,
    Query = 11,
    Fragment = 12
  }

  export enum CFURLPathStyle {
    POSIXPathStyle = 0,
    HFSPathStyle = 1,
    WindowsPathStyle = 2
  }

}

export namespace CFURLEnumerator {
  export enum CFURLEnumeratorOptions {
    DefaultBehavior = 0,
    DescendRecursively = 1,
    SkipInvisibles = 2,
    GenerateFileReferenceURLs = 4,
    SkipPackageContents = 8,
    IncludeDirectoriesPreOrder = 16,
    IncludeDirectoriesPostOrder = 32,
    GenerateRelativePathURLs = 64
  }

  export enum CFURLEnumeratorResult {
    Success = 1,
    End = 2,
    Error = 3,
    DirectoryPostOrderSuccess = 4
  }

}

export namespace CFUserNotification {
}

export namespace CFXMLNode {
  export enum CFXMLEntityTypeCode {
    Parameter = 0,
    ParsedInternal = 1,
    ParsedExternal = 2,
    Unparsed = 3,
    Character = 4
  }

  export enum CFXMLNodeTypeCode {
    Document = 1,
    Element = 2,
    Attribute = 3,
    ProcessingInstruction = 4,
    Comment = 5,
    Text = 6,
    CDATASection = 7,
    DocumentFragment = 8,
    Entity = 9,
    EntityReference = 10,
    DocumentType = 11,
    Whitespace = 12,
    Notation = 13,
    ElementTypeDeclaration = 14,
    AttributeListDeclaration = 15
  }

}

export namespace CFXMLParser {
  export enum CFXMLParserOptions {
    ValidateDocument = 1,
    SkipMetaData = 2,
    ReplacePhysicalEntities = 4,
    SkipWhitespace = 8,
    ResolveExternalEntities = 16,
    AddImpliedAttributes = 32,
    AllOptions = 16777215,
    NoOptions = 0
  }

  export enum CFXMLParserStatusCode {
    StatusParseNotBegun = -2,
    StatusParseInProgress = -1,
    StatusParseSuccessful = 0,
    ErrorUnexpectedEOF = 1,
    ErrorUnknownEncoding = 2,
    ErrorEncodingConversionFailure = 3,
    ErrorMalformedProcessingInstruction = 4,
    ErrorMalformedDTD = 5,
    ErrorMalformedName = 6,
    ErrorMalformedCDSect = 7,
    ErrorMalformedCloseTag = 8,
    ErrorMalformedStartTag = 9,
    ErrorMalformedDocument = 10,
    ErrorElementlessDocument = 11,
    ErrorMalformedComment = 12,
    ErrorMalformedCharacterReference = 13,
    ErrorMalformedParsedCharacterData = 14,
    ErrorNoData = 15
  }

}

export namespace CGAffineTransform {
}

export namespace CGColor {
}

export namespace CGColorConversionInfo {
  export enum CGColorConversionInfoTransformType {
    FromSpace = 0,
    ToSpace = 1,
    ApplySpace = 2
  }

}

export namespace CGColorSpace {
  export enum CGColorRenderingIntent {
    Default = 0,
    AbsoluteColorimetric = 1,
    RelativeColorimetric = 2,
    Perceptual = 3,
    Saturation = 4
  }

  export enum CGColorSpaceModel {
    Unknown = -1,
    Monochrome = 0,
    RGB = 1,
    CMYK = 2,
    Lab = 3,
    DeviceN = 4,
    Indexed = 5,
    Pattern = 6,
    XYZ = 7
  }

}

export namespace CGContext {
  export enum CGBlendMode {
    Normal = 0,
    Multiply = 1,
    Screen = 2,
    Overlay = 3,
    Darken = 4,
    Lighten = 5,
    ColorDodge = 6,
    ColorBurn = 7,
    SoftLight = 8,
    HardLight = 9,
    Difference = 10,
    Exclusion = 11,
    Hue = 12,
    Saturation = 13,
    Color = 14,
    Luminosity = 15,
    Clear = 16,
    Copy = 17,
    SourceIn = 18,
    SourceOut = 19,
    SourceAtop = 20,
    DestinationOver = 21,
    DestinationIn = 22,
    DestinationOut = 23,
    DestinationAtop = 24,
    XOR = 25,
    PlusDarker = 26,
    PlusLighter = 27
  }

  export enum CGInterpolationQuality {
    Default = 0,
    None = 1,
    Low = 2,
    Medium = 4,
    High = 3
  }

  export enum CGPathDrawingMode {
    Fill = 0,
    EOFill = 1,
    Stroke = 2,
    FillStroke = 3,
    EOFillStroke = 4
  }

  export enum CGTextDrawingMode {
    Fill = 0,
    Stroke = 1,
    FillStroke = 2,
    Invisible = 3,
    FillClip = 4,
    StrokeClip = 5,
    FillStrokeClip = 6,
    Clip = 7
  }

}

export namespace CGDirectDisplay {
  export enum CGCaptureOptions {
    Options = 0,
    Fill = 1
  }

}

export namespace CGDisplayConfiguration {
  export enum CGConfigureOption {
    ForAppOnly = 0,
    ForSession = 1,
    Permanently = 2
  }

  export enum CGDisplayChangeSummaryFlags {
    BeginConfigurationFlag = 1,
    MovedFlag = 2,
    SetMainFlag = 4,
    SetModeFlag = 8,
    AddFlag = 16,
    RemoveFlag = 32,
    EnabledFlag = 256,
    DisabledFlag = 512,
    MirrorFlag = 1024,
    UnMirrorFlag = 2048,
    DesktopShapeChangedFlag = 4096
  }

}

export namespace CGDisplayStream {
  export enum CGDisplayStreamFrameStatus {
    FrameComplete = 0,
    FrameIdle = 1,
    FrameBlank = 2,
    Stopped = 3
  }

  export enum CGDisplayStreamUpdateRectType {
    RefreshedRects = 0,
    MovedRects = 1,
    DirtyRects = 2,
    ReducedDirtyRects = 3
  }

}

export namespace CGError {
  export enum CGError {
    Success = 0,
    Failure = 1000,
    IllegalArgument = 1001,
    InvalidConnection = 1002,
    InvalidContext = 1003,
    CannotComplete = 1004,
    NotImplemented = 1006,
    RangeCheck = 1007,
    TypeCheck = 1008,
    InvalidOperation = 1010,
    NoneAvailable = 1011
  }

}

export namespace CGEventTypes {
  export enum CGEventField {
    MouseEventNumber = 0,
    MouseEventClickState = 1,
    MouseEventPressure = 2,
    MouseEventButtonNumber = 3,
    MouseEventDeltaX = 4,
    MouseEventDeltaY = 5,
    MouseEventInstantMouser = 6,
    MouseEventSubtype = 7,
    KeyboardEventAutorepeat = 8,
    KeyboardEventKeycode = 9,
    KeyboardEventKeyboardType = 10,
    ScrollWheelEventDeltaAxis1 = 11,
    ScrollWheelEventDeltaAxis2 = 12,
    ScrollWheelEventDeltaAxis3 = 13,
    ScrollWheelEventFixedPtDeltaAxis1 = 93,
    ScrollWheelEventFixedPtDeltaAxis2 = 94,
    ScrollWheelEventFixedPtDeltaAxis3 = 95,
    ScrollWheelEventPointDeltaAxis1 = 96,
    ScrollWheelEventPointDeltaAxis2 = 97,
    ScrollWheelEventPointDeltaAxis3 = 98,
    ScrollWheelEventScrollPhase = 99,
    ScrollWheelEventScrollCount = 100,
    ScrollWheelEventMomentumPhase = 123,
    ScrollWheelEventInstantMouser = 14,
    TabletEventPointX = 15,
    TabletEventPointY = 16,
    TabletEventPointZ = 17,
    TabletEventPointButtons = 18,
    TabletEventPointPressure = 19,
    TabletEventTiltX = 20,
    TabletEventTiltY = 21,
    TabletEventRotation = 22,
    TabletEventTangentialPressure = 23,
    TabletEventDeviceID = 24,
    TabletEventVendor1 = 25,
    TabletEventVendor2 = 26,
    TabletEventVendor3 = 27,
    TabletProximityEventVendorID = 28,
    TabletProximityEventTabletID = 29,
    TabletProximityEventPointerID = 30,
    TabletProximityEventDeviceID = 31,
    TabletProximityEventSystemTabletID = 32,
    TabletProximityEventVendorPointerType = 33,
    TabletProximityEventVendorPointerSerialNumber = 34,
    TabletProximityEventVendorUniqueID = 35,
    TabletProximityEventCapabilityMask = 36,
    TabletProximityEventPointerType = 37,
    TabletProximityEventEnterProximity = 38,
    EventTargetProcessSerialNumber = 39,
    EventTargetUnixProcessID = 40,
    EventSourceUnixProcessID = 41,
    EventSourceUserData = 42,
    EventSourceUserID = 43,
    EventSourceGroupID = 44,
    EventSourceStateID = 45,
    ScrollWheelEventIsContinuous = 88,
    MouseEventWindowUnderMousePointer = 91,
    MouseEventWindowUnderMousePointerThatCanHandleThisEvent = 92,
    EventUnacceleratedPointerMovementX = 170,
    EventUnacceleratedPointerMovementY = 171
  }

  export enum CGEventFlags {
    AlphaShift = 65536,
    Shift = 131072,
    Control = 262144,
    Alternate = 524288,
    Command = 1048576,
    Help = 4194304,
    SecondaryFn = 8388608,
    NumericPad = 2097152,
    NonCoalesced = 256
  }

  export enum CGEventMouseSubtype {
    Default = 0,
    TabletPoint = 1,
    TabletProximity = 2
  }

  export enum CGEventSourceStateID {
    Private = -1,
    CombinedSessionState = 0,
    HIDSystemState = 1
  }

  export enum CGEventTapLocation {
    HIDEventTap = 0,
    SessionEventTap = 1,
    AnnotatedSessionEventTap = 2
  }

  export enum CGEventTapOptions {
    Default = 0,
    ListenOnly = 1
  }

  export enum CGEventTapPlacement {
    HeadInsertEventTap = 0,
    TailAppendEventTap = 1
  }

  export enum CGEventType {
    Null = 0,
    LeftMouseDown = 1,
    LeftMouseUp = 2,
    RightMouseDown = 3,
    RightMouseUp = 4,
    MouseMoved = 5,
    LeftMouseDragged = 6,
    RightMouseDragged = 7,
    KeyDown = 10,
    KeyUp = 11,
    FlagsChanged = 12,
    ScrollWheel = 22,
    TabletPointer = 23,
    TabletProximity = 24,
    OtherMouseDown = 25,
    OtherMouseUp = 26,
    OtherMouseDragged = 27,
    TapDisabledByTimeout = 4294967294,
    TapDisabledByUserInput = 4294967295
  }

  export enum CGGesturePhase {
    None = 0,
    Began = 1,
    Changed = 2,
    Ended = 4,
    Cancelled = 8,
    MayBegin = 128
  }

  export enum CGMomentumScrollPhase {
    None = 0,
    Begin = 1,
    Continue = 2,
    End = 3
  }

  export enum CGMouseButton {
    Left = 0,
    Right = 1,
    Center = 2
  }

  export enum CGScrollEventUnit {
    Pixel = 0,
    Line = 1
  }

  export enum CGScrollPhase {
    Began = 1,
    Changed = 2,
    Ended = 4,
    Cancelled = 8,
    MayBegin = 128
  }

}

export namespace CGFont {
  export enum CGFontPostScriptFormat {
    e1 = 1,
    e3 = 3,
    e42 = 42
  }

  export enum CGGlyphDeprecatedEnum {
    in = 0,
    ax = 1
  }

}

export namespace CGGeometry {
  export enum CGRectEdge {
    inXEdge = 0,
    inYEdge = 1,
    axXEdge = 2,
    axYEdge = 3
  }

}

export namespace CGGradient {
  export enum CGGradientDrawingOptions {
    BeforeStartLocation = 1,
    AfterEndLocation = 2
  }

}

export namespace CGImage {
  export enum CGBitmapInfo {
    AlphaInfoMask = 31,
    FloatInfoMask = 3840,
    FloatComponents = 256,
    ByteOrderMask = 28672,
    ByteOrderDefault = 0,
    ByteOrder16Little = 4096,
    ByteOrder32Little = 8192,
    ByteOrder16Big = 12288,
    ByteOrder32Big = 16384
  }

  export enum CGImageAlphaInfo {
    None = 0,
    PremultipliedLast = 1,
    PremultipliedFirst = 2,
    Last = 3,
    First = 4,
    NoneSkipLast = 5,
    NoneSkipFirst = 6,
    Only = 7
  }

  export enum CGImageByteOrderInfo {
    rMask = 28672,
    rDefault = 0,
    r16Little = 4096,
    r32Little = 8192,
    r16Big = 12288,
    r32Big = 16384
  }

  export enum CGImagePixelFormatInfo {
    Mask = 983040,
    Packed = 0,
    RGB555 = 65536,
    RGB565 = 131072,
    RGB101010 = 196608,
    RGBCIF10 = 262144
  }

}

export namespace CGPDFContext {
  export enum CGPDFTagType {
    Document = 100,
    Part = 101,
    Art = 102,
    Section = 103,
    Div = 104,
    BlockQuote = 105,
    Caption = 106,
    TOC = 107,
    TOCI = 108,
    Index = 109,
    NonStructure = 110,
    Private = 111,
    Paragraph = 200,
    Header = 201,
    Header1 = 202,
    Header2 = 203,
    Header3 = 204,
    Header4 = 205,
    Header5 = 206,
    Header6 = 207,
    List = 300,
    ListItem = 301,
    Label = 302,
    ListBody = 303,
    Table = 400,
    TableRow = 401,
    TableHeaderCell = 402,
    TableDataCell = 403,
    TableHeader = 404,
    TableBody = 405,
    TableFooter = 406,
    Span = 500,
    Quote = 501,
    Note = 502,
    Reference = 503,
    Bibliography = 504,
    Code = 505,
    Link = 506,
    Annotation = 507,
    Ruby = 600,
    RubyBaseText = 601,
    RubyAnnotationText = 602,
    RubyPunctuation = 603,
    Warichu = 604,
    WarichuText = 605,
    WarichuPunctiation = 606,
    Figure = 700,
    Formula = 701,
    Form = 702
  }

}

export namespace CGPDFDocument {
  export enum CGPDFAccessPermissions {
    LowQualityPrinting = 1,
    HighQualityPrinting = 2,
    DocumentChanges = 4,
    DocumentAssembly = 8,
    ContentCopying = 16,
    ContentAccessibility = 32,
    Commenting = 64,
    FormFieldEntry = 128
  }

}

export namespace CGPDFObject {
  export enum CGPDFObjectType {
    Null = 1,
    Boolean = 2,
    Integer = 3,
    Real = 4,
    Name = 5,
    String = 6,
    Array = 7,
    Dictionary = 8,
    Stream = 9
  }

}

export namespace CGPDFPage {
  export enum CGPDFBox {
    MediaBox = 0,
    CropBox = 1,
    BleedBox = 2,
    TrimBox = 3,
    ArtBox = 4
  }

}

export namespace CGPDFStream {
  export enum CGPDFDataFormat {
    Raw = 0,
    JPEGEncoded = 1,
    JPEG2000 = 2
  }

}

export namespace CGPath {
  export enum CGLineCap {
    Butt = 0,
    Round = 1,
    Square = 2
  }

  export enum CGLineJoin {
    Miter = 0,
    Round = 1,
    Bevel = 2
  }

  export enum CGPathElementType {
    MoveToPoint = 0,
    AddLineToPoint = 1,
    AddQuadCurveToPoint = 2,
    AddCurveToPoint = 3,
    CloseSubpath = 4
  }

}

export namespace CGPattern {
  export enum CGPatternTiling {
    NoDistortion = 0,
    ConstantSpacingMinimalDistortion = 1,
    ConstantSpacing = 2
  }

}

export namespace CGRemoteOperation {
  export enum CGEventFilterMask {
    LocalMouseEvents = 1,
    LocalKeyboardEvents = 2,
    SystemDefinedEvents = 4
  }

  export enum CGEventSuppressionState {
    EventSuppressionStateSuppressionInterval = 0,
    EventSuppressionStateRemoteMouseDrag = 1,
    NumberOfEventSuppressionStates = 2
  }

  export enum CGScreenUpdateOperation {
    Refresh = 0,
    Move = 1,
    ReducedDirtyRectangleCount = 2147483648
  }

}

export namespace CGWindow {
  export enum CGWindowBackingType {
    Retained = 0,
    Nonretained = 1,
    Buffered = 2
  }

  export enum CGWindowImageOption {
    Default = 0,
    BoundsIgnoreFraming = 1,
    ShouldBeOpaque = 2,
    OnlyShadows = 4,
    BestResolution = 8,
    NominalResolution = 16
  }

  export enum CGWindowListOption {
    OptionAll = 0,
    OptionOnScreenOnly = 1,
    OptionOnScreenAboveWindow = 2,
    OptionOnScreenBelowWindow = 4,
    OptionIncludingWindow = 8,
    ExcludeDesktopElements = 16
  }

  export enum CGWindowSharingType {
    None = 0,
    ReadOnly = 1,
    ReadWrite = 2
  }

}

export namespace CGWindowLevel {
  export enum CGWindowLevelKey {
    BaseWindowLevelKey = 0,
    MinimumWindowLevelKey = 1,
    DesktopWindowLevelKey = 2,
    BackstopMenuLevelKey = 3,
    NormalWindowLevelKey = 4,
    FloatingWindowLevelKey = 5,
    TornOffMenuWindowLevelKey = 6,
    DockWindowLevelKey = 7,
    MainMenuWindowLevelKey = 8,
    StatusWindowLevelKey = 9,
    ModalPanelWindowLevelKey = 10,
    PopUpMenuWindowLevelKey = 11,
    DraggingWindowLevelKey = 12,
    ScreenSaverWindowLevelKey = 13,
    MaximumWindowLevelKey = 14,
    OverlayWindowLevelKey = 15,
    HelpWindowLevelKey = 16,
    UtilityWindowLevelKey = 17,
    DesktopIconWindowLevelKey = 18,
    CursorWindowLevelKey = 19,
    AssistiveTechHighWindowLevelKey = 20,
    NumberOfWindowLevelKeys = 21
  }

}

export namespace CIBarcodeDescriptor {
  export enum CIDataMatrixCodeECCVersion {
    n000 = 0,
    n050 = 50,
    n080 = 80,
    n100 = 100,
    n140 = 140,
    n200 = 200
  }

  export enum CIQRCodeErrorCorrectionLevel {
    L = 76,
    M = 77,
    Q = 81,
    H = 72
  }

}

export namespace CIColor {
}

export namespace CIContext {
}

export namespace CIDetector {
}

export namespace CIFeature {
}

export namespace CIFilter {
}

export namespace CIFilterConstructor {
}

export namespace CIFilterGenerator {
}

export namespace CIFilterShape {
}

export namespace CIImage {
}

export namespace CIImageAccumulator {
}

export namespace CIImageProvider {
}

export namespace CIKernel {
}

export namespace CIPlugIn {
}

export namespace CIRAWFilter {
}

export namespace CIRenderDestination {
  export enum CIRenderDestinationAlphaMode {
    None = 0,
    Premultiplied = 1,
    Unpremultiplied = 2
  }

}

export namespace CISampler {
}

export namespace CIVector {
}

export namespace CKAcceptSharesOperation {
}

export namespace CKAsset {
}

export namespace CKContainer {
  export enum CKAccountStatus {
    CouldNotDetermine = 0,
    Available = 1,
    Restricted = 2,
    NoAccount = 3
  }

  export enum CKContainer_Application_PermissionStatus {
    InitialState = 0,
    CouldNotComplete = 1,
    Denied = 2,
    Granted = 3
  }

  export enum CKContainer_Application_Permissions {
    CKApplicationPermissionUserDiscoverability = 1
  }

}

export namespace CKDatabase {
  export enum Scope {
    Public = 1,
    Private = 2,
    Shared = 3
  }

}

export namespace CKDatabaseOperation {
}

export namespace CKDiscoverAllUserIdentitiesOperation {
}

export namespace CKDiscoverUserIdentitiesOperation {
}

export namespace CKError {
  export enum CKErrorCode {
    InternalError = 1,
    PartialFailure = 2,
    NetworkUnavailable = 3,
    NetworkFailure = 4,
    BadContainer = 5,
    ServiceUnavailable = 6,
    RequestRateLimited = 7,
    MissingEntitlement = 8,
    NotAuthenticated = 9,
    PermissionFailure = 10,
    UnknownItem = 11,
    InvalidArguments = 12,
    ResultsTruncated = 13,
    ServerRecordChanged = 14,
    ServerRejectedRequest = 15,
    AssetFileNotFound = 16,
    AssetFileModified = 17,
    IncompatibleVersion = 18,
    ConstraintViolation = 19,
    OperationCancelled = 20,
    ChangeTokenExpired = 21,
    BatchRequestFailed = 22,
    ZoneBusy = 23,
    BadDatabase = 24,
    QuotaExceeded = 25,
    ZoneNotFound = 26,
    LimitExceeded = 27,
    UserDeletedZone = 28,
    TooManyParticipants = 29,
    AlreadyShared = 30,
    ReferenceViolation = 31,
    ManagedAccountRestricted = 32,
    ParticipantMayNeedVerification = 33,
    ServerResponseLost = 34,
    AssetNotAvailable = 35
  }

}

export namespace CKFetchDatabaseChangesOperation {
}

export namespace CKFetchRecordZoneChangesOperation {
  export class ZoneConfiguration extends NSObject {
    desiredKeys: string[];
    setDesiredKeys(_: string[]);
    previousServerChangeToken: CKServerChangeToken;
    setPreviousServerChangeToken(_: CKServerChangeToken);
    resultsLimit: number;
    setResultsLimit(_: number);
  }
  
}

export namespace CKFetchRecordZonesOperation {
}

export namespace CKFetchRecordsOperation {
}

export namespace CKFetchShareMetadataOperation {
}

export namespace CKFetchShareParticipantsOperation {
}

export namespace CKFetchSubscriptionsOperation {
}

export namespace CKFetchWebAuthTokenOperation {
}

export namespace CKLocationSortDescriptor {
}

export namespace CKModifyRecordZonesOperation {
}

export namespace CKModifyRecordsOperation {
  export enum RecordSavePolicy {
    IfServerRecordUnchanged = 0,
    ChangedKeys = 1,
    AllKeys = 2
  }

}

export namespace CKModifySubscriptionsOperation {
}

export namespace CKNotification {
  export class ID extends NSObject {
  }
  
  export namespace CKQueryNotification {
    export enum Reason {
      Created = 1,
      Updated = 2,
      Deleted = 3
    }
  }

  export enum NotificationType {
    Query = 1,
    RecordZone = 2,
    ReadNotification = 3,
    Database = 4
  }

}

export namespace CKOperation {
  export class Configuration extends NSObject {
    allowsCellularAccess: boolean;
    setAllowsCellularAccess(_: boolean);
    container: CKContainer;
    setContainer(_: CKContainer);
    isLongLived: boolean;
    setLongLived(_: boolean);
    qualityOfService: NSObjCRuntime.QualityOfService;
    setQualityOfService(_: NSObjCRuntime.QualityOfService);
    timeoutIntervalForRequest: number;
    setTimeoutIntervalForRequest(_: number);
    timeoutIntervalForResource: number;
    setTimeoutIntervalForResource(_: number);
  }
  
}

export namespace CKOperationGroup {
  export enum TransferSize {
    Unknown = 0,
    Kilobytes = 1,
    Megabytes = 2,
    TensOfMegabytes = 3,
    HundredsOfMegabytes = 4,
    Gigabytes = 5,
    TensOfGigabytes = 6,
    HundredsOfGigabytes = 7
  }

}

export namespace CKQuery {
}

export namespace CKQueryOperation {
  export class Cursor extends NSObject {
  }
  
}

export namespace CKRecord {
  export class ID extends NSObject {
    recordName: string;
    zoneID: CKRecordZone.ID;
    static initWithRecordName(_: string): CKRecord.ID;
    static initWithRecordNameZoneID(_: string, zoneID: CKRecordZone.ID): CKRecord.ID;
  }
  
  export class Reference extends NSObject {
    recordID: CKRecord.ID;
    referenceAction: CKRecord.Reference.CKRecord_Reference_Action;
    static initWithRecordAction(_: CKRecord, action: CKRecord.Reference.CKRecord_Reference_Action): CKRecord.Reference;
    static initWithRecordIDAction(_: CKRecord.ID, action: CKRecord.Reference.CKRecord_Reference_Action): CKRecord.Reference;
  }
  
}

export namespace CKRecordZone {
  export class ID extends NSObject {
    ownerName: string;
    zoneName: string;
    static initWithZoneNameOwnerName(_: string, ownerName: string): CKRecordZone.ID;
  }
  
  export enum Capabilities {
    FetchChanges = 1,
    Atomic = 2,
    Sharing = 4
  }

}

export namespace CKShare {
  export class Metadata extends NSObject {
    containerIdentifier: string;
    ownerIdentity: CKUserIdentity;
    participantPermission: CKShare.Participant.CKShare_Participant_Permission;
    participantRole: CKShare.Participant.CKShare_Participant_Role;
    participantStatus: CKShare.Participant.CKShare_Participant_AcceptanceStatus;
    rootRecord: CKRecord;
    rootRecordID: CKRecord.ID;
    share: CKShare;
  }
  
  export class Participant extends NSObject {
    acceptanceStatus: CKShare.Participant.CKShare_Participant_AcceptanceStatus;
    permission: CKShare.Participant.CKShare_Participant_Permission;
    setPermission(_: CKShare.Participant.CKShare_Participant_Permission);
    role: CKShare.Participant.CKShare_Participant_Role;
    setRole(_: CKShare.Participant.CKShare_Participant_Role);
    userIdentity: CKUserIdentity;
  }
  
}

export namespace CKSubscription {
  export class NotificationInfo extends NSObject {
    alertActionLocalizationKey: string;
    setAlertActionLocalizationKey(_: string);
    alertBody: string;
    setAlertBody(_: string);
    alertLaunchImage: string;
    setAlertLaunchImage(_: string);
    alertLocalizationKey: string;
    setAlertLocalizationKey(_: string);
    category: string;
    setCategory(_: string);
    collapseIDKey: string;
    setCollapseIDKey(_: string);
    desiredKeys: string[];
    setDesiredKeys(_: string[]);
    shouldBadge: boolean;
    setShouldBadge(_: boolean);
    shouldSendContentAvailable: boolean;
    setShouldSendContentAvailable(_: boolean);
    shouldSendMutableContent: boolean;
    setShouldSendMutableContent(_: boolean);
    soundName: string;
    setSoundName(_: string);
    subtitle: string;
    setSubtitle(_: string);
    subtitleLocalizationKey: string;
    setSubtitleLocalizationKey(_: string);
    title: string;
    setTitle(_: string);
    titleLocalizationKey: string;
    setTitleLocalizationKey(_: string);
  }
  
  export namespace CKQuerySubscription {
    export enum Options {
      RecordCreation = 1,
      RecordUpdate = 2,
      RecordDeletion = 4,
      ce = 8
    }
  }

  export enum SubscriptionType {
    Query = 1,
    RecordZone = 2,
    Database = 3
  }

}

export namespace CKUserIdentity {
  export class LookupInfo extends NSObject {
    static lookupInfosWithEmails(_: string[]): CKUserIdentity.LookupInfo[];
    static lookupInfosWithPhoneNumbers(_: string[]): CKUserIdentity.LookupInfo[];
    static lookupInfosWithRecordIDs(_: CKRecord.ID[]): CKUserIdentity.LookupInfo[];
    emailAddress: string;
    phoneNumber: string;
    userRecordID: CKRecord.ID;
    static initWithEmailAddress(_: string): CKUserIdentity.LookupInfo;
    static initWithPhoneNumber(_: string): CKUserIdentity.LookupInfo;
    static initWithUserRecordID(_: CKRecord.ID): CKUserIdentity.LookupInfo;
  }
  
}

export namespace CMFormatDescription {
}

export namespace CMFormatDescriptionBridge {
}

export namespace CMIOSampleBuffer {
}

export namespace CMMemoryPool {
}

export namespace CMMetadata {
}

export namespace CMSampleBuffer {
}

export namespace CMSync {
}

export namespace CMTextMarkup {
}

export namespace CMTime {
  export enum CMTimeFlags {
    _Valid = 1,
    _HasBeenRounded = 2,
    _PositiveInfinity = 4,
    _NegativeInfinity = 8,
    _Indefinite = 16,
    _ImpliedValueFlagsMask = 28
  }

  export enum CMTimeRoundingMethod {
    _RoundHalfAwayFromZero = 1,
    _RoundTowardZero = 2,
    _RoundAwayFromZero = 3,
    _QuickTime = 4,
    _RoundTowardPositiveInfinity = 5,
    _RoundTowardNegativeInfinity = 6,
    _Default = 1
  }

}

export namespace CMTimeRange {
}

export namespace Calendar {
  export enum Options {
    WrapComponents = 1,
    MatchStrictly = 2,
    SearchBackwards = 4,
    MatchPreviousTimePreservingSmallerUnits = 256,
    MatchNextTimePreservingSmallerUnits = 512,
    MatchNextTime = 1024,
    MatchFirst = 4096,
    MatchLast = 8192
  }

  export enum Unit {
    CalendarUnitEra = 2,
    CalendarUnitYear = 4,
    CalendarUnitMonth = 8,
    CalendarUnitDay = 16,
    CalendarUnitHour = 32,
    CalendarUnitMinute = 64,
    CalendarUnitSecond = 128,
    CalendarUnitWeekday = 512,
    CalendarUnitWeekdayOrdinal = 1024,
    CalendarUnitQuarter = 2048,
    CalendarUnitWeekOfMonth = 4096,
    CalendarUnitWeekOfYear = 8192,
    CalendarUnitYearForWeekOfYear = 16384,
    CalendarUnitNanosecond = 32768,
    CalendarUnitCalendar = 1048576,
    CalendarUnitTimeZone = 2097152,
    EraCalendarUnit = 2,
    YearCalendarUnit = 4,
    MonthCalendarUnit = 8,
    DayCalendarUnit = 16,
    HourCalendarUnit = 32,
    MinuteCalendarUnit = 64,
    SecondCalendarUnit = 128,
    WeekCalendarUnit = 256,
    WeekdayCalendarUnit = 512,
    WeekdayOrdinalCalendarUnit = 1024,
    QuarterCalendarUnit = 2048,
    WeekOfMonthCalendarUnit = 4096,
    WeekOfYearCalendarUnit = 8192,
    YearForWeekOfYearCalendarUnit = 16384,
    CalendarCalendarUnit = 1048576,
    TimeZoneCalendarUnit = 2097152
  }

}

export namespace CollectionDifference {
  export enum NSOrderedCollectionDifferenceCalculationOptions {
    OmitInsertedObjects = 1,
    OmitRemovedObjects = 2,
    InferMoves = 4
  }

}

export namespace CoreDataDefines {
}

export namespace CoreDataErrors {
}

export namespace Data {
  export enum Base64DecodingOptions {
    NSDataBase64DecodingIgnoreUnknownCharacters = 1
  }

  export enum Base64EncodingOptions {
    ing64CharacterLineLength = 1,
    ing76CharacterLineLength = 2,
    ingEndLineWithCarriageReturn = 16,
    ingEndLineWithLineFeed = 32
  }

  export enum CompressionAlgorithm {
    LZFSE = 0,
    LZ4 = 1,
    LZMA = 2,
    Zlib = 3
  }

  export enum ReadingOptions {
    DataReadingMappedIfSafe = 1,
    DataReadingUncached = 2,
    DataReadingMappedAlways = 8,
    DataReadingMapped = 1,
    MappedRead = 1,
    UncachedRead = 2
  }

  export enum SearchOptions {
    Backwards = 1,
    Anchored = 2
  }

  export enum WritingOptions {
    DataWritingAtomic = 1,
    DataWritingWithoutOverwriting = 2,
    DataWritingFileProtectionNone = 268435456,
    DataWritingFileProtectionComplete = 536870912,
    DataWritingFileProtectionCompleteUnlessOpen = 805306368,
    DataWritingFileProtectionCompleteUntilFirstUserAuthentication = 1073741824,
    DataWritingFileProtectionMask = 4026531840,
    AtomicWrite = 1
  }

}

export namespace DateComponentsFormatter {
  export enum UnitsStyle {
    Positional = 0,
    Abbreviated = 1,
    Short = 2,
    Full = 3,
    SpellOut = 4,
    Brief = 5
  }

  export enum ZeroFormattingBehavior {
    None = 0,
    Default = 1,
    DropLeading = 2,
    DropMiddle = 4,
    DropTrailing = 8,
    DropAll = 14,
    Pad = 65536
  }

}

export namespace DateFormatter {
  export enum Behavior {
    rDefault = 0,
    r10_0 = 1000,
    r10_4 = 1040
  }

  export enum Style {
    NoStyle = 0,
    ShortStyle = 1,
    MediumStyle = 2,
    LongStyle = 3,
    FullStyle = 4
  }

}

export namespace DateIntervalFormatter {
  export enum Style {
    NoStyle = 0,
    ShortStyle = 1,
    MediumStyle = 2,
    LongStyle = 3,
    FullStyle = 4
  }

}

export namespace Decimal {
  export enum CalculationError {
    NoError = 0,
    LossOfPrecision = 1,
    Underflow = 2,
    Overflow = 3,
    DivideByZero = 4
  }

  export enum RoundingMode {
    Plain = 0,
    Down = 1,
    Up = 2,
    Bankers = 3
  }

}

export namespace DistributedNotificationCenter {
  export enum Options {
    DeliverImmediately = 1,
    PostToAllSessions = 2
  }

  export enum SuspensionBehavior {
    Drop = 1,
    Coalesce = 2,
    Hold = 3,
    DeliverImmediately = 4
  }

}

export namespace EnergyFormatter {
  export enum Unit {
    Joule = 11,
    Kilojoule = 14,
    Calorie = 1793,
    Kilocalorie = 1794
  }

}

export namespace FileManager {
  export class DirectoryEnumerator<ObjectType> extends NSEnumerator<ObjectType> {
    directoryAttributes: Map<string, any>;
    fileAttributes: Map<string, any>;
    isEnumeratingDirectoryPostOrder: boolean;
    level: number;
    skipDescendants(): void;
    skipDescendents(): void;
  }
  
  export enum DirectoryEnumerationOptions {
    SkipsSubdirectoryDescendants = 1,
    SkipsPackageDescendants = 2,
    SkipsHiddenFiles = 4,
    IncludesDirectoriesPostOrder = 8,
    ProducesRelativePathURLs = 16
  }

  export enum ItemReplacementOptions {
    UsingNewMetadataOnly = 1,
    WithoutDeletingBackupItem = 2
  }

  export enum SearchPathDirectory {
    ApplicationDirectory = 1,
    DemoApplicationDirectory = 2,
    DeveloperApplicationDirectory = 3,
    AdminApplicationDirectory = 4,
    LibraryDirectory = 5,
    DeveloperDirectory = 6,
    UserDirectory = 7,
    DocumentationDirectory = 8,
    DocumentDirectory = 9,
    CoreServiceDirectory = 10,
    AutosavedInformationDirectory = 11,
    DesktopDirectory = 12,
    CachesDirectory = 13,
    ApplicationSupportDirectory = 14,
    DownloadsDirectory = 15,
    InputMethodsDirectory = 16,
    MoviesDirectory = 17,
    MusicDirectory = 18,
    PicturesDirectory = 19,
    PrinterDescriptionDirectory = 20,
    SharedPublicDirectory = 21,
    PreferencePanesDirectory = 22,
    ApplicationScriptsDirectory = 23,
    ItemReplacementDirectory = 99,
    AllApplicationsDirectory = 100,
    AllLibrariesDirectory = 101,
    TrashDirectory = 102
  }

  export enum SearchPathDomainMask {
    UserDomainMask = 1,
    LocalDomainMask = 2,
    NetworkDomainMask = 4,
    SystemDomainMask = 8,
    AllDomainsMask = 65535
  }

  export enum URLRelationship {
    Contains = 0,
    Same = 1,
    Other = 2
  }

  export enum UnmountOptions {
    AllPartitionsAndEjectDisk = 1,
    WithoutUI = 2
  }

  export enum VolumeEnumerationOptions {
    SkipHiddenVolumes = 2,
    ProduceFileReferenceURLs = 4
  }

}

export namespace FileWrapper {
  export enum ReadingOptions {
    Immediate = 1,
    WithoutMapping = 2
  }

  export enum WritingOptions {
    Atomic = 1,
    WithNameUpdating = 2
  }

}

export namespace Formatter {
  export enum Context {
    Unknown = 0,
    Dynamic = 1,
    Standalone = 2,
    ListItem = 3,
    BeginningOfSentence = 4,
    MiddleOfSentence = 5
  }

  export enum UnitStyle {
    Short = 1,
    Medium = 2,
    Long = 3
  }

}

export namespace HTTPCookieStorage {
  export namespace HTTPCookie {
    export enum AcceptPolicy {
      Always = 0,
      Never = 1,
      OnlyFromMainDocumentDomain = 2
    }
  }

}

export namespace IKCameraDeviceView {
  export enum IKCameraDeviceViewDisplayMode {
    None = -1,
    Table = 0,
    Icon = 1
  }

  export enum IKCameraDeviceViewTransferMode {
    FileBased = 0,
    MemoryBased = 1
  }

}

export namespace IKDeviceBrowserView {
  export enum IKDeviceBrowserViewDisplayMode {
    Table = 0,
    Outline = 1,
    Icon = 2
  }

}

export namespace IKFilterBrowserPanel {
}

export namespace IKFilterBrowserView {
}

export namespace IKFilterUI {
}

export namespace IKFilterUIView {
}

export namespace IKImageBrowserCell {
  export enum IKImageBrowserCellState {
    NoImage = 0,
    Invalid = 1,
    Ready = 2
  }

}

export namespace IKImageBrowserView {
  export enum IKImageBrowserDropOperation {
    On = 0,
    Before = 1
  }

}

export namespace IKImageEditPanel {
}

export namespace IKImageView {
}

export namespace IKPictureTaker {
}

export namespace IKSaveOptions {
}

export namespace IKScannerDeviceView {
  export enum IKScannerDeviceViewDisplayMode {
    None = -1,
    Simple = 0,
    Advanced = 1
  }

  export enum IKScannerDeviceViewTransferMode {
    FileBased = 0,
    MemoryBased = 1
  }

}

export namespace IKSlideshow {
}

export namespace ISO8601DateFormatter {
  export enum Options {
    WithYear = 1,
    WithMonth = 2,
    WithWeekOfYear = 4,
    WithDay = 16,
    WithTime = 32,
    WithTimeZone = 64,
    WithSpaceBetweenDateAndTime = 128,
    WithDashSeparatorInDate = 256,
    WithColonSeparatorInTime = 512,
    WithColonSeparatorInTimeZone = 1024,
    WithFractionalSeconds = 2048,
    WithFullDate = 275,
    WithFullTime = 1632,
    WithInternetDateTime = 1907
  }

}

export namespace ImageKitDeprecated {
}

export namespace JSONSerialization {
  export enum ReadingOptions {
    MutableContainers = 1,
    MutableLeaves = 2,
    FragmentsAllowed = 4,
    AllowFragments = 4
  }

  export enum WritingOptions {
    PrettyPrinted = 1,
    SortedKeys = 2,
    FragmentsAllowed = 4,
    WithoutEscapingSlashes = 8
  }

}

export namespace LengthFormatter {
  export enum Unit {
    Millimeter = 8,
    Centimeter = 9,
    Meter = 11,
    Kilometer = 14,
    Inch = 1281,
    Foot = 1282,
    Yard = 1283,
    Mile = 1284
  }

}

export namespace Locale {
  export enum LanguageDirection {
    Unknown = 0,
    LeftToRight = 1,
    RightToLeft = 2,
    TopToBottom = 3,
    BottomToTop = 4
  }

}

export namespace MassFormatter {
  export enum Unit {
    Gram = 11,
    Kilogram = 14,
    Ounce = 1537,
    Pound = 1538,
    Stone = 1539
  }

}

export namespace MeasurementFormatter {
  export enum UnitOptions {
    ProvidedUnit = 1,
    NaturalScale = 2,
    TemperatureWithoutUnit = 4
  }

}

export namespace NSATSTypesetter {
}

export namespace NSAccessibility {
  export enum AnnotationPosition {
    FullRange = 0,
    Start = 1,
    End = 2
  }

  export enum Orientation {
    Unknown = 0,
    Vertical = 1,
    Horizontal = 2
  }

  export enum RulerMarkerType {
    Unknown = 0,
    TabStopLeft = 1,
    TabStopRight = 2,
    TabStopCenter = 3,
    TabStopDecimal = 4,
    IndentHead = 5,
    IndentTail = 6,
    IndentFirstLine = 7
  }

  export enum SortDirection {
    Unknown = 0,
    Ascending = 1,
    Descending = 2
  }

  export enum Units {
    Unknown = 0,
    Inches = 1,
    Centimeters = 2,
    Points = 3,
    Picas = 4
  }

}

export namespace NSAccessibilityConstants {
  export namespace NSAccessibility {
    export enum AnnotationPosition {
      FullRange = 0,
      Start = 1,
      End = 2
    }
    export enum Orientation {
      Unknown = 0,
      Vertical = 1,
      Horizontal = 2
    }
    export enum RulerMarkerType {
      Unknown = 0,
      TabStopLeft = 1,
      TabStopRight = 2,
      TabStopCenter = 3,
      TabStopDecimal = 4,
      IndentHead = 5,
      IndentTail = 6,
      IndentFirstLine = 7
    }
    export enum SortDirection {
      Unknown = 0,
      Ascending = 1,
      Descending = 2
    }
    export enum Units {
      Unknown = 0,
      Inches = 1,
      Centimeters = 2,
      Points = 3,
      Picas = 4
    }
  }

  export enum NSAccessibilityPriorityLevel {
    Low = 10,
    Medium = 50,
    High = 90
  }

}

export namespace NSAccessibilityCustomAction {
}

export namespace NSAccessibilityCustomRotor {
  export class ItemResult extends NSObject {
    customLabel: string;
    setCustomLabel(_: string);
    itemLoadingToken: any;
    targetElement: any;
    targetRange: NSRange;
    setTargetRange(_: NSRange);
    static initWithItemLoadingTokenCustomLabel(_: any, customLabel: string): NSAccessibilityCustomRotor.ItemResult;
    static initWithTargetElement(_: any): NSAccessibilityCustomRotor.ItemResult;
  }
  
  export class SearchParameters extends NSObject {
    currentItem: NSAccessibilityCustomRotor.ItemResult;
    setCurrentItem(_: NSAccessibilityCustomRotor.ItemResult);
    filterString: string;
    setFilterString(_: string);
    searchDirection: NSAccessibilityCustomRotor.SearchDirection;
    setSearchDirection(_: NSAccessibilityCustomRotor.SearchDirection);
  }
  
  export enum RotorType {
    Custom = 0,
    Any = 1,
    Annotation = 2,
    BoldText = 3,
    Heading = 4,
    HeadingLevel1 = 5,
    HeadingLevel2 = 6,
    HeadingLevel3 = 7,
    HeadingLevel4 = 8,
    HeadingLevel5 = 9,
    HeadingLevel6 = 10,
    Image = 11,
    ItalicText = 12,
    Landmark = 13,
    Link = 14,
    List = 15,
    MisspelledWord = 16,
    Table = 17,
    TextField = 18,
    UnderlinedText = 19,
    VisitedLink = 20
  }

  export enum SearchDirection {
    Previous = 0,
    Next = 1
  }

}

export namespace NSAccessibilityElement {
}

export namespace AffineTransform {
}

export namespace NSAlert {
  export enum Style {
    Warning = 0,
    Informational = 1,
    Critical = 2
  }

}

export namespace NSAlignmentFeedbackFilter {
}

export namespace NSAnimation {
  export enum BlockingMode {
    Blocking = 0,
    Nonblocking = 1,
    NonblockingThreaded = 2
  }

  export enum Curve {
    EaseInOut = 0,
    EaseIn = 1,
    EaseOut = 2,
    Linear = 3
  }

}

export namespace NSAnimationContext {
}

export namespace NSAppearance {
}

export namespace NSAppleEventDescriptor {
  export enum SendOptions {
    NoReply = 1,
    QueueReply = 2,
    WaitForReply = 3,
    NeverInteract = 16,
    CanInteract = 32,
    AlwaysInteract = 48,
    CanSwitchLayer = 64,
    DontRecord = 4096,
    DontExecute = 8192,
    DontAnnotate = 65536,
    DefaultOptions = 35
  }

}

export namespace NSAppleEventManager {
}

export namespace NSAppleScript {
}

export namespace NSApplication {
  export enum ActivationOptions {
    AllWindows = 1,
    IgnoringOtherApps = 2
  }

  export enum ActivationPolicy {
    Regular = 0,
    Accessory = 1,
    Prohibited = 2
  }

  export enum DelegateReply {
    Success = 0,
    Cancel = 1,
    Failure = 2
  }

  export enum OcclusionState {
    NSApplicationOcclusionStateVisible = 2
  }

  export enum PresentationOptions {
    Default = 0,
    AutoHideDock = 1,
    HideDock = 2,
    AutoHideMenuBar = 4,
    HideMenuBar = 8,
    DisableAppleMenu = 16,
    DisableProcessSwitching = 32,
    DisableForceQuit = 64,
    DisableSessionTermination = 128,
    DisableHideApplication = 256,
    DisableMenuBarTransparency = 512,
    FullScreen = 1024,
    AutoHideToolbar = 2048,
    DisableCursorLocationAssistance = 4096
  }

  export enum PrintReply {
    Cancelled = 0,
    Success = 1,
    Failure = 3,
    ReplyLater = 2
  }

  export enum RemoteNotificationType {
    None = 0,
    Badge = 1,
    Sound = 2,
    Alert = 4
  }

  export enum RequestUserAttentionType {
    CriticalRequest = 0,
    InformationalRequest = 10
  }

  export enum TerminateReply {
    Cancel = 0,
    Now = 1,
    Later = 2
  }

  export enum WindowListOptions {
    NSWindowListOrderedFrontToBack = 1
  }

}

export namespace NSArrayController {
}

export namespace NSAtomicStore {
}

export namespace NSAtomicStoreCacheNode {
}

export namespace NSAttributeDescription {
  export enum NSAttributeType {
    UndefinedAttributeType = 0,
    Integer16AttributeType = 100,
    Integer32AttributeType = 200,
    Integer64AttributeType = 300,
    DecimalAttributeType = 400,
    DoubleAttributeType = 500,
    FloatAttributeType = 600,
    StringAttributeType = 700,
    BooleanAttributeType = 800,
    DateAttributeType = 900,
    BinaryDataAttributeType = 1000,
    UUIDAttributeType = 1100,
    URIAttributeType = 1200,
    TransformableAttributeType = 1800,
    ObjectIDAttributeType = 2000
  }

}

export namespace NSAttributedString {
  export enum EnumerationOptions {
    Reverse = 2,
    LongestEffectiveRangeNotRequired = 1048576
  }

  export enum NSTextScalingType {
    Standard = 0,
    iOS = 1
  }

  export enum NSUnderlineStyle {
    None = 0,
    Single = 1,
    Thick = 2,
    Double = 9,
    PatternSolid = 0,
    PatternDot = 256,
    PatternDash = 512,
    PatternDashDot = 768,
    PatternDashDotDot = 1024,
    ByWord = 32768
  }

  export enum NSWritingDirectionFormatType {
    Embedding = 0,
    Override = 2
  }

  export enum SpellingState {
    SpellingFlag = 1,
    GrammarFlag = 2
  }

}

export namespace NSAutoreleasePool {
}

export namespace NSBackgroundActivityScheduler {
  export enum Result {
    Finished = 1,
    Deferred = 2
  }

}

export namespace NSBatchDeleteRequest {
}

export namespace NSBatchInsertRequest {
}

export namespace NSBatchUpdateRequest {
}

export namespace NSBezierPath {
  export enum ElementType {
    MoveTo = 0,
    LineTo = 1,
    CurveTo = 2,
    ClosePath = 3
  }

  export enum LineCapStyle {
    Butt = 0,
    Round = 1,
    Square = 2
  }

  export enum LineJoinStyle {
    Miter = 0,
    Round = 1,
    Bevel = 2
  }

  export enum WindingRule {
    NonZero = 0,
    EvenOdd = 1
  }

}

export namespace NSBitmapImageRep {
  export enum FileType {
    TIFF = 0,
    BMP = 1,
    GIF = 2,
    JPEG = 3,
    PNG = 4,
    JPEG2000 = 5
  }

  export enum Format {
    AlphaFirst = 1,
    AlphaNonpremultiplied = 2,
    FloatingPointSamples = 4,
    SixteenBitLittleEndian = 256,
    ThirtyTwoBitLittleEndian = 512,
    SixteenBitBigEndian = 1024,
    ThirtyTwoBitBigEndian = 2048
  }

  export enum LoadStatus {
    UnknownType = -1,
    ReadingHeader = -2,
    WillNeedAllData = -3,
    InvalidData = -4,
    UnexpectedEOF = -5,
    Completed = -6
  }

  export enum TIFFCompression {
    None = 1,
    CCITTFAX3 = 3,
    CCITTFAX4 = 4,
    LZW = 5,
    JPEG = 6,
    NEXT = 32766,
    PackBits = 32773,
    OldJPEG = 32865
  }

}

export namespace NSBox {
  export enum BoxType {
    Primary = 0,
    Separator = 2,
    Custom = 4
  }

  export enum TitlePosition {
    NoTitle = 0,
    AboveTop = 1,
    AtTop = 2,
    BelowTop = 3,
    AboveBottom = 4,
    AtBottom = 5,
    BelowBottom = 6
  }

}

export namespace NSBrowser {
  export enum ColumnResizingType {
    NoColumnResizing = 0,
    AutoColumnResizing = 1,
    UserColumnResizing = 2
  }

  export enum DropOperation {
    On = 0,
    Above = 1
  }

}

export namespace NSBrowserCell {
}

export namespace Bundle {
}

export namespace NSButton {
  export enum BezelStyle {
    Rounded = 1,
    RegularSquare = 2,
    Disclosure = 5,
    ShadowlessSquare = 6,
    Circular = 7,
    TexturedSquare = 8,
    HelpButton = 9,
    SmallSquare = 10,
    TexturedRounded = 11,
    RoundRect = 12,
    Recessed = 13,
    RoundedDisclosure = 14,
    Inline = 15
  }

  export enum ButtonType {
    MomentaryLight = 0,
    PushOnPushOff = 1,
    Toggle = 2,
    Switch = 3,
    Radio = 4,
    MomentaryChange = 5,
    OnOff = 6,
    MomentaryPushIn = 7,
    Accelerator = 8,
    MultiLevelAccelerator = 9
  }

}

export namespace NSButtonCell {
  export namespace NSButton {
    export enum BezelStyle {
      Rounded = 1,
      RegularSquare = 2,
      Disclosure = 5,
      ShadowlessSquare = 6,
      Circular = 7,
      TexturedSquare = 8,
      HelpButton = 9,
      SmallSquare = 10,
      TexturedRounded = 11,
      RoundRect = 12,
      Recessed = 13,
      RoundedDisclosure = 14,
      Inline = 15
    }
    export enum ButtonType {
      MomentaryLight = 0,
      PushOnPushOff = 1,
      Toggle = 2,
      Switch = 3,
      Radio = 4,
      MomentaryChange = 5,
      OnOff = 6,
      MomentaryPushIn = 7,
      Accelerator = 8,
      MultiLevelAccelerator = 9
    }
  }

}

export namespace NSButtonTouchBarItem {
}

export namespace NSCIImageRep {
}

export namespace NSCache {
}

export namespace NSCandidateListTouchBarItem {
}

export namespace NSCell {
  export namespace NSControl {
    export enum ControlSize {
      Regular = 0,
      Small = 1,
      Mini = 2
    }
    export enum ImagePosition {
      NoImage = 0,
      ImageOnly = 1,
      ImageLeft = 2,
      ImageRight = 3,
      ImageBelow = 4,
      ImageAbove = 5,
      ImageOverlaps = 6,
      ImageLeading = 7,
      ImageTrailing = 8
    }
  }

  export namespace NSView {
    export enum BackgroundStyle {
      Normal = 0,
      Emphasized = 1,
      Raised = 2,
      Lowered = 3
    }
  }

  export enum Attribute {
    CellDisabled = 0,
    CellState = 1,
    PushInCell = 2,
    CellEditable = 3,
    ChangeGrayCell = 4,
    CellHighlighted = 5,
    CellLightsByContents = 6,
    CellLightsByGray = 7,
    ChangeBackgroundCell = 8,
    CellLightsByBackground = 9,
    CellIsBordered = 10,
    CellHasOverlappingImage = 11,
    CellHasImageHorizontal = 12,
    CellHasImageOnLeftOrBottom = 13,
    CellChangesContents = 14,
    CellIsInsetButton = 15,
    CellAllowsMixedState = 16
  }

  export enum CellType {
    NullCellType = 0,
    TextCellType = 1,
    ImageCellType = 2
  }

  export enum HitResult {
    None = 0,
    ContentArea = 1,
    EditableTextArea = 2,
    TrackableArea = 4
  }

  export enum NSControlTint {
    DefaultControlTint = 0,
    BlueControlTint = 1,
    GraphiteControlTint = 6,
    ClearControlTint = 7
  }

  export enum NSImageScaling {
    ImageScaleProportionallyDown = 0,
    ImageScaleAxesIndependently = 1,
    ImageScaleNone = 2,
    ImageScaleProportionallyUpOrDown = 3,
    ScaleProportionally = 0,
    ScaleToFit = 1,
    ScaleNone = 2
  }

  export enum StyleMask {
    NoCellMask = 0,
    ContentsCellMask = 1,
    PushInCellMask = 2,
    ChangeGrayCellMask = 4,
    ChangeBackgroundCellMask = 8
  }

}

export namespace CharacterSet {
}

export namespace NSClassDescription {
}

export namespace NSClickGestureRecognizer {
}

export namespace NSClipView {
}

export namespace NSCoder {
  export enum DecodingFailurePolicy {
    RaiseException = 0,
    SetErrorAndReturn = 1
  }

}

export namespace NSCollectionView {
  export namespace NSCollectionViewItem {
    export enum HighlightState {
      None = 0,
      ForSelection = 1,
      ForDeselection = 2,
      AsDropTarget = 3
    }
  }

  export enum DropOperation {
    On = 0,
    Before = 1
  }

  export enum ScrollDirection {
    Vertical = 0,
    Horizontal = 1
  }

  export enum ScrollPosition {
    None = 0,
    Top = 1,
    CenteredVertically = 2,
    Bottom = 4,
    NearestHorizontalEdge = 512,
    Left = 8,
    CenteredHorizontally = 16,
    Right = 32,
    LeadingEdge = 64,
    TrailingEdge = 128,
    NearestVerticalEdge = 256
  }

  export enum UpdateAction {
    Insert = 0,
    Delete = 1,
    Reload = 2,
    Move = 3,
    None = 4
  }

}

export namespace NSCollectionViewCompositionalLayout {
  export enum NSCollectionLayoutSectionOrthogonalScrollingBehavior {
    None = 0,
    Continuous = 1,
    ContinuousGroupLeadingBoundary = 2,
    Paging = 3,
    GroupPaging = 4,
    GroupPagingCentered = 5
  }

  export enum NSDirectionalRectEdge {
    None = 0,
    Top = 1,
    Leading = 2,
    Bottom = 4,
    Trailing = 8,
    All = 15
  }

  export enum NSRectAlignment {
    None = 0,
    Top = 1,
    TopLeading = 2,
    Leading = 3,
    BottomLeading = 4,
    Bottom = 5,
    BottomTrailing = 6,
    Trailing = 7,
    TopTrailing = 8
  }

}

export namespace NSCollectionViewFlowLayout {
  export namespace NSCollectionView {
    export enum DropOperation {
      On = 0,
      Before = 1
    }
    export enum ScrollDirection {
      Vertical = 0,
      Horizontal = 1
    }
    export enum ScrollPosition {
      None = 0,
      Top = 1,
      CenteredVertically = 2,
      Bottom = 4,
      NearestHorizontalEdge = 512,
      Left = 8,
      CenteredHorizontally = 16,
      Right = 32,
      LeadingEdge = 64,
      TrailingEdge = 128,
      NearestVerticalEdge = 256
    }
    export enum UpdateAction {
      Insert = 0,
      Delete = 1,
      Reload = 2,
      Move = 3,
      None = 4
    }
  }

}

export namespace NSCollectionViewGridLayout {
}

export namespace NSCollectionViewLayout {
  export namespace NSCollectionView {
    export enum UpdateAction {
      Insert = 0,
      Delete = 1,
      Reload = 2,
      Move = 3,
      None = 4
    }
  }

  export enum NSCollectionElementCategory {
    Item = 0,
    SupplementaryView = 1,
    DecorationView = 2,
    InterItemGap = 3
  }

}

export namespace NSCollectionViewTransitionLayout {
}

export namespace NSColor {
  export enum ColorType {
    ComponentBased = 0,
    Pattern = 1,
    Catalog = 2
  }

  export enum SystemEffect {
    None = 0,
    Pressed = 1,
    DeepPressed = 2,
    Disabled = 3,
    Rollover = 4
  }

}

export namespace NSColorList {
}

export namespace NSColorPanel {
  export enum Mode {
    None = -1,
    Gray = 0,
    RGB = 1,
    CMYK = 2,
    HSB = 3,
    CustomPalette = 4,
    ColorList = 5,
    Wheel = 6,
    Crayon = 7
  }

  export enum Options {
    GrayModeMask = 1,
    RGBModeMask = 2,
    CMYKModeMask = 4,
    HSBModeMask = 8,
    CustomPaletteModeMask = 16,
    ColorListModeMask = 32,
    WheelModeMask = 64,
    CrayonModeMask = 128,
    AllModesMask = 65535
  }

}

export namespace NSColorPicker {
}

export namespace NSColorPickerTouchBarItem {
}

export namespace NSColorSampler {
}

export namespace NSColorSpace {
  export enum Model {
    Unknown = -1,
    Gray = 0,
    RGB = 1,
    CMYK = 2,
    LAB = 3,
    DeviceN = 4,
    Indexed = 5,
    Patterned = 6
  }

}

export namespace NSColorWell {
}

export namespace NSComboBox {
}

export namespace NSComboBoxCell {
}

export namespace NSComparisonPredicate {
  export enum Modifier {
    DirectPredicateModifier = 0,
    AllPredicateModifier = 1,
    AnyPredicateModifier = 2
  }

  export enum Operator {
    LessThanPredicateOperatorType = 0,
    LessThanOrEqualToPredicateOperatorType = 1,
    GreaterThanPredicateOperatorType = 2,
    GreaterThanOrEqualToPredicateOperatorType = 3,
    EqualToPredicateOperatorType = 4,
    NotEqualToPredicateOperatorType = 5,
    MatchesPredicateOperatorType = 6,
    LikePredicateOperatorType = 7,
    BeginsWithPredicateOperatorType = 8,
    EndsWithPredicateOperatorType = 9,
    InPredicateOperatorType = 10,
    CustomSelectorPredicateOperatorType = 11,
    ContainsPredicateOperatorType = 99,
    BetweenPredicateOperatorType = 100
  }

  export enum Options {
    CaseInsensitivePredicateOption = 1,
    DiacriticInsensitivePredicateOption = 2,
    NormalizedPredicateOption = 4
  }

}

export namespace NSCompoundPredicate {
  export enum LogicalType {
    NotPredicateType = 0,
    AndPredicateType = 1,
    OrPredicateType = 2
  }

}

export namespace NSConnection {
}

export namespace NSControl {
  export enum ControlSize {
    Regular = 0,
    Small = 1,
    Mini = 2
  }

  export enum ImagePosition {
    NoImage = 0,
    ImageOnly = 1,
    ImageLeft = 2,
    ImageRight = 3,
    ImageBelow = 4,
    ImageAbove = 5,
    ImageOverlaps = 6,
    ImageLeading = 7,
    ImageTrailing = 8
  }

}

export namespace NSController {
}

export namespace NSCoreDataCoreSpotlightDelegate {
}

export namespace NSCursor {
}

export namespace NSCustomImageRep {
}

export namespace NSCustomTouchBarItem {
}

export namespace NSDataAsset {
}

// @ts-ignore
export namespace Date {
}

export namespace DateInterval {
}

export namespace NSDatePicker {
  export enum ElementFlags {
    HourMinute = 12,
    HourMinuteSecond = 14,
    TimeZone = 16,
    YearMonth = 192,
    YearMonthDay = 224,
    Era = 256
  }

  export enum Mode {
    Single = 0,
    Range = 1
  }

  export enum Style {
    TextFieldAndStepper = 0,
    ClockAndCalendar = 1,
    TextField = 2
  }

}

export namespace NSDatePickerCell {
  export namespace NSDatePicker {
    export enum ElementFlags {
      HourMinute = 12,
      HourMinuteSecond = 14,
      TimeZone = 16,
      YearMonth = 192,
      YearMonthDay = 224,
      Era = 256
    }
    export enum Mode {
      Single = 0,
      Range = 1
    }
    export enum Style {
      TextFieldAndStepper = 0,
      ClockAndCalendar = 1,
      TextField = 2
    }
  }

}

export namespace NSDebug {
}

export namespace NSDerivedAttributeDescription {
}

// @ts-ignore
export namespace Dictionary {
}

export namespace NSDictionaryController {
}

export namespace NSDistantObject {
}

export namespace NSDistributedLock {
}

export namespace NSDockTile {
}

export namespace NSDocument {
  export enum ChangeType {
    Done = 0,
    Undone = 1,
    Redone = 5,
    Cleared = 2,
    ReadOtherContents = 3,
    Autosaved = 4,
    Discardable = 256
  }

  export enum SaveOperationType {
    SaveOperation = 0,
    SaveAsOperation = 1,
    SaveToOperation = 2,
    AutosaveInPlaceOperation = 4,
    AutosaveElsewhereOperation = 3,
    AutosaveAsOperation = 5,
    AutosaveOperation = 3
  }

}

export namespace NSDocumentController {
}

export namespace NSDragging {
  export enum NSDragOperation {
    None = 0,
    Copy = 1,
    Link = 2,
    Generic = 4,
    Private = 8,
    Move = 16,
    Delete = 32,
    Every = -1,
    All_Obsolete = 15,
    All = 15
  }

  export enum NSDraggingContext {
    OutsideApplication = 0,
    WithinApplication = 1
  }

  export enum NSDraggingFormation {
    Default = 0,
    None = 1,
    Pile = 2,
    List = 3,
    Stack = 4
  }

  export enum NSDraggingItemEnumerationOptions {
    oncurrent = 1,
    learNonenumeratedImages = 65536
  }

  export enum NSSpringLoadingHighlight {
    None = 0,
    Standard = 1,
    Emphasized = 2
  }

  export enum NSSpringLoadingOptions {
    Disabled = 0,
    Enabled = 1,
    ContinuousActivation = 2,
    NoHover = 8
  }

}

export namespace NSDraggingItem {
}

export namespace NSDraggingSession {
}

export namespace NSDrawer {
  export enum State {
    ClosedState = 0,
    OpeningState = 1,
    OpenState = 2,
    ClosingState = 3
  }

}

export namespace NSEPSImageRep {
}

export namespace NSEntityDescription {
}

export namespace NSEntityMapping {
  export enum NSEntityMappingType {
    UndefinedEntityMappingType = 0,
    CustomEntityMappingType = 1,
    AddEntityMappingType = 2,
    RemoveEntityMappingType = 3,
    CopyEntityMappingType = 4,
    TransformEntityMappingType = 5
  }

}

export namespace NSEntityMigrationPolicy {
}

export namespace NSEnumerator {
}

// @ts-ignore
export namespace Error {
}

export namespace NSErrors {
}

export namespace NSEvent {
  export enum ButtonMask {
    Tip = 1,
    LowerSide = 2,
    UpperSide = 4
  }

  export enum EventSubtype {
    WindowExposed = 0,
    ApplicationActivated = 1,
    ApplicationDeactivated = 2,
    WindowMoved = 4,
    ScreenChanged = 8,
    PowerOff = 1,
    MouseEvent = 0,
    TabletPoint = 1,
    TabletProximity = 2,
    Touch = 3
  }

  export enum EventType {
    LeftMouseDown = 1,
    LeftMouseUp = 2,
    RightMouseDown = 3,
    RightMouseUp = 4,
    MouseMoved = 5,
    LeftMouseDragged = 6,
    RightMouseDragged = 7,
    MouseEntered = 8,
    MouseExited = 9,
    KeyDown = 10,
    KeyUp = 11,
    FlagsChanged = 12,
    AppKitDefined = 13,
    SystemDefined = 14,
    ApplicationDefined = 15,
    Periodic = 16,
    CursorUpdate = 17,
    ScrollWheel = 22,
    TabletPoint = 23,
    TabletProximity = 24,
    OtherMouseDown = 25,
    OtherMouseUp = 26,
    OtherMouseDragged = 27,
    Gesture = 29,
    Magnify = 30,
    Swipe = 31,
    Rotate = 18,
    BeginGesture = 19,
    EndGesture = 20,
    SmartMagnify = 32,
    QuickLook = 33,
    Pressure = 34,
    DirectTouch = 37,
    ChangeMode = 38
  }

  export enum EventTypeMask {
    LeftMouseDown = 2,
    LeftMouseUp = 4,
    RightMouseDown = 8,
    RightMouseUp = 16,
    MouseMoved = 32,
    LeftMouseDragged = 64,
    RightMouseDragged = 128,
    MouseEntered = 256,
    MouseExited = 512,
    KeyDown = 1024,
    KeyUp = 2048,
    FlagsChanged = 4096,
    AppKitDefined = 8192,
    SystemDefined = 16384,
    ApplicationDefined = 32768,
    Periodic = 65536,
    CursorUpdate = 131072,
    ScrollWheel = 4194304,
    TabletPoint = 8388608,
    TabletProximity = 16777216,
    OtherMouseDown = 33554432,
    OtherMouseUp = 67108864,
    OtherMouseDragged = 134217728,
    Gesture = 536870912,
    Magnify = 1073741824,
    Swipe = 2147483648,
    Rotate = 262144,
    BeginGesture = 524288,
    EndGesture = 1048576,
    SmartMagnify = 4294967296,
    Pressure = 17179869184,
    DirectTouch = 137438953472,
    ChangeMode = 274877906944,
    Any = -1
  }

  export enum GestureAxis {
    None = 0,
    Horizontal = 1,
    Vertical = 2
  }

  export enum ModifierFlags {
    CapsLock = 65536,
    Shift = 131072,
    Control = 262144,
    Option = 524288,
    Command = 1048576,
    NumericPad = 2097152,
    Help = 4194304,
    Function = 8388608,
    DeviceIndependentFlagsMask = 4294901760
  }

  export enum Phase {
    None = 0,
    Began = 1,
    Stationary = 2,
    Changed = 4,
    Ended = 8,
    Cancelled = 16,
    MayBegin = 32
  }

  export enum PointingDeviceType {
    Unknown = 0,
    Pen = 1,
    Cursor = 2,
    Eraser = 3
  }

  export enum PressureBehavior {
    Unknown = -1,
    PrimaryDefault = 0,
    PrimaryClick = 1,
    PrimaryGeneric = 2,
    PrimaryAccelerator = 3,
    PrimaryDeepClick = 5,
    PrimaryDeepDrag = 6
  }

  export enum SwipeTrackingOptions {
    LockDirection = 1,
    ClampGestureAmount = 2
  }

}

export namespace NSException {
}

export namespace NSExpression {
  export enum ExpressionType {
    ConstantValueExpressionType = 0,
    EvaluatedObjectExpressionType = 1,
    VariableExpressionType = 2,
    KeyPathExpressionType = 3,
    FunctionExpressionType = 4,
    UnionSetExpressionType = 5,
    IntersectSetExpressionType = 6,
    MinusSetExpressionType = 7,
    SubqueryExpressionType = 13,
    AggregateExpressionType = 14,
    AnyKeyExpressionType = 15,
    BlockExpressionType = 19,
    ConditionalExpressionType = 20
  }

}

export namespace NSExpressionDescription {
}

export namespace NSExtensionContext {
}

export namespace NSExtensionItem {
}

export namespace NSExtensionRequestHandling {
}

export namespace NSFetchIndexDescription {
}

export namespace NSFetchIndexElementDescription {
  export enum NSFetchIndexElementType {
    Binary = 0,
    RTree = 1
  }

}

export namespace NSFetchRequest {
  export enum NSFetchRequestResultType {
    ManagedObjectResultType = 0,
    ManagedObjectIDResultType = 1,
    DictionaryResultType = 2,
    CountResultType = 4
  }

}

export namespace NSFetchRequestExpression {
}

export namespace NSFetchedPropertyDescription {
}

export namespace NSFetchedResultsController {
  export enum NSFetchedResultsChangeType {
    Insert = 1,
    Delete = 2,
    Move = 3,
    Update = 4
  }

}

export namespace NSFileCoordinator {
  export enum ReadingOptions {
    WithoutChanges = 1,
    ResolvesSymbolicLink = 2,
    ImmediatelyAvailableMetadataOnly = 4,
    ForUploading = 8
  }

  export enum WritingOptions {
    ForDeleting = 1,
    ForMoving = 2,
    ForMerging = 4,
    ForReplacing = 8,
    ContentIndependentMetadataOnly = 16
  }

}

export namespace FileHandle {
}

export namespace NSFilePresenter {
}

export namespace NSFilePromiseProvider {
}

export namespace NSFilePromiseReceiver {
}

export namespace NSFileVersion {
  export enum AddingOptions {
    NSFileVersionAddingByMoving = 1
  }

  export enum ReplacingOptions {
    NSFileVersionReplacingByMoving = 1
  }

}

export namespace NSFont {
  export enum NSFontRenderingMode {
    DefaultRenderingMode = 0,
    AntialiasedRenderingMode = 1,
    IntegerAdvancementsRenderingMode = 2,
    AntialiasedIntegerAdvancementsRenderingMode = 3
  }

}

export namespace NSFontAssetRequest {
  export enum Options {
    NSFontAssetRequestOptionUsesStandardUI = 1
  }

}

export namespace NSFontCollection {
  export enum Visibility {
    Process = 1,
    User = 2,
    Computer = 4
  }

}

export namespace NSFontDescriptor {
  export enum SymbolicTraits {
    TraitItalic = 1,
    TraitBold = 2,
    TraitExpanded = 32,
    TraitCondensed = 64,
    TraitMonoSpace = 1024,
    TraitVertical = 2048,
    TraitUIOptimized = 4096,
    TraitTightLeading = 32768,
    TraitLooseLeading = 65536,
    ClassMask = 4026531840,
    ClassUnknown = 0,
    ClassOldStyleSerifs = 268435456,
    ClassTransitionalSerifs = 536870912,
    ClassModernSerifs = 805306368,
    ClassClarendonSerifs = 1073741824,
    ClassSlabSerifs = 1342177280,
    ClassFreeformSerifs = 1879048192,
    ClassSansSerif = 2147483648,
    ClassOrnamentals = 2415919104,
    ClassScripts = 2684354560,
    ClassSymbolic = 3221225472
  }

}

export namespace NSFontManager {
  export enum NSFontAction {
    NoFontChangeAction = 0,
    ViaPanelFontAction = 1,
    AddTraitFontAction = 2,
    SizeUpFontAction = 3,
    SizeDownFontAction = 4,
    HeavierFontAction = 5,
    LighterFontAction = 6,
    RemoveTraitFontAction = 7
  }

  export enum NSFontCollectionOptions {
    NSFontCollectionApplicationOnlyMask = 1
  }

  export enum NSFontTraitMask {
    ItalicFontMask = 1,
    BoldFontMask = 2,
    UnboldFontMask = 4,
    NonStandardCharacterSetFontMask = 8,
    NarrowFontMask = 16,
    ExpandedFontMask = 32,
    CondensedFontMask = 64,
    SmallCapsFontMask = 128,
    PosterFontMask = 256,
    CompressedFontMask = 512,
    FixedPitchFontMask = 1024,
    UnitalicFontMask = 16777216
  }

}

export namespace NSFontPanel {
  export enum ModeMask {
    MaskFace = 1,
    MaskSize = 2,
    MaskCollection = 4,
    MaskUnderlineEffect = 256,
    MaskStrikethroughEffect = 512,
    MaskTextColorEffect = 1024,
    MaskDocumentColorEffect = 2048,
    MaskShadowEffect = 4096,
    MaskAllEffects = 1048320,
    sMaskStandardModes = 65535,
    sMaskAllModes = 4294967295
  }

}

export namespace NSFormCell {
}

export namespace NSGarbageCollector {
}

export namespace NSGeometry {
  export enum AlignmentOptions {
    MinXInward = 1,
    MinYInward = 2,
    MaxXInward = 4,
    MaxYInward = 8,
    WidthInward = 16,
    HeightInward = 32,
    MinXOutward = 256,
    MinYOutward = 512,
    MaxXOutward = 1024,
    MaxYOutward = 2048,
    WidthOutward = 4096,
    HeightOutward = 8192,
    MinXNearest = 65536,
    MinYNearest = 131072,
    MaxXNearest = 262144,
    MaxYNearest = 524288,
    WidthNearest = 1048576,
    HeightNearest = 2097152,
    RectFlipped = -9223372036854775808,
    AllEdgesInward = 15,
    AllEdgesOutward = 3840,
    AllEdgesNearest = 983040
  }

  export enum NSRectEdge {
    RectEdgeMinX = 0,
    RectEdgeMinY = 1,
    RectEdgeMaxX = 2,
    RectEdgeMaxY = 3,
    MinXEdge = 0,
    MinYEdge = 1,
    MaxXEdge = 2,
    MaxYEdge = 3
  }

}

export namespace NSGestureRecognizer {
  export enum State {
    Possible = 0,
    Began = 1,
    Changed = 2,
    Ended = 3,
    Cancelled = 4,
    Failed = 5,
    Recognized = 3
  }

}

export namespace NSGlyphGenerator {
}

export namespace NSGlyphInfo {
  export enum NSCharacterCollection {
    IdentityMappingCharacterCollection = 0,
    AdobeCNS1CharacterCollection = 1,
    AdobeGB1CharacterCollection = 2,
    AdobeJapan1CharacterCollection = 3,
    AdobeJapan2CharacterCollection = 4,
    AdobeKorea1CharacterCollection = 5
  }

}

export namespace NSGradient {
  export enum DrawingOptions {
    BeforeStartingLocation = 1,
    AfterEndingLocation = 2
  }

}

export namespace NSGraphics {
  export namespace NSWindow {
    export enum BackingStoreType {
      Retained = 0,
      Nonretained = 1,
      Buffered = 2
    }
    export enum Depth {
      TwentyfourBitRGB = 520,
      SixtyfourBitRGB = 528,
      OnehundredtwentyeightBitRGB = 544
    }
    export enum OrderingMode {
      Above = 1,
      Below = -1,
      Out = 0
    }
  }

  export enum NSAnimationEffect {
    DisappearingItemDefault = 0,
    Poof = 10
  }

  export enum NSColorRenderingIntent {
    Default = 0,
    AbsoluteColorimetric = 1,
    RelativeColorimetric = 2,
    Perceptual = 3,
    Saturation = 4
  }

  export enum NSCompositingOperation {
    Clear = 0,
    Copy = 1,
    SourceOver = 2,
    SourceIn = 3,
    SourceOut = 4,
    SourceAtop = 5,
    DestinationOver = 6,
    DestinationIn = 7,
    DestinationOut = 8,
    DestinationAtop = 9,
    XOR = 10,
    PlusDarker = 11,
    Highlight = 12,
    PlusLighter = 13,
    Multiply = 14,
    Screen = 15,
    Overlay = 16,
    Darken = 17,
    Lighten = 18,
    ColorDodge = 19,
    ColorBurn = 20,
    SoftLight = 21,
    HardLight = 22,
    Difference = 23,
    Exclusion = 24,
    Hue = 25,
    Saturation = 26,
    Color = 27,
    Luminosity = 28
  }

  export enum NSDisplayGamut {
    SRGB = 1,
    P3 = 2
  }

  export enum NSFocusRingPlacement {
    Only = 0,
    Below = 1,
    Above = 2
  }

  export enum NSFocusRingType {
    Default = 0,
    None = 1,
    Exterior = 2
  }

}

export namespace NSGraphicsContext {
  export enum NSImageInterpolation {
    Default = 0,
    None = 1,
    Low = 2,
    Medium = 4,
    High = 3
  }

}

export namespace NSGridView {
  export namespace NSGridCell {
    export enum Placement {
      Inherited = 0,
      None = 1,
      Leading = 2,
      Top = 2,
      Trailing = 3,
      Bottom = 3,
      Center = 4,
      Fill = 5
    }
  }

  export namespace NSGridRow {
    export enum Alignment {
      Inherited = 0,
      None = 1,
      FirstBaseline = 2,
      LastBaseline = 3
    }
  }

}

export namespace NSGroupTouchBarItem {
}

export namespace HTTPCookie {
  export enum AcceptPolicy {
    Always = 0,
    Never = 1,
    OnlyFromMainDocumentDomain = 2
  }

}

export namespace NSHapticFeedback {
  export namespace NSHapticFeedbackManager {
    export enum FeedbackPattern {
      Generic = 0,
      Alignment = 1,
      LevelChange = 2
    }
    export enum PerformanceTime {
      Default = 0,
      Now = 1,
      DrawCompleted = 2
    }
  }

}

export namespace NSHashTable {
}

export namespace NSHelpManager {
}

export namespace Host {
}

export namespace NSImage {
  export enum CacheMode {
    Default = 0,
    Always = 1,
    BySize = 2,
    Never = 3
  }

  export enum LayoutDirection {
    Unspecified = -1,
    LeftToRight = 2,
    RightToLeft = 3
  }

  export enum LoadStatus {
    Completed = 0,
    Cancelled = 1,
    InvalidData = 2,
    UnexpectedEOF = 3,
    ReadError = 4
  }

  export enum ResizingMode {
    Stretch = 0,
    Tile = 1
  }

}

export namespace NSImageCell {
  export namespace NSImageView {
    export enum FrameStyle {
      None = 0,
      Photo = 1,
      GrayBezel = 2,
      Groove = 3,
      Button = 4
    }
  }

  export enum NSImageAlignment {
    Center = 0,
    Top = 1,
    TopLeft = 2,
    TopRight = 3,
    Left = 4,
    Bottom = 5,
    BottomLeft = 6,
    BottomRight = 7,
    Right = 8
  }

}

export namespace NSImageRep {
  export namespace NSImage {
    export enum LayoutDirection {
      Unspecified = -1,
      LeftToRight = 2,
      RightToLeft = 3
    }
  }

}

export namespace NSImageView {
  export enum FrameStyle {
    None = 0,
    Photo = 1,
    GrayBezel = 2,
    Groove = 3,
    Button = 4
  }

}

export namespace NSIncrementalStore {
}

export namespace NSIncrementalStoreNode {
}

export namespace IndexPath {
}

export namespace IndexSet {
}

export namespace NSInvocation {
}

export namespace NSItemProvider {
  export enum ErrorCode {
    UnknownError = -1,
    ItemUnavailableError = -1000,
    UnexpectedValueClassError = -1100,
    UnavailableCoercionError = -1200
  }

  export enum NSItemProviderFileOptions {
    NSItemProviderFileOptionOpenInPlace = 1
  }

  export enum NSItemProviderRepresentationVisibility {
    All = 0,
    Team = 1,
    Group = 2,
    OwnProcess = 3
  }

}

export namespace NSKeyValueBinding {
}

export namespace NSKeyValueCoding {
}

export namespace NSKeyValueObserving {
  export enum NSKeyValueChange {
    Setting = 1,
    Insertion = 2,
    Removal = 3,
    Replacement = 4
  }

  export enum NSKeyValueObservingOptions {
    New = 1,
    Old = 2,
    Initial = 4,
    Prior = 8
  }

  export enum NSKeyValueSetMutationKind {
    UnionSetMutation = 1,
    MinusSetMutation = 2,
    IntersectSetMutation = 3,
    SetSetMutation = 4
  }

}

export namespace NSKeyedArchiver {
}

export namespace NSLayoutAnchor {
}

export namespace NSLayoutConstraint {
  export enum Attribute {
    Left = 1,
    Right = 2,
    Top = 3,
    Bottom = 4,
    Leading = 5,
    Trailing = 6,
    Width = 7,
    Height = 8,
    CenterX = 9,
    CenterY = 10,
    LastBaseline = 11,
    Baseline = 11,
    FirstBaseline = 12,
    NotAnAttribute = 0
  }

  export enum FormatOptions {
    AlignAllLeft = 2,
    AlignAllRight = 4,
    AlignAllTop = 8,
    AlignAllBottom = 16,
    AlignAllLeading = 32,
    AlignAllTrailing = 64,
    AlignAllCenterX = 512,
    AlignAllCenterY = 1024,
    AlignAllLastBaseline = 2048,
    AlignAllFirstBaseline = 4096,
    AlignAllBaseline = 2048,
    AlignmentMask = 65535,
    DirectionLeadingToTrailing = 0,
    DirectionLeftToRight = 65536,
    DirectionRightToLeft = 131072,
    DirectionMask = 196608
  }

  export enum Orientation {
    Horizontal = 0,
    Vertical = 1
  }

  export enum Relation {
    LessThanOrEqual = -1,
    Equal = 0,
    GreaterThanOrEqual = 1
  }

}

export namespace NSLayoutGuide {
}

export namespace NSLayoutManager {
  export enum ControlCharacterAction {
    ZeroAdvancement = 1,
    Whitespace = 2,
    HorizontalTab = 4,
    LineBreak = 8,
    ParagraphBreak = 16,
    ContainerBreak = 32
  }

  export enum GlyphProperty {
    Null = 1,
    ControlCharacter = 2,
    Elastic = 4,
    NonBaseCharacter = 8
  }

  export enum TextLayoutOrientation {
    Horizontal = 0,
    Vertical = 1
  }

  export enum TypesetterBehavior {
    LatestBehavior = -1,
    OriginalBehavior = 0,
    Behavior_10_2_WithCompatibility = 1,
    Behavior_10_2 = 2,
    Behavior_10_3 = 3,
    Behavior_10_4 = 4
  }

}

export namespace NSLevelIndicator {
  export enum PlaceholderVisibility {
    Automatic = 0,
    Always = 1,
    WhileEditing = 2
  }

  export enum Style {
    Relevancy = 0,
    ContinuousCapacity = 1,
    DiscreteCapacity = 2,
    Rating = 3
  }

}

export namespace NSLevelIndicatorCell {
  export namespace NSLevelIndicator {
    export enum Style {
      Relevancy = 0,
      ContinuousCapacity = 1,
      DiscreteCapacity = 2,
      Rating = 3
    }
  }

}

export namespace NSLinguisticTagger {
  export enum NSLinguisticTaggerUnit {
    Word = 0,
    Sentence = 1,
    Paragraph = 2,
    Document = 3
  }

  export enum Options {
    OmitWords = 1,
    OmitPunctuation = 2,
    OmitWhitespace = 4,
    OmitOther = 8,
    JoinNames = 16
  }

}

export namespace ListFormatter {
}

export namespace NSLock {
}

export namespace NSMagnificationGestureRecognizer {
}

export namespace NSManagedObject {
  export enum NSSnapshotEventType {
    UndoInsertion = 2,
    UndoDeletion = 4,
    UndoUpdate = 8,
    Rollback = 16,
    Refresh = 32,
    MergePolicy = 64
  }

}

export namespace NSManagedObjectContext {
  export enum NSManagedObjectContextConcurrencyType {
    ConfinementConcurrencyType = 0,
    PrivateQueueConcurrencyType = 1,
    MainQueueConcurrencyType = 2
  }

}

export namespace NSManagedObjectID {
}

export namespace NSManagedObjectModel {
}

export namespace NSMapTable {
}

export namespace NSMappingModel {
}

export namespace NSMatrix {
  export enum Mode {
    RadioModeMatrix = 0,
    HighlightModeMatrix = 1,
    ListModeMatrix = 2,
    TrackModeMatrix = 3
  }

}

export namespace Measurement {
}

export namespace NSMediaLibraryBrowserController {
  export enum Library {
    Audio = 1,
    Image = 2,
    Movie = 4
  }

}

export namespace NSMenu {
  export enum Properties {
    Title = 1,
    AttributedTitle = 2,
    KeyEquivalent = 4,
    Image = 8,
    Enabled = 16,
    AccessibilityDescription = 32
  }

}

export namespace NSMenuItem {
}

export namespace NSMenuItemCell {
}

export namespace NSMenuToolbarItem {
}

export namespace NSMergePolicy {
  export enum NSMergePolicyType {
    ErrorMergePolicyType = 0,
    MergeByPropertyStoreTrumpMergePolicyType = 1,
    MergeByPropertyObjectTrumpMergePolicyType = 2,
    OverwriteMergePolicyType = 3,
    RollbackMergePolicyType = 4
  }

}

export namespace NSMetadata {
}

export namespace NSMetadataAttributes {
}

export namespace NSMethodSignature {
}

export namespace NSMigrationManager {
}

export namespace NSNetServices {
  export namespace NetService {
    export enum ErrorCode {
      UnknownError = -72000,
      CollisionError = -72001,
      NotFoundError = -72002,
      ActivityInProgress = -72003,
      BadArgumentError = -72004,
      CancelledError = -72005,
      InvalidError = -72006,
      TimeoutError = -72007
    }
    export enum Options {
      NoAutoRename = 1,
      ListenForConnections = 2
    }
  }

}

export namespace NSNib {
}

export namespace Notification {
}

export namespace NotificationQueue {
  export enum NotificationCoalescing {
    NoCoalescing = 0,
    CoalescingOnName = 1,
    CoalescingOnSender = 2
  }

  export enum PostingStyle {
    WhenIdle = 1,
    ASAP = 2,
    Now = 3
  }

}

export namespace NumberFormatter {
  export enum Behavior {
    rDefault = 0,
    r10_0 = 1000,
    r10_4 = 1040
  }

  export enum PadPosition {
    BeforePrefix = 0,
    AfterPrefix = 1,
    BeforeSuffix = 2,
    AfterSuffix = 3
  }

  export enum RoundingMode {
    Ceiling = 0,
    Floor = 1,
    Down = 2,
    Up = 3,
    HalfEven = 4,
    HalfDown = 5,
    HalfUp = 6
  }

  export enum Style {
    NoStyle = 0,
    DecimalStyle = 1,
    CurrencyStyle = 2,
    PercentStyle = 3,
    ScientificStyle = 4,
    SpellOutStyle = 5,
    OrdinalStyle = 6,
    CurrencyISOCodeStyle = 8,
    CurrencyPluralStyle = 9,
    CurrencyAccountingStyle = 10
  }

}

export namespace NSObjCRuntime {
  export enum ComparisonResult {
    Ascending = -1,
    Same = 0,
    Descending = 1
  }

  export enum NSEnumerationOptions {
    Concurrent = 1,
    Reverse = 2
  }

  export enum NSSortOptions {
    Concurrent = 1,
    Stable = 16
  }

  export enum QualityOfService {
    UserInteractive = 33,
    UserInitiated = 25,
    Utility = 17,
    Background = 9,
    Default = -1
  }

}

export namespace NSObjectController {
}

export namespace NSOpenPanel {
}

export namespace Operation {
  export enum QueuePriority {
    VeryLow = -8,
    Low = -4,
    Normal = 0,
    High = 4,
    VeryHigh = 8
  }

}

export namespace NSOrderedCollectionChange {
  export enum NSCollectionChangeType {
    Insert = 0,
    Remove = 1
  }

}

export namespace NSOrderedSet {
}

export namespace NSOrthography {
}

export namespace NSOutlineView {
}

export namespace NSPDFImageRep {
}

export namespace NSPDFInfo {
}

export namespace NSPDFPanel {
  export enum Options {
    ShowsPaperSize = 4,
    ShowsOrientation = 8,
    RequestsParentDirectory = 16777216
  }

}

export namespace NSPICTImageRep {
}

export namespace NSPageController {
  export enum TransitionStyle {
    StackHistory = 0,
    StackBook = 1,
    HorizontalStrip = 2
  }

}

export namespace NSPageLayout {
}

export namespace NSPanGestureRecognizer {
}

export namespace NSPanel {
}

export namespace NSParagraphStyle {
  export enum NSLineBreakMode {
    WordWrapping = 0,
    CharWrapping = 1,
    Clipping = 2,
    TruncatingHead = 3,
    TruncatingTail = 4,
    TruncatingMiddle = 5
  }

  export enum TextTabType {
    LeftTabStopType = 0,
    RightTabStopType = 1,
    CenterTabStopType = 2,
    DecimalTabStopType = 3
  }

}

export namespace NSPasteboard {
  export enum ContentsOptions {
    NSPasteboardContentsCurrentHostOnly = 1
  }

  export enum ReadingOptions {
    Data = 0,
    String = 1,
    PropertyList = 2,
    KeyedArchive = 4
  }

  export enum WritingOptions {
    NSPasteboardWritingPromised = 512
  }

}

export namespace NSPasteboardItem {
}

export namespace NSPathCell {
  export namespace NSPathControl {
    export enum Style {
      Standard = 0,
      PopUp = 2,
      NavigationBar = 1
    }
  }

}

export namespace NSPathComponentCell {
}

export namespace NSPathControl {
  export enum Style {
    Standard = 0,
    PopUp = 2,
    NavigationBar = 1
  }

}

export namespace NSPathControlItem {
}

export namespace NSPathUtilities {
  export namespace FileManager {
    export enum SearchPathDirectory {
      ApplicationDirectory = 1,
      DemoApplicationDirectory = 2,
      DeveloperApplicationDirectory = 3,
      AdminApplicationDirectory = 4,
      LibraryDirectory = 5,
      DeveloperDirectory = 6,
      UserDirectory = 7,
      DocumentationDirectory = 8,
      DocumentDirectory = 9,
      CoreServiceDirectory = 10,
      AutosavedInformationDirectory = 11,
      DesktopDirectory = 12,
      CachesDirectory = 13,
      ApplicationSupportDirectory = 14,
      DownloadsDirectory = 15,
      InputMethodsDirectory = 16,
      MoviesDirectory = 17,
      MusicDirectory = 18,
      PicturesDirectory = 19,
      PrinterDescriptionDirectory = 20,
      SharedPublicDirectory = 21,
      PreferencePanesDirectory = 22,
      ApplicationScriptsDirectory = 23,
      ItemReplacementDirectory = 99,
      AllApplicationsDirectory = 100,
      AllLibrariesDirectory = 101,
      TrashDirectory = 102
    }
    export enum SearchPathDomainMask {
      UserDomainMask = 1,
      LocalDomainMask = 2,
      NetworkDomainMask = 4,
      SystemDomainMask = 8,
      AllDomainsMask = 65535
    }
  }

}

export namespace NSPersistentCloudKitContainer {
  export enum NSPersistentCloudKitContainerSchemaInitializationOptions {
    None = 0,
    DryRun = 2,
    PrintSchema = 4
  }

}

export namespace NSPersistentCloudKitContainerOptions {
}

export namespace NSPersistentContainer {
}

export namespace NSPersistentDocument {
}

export namespace NSPersistentHistoryChange {
  export enum NSPersistentHistoryChangeType {
    Insert = 0,
    Update = 1,
    Delete = 2
  }

}

export namespace NSPersistentHistoryChangeRequest {
}

export namespace NSPersistentHistoryTransaction {
}

export namespace NSPersistentStore {
}

export namespace NSPersistentStoreCoordinator {
}

export namespace NSPersistentStoreDescription {
}

export namespace NSPersistentStoreRequest {
  export enum NSPersistentStoreRequestType {
    FetchRequestType = 1,
    SaveRequestType = 2,
    BatchInsertRequestType = 5,
    BatchUpdateRequestType = 6,
    BatchDeleteRequestType = 7
  }

}

export namespace NSPersistentStoreResult {
  export enum NSBatchDeleteRequestResultType {
    StatusOnly = 0,
    ObjectIDs = 1,
    Count = 2
  }

  export enum NSBatchInsertRequestResultType {
    StatusOnly = 0,
    ObjectIDs = 1,
    Count = 2
  }

  export enum NSBatchUpdateRequestResultType {
    StatusOnlyResultType = 0,
    UpdatedObjectIDsResultType = 1,
    UpdatedObjectsCountResultType = 2
  }

  export enum NSPersistentHistoryResultType {
    StatusOnly = 0,
    ObjectIDs = 1,
    Count = 2,
    TransactionsOnly = 3,
    ChangesOnly = 4,
    TransactionsAndChanges = 5
  }

}

export namespace PersonNameComponents {
}

export namespace PersonNameComponentsFormatter {
  export enum Options {
    NSPersonNameComponentsFormatterPhonetic = 2
  }

  export enum Style {
    Default = 0,
    Short = 1,
    Medium = 2,
    Long = 3,
    Abbreviated = 4
  }

}

export namespace NSPickerTouchBarItem {
  export enum ControlRepresentation {
    Automatic = 0,
    Expanded = 1,
    Collapsed = 2
  }

  export enum SelectionMode {
    SelectOne = 0,
    SelectAny = 1,
    Momentary = 2
  }

}

export namespace NSPointerArray {
}

export namespace NSPointerFunctions {
  export enum Options {
    StrongMemory = 0,
    ZeroingWeakMemory = 1,
    OpaqueMemory = 2,
    MallocMemory = 3,
    MachVirtualMemory = 4,
    WeakMemory = 5,
    ObjectPersonality = 0,
    OpaquePersonality = 256,
    ObjectPointerPersonality = 512,
    CStringPersonality = 768,
    StructPersonality = 1024,
    IntegerPersonality = 1280,
    CopyIn = 65536
  }

}

export namespace NSPopUpButton {
  export enum ArrowPosition {
    NoArrow = 0,
    ArrowAtCenter = 1,
    ArrowAtBottom = 2
  }

}

export namespace NSPopUpButtonCell {
  export namespace NSPopUpButton {
    export enum ArrowPosition {
      NoArrow = 0,
      ArrowAtCenter = 1,
      ArrowAtBottom = 2
    }
  }

}

export namespace NSPopover {
  export enum Behavior {
    ApplicationDefined = 0,
    Transient = 1,
    Semitransient = 2
  }

}

export namespace NSPopoverTouchBarItem {
}

export namespace Port {
  export namespace NSMachPort {
    export enum Options {
      None = 0,
      SendRight = 1,
      ReceiveRight = 2
    }
  }

}

export namespace NSPortCoder {
}

export namespace PortMessage {
}

export namespace NSPortNameServer {
}

export namespace NSPredicate {
}

export namespace NSPredicateEditor {
}

export namespace NSPredicateEditorRowTemplate {
}

export namespace NSPressGestureRecognizer {
}

export namespace NSPressureConfiguration {
}

export namespace NSPrintInfo {
  export enum PaginationMode {
    Automatic = 0,
    Fit = 1,
    Clip = 2
  }

  export enum PaperOrientation {
    Portrait = 0,
    Landscape = 1
  }

}

export namespace NSPrintOperation {
  export enum PageOrder {
    DescendingPageOrder = -1,
    SpecialPageOrder = 0,
    AscendingPageOrder = 1,
    UnknownPageOrder = 2
  }

  export enum RenderingQuality {
    Best = 0,
    Responsive = 1
  }

}

export namespace NSPrintPanel {
  export enum Options {
    Copies = 1,
    PageRange = 2,
    PaperSize = 4,
    Orientation = 8,
    Scaling = 16,
    PrintSelection = 32,
    PageSetupAccessory = 256,
    Preview = 131072
  }

}

export namespace NSPrinter {
  export enum TableStatus {
    OK = 0,
    NotFound = 1,
    Error = 2
  }

}

export namespace ProcessInfo {
  export enum ActivityOptions {
    IdleDisplaySleepDisabled = 1099511627776,
    IdleSystemSleepDisabled = 1048576,
    SuddenTerminationDisabled = 16384,
    AutomaticTerminationDisabled = 32768,
    UserInitiated = 16777215,
    UserInitiatedAllowingIdleSystemSleep = 15728639,
    Background = 255,
    LatencyCritical = 1095216660480
  }

  export enum ThermalState {
    Nominal = 0,
    Fair = 1,
    Serious = 2,
    Critical = 3
  }

}

export namespace Progress {
}

export namespace NSProgressIndicator {
  export enum Style {
    Bar = 0,
    Spinning = 1
  }

}

export namespace NSPropertyDescription {
}

export namespace NSPropertyList {
  export namespace PropertyListSerialization {
    export enum MutabilityOptions {
      Immutable = 0,
      MutableContainers = 1,
      MutableContainersAndLeaves = 2
    }
    export enum PropertyListFormat {
      OpenStepFormat = 1,
      XMLFormat_v1_0 = 100,
      BinaryFormat_v1_0 = 200
    }
  }

}

export namespace NSPropertyMapping {
}

export namespace NSProtocolChecker {
}

export namespace NSProxy {
}

export namespace NSQueryGenerationToken {
}

export namespace NSRegularExpression {
  export enum MatchingFlags {
    Progress = 1,
    Completed = 2,
    HitEnd = 4,
    RequiredEnd = 8,
    InternalError = 16
  }

  export enum MatchingOptions {
    ReportProgress = 1,
    ReportCompletion = 2,
    Anchored = 4,
    WithTransparentBounds = 8,
    WithoutAnchoringBounds = 16
  }

  export enum Options {
    CaseInsensitive = 1,
    AllowCommentsAndWhitespace = 2,
    IgnoreMetacharacters = 4,
    DotMatchesLineSeparators = 8,
    AnchorsMatchLines = 16,
    UseUnixLineSeparators = 32,
    UseUnicodeWordBoundaries = 64
  }

}

export namespace NSRelationshipDescription {
  export enum NSDeleteRule {
    NoActionDeleteRule = 0,
    NullifyDeleteRule = 1,
    CascadeDeleteRule = 2,
    DenyDeleteRule = 3
  }

}

export namespace RelativeDateTimeFormatter {
  export enum DateTimeStyle {
    umeric = 0,
    amed = 1
  }

  export enum UnitsStyle {
    Full = 0,
    SpellOut = 1,
    Short = 2,
    Abbreviated = 3
  }

}

export namespace NSResponder {
}

export namespace NSRotationGestureRecognizer {
}

export namespace NSRuleEditor {
  export enum NestingMode {
    Single = 0,
    List = 1,
    Compound = 2,
    Simple = 3
  }

  export enum RowType {
    Simple = 0,
    Compound = 1
  }

}

export namespace NSRulerMarker {
}

export namespace NSRulerView {
  export enum Orientation {
    HorizontalRuler = 0,
    VerticalRuler = 1
  }

}

export namespace RunLoop {
}

export namespace NSRunningApplication {
  export namespace NSApplication {
    export enum ActivationOptions {
      AllWindows = 1,
      IgnoringOtherApps = 2
    }
    export enum ActivationPolicy {
      Regular = 0,
      Accessory = 1,
      Prohibited = 2
    }
  }

}

export namespace NSSaveChangesRequest {
}

export namespace NSSavePanel {
}

export namespace Scanner {
}

export namespace NSScreen {
}

export namespace NSScriptClassDescription {
}

export namespace NSScriptCoercionHandler {
}

export namespace NSScriptCommand {
}

export namespace NSScriptCommandDescription {
}

export namespace NSScriptExecutionContext {
}

export namespace NSScriptKeyValueCoding {
}

export namespace NSScriptObjectSpecifiers {
  export namespace NSPositionalSpecifier {
    export enum InsertionPosition {
      After = 0,
      Before = 1,
      Beginning = 2,
      End = 3,
      Replace = 4
    }
  }

  export namespace NSRelativeSpecifier {
    export enum RelativePosition {
      After = 0,
      Before = 1
    }
  }

  export namespace NSWhoseSpecifier {
    export enum SubelementIdentifier {
      IndexSubelement = 0,
      EverySubelement = 1,
      MiddleSubelement = 2,
      RandomSubelement = 3,
      NoSubelement = 4
    }
  }

}

export namespace NSScriptStandardSuiteCommands {
  export enum NSSaveOptions {
    Yes = 0,
    No = 1,
    Ask = 2
  }

}

export namespace NSScriptSuiteRegistry {
}

export namespace NSScriptWhoseTests {
  export namespace NSSpecifierTest {
    export enum TestComparisonOperation {
      EqualToComparison = 0,
      LessThanOrEqualToComparison = 1,
      LessThanComparison = 2,
      GreaterThanOrEqualToComparison = 3,
      GreaterThanComparison = 4,
      BeginsWithComparison = 5,
      EndsWithComparison = 6,
      ContainsComparison = 7
    }
  }

}

export namespace NSScrollView {
  export enum Elasticity {
    Automatic = 0,
    None = 1,
    Allowed = 2
  }

  export enum FindBarPosition {
    AboveHorizontalRuler = 0,
    AboveContent = 1,
    BelowContent = 2
  }

}

export namespace NSScroller {
  export enum KnobStyle {
    Default = 0,
    Dark = 1,
    Light = 2
  }

  export enum Part {
    NoPart = 0,
    DecrementPage = 1,
    Knob = 2,
    IncrementPage = 3,
    DecrementLine = 4,
    IncrementLine = 5,
    KnobSlot = 6
  }

  export enum Style {
    Legacy = 0,
    Overlay = 1
  }

  export enum UsableParts {
    NoScrollerParts = 0,
    OnlyScrollerArrows = 1,
    AllScrollerParts = 2
  }

}

export namespace NSScrubber {
  export enum Alignment {
    None = 0,
    Leading = 1,
    Trailing = 2,
    Center = 3
  }

  export enum Mode {
    ixed = 0,
    ree = 1
  }

}

export namespace NSScrubberLayout {
}

export namespace NSSearchField {
}

export namespace NSSearchFieldCell {
}

export namespace NSSegmentedCell {
}

export namespace NSSegmentedControl {
  export enum Distribution {
    t = 0,
    ll = 1,
    llEqually = 2,
    llProportionally = 3
  }

  export enum Style {
    Automatic = 0,
    Rounded = 1,
    RoundRect = 3,
    TexturedSquare = 4,
    SmallSquare = 6,
    Separated = 8,
    TexturedRounded = 2,
    Capsule = 5
  }

  export enum SwitchTracking {
    SelectOne = 0,
    SelectAny = 1,
    Momentary = 2,
    MomentaryAccelerator = 3
  }

}

// @ts-ignore
export namespace Set {
}

export namespace NSShadow {
}

export namespace NSSharingService {
  export enum CloudKitOptions {
    Standard = 0,
    AllowPublic = 1,
    AllowPrivate = 2,
    AllowReadOnly = 16,
    AllowReadWrite = 32
  }

  export enum SharingContentScope {
    Item = 0,
    Partial = 1,
    Full = 2
  }

}

export namespace NSSharingServicePickerToolbarItem {
}

export namespace NSSharingServicePickerTouchBarItem {
}

export namespace NSSlider {
  export enum SliderType {
    Linear = 0,
    Circular = 1
  }

  export enum TickMarkPosition {
    Below = 0,
    Above = 1,
    Leading = 1,
    Trailing = 0
  }

}

export namespace NSSliderAccessory {
}

export namespace NSSliderCell {
  export namespace NSSlider {
    export enum SliderType {
      Linear = 0,
      Circular = 1
    }
    export enum TickMarkPosition {
      Below = 0,
      Above = 1,
      Leading = 1,
      Trailing = 0
    }
  }

}

export namespace NSSliderTouchBarItem {
}

export namespace NSSortDescriptor {
}

export namespace NSSound {
}

export namespace NSSpeechRecognizer {
}

export namespace NSSpeechSynthesizer {
  export enum Boundary {
    ImmediateBoundary = 0,
    WordBoundary = 1,
    SentenceBoundary = 2
  }

}

export namespace NSSpellChecker {
  export enum CorrectionIndicatorType {
    Default = 0,
    Reversion = 1,
    Guesses = 2
  }

  export enum CorrectionResponse {
    None = 0,
    Accepted = 1,
    Rejected = 2,
    Ignored = 3,
    Edited = 4,
    Reverted = 5
  }

}

export namespace NSSpellServer {
}

export namespace NSSplitView {
  export enum DividerStyle {
    Thick = 1,
    Thin = 2,
    PaneSplitter = 3
  }

}

export namespace NSSplitViewController {
}

export namespace NSSplitViewItem {
  export enum Behavior {
    Default = 0,
    Sidebar = 1,
    ContentList = 2
  }

  export enum CollapseBehavior {
    Default = 0,
    PreferResizingSplitViewWithFixedSiblings = 1,
    PreferResizingSiblingsWithFixedSplitView = 2,
    UseConstraints = 3
  }

}

export namespace NSStackView {
  export enum Distribution {
    GravityAreas = -1,
    Fill = 0,
    FillEqually = 1,
    FillProportionally = 2,
    EqualSpacing = 3,
    EqualCentering = 4
  }

  export enum Gravity {
    Top = 1,
    Leading = 1,
    Center = 2,
    Bottom = 3,
    Trailing = 3
  }

}

export namespace NSStatusBar {
}

export namespace NSStatusBarButton {
}

export namespace NSStatusItem {
  export enum Behavior {
    RemovalAllowed = 2,
    TerminationOnRemoval = 4
  }

}

export namespace NSStepper {
}

export namespace NSStepperCell {
}

export namespace NSStepperTouchBarItem {
}

export namespace NSStoryboard {
}

export namespace NSStoryboardSegue {
}

export namespace Stream {
  export enum Event {
    None = 0,
    OpenCompleted = 1,
    HasBytesAvailable = 2,
    HasSpaceAvailable = 4,
    ErrorOccurred = 8,
    EndEncountered = 16
  }

  export enum Status {
    NotOpen = 0,
    Opening = 1,
    Open = 2,
    Reading = 3,
    Writing = 4,
    AtEnd = 5,
    Closed = 6,
    Error = 7
  }

}

// @ts-ignore
export namespace String {
  export enum CompareOptions {
    CaseInsensitiveSearch = 1,
    LiteralSearch = 2,
    BackwardsSearch = 4,
    AnchoredSearch = 8,
    NumericSearch = 64,
    DiacriticInsensitiveSearch = 128,
    WidthInsensitiveSearch = 256,
    ForcedOrderingSearch = 512,
    RegularExpressionSearch = 1024
  }

  export enum DrawingOptions {
    UsesLineFragmentOrigin = 1,
    UsesFontLeading = 2,
    UsesDeviceMetrics = 8,
    TruncatesLastVisibleLine = 32,
    DisableScreenFontSubstitution = 4,
    OneShot = 16
  }

  export enum EncodingConversionOptions {
    AllowLossy = 1,
    ExternalRepresentation = 2
  }

  export enum EnumerationOptions {
    ByLines = 0,
    ByParagraphs = 1,
    ByComposedCharacterSequences = 2,
    ByWords = 3,
    BySentences = 4,
    Reverse = 256,
    SubstringNotRequired = 512,
    Localized = 1024
  }

}

export namespace NSStringDrawing {
  export namespace String {
    export enum DrawingOptions {
      UsesLineFragmentOrigin = 1,
      UsesFontLeading = 2,
      UsesDeviceMetrics = 8,
      TruncatesLastVisibleLine = 32,
      DisableScreenFontSubstitution = 4,
      OneShot = 16
    }
  }

}

export namespace NSSwitch {
}

export namespace NSTabView {
  export enum TabPosition {
    None = 0,
    Top = 1,
    Left = 2,
    Bottom = 3,
    Right = 4
  }

  export enum TabType {
    TopTabsBezelBorder = 0,
    LeftTabsBezelBorder = 1,
    BottomTabsBezelBorder = 2,
    RightTabsBezelBorder = 3,
    NoTabsBezelBorder = 4,
    NoTabsLineBorder = 5,
    NoTabsNoBorder = 6
  }

  export enum TabViewBorderType {
    None = 0,
    Line = 1,
    Bezel = 2
  }

}

export namespace NSTabViewController {
  export enum TabStyle {
    SegmentedControlOnTop = 0,
    SegmentedControlOnBottom = 1,
    Toolbar = 2,
    Unspecified = -1
  }

}

export namespace NSTabViewItem {
  export enum State {
    SelectedTab = 0,
    BackgroundTab = 1,
    PressedTab = 2
  }

}

export namespace NSTableCellView {
}

export namespace NSTableColumn {
  export enum ResizingOptions {
    NoResizing = 0,
    AutoresizingMask = 1,
    UserResizingMask = 2
  }

}

export namespace NSTableHeaderCell {
}

export namespace NSTableHeaderView {
}

export namespace NSTableRowView {
}

export namespace NSTableView {
  export enum AnimationOptions {
    EffectNone = 0,
    EffectFade = 1,
    EffectGap = 2,
    SlideUp = 16,
    SlideDown = 32,
    SlideLeft = 48,
    SlideRight = 64
  }

  export enum ColumnAutoresizingStyle {
    NoColumnAutoresizing = 0,
    UniformColumnAutoresizingStyle = 1,
    SequentialColumnAutoresizingStyle = 2,
    ReverseSequentialColumnAutoresizingStyle = 3,
    LastColumnOnlyAutoresizingStyle = 4,
    FirstColumnOnlyAutoresizingStyle = 5
  }

  export enum DraggingDestinationFeedbackStyle {
    None = -1,
    Regular = 0,
    SourceList = 1,
    Gap = 2
  }

  export enum DropOperation {
    On = 0,
    Above = 1
  }

  export enum GridLineStyle {
    GridNone = 0,
    SolidVerticalGridLineMask = 1,
    SolidHorizontalGridLineMask = 2,
    DashedHorizontalGridLineMask = 8
  }

  export enum RowActionEdge {
    Leading = 0,
    Trailing = 1
  }

  export enum RowSizeStyle {
    Default = -1,
    Custom = 0,
    Small = 1,
    Medium = 2,
    Large = 3
  }

  export enum SelectionHighlightStyle {
    None = -1,
    Regular = 0,
    SourceList = 1
  }

}

export namespace NSTableViewRowAction {
  export enum Style {
    Regular = 0,
    Destructive = 1
  }

}

export namespace Process {
  export enum TerminationReason {
    Exit = 1,
    UncaughtSignal = 2
  }

}

export namespace NSText {
  export enum NSTextAlignment {
    Left = 0,
    Right = 1,
    Center = 2,
    Justified = 3,
    Natural = 4
  }

  export enum NSTextMovement {
    Return = 16,
    Tab = 17,
    Backtab = 18,
    Left = 19,
    Right = 20,
    Up = 21,
    Down = 22,
    Cancel = 23,
    Other = 0
  }

  export enum NSWritingDirection {
    Natural = -1,
    LeftToRight = 0,
    RightToLeft = 1
  }

}

export namespace NSTextAlternatives {
}

export namespace NSTextAttachment {
}

export namespace NSTextCheckingClient {
  export enum NSTextInputTraitType {
    Default = 0,
    No = 1,
    Yes = 2
  }

}

export namespace NSTextCheckingController {
}

export namespace NSTextCheckingResult {
  export enum CheckingType {
    Orthography = 1,
    Spelling = 2,
    Grammar = 4,
    Date = 8,
    Address = 16,
    Link = 32,
    Quote = 64,
    Dash = 128,
    Replacement = 256,
    Correction = 512,
    RegularExpression = 1024,
    PhoneNumber = 2048,
    TransitInformation = 4096
  }

}

export namespace NSTextContainer {
  export enum NSLineMovementDirection {
    DoesntMove = 0,
    MovesLeft = 1,
    MovesRight = 2,
    MovesDown = 3,
    MovesUp = 4
  }

  export enum NSLineSweepDirection {
    Left = 0,
    Right = 1,
    Down = 2,
    Up = 3
  }

}

export namespace NSTextField {
  export enum BezelStyle {
    SquareBezel = 0,
    RoundedBezel = 1
  }

}

export namespace NSTextFieldCell {
  export namespace NSTextField {
    export enum BezelStyle {
      SquareBezel = 0,
      RoundedBezel = 1
    }
  }

}

export namespace NSTextFinder {
  export enum Action {
    ShowFindInterface = 1,
    NextMatch = 2,
    PreviousMatch = 3,
    ReplaceAll = 4,
    Replace = 5,
    ReplaceAndFind = 6,
    SetSearchString = 7,
    ReplaceAllInSelection = 8,
    SelectAll = 9,
    SelectAllInSelection = 10,
    HideFindInterface = 11,
    ShowReplaceInterface = 12,
    HideReplaceInterface = 13
  }

  export enum MatchingType {
    Contains = 0,
    StartsWith = 1,
    FullWord = 2,
    EndsWith = 3
  }

}

export namespace NSTextInputClient {
}

export namespace NSTextInputContext {
}

export namespace NSTextList {
  export enum Options {
    NSTextListPrependEnclosingMarker = 1
  }

}

export namespace NSTextStorage {
  export enum NSTextStorageEditActions {
    Attributes = 1,
    Characters = 2
  }

}

export namespace NSTextTable {
  export namespace NSTextBlock {
    export enum Dimension {
      Width = 0,
      MinimumWidth = 1,
      MaximumWidth = 2,
      Height = 4,
      MinimumHeight = 5,
      MaximumHeight = 6
    }
    export enum Layer {
      Padding = -1,
      Border = 0,
      Margin = 1
    }
    export enum ValueType {
      AbsoluteValueType = 0,
      PercentageValueType = 1
    }
    export enum VerticalAlignment {
      TopAlignment = 0,
      MiddleAlignment = 1,
      BottomAlignment = 2,
      BaselineAlignment = 3
    }
  }

  export enum LayoutAlgorithm {
    AutomaticLayoutAlgorithm = 0,
    FixedLayoutAlgorithm = 1
  }

}

export namespace NSTextView {
  export enum NSFindPanelAction {
    ShowFindPanel = 1,
    Next = 2,
    Previous = 3,
    ReplaceAll = 4,
    Replace = 5,
    ReplaceAndFind = 6,
    SetFindString = 7,
    ReplaceAllInSelection = 8,
    SelectAll = 9,
    SelectAllInSelection = 10
  }

  export enum NSFindPanelSubstringMatchType {
    Contains = 0,
    StartsWith = 1,
    FullWord = 2,
    EndsWith = 3
  }

  export enum NSSelectionAffinity {
    Upstream = 0,
    Downstream = 1
  }

  export enum NSSelectionGranularity {
    Character = 0,
    Word = 1,
    Paragraph = 2
  }

}

export namespace Thread {
}

export namespace TimeZone {
  export enum NameStyle {
    Standard = 0,
    ShortStandard = 1,
    DaylightSaving = 2,
    ShortDaylightSaving = 3,
    Generic = 4,
    ShortGeneric = 5
  }

}

export namespace Timer {
}

export namespace NSTitlebarAccessoryViewController {
}

export namespace NSTokenField {
  export enum TokenStyle {
    Default = 0,
    None = 1,
    Rounded = 2,
    Squared = 3,
    PlainSquared = 4
  }

}

export namespace NSTokenFieldCell {
  export namespace NSTokenField {
    export enum TokenStyle {
      Default = 0,
      None = 1,
      Rounded = 2,
      Squared = 3,
      PlainSquared = 4
    }
  }

}

export namespace NSToolbar {
  export enum DisplayMode {
    Default = 0,
    IconAndLabel = 1,
    IconOnly = 2,
    LabelOnly = 3
  }

  export enum SizeMode {
    Default = 0,
    Regular = 1,
    Small = 2
  }

}

export namespace NSToolbarItem {
}

export namespace NSToolbarItemGroup {
  export enum ControlRepresentation {
    Automatic = 0,
    Expanded = 1,
    Collapsed = 2
  }

  export enum SelectionMode {
    SelectOne = 0,
    SelectAny = 1,
    Momentary = 2
  }

}

export namespace NSTouch {
  export enum Phase {
    Began = 1,
    Moved = 2,
    Stationary = 4,
    Ended = 8,
    Cancelled = 16,
    Touching = 7,
    Any = -1
  }

  export enum TouchType {
    Direct = 0,
    Indirect = 1
  }

  export enum TouchTypeMask {
    Direct = 1,
    Indirect = 2
  }

}

export namespace NSTouchBar {
}

export namespace NSTouchBarItem {
}

export namespace NSTrackingArea {
  export enum Options {
    MouseEnteredAndExited = 1,
    MouseMoved = 2,
    CursorUpdate = 4,
    ActiveWhenFirstResponder = 16,
    ActiveInKeyWindow = 32,
    ActiveInActiveApp = 64,
    ActiveAlways = 128,
    AssumeInside = 256,
    InVisibleRect = 512,
    EnabledDuringMouseDrag = 1024
  }

}

export namespace NSTreeController {
}

export namespace NSTreeNode {
}

export namespace NSTypesetter {
  export enum NSTypesetterControlCharacterAction {
    ZeroAdvancementAction = 1,
    WhitespaceAction = 2,
    HorizontalTabAction = 4,
    LineBreakAction = 8,
    ParagraphBreakAction = 16,
    ContainerBreakAction = 32
  }

}

export namespace URL {
  export enum BookmarkCreationOptions {
    PreferFileIDResolution = 256,
    MinimalBookmark = 512,
    SuitableForBookmarkFile = 1024,
    WithSecurityScope = 2048,
    SecurityScopeAllowOnlyReadAccess = 4096
  }

  export enum BookmarkResolutionOptions {
    outUI = 256,
    outMounting = 512,
    SecurityScope = 1024
  }

}

export namespace URLAuthenticationChallenge {
}

export namespace URLCache {
  export enum StoragePolicy {
    Allowed = 0,
    AllowedInMemoryOnly = 1,
    NotAllowed = 2
  }

}

export namespace NSURLConnection {
}

export namespace URLCredential {
  export enum Persistence {
    None = 0,
    ForSession = 1,
    Permanent = 2,
    Synchronizable = 3
  }

}

export namespace URLCredentialStorage {
}

export namespace NSURLDownload {
}

export namespace NSURLError {
  export enum NSURLErrorNetworkUnavailableReason {
    Cellular = 0,
    Expensive = 1,
    Constrained = 2
  }

}

export namespace NSURLHandle {
  export enum Status {
    NotLoaded = 0,
    LoadSucceeded = 1,
    LoadInProgress = 2,
    LoadFailed = 3
  }

}

export namespace URLProtectionSpace {
}

export namespace URLProtocol {
}

export namespace URLRequest {
  export enum CachePolicy {
    UseProtocolCachePolicy = 0,
    ReloadIgnoringLocalCacheData = 1,
    ReloadIgnoringLocalAndRemoteCacheData = 4,
    ReloadIgnoringCacheData = 1,
    ReturnCacheDataElseLoad = 2,
    ReturnCacheDataDontLoad = 3,
    ReloadRevalidatingCacheData = 5
  }

  export enum NetworkServiceType {
    Default = 0,
    VoIP = 1,
    Video = 2,
    Background = 3,
    Voice = 4,
    ResponsiveData = 6,
    AVStreaming = 8,
    ResponsiveAV = 9,
    CallSignaling = 11
  }

}

export namespace URLResponse {
}

export namespace URLSession {
  export namespace URLSessionTask {
    export enum State {
      Running = 0,
      Suspended = 1,
      Canceling = 2,
      Completed = 3
    }
  }

  export namespace URLSessionTaskMetrics {
    export enum ResourceFetchType {
      Unknown = 0,
      NetworkLoad = 1,
      ServerPush = 2,
      LocalCache = 3
    }
  }

  export namespace URLSessionWebSocketTask {
    export enum CloseCode {
      Invalid = 0,
      NormalClosure = 1000,
      GoingAway = 1001,
      ProtocolError = 1002,
      UnsupportedData = 1003,
      NoStatusReceived = 1005,
      AbnormalClosure = 1006,
      InvalidFramePayloadData = 1007,
      PolicyViolation = 1008,
      MessageTooBig = 1009,
      MandatoryExtensionMissing = 1010,
      InternalServerError = 1011,
      TLSHandshakeFailure = 1015
    }
  }

  export enum AuthChallengeDisposition {
    UseCredential = 0,
    PerformDefaultHandling = 1,
    CancelAuthenticationChallenge = 2,
    RejectProtectionSpace = 3
  }

  export enum NSURLSessionDelayedRequestDisposition {
    ContinueLoading = 0,
    UseNewRequest = 1,
    Cancel = 2
  }

  export enum NSURLSessionMultipathServiceType {
    None = 0,
    Handover = 1,
    Interactive = 2,
    Aggregate = 3
  }

  export enum NSURLSessionWebSocketMessageType {
    Data = 0,
    String = 1
  }

  export enum ResponseDisposition {
    Cancel = 0,
    Allow = 1,
    BecomeDownload = 2,
    BecomeStream = 3
  }

}

export namespace UUID {
}

export namespace NSUbiquitousKeyValueStore {
}

export namespace UndoManager {
}

export namespace Unit {
}

export namespace NSUserActivity {
}

export namespace UserDefaults {
}

export namespace NSUserDefaultsController {
}

export namespace NSUserInterfaceCompression {
}

export namespace NSUserInterfaceItemIdentification {
}

export namespace NSUserInterfaceItemSearching {
}

export namespace NSUserInterfaceLayout {
  export enum NSUserInterfaceLayoutDirection {
    LeftToRight = 0,
    RightToLeft = 1
  }

  export enum NSUserInterfaceLayoutOrientation {
    Horizontal = 0,
    Vertical = 1
  }

}

export namespace NSUserNotification {
  export enum ActivationType {
    None = 0,
    ContentsClicked = 1,
    ActionButtonClicked = 2,
    Replied = 3,
    AdditionalActionClicked = 4
  }

}

export namespace NSUserScriptTask {
}

export namespace NSValue {
}

export namespace ValueTransformer {
}

export namespace NSView {
  export enum AutoresizingMask {
    NotSizable = 0,
    MinXMargin = 1,
    WidthSizable = 2,
    MaxXMargin = 4,
    MinYMargin = 8,
    HeightSizable = 16,
    MaxYMargin = 32
  }

  export enum BackgroundStyle {
    Normal = 0,
    Emphasized = 1,
    Raised = 2,
    Lowered = 3
  }

  export enum LayerContentsPlacement {
    ScaleAxesIndependently = 0,
    ScaleProportionallyToFit = 1,
    ScaleProportionallyToFill = 2,
    Center = 3,
    Top = 4,
    TopRight = 5,
    Right = 6,
    BottomRight = 7,
    Bottom = 8,
    BottomLeft = 9,
    Left = 10,
    TopLeft = 11
  }

  export enum LayerContentsRedrawPolicy {
    Never = 0,
    OnSetNeedsDisplay = 1,
    DuringViewResize = 2,
    BeforeViewResize = 3,
    Crossfade = 4
  }

  export enum NSBorderType {
    NoBorder = 0,
    LineBorder = 1,
    BezelBorder = 2,
    GrooveBorder = 3
  }

}

export namespace NSViewController {
  export enum TransitionOptions {
    None = 0,
    Crossfade = 1,
    SlideUp = 16,
    SlideDown = 32,
    SlideLeft = 64,
    SlideRight = 128,
    SlideForward = 320,
    SlideBackward = 384,
    AllowUserInteraction = 4096
  }

}

export namespace NSVisualEffectView {
  export enum BlendingMode {
    BehindWindow = 0,
    WithinWindow = 1
  }

  export enum Material {
    Titlebar = 3,
    Selection = 4,
    Menu = 5,
    Popover = 6,
    Sidebar = 7,
    HeaderView = 10,
    Sheet = 11,
    WindowBackground = 12,
    HUDWindow = 13,
    FullScreenUI = 15,
    ToolTip = 17,
    ContentBackground = 18,
    UnderWindowBackground = 21,
    UnderPageBackground = 22,
    AppearanceBased = 0,
    Light = 1,
    Dark = 2,
    MediumLight = 8,
    UltraDark = 9
  }

  export enum State {
    FollowsWindowActiveState = 0,
    Active = 1,
    Inactive = 2
  }

}

export namespace NSWindow {
  export enum AnimationBehavior {
    Default = 0,
    None = 2,
    DocumentWindow = 3,
    UtilityWindow = 4,
    AlertPanel = 5
  }

  export enum BackingStoreType {
    Retained = 0,
    Nonretained = 1,
    Buffered = 2
  }

  export enum ButtonType {
    CloseButton = 0,
    MiniaturizeButton = 1,
    ZoomButton = 2,
    ToolbarButton = 3,
    DocumentIconButton = 4,
    DocumentVersionsButton = 6
  }

  export enum CollectionBehavior {
    Default = 0,
    CanJoinAllSpaces = 1,
    MoveToActiveSpace = 2,
    Managed = 4,
    Transient = 8,
    Stationary = 16,
    ParticipatesInCycle = 32,
    IgnoresCycle = 64,
    FullScreenPrimary = 128,
    FullScreenAuxiliary = 256,
    FullScreenNone = 512,
    FullScreenAllowsTiling = 2048,
    FullScreenDisallowsTiling = 4096
  }

  export enum Depth {
    TwentyfourBitRGB = 520,
    SixtyfourBitRGB = 528,
    OnehundredtwentyeightBitRGB = 544
  }

  export enum NumberListOptions {
    Applications = 1,
    Spaces = 16
  }

  export enum OcclusionState {
    NSWindowOcclusionStateVisible = 2
  }

  export enum OrderingMode {
    Above = 1,
    Below = -1,
    Out = 0
  }

  export enum SelectionDirection {
    DirectSelection = 0,
    SelectingNext = 1,
    SelectingPrevious = 2
  }

  export enum SharingType {
    None = 0,
    ReadOnly = 1,
    ReadWrite = 2
  }

  export enum StyleMask {
    Borderless = 0,
    Titled = 1,
    Closable = 2,
    Miniaturizable = 4,
    Resizable = 8,
    TexturedBackground = 256,
    UnifiedTitleAndToolbar = 4096,
    FullScreen = 16384,
    FullSizeContentView = 32768,
    UtilityWindow = 16,
    DocModalWindow = 64,
    NonactivatingPanel = 128,
    HUDWindow = 8192
  }

  export enum TabbingMode {
    Automatic = 0,
    Preferred = 1,
    Disallowed = 2
  }

  export enum TitleVisibility {
    Visible = 0,
    Hidden = 1
  }

  export enum UserTabbingPreference {
    Manual = 0,
    Always = 1,
    InFullScreen = 2
  }

}

export namespace NSWindowController {
}

export namespace NSWindowRestoration {
}

export namespace NSWindowTab {
}

export namespace NSWindowTabGroup {
}

export namespace NSWorkspace {
  export class Authorization extends NSObject {
  }
  
  export class OpenConfiguration extends NSObject {
    static configuration(): NSWorkspace.OpenConfiguration;
    activates: boolean;
    setActivates(_: boolean);
    addsToRecentItems: boolean;
    setAddsToRecentItems(_: boolean);
    allowsRunningApplicationSubstitution: boolean;
    setAllowsRunningApplicationSubstitution(_: boolean);
    appleEvent: NSAppleEventDescriptor;
    setAppleEvent(_: NSAppleEventDescriptor);
    architecture: number;
    setArchitecture(_: number);
    arguments: string[];
    setArguments(_: string[]);
    createsNewApplicationInstance: boolean;
    setCreatesNewApplicationInstance(_: boolean);
    environment: Map<string, string>;
    setEnvironment(_: Map<string, string>);
    isForPrinting: boolean;
    setForPrinting(_: boolean);
    hides: boolean;
    setHides(_: boolean);
    hidesOthers: boolean;
    setHidesOthers(_: boolean);
    promptsUserIfNeeded: boolean;
    setPromptsUserIfNeeded(_: boolean);
    requiresUniversalLinks: boolean;
    setRequiresUniversalLinks(_: boolean);
  }
  
  export enum AuthorizationType {
    CreateSymbolicLink = 0,
    SetAttributes = 1,
    ReplaceFile = 2
  }

  export enum IconCreationOptions {
    eQuickDrawElementsIconCreationOption = 2,
    e10_4ElementsIconCreationOption = 4
  }

  export enum LaunchOptions {
    AndPrint = 2,
    WithErrorPresentation = 64,
    InhibitingBackgroundOnly = 128,
    WithoutAddingToRecents = 256,
    WithoutActivation = 512,
    Async = 65536,
    NewInstance = 524288,
    AndHide = 1048576,
    AndHideOthers = 2097152,
    Default = 65536,
    AllowingClassicStartup = 131072,
    PreferringClassic = 262144
  }

}

export namespace XMLDTD {
}

export namespace XMLDTDNode {
  export enum DTDKind {
    EntityGeneralKind = 1,
    EntityParsedKind = 2,
    EntityUnparsedKind = 3,
    EntityParameterKind = 4,
    EntityPredefined = 5,
    AttributeCDATAKind = 6,
    AttributeIDKind = 7,
    AttributeIDRefKind = 8,
    AttributeIDRefsKind = 9,
    AttributeEntityKind = 10,
    AttributeEntitiesKind = 11,
    AttributeNMTokenKind = 12,
    AttributeNMTokensKind = 13,
    AttributeEnumerationKind = 14,
    AttributeNotationKind = 15,
    ElementDeclarationUndefinedKind = 16,
    ElementDeclarationEmptyKind = 17,
    ElementDeclarationAnyKind = 18,
    ElementDeclarationMixedKind = 19,
    ElementDeclarationElementKind = 20
  }

}

export namespace XMLDocument {
  export enum ContentKind {
    XMLKind = 0,
    XHTMLKind = 1,
    HTMLKind = 2,
    TextKind = 3
  }

}

export namespace XMLElement {
}

export namespace XMLNode {
  export enum Kind {
    InvalidKind = 0,
    DocumentKind = 1,
    ElementKind = 2,
    AttributeKind = 3,
    NamespaceKind = 4,
    ProcessingInstructionKind = 5,
    CommentKind = 6,
    TextKind = 7,
    DTDKind = 8,
    EntityDeclarationKind = 9,
    AttributeDeclarationKind = 10,
    ElementDeclarationKind = 11,
    NotationDeclarationKind = 12
  }

  export enum Options {
    NodeOptionsNone = 0,
    NodeIsCDATA = 1,
    NodeExpandEmptyElement = 2,
    NodeCompactEmptyElement = 4,
    NodeUseSingleQuotes = 8,
    NodeUseDoubleQuotes = 16,
    NodeNeverEscapeContents = 32,
    DocumentTidyHTML = 512,
    DocumentTidyXML = 1024,
    DocumentValidate = 8192,
    NodeLoadExternalEntitiesAlways = 16384,
    NodeLoadExternalEntitiesSameOriginOnly = 32768,
    NodeLoadExternalEntitiesNever = 524288,
    DocumentXInclude = 65536,
    NodePrettyPrint = 131072,
    DocumentIncludeContentTypeDeclaration = 262144,
    NodePreserveNamespaceOrder = 1048576,
    NodePreserveAttributeOrder = 2097152,
    NodePreserveEntities = 4194304,
    NodePreservePrefixes = 8388608,
    NodePreserveCDATA = 16777216,
    NodePreserveWhitespace = 33554432,
    NodePreserveDTD = 67108864,
    NodePreserveCharacterReferences = 134217728,
    NodePromoteSignificantWhitespace = 268435456,
    NodePreserveEmptyElements = 6,
    NodePreserveQuotes = 24,
    NodePreserveAll = 4293918750
  }

}

export namespace XMLParser {
  export enum ErrorCode {
    InternalError = 1,
    OutOfMemoryError = 2,
    DocumentStartError = 3,
    EmptyDocumentError = 4,
    PrematureDocumentEndError = 5,
    InvalidHexCharacterRefError = 6,
    InvalidDecimalCharacterRefError = 7,
    InvalidCharacterRefError = 8,
    InvalidCharacterError = 9,
    CharacterRefAtEOFError = 10,
    CharacterRefInPrologError = 11,
    CharacterRefInEpilogError = 12,
    CharacterRefInDTDError = 13,
    EntityRefAtEOFError = 14,
    EntityRefInPrologError = 15,
    EntityRefInEpilogError = 16,
    EntityRefInDTDError = 17,
    ParsedEntityRefAtEOFError = 18,
    ParsedEntityRefInPrologError = 19,
    ParsedEntityRefInEpilogError = 20,
    ParsedEntityRefInInternalSubsetError = 21,
    EntityReferenceWithoutNameError = 22,
    EntityReferenceMissingSemiError = 23,
    ParsedEntityRefNoNameError = 24,
    ParsedEntityRefMissingSemiError = 25,
    UndeclaredEntityError = 26,
    UnparsedEntityError = 28,
    EntityIsExternalError = 29,
    EntityIsParameterError = 30,
    UnknownEncodingError = 31,
    EncodingNotSupportedError = 32,
    StringNotStartedError = 33,
    StringNotClosedError = 34,
    NamespaceDeclarationError = 35,
    EntityNotStartedError = 36,
    EntityNotFinishedError = 37,
    LessThanSymbolInAttributeError = 38,
    AttributeNotStartedError = 39,
    AttributeNotFinishedError = 40,
    AttributeHasNoValueError = 41,
    AttributeRedefinedError = 42,
    LiteralNotStartedError = 43,
    LiteralNotFinishedError = 44,
    CommentNotFinishedError = 45,
    ProcessingInstructionNotStartedError = 46,
    ProcessingInstructionNotFinishedError = 47,
    NotationNotStartedError = 48,
    NotationNotFinishedError = 49,
    AttributeListNotStartedError = 50,
    AttributeListNotFinishedError = 51,
    MixedContentDeclNotStartedError = 52,
    MixedContentDeclNotFinishedError = 53,
    ElementContentDeclNotStartedError = 54,
    ElementContentDeclNotFinishedError = 55,
    XMLDeclNotStartedError = 56,
    XMLDeclNotFinishedError = 57,
    ConditionalSectionNotStartedError = 58,
    ConditionalSectionNotFinishedError = 59,
    ExternalSubsetNotFinishedError = 60,
    DOCTYPEDeclNotFinishedError = 61,
    MisplacedCDATAEndStringError = 62,
    CDATANotFinishedError = 63,
    MisplacedXMLDeclarationError = 64,
    SpaceRequiredError = 65,
    SeparatorRequiredError = 66,
    NMTOKENRequiredError = 67,
    NAMERequiredError = 68,
    PCDATARequiredError = 69,
    URIRequiredError = 70,
    PublicIdentifierRequiredError = 71,
    LTRequiredError = 72,
    GTRequiredError = 73,
    LTSlashRequiredError = 74,
    EqualExpectedError = 75,
    TagNameMismatchError = 76,
    UnfinishedTagError = 77,
    StandaloneValueError = 78,
    InvalidEncodingNameError = 79,
    CommentContainsDoubleHyphenError = 80,
    InvalidEncodingError = 81,
    ExternalStandaloneEntityError = 82,
    InvalidConditionalSectionError = 83,
    EntityValueRequiredError = 84,
    NotWellBalancedError = 85,
    ExtraContentError = 86,
    InvalidCharacterInEntityError = 87,
    ParsedEntityRefInInternalError = 88,
    EntityRefLoopError = 89,
    EntityBoundaryError = 90,
    InvalidURIError = 91,
    URIFragmentError = 92,
    NoDTDError = 94,
    DelegateAbortedParseError = 512
  }

  export enum ExternalEntityResolvingPolicy {
    Never = 0,
    NoNetwork = 1,
    SameOriginOnly = 2,
    Always = 3
  }

}

export namespace NSXPCConnection {
  export enum Options {
    NSXPCConnectionPrivileged = 4096
  }

}

export namespace QCComposition {
}

export namespace QCPlugIn {
  export enum QCPlugInExecutionMode {
    Provider = 1,
    Processor = 2,
    Consumer = 3
  }

  export enum QCPlugInTimeMode {
    None = 0,
    Idle = 1,
    TimeBase = 2
  }

}

export namespace QLPreviewItem {
}

export namespace QLPreviewPanel {
}

export namespace QLPreviewView {
  export enum QLPreviewViewStyle {
    Normal = 0,
    Compact = 1
  }

}

export namespace QLPreviewingController {
}

export namespace QuartzFilter {
}

export namespace QuartzFilterManager {
}

export namespace runtime {
  export enum objc_AssociationPolicy {
    N_ASSIGN = 0,
    N_RETAIN_NONATOMIC = 1,
    N_COPY_NONATOMIC = 3,
    N_RETAIN = 769,
    N_COPY = 771
  }

}

}

// Add enums to the already-existing bridged classes
//
// If we didn't do this, these would be duplicated
// (i.e. both NSButton and NSButton$1 would exist
// in global scope)

let global = globalThis as any;


(globalThis as any)['AVAsset'] = (globalThis as any)['AVAsset'] || {};
(globalThis as any)['AVAsset']['AVAssetReferenceRestrictions'] = (globalThis as any)['AVAsset']['AVAssetReferenceRestrictions'] || {};
(globalThis as any)['AVAsset']['AVAssetReferenceRestrictions'] = {
  ForbidNone: 0,
  ForbidRemoteReferenceToLocal: 1,
  ForbidLocalReferenceToRemote: 2,
  ForbidCrossSiteReference: 4,
  ForbidLocalReferenceToLocal: 8,
  ForbidAll: 65535,
  DefaultPolicy: 2
};


(globalThis as any)['AVAssetCache'] = (globalThis as any)['AVAssetCache'] || {};

(globalThis as any)['AVAssetExportSession'] = (globalThis as any)['AVAssetExportSession'] || {};
(globalThis as any)['AVAssetExportSession']['Status'] = (globalThis as any)['AVAssetExportSession']['Status'] || {};
(globalThis as any)['AVAssetExportSession']['Status'] = {
  Unknown: 0,
  Waiting: 1,
  Exporting: 2,
  Completed: 3,
  Failed: 4,
  Cancelled: 5
};


(globalThis as any)['AVAssetImageGenerator'] = (globalThis as any)['AVAssetImageGenerator'] || {};
(globalThis as any)['AVAssetImageGenerator']['Result'] = (globalThis as any)['AVAssetImageGenerator']['Result'] || {};
(globalThis as any)['AVAssetImageGenerator']['Result'] = {
  Succeeded: 0,
  Failed: 1,
  Cancelled: 2
};


(globalThis as any)['AVAssetReader'] = (globalThis as any)['AVAssetReader'] || {};
(globalThis as any)['AVAssetReader']['Status'] = (globalThis as any)['AVAssetReader']['Status'] || {};
(globalThis as any)['AVAssetReader']['Status'] = {
  Unknown: 0,
  Reading: 1,
  Completed: 2,
  Failed: 3,
  Cancelled: 4
};


(globalThis as any)['AVAssetReaderOutput'] = (globalThis as any)['AVAssetReaderOutput'] || {};

(globalThis as any)['AVAssetResourceLoader'] = (globalThis as any)['AVAssetResourceLoader'] || {};

(globalThis as any)['AVAssetTrack'] = (globalThis as any)['AVAssetTrack'] || {};

(globalThis as any)['AVAssetTrackGroup'] = (globalThis as any)['AVAssetTrackGroup'] || {};

(globalThis as any)['AVAssetTrackSegment'] = (globalThis as any)['AVAssetTrackSegment'] || {};

(globalThis as any)['AVAssetWriter'] = (globalThis as any)['AVAssetWriter'] || {};
(globalThis as any)['AVAssetWriter']['Status'] = (globalThis as any)['AVAssetWriter']['Status'] || {};
(globalThis as any)['AVAssetWriter']['Status'] = {
  Unknown: 0,
  Writing: 1,
  Completed: 2,
  Failed: 3,
  Cancelled: 4
};


(globalThis as any)['AVAssetWriterInput'] = (globalThis as any)['AVAssetWriterInput'] || {};

(globalThis as any)['AVAsynchronousKeyValueLoading'] = (globalThis as any)['AVAsynchronousKeyValueLoading'] || {};
(globalThis as any)['AVAsynchronousKeyValueLoading']['AVKeyValueStatus'] = (globalThis as any)['AVAsynchronousKeyValueLoading']['AVKeyValueStatus'] || {};
(globalThis as any)['AVAsynchronousKeyValueLoading']['AVKeyValueStatus'] = {
  Unknown: 0,
  Loading: 1,
  Loaded: 2,
  Failed: 3,
  Cancelled: 4
};


(globalThis as any)['AVAudioBuffer'] = (globalThis as any)['AVAudioBuffer'] || {};

(globalThis as any)['AVAudioChannelLayout'] = (globalThis as any)['AVAudioChannelLayout'] || {};

(globalThis as any)['AVAudioConnectionPoint'] = (globalThis as any)['AVAudioConnectionPoint'] || {};

(globalThis as any)['AVAudioConverter'] = (globalThis as any)['AVAudioConverter'] || {};
(globalThis as any)['AVAudioConverter']['AVAudioConverterInputStatus'] = (globalThis as any)['AVAudioConverter']['AVAudioConverterInputStatus'] || {};
(globalThis as any)['AVAudioConverter']['AVAudioConverterInputStatus'] = {
  _HaveData: 0,
  _NoDataNow: 1,
  _EndOfStream: 2
};

(globalThis as any)['AVAudioConverter']['AVAudioConverterOutputStatus'] = (globalThis as any)['AVAudioConverter']['AVAudioConverterOutputStatus'] || {};
(globalThis as any)['AVAudioConverter']['AVAudioConverterOutputStatus'] = {
  _HaveData: 0,
  _InputRanDry: 1,
  _EndOfStream: 2,
  _Error: 3
};

(globalThis as any)['AVAudioConverter']['AVAudioConverterPrimeMethod'] = (globalThis as any)['AVAudioConverter']['AVAudioConverterPrimeMethod'] || {};
(globalThis as any)['AVAudioConverter']['AVAudioConverterPrimeMethod'] = {
  _Pre: 0,
  _Normal: 1,
  _None: 2
};


(globalThis as any)['AVAudioEngine'] = (globalThis as any)['AVAudioEngine'] || {};
(globalThis as any)['AVAudioEngine']['AVAudioEngineManualRenderingError'] = (globalThis as any)['AVAudioEngine']['AVAudioEngineManualRenderingError'] || {};
(globalThis as any)['AVAudioEngine']['AVAudioEngineManualRenderingError'] = {
  InvalidMode: -80800,
  Initialized: -80801,
  NotRunning: -80802
};

(globalThis as any)['AVAudioEngine']['AVAudioEngineManualRenderingMode'] = (globalThis as any)['AVAudioEngine']['AVAudioEngineManualRenderingMode'] || {};
(globalThis as any)['AVAudioEngine']['AVAudioEngineManualRenderingMode'] = {
  Offline: 0,
  Realtime: 1
};

(globalThis as any)['AVAudioEngine']['AVAudioEngineManualRenderingStatus'] = (globalThis as any)['AVAudioEngine']['AVAudioEngineManualRenderingStatus'] || {};
(globalThis as any)['AVAudioEngine']['AVAudioEngineManualRenderingStatus'] = {
  Error: -1,
  Success: 0,
  InsufficientDataFromInputNode: 1,
  CannotDoInCurrentContext: 2
};


(globalThis as any)['AVAudioEnvironmentNode'] = (globalThis as any)['AVAudioEnvironmentNode'] || {};
(globalThis as any)['AVAudioEnvironmentNode']['AVAudioEnvironmentDistanceAttenuationModel'] = (globalThis as any)['AVAudioEnvironmentNode']['AVAudioEnvironmentDistanceAttenuationModel'] || {};
(globalThis as any)['AVAudioEnvironmentNode']['AVAudioEnvironmentDistanceAttenuationModel'] = {
  Exponential: 1,
  Inverse: 2,
  Linear: 3
};

(globalThis as any)['AVAudioEnvironmentNode']['AVAudioEnvironmentOutputType'] = (globalThis as any)['AVAudioEnvironmentNode']['AVAudioEnvironmentOutputType'] || {};
(globalThis as any)['AVAudioEnvironmentNode']['AVAudioEnvironmentOutputType'] = {
  Auto: 0,
  Headphones: 1,
  BuiltInSpeakers: 2,
  ExternalSpeakers: 3
};


(globalThis as any)['AVAudioFile'] = (globalThis as any)['AVAudioFile'] || {};

(globalThis as any)['AVAudioFormat'] = (globalThis as any)['AVAudioFormat'] || {};
(globalThis as any)['AVAudioFormat']['AVAudioCommonFormat'] = (globalThis as any)['AVAudioFormat']['AVAudioCommonFormat'] || {};
(globalThis as any)['AVAudioFormat']['AVAudioCommonFormat'] = {
  OtherFormat: 0,
  PCMFormatFloat32: 1,
  PCMFormatFloat64: 2,
  PCMFormatInt16: 3,
  PCMFormatInt32: 4
};


(globalThis as any)['AVAudioIONode'] = (globalThis as any)['AVAudioIONode'] || {};

(globalThis as any)['AVAudioMix'] = (globalThis as any)['AVAudioMix'] || {};

(globalThis as any)['AVAudioMixerNode'] = (globalThis as any)['AVAudioMixerNode'] || {};

(globalThis as any)['AVAudioMixing'] = (globalThis as any)['AVAudioMixing'] || {};
(globalThis as any)['AVAudioMixing']['AVAudio3DMixingPointSourceInHeadMode'] = (globalThis as any)['AVAudioMixing']['AVAudio3DMixingPointSourceInHeadMode'] || {};
(globalThis as any)['AVAudioMixing']['AVAudio3DMixingPointSourceInHeadMode'] = {
  eMono: 0,
  eBypass: 1
};

(globalThis as any)['AVAudioMixing']['AVAudio3DMixingRenderingAlgorithm'] = (globalThis as any)['AVAudioMixing']['AVAudio3DMixingRenderingAlgorithm'] || {};
(globalThis as any)['AVAudioMixing']['AVAudio3DMixingRenderingAlgorithm'] = {
  mEqualPowerPanning: 0,
  mSphericalHead: 1,
  mHRTF: 2,
  mSoundField: 3,
  mStereoPassThrough: 5,
  mHRTFHQ: 6,
  mAuto: 7
};

(globalThis as any)['AVAudioMixing']['AVAudio3DMixingSourceMode'] = (globalThis as any)['AVAudioMixing']['AVAudio3DMixingSourceMode'] || {};
(globalThis as any)['AVAudioMixing']['AVAudio3DMixingSourceMode'] = {
  eSpatializeIfMono: 0,
  eBypass: 1,
  ePointSource: 2,
  eAmbienceBed: 3
};


(globalThis as any)['AVAudioNode'] = (globalThis as any)['AVAudioNode'] || {};

(globalThis as any)['AVAudioPlayer'] = (globalThis as any)['AVAudioPlayer'] || {};

(globalThis as any)['AVAudioPlayerNode'] = (globalThis as any)['AVAudioPlayerNode'] || {};
(globalThis as any)['AVAudioPlayerNode']['AVAudioPlayerNodeBufferOptions'] = (globalThis as any)['AVAudioPlayerNode']['AVAudioPlayerNodeBufferOptions'] || {};
(globalThis as any)['AVAudioPlayerNode']['AVAudioPlayerNodeBufferOptions'] = {
  Loops: 1,
  Interrupts: 2,
  InterruptsAtLoop: 4
};

(globalThis as any)['AVAudioPlayerNode']['AVAudioPlayerNodeCompletionCallbackType'] = (globalThis as any)['AVAudioPlayerNode']['AVAudioPlayerNodeCompletionCallbackType'] || {};
(globalThis as any)['AVAudioPlayerNode']['AVAudioPlayerNodeCompletionCallbackType'] = {
  Consumed: 0,
  Rendered: 1,
  PlayedBack: 2
};



(globalThis as any)['AVAudioRecorder'] = (globalThis as any)['AVAudioRecorder'] || {};

(globalThis as any)['AVAudioSequencer'] = (globalThis as any)['AVAudioSequencer'] || {};
(globalThis as any)['AVAudioSequencer']['AVMusicSequenceLoadOptions'] = (globalThis as any)['AVAudioSequencer']['AVMusicSequenceLoadOptions'] || {};
(globalThis as any)['AVAudioSequencer']['AVMusicSequenceLoadOptions'] = {
  _PreserveTracks: 0,
  _ChannelsToTracks: 1
};

(globalThis as any)['AVAudioSequencer']['AVMusicTrackLoopCount'] = (globalThis as any)['AVAudioSequencer']['AVMusicTrackLoopCount'] || {};
(globalThis as any)['AVAudioSequencer']['AVMusicTrackLoopCount'] = {
  AVMusicTrackLoopCountForever: -1
};


(globalThis as any)['AVAudioSession'] = (globalThis as any)['AVAudioSession'] || {};
(globalThis as any)['AVAudioSession']['AVAudioSessionActivationOptions'] = (globalThis as any)['AVAudioSession']['AVAudioSessionActivationOptions'] || {};
(globalThis as any)['AVAudioSession']['AVAudioSessionActivationOptions'] = {
  AVAudioSessionActivationOptionNone: 0
};

(globalThis as any)['AVAudioSession']['CategoryOptions'] = (globalThis as any)['AVAudioSession']['CategoryOptions'] || {};
(globalThis as any)['AVAudioSession']['CategoryOptions'] = {
  MixWithOthers: 1,
  DuckOthers: 2,
  AllowBluetooth: 4,
  DefaultToSpeaker: 8,
  InterruptSpokenAudioAndMixWithOthers: 17,
  AllowBluetoothA2DP: 32,
  AllowAirPlay: 64
};

(globalThis as any)['AVAudioSession']['IOType'] = (globalThis as any)['AVAudioSession']['IOType'] || {};
(globalThis as any)['AVAudioSession']['IOType'] = {
  NotSpecified: 0,
  Aggregated: 1
};

(globalThis as any)['AVAudioSession']['InterruptionOptions'] = (globalThis as any)['AVAudioSession']['InterruptionOptions'] || {};
(globalThis as any)['AVAudioSession']['InterruptionOptions'] = {
  AVAudioSessionInterruptionOptionShouldResume: 1
};

(globalThis as any)['AVAudioSession']['InterruptionType'] = (globalThis as any)['AVAudioSession']['InterruptionType'] || {};
(globalThis as any)['AVAudioSession']['InterruptionType'] = {
  Began: 1,
  Ended: 0
};

(globalThis as any)['AVAudioSession']['PortOverride'] = (globalThis as any)['AVAudioSession']['PortOverride'] || {};
(globalThis as any)['AVAudioSession']['PortOverride'] = {
  None: 0,
  Speaker: 1936747378
};

(globalThis as any)['AVAudioSession']['PromptStyle'] = (globalThis as any)['AVAudioSession']['PromptStyle'] || {};
(globalThis as any)['AVAudioSession']['PromptStyle'] = {
  None: 1852796517,
  Short: 1936224884,
  Normal: 1852992876
};

(globalThis as any)['AVAudioSession']['RecordPermission'] = (globalThis as any)['AVAudioSession']['RecordPermission'] || {};
(globalThis as any)['AVAudioSession']['RecordPermission'] = {
  Undetermined: 1970168948,
  Denied: 1684369017,
  Granted: 1735552628
};

(globalThis as any)['AVAudioSession']['RouteChangeReason'] = (globalThis as any)['AVAudioSession']['RouteChangeReason'] || {};
(globalThis as any)['AVAudioSession']['RouteChangeReason'] = {
  Unknown: 0,
  NewDeviceAvailable: 1,
  OldDeviceUnavailable: 2,
  CategoryChange: 3,
  Override: 4,
  WakeFromSleep: 6,
  NoSuitableRouteForCategory: 7,
  RouteConfigurationChange: 8
};

(globalThis as any)['AVAudioSession']['RouteSharingPolicy'] = (globalThis as any)['AVAudioSession']['RouteSharingPolicy'] || {};
(globalThis as any)['AVAudioSession']['RouteSharingPolicy'] = {
  Default: 0,
  LongFormAudio: 1,
  LongForm: 1,
  Independent: 2,
  LongFormVideo: 3
};

(globalThis as any)['AVAudioSession']['SetActiveOptions'] = (globalThis as any)['AVAudioSession']['SetActiveOptions'] || {};
(globalThis as any)['AVAudioSession']['SetActiveOptions'] = {
  AVAudioSessionSetActiveOptionNotifyOthersOnDeactivation: 1
};

(globalThis as any)['AVAudioSession']['SilenceSecondaryAudioHintType'] = (globalThis as any)['AVAudioSession']['SilenceSecondaryAudioHintType'] || {};
(globalThis as any)['AVAudioSession']['SilenceSecondaryAudioHintType'] = {
  Begin: 1,
  End: 0
};


(globalThis as any)['AVAudioSettings'] = (globalThis as any)['AVAudioSettings'] || {};
(globalThis as any)['AVAudioSettings']['AVAudioQuality'] = (globalThis as any)['AVAudioSettings']['AVAudioQuality'] || {};
(globalThis as any)['AVAudioSettings']['AVAudioQuality'] = {
  Min: 0,
  Low: 32,
  Medium: 64,
  High: 96,
  Max: 127
};


(globalThis as any)['AVAudioTime'] = (globalThis as any)['AVAudioTime'] || {};

(globalThis as any)['AVAudioUnit'] = (globalThis as any)['AVAudioUnit'] || {};

(globalThis as any)['AVAudioUnitComponent'] = (globalThis as any)['AVAudioUnitComponent'] || {};

(globalThis as any)['AVAudioUnitDelay'] = (globalThis as any)['AVAudioUnitDelay'] || {};

(globalThis as any)['AVAudioUnitDistortion'] = (globalThis as any)['AVAudioUnitDistortion'] || {};
(globalThis as any)['AVAudioUnitDistortion']['AVAudioUnitDistortionPreset'] = (globalThis as any)['AVAudioUnitDistortion']['AVAudioUnitDistortionPreset'] || {};
(globalThis as any)['AVAudioUnitDistortion']['AVAudioUnitDistortionPreset'] = {
  DrumsBitBrush: 0,
  DrumsBufferBeats: 1,
  DrumsLoFi: 2,
  MultiBrokenSpeaker: 3,
  MultiCellphoneConcert: 4,
  MultiDecimated1: 5,
  MultiDecimated2: 6,
  MultiDecimated3: 7,
  MultiDecimated4: 8,
  MultiDistortedFunk: 9,
  MultiDistortedCubed: 10,
  MultiDistortedSquared: 11,
  MultiEcho1: 12,
  MultiEcho2: 13,
  MultiEchoTight1: 14,
  MultiEchoTight2: 15,
  MultiEverythingIsBroken: 16,
  SpeechAlienChatter: 17,
  SpeechCosmicInterference: 18,
  SpeechGoldenPi: 19,
  SpeechRadioTower: 20,
  SpeechWaves: 21
};


(globalThis as any)['AVAudioUnitEQ'] = (globalThis as any)['AVAudioUnitEQ'] || {};
(globalThis as any)['AVAudioUnitEQ']['AVAudioUnitEQFilterType'] = (globalThis as any)['AVAudioUnitEQ']['AVAudioUnitEQFilterType'] || {};
(globalThis as any)['AVAudioUnitEQ']['AVAudioUnitEQFilterType'] = {
  Parametric: 0,
  LowPass: 1,
  HighPass: 2,
  ResonantLowPass: 3,
  ResonantHighPass: 4,
  BandPass: 5,
  BandStop: 6,
  LowShelf: 7,
  HighShelf: 8,
  ResonantLowShelf: 9,
  ResonantHighShelf: 10
};


(globalThis as any)['AVAudioUnitEffect'] = (globalThis as any)['AVAudioUnitEffect'] || {};

(globalThis as any)['AVAudioUnitGenerator'] = (globalThis as any)['AVAudioUnitGenerator'] || {};

(globalThis as any)['AVAudioUnitMIDIInstrument'] = (globalThis as any)['AVAudioUnitMIDIInstrument'] || {};

(globalThis as any)['AVAudioUnitReverb'] = (globalThis as any)['AVAudioUnitReverb'] || {};
(globalThis as any)['AVAudioUnitReverb']['AVAudioUnitReverbPreset'] = (globalThis as any)['AVAudioUnitReverb']['AVAudioUnitReverbPreset'] || {};
(globalThis as any)['AVAudioUnitReverb']['AVAudioUnitReverbPreset'] = {
  SmallRoom: 0,
  MediumRoom: 1,
  LargeRoom: 2,
  MediumHall: 3,
  LargeHall: 4,
  Plate: 5,
  MediumChamber: 6,
  LargeChamber: 7,
  Cathedral: 8,
  LargeRoom2: 9,
  MediumHall2: 10,
  MediumHall3: 11,
  LargeHall2: 12
};


(globalThis as any)['AVAudioUnitSampler'] = (globalThis as any)['AVAudioUnitSampler'] || {};

(globalThis as any)['AVAudioUnitTimeEffect'] = (globalThis as any)['AVAudioUnitTimeEffect'] || {};

(globalThis as any)['AVAudioUnitTimePitch'] = (globalThis as any)['AVAudioUnitTimePitch'] || {};

(globalThis as any)['AVAudioUnitVarispeed'] = (globalThis as any)['AVAudioUnitVarispeed'] || {};

(globalThis as any)['AVCameraCalibrationData'] = (globalThis as any)['AVCameraCalibrationData'] || {};

(globalThis as any)['AVCaptureAudioDataOutput'] = (globalThis as any)['AVCaptureAudioDataOutput'] || {};

(globalThis as any)['AVCaptureAudioPreviewOutput'] = (globalThis as any)['AVCaptureAudioPreviewOutput'] || {};

(globalThis as any)['AVCaptureDataOutputSynchronizer'] = (globalThis as any)['AVCaptureDataOutputSynchronizer'] || {};

(globalThis as any)['AVCaptureDepthDataOutput'] = (globalThis as any)['AVCaptureDepthDataOutput'] || {};

(globalThis as any)['AVCaptureDevice'] = (globalThis as any)['AVCaptureDevice'] || {};
(globalThis as any)['AVCaptureDevice']['Format'] = (globalThis as any)['AVCaptureDevice']['Format'] || {};
(globalThis as any)['AVCaptureDevice']['Format']['AutoFocusSystem'] = (globalThis as any)['AVCaptureDevice']['Format']['AutoFocusSystem'] || {};
(globalThis as any)['AVCaptureDevice']['Format']['AutoFocusSystem'] = {
  None: 0,
  ContrastDetection: 1,
  PhaseDetection: 2
};

(globalThis as any)['AVCaptureDevice']['SystemPressureState'] = (globalThis as any)['AVCaptureDevice']['SystemPressureState'] || {};
(globalThis as any)['AVCaptureDevice']['SystemPressureState']['Factors'] = (globalThis as any)['AVCaptureDevice']['SystemPressureState']['Factors'] || {};
(globalThis as any)['AVCaptureDevice']['SystemPressureState']['Factors'] = {
  None: 0,
  SystemTemperature: 1,
  PeakPower: 2,
  DepthModuleTemperature: 4
};

(globalThis as any)['AVCaptureDevice']['AVAuthorizationStatus'] = (globalThis as any)['AVCaptureDevice']['AVAuthorizationStatus'] || {};
(globalThis as any)['AVCaptureDevice']['AVAuthorizationStatus'] = {
  NotDetermined: 0,
  Restricted: 1,
  Denied: 2,
  Authorized: 3
};

(globalThis as any)['AVCaptureDevice']['AVCaptureColorSpace'] = (globalThis as any)['AVCaptureDevice']['AVCaptureColorSpace'] || {};
(globalThis as any)['AVCaptureDevice']['AVCaptureColorSpace'] = {
  _sRGB: 0,
  _P3_D65: 1
};

(globalThis as any)['AVCaptureDevice']['AVCaptureVideoStabilizationMode'] = (globalThis as any)['AVCaptureDevice']['AVCaptureVideoStabilizationMode'] || {};
(globalThis as any)['AVCaptureDevice']['AVCaptureVideoStabilizationMode'] = {
  Off: 0,
  Standard: 1,
  Cinematic: 2,
  CinematicExtended: 3,
  Auto: -1
};

(globalThis as any)['AVCaptureDevice']['AutoFocusRangeRestriction'] = (globalThis as any)['AVCaptureDevice']['AutoFocusRangeRestriction'] || {};
(globalThis as any)['AVCaptureDevice']['AutoFocusRangeRestriction'] = {
  None: 0,
  Near: 1,
  Far: 2
};

(globalThis as any)['AVCaptureDevice']['ExposureMode'] = (globalThis as any)['AVCaptureDevice']['ExposureMode'] || {};
(globalThis as any)['AVCaptureDevice']['ExposureMode'] = {
  Locked: 0,
  AutoExpose: 1,
  ContinuousAutoExposure: 2,
  Custom: 3
};

(globalThis as any)['AVCaptureDevice']['FlashMode'] = (globalThis as any)['AVCaptureDevice']['FlashMode'] || {};
(globalThis as any)['AVCaptureDevice']['FlashMode'] = {
  Off: 0,
  On: 1,
  Auto: 2
};

(globalThis as any)['AVCaptureDevice']['FocusMode'] = (globalThis as any)['AVCaptureDevice']['FocusMode'] || {};
(globalThis as any)['AVCaptureDevice']['FocusMode'] = {
  Locked: 0,
  AutoFocus: 1,
  ContinuousAutoFocus: 2
};

(globalThis as any)['AVCaptureDevice']['LensStabilizationStatus'] = (globalThis as any)['AVCaptureDevice']['LensStabilizationStatus'] || {};
(globalThis as any)['AVCaptureDevice']['LensStabilizationStatus'] = {
  Unsupported: 0,
  Off: 1,
  Active: 2,
  OutOfRange: 3,
  Unavailable: 4
};

(globalThis as any)['AVCaptureDevice']['Position'] = (globalThis as any)['AVCaptureDevice']['Position'] || {};
(globalThis as any)['AVCaptureDevice']['Position'] = {
  Unspecified: 0,
  Back: 1,
  Front: 2
};

(globalThis as any)['AVCaptureDevice']['TorchMode'] = (globalThis as any)['AVCaptureDevice']['TorchMode'] || {};
(globalThis as any)['AVCaptureDevice']['TorchMode'] = {
  Off: 0,
  On: 1,
  Auto: 2
};

(globalThis as any)['AVCaptureDevice']['TransportControlsPlaybackMode'] = (globalThis as any)['AVCaptureDevice']['TransportControlsPlaybackMode'] || {};
(globalThis as any)['AVCaptureDevice']['TransportControlsPlaybackMode'] = {
  NotPlayingMode: 0,
  PlayingMode: 1
};

(globalThis as any)['AVCaptureDevice']['WhiteBalanceMode'] = (globalThis as any)['AVCaptureDevice']['WhiteBalanceMode'] || {};
(globalThis as any)['AVCaptureDevice']['WhiteBalanceMode'] = {
  Locked: 0,
  AutoWhiteBalance: 1,
  ContinuousAutoWhiteBalance: 2
};


(globalThis as any)['AVCaptureFileOutput'] = (globalThis as any)['AVCaptureFileOutput'] || {};

(globalThis as any)['AVCaptureInput'] = (globalThis as any)['AVCaptureInput'] || {};

(globalThis as any)['AVCaptureMetadataOutput'] = (globalThis as any)['AVCaptureMetadataOutput'] || {};

(globalThis as any)['AVCaptureOutputBase'] = (globalThis as any)['AVCaptureOutputBase'] || {};
(globalThis as any)['AVCaptureOutputBase']['AVCaptureOutput'] = (globalThis as any)['AVCaptureOutputBase']['AVCaptureOutput'] || {};
(globalThis as any)['AVCaptureOutputBase']['AVCaptureOutput']['DataDroppedReason'] = (globalThis as any)['AVCaptureOutputBase']['AVCaptureOutput']['DataDroppedReason'] || {};
(globalThis as any)['AVCaptureOutputBase']['AVCaptureOutput']['DataDroppedReason'] = {
  None: 0,
  LateData: 1,
  OutOfBuffers: 2,
  Discontinuity: 3
};


(globalThis as any)['AVCapturePhotoOutput'] = (globalThis as any)['AVCapturePhotoOutput'] || {};
(globalThis as any)['AVCapturePhotoOutput']['AVCaptureDevice'] = (globalThis as any)['AVCapturePhotoOutput']['AVCaptureDevice'] || {};
(globalThis as any)['AVCapturePhotoOutput']['AVCaptureDevice']['LensStabilizationStatus'] = (globalThis as any)['AVCapturePhotoOutput']['AVCaptureDevice']['LensStabilizationStatus'] || {};
(globalThis as any)['AVCapturePhotoOutput']['AVCaptureDevice']['LensStabilizationStatus'] = {
  Unsupported: 0,
  Off: 1,
  Active: 2,
  OutOfRange: 3,
  Unavailable: 4
};

(globalThis as any)['AVCapturePhotoOutput']['QualityPrioritization'] = (globalThis as any)['AVCapturePhotoOutput']['QualityPrioritization'] || {};
(globalThis as any)['AVCapturePhotoOutput']['QualityPrioritization'] = {
  Speed: 1,
  Balanced: 2,
  Quality: 3
};


(globalThis as any)['AVCaptureSession'] = (globalThis as any)['AVCaptureSession'] || {};
(globalThis as any)['AVCaptureSession']['AVCaptureVideoOrientation'] = (globalThis as any)['AVCaptureSession']['AVCaptureVideoOrientation'] || {};
(globalThis as any)['AVCaptureSession']['AVCaptureVideoOrientation'] = {
  Portrait: 1,
  PortraitUpsideDown: 2,
  LandscapeRight: 3,
  LandscapeLeft: 4
};

(globalThis as any)['AVCaptureSession']['AVVideoFieldMode'] = (globalThis as any)['AVCaptureSession']['AVVideoFieldMode'] || {};
(globalThis as any)['AVCaptureSession']['AVVideoFieldMode'] = {
  Both: 0,
  TopOnly: 1,
  BottomOnly: 2,
  Deinterlace: 3
};

(globalThis as any)['AVCaptureSession']['InterruptionReason'] = (globalThis as any)['AVCaptureSession']['InterruptionReason'] || {};
(globalThis as any)['AVCaptureSession']['InterruptionReason'] = {
  VideoDeviceNotAvailableInBackground: 1,
  AudioDeviceInUseByAnotherClient: 2,
  VideoDeviceInUseByAnotherClient: 3,
  VideoDeviceNotAvailableWithMultipleForegroundApps: 4,
  VideoDeviceNotAvailableDueToSystemPressure: 5
};



(globalThis as any)['AVCaptureVideoDataOutput'] = (globalThis as any)['AVCaptureVideoDataOutput'] || {};

(globalThis as any)['AVCaptureVideoPreviewLayer'] = (globalThis as any)['AVCaptureVideoPreviewLayer'] || {};

(globalThis as any)['AVCaptureView'] = (globalThis as any)['AVCaptureView'] || {};
(globalThis as any)['AVCaptureView']['AVCaptureViewControlsStyle'] = (globalThis as any)['AVCaptureView']['AVCaptureViewControlsStyle'] || {};
(globalThis as any)['AVCaptureView']['AVCaptureViewControlsStyle'] = {
  Inline: 0,
  Floating: 1,
  InlineDeviceSelection: 2,
  Default: 0
};


(globalThis as any)['AVComposition'] = (globalThis as any)['AVComposition'] || {};

(globalThis as any)['AVCompositionTrack'] = (globalThis as any)['AVCompositionTrack'] || {};

(globalThis as any)['AVCompositionTrackSegment'] = (globalThis as any)['AVCompositionTrackSegment'] || {};

(globalThis as any)['AVContentKeySession'] = (globalThis as any)['AVContentKeySession'] || {};
(globalThis as any)['AVContentKeySession']['AVContentKeyRequest'] = (globalThis as any)['AVContentKeySession']['AVContentKeyRequest'] || {};
(globalThis as any)['AVContentKeySession']['AVContentKeyRequest']['Status'] = (globalThis as any)['AVContentKeySession']['AVContentKeyRequest']['Status'] || {};
(globalThis as any)['AVContentKeySession']['AVContentKeyRequest']['Status'] = {
  RequestingResponse: 0,
  ReceivedResponse: 1,
  Renewed: 2,
  Retried: 3,
  Cancelled: 4,
  Failed: 5
};


(globalThis as any)['AVDepthData'] = (globalThis as any)['AVDepthData'] || {};
(globalThis as any)['AVDepthData']['Accuracy'] = (globalThis as any)['AVDepthData']['Accuracy'] || {};
(globalThis as any)['AVDepthData']['Accuracy'] = {
  Relative: 0,
  Absolute: 1
};

(globalThis as any)['AVDepthData']['Quality'] = (globalThis as any)['AVDepthData']['Quality'] || {};
(globalThis as any)['AVDepthData']['Quality'] = {
  Low: 0,
  High: 1
};


(globalThis as any)['AVError'] = (globalThis as any)['AVError'] || {};
(globalThis as any)['AVError']['AVError'] = (globalThis as any)['AVError']['AVError'] || {};
(globalThis as any)['AVError']['AVError'] = {
  Unknown: -11800,
  OutOfMemory: -11801,
  SessionNotRunning: -11803,
  DeviceAlreadyUsedByAnotherSession: -11804,
  NoDataCaptured: -11805,
  SessionConfigurationChanged: -11806,
  DiskFull: -11807,
  DeviceWasDisconnected: -11808,
  MediaChanged: -11809,
  MaximumDurationReached: -11810,
  MaximumFileSizeReached: -11811,
  MediaDiscontinuity: -11812,
  MaximumNumberOfSamplesForFileFormatReached: -11813,
  DeviceNotConnected: -11814,
  DeviceInUseByAnotherApplication: -11815,
  DeviceLockedForConfigurationByAnotherProcess: -11817,
  ExportFailed: -11820,
  DecodeFailed: -11821,
  InvalidSourceMedia: -11822,
  FileAlreadyExists: -11823,
  CompositionTrackSegmentsNotContiguous: -11824,
  InvalidCompositionTrackSegmentDuration: -11825,
  InvalidCompositionTrackSegmentSourceStartTime: -11826,
  InvalidCompositionTrackSegmentSourceDuration: -11827,
  FileFormatNotRecognized: -11828,
  FileFailedToParse: -11829,
  MaximumStillImageCaptureRequestsExceeded: -11830,
  ContentIsProtected: -11831,
  NoImageAtTime: -11832,
  DecoderNotFound: -11833,
  EncoderNotFound: -11834,
  ContentIsNotAuthorized: -11835,
  ApplicationIsNotAuthorized: -11836,
  OperationNotSupportedForAsset: -11838,
  DecoderTemporarilyUnavailable: -11839,
  EncoderTemporarilyUnavailable: -11840,
  InvalidVideoComposition: -11841,
  ReferenceForbiddenByReferencePolicy: -11842,
  InvalidOutputURLPathExtension: -11843,
  ScreenCaptureFailed: -11844,
  DisplayWasDisabled: -11845,
  TorchLevelUnavailable: -11846,
  IncompatibleAsset: -11848,
  FailedToLoadMediaData: -11849,
  ServerIncorrectlyConfigured: -11850,
  ApplicationIsNotAuthorizedToUseDevice: -11852,
  FailedToParse: -11853,
  FileTypeDoesNotSupportSampleReferences: -11854,
  UndecodableMediaData: -11855,
  AirPlayControllerRequiresInternet: -11856,
  AirPlayReceiverRequiresInternet: -11857,
  VideoCompositorFailed: -11858,
  CreateContentKeyRequestFailed: -11860,
  UnsupportedOutputSettings: -11861,
  OperationNotAllowed: -11862,
  ContentIsUnavailable: -11863,
  FormatUnsupported: -11864,
  MalformedDepth: -11865,
  ContentNotUpdated: -11866,
  NoLongerPlayable: -11867,
  NoCompatibleAlternatesForExternalDisplay: -11868,
  NoSourceTrack: -11869,
  ExternalPlaybackNotSupportedForAsset: -11870,
  OperationNotSupportedForPreset: -11871,
  SessionHardwareCostOverage: -11872,
  UnsupportedDeviceActiveFormat: -11873
};


(globalThis as any)['AVMIDIPlayer'] = (globalThis as any)['AVMIDIPlayer'] || {};


(globalThis as any)['AVMediaSelection'] = (globalThis as any)['AVMediaSelection'] || {};

(globalThis as any)['AVMediaSelectionGroup'] = (globalThis as any)['AVMediaSelectionGroup'] || {};



(globalThis as any)['AVMetadataItem'] = (globalThis as any)['AVMetadataItem'] || {};

(globalThis as any)['AVMetadataObject'] = (globalThis as any)['AVMetadataObject'] || {};

(globalThis as any)['AVMovie'] = (globalThis as any)['AVMovie'] || {};
(globalThis as any)['AVMovie']['AVMovieWritingOptions'] = (globalThis as any)['AVMovie']['AVMovieWritingOptions'] || {};
(globalThis as any)['AVMovie']['AVMovieWritingOptions'] = {
  AddMovieHeaderToDestination: 0,
  TruncateDestinationToMovieHeaderOnly: 1
};


(globalThis as any)['AVMovieTrack'] = (globalThis as any)['AVMovieTrack'] || {};

(globalThis as any)['AVOutputSettingsAssistant'] = (globalThis as any)['AVOutputSettingsAssistant'] || {};

(globalThis as any)['AVPictureInPictureController'] = (globalThis as any)['AVPictureInPictureController'] || {};

(globalThis as any)['AVPlayer'] = (globalThis as any)['AVPlayer'] || {};
(globalThis as any)['AVPlayer']['ActionAtItemEnd'] = (globalThis as any)['AVPlayer']['ActionAtItemEnd'] || {};
(globalThis as any)['AVPlayer']['ActionAtItemEnd'] = {
  Advance: 0,
  Pause: 1,
  None: 2
};

(globalThis as any)['AVPlayer']['HDRMode'] = (globalThis as any)['AVPlayer']['HDRMode'] || {};
(globalThis as any)['AVPlayer']['HDRMode'] = {
  HLG: 1,
  HDR10: 2,
  DolbyVision: 4
};

(globalThis as any)['AVPlayer']['Status'] = (globalThis as any)['AVPlayer']['Status'] || {};
(globalThis as any)['AVPlayer']['Status'] = {
  Unknown: 0,
  ReadyToPlay: 1,
  Failed: 2
};

(globalThis as any)['AVPlayer']['TimeControlStatus'] = (globalThis as any)['AVPlayer']['TimeControlStatus'] || {};
(globalThis as any)['AVPlayer']['TimeControlStatus'] = {
  Paused: 0,
  WaitingToPlayAtSpecifiedRate: 1,
  Playing: 2
};


(globalThis as any)['AVPlayerItem'] = (globalThis as any)['AVPlayerItem'] || {};
(globalThis as any)['AVPlayerItem']['Status'] = (globalThis as any)['AVPlayerItem']['Status'] || {};
(globalThis as any)['AVPlayerItem']['Status'] = {
  Unknown: 0,
  ReadyToPlay: 1,
  Failed: 2
};


(globalThis as any)['AVPlayerItemOutput'] = (globalThis as any)['AVPlayerItemOutput'] || {};

(globalThis as any)['AVPlayerItemProtectedContentAdditions'] = (globalThis as any)['AVPlayerItemProtectedContentAdditions'] || {};
(globalThis as any)['AVPlayerItemProtectedContentAdditions']['AVContentAuthorizationStatus'] = (globalThis as any)['AVPlayerItemProtectedContentAdditions']['AVContentAuthorizationStatus'] || {};
(globalThis as any)['AVPlayerItemProtectedContentAdditions']['AVContentAuthorizationStatus'] = {
  Unknown: 0,
  Completed: 1,
  Cancelled: 2,
  TimedOut: 3,
  Busy: 4,
  NotAvailable: 5,
  NotPossible: 6
};


(globalThis as any)['AVPlayerItemTrack'] = (globalThis as any)['AVPlayerItemTrack'] || {};

(globalThis as any)['AVPlayerLayer'] = (globalThis as any)['AVPlayerLayer'] || {};

(globalThis as any)['AVPlayerLooper'] = (globalThis as any)['AVPlayerLooper'] || {};
(globalThis as any)['AVPlayerLooper']['Status'] = (globalThis as any)['AVPlayerLooper']['Status'] || {};
(globalThis as any)['AVPlayerLooper']['Status'] = {
  Unknown: 0,
  Ready: 1,
  Failed: 2,
  Cancelled: 3
};


(globalThis as any)['AVPlayerMediaSelectionCriteria'] = (globalThis as any)['AVPlayerMediaSelectionCriteria'] || {};

(globalThis as any)['AVPlayerView'] = (globalThis as any)['AVPlayerView'] || {};
(globalThis as any)['AVPlayerView']['AVPlayerViewControlsStyle'] = (globalThis as any)['AVPlayerView']['AVPlayerViewControlsStyle'] || {};
(globalThis as any)['AVPlayerView']['AVPlayerViewControlsStyle'] = {
  None: 0,
  Inline: 1,
  Floating: 2,
  Minimal: 3,
  Default: 1
};

(globalThis as any)['AVPlayerView']['AVPlayerViewTrimResult'] = (globalThis as any)['AVPlayerView']['AVPlayerViewTrimResult'] || {};
(globalThis as any)['AVPlayerView']['AVPlayerViewTrimResult'] = {
  OKButton: 0,
  CancelButton: 1
};


(globalThis as any)['AVPortraitEffectsMatte'] = (globalThis as any)['AVPortraitEffectsMatte'] || {};

(globalThis as any)['AVQueuedSampleBufferRendering'] = (globalThis as any)['AVQueuedSampleBufferRendering'] || {};
(globalThis as any)['AVQueuedSampleBufferRendering']['AVQueuedSampleBufferRenderingStatus'] = (globalThis as any)['AVQueuedSampleBufferRendering']['AVQueuedSampleBufferRenderingStatus'] || {};
(globalThis as any)['AVQueuedSampleBufferRendering']['AVQueuedSampleBufferRenderingStatus'] = {
  Unknown: 0,
  Rendering: 1,
  Failed: 2
};


(globalThis as any)['AVRouteDetector'] = (globalThis as any)['AVRouteDetector'] || {};

(globalThis as any)['AVRoutePickerView'] = (globalThis as any)['AVRoutePickerView'] || {};
(globalThis as any)['AVRoutePickerView']['AVRoutePickerViewButtonState'] = (globalThis as any)['AVRoutePickerView']['AVRoutePickerViewButtonState'] || {};
(globalThis as any)['AVRoutePickerView']['AVRoutePickerViewButtonState'] = {
  Normal: 0,
  NormalHighlighted: 1,
  Active: 2,
  ActiveHighlighted: 3
};


(globalThis as any)['AVSampleBufferAudioRenderer'] = (globalThis as any)['AVSampleBufferAudioRenderer'] || {};

(globalThis as any)['AVSampleBufferDisplayLayer'] = (globalThis as any)['AVSampleBufferDisplayLayer'] || {};

(globalThis as any)['AVSampleBufferGenerator'] = (globalThis as any)['AVSampleBufferGenerator'] || {};
(globalThis as any)['AVSampleBufferGenerator']['AVSampleBufferRequest'] = (globalThis as any)['AVSampleBufferGenerator']['AVSampleBufferRequest'] || {};
(globalThis as any)['AVSampleBufferGenerator']['AVSampleBufferRequest']['Direction'] = (globalThis as any)['AVSampleBufferGenerator']['AVSampleBufferRequest']['Direction'] || {};
(globalThis as any)['AVSampleBufferGenerator']['AVSampleBufferRequest']['Direction'] = {
  Forward: 1,
  None: 0,
  Reverse: -1
};

(globalThis as any)['AVSampleBufferGenerator']['AVSampleBufferRequest'] = (globalThis as any)['AVSampleBufferGenerator']['AVSampleBufferRequest'] || {};
(globalThis as any)['AVSampleBufferGenerator']['AVSampleBufferRequest']['Mode'] = (globalThis as any)['AVSampleBufferGenerator']['AVSampleBufferRequest']['Mode'] || {};
(globalThis as any)['AVSampleBufferGenerator']['AVSampleBufferRequest']['Mode'] = {
  Immediate: 0,
  Scheduled: 1,
  Opportunistic: 2
};


(globalThis as any)['AVSampleBufferRenderSynchronizer'] = (globalThis as any)['AVSampleBufferRenderSynchronizer'] || {};

(globalThis as any)['AVSampleCursor'] = (globalThis as any)['AVSampleCursor'] || {};

(globalThis as any)['AVSemanticSegmentationMatte'] = (globalThis as any)['AVSemanticSegmentationMatte'] || {};

(globalThis as any)['AVSpeechSynthesis'] = (globalThis as any)['AVSpeechSynthesis'] || {};
(globalThis as any)['AVSpeechSynthesis']['AVSpeechBoundary'] = (globalThis as any)['AVSpeechSynthesis']['AVSpeechBoundary'] || {};
(globalThis as any)['AVSpeechSynthesis']['AVSpeechBoundary'] = {
  Immediate: 0,
  Word: 1
};

(globalThis as any)['AVSpeechSynthesis']['AVSpeechSynthesisVoiceGender'] = (globalThis as any)['AVSpeechSynthesis']['AVSpeechSynthesisVoiceGender'] || {};
(globalThis as any)['AVSpeechSynthesis']['AVSpeechSynthesisVoiceGender'] = {
  Unspecified: 0,
  Male: 1,
  Female: 2
};

(globalThis as any)['AVSpeechSynthesis']['AVSpeechSynthesisVoiceQuality'] = (globalThis as any)['AVSpeechSynthesis']['AVSpeechSynthesisVoiceQuality'] || {};
(globalThis as any)['AVSpeechSynthesis']['AVSpeechSynthesisVoiceQuality'] = {
  Default: 1,
  Enhanced: 2
};


(globalThis as any)['AVSynchronizedLayer'] = (globalThis as any)['AVSynchronizedLayer'] || {};

(globalThis as any)['AVTextStyleRule'] = (globalThis as any)['AVTextStyleRule'] || {};

(globalThis as any)['AVTimedMetadataGroup'] = (globalThis as any)['AVTimedMetadataGroup'] || {};

(globalThis as any)['AVVideoCompositing'] = (globalThis as any)['AVVideoCompositing'] || {};

(globalThis as any)['AVVideoComposition'] = (globalThis as any)['AVVideoComposition'] || {};


(globalThis as any)['Array'] = (globalThis as any)['Array'] || {};
(globalThis as any)['Array']['NSBinarySearchingOptions'] = (globalThis as any)['Array']['NSBinarySearchingOptions'] || {};
(globalThis as any)['Array']['NSBinarySearchingOptions'] = {
  FirstEqual: 256,
  LastEqual: 512,
  InsertionIndex: 1024
};


(globalThis as any)['ByteCountFormatter'] = (globalThis as any)['ByteCountFormatter'] || {};
(globalThis as any)['ByteCountFormatter']['CountStyle'] = (globalThis as any)['ByteCountFormatter']['CountStyle'] || {};
(globalThis as any)['ByteCountFormatter']['CountStyle'] = {
  File: 0,
  Memory: 1,
  Decimal: 2,
  Binary: 3
};

(globalThis as any)['ByteCountFormatter']['Units'] = (globalThis as any)['ByteCountFormatter']['Units'] || {};
(globalThis as any)['ByteCountFormatter']['Units'] = {
  Default: 0,
  Bytes: 1,
  KB: 2,
  MB: 4,
  GB: 8,
  TB: 16,
  PB: 32,
  EB: 64,
  ZB: 128,
  YBOrHigher: 65280,
  All: 65535
};


(globalThis as any)['CAAnimation'] = (globalThis as any)['CAAnimation'] || {};

(globalThis as any)['CAConstraintLayoutManager'] = (globalThis as any)['CAConstraintLayoutManager'] || {};
(globalThis as any)['CAConstraintLayoutManager']['CAConstraintAttribute'] = (globalThis as any)['CAConstraintLayoutManager']['CAConstraintAttribute'] || {};
(globalThis as any)['CAConstraintLayoutManager']['CAConstraintAttribute'] = {
  MinX: 0,
  MidX: 1,
  MaxX: 2,
  Width: 3,
  MinY: 4,
  MidY: 5,
  MaxY: 6,
  Height: 7
};


(globalThis as any)['CADisplayLink'] = (globalThis as any)['CADisplayLink'] || {};

(globalThis as any)['CAEDRMetadata'] = (globalThis as any)['CAEDRMetadata'] || {};

(globalThis as any)['CAEmitterCell'] = (globalThis as any)['CAEmitterCell'] || {};

(globalThis as any)['CAEmitterLayer'] = (globalThis as any)['CAEmitterLayer'] || {};

(globalThis as any)['CAGradientLayer'] = (globalThis as any)['CAGradientLayer'] || {};

(globalThis as any)['CALayer'] = (globalThis as any)['CALayer'] || {};
(globalThis as any)['CALayer']['CAAutoresizingMask'] = (globalThis as any)['CALayer']['CAAutoresizingMask'] || {};
(globalThis as any)['CALayer']['CAAutoresizingMask'] = {
  NotSizable: 0,
  MinXMargin: 1,
  WidthSizable: 2,
  MaxXMargin: 4,
  MinYMargin: 8,
  HeightSizable: 16,
  MaxYMargin: 32
};

(globalThis as any)['CALayer']['CACornerMask'] = (globalThis as any)['CALayer']['CACornerMask'] || {};
(globalThis as any)['CALayer']['CACornerMask'] = {
  inXMinYCorner: 1,
  axXMinYCorner: 2,
  inXMaxYCorner: 4,
  axXMaxYCorner: 8
};

(globalThis as any)['CALayer']['CAEdgeAntialiasingMask'] = (globalThis as any)['CALayer']['CAEdgeAntialiasingMask'] || {};
(globalThis as any)['CALayer']['CAEdgeAntialiasingMask'] = {
  LeftEdge: 1,
  RightEdge: 2,
  BottomEdge: 4,
  TopEdge: 8
};


(globalThis as any)['CAMediaTiming'] = (globalThis as any)['CAMediaTiming'] || {};

(globalThis as any)['CAMediaTimingFunction'] = (globalThis as any)['CAMediaTimingFunction'] || {};

(globalThis as any)['CAMetalLayer'] = (globalThis as any)['CAMetalLayer'] || {};

(globalThis as any)['CARemoteLayerClient'] = (globalThis as any)['CARemoteLayerClient'] || {};

(globalThis as any)['CARemoteLayerServer'] = (globalThis as any)['CARemoteLayerServer'] || {};

(globalThis as any)['CARenderer'] = (globalThis as any)['CARenderer'] || {};

(globalThis as any)['CAReplicatorLayer'] = (globalThis as any)['CAReplicatorLayer'] || {};

(globalThis as any)['CAScrollLayer'] = (globalThis as any)['CAScrollLayer'] || {};

(globalThis as any)['CAShapeLayer'] = (globalThis as any)['CAShapeLayer'] || {};

(globalThis as any)['CATextLayer'] = (globalThis as any)['CATextLayer'] || {};

(globalThis as any)['CATiledLayer'] = (globalThis as any)['CATiledLayer'] || {};

(globalThis as any)['CATransaction'] = (globalThis as any)['CATransaction'] || {};


(globalThis as any)['CAValueFunction'] = (globalThis as any)['CAValueFunction'] || {};



(globalThis as any)['CFBase'] = (globalThis as any)['CFBase'] || {};
(globalThis as any)['CFBase']['CFComparisonResult'] = (globalThis as any)['CFBase']['CFComparisonResult'] || {};
(globalThis as any)['CFBase']['CFComparisonResult'] = {
  LessThan: -1,
  EqualTo: 0,
  GreaterThan: 1
};




(globalThis as any)['CFByteOrder'] = (globalThis as any)['CFByteOrder'] || {};
(globalThis as any)['CFByteOrder']['__CFByteOrder'] = (globalThis as any)['CFByteOrder']['__CFByteOrder'] || {};
(globalThis as any)['CFByteOrder']['__CFByteOrder'] = {
  Unknown: 0,
  LittleEndian: 1,
  BigEndian: 2
};


(globalThis as any)['CFCalendar'] = (globalThis as any)['CFCalendar'] || {};
(globalThis as any)['CFCalendar']['CFCalendarUnit'] = (globalThis as any)['CFCalendar']['CFCalendarUnit'] || {};
(globalThis as any)['CFCalendar']['CFCalendarUnit'] = {
  Era: 2,
  Year: 4,
  Month: 8,
  Day: 16,
  Hour: 32,
  Minute: 64,
  Second: 128,
  Week: 256,
  Weekday: 512,
  WeekdayOrdinal: 1024,
  Quarter: 2048,
  WeekOfMonth: 4096,
  WeekOfYear: 8192,
  YearForWeekOfYear: 16384
};


(globalThis as any)['CFCharacterSet'] = (globalThis as any)['CFCharacterSet'] || {};
(globalThis as any)['CFCharacterSet']['CFCharacterSetPredefinedSet'] = (globalThis as any)['CFCharacterSet']['CFCharacterSetPredefinedSet'] || {};
(globalThis as any)['CFCharacterSet']['CFCharacterSetPredefinedSet'] = {
  Control: 1,
  Whitespace: 2,
  WhitespaceAndNewline: 3,
  DecimalDigit: 4,
  Letter: 5,
  LowercaseLetter: 6,
  UppercaseLetter: 7,
  NonBase: 8,
  Decomposable: 9,
  AlphaNumeric: 10,
  Punctuation: 11,
  CapitalizedLetter: 13,
  Symbol: 14,
  Newline: 15,
  Illegal: 12
};


(globalThis as any)['CFData'] = (globalThis as any)['CFData'] || {};
(globalThis as any)['CFData']['CFDataSearchFlags'] = (globalThis as any)['CFData']['CFDataSearchFlags'] || {};
(globalThis as any)['CFData']['CFDataSearchFlags'] = {
  Backwards: 1,
  Anchored: 2
};


(globalThis as any)['CFDate'] = (globalThis as any)['CFDate'] || {};
(globalThis as any)['CFDate']['CFGregorianUnitFlags'] = (globalThis as any)['CFDate']['CFGregorianUnitFlags'] || {};
(globalThis as any)['CFDate']['CFGregorianUnitFlags'] = {
  UnitsYears: 1,
  UnitsMonths: 2,
  UnitsDays: 4,
  UnitsHours: 8,
  UnitsMinutes: 16,
  UnitsSeconds: 32,
  AllUnits: 16777215
};


(globalThis as any)['CFDateFormatter'] = (globalThis as any)['CFDateFormatter'] || {};
(globalThis as any)['CFDateFormatter']['CFDateFormatterStyle'] = (globalThis as any)['CFDateFormatter']['CFDateFormatterStyle'] || {};
(globalThis as any)['CFDateFormatter']['CFDateFormatterStyle'] = {
  NoStyle: 0,
  ShortStyle: 1,
  MediumStyle: 2,
  LongStyle: 3,
  FullStyle: 4
};

(globalThis as any)['CFDateFormatter']['CFISO8601DateFormatOptions'] = (globalThis as any)['CFDateFormatter']['CFISO8601DateFormatOptions'] || {};
(globalThis as any)['CFDateFormatter']['CFISO8601DateFormatOptions'] = {
  WithYear: 1,
  WithMonth: 2,
  WithWeekOfYear: 4,
  WithDay: 16,
  WithTime: 32,
  WithTimeZone: 64,
  WithSpaceBetweenDateAndTime: 128,
  WithDashSeparatorInDate: 256,
  WithColonSeparatorInTime: 512,
  WithColonSeparatorInTimeZone: 1024,
  WithFractionalSeconds: 2048,
  WithFullDate: 275,
  WithFullTime: 1632,
  WithInternetDateTime: 1907
};




(globalThis as any)['CFFileSecurity'] = (globalThis as any)['CFFileSecurity'] || {};
(globalThis as any)['CFFileSecurity']['CFFileSecurityClearOptions'] = (globalThis as any)['CFFileSecurity']['CFFileSecurityClearOptions'] || {};
(globalThis as any)['CFFileSecurity']['CFFileSecurityClearOptions'] = {
  Owner: 1,
  Group: 2,
  Mode: 4,
  OwnerUUID: 8,
  GroupUUID: 16,
  AccessControlList: 32
};


(globalThis as any)['CFLocale'] = (globalThis as any)['CFLocale'] || {};
(globalThis as any)['CFLocale']['CFLocaleLanguageDirection'] = (globalThis as any)['CFLocale']['CFLocaleLanguageDirection'] || {};
(globalThis as any)['CFLocale']['CFLocaleLanguageDirection'] = {
  Unknown: 0,
  LeftToRight: 1,
  RightToLeft: 2,
  TopToBottom: 3,
  BottomToTop: 4
};


(globalThis as any)['CFNotificationCenter'] = (globalThis as any)['CFNotificationCenter'] || {};
(globalThis as any)['CFNotificationCenter']['CFNotificationSuspensionBehavior'] = (globalThis as any)['CFNotificationCenter']['CFNotificationSuspensionBehavior'] || {};
(globalThis as any)['CFNotificationCenter']['CFNotificationSuspensionBehavior'] = {
  Drop: 1,
  Coalesce: 2,
  Hold: 3,
  DeliverImmediately: 4
};


(globalThis as any)['CFNumber'] = (globalThis as any)['CFNumber'] || {};
(globalThis as any)['CFNumber']['CFNumberType'] = (globalThis as any)['CFNumber']['CFNumberType'] || {};
(globalThis as any)['CFNumber']['CFNumberType'] = {
  SInt8Type: 1,
  SInt16Type: 2,
  SInt32Type: 3,
  SInt64Type: 4,
  Float32Type: 5,
  Float64Type: 6,
  CharType: 7,
  ShortType: 8,
  IntType: 9,
  LongType: 10,
  LongLongType: 11,
  FloatType: 12,
  DoubleType: 13,
  CFIndexType: 14,
  NSIntegerType: 15,
  CGFloatType: 16,
  MaxType: 16
};


(globalThis as any)['CFNumberFormatter'] = (globalThis as any)['CFNumberFormatter'] || {};
(globalThis as any)['CFNumberFormatter']['CFNumberFormatterOptionFlags'] = (globalThis as any)['CFNumberFormatter']['CFNumberFormatterOptionFlags'] || {};
(globalThis as any)['CFNumberFormatter']['CFNumberFormatterOptionFlags'] = {
  kCFNumberFormatterParseIntegersOnly: 1
};

(globalThis as any)['CFNumberFormatter']['CFNumberFormatterPadPosition'] = (globalThis as any)['CFNumberFormatter']['CFNumberFormatterPadPosition'] || {};
(globalThis as any)['CFNumberFormatter']['CFNumberFormatterPadPosition'] = {
  BeforePrefix: 0,
  AfterPrefix: 1,
  BeforeSuffix: 2,
  AfterSuffix: 3
};

(globalThis as any)['CFNumberFormatter']['CFNumberFormatterRoundingMode'] = (globalThis as any)['CFNumberFormatter']['CFNumberFormatterRoundingMode'] || {};
(globalThis as any)['CFNumberFormatter']['CFNumberFormatterRoundingMode'] = {
  Ceiling: 0,
  Floor: 1,
  Down: 2,
  Up: 3,
  HalfEven: 4,
  HalfDown: 5,
  HalfUp: 6
};

(globalThis as any)['CFNumberFormatter']['CFNumberFormatterStyle'] = (globalThis as any)['CFNumberFormatter']['CFNumberFormatterStyle'] || {};
(globalThis as any)['CFNumberFormatter']['CFNumberFormatterStyle'] = {
  NoStyle: 0,
  DecimalStyle: 1,
  CurrencyStyle: 2,
  PercentStyle: 3,
  ScientificStyle: 4,
  SpellOutStyle: 5,
  OrdinalStyle: 6,
  CurrencyISOCodeStyle: 8,
  CurrencyPluralStyle: 9,
  CurrencyAccountingStyle: 10
};




(globalThis as any)['CFPropertyList'] = (globalThis as any)['CFPropertyList'] || {};
(globalThis as any)['CFPropertyList']['CFPropertyListFormat'] = (globalThis as any)['CFPropertyList']['CFPropertyListFormat'] || {};
(globalThis as any)['CFPropertyList']['CFPropertyListFormat'] = {
  OpenStepFormat: 1,
  XMLFormat_v1_0: 100,
  BinaryFormat_v1_0: 200
};

(globalThis as any)['CFPropertyList']['CFPropertyListMutabilityOptions'] = (globalThis as any)['CFPropertyList']['CFPropertyListMutabilityOptions'] || {};
(globalThis as any)['CFPropertyList']['CFPropertyListMutabilityOptions'] = {
  Immutable: 0,
  MutableContainers: 1,
  MutableContainersAndLeaves: 2
};


(globalThis as any)['CFRunLoop'] = (globalThis as any)['CFRunLoop'] || {};
(globalThis as any)['CFRunLoop']['CFRunLoopActivity'] = (globalThis as any)['CFRunLoop']['CFRunLoopActivity'] || {};
(globalThis as any)['CFRunLoop']['CFRunLoopActivity'] = {
  Entry: 1,
  BeforeTimers: 2,
  BeforeSources: 4,
  BeforeWaiting: 32,
  AfterWaiting: 64,
  Exit: 128,
  AllActivities: 268435455
};

(globalThis as any)['CFRunLoop']['CFRunLoopRunResult'] = (globalThis as any)['CFRunLoop']['CFRunLoopRunResult'] || {};
(globalThis as any)['CFRunLoop']['CFRunLoopRunResult'] = {
  Finished: 1,
  Stopped: 2,
  TimedOut: 3,
  HandledSource: 4
};



(globalThis as any)['CFSocket'] = (globalThis as any)['CFSocket'] || {};
(globalThis as any)['CFSocket']['CFSocketCallBackType'] = (globalThis as any)['CFSocket']['CFSocketCallBackType'] || {};
(globalThis as any)['CFSocket']['CFSocketCallBackType'] = {
  NoCallBack: 0,
  ReadCallBack: 1,
  AcceptCallBack: 2,
  DataCallBack: 3,
  ConnectCallBack: 4,
  WriteCallBack: 8
};

(globalThis as any)['CFSocket']['CFSocketError'] = (globalThis as any)['CFSocket']['CFSocketError'] || {};
(globalThis as any)['CFSocket']['CFSocketError'] = {
  Success: 0,
  Error: -1,
  Timeout: -2
};


(globalThis as any)['CFStream'] = (globalThis as any)['CFStream'] || {};
(globalThis as any)['CFStream']['CFStreamErrorDomain'] = (globalThis as any)['CFStream']['CFStreamErrorDomain'] || {};
(globalThis as any)['CFStream']['CFStreamErrorDomain'] = {
  Custom: -1,
  POSIX: 1,
  MacOSStatus: 2
};

(globalThis as any)['CFStream']['CFStreamEventType'] = (globalThis as any)['CFStream']['CFStreamEventType'] || {};
(globalThis as any)['CFStream']['CFStreamEventType'] = {
  None: 0,
  OpenCompleted: 1,
  HasBytesAvailable: 2,
  CanAcceptBytes: 4,
  ErrorOccurred: 8,
  EndEncountered: 16
};

(globalThis as any)['CFStream']['CFStreamStatus'] = (globalThis as any)['CFStream']['CFStreamStatus'] || {};
(globalThis as any)['CFStream']['CFStreamStatus'] = {
  NotOpen: 0,
  Opening: 1,
  Open: 2,
  Reading: 3,
  Writing: 4,
  AtEnd: 5,
  Closed: 6,
  Error: 7
};


(globalThis as any)['CFString'] = (globalThis as any)['CFString'] || {};
(globalThis as any)['CFString']['CFStringBuiltInEncodings'] = (globalThis as any)['CFString']['CFStringBuiltInEncodings'] || {};
(globalThis as any)['CFString']['CFStringBuiltInEncodings'] = {
  MacRoman: 0,
  WindowsLatin1: 1280,
  ISOLatin1: 513,
  NextStepLatin: 2817,
  ASCII: 1536,
  Unicode: 256,
  UTF8: 134217984,
  NonLossyASCII: 3071,
  UTF16: 256,
  UTF16BE: 268435712,
  UTF16LE: 335544576,
  UTF32: 201326848,
  UTF32BE: 402653440,
  UTF32LE: 469762304
};

(globalThis as any)['CFString']['CFStringCompareFlags'] = (globalThis as any)['CFString']['CFStringCompareFlags'] || {};
(globalThis as any)['CFString']['CFStringCompareFlags'] = {
  CaseInsensitive: 1,
  Backwards: 4,
  Anchored: 8,
  Nonliteral: 16,
  Localized: 32,
  Numerically: 64,
  DiacriticInsensitive: 128,
  WidthInsensitive: 256,
  ForcedOrdering: 512
};

(globalThis as any)['CFString']['CFStringNormalizationForm'] = (globalThis as any)['CFString']['CFStringNormalizationForm'] || {};
(globalThis as any)['CFString']['CFStringNormalizationForm'] = {
  D: 0,
  KD: 1,
  C: 2,
  KC: 3
};


(globalThis as any)['CFStringEncodingExt'] = (globalThis as any)['CFStringEncodingExt'] || {};
(globalThis as any)['CFStringEncodingExt']['CFStringEncodings'] = (globalThis as any)['CFStringEncodingExt']['CFStringEncodings'] || {};
(globalThis as any)['CFStringEncodingExt']['CFStringEncodings'] = {
  MacJapanese: 1,
  MacChineseTrad: 2,
  MacKorean: 3,
  MacArabic: 4,
  MacHebrew: 5,
  MacGreek: 6,
  MacCyrillic: 7,
  MacDevanagari: 9,
  MacGurmukhi: 10,
  MacGujarati: 11,
  MacOriya: 12,
  MacBengali: 13,
  MacTamil: 14,
  MacTelugu: 15,
  MacKannada: 16,
  MacMalayalam: 17,
  MacSinhalese: 18,
  MacBurmese: 19,
  MacKhmer: 20,
  MacThai: 21,
  MacLaotian: 22,
  MacGeorgian: 23,
  MacArmenian: 24,
  MacChineseSimp: 25,
  MacTibetan: 26,
  MacMongolian: 27,
  MacEthiopic: 28,
  MacCentralEurRoman: 29,
  MacVietnamese: 30,
  MacExtArabic: 31,
  MacSymbol: 33,
  MacDingbats: 34,
  MacTurkish: 35,
  MacCroatian: 36,
  MacIcelandic: 37,
  MacRomanian: 38,
  MacCeltic: 39,
  MacGaelic: 40,
  MacFarsi: 140,
  MacUkrainian: 152,
  MacInuit: 236,
  MacVT100: 252,
  MacHFS: 255,
  ISOLatin2: 514,
  ISOLatin3: 515,
  ISOLatin4: 516,
  ISOLatinCyrillic: 517,
  ISOLatinArabic: 518,
  ISOLatinGreek: 519,
  ISOLatinHebrew: 520,
  ISOLatin5: 521,
  ISOLatin6: 522,
  ISOLatinThai: 523,
  ISOLatin7: 525,
  ISOLatin8: 526,
  ISOLatin9: 527,
  ISOLatin10: 528,
  DOSLatinUS: 1024,
  DOSGreek: 1029,
  DOSBalticRim: 1030,
  DOSLatin1: 1040,
  DOSGreek1: 1041,
  DOSLatin2: 1042,
  DOSCyrillic: 1043,
  DOSTurkish: 1044,
  DOSPortuguese: 1045,
  DOSIcelandic: 1046,
  DOSHebrew: 1047,
  DOSCanadianFrench: 1048,
  DOSArabic: 1049,
  DOSNordic: 1050,
  DOSRussian: 1051,
  DOSGreek2: 1052,
  DOSThai: 1053,
  DOSJapanese: 1056,
  DOSChineseSimplif: 1057,
  DOSKorean: 1058,
  DOSChineseTrad: 1059,
  WindowsLatin2: 1281,
  WindowsCyrillic: 1282,
  WindowsGreek: 1283,
  WindowsLatin5: 1284,
  WindowsHebrew: 1285,
  WindowsArabic: 1286,
  WindowsBalticRim: 1287,
  WindowsVietnamese: 1288,
  WindowsKoreanJohab: 1296,
  ANSEL: 1537,
  JIS_X0201_76: 1568,
  JIS_X0208_83: 1569,
  JIS_X0208_90: 1570,
  JIS_X0212_90: 1571,
  JIS_C6226_78: 1572,
  ShiftJIS_X0213: 1576,
  ShiftJIS_X0213_MenKuTen: 1577,
  GB_2312_80: 1584,
  GBK_95: 1585,
  GB_18030_2000: 1586,
  KSC_5601_87: 1600,
  KSC_5601_92_Johab: 1601,
  CNS_11643_92_P1: 1617,
  CNS_11643_92_P2: 1618,
  CNS_11643_92_P3: 1619,
  ISO_2022_JP: 2080,
  ISO_2022_JP_2: 2081,
  ISO_2022_JP_1: 2082,
  ISO_2022_JP_3: 2083,
  ISO_2022_CN: 2096,
  ISO_2022_CN_EXT: 2097,
  ISO_2022_KR: 2112,
  EUC_JP: 2336,
  EUC_CN: 2352,
  EUC_TW: 2353,
  EUC_KR: 2368,
  ShiftJIS: 2561,
  KOI8_R: 2562,
  Big5: 2563,
  MacRomanLatin1: 2564,
  HZ_GB_2312: 2565,
  Big5_HKSCS_1999: 2566,
  VISCII: 2567,
  KOI8_U: 2568,
  Big5_E: 2569,
  NextStepJapanese: 2818,
  EBCDIC_US: 3073,
  EBCDIC_CP037: 3074,
  UTF7: 67109120,
  UTF7_IMAP: 2576,
  ShiftJIS_X0213_00: 1576
};


(globalThis as any)['CFStringTokenizer'] = (globalThis as any)['CFStringTokenizer'] || {};
(globalThis as any)['CFStringTokenizer']['CFStringTokenizerTokenType'] = (globalThis as any)['CFStringTokenizer']['CFStringTokenizerTokenType'] || {};
(globalThis as any)['CFStringTokenizer']['CFStringTokenizerTokenType'] = {
  None: 0,
  Normal: 1,
  HasSubTokensMask: 2,
  HasDerivedSubTokensMask: 4,
  HasHasNumbersMask: 8,
  HasNonLettersMask: 16,
  IsCJWordMask: 32
};


(globalThis as any)['CFTimeZone'] = (globalThis as any)['CFTimeZone'] || {};
(globalThis as any)['CFTimeZone']['CFTimeZoneNameStyle'] = (globalThis as any)['CFTimeZone']['CFTimeZoneNameStyle'] || {};
(globalThis as any)['CFTimeZone']['CFTimeZoneNameStyle'] = {
  Standard: 0,
  ShortStandard: 1,
  DaylightSaving: 2,
  ShortDaylightSaving: 3,
  Generic: 4,
  ShortGeneric: 5
};


(globalThis as any)['CFURL'] = (globalThis as any)['CFURL'] || {};
(globalThis as any)['CFURL']['CFURLBookmarkCreationOptions'] = (globalThis as any)['CFURL']['CFURLBookmarkCreationOptions'] || {};
(globalThis as any)['CFURL']['CFURLBookmarkCreationOptions'] = {
  MinimalBookmarkMask: 512,
  SuitableForBookmarkFile: 1024,
  WithSecurityScope: 2048,
  SecurityScopeAllowOnlyReadAccess: 4096,
  PreferFileIDResolutionMask: 256
};

(globalThis as any)['CFURL']['CFURLBookmarkResolutionOptions'] = (globalThis as any)['CFURL']['CFURLBookmarkResolutionOptions'] || {};
(globalThis as any)['CFURL']['CFURLBookmarkResolutionOptions'] = {
  URLBookmarkResolutionWithoutUIMask: 256,
  URLBookmarkResolutionWithoutMountingMask: 512,
  URLBookmarkResolutionWithSecurityScope: 1024,
  BookmarkResolutionWithoutUIMask: 256,
  BookmarkResolutionWithoutMountingMask: 512
};

(globalThis as any)['CFURL']['CFURLComponentType'] = (globalThis as any)['CFURL']['CFURLComponentType'] || {};
(globalThis as any)['CFURL']['CFURLComponentType'] = {
  Scheme: 1,
  NetLocation: 2,
  Path: 3,
  ResourceSpecifier: 4,
  User: 5,
  Password: 6,
  UserInfo: 7,
  Host: 8,
  Port: 9,
  ParameterString: 10,
  Query: 11,
  Fragment: 12
};

(globalThis as any)['CFURL']['CFURLPathStyle'] = (globalThis as any)['CFURL']['CFURLPathStyle'] || {};
(globalThis as any)['CFURL']['CFURLPathStyle'] = {
  POSIXPathStyle: 0,
  HFSPathStyle: 1,
  WindowsPathStyle: 2
};


(globalThis as any)['CFURLEnumerator'] = (globalThis as any)['CFURLEnumerator'] || {};
(globalThis as any)['CFURLEnumerator']['CFURLEnumeratorOptions'] = (globalThis as any)['CFURLEnumerator']['CFURLEnumeratorOptions'] || {};
(globalThis as any)['CFURLEnumerator']['CFURLEnumeratorOptions'] = {
  DefaultBehavior: 0,
  DescendRecursively: 1,
  SkipInvisibles: 2,
  GenerateFileReferenceURLs: 4,
  SkipPackageContents: 8,
  IncludeDirectoriesPreOrder: 16,
  IncludeDirectoriesPostOrder: 32,
  GenerateRelativePathURLs: 64
};

(globalThis as any)['CFURLEnumerator']['CFURLEnumeratorResult'] = (globalThis as any)['CFURLEnumerator']['CFURLEnumeratorResult'] || {};
(globalThis as any)['CFURLEnumerator']['CFURLEnumeratorResult'] = {
  Success: 1,
  End: 2,
  Error: 3,
  DirectoryPostOrderSuccess: 4
};



(globalThis as any)['CFXMLNode'] = (globalThis as any)['CFXMLNode'] || {};
(globalThis as any)['CFXMLNode']['CFXMLEntityTypeCode'] = (globalThis as any)['CFXMLNode']['CFXMLEntityTypeCode'] || {};
(globalThis as any)['CFXMLNode']['CFXMLEntityTypeCode'] = {
  Parameter: 0,
  ParsedInternal: 1,
  ParsedExternal: 2,
  Unparsed: 3,
  Character: 4
};

(globalThis as any)['CFXMLNode']['CFXMLNodeTypeCode'] = (globalThis as any)['CFXMLNode']['CFXMLNodeTypeCode'] || {};
(globalThis as any)['CFXMLNode']['CFXMLNodeTypeCode'] = {
  Document: 1,
  Element: 2,
  Attribute: 3,
  ProcessingInstruction: 4,
  Comment: 5,
  Text: 6,
  CDATASection: 7,
  DocumentFragment: 8,
  Entity: 9,
  EntityReference: 10,
  DocumentType: 11,
  Whitespace: 12,
  Notation: 13,
  ElementTypeDeclaration: 14,
  AttributeListDeclaration: 15
};


(globalThis as any)['CFXMLParser'] = (globalThis as any)['CFXMLParser'] || {};
(globalThis as any)['CFXMLParser']['CFXMLParserOptions'] = (globalThis as any)['CFXMLParser']['CFXMLParserOptions'] || {};
(globalThis as any)['CFXMLParser']['CFXMLParserOptions'] = {
  ValidateDocument: 1,
  SkipMetaData: 2,
  ReplacePhysicalEntities: 4,
  SkipWhitespace: 8,
  ResolveExternalEntities: 16,
  AddImpliedAttributes: 32,
  AllOptions: 16777215,
  NoOptions: 0
};

(globalThis as any)['CFXMLParser']['CFXMLParserStatusCode'] = (globalThis as any)['CFXMLParser']['CFXMLParserStatusCode'] || {};
(globalThis as any)['CFXMLParser']['CFXMLParserStatusCode'] = {
  StatusParseNotBegun: -2,
  StatusParseInProgress: -1,
  StatusParseSuccessful: 0,
  ErrorUnexpectedEOF: 1,
  ErrorUnknownEncoding: 2,
  ErrorEncodingConversionFailure: 3,
  ErrorMalformedProcessingInstruction: 4,
  ErrorMalformedDTD: 5,
  ErrorMalformedName: 6,
  ErrorMalformedCDSect: 7,
  ErrorMalformedCloseTag: 8,
  ErrorMalformedStartTag: 9,
  ErrorMalformedDocument: 10,
  ErrorElementlessDocument: 11,
  ErrorMalformedComment: 12,
  ErrorMalformedCharacterReference: 13,
  ErrorMalformedParsedCharacterData: 14,
  ErrorNoData: 15
};




(globalThis as any)['CGColorConversionInfo'] = (globalThis as any)['CGColorConversionInfo'] || {};
(globalThis as any)['CGColorConversionInfo']['CGColorConversionInfoTransformType'] = (globalThis as any)['CGColorConversionInfo']['CGColorConversionInfoTransformType'] || {};
(globalThis as any)['CGColorConversionInfo']['CGColorConversionInfoTransformType'] = {
  FromSpace: 0,
  ToSpace: 1,
  ApplySpace: 2
};


(globalThis as any)['CGColorSpace'] = (globalThis as any)['CGColorSpace'] || {};
(globalThis as any)['CGColorSpace']['CGColorRenderingIntent'] = (globalThis as any)['CGColorSpace']['CGColorRenderingIntent'] || {};
(globalThis as any)['CGColorSpace']['CGColorRenderingIntent'] = {
  Default: 0,
  AbsoluteColorimetric: 1,
  RelativeColorimetric: 2,
  Perceptual: 3,
  Saturation: 4
};

(globalThis as any)['CGColorSpace']['CGColorSpaceModel'] = (globalThis as any)['CGColorSpace']['CGColorSpaceModel'] || {};
(globalThis as any)['CGColorSpace']['CGColorSpaceModel'] = {
  Unknown: -1,
  Monochrome: 0,
  RGB: 1,
  CMYK: 2,
  Lab: 3,
  DeviceN: 4,
  Indexed: 5,
  Pattern: 6,
  XYZ: 7
};


(globalThis as any)['CGContext'] = (globalThis as any)['CGContext'] || {};
(globalThis as any)['CGContext']['CGBlendMode'] = (globalThis as any)['CGContext']['CGBlendMode'] || {};
(globalThis as any)['CGContext']['CGBlendMode'] = {
  Normal: 0,
  Multiply: 1,
  Screen: 2,
  Overlay: 3,
  Darken: 4,
  Lighten: 5,
  ColorDodge: 6,
  ColorBurn: 7,
  SoftLight: 8,
  HardLight: 9,
  Difference: 10,
  Exclusion: 11,
  Hue: 12,
  Saturation: 13,
  Color: 14,
  Luminosity: 15,
  Clear: 16,
  Copy: 17,
  SourceIn: 18,
  SourceOut: 19,
  SourceAtop: 20,
  DestinationOver: 21,
  DestinationIn: 22,
  DestinationOut: 23,
  DestinationAtop: 24,
  XOR: 25,
  PlusDarker: 26,
  PlusLighter: 27
};

(globalThis as any)['CGContext']['CGInterpolationQuality'] = (globalThis as any)['CGContext']['CGInterpolationQuality'] || {};
(globalThis as any)['CGContext']['CGInterpolationQuality'] = {
  Default: 0,
  None: 1,
  Low: 2,
  Medium: 4,
  High: 3
};

(globalThis as any)['CGContext']['CGPathDrawingMode'] = (globalThis as any)['CGContext']['CGPathDrawingMode'] || {};
(globalThis as any)['CGContext']['CGPathDrawingMode'] = {
  Fill: 0,
  EOFill: 1,
  Stroke: 2,
  FillStroke: 3,
  EOFillStroke: 4
};

(globalThis as any)['CGContext']['CGTextDrawingMode'] = (globalThis as any)['CGContext']['CGTextDrawingMode'] || {};
(globalThis as any)['CGContext']['CGTextDrawingMode'] = {
  Fill: 0,
  Stroke: 1,
  FillStroke: 2,
  Invisible: 3,
  FillClip: 4,
  StrokeClip: 5,
  FillStrokeClip: 6,
  Clip: 7
};


(globalThis as any)['CGDirectDisplay'] = (globalThis as any)['CGDirectDisplay'] || {};
(globalThis as any)['CGDirectDisplay']['CGCaptureOptions'] = (globalThis as any)['CGDirectDisplay']['CGCaptureOptions'] || {};
(globalThis as any)['CGDirectDisplay']['CGCaptureOptions'] = {
  Options: 0,
  Fill: 1
};


(globalThis as any)['CGDisplayConfiguration'] = (globalThis as any)['CGDisplayConfiguration'] || {};
(globalThis as any)['CGDisplayConfiguration']['CGConfigureOption'] = (globalThis as any)['CGDisplayConfiguration']['CGConfigureOption'] || {};
(globalThis as any)['CGDisplayConfiguration']['CGConfigureOption'] = {
  ForAppOnly: 0,
  ForSession: 1,
  Permanently: 2
};

(globalThis as any)['CGDisplayConfiguration']['CGDisplayChangeSummaryFlags'] = (globalThis as any)['CGDisplayConfiguration']['CGDisplayChangeSummaryFlags'] || {};
(globalThis as any)['CGDisplayConfiguration']['CGDisplayChangeSummaryFlags'] = {
  BeginConfigurationFlag: 1,
  MovedFlag: 2,
  SetMainFlag: 4,
  SetModeFlag: 8,
  AddFlag: 16,
  RemoveFlag: 32,
  EnabledFlag: 256,
  DisabledFlag: 512,
  MirrorFlag: 1024,
  UnMirrorFlag: 2048,
  DesktopShapeChangedFlag: 4096
};


(globalThis as any)['CGDisplayStream'] = (globalThis as any)['CGDisplayStream'] || {};
(globalThis as any)['CGDisplayStream']['CGDisplayStreamFrameStatus'] = (globalThis as any)['CGDisplayStream']['CGDisplayStreamFrameStatus'] || {};
(globalThis as any)['CGDisplayStream']['CGDisplayStreamFrameStatus'] = {
  FrameComplete: 0,
  FrameIdle: 1,
  FrameBlank: 2,
  Stopped: 3
};

(globalThis as any)['CGDisplayStream']['CGDisplayStreamUpdateRectType'] = (globalThis as any)['CGDisplayStream']['CGDisplayStreamUpdateRectType'] || {};
(globalThis as any)['CGDisplayStream']['CGDisplayStreamUpdateRectType'] = {
  RefreshedRects: 0,
  MovedRects: 1,
  DirtyRects: 2,
  ReducedDirtyRects: 3
};


(globalThis as any)['CGError'] = (globalThis as any)['CGError'] || {};
(globalThis as any)['CGError']['CGError'] = (globalThis as any)['CGError']['CGError'] || {};
(globalThis as any)['CGError']['CGError'] = {
  Success: 0,
  Failure: 1000,
  IllegalArgument: 1001,
  InvalidConnection: 1002,
  InvalidContext: 1003,
  CannotComplete: 1004,
  NotImplemented: 1006,
  RangeCheck: 1007,
  TypeCheck: 1008,
  InvalidOperation: 1010,
  NoneAvailable: 1011
};


(globalThis as any)['CGEventTypes'] = (globalThis as any)['CGEventTypes'] || {};
(globalThis as any)['CGEventTypes']['CGEventField'] = (globalThis as any)['CGEventTypes']['CGEventField'] || {};
(globalThis as any)['CGEventTypes']['CGEventField'] = {
  MouseEventNumber: 0,
  MouseEventClickState: 1,
  MouseEventPressure: 2,
  MouseEventButtonNumber: 3,
  MouseEventDeltaX: 4,
  MouseEventDeltaY: 5,
  MouseEventInstantMouser: 6,
  MouseEventSubtype: 7,
  KeyboardEventAutorepeat: 8,
  KeyboardEventKeycode: 9,
  KeyboardEventKeyboardType: 10,
  ScrollWheelEventDeltaAxis1: 11,
  ScrollWheelEventDeltaAxis2: 12,
  ScrollWheelEventDeltaAxis3: 13,
  ScrollWheelEventFixedPtDeltaAxis1: 93,
  ScrollWheelEventFixedPtDeltaAxis2: 94,
  ScrollWheelEventFixedPtDeltaAxis3: 95,
  ScrollWheelEventPointDeltaAxis1: 96,
  ScrollWheelEventPointDeltaAxis2: 97,
  ScrollWheelEventPointDeltaAxis3: 98,
  ScrollWheelEventScrollPhase: 99,
  ScrollWheelEventScrollCount: 100,
  ScrollWheelEventMomentumPhase: 123,
  ScrollWheelEventInstantMouser: 14,
  TabletEventPointX: 15,
  TabletEventPointY: 16,
  TabletEventPointZ: 17,
  TabletEventPointButtons: 18,
  TabletEventPointPressure: 19,
  TabletEventTiltX: 20,
  TabletEventTiltY: 21,
  TabletEventRotation: 22,
  TabletEventTangentialPressure: 23,
  TabletEventDeviceID: 24,
  TabletEventVendor1: 25,
  TabletEventVendor2: 26,
  TabletEventVendor3: 27,
  TabletProximityEventVendorID: 28,
  TabletProximityEventTabletID: 29,
  TabletProximityEventPointerID: 30,
  TabletProximityEventDeviceID: 31,
  TabletProximityEventSystemTabletID: 32,
  TabletProximityEventVendorPointerType: 33,
  TabletProximityEventVendorPointerSerialNumber: 34,
  TabletProximityEventVendorUniqueID: 35,
  TabletProximityEventCapabilityMask: 36,
  TabletProximityEventPointerType: 37,
  TabletProximityEventEnterProximity: 38,
  EventTargetProcessSerialNumber: 39,
  EventTargetUnixProcessID: 40,
  EventSourceUnixProcessID: 41,
  EventSourceUserData: 42,
  EventSourceUserID: 43,
  EventSourceGroupID: 44,
  EventSourceStateID: 45,
  ScrollWheelEventIsContinuous: 88,
  MouseEventWindowUnderMousePointer: 91,
  MouseEventWindowUnderMousePointerThatCanHandleThisEvent: 92,
  EventUnacceleratedPointerMovementX: 170,
  EventUnacceleratedPointerMovementY: 171
};

(globalThis as any)['CGEventTypes']['CGEventFlags'] = (globalThis as any)['CGEventTypes']['CGEventFlags'] || {};
(globalThis as any)['CGEventTypes']['CGEventFlags'] = {
  AlphaShift: 65536,
  Shift: 131072,
  Control: 262144,
  Alternate: 524288,
  Command: 1048576,
  Help: 4194304,
  SecondaryFn: 8388608,
  NumericPad: 2097152,
  NonCoalesced: 256
};

(globalThis as any)['CGEventTypes']['CGEventMouseSubtype'] = (globalThis as any)['CGEventTypes']['CGEventMouseSubtype'] || {};
(globalThis as any)['CGEventTypes']['CGEventMouseSubtype'] = {
  Default: 0,
  TabletPoint: 1,
  TabletProximity: 2
};

(globalThis as any)['CGEventTypes']['CGEventSourceStateID'] = (globalThis as any)['CGEventTypes']['CGEventSourceStateID'] || {};
(globalThis as any)['CGEventTypes']['CGEventSourceStateID'] = {
  Private: -1,
  CombinedSessionState: 0,
  HIDSystemState: 1
};

(globalThis as any)['CGEventTypes']['CGEventTapLocation'] = (globalThis as any)['CGEventTypes']['CGEventTapLocation'] || {};
(globalThis as any)['CGEventTypes']['CGEventTapLocation'] = {
  HIDEventTap: 0,
  SessionEventTap: 1,
  AnnotatedSessionEventTap: 2
};

(globalThis as any)['CGEventTypes']['CGEventTapOptions'] = (globalThis as any)['CGEventTypes']['CGEventTapOptions'] || {};
(globalThis as any)['CGEventTypes']['CGEventTapOptions'] = {
  Default: 0,
  ListenOnly: 1
};

(globalThis as any)['CGEventTypes']['CGEventTapPlacement'] = (globalThis as any)['CGEventTypes']['CGEventTapPlacement'] || {};
(globalThis as any)['CGEventTypes']['CGEventTapPlacement'] = {
  HeadInsertEventTap: 0,
  TailAppendEventTap: 1
};

(globalThis as any)['CGEventTypes']['CGEventType'] = (globalThis as any)['CGEventTypes']['CGEventType'] || {};
(globalThis as any)['CGEventTypes']['CGEventType'] = {
  Null: 0,
  LeftMouseDown: 1,
  LeftMouseUp: 2,
  RightMouseDown: 3,
  RightMouseUp: 4,
  MouseMoved: 5,
  LeftMouseDragged: 6,
  RightMouseDragged: 7,
  KeyDown: 10,
  KeyUp: 11,
  FlagsChanged: 12,
  ScrollWheel: 22,
  TabletPointer: 23,
  TabletProximity: 24,
  OtherMouseDown: 25,
  OtherMouseUp: 26,
  OtherMouseDragged: 27,
  TapDisabledByTimeout: 4294967294,
  TapDisabledByUserInput: 4294967295
};

(globalThis as any)['CGEventTypes']['CGGesturePhase'] = (globalThis as any)['CGEventTypes']['CGGesturePhase'] || {};
(globalThis as any)['CGEventTypes']['CGGesturePhase'] = {
  None: 0,
  Began: 1,
  Changed: 2,
  Ended: 4,
  Cancelled: 8,
  MayBegin: 128
};

(globalThis as any)['CGEventTypes']['CGMomentumScrollPhase'] = (globalThis as any)['CGEventTypes']['CGMomentumScrollPhase'] || {};
(globalThis as any)['CGEventTypes']['CGMomentumScrollPhase'] = {
  None: 0,
  Begin: 1,
  Continue: 2,
  End: 3
};

(globalThis as any)['CGEventTypes']['CGMouseButton'] = (globalThis as any)['CGEventTypes']['CGMouseButton'] || {};
(globalThis as any)['CGEventTypes']['CGMouseButton'] = {
  Left: 0,
  Right: 1,
  Center: 2
};

(globalThis as any)['CGEventTypes']['CGScrollEventUnit'] = (globalThis as any)['CGEventTypes']['CGScrollEventUnit'] || {};
(globalThis as any)['CGEventTypes']['CGScrollEventUnit'] = {
  Pixel: 0,
  Line: 1
};

(globalThis as any)['CGEventTypes']['CGScrollPhase'] = (globalThis as any)['CGEventTypes']['CGScrollPhase'] || {};
(globalThis as any)['CGEventTypes']['CGScrollPhase'] = {
  Began: 1,
  Changed: 2,
  Ended: 4,
  Cancelled: 8,
  MayBegin: 128
};


(globalThis as any)['CGFont'] = (globalThis as any)['CGFont'] || {};
(globalThis as any)['CGFont']['CGFontPostScriptFormat'] = (globalThis as any)['CGFont']['CGFontPostScriptFormat'] || {};
(globalThis as any)['CGFont']['CGFontPostScriptFormat'] = {
  e1: 1,
  e3: 3,
  e42: 42
};

(globalThis as any)['CGFont']['CGGlyphDeprecatedEnum'] = (globalThis as any)['CGFont']['CGGlyphDeprecatedEnum'] || {};
(globalThis as any)['CGFont']['CGGlyphDeprecatedEnum'] = {
  in: 0,
  ax: 1
};


(globalThis as any)['CGGeometry'] = (globalThis as any)['CGGeometry'] || {};
(globalThis as any)['CGGeometry']['CGRectEdge'] = (globalThis as any)['CGGeometry']['CGRectEdge'] || {};
(globalThis as any)['CGGeometry']['CGRectEdge'] = {
  inXEdge: 0,
  inYEdge: 1,
  axXEdge: 2,
  axYEdge: 3
};


(globalThis as any)['CGGradient'] = (globalThis as any)['CGGradient'] || {};
(globalThis as any)['CGGradient']['CGGradientDrawingOptions'] = (globalThis as any)['CGGradient']['CGGradientDrawingOptions'] || {};
(globalThis as any)['CGGradient']['CGGradientDrawingOptions'] = {
  BeforeStartLocation: 1,
  AfterEndLocation: 2
};


(globalThis as any)['CGImage'] = (globalThis as any)['CGImage'] || {};
(globalThis as any)['CGImage']['CGBitmapInfo'] = (globalThis as any)['CGImage']['CGBitmapInfo'] || {};
(globalThis as any)['CGImage']['CGBitmapInfo'] = {
  AlphaInfoMask: 31,
  FloatInfoMask: 3840,
  FloatComponents: 256,
  ByteOrderMask: 28672,
  ByteOrderDefault: 0,
  ByteOrder16Little: 4096,
  ByteOrder32Little: 8192,
  ByteOrder16Big: 12288,
  ByteOrder32Big: 16384
};

(globalThis as any)['CGImage']['CGImageAlphaInfo'] = (globalThis as any)['CGImage']['CGImageAlphaInfo'] || {};
(globalThis as any)['CGImage']['CGImageAlphaInfo'] = {
  None: 0,
  PremultipliedLast: 1,
  PremultipliedFirst: 2,
  Last: 3,
  First: 4,
  NoneSkipLast: 5,
  NoneSkipFirst: 6,
  Only: 7
};

(globalThis as any)['CGImage']['CGImageByteOrderInfo'] = (globalThis as any)['CGImage']['CGImageByteOrderInfo'] || {};
(globalThis as any)['CGImage']['CGImageByteOrderInfo'] = {
  rMask: 28672,
  rDefault: 0,
  r16Little: 4096,
  r32Little: 8192,
  r16Big: 12288,
  r32Big: 16384
};

(globalThis as any)['CGImage']['CGImagePixelFormatInfo'] = (globalThis as any)['CGImage']['CGImagePixelFormatInfo'] || {};
(globalThis as any)['CGImage']['CGImagePixelFormatInfo'] = {
  Mask: 983040,
  Packed: 0,
  RGB555: 65536,
  RGB565: 131072,
  RGB101010: 196608,
  RGBCIF10: 262144
};


(globalThis as any)['CGPDFContext'] = (globalThis as any)['CGPDFContext'] || {};
(globalThis as any)['CGPDFContext']['CGPDFTagType'] = (globalThis as any)['CGPDFContext']['CGPDFTagType'] || {};
(globalThis as any)['CGPDFContext']['CGPDFTagType'] = {
  Document: 100,
  Part: 101,
  Art: 102,
  Section: 103,
  Div: 104,
  BlockQuote: 105,
  Caption: 106,
  TOC: 107,
  TOCI: 108,
  Index: 109,
  NonStructure: 110,
  Private: 111,
  Paragraph: 200,
  Header: 201,
  Header1: 202,
  Header2: 203,
  Header3: 204,
  Header4: 205,
  Header5: 206,
  Header6: 207,
  List: 300,
  ListItem: 301,
  Label: 302,
  ListBody: 303,
  Table: 400,
  TableRow: 401,
  TableHeaderCell: 402,
  TableDataCell: 403,
  TableHeader: 404,
  TableBody: 405,
  TableFooter: 406,
  Span: 500,
  Quote: 501,
  Note: 502,
  Reference: 503,
  Bibliography: 504,
  Code: 505,
  Link: 506,
  Annotation: 507,
  Ruby: 600,
  RubyBaseText: 601,
  RubyAnnotationText: 602,
  RubyPunctuation: 603,
  Warichu: 604,
  WarichuText: 605,
  WarichuPunctiation: 606,
  Figure: 700,
  Formula: 701,
  Form: 702
};


(globalThis as any)['CGPDFDocument'] = (globalThis as any)['CGPDFDocument'] || {};
(globalThis as any)['CGPDFDocument']['CGPDFAccessPermissions'] = (globalThis as any)['CGPDFDocument']['CGPDFAccessPermissions'] || {};
(globalThis as any)['CGPDFDocument']['CGPDFAccessPermissions'] = {
  LowQualityPrinting: 1,
  HighQualityPrinting: 2,
  DocumentChanges: 4,
  DocumentAssembly: 8,
  ContentCopying: 16,
  ContentAccessibility: 32,
  Commenting: 64,
  FormFieldEntry: 128
};


(globalThis as any)['CGPDFObject'] = (globalThis as any)['CGPDFObject'] || {};
(globalThis as any)['CGPDFObject']['CGPDFObjectType'] = (globalThis as any)['CGPDFObject']['CGPDFObjectType'] || {};
(globalThis as any)['CGPDFObject']['CGPDFObjectType'] = {
  Null: 1,
  Boolean: 2,
  Integer: 3,
  Real: 4,
  Name: 5,
  String: 6,
  Array: 7,
  Dictionary: 8,
  Stream: 9
};


(globalThis as any)['CGPDFPage'] = (globalThis as any)['CGPDFPage'] || {};
(globalThis as any)['CGPDFPage']['CGPDFBox'] = (globalThis as any)['CGPDFPage']['CGPDFBox'] || {};
(globalThis as any)['CGPDFPage']['CGPDFBox'] = {
  MediaBox: 0,
  CropBox: 1,
  BleedBox: 2,
  TrimBox: 3,
  ArtBox: 4
};


(globalThis as any)['CGPDFStream'] = (globalThis as any)['CGPDFStream'] || {};
(globalThis as any)['CGPDFStream']['CGPDFDataFormat'] = (globalThis as any)['CGPDFStream']['CGPDFDataFormat'] || {};
(globalThis as any)['CGPDFStream']['CGPDFDataFormat'] = {
  Raw: 0,
  JPEGEncoded: 1,
  JPEG2000: 2
};


(globalThis as any)['CGPath'] = (globalThis as any)['CGPath'] || {};
(globalThis as any)['CGPath']['CGLineCap'] = (globalThis as any)['CGPath']['CGLineCap'] || {};
(globalThis as any)['CGPath']['CGLineCap'] = {
  Butt: 0,
  Round: 1,
  Square: 2
};

(globalThis as any)['CGPath']['CGLineJoin'] = (globalThis as any)['CGPath']['CGLineJoin'] || {};
(globalThis as any)['CGPath']['CGLineJoin'] = {
  Miter: 0,
  Round: 1,
  Bevel: 2
};

(globalThis as any)['CGPath']['CGPathElementType'] = (globalThis as any)['CGPath']['CGPathElementType'] || {};
(globalThis as any)['CGPath']['CGPathElementType'] = {
  MoveToPoint: 0,
  AddLineToPoint: 1,
  AddQuadCurveToPoint: 2,
  AddCurveToPoint: 3,
  CloseSubpath: 4
};


(globalThis as any)['CGPattern'] = (globalThis as any)['CGPattern'] || {};
(globalThis as any)['CGPattern']['CGPatternTiling'] = (globalThis as any)['CGPattern']['CGPatternTiling'] || {};
(globalThis as any)['CGPattern']['CGPatternTiling'] = {
  NoDistortion: 0,
  ConstantSpacingMinimalDistortion: 1,
  ConstantSpacing: 2
};


(globalThis as any)['CGRemoteOperation'] = (globalThis as any)['CGRemoteOperation'] || {};
(globalThis as any)['CGRemoteOperation']['CGEventFilterMask'] = (globalThis as any)['CGRemoteOperation']['CGEventFilterMask'] || {};
(globalThis as any)['CGRemoteOperation']['CGEventFilterMask'] = {
  LocalMouseEvents: 1,
  LocalKeyboardEvents: 2,
  SystemDefinedEvents: 4
};

(globalThis as any)['CGRemoteOperation']['CGEventSuppressionState'] = (globalThis as any)['CGRemoteOperation']['CGEventSuppressionState'] || {};
(globalThis as any)['CGRemoteOperation']['CGEventSuppressionState'] = {
  EventSuppressionStateSuppressionInterval: 0,
  EventSuppressionStateRemoteMouseDrag: 1,
  NumberOfEventSuppressionStates: 2
};

(globalThis as any)['CGRemoteOperation']['CGScreenUpdateOperation'] = (globalThis as any)['CGRemoteOperation']['CGScreenUpdateOperation'] || {};
(globalThis as any)['CGRemoteOperation']['CGScreenUpdateOperation'] = {
  Refresh: 0,
  Move: 1,
  ReducedDirtyRectangleCount: 2147483648
};


(globalThis as any)['CGWindow'] = (globalThis as any)['CGWindow'] || {};
(globalThis as any)['CGWindow']['CGWindowBackingType'] = (globalThis as any)['CGWindow']['CGWindowBackingType'] || {};
(globalThis as any)['CGWindow']['CGWindowBackingType'] = {
  Retained: 0,
  Nonretained: 1,
  Buffered: 2
};

(globalThis as any)['CGWindow']['CGWindowImageOption'] = (globalThis as any)['CGWindow']['CGWindowImageOption'] || {};
(globalThis as any)['CGWindow']['CGWindowImageOption'] = {
  Default: 0,
  BoundsIgnoreFraming: 1,
  ShouldBeOpaque: 2,
  OnlyShadows: 4,
  BestResolution: 8,
  NominalResolution: 16
};

(globalThis as any)['CGWindow']['CGWindowListOption'] = (globalThis as any)['CGWindow']['CGWindowListOption'] || {};
(globalThis as any)['CGWindow']['CGWindowListOption'] = {
  OptionAll: 0,
  OptionOnScreenOnly: 1,
  OptionOnScreenAboveWindow: 2,
  OptionOnScreenBelowWindow: 4,
  OptionIncludingWindow: 8,
  ExcludeDesktopElements: 16
};

(globalThis as any)['CGWindow']['CGWindowSharingType'] = (globalThis as any)['CGWindow']['CGWindowSharingType'] || {};
(globalThis as any)['CGWindow']['CGWindowSharingType'] = {
  None: 0,
  ReadOnly: 1,
  ReadWrite: 2
};


(globalThis as any)['CGWindowLevel'] = (globalThis as any)['CGWindowLevel'] || {};
(globalThis as any)['CGWindowLevel']['CGWindowLevelKey'] = (globalThis as any)['CGWindowLevel']['CGWindowLevelKey'] || {};
(globalThis as any)['CGWindowLevel']['CGWindowLevelKey'] = {
  BaseWindowLevelKey: 0,
  MinimumWindowLevelKey: 1,
  DesktopWindowLevelKey: 2,
  BackstopMenuLevelKey: 3,
  NormalWindowLevelKey: 4,
  FloatingWindowLevelKey: 5,
  TornOffMenuWindowLevelKey: 6,
  DockWindowLevelKey: 7,
  MainMenuWindowLevelKey: 8,
  StatusWindowLevelKey: 9,
  ModalPanelWindowLevelKey: 10,
  PopUpMenuWindowLevelKey: 11,
  DraggingWindowLevelKey: 12,
  ScreenSaverWindowLevelKey: 13,
  MaximumWindowLevelKey: 14,
  OverlayWindowLevelKey: 15,
  HelpWindowLevelKey: 16,
  UtilityWindowLevelKey: 17,
  DesktopIconWindowLevelKey: 18,
  CursorWindowLevelKey: 19,
  AssistiveTechHighWindowLevelKey: 20,
  NumberOfWindowLevelKeys: 21
};


(globalThis as any)['CIBarcodeDescriptor'] = (globalThis as any)['CIBarcodeDescriptor'] || {};
(globalThis as any)['CIBarcodeDescriptor']['CIDataMatrixCodeECCVersion'] = (globalThis as any)['CIBarcodeDescriptor']['CIDataMatrixCodeECCVersion'] || {};
(globalThis as any)['CIBarcodeDescriptor']['CIDataMatrixCodeECCVersion'] = {
  n000: 0,
  n050: 50,
  n080: 80,
  n100: 100,
  n140: 140,
  n200: 200
};

(globalThis as any)['CIBarcodeDescriptor']['CIQRCodeErrorCorrectionLevel'] = (globalThis as any)['CIBarcodeDescriptor']['CIQRCodeErrorCorrectionLevel'] || {};
(globalThis as any)['CIBarcodeDescriptor']['CIQRCodeErrorCorrectionLevel'] = {
  L: 76,
  M: 77,
  Q: 81,
  H: 72
};


(globalThis as any)['CIColor'] = (globalThis as any)['CIColor'] || {};

(globalThis as any)['CIContext'] = (globalThis as any)['CIContext'] || {};

(globalThis as any)['CIDetector'] = (globalThis as any)['CIDetector'] || {};

(globalThis as any)['CIFeature'] = (globalThis as any)['CIFeature'] || {};

(globalThis as any)['CIFilter'] = (globalThis as any)['CIFilter'] || {};

(globalThis as any)['CIFilterConstructor'] = (globalThis as any)['CIFilterConstructor'] || {};

(globalThis as any)['CIFilterGenerator'] = (globalThis as any)['CIFilterGenerator'] || {};

(globalThis as any)['CIFilterShape'] = (globalThis as any)['CIFilterShape'] || {};

(globalThis as any)['CIImage'] = (globalThis as any)['CIImage'] || {};

(globalThis as any)['CIImageAccumulator'] = (globalThis as any)['CIImageAccumulator'] || {};


(globalThis as any)['CIKernel'] = (globalThis as any)['CIKernel'] || {};

(globalThis as any)['CIPlugIn'] = (globalThis as any)['CIPlugIn'] || {};


(globalThis as any)['CIRenderDestination'] = (globalThis as any)['CIRenderDestination'] || {};
(globalThis as any)['CIRenderDestination']['CIRenderDestinationAlphaMode'] = (globalThis as any)['CIRenderDestination']['CIRenderDestinationAlphaMode'] || {};
(globalThis as any)['CIRenderDestination']['CIRenderDestinationAlphaMode'] = {
  None: 0,
  Premultiplied: 1,
  Unpremultiplied: 2
};


(globalThis as any)['CISampler'] = (globalThis as any)['CISampler'] || {};

(globalThis as any)['CIVector'] = (globalThis as any)['CIVector'] || {};

(globalThis as any)['CKAcceptSharesOperation'] = (globalThis as any)['CKAcceptSharesOperation'] || {};

(globalThis as any)['CKAsset'] = (globalThis as any)['CKAsset'] || {};

(globalThis as any)['CKContainer'] = (globalThis as any)['CKContainer'] || {};
(globalThis as any)['CKContainer']['CKAccountStatus'] = (globalThis as any)['CKContainer']['CKAccountStatus'] || {};
(globalThis as any)['CKContainer']['CKAccountStatus'] = {
  CouldNotDetermine: 0,
  Available: 1,
  Restricted: 2,
  NoAccount: 3
};

(globalThis as any)['CKContainer']['CKContainer_Application_PermissionStatus'] = (globalThis as any)['CKContainer']['CKContainer_Application_PermissionStatus'] || {};
(globalThis as any)['CKContainer']['CKContainer_Application_PermissionStatus'] = {
  InitialState: 0,
  CouldNotComplete: 1,
  Denied: 2,
  Granted: 3
};

(globalThis as any)['CKContainer']['CKContainer_Application_Permissions'] = (globalThis as any)['CKContainer']['CKContainer_Application_Permissions'] || {};
(globalThis as any)['CKContainer']['CKContainer_Application_Permissions'] = {
  CKApplicationPermissionUserDiscoverability: 1
};


(globalThis as any)['CKDatabase'] = (globalThis as any)['CKDatabase'] || {};
(globalThis as any)['CKDatabase']['Scope'] = (globalThis as any)['CKDatabase']['Scope'] || {};
(globalThis as any)['CKDatabase']['Scope'] = {
  Public: 1,
  Private: 2,
  Shared: 3
};


(globalThis as any)['CKDatabaseOperation'] = (globalThis as any)['CKDatabaseOperation'] || {};

(globalThis as any)['CKDiscoverAllUserIdentitiesOperation'] = (globalThis as any)['CKDiscoverAllUserIdentitiesOperation'] || {};

(globalThis as any)['CKDiscoverUserIdentitiesOperation'] = (globalThis as any)['CKDiscoverUserIdentitiesOperation'] || {};

(globalThis as any)['CKError'] = (globalThis as any)['CKError'] || {};
(globalThis as any)['CKError']['CKErrorCode'] = (globalThis as any)['CKError']['CKErrorCode'] || {};
(globalThis as any)['CKError']['CKErrorCode'] = {
  InternalError: 1,
  PartialFailure: 2,
  NetworkUnavailable: 3,
  NetworkFailure: 4,
  BadContainer: 5,
  ServiceUnavailable: 6,
  RequestRateLimited: 7,
  MissingEntitlement: 8,
  NotAuthenticated: 9,
  PermissionFailure: 10,
  UnknownItem: 11,
  InvalidArguments: 12,
  ResultsTruncated: 13,
  ServerRecordChanged: 14,
  ServerRejectedRequest: 15,
  AssetFileNotFound: 16,
  AssetFileModified: 17,
  IncompatibleVersion: 18,
  ConstraintViolation: 19,
  OperationCancelled: 20,
  ChangeTokenExpired: 21,
  BatchRequestFailed: 22,
  ZoneBusy: 23,
  BadDatabase: 24,
  QuotaExceeded: 25,
  ZoneNotFound: 26,
  LimitExceeded: 27,
  UserDeletedZone: 28,
  TooManyParticipants: 29,
  AlreadyShared: 30,
  ReferenceViolation: 31,
  ManagedAccountRestricted: 32,
  ParticipantMayNeedVerification: 33,
  ServerResponseLost: 34,
  AssetNotAvailable: 35
};


(globalThis as any)['CKFetchDatabaseChangesOperation'] = (globalThis as any)['CKFetchDatabaseChangesOperation'] || {};

(globalThis as any)['CKFetchRecordZoneChangesOperation'] = (globalThis as any)['CKFetchRecordZoneChangesOperation'] || {};

(globalThis as any)['CKFetchRecordZonesOperation'] = (globalThis as any)['CKFetchRecordZonesOperation'] || {};

(globalThis as any)['CKFetchRecordsOperation'] = (globalThis as any)['CKFetchRecordsOperation'] || {};

(globalThis as any)['CKFetchShareMetadataOperation'] = (globalThis as any)['CKFetchShareMetadataOperation'] || {};

(globalThis as any)['CKFetchShareParticipantsOperation'] = (globalThis as any)['CKFetchShareParticipantsOperation'] || {};

(globalThis as any)['CKFetchSubscriptionsOperation'] = (globalThis as any)['CKFetchSubscriptionsOperation'] || {};

(globalThis as any)['CKFetchWebAuthTokenOperation'] = (globalThis as any)['CKFetchWebAuthTokenOperation'] || {};

(globalThis as any)['CKLocationSortDescriptor'] = (globalThis as any)['CKLocationSortDescriptor'] || {};

(globalThis as any)['CKModifyRecordZonesOperation'] = (globalThis as any)['CKModifyRecordZonesOperation'] || {};

(globalThis as any)['CKModifyRecordsOperation'] = (globalThis as any)['CKModifyRecordsOperation'] || {};
(globalThis as any)['CKModifyRecordsOperation']['RecordSavePolicy'] = (globalThis as any)['CKModifyRecordsOperation']['RecordSavePolicy'] || {};
(globalThis as any)['CKModifyRecordsOperation']['RecordSavePolicy'] = {
  IfServerRecordUnchanged: 0,
  ChangedKeys: 1,
  AllKeys: 2
};


(globalThis as any)['CKModifySubscriptionsOperation'] = (globalThis as any)['CKModifySubscriptionsOperation'] || {};

(globalThis as any)['CKNotification'] = (globalThis as any)['CKNotification'] || {};
(globalThis as any)['CKNotification']['CKQueryNotification'] = (globalThis as any)['CKNotification']['CKQueryNotification'] || {};
(globalThis as any)['CKNotification']['CKQueryNotification']['Reason'] = (globalThis as any)['CKNotification']['CKQueryNotification']['Reason'] || {};
(globalThis as any)['CKNotification']['CKQueryNotification']['Reason'] = {
  Created: 1,
  Updated: 2,
  Deleted: 3
};

(globalThis as any)['CKNotification']['NotificationType'] = (globalThis as any)['CKNotification']['NotificationType'] || {};
(globalThis as any)['CKNotification']['NotificationType'] = {
  Query: 1,
  RecordZone: 2,
  ReadNotification: 3,
  Database: 4
};


(globalThis as any)['CKOperation'] = (globalThis as any)['CKOperation'] || {};

(globalThis as any)['CKOperationGroup'] = (globalThis as any)['CKOperationGroup'] || {};
(globalThis as any)['CKOperationGroup']['TransferSize'] = (globalThis as any)['CKOperationGroup']['TransferSize'] || {};
(globalThis as any)['CKOperationGroup']['TransferSize'] = {
  Unknown: 0,
  Kilobytes: 1,
  Megabytes: 2,
  TensOfMegabytes: 3,
  HundredsOfMegabytes: 4,
  Gigabytes: 5,
  TensOfGigabytes: 6,
  HundredsOfGigabytes: 7
};


(globalThis as any)['CKQuery'] = (globalThis as any)['CKQuery'] || {};

(globalThis as any)['CKQueryOperation'] = (globalThis as any)['CKQueryOperation'] || {};

(globalThis as any)['CKRecord'] = (globalThis as any)['CKRecord'] || {};

(globalThis as any)['CKRecordZone'] = (globalThis as any)['CKRecordZone'] || {};
(globalThis as any)['CKRecordZone']['Capabilities'] = (globalThis as any)['CKRecordZone']['Capabilities'] || {};
(globalThis as any)['CKRecordZone']['Capabilities'] = {
  FetchChanges: 1,
  Atomic: 2,
  Sharing: 4
};


(globalThis as any)['CKShare'] = (globalThis as any)['CKShare'] || {};

(globalThis as any)['CKSubscription'] = (globalThis as any)['CKSubscription'] || {};
(globalThis as any)['CKSubscription']['CKQuerySubscription'] = (globalThis as any)['CKSubscription']['CKQuerySubscription'] || {};
(globalThis as any)['CKSubscription']['CKQuerySubscription']['Options'] = (globalThis as any)['CKSubscription']['CKQuerySubscription']['Options'] || {};
(globalThis as any)['CKSubscription']['CKQuerySubscription']['Options'] = {
  RecordCreation: 1,
  RecordUpdate: 2,
  RecordDeletion: 4,
  ce: 8
};

(globalThis as any)['CKSubscription']['SubscriptionType'] = (globalThis as any)['CKSubscription']['SubscriptionType'] || {};
(globalThis as any)['CKSubscription']['SubscriptionType'] = {
  Query: 1,
  RecordZone: 2,
  Database: 3
};


(globalThis as any)['CKUserIdentity'] = (globalThis as any)['CKUserIdentity'] || {};









(globalThis as any)['CMTime'] = (globalThis as any)['CMTime'] || {};
(globalThis as any)['CMTime']['CMTimeFlags'] = (globalThis as any)['CMTime']['CMTimeFlags'] || {};
(globalThis as any)['CMTime']['CMTimeFlags'] = {
  _Valid: 1,
  _HasBeenRounded: 2,
  _PositiveInfinity: 4,
  _NegativeInfinity: 8,
  _Indefinite: 16,
  _ImpliedValueFlagsMask: 28
};

(globalThis as any)['CMTime']['CMTimeRoundingMethod'] = (globalThis as any)['CMTime']['CMTimeRoundingMethod'] || {};
(globalThis as any)['CMTime']['CMTimeRoundingMethod'] = {
  _RoundHalfAwayFromZero: 1,
  _RoundTowardZero: 2,
  _RoundAwayFromZero: 3,
  _QuickTime: 4,
  _RoundTowardPositiveInfinity: 5,
  _RoundTowardNegativeInfinity: 6,
  _Default: 1
};



(globalThis as any)['Calendar'] = (globalThis as any)['Calendar'] || {};
(globalThis as any)['Calendar']['Options'] = (globalThis as any)['Calendar']['Options'] || {};
(globalThis as any)['Calendar']['Options'] = {
  WrapComponents: 1,
  MatchStrictly: 2,
  SearchBackwards: 4,
  MatchPreviousTimePreservingSmallerUnits: 256,
  MatchNextTimePreservingSmallerUnits: 512,
  MatchNextTime: 1024,
  MatchFirst: 4096,
  MatchLast: 8192
};

(globalThis as any)['Calendar']['Unit'] = (globalThis as any)['Calendar']['Unit'] || {};
(globalThis as any)['Calendar']['Unit'] = {
  CalendarUnitEra: 2,
  CalendarUnitYear: 4,
  CalendarUnitMonth: 8,
  CalendarUnitDay: 16,
  CalendarUnitHour: 32,
  CalendarUnitMinute: 64,
  CalendarUnitSecond: 128,
  CalendarUnitWeekday: 512,
  CalendarUnitWeekdayOrdinal: 1024,
  CalendarUnitQuarter: 2048,
  CalendarUnitWeekOfMonth: 4096,
  CalendarUnitWeekOfYear: 8192,
  CalendarUnitYearForWeekOfYear: 16384,
  CalendarUnitNanosecond: 32768,
  CalendarUnitCalendar: 1048576,
  CalendarUnitTimeZone: 2097152,
  EraCalendarUnit: 2,
  YearCalendarUnit: 4,
  MonthCalendarUnit: 8,
  DayCalendarUnit: 16,
  HourCalendarUnit: 32,
  MinuteCalendarUnit: 64,
  SecondCalendarUnit: 128,
  WeekCalendarUnit: 256,
  WeekdayCalendarUnit: 512,
  WeekdayOrdinalCalendarUnit: 1024,
  QuarterCalendarUnit: 2048,
  WeekOfMonthCalendarUnit: 4096,
  WeekOfYearCalendarUnit: 8192,
  YearForWeekOfYearCalendarUnit: 16384,
  CalendarCalendarUnit: 1048576,
  TimeZoneCalendarUnit: 2097152
};


(globalThis as any)['CollectionDifference'] = (globalThis as any)['CollectionDifference'] || {};
(globalThis as any)['CollectionDifference']['NSOrderedCollectionDifferenceCalculationOptions'] = (globalThis as any)['CollectionDifference']['NSOrderedCollectionDifferenceCalculationOptions'] || {};
(globalThis as any)['CollectionDifference']['NSOrderedCollectionDifferenceCalculationOptions'] = {
  OmitInsertedObjects: 1,
  OmitRemovedObjects: 2,
  InferMoves: 4
};




(globalThis as any)['Data'] = (globalThis as any)['Data'] || {};
(globalThis as any)['Data']['Base64DecodingOptions'] = (globalThis as any)['Data']['Base64DecodingOptions'] || {};
(globalThis as any)['Data']['Base64DecodingOptions'] = {
  NSDataBase64DecodingIgnoreUnknownCharacters: 1
};

(globalThis as any)['Data']['Base64EncodingOptions'] = (globalThis as any)['Data']['Base64EncodingOptions'] || {};
(globalThis as any)['Data']['Base64EncodingOptions'] = {
  ing64CharacterLineLength: 1,
  ing76CharacterLineLength: 2,
  ingEndLineWithCarriageReturn: 16,
  ingEndLineWithLineFeed: 32
};

(globalThis as any)['Data']['CompressionAlgorithm'] = (globalThis as any)['Data']['CompressionAlgorithm'] || {};
(globalThis as any)['Data']['CompressionAlgorithm'] = {
  LZFSE: 0,
  LZ4: 1,
  LZMA: 2,
  Zlib: 3
};

(globalThis as any)['Data']['ReadingOptions'] = (globalThis as any)['Data']['ReadingOptions'] || {};
(globalThis as any)['Data']['ReadingOptions'] = {
  DataReadingMappedIfSafe: 1,
  DataReadingUncached: 2,
  DataReadingMappedAlways: 8,
  DataReadingMapped: 1,
  MappedRead: 1,
  UncachedRead: 2
};

(globalThis as any)['Data']['SearchOptions'] = (globalThis as any)['Data']['SearchOptions'] || {};
(globalThis as any)['Data']['SearchOptions'] = {
  Backwards: 1,
  Anchored: 2
};

(globalThis as any)['Data']['WritingOptions'] = (globalThis as any)['Data']['WritingOptions'] || {};
(globalThis as any)['Data']['WritingOptions'] = {
  DataWritingAtomic: 1,
  DataWritingWithoutOverwriting: 2,
  DataWritingFileProtectionNone: 268435456,
  DataWritingFileProtectionComplete: 536870912,
  DataWritingFileProtectionCompleteUnlessOpen: 805306368,
  DataWritingFileProtectionCompleteUntilFirstUserAuthentication: 1073741824,
  DataWritingFileProtectionMask: 4026531840,
  AtomicWrite: 1
};


(globalThis as any)['DateComponentsFormatter'] = (globalThis as any)['DateComponentsFormatter'] || {};
(globalThis as any)['DateComponentsFormatter']['UnitsStyle'] = (globalThis as any)['DateComponentsFormatter']['UnitsStyle'] || {};
(globalThis as any)['DateComponentsFormatter']['UnitsStyle'] = {
  Positional: 0,
  Abbreviated: 1,
  Short: 2,
  Full: 3,
  SpellOut: 4,
  Brief: 5
};

(globalThis as any)['DateComponentsFormatter']['ZeroFormattingBehavior'] = (globalThis as any)['DateComponentsFormatter']['ZeroFormattingBehavior'] || {};
(globalThis as any)['DateComponentsFormatter']['ZeroFormattingBehavior'] = {
  None: 0,
  Default: 1,
  DropLeading: 2,
  DropMiddle: 4,
  DropTrailing: 8,
  DropAll: 14,
  Pad: 65536
};


(globalThis as any)['DateFormatter'] = (globalThis as any)['DateFormatter'] || {};
(globalThis as any)['DateFormatter']['Behavior'] = (globalThis as any)['DateFormatter']['Behavior'] || {};
(globalThis as any)['DateFormatter']['Behavior'] = {
  rDefault: 0,
  r10_0: 1000,
  r10_4: 1040
};

(globalThis as any)['DateFormatter']['Style'] = (globalThis as any)['DateFormatter']['Style'] || {};
(globalThis as any)['DateFormatter']['Style'] = {
  NoStyle: 0,
  ShortStyle: 1,
  MediumStyle: 2,
  LongStyle: 3,
  FullStyle: 4
};


(globalThis as any)['DateIntervalFormatter'] = (globalThis as any)['DateIntervalFormatter'] || {};
(globalThis as any)['DateIntervalFormatter']['Style'] = (globalThis as any)['DateIntervalFormatter']['Style'] || {};
(globalThis as any)['DateIntervalFormatter']['Style'] = {
  NoStyle: 0,
  ShortStyle: 1,
  MediumStyle: 2,
  LongStyle: 3,
  FullStyle: 4
};


(globalThis as any)['Decimal'] = (globalThis as any)['Decimal'] || {};
(globalThis as any)['Decimal']['CalculationError'] = (globalThis as any)['Decimal']['CalculationError'] || {};
(globalThis as any)['Decimal']['CalculationError'] = {
  NoError: 0,
  LossOfPrecision: 1,
  Underflow: 2,
  Overflow: 3,
  DivideByZero: 4
};

(globalThis as any)['Decimal']['RoundingMode'] = (globalThis as any)['Decimal']['RoundingMode'] || {};
(globalThis as any)['Decimal']['RoundingMode'] = {
  Plain: 0,
  Down: 1,
  Up: 2,
  Bankers: 3
};


(globalThis as any)['DistributedNotificationCenter'] = (globalThis as any)['DistributedNotificationCenter'] || {};
(globalThis as any)['DistributedNotificationCenter']['Options'] = (globalThis as any)['DistributedNotificationCenter']['Options'] || {};
(globalThis as any)['DistributedNotificationCenter']['Options'] = {
  DeliverImmediately: 1,
  PostToAllSessions: 2
};

(globalThis as any)['DistributedNotificationCenter']['SuspensionBehavior'] = (globalThis as any)['DistributedNotificationCenter']['SuspensionBehavior'] || {};
(globalThis as any)['DistributedNotificationCenter']['SuspensionBehavior'] = {
  Drop: 1,
  Coalesce: 2,
  Hold: 3,
  DeliverImmediately: 4
};


(globalThis as any)['EnergyFormatter'] = (globalThis as any)['EnergyFormatter'] || {};
(globalThis as any)['EnergyFormatter']['Unit'] = (globalThis as any)['EnergyFormatter']['Unit'] || {};
(globalThis as any)['EnergyFormatter']['Unit'] = {
  Joule: 11,
  Kilojoule: 14,
  Calorie: 1793,
  Kilocalorie: 1794
};


(globalThis as any)['FileManager'] = (globalThis as any)['FileManager'] || {};
(globalThis as any)['FileManager']['DirectoryEnumerationOptions'] = (globalThis as any)['FileManager']['DirectoryEnumerationOptions'] || {};
(globalThis as any)['FileManager']['DirectoryEnumerationOptions'] = {
  SkipsSubdirectoryDescendants: 1,
  SkipsPackageDescendants: 2,
  SkipsHiddenFiles: 4,
  IncludesDirectoriesPostOrder: 8,
  ProducesRelativePathURLs: 16
};

(globalThis as any)['FileManager']['ItemReplacementOptions'] = (globalThis as any)['FileManager']['ItemReplacementOptions'] || {};
(globalThis as any)['FileManager']['ItemReplacementOptions'] = {
  UsingNewMetadataOnly: 1,
  WithoutDeletingBackupItem: 2
};

(globalThis as any)['FileManager']['SearchPathDirectory'] = (globalThis as any)['FileManager']['SearchPathDirectory'] || {};
(globalThis as any)['FileManager']['SearchPathDirectory'] = {
  ApplicationDirectory: 1,
  DemoApplicationDirectory: 2,
  DeveloperApplicationDirectory: 3,
  AdminApplicationDirectory: 4,
  LibraryDirectory: 5,
  DeveloperDirectory: 6,
  UserDirectory: 7,
  DocumentationDirectory: 8,
  DocumentDirectory: 9,
  CoreServiceDirectory: 10,
  AutosavedInformationDirectory: 11,
  DesktopDirectory: 12,
  CachesDirectory: 13,
  ApplicationSupportDirectory: 14,
  DownloadsDirectory: 15,
  InputMethodsDirectory: 16,
  MoviesDirectory: 17,
  MusicDirectory: 18,
  PicturesDirectory: 19,
  PrinterDescriptionDirectory: 20,
  SharedPublicDirectory: 21,
  PreferencePanesDirectory: 22,
  ApplicationScriptsDirectory: 23,
  ItemReplacementDirectory: 99,
  AllApplicationsDirectory: 100,
  AllLibrariesDirectory: 101,
  TrashDirectory: 102
};

(globalThis as any)['FileManager']['SearchPathDomainMask'] = (globalThis as any)['FileManager']['SearchPathDomainMask'] || {};
(globalThis as any)['FileManager']['SearchPathDomainMask'] = {
  UserDomainMask: 1,
  LocalDomainMask: 2,
  NetworkDomainMask: 4,
  SystemDomainMask: 8,
  AllDomainsMask: 65535
};

(globalThis as any)['FileManager']['URLRelationship'] = (globalThis as any)['FileManager']['URLRelationship'] || {};
(globalThis as any)['FileManager']['URLRelationship'] = {
  Contains: 0,
  Same: 1,
  Other: 2
};

(globalThis as any)['FileManager']['UnmountOptions'] = (globalThis as any)['FileManager']['UnmountOptions'] || {};
(globalThis as any)['FileManager']['UnmountOptions'] = {
  AllPartitionsAndEjectDisk: 1,
  WithoutUI: 2
};

(globalThis as any)['FileManager']['VolumeEnumerationOptions'] = (globalThis as any)['FileManager']['VolumeEnumerationOptions'] || {};
(globalThis as any)['FileManager']['VolumeEnumerationOptions'] = {
  SkipHiddenVolumes: 2,
  ProduceFileReferenceURLs: 4
};


(globalThis as any)['FileWrapper'] = (globalThis as any)['FileWrapper'] || {};
(globalThis as any)['FileWrapper']['ReadingOptions'] = (globalThis as any)['FileWrapper']['ReadingOptions'] || {};
(globalThis as any)['FileWrapper']['ReadingOptions'] = {
  Immediate: 1,
  WithoutMapping: 2
};

(globalThis as any)['FileWrapper']['WritingOptions'] = (globalThis as any)['FileWrapper']['WritingOptions'] || {};
(globalThis as any)['FileWrapper']['WritingOptions'] = {
  Atomic: 1,
  WithNameUpdating: 2
};


(globalThis as any)['Formatter'] = (globalThis as any)['Formatter'] || {};
(globalThis as any)['Formatter']['Context'] = (globalThis as any)['Formatter']['Context'] || {};
(globalThis as any)['Formatter']['Context'] = {
  Unknown: 0,
  Dynamic: 1,
  Standalone: 2,
  ListItem: 3,
  BeginningOfSentence: 4,
  MiddleOfSentence: 5
};

(globalThis as any)['Formatter']['UnitStyle'] = (globalThis as any)['Formatter']['UnitStyle'] || {};
(globalThis as any)['Formatter']['UnitStyle'] = {
  Short: 1,
  Medium: 2,
  Long: 3
};


(globalThis as any)['HTTPCookieStorage'] = (globalThis as any)['HTTPCookieStorage'] || {};
(globalThis as any)['HTTPCookieStorage']['HTTPCookie'] = (globalThis as any)['HTTPCookieStorage']['HTTPCookie'] || {};
(globalThis as any)['HTTPCookieStorage']['HTTPCookie']['AcceptPolicy'] = (globalThis as any)['HTTPCookieStorage']['HTTPCookie']['AcceptPolicy'] || {};
(globalThis as any)['HTTPCookieStorage']['HTTPCookie']['AcceptPolicy'] = {
  Always: 0,
  Never: 1,
  OnlyFromMainDocumentDomain: 2
};


(globalThis as any)['IKCameraDeviceView'] = (globalThis as any)['IKCameraDeviceView'] || {};
(globalThis as any)['IKCameraDeviceView']['IKCameraDeviceViewDisplayMode'] = (globalThis as any)['IKCameraDeviceView']['IKCameraDeviceViewDisplayMode'] || {};
(globalThis as any)['IKCameraDeviceView']['IKCameraDeviceViewDisplayMode'] = {
  None: -1,
  Table: 0,
  Icon: 1
};

(globalThis as any)['IKCameraDeviceView']['IKCameraDeviceViewTransferMode'] = (globalThis as any)['IKCameraDeviceView']['IKCameraDeviceViewTransferMode'] || {};
(globalThis as any)['IKCameraDeviceView']['IKCameraDeviceViewTransferMode'] = {
  FileBased: 0,
  MemoryBased: 1
};


(globalThis as any)['IKDeviceBrowserView'] = (globalThis as any)['IKDeviceBrowserView'] || {};
(globalThis as any)['IKDeviceBrowserView']['IKDeviceBrowserViewDisplayMode'] = (globalThis as any)['IKDeviceBrowserView']['IKDeviceBrowserViewDisplayMode'] || {};
(globalThis as any)['IKDeviceBrowserView']['IKDeviceBrowserViewDisplayMode'] = {
  Table: 0,
  Outline: 1,
  Icon: 2
};


(globalThis as any)['IKFilterBrowserPanel'] = (globalThis as any)['IKFilterBrowserPanel'] || {};

(globalThis as any)['IKFilterBrowserView'] = (globalThis as any)['IKFilterBrowserView'] || {};


(globalThis as any)['IKFilterUIView'] = (globalThis as any)['IKFilterUIView'] || {};

(globalThis as any)['IKImageBrowserCell'] = (globalThis as any)['IKImageBrowserCell'] || {};
(globalThis as any)['IKImageBrowserCell']['IKImageBrowserCellState'] = (globalThis as any)['IKImageBrowserCell']['IKImageBrowserCellState'] || {};
(globalThis as any)['IKImageBrowserCell']['IKImageBrowserCellState'] = {
  NoImage: 0,
  Invalid: 1,
  Ready: 2
};


(globalThis as any)['IKImageBrowserView'] = (globalThis as any)['IKImageBrowserView'] || {};
(globalThis as any)['IKImageBrowserView']['IKImageBrowserDropOperation'] = (globalThis as any)['IKImageBrowserView']['IKImageBrowserDropOperation'] || {};
(globalThis as any)['IKImageBrowserView']['IKImageBrowserDropOperation'] = {
  On: 0,
  Before: 1
};


(globalThis as any)['IKImageEditPanel'] = (globalThis as any)['IKImageEditPanel'] || {};

(globalThis as any)['IKImageView'] = (globalThis as any)['IKImageView'] || {};

(globalThis as any)['IKPictureTaker'] = (globalThis as any)['IKPictureTaker'] || {};

(globalThis as any)['IKSaveOptions'] = (globalThis as any)['IKSaveOptions'] || {};

(globalThis as any)['IKScannerDeviceView'] = (globalThis as any)['IKScannerDeviceView'] || {};
(globalThis as any)['IKScannerDeviceView']['IKScannerDeviceViewDisplayMode'] = (globalThis as any)['IKScannerDeviceView']['IKScannerDeviceViewDisplayMode'] || {};
(globalThis as any)['IKScannerDeviceView']['IKScannerDeviceViewDisplayMode'] = {
  None: -1,
  Simple: 0,
  Advanced: 1
};

(globalThis as any)['IKScannerDeviceView']['IKScannerDeviceViewTransferMode'] = (globalThis as any)['IKScannerDeviceView']['IKScannerDeviceViewTransferMode'] || {};
(globalThis as any)['IKScannerDeviceView']['IKScannerDeviceViewTransferMode'] = {
  FileBased: 0,
  MemoryBased: 1
};


(globalThis as any)['IKSlideshow'] = (globalThis as any)['IKSlideshow'] || {};

(globalThis as any)['ISO8601DateFormatter'] = (globalThis as any)['ISO8601DateFormatter'] || {};
(globalThis as any)['ISO8601DateFormatter']['Options'] = (globalThis as any)['ISO8601DateFormatter']['Options'] || {};
(globalThis as any)['ISO8601DateFormatter']['Options'] = {
  WithYear: 1,
  WithMonth: 2,
  WithWeekOfYear: 4,
  WithDay: 16,
  WithTime: 32,
  WithTimeZone: 64,
  WithSpaceBetweenDateAndTime: 128,
  WithDashSeparatorInDate: 256,
  WithColonSeparatorInTime: 512,
  WithColonSeparatorInTimeZone: 1024,
  WithFractionalSeconds: 2048,
  WithFullDate: 275,
  WithFullTime: 1632,
  WithInternetDateTime: 1907
};



(globalThis as any)['JSONSerialization'] = (globalThis as any)['JSONSerialization'] || {};
(globalThis as any)['JSONSerialization']['ReadingOptions'] = (globalThis as any)['JSONSerialization']['ReadingOptions'] || {};
(globalThis as any)['JSONSerialization']['ReadingOptions'] = {
  MutableContainers: 1,
  MutableLeaves: 2,
  FragmentsAllowed: 4,
  AllowFragments: 4
};

(globalThis as any)['JSONSerialization']['WritingOptions'] = (globalThis as any)['JSONSerialization']['WritingOptions'] || {};
(globalThis as any)['JSONSerialization']['WritingOptions'] = {
  PrettyPrinted: 1,
  SortedKeys: 2,
  FragmentsAllowed: 4,
  WithoutEscapingSlashes: 8
};


(globalThis as any)['LengthFormatter'] = (globalThis as any)['LengthFormatter'] || {};
(globalThis as any)['LengthFormatter']['Unit'] = (globalThis as any)['LengthFormatter']['Unit'] || {};
(globalThis as any)['LengthFormatter']['Unit'] = {
  Millimeter: 8,
  Centimeter: 9,
  Meter: 11,
  Kilometer: 14,
  Inch: 1281,
  Foot: 1282,
  Yard: 1283,
  Mile: 1284
};


(globalThis as any)['Locale'] = (globalThis as any)['Locale'] || {};
(globalThis as any)['Locale']['LanguageDirection'] = (globalThis as any)['Locale']['LanguageDirection'] || {};
(globalThis as any)['Locale']['LanguageDirection'] = {
  Unknown: 0,
  LeftToRight: 1,
  RightToLeft: 2,
  TopToBottom: 3,
  BottomToTop: 4
};


(globalThis as any)['MassFormatter'] = (globalThis as any)['MassFormatter'] || {};
(globalThis as any)['MassFormatter']['Unit'] = (globalThis as any)['MassFormatter']['Unit'] || {};
(globalThis as any)['MassFormatter']['Unit'] = {
  Gram: 11,
  Kilogram: 14,
  Ounce: 1537,
  Pound: 1538,
  Stone: 1539
};


(globalThis as any)['MeasurementFormatter'] = (globalThis as any)['MeasurementFormatter'] || {};
(globalThis as any)['MeasurementFormatter']['UnitOptions'] = (globalThis as any)['MeasurementFormatter']['UnitOptions'] || {};
(globalThis as any)['MeasurementFormatter']['UnitOptions'] = {
  ProvidedUnit: 1,
  NaturalScale: 2,
  TemperatureWithoutUnit: 4
};


(globalThis as any)['NSATSTypesetter'] = (globalThis as any)['NSATSTypesetter'] || {};

(globalThis as any)['NSAccessibility'] = (globalThis as any)['NSAccessibility'] || {};
(globalThis as any)['NSAccessibility']['AnnotationPosition'] = (globalThis as any)['NSAccessibility']['AnnotationPosition'] || {};
(globalThis as any)['NSAccessibility']['AnnotationPosition'] = {
  FullRange: 0,
  Start: 1,
  End: 2
};

(globalThis as any)['NSAccessibility']['Orientation'] = (globalThis as any)['NSAccessibility']['Orientation'] || {};
(globalThis as any)['NSAccessibility']['Orientation'] = {
  Unknown: 0,
  Vertical: 1,
  Horizontal: 2
};

(globalThis as any)['NSAccessibility']['RulerMarkerType'] = (globalThis as any)['NSAccessibility']['RulerMarkerType'] || {};
(globalThis as any)['NSAccessibility']['RulerMarkerType'] = {
  Unknown: 0,
  TabStopLeft: 1,
  TabStopRight: 2,
  TabStopCenter: 3,
  TabStopDecimal: 4,
  IndentHead: 5,
  IndentTail: 6,
  IndentFirstLine: 7
};

(globalThis as any)['NSAccessibility']['SortDirection'] = (globalThis as any)['NSAccessibility']['SortDirection'] || {};
(globalThis as any)['NSAccessibility']['SortDirection'] = {
  Unknown: 0,
  Ascending: 1,
  Descending: 2
};

(globalThis as any)['NSAccessibility']['Units'] = (globalThis as any)['NSAccessibility']['Units'] || {};
(globalThis as any)['NSAccessibility']['Units'] = {
  Unknown: 0,
  Inches: 1,
  Centimeters: 2,
  Points: 3,
  Picas: 4
};


(globalThis as any)['NSAccessibilityConstants'] = (globalThis as any)['NSAccessibilityConstants'] || {};
(globalThis as any)['NSAccessibilityConstants']['NSAccessibility'] = (globalThis as any)['NSAccessibilityConstants']['NSAccessibility'] || {};
(globalThis as any)['NSAccessibilityConstants']['NSAccessibility']['AnnotationPosition'] = (globalThis as any)['NSAccessibilityConstants']['NSAccessibility']['AnnotationPosition'] || {};
(globalThis as any)['NSAccessibilityConstants']['NSAccessibility']['AnnotationPosition'] = {
  FullRange: 0,
  Start: 1,
  End: 2
};

(globalThis as any)['NSAccessibilityConstants']['NSAccessibility'] = (globalThis as any)['NSAccessibilityConstants']['NSAccessibility'] || {};
(globalThis as any)['NSAccessibilityConstants']['NSAccessibility']['Orientation'] = (globalThis as any)['NSAccessibilityConstants']['NSAccessibility']['Orientation'] || {};
(globalThis as any)['NSAccessibilityConstants']['NSAccessibility']['Orientation'] = {
  Unknown: 0,
  Vertical: 1,
  Horizontal: 2
};

(globalThis as any)['NSAccessibilityConstants']['NSAccessibility'] = (globalThis as any)['NSAccessibilityConstants']['NSAccessibility'] || {};
(globalThis as any)['NSAccessibilityConstants']['NSAccessibility']['RulerMarkerType'] = (globalThis as any)['NSAccessibilityConstants']['NSAccessibility']['RulerMarkerType'] || {};
(globalThis as any)['NSAccessibilityConstants']['NSAccessibility']['RulerMarkerType'] = {
  Unknown: 0,
  TabStopLeft: 1,
  TabStopRight: 2,
  TabStopCenter: 3,
  TabStopDecimal: 4,
  IndentHead: 5,
  IndentTail: 6,
  IndentFirstLine: 7
};

(globalThis as any)['NSAccessibilityConstants']['NSAccessibility'] = (globalThis as any)['NSAccessibilityConstants']['NSAccessibility'] || {};
(globalThis as any)['NSAccessibilityConstants']['NSAccessibility']['SortDirection'] = (globalThis as any)['NSAccessibilityConstants']['NSAccessibility']['SortDirection'] || {};
(globalThis as any)['NSAccessibilityConstants']['NSAccessibility']['SortDirection'] = {
  Unknown: 0,
  Ascending: 1,
  Descending: 2
};

(globalThis as any)['NSAccessibilityConstants']['NSAccessibility'] = (globalThis as any)['NSAccessibilityConstants']['NSAccessibility'] || {};
(globalThis as any)['NSAccessibilityConstants']['NSAccessibility']['Units'] = (globalThis as any)['NSAccessibilityConstants']['NSAccessibility']['Units'] || {};
(globalThis as any)['NSAccessibilityConstants']['NSAccessibility']['Units'] = {
  Unknown: 0,
  Inches: 1,
  Centimeters: 2,
  Points: 3,
  Picas: 4
};

(globalThis as any)['NSAccessibilityConstants']['NSAccessibilityPriorityLevel'] = (globalThis as any)['NSAccessibilityConstants']['NSAccessibilityPriorityLevel'] || {};
(globalThis as any)['NSAccessibilityConstants']['NSAccessibilityPriorityLevel'] = {
  Low: 10,
  Medium: 50,
  High: 90
};


(globalThis as any)['NSAccessibilityCustomAction'] = (globalThis as any)['NSAccessibilityCustomAction'] || {};

(globalThis as any)['NSAccessibilityCustomRotor'] = (globalThis as any)['NSAccessibilityCustomRotor'] || {};
(globalThis as any)['NSAccessibilityCustomRotor']['RotorType'] = (globalThis as any)['NSAccessibilityCustomRotor']['RotorType'] || {};
(globalThis as any)['NSAccessibilityCustomRotor']['RotorType'] = {
  Custom: 0,
  Any: 1,
  Annotation: 2,
  BoldText: 3,
  Heading: 4,
  HeadingLevel1: 5,
  HeadingLevel2: 6,
  HeadingLevel3: 7,
  HeadingLevel4: 8,
  HeadingLevel5: 9,
  HeadingLevel6: 10,
  Image: 11,
  ItalicText: 12,
  Landmark: 13,
  Link: 14,
  List: 15,
  MisspelledWord: 16,
  Table: 17,
  TextField: 18,
  UnderlinedText: 19,
  VisitedLink: 20
};

(globalThis as any)['NSAccessibilityCustomRotor']['SearchDirection'] = (globalThis as any)['NSAccessibilityCustomRotor']['SearchDirection'] || {};
(globalThis as any)['NSAccessibilityCustomRotor']['SearchDirection'] = {
  Previous: 0,
  Next: 1
};


(globalThis as any)['NSAccessibilityElement'] = (globalThis as any)['NSAccessibilityElement'] || {};

(globalThis as any)['AffineTransform'] = (globalThis as any)['AffineTransform'] || {};

(globalThis as any)['NSAlert'] = (globalThis as any)['NSAlert'] || {};
(globalThis as any)['NSAlert']['Style'] = (globalThis as any)['NSAlert']['Style'] || {};
(globalThis as any)['NSAlert']['Style'] = {
  Warning: 0,
  Informational: 1,
  Critical: 2
};


(globalThis as any)['NSAlignmentFeedbackFilter'] = (globalThis as any)['NSAlignmentFeedbackFilter'] || {};

(globalThis as any)['NSAnimation'] = (globalThis as any)['NSAnimation'] || {};
(globalThis as any)['NSAnimation']['BlockingMode'] = (globalThis as any)['NSAnimation']['BlockingMode'] || {};
(globalThis as any)['NSAnimation']['BlockingMode'] = {
  Blocking: 0,
  Nonblocking: 1,
  NonblockingThreaded: 2
};

(globalThis as any)['NSAnimation']['Curve'] = (globalThis as any)['NSAnimation']['Curve'] || {};
(globalThis as any)['NSAnimation']['Curve'] = {
  EaseInOut: 0,
  EaseIn: 1,
  EaseOut: 2,
  Linear: 3
};


(globalThis as any)['NSAnimationContext'] = (globalThis as any)['NSAnimationContext'] || {};

(globalThis as any)['NSAppearance'] = (globalThis as any)['NSAppearance'] || {};

(globalThis as any)['NSAppleEventDescriptor'] = (globalThis as any)['NSAppleEventDescriptor'] || {};
(globalThis as any)['NSAppleEventDescriptor']['SendOptions'] = (globalThis as any)['NSAppleEventDescriptor']['SendOptions'] || {};
(globalThis as any)['NSAppleEventDescriptor']['SendOptions'] = {
  NoReply: 1,
  QueueReply: 2,
  WaitForReply: 3,
  NeverInteract: 16,
  CanInteract: 32,
  AlwaysInteract: 48,
  CanSwitchLayer: 64,
  DontRecord: 4096,
  DontExecute: 8192,
  DontAnnotate: 65536,
  DefaultOptions: 35
};


(globalThis as any)['NSAppleEventManager'] = (globalThis as any)['NSAppleEventManager'] || {};

(globalThis as any)['NSAppleScript'] = (globalThis as any)['NSAppleScript'] || {};

(globalThis as any)['NSApplication'] = (globalThis as any)['NSApplication'] || {};
(globalThis as any)['NSApplication']['ActivationOptions'] = (globalThis as any)['NSApplication']['ActivationOptions'] || {};
(globalThis as any)['NSApplication']['ActivationOptions'] = {
  AllWindows: 1,
  IgnoringOtherApps: 2
};

(globalThis as any)['NSApplication']['ActivationPolicy'] = (globalThis as any)['NSApplication']['ActivationPolicy'] || {};
(globalThis as any)['NSApplication']['ActivationPolicy'] = {
  Regular: 0,
  Accessory: 1,
  Prohibited: 2
};

(globalThis as any)['NSApplication']['DelegateReply'] = (globalThis as any)['NSApplication']['DelegateReply'] || {};
(globalThis as any)['NSApplication']['DelegateReply'] = {
  Success: 0,
  Cancel: 1,
  Failure: 2
};

(globalThis as any)['NSApplication']['OcclusionState'] = (globalThis as any)['NSApplication']['OcclusionState'] || {};
(globalThis as any)['NSApplication']['OcclusionState'] = {
  NSApplicationOcclusionStateVisible: 2
};

(globalThis as any)['NSApplication']['PresentationOptions'] = (globalThis as any)['NSApplication']['PresentationOptions'] || {};
(globalThis as any)['NSApplication']['PresentationOptions'] = {
  Default: 0,
  AutoHideDock: 1,
  HideDock: 2,
  AutoHideMenuBar: 4,
  HideMenuBar: 8,
  DisableAppleMenu: 16,
  DisableProcessSwitching: 32,
  DisableForceQuit: 64,
  DisableSessionTermination: 128,
  DisableHideApplication: 256,
  DisableMenuBarTransparency: 512,
  FullScreen: 1024,
  AutoHideToolbar: 2048,
  DisableCursorLocationAssistance: 4096
};

(globalThis as any)['NSApplication']['PrintReply'] = (globalThis as any)['NSApplication']['PrintReply'] || {};
(globalThis as any)['NSApplication']['PrintReply'] = {
  Cancelled: 0,
  Success: 1,
  Failure: 3,
  ReplyLater: 2
};

(globalThis as any)['NSApplication']['RemoteNotificationType'] = (globalThis as any)['NSApplication']['RemoteNotificationType'] || {};
(globalThis as any)['NSApplication']['RemoteNotificationType'] = {
  None: 0,
  Badge: 1,
  Sound: 2,
  Alert: 4
};

(globalThis as any)['NSApplication']['RequestUserAttentionType'] = (globalThis as any)['NSApplication']['RequestUserAttentionType'] || {};
(globalThis as any)['NSApplication']['RequestUserAttentionType'] = {
  CriticalRequest: 0,
  InformationalRequest: 10
};

(globalThis as any)['NSApplication']['TerminateReply'] = (globalThis as any)['NSApplication']['TerminateReply'] || {};
(globalThis as any)['NSApplication']['TerminateReply'] = {
  Cancel: 0,
  Now: 1,
  Later: 2
};

(globalThis as any)['NSApplication']['WindowListOptions'] = (globalThis as any)['NSApplication']['WindowListOptions'] || {};
(globalThis as any)['NSApplication']['WindowListOptions'] = {
  NSWindowListOrderedFrontToBack: 1
};


(globalThis as any)['NSArrayController'] = (globalThis as any)['NSArrayController'] || {};

(globalThis as any)['NSAtomicStore'] = (globalThis as any)['NSAtomicStore'] || {};

(globalThis as any)['NSAtomicStoreCacheNode'] = (globalThis as any)['NSAtomicStoreCacheNode'] || {};

(globalThis as any)['NSAttributeDescription'] = (globalThis as any)['NSAttributeDescription'] || {};
(globalThis as any)['NSAttributeDescription']['NSAttributeType'] = (globalThis as any)['NSAttributeDescription']['NSAttributeType'] || {};
(globalThis as any)['NSAttributeDescription']['NSAttributeType'] = {
  UndefinedAttributeType: 0,
  Integer16AttributeType: 100,
  Integer32AttributeType: 200,
  Integer64AttributeType: 300,
  DecimalAttributeType: 400,
  DoubleAttributeType: 500,
  FloatAttributeType: 600,
  StringAttributeType: 700,
  BooleanAttributeType: 800,
  DateAttributeType: 900,
  BinaryDataAttributeType: 1000,
  UUIDAttributeType: 1100,
  URIAttributeType: 1200,
  TransformableAttributeType: 1800,
  ObjectIDAttributeType: 2000
};


(globalThis as any)['NSAttributedString'] = (globalThis as any)['NSAttributedString'] || {};
(globalThis as any)['NSAttributedString']['EnumerationOptions'] = (globalThis as any)['NSAttributedString']['EnumerationOptions'] || {};
(globalThis as any)['NSAttributedString']['EnumerationOptions'] = {
  Reverse: 2,
  LongestEffectiveRangeNotRequired: 1048576
};

(globalThis as any)['NSAttributedString']['NSTextScalingType'] = (globalThis as any)['NSAttributedString']['NSTextScalingType'] || {};
(globalThis as any)['NSAttributedString']['NSTextScalingType'] = {
  Standard: 0,
  iOS: 1
};

(globalThis as any)['NSAttributedString']['NSUnderlineStyle'] = (globalThis as any)['NSAttributedString']['NSUnderlineStyle'] || {};
(globalThis as any)['NSAttributedString']['NSUnderlineStyle'] = {
  None: 0,
  Single: 1,
  Thick: 2,
  Double: 9,
  PatternSolid: 0,
  PatternDot: 256,
  PatternDash: 512,
  PatternDashDot: 768,
  PatternDashDotDot: 1024,
  ByWord: 32768
};

(globalThis as any)['NSAttributedString']['NSWritingDirectionFormatType'] = (globalThis as any)['NSAttributedString']['NSWritingDirectionFormatType'] || {};
(globalThis as any)['NSAttributedString']['NSWritingDirectionFormatType'] = {
  Embedding: 0,
  Override: 2
};

(globalThis as any)['NSAttributedString']['SpellingState'] = (globalThis as any)['NSAttributedString']['SpellingState'] || {};
(globalThis as any)['NSAttributedString']['SpellingState'] = {
  SpellingFlag: 1,
  GrammarFlag: 2
};


(globalThis as any)['NSAutoreleasePool'] = (globalThis as any)['NSAutoreleasePool'] || {};

(globalThis as any)['NSBackgroundActivityScheduler'] = (globalThis as any)['NSBackgroundActivityScheduler'] || {};
(globalThis as any)['NSBackgroundActivityScheduler']['Result'] = (globalThis as any)['NSBackgroundActivityScheduler']['Result'] || {};
(globalThis as any)['NSBackgroundActivityScheduler']['Result'] = {
  Finished: 1,
  Deferred: 2
};


(globalThis as any)['NSBatchDeleteRequest'] = (globalThis as any)['NSBatchDeleteRequest'] || {};

(globalThis as any)['NSBatchInsertRequest'] = (globalThis as any)['NSBatchInsertRequest'] || {};

(globalThis as any)['NSBatchUpdateRequest'] = (globalThis as any)['NSBatchUpdateRequest'] || {};

(globalThis as any)['NSBezierPath'] = (globalThis as any)['NSBezierPath'] || {};
(globalThis as any)['NSBezierPath']['ElementType'] = (globalThis as any)['NSBezierPath']['ElementType'] || {};
(globalThis as any)['NSBezierPath']['ElementType'] = {
  MoveTo: 0,
  LineTo: 1,
  CurveTo: 2,
  ClosePath: 3
};

(globalThis as any)['NSBezierPath']['LineCapStyle'] = (globalThis as any)['NSBezierPath']['LineCapStyle'] || {};
(globalThis as any)['NSBezierPath']['LineCapStyle'] = {
  Butt: 0,
  Round: 1,
  Square: 2
};

(globalThis as any)['NSBezierPath']['LineJoinStyle'] = (globalThis as any)['NSBezierPath']['LineJoinStyle'] || {};
(globalThis as any)['NSBezierPath']['LineJoinStyle'] = {
  Miter: 0,
  Round: 1,
  Bevel: 2
};

(globalThis as any)['NSBezierPath']['WindingRule'] = (globalThis as any)['NSBezierPath']['WindingRule'] || {};
(globalThis as any)['NSBezierPath']['WindingRule'] = {
  NonZero: 0,
  EvenOdd: 1
};


(globalThis as any)['NSBitmapImageRep'] = (globalThis as any)['NSBitmapImageRep'] || {};
(globalThis as any)['NSBitmapImageRep']['FileType'] = (globalThis as any)['NSBitmapImageRep']['FileType'] || {};
(globalThis as any)['NSBitmapImageRep']['FileType'] = {
  TIFF: 0,
  BMP: 1,
  GIF: 2,
  JPEG: 3,
  PNG: 4,
  JPEG2000: 5
};

(globalThis as any)['NSBitmapImageRep']['Format'] = (globalThis as any)['NSBitmapImageRep']['Format'] || {};
(globalThis as any)['NSBitmapImageRep']['Format'] = {
  AlphaFirst: 1,
  AlphaNonpremultiplied: 2,
  FloatingPointSamples: 4,
  SixteenBitLittleEndian: 256,
  ThirtyTwoBitLittleEndian: 512,
  SixteenBitBigEndian: 1024,
  ThirtyTwoBitBigEndian: 2048
};

(globalThis as any)['NSBitmapImageRep']['LoadStatus'] = (globalThis as any)['NSBitmapImageRep']['LoadStatus'] || {};
(globalThis as any)['NSBitmapImageRep']['LoadStatus'] = {
  UnknownType: -1,
  ReadingHeader: -2,
  WillNeedAllData: -3,
  InvalidData: -4,
  UnexpectedEOF: -5,
  Completed: -6
};

(globalThis as any)['NSBitmapImageRep']['TIFFCompression'] = (globalThis as any)['NSBitmapImageRep']['TIFFCompression'] || {};
(globalThis as any)['NSBitmapImageRep']['TIFFCompression'] = {
  None: 1,
  CCITTFAX3: 3,
  CCITTFAX4: 4,
  LZW: 5,
  JPEG: 6,
  NEXT: 32766,
  PackBits: 32773,
  OldJPEG: 32865
};


(globalThis as any)['NSBox'] = (globalThis as any)['NSBox'] || {};
(globalThis as any)['NSBox']['BoxType'] = (globalThis as any)['NSBox']['BoxType'] || {};
(globalThis as any)['NSBox']['BoxType'] = {
  Primary: 0,
  Separator: 2,
  Custom: 4
};

(globalThis as any)['NSBox']['TitlePosition'] = (globalThis as any)['NSBox']['TitlePosition'] || {};
(globalThis as any)['NSBox']['TitlePosition'] = {
  NoTitle: 0,
  AboveTop: 1,
  AtTop: 2,
  BelowTop: 3,
  AboveBottom: 4,
  AtBottom: 5,
  BelowBottom: 6
};


(globalThis as any)['NSBrowser'] = (globalThis as any)['NSBrowser'] || {};
(globalThis as any)['NSBrowser']['ColumnResizingType'] = (globalThis as any)['NSBrowser']['ColumnResizingType'] || {};
(globalThis as any)['NSBrowser']['ColumnResizingType'] = {
  NoColumnResizing: 0,
  AutoColumnResizing: 1,
  UserColumnResizing: 2
};

(globalThis as any)['NSBrowser']['DropOperation'] = (globalThis as any)['NSBrowser']['DropOperation'] || {};
(globalThis as any)['NSBrowser']['DropOperation'] = {
  On: 0,
  Above: 1
};


(globalThis as any)['NSBrowserCell'] = (globalThis as any)['NSBrowserCell'] || {};

(globalThis as any)['Bundle'] = (globalThis as any)['Bundle'] || {};

(globalThis as any)['NSButton'] = (globalThis as any)['NSButton'] || {};
(globalThis as any)['NSButton']['BezelStyle'] = (globalThis as any)['NSButton']['BezelStyle'] || {};
(globalThis as any)['NSButton']['BezelStyle'] = {
  Rounded: 1,
  RegularSquare: 2,
  Disclosure: 5,
  ShadowlessSquare: 6,
  Circular: 7,
  TexturedSquare: 8,
  HelpButton: 9,
  SmallSquare: 10,
  TexturedRounded: 11,
  RoundRect: 12,
  Recessed: 13,
  RoundedDisclosure: 14,
  Inline: 15
};

(globalThis as any)['NSButton']['ButtonType'] = (globalThis as any)['NSButton']['ButtonType'] || {};
(globalThis as any)['NSButton']['ButtonType'] = {
  MomentaryLight: 0,
  PushOnPushOff: 1,
  Toggle: 2,
  Switch: 3,
  Radio: 4,
  MomentaryChange: 5,
  OnOff: 6,
  MomentaryPushIn: 7,
  Accelerator: 8,
  MultiLevelAccelerator: 9
};


(globalThis as any)['NSButtonCell'] = (globalThis as any)['NSButtonCell'] || {};
(globalThis as any)['NSButtonCell']['NSButton'] = (globalThis as any)['NSButtonCell']['NSButton'] || {};
(globalThis as any)['NSButtonCell']['NSButton']['BezelStyle'] = (globalThis as any)['NSButtonCell']['NSButton']['BezelStyle'] || {};
(globalThis as any)['NSButtonCell']['NSButton']['BezelStyle'] = {
  Rounded: 1,
  RegularSquare: 2,
  Disclosure: 5,
  ShadowlessSquare: 6,
  Circular: 7,
  TexturedSquare: 8,
  HelpButton: 9,
  SmallSquare: 10,
  TexturedRounded: 11,
  RoundRect: 12,
  Recessed: 13,
  RoundedDisclosure: 14,
  Inline: 15
};

(globalThis as any)['NSButtonCell']['NSButton'] = (globalThis as any)['NSButtonCell']['NSButton'] || {};
(globalThis as any)['NSButtonCell']['NSButton']['ButtonType'] = (globalThis as any)['NSButtonCell']['NSButton']['ButtonType'] || {};
(globalThis as any)['NSButtonCell']['NSButton']['ButtonType'] = {
  MomentaryLight: 0,
  PushOnPushOff: 1,
  Toggle: 2,
  Switch: 3,
  Radio: 4,
  MomentaryChange: 5,
  OnOff: 6,
  MomentaryPushIn: 7,
  Accelerator: 8,
  MultiLevelAccelerator: 9
};


(globalThis as any)['NSButtonTouchBarItem'] = (globalThis as any)['NSButtonTouchBarItem'] || {};

(globalThis as any)['NSCIImageRep'] = (globalThis as any)['NSCIImageRep'] || {};

(globalThis as any)['NSCache'] = (globalThis as any)['NSCache'] || {};

(globalThis as any)['NSCandidateListTouchBarItem'] = (globalThis as any)['NSCandidateListTouchBarItem'] || {};

(globalThis as any)['NSCell'] = (globalThis as any)['NSCell'] || {};
(globalThis as any)['NSCell']['NSControl'] = (globalThis as any)['NSCell']['NSControl'] || {};
(globalThis as any)['NSCell']['NSControl']['ControlSize'] = (globalThis as any)['NSCell']['NSControl']['ControlSize'] || {};
(globalThis as any)['NSCell']['NSControl']['ControlSize'] = {
  Regular: 0,
  Small: 1,
  Mini: 2
};

(globalThis as any)['NSCell']['NSControl'] = (globalThis as any)['NSCell']['NSControl'] || {};
(globalThis as any)['NSCell']['NSControl']['ImagePosition'] = (globalThis as any)['NSCell']['NSControl']['ImagePosition'] || {};
(globalThis as any)['NSCell']['NSControl']['ImagePosition'] = {
  NoImage: 0,
  ImageOnly: 1,
  ImageLeft: 2,
  ImageRight: 3,
  ImageBelow: 4,
  ImageAbove: 5,
  ImageOverlaps: 6,
  ImageLeading: 7,
  ImageTrailing: 8
};

(globalThis as any)['NSCell']['NSView'] = (globalThis as any)['NSCell']['NSView'] || {};
(globalThis as any)['NSCell']['NSView']['BackgroundStyle'] = (globalThis as any)['NSCell']['NSView']['BackgroundStyle'] || {};
(globalThis as any)['NSCell']['NSView']['BackgroundStyle'] = {
  Normal: 0,
  Emphasized: 1,
  Raised: 2,
  Lowered: 3
};

(globalThis as any)['NSCell']['Attribute'] = (globalThis as any)['NSCell']['Attribute'] || {};
(globalThis as any)['NSCell']['Attribute'] = {
  CellDisabled: 0,
  CellState: 1,
  PushInCell: 2,
  CellEditable: 3,
  ChangeGrayCell: 4,
  CellHighlighted: 5,
  CellLightsByContents: 6,
  CellLightsByGray: 7,
  ChangeBackgroundCell: 8,
  CellLightsByBackground: 9,
  CellIsBordered: 10,
  CellHasOverlappingImage: 11,
  CellHasImageHorizontal: 12,
  CellHasImageOnLeftOrBottom: 13,
  CellChangesContents: 14,
  CellIsInsetButton: 15,
  CellAllowsMixedState: 16
};

(globalThis as any)['NSCell']['CellType'] = (globalThis as any)['NSCell']['CellType'] || {};
(globalThis as any)['NSCell']['CellType'] = {
  NullCellType: 0,
  TextCellType: 1,
  ImageCellType: 2
};

(globalThis as any)['NSCell']['HitResult'] = (globalThis as any)['NSCell']['HitResult'] || {};
(globalThis as any)['NSCell']['HitResult'] = {
  None: 0,
  ContentArea: 1,
  EditableTextArea: 2,
  TrackableArea: 4
};

(globalThis as any)['NSCell']['NSControlTint'] = (globalThis as any)['NSCell']['NSControlTint'] || {};
(globalThis as any)['NSCell']['NSControlTint'] = {
  DefaultControlTint: 0,
  BlueControlTint: 1,
  GraphiteControlTint: 6,
  ClearControlTint: 7
};

(globalThis as any)['NSCell']['NSImageScaling'] = (globalThis as any)['NSCell']['NSImageScaling'] || {};
(globalThis as any)['NSCell']['NSImageScaling'] = {
  ImageScaleProportionallyDown: 0,
  ImageScaleAxesIndependently: 1,
  ImageScaleNone: 2,
  ImageScaleProportionallyUpOrDown: 3,
  ScaleProportionally: 0,
  ScaleToFit: 1,
  ScaleNone: 2
};

(globalThis as any)['NSCell']['StyleMask'] = (globalThis as any)['NSCell']['StyleMask'] || {};
(globalThis as any)['NSCell']['StyleMask'] = {
  NoCellMask: 0,
  ContentsCellMask: 1,
  PushInCellMask: 2,
  ChangeGrayCellMask: 4,
  ChangeBackgroundCellMask: 8
};


(globalThis as any)['CharacterSet'] = (globalThis as any)['CharacterSet'] || {};

(globalThis as any)['NSClassDescription'] = (globalThis as any)['NSClassDescription'] || {};

(globalThis as any)['NSClickGestureRecognizer'] = (globalThis as any)['NSClickGestureRecognizer'] || {};

(globalThis as any)['NSClipView'] = (globalThis as any)['NSClipView'] || {};

(globalThis as any)['NSCoder'] = (globalThis as any)['NSCoder'] || {};
(globalThis as any)['NSCoder']['DecodingFailurePolicy'] = (globalThis as any)['NSCoder']['DecodingFailurePolicy'] || {};
(globalThis as any)['NSCoder']['DecodingFailurePolicy'] = {
  RaiseException: 0,
  SetErrorAndReturn: 1
};


(globalThis as any)['NSCollectionView'] = (globalThis as any)['NSCollectionView'] || {};
(globalThis as any)['NSCollectionView']['NSCollectionViewItem'] = (globalThis as any)['NSCollectionView']['NSCollectionViewItem'] || {};
(globalThis as any)['NSCollectionView']['NSCollectionViewItem']['HighlightState'] = (globalThis as any)['NSCollectionView']['NSCollectionViewItem']['HighlightState'] || {};
(globalThis as any)['NSCollectionView']['NSCollectionViewItem']['HighlightState'] = {
  None: 0,
  ForSelection: 1,
  ForDeselection: 2,
  AsDropTarget: 3
};

(globalThis as any)['NSCollectionView']['DropOperation'] = (globalThis as any)['NSCollectionView']['DropOperation'] || {};
(globalThis as any)['NSCollectionView']['DropOperation'] = {
  On: 0,
  Before: 1
};

(globalThis as any)['NSCollectionView']['ScrollDirection'] = (globalThis as any)['NSCollectionView']['ScrollDirection'] || {};
(globalThis as any)['NSCollectionView']['ScrollDirection'] = {
  Vertical: 0,
  Horizontal: 1
};

(globalThis as any)['NSCollectionView']['ScrollPosition'] = (globalThis as any)['NSCollectionView']['ScrollPosition'] || {};
(globalThis as any)['NSCollectionView']['ScrollPosition'] = {
  None: 0,
  Top: 1,
  CenteredVertically: 2,
  Bottom: 4,
  NearestHorizontalEdge: 512,
  Left: 8,
  CenteredHorizontally: 16,
  Right: 32,
  LeadingEdge: 64,
  TrailingEdge: 128,
  NearestVerticalEdge: 256
};

(globalThis as any)['NSCollectionView']['UpdateAction'] = (globalThis as any)['NSCollectionView']['UpdateAction'] || {};
(globalThis as any)['NSCollectionView']['UpdateAction'] = {
  Insert: 0,
  Delete: 1,
  Reload: 2,
  Move: 3,
  None: 4
};


(globalThis as any)['NSCollectionViewCompositionalLayout'] = (globalThis as any)['NSCollectionViewCompositionalLayout'] || {};
(globalThis as any)['NSCollectionViewCompositionalLayout']['NSCollectionLayoutSectionOrthogonalScrollingBehavior'] = (globalThis as any)['NSCollectionViewCompositionalLayout']['NSCollectionLayoutSectionOrthogonalScrollingBehavior'] || {};
(globalThis as any)['NSCollectionViewCompositionalLayout']['NSCollectionLayoutSectionOrthogonalScrollingBehavior'] = {
  None: 0,
  Continuous: 1,
  ContinuousGroupLeadingBoundary: 2,
  Paging: 3,
  GroupPaging: 4,
  GroupPagingCentered: 5
};

(globalThis as any)['NSCollectionViewCompositionalLayout']['NSDirectionalRectEdge'] = (globalThis as any)['NSCollectionViewCompositionalLayout']['NSDirectionalRectEdge'] || {};
(globalThis as any)['NSCollectionViewCompositionalLayout']['NSDirectionalRectEdge'] = {
  None: 0,
  Top: 1,
  Leading: 2,
  Bottom: 4,
  Trailing: 8,
  All: 15
};

(globalThis as any)['NSCollectionViewCompositionalLayout']['NSRectAlignment'] = (globalThis as any)['NSCollectionViewCompositionalLayout']['NSRectAlignment'] || {};
(globalThis as any)['NSCollectionViewCompositionalLayout']['NSRectAlignment'] = {
  None: 0,
  Top: 1,
  TopLeading: 2,
  Leading: 3,
  BottomLeading: 4,
  Bottom: 5,
  BottomTrailing: 6,
  Trailing: 7,
  TopTrailing: 8
};


(globalThis as any)['NSCollectionViewFlowLayout'] = (globalThis as any)['NSCollectionViewFlowLayout'] || {};
(globalThis as any)['NSCollectionViewFlowLayout']['NSCollectionView'] = (globalThis as any)['NSCollectionViewFlowLayout']['NSCollectionView'] || {};
(globalThis as any)['NSCollectionViewFlowLayout']['NSCollectionView']['DropOperation'] = (globalThis as any)['NSCollectionViewFlowLayout']['NSCollectionView']['DropOperation'] || {};
(globalThis as any)['NSCollectionViewFlowLayout']['NSCollectionView']['DropOperation'] = {
  On: 0,
  Before: 1
};

(globalThis as any)['NSCollectionViewFlowLayout']['NSCollectionView'] = (globalThis as any)['NSCollectionViewFlowLayout']['NSCollectionView'] || {};
(globalThis as any)['NSCollectionViewFlowLayout']['NSCollectionView']['ScrollDirection'] = (globalThis as any)['NSCollectionViewFlowLayout']['NSCollectionView']['ScrollDirection'] || {};
(globalThis as any)['NSCollectionViewFlowLayout']['NSCollectionView']['ScrollDirection'] = {
  Vertical: 0,
  Horizontal: 1
};

(globalThis as any)['NSCollectionViewFlowLayout']['NSCollectionView'] = (globalThis as any)['NSCollectionViewFlowLayout']['NSCollectionView'] || {};
(globalThis as any)['NSCollectionViewFlowLayout']['NSCollectionView']['ScrollPosition'] = (globalThis as any)['NSCollectionViewFlowLayout']['NSCollectionView']['ScrollPosition'] || {};
(globalThis as any)['NSCollectionViewFlowLayout']['NSCollectionView']['ScrollPosition'] = {
  None: 0,
  Top: 1,
  CenteredVertically: 2,
  Bottom: 4,
  NearestHorizontalEdge: 512,
  Left: 8,
  CenteredHorizontally: 16,
  Right: 32,
  LeadingEdge: 64,
  TrailingEdge: 128,
  NearestVerticalEdge: 256
};

(globalThis as any)['NSCollectionViewFlowLayout']['NSCollectionView'] = (globalThis as any)['NSCollectionViewFlowLayout']['NSCollectionView'] || {};
(globalThis as any)['NSCollectionViewFlowLayout']['NSCollectionView']['UpdateAction'] = (globalThis as any)['NSCollectionViewFlowLayout']['NSCollectionView']['UpdateAction'] || {};
(globalThis as any)['NSCollectionViewFlowLayout']['NSCollectionView']['UpdateAction'] = {
  Insert: 0,
  Delete: 1,
  Reload: 2,
  Move: 3,
  None: 4
};


(globalThis as any)['NSCollectionViewGridLayout'] = (globalThis as any)['NSCollectionViewGridLayout'] || {};

(globalThis as any)['NSCollectionViewLayout'] = (globalThis as any)['NSCollectionViewLayout'] || {};
(globalThis as any)['NSCollectionViewLayout']['NSCollectionView'] = (globalThis as any)['NSCollectionViewLayout']['NSCollectionView'] || {};
(globalThis as any)['NSCollectionViewLayout']['NSCollectionView']['UpdateAction'] = (globalThis as any)['NSCollectionViewLayout']['NSCollectionView']['UpdateAction'] || {};
(globalThis as any)['NSCollectionViewLayout']['NSCollectionView']['UpdateAction'] = {
  Insert: 0,
  Delete: 1,
  Reload: 2,
  Move: 3,
  None: 4
};

(globalThis as any)['NSCollectionViewLayout']['NSCollectionElementCategory'] = (globalThis as any)['NSCollectionViewLayout']['NSCollectionElementCategory'] || {};
(globalThis as any)['NSCollectionViewLayout']['NSCollectionElementCategory'] = {
  Item: 0,
  SupplementaryView: 1,
  DecorationView: 2,
  InterItemGap: 3
};


(globalThis as any)['NSCollectionViewTransitionLayout'] = (globalThis as any)['NSCollectionViewTransitionLayout'] || {};

(globalThis as any)['NSColor'] = (globalThis as any)['NSColor'] || {};
(globalThis as any)['NSColor']['ColorType'] = (globalThis as any)['NSColor']['ColorType'] || {};
(globalThis as any)['NSColor']['ColorType'] = {
  ComponentBased: 0,
  Pattern: 1,
  Catalog: 2
};

(globalThis as any)['NSColor']['SystemEffect'] = (globalThis as any)['NSColor']['SystemEffect'] || {};
(globalThis as any)['NSColor']['SystemEffect'] = {
  None: 0,
  Pressed: 1,
  DeepPressed: 2,
  Disabled: 3,
  Rollover: 4
};


(globalThis as any)['NSColorList'] = (globalThis as any)['NSColorList'] || {};

(globalThis as any)['NSColorPanel'] = (globalThis as any)['NSColorPanel'] || {};
(globalThis as any)['NSColorPanel']['Mode'] = (globalThis as any)['NSColorPanel']['Mode'] || {};
(globalThis as any)['NSColorPanel']['Mode'] = {
  None: -1,
  Gray: 0,
  RGB: 1,
  CMYK: 2,
  HSB: 3,
  CustomPalette: 4,
  ColorList: 5,
  Wheel: 6,
  Crayon: 7
};

(globalThis as any)['NSColorPanel']['Options'] = (globalThis as any)['NSColorPanel']['Options'] || {};
(globalThis as any)['NSColorPanel']['Options'] = {
  GrayModeMask: 1,
  RGBModeMask: 2,
  CMYKModeMask: 4,
  HSBModeMask: 8,
  CustomPaletteModeMask: 16,
  ColorListModeMask: 32,
  WheelModeMask: 64,
  CrayonModeMask: 128,
  AllModesMask: 65535
};


(globalThis as any)['NSColorPicker'] = (globalThis as any)['NSColorPicker'] || {};

(globalThis as any)['NSColorPickerTouchBarItem'] = (globalThis as any)['NSColorPickerTouchBarItem'] || {};

(globalThis as any)['NSColorSampler'] = (globalThis as any)['NSColorSampler'] || {};

(globalThis as any)['NSColorSpace'] = (globalThis as any)['NSColorSpace'] || {};
(globalThis as any)['NSColorSpace']['Model'] = (globalThis as any)['NSColorSpace']['Model'] || {};
(globalThis as any)['NSColorSpace']['Model'] = {
  Unknown: -1,
  Gray: 0,
  RGB: 1,
  CMYK: 2,
  LAB: 3,
  DeviceN: 4,
  Indexed: 5,
  Patterned: 6
};


(globalThis as any)['NSColorWell'] = (globalThis as any)['NSColorWell'] || {};

(globalThis as any)['NSComboBox'] = (globalThis as any)['NSComboBox'] || {};

(globalThis as any)['NSComboBoxCell'] = (globalThis as any)['NSComboBoxCell'] || {};

(globalThis as any)['NSComparisonPredicate'] = (globalThis as any)['NSComparisonPredicate'] || {};
(globalThis as any)['NSComparisonPredicate']['Modifier'] = (globalThis as any)['NSComparisonPredicate']['Modifier'] || {};
(globalThis as any)['NSComparisonPredicate']['Modifier'] = {
  DirectPredicateModifier: 0,
  AllPredicateModifier: 1,
  AnyPredicateModifier: 2
};

(globalThis as any)['NSComparisonPredicate']['Operator'] = (globalThis as any)['NSComparisonPredicate']['Operator'] || {};
(globalThis as any)['NSComparisonPredicate']['Operator'] = {
  LessThanPredicateOperatorType: 0,
  LessThanOrEqualToPredicateOperatorType: 1,
  GreaterThanPredicateOperatorType: 2,
  GreaterThanOrEqualToPredicateOperatorType: 3,
  EqualToPredicateOperatorType: 4,
  NotEqualToPredicateOperatorType: 5,
  MatchesPredicateOperatorType: 6,
  LikePredicateOperatorType: 7,
  BeginsWithPredicateOperatorType: 8,
  EndsWithPredicateOperatorType: 9,
  InPredicateOperatorType: 10,
  CustomSelectorPredicateOperatorType: 11,
  ContainsPredicateOperatorType: 99,
  BetweenPredicateOperatorType: 100
};

(globalThis as any)['NSComparisonPredicate']['Options'] = (globalThis as any)['NSComparisonPredicate']['Options'] || {};
(globalThis as any)['NSComparisonPredicate']['Options'] = {
  CaseInsensitivePredicateOption: 1,
  DiacriticInsensitivePredicateOption: 2,
  NormalizedPredicateOption: 4
};


(globalThis as any)['NSCompoundPredicate'] = (globalThis as any)['NSCompoundPredicate'] || {};
(globalThis as any)['NSCompoundPredicate']['LogicalType'] = (globalThis as any)['NSCompoundPredicate']['LogicalType'] || {};
(globalThis as any)['NSCompoundPredicate']['LogicalType'] = {
  NotPredicateType: 0,
  AndPredicateType: 1,
  OrPredicateType: 2
};


(globalThis as any)['NSConnection'] = (globalThis as any)['NSConnection'] || {};

(globalThis as any)['NSControl'] = (globalThis as any)['NSControl'] || {};
(globalThis as any)['NSControl']['ControlSize'] = (globalThis as any)['NSControl']['ControlSize'] || {};
(globalThis as any)['NSControl']['ControlSize'] = {
  Regular: 0,
  Small: 1,
  Mini: 2
};

(globalThis as any)['NSControl']['ImagePosition'] = (globalThis as any)['NSControl']['ImagePosition'] || {};
(globalThis as any)['NSControl']['ImagePosition'] = {
  NoImage: 0,
  ImageOnly: 1,
  ImageLeft: 2,
  ImageRight: 3,
  ImageBelow: 4,
  ImageAbove: 5,
  ImageOverlaps: 6,
  ImageLeading: 7,
  ImageTrailing: 8
};


(globalThis as any)['NSController'] = (globalThis as any)['NSController'] || {};

(globalThis as any)['NSCoreDataCoreSpotlightDelegate'] = (globalThis as any)['NSCoreDataCoreSpotlightDelegate'] || {};

(globalThis as any)['NSCursor'] = (globalThis as any)['NSCursor'] || {};

(globalThis as any)['NSCustomImageRep'] = (globalThis as any)['NSCustomImageRep'] || {};

(globalThis as any)['NSCustomTouchBarItem'] = (globalThis as any)['NSCustomTouchBarItem'] || {};

(globalThis as any)['NSDataAsset'] = (globalThis as any)['NSDataAsset'] || {};

(globalThis as any)['Date'] = (globalThis as any)['Date'] || {};

(globalThis as any)['DateInterval'] = (globalThis as any)['DateInterval'] || {};

(globalThis as any)['NSDatePicker'] = (globalThis as any)['NSDatePicker'] || {};
(globalThis as any)['NSDatePicker']['ElementFlags'] = (globalThis as any)['NSDatePicker']['ElementFlags'] || {};
(globalThis as any)['NSDatePicker']['ElementFlags'] = {
  HourMinute: 12,
  HourMinuteSecond: 14,
  TimeZone: 16,
  YearMonth: 192,
  YearMonthDay: 224,
  Era: 256
};

(globalThis as any)['NSDatePicker']['Mode'] = (globalThis as any)['NSDatePicker']['Mode'] || {};
(globalThis as any)['NSDatePicker']['Mode'] = {
  Single: 0,
  Range: 1
};

(globalThis as any)['NSDatePicker']['Style'] = (globalThis as any)['NSDatePicker']['Style'] || {};
(globalThis as any)['NSDatePicker']['Style'] = {
  TextFieldAndStepper: 0,
  ClockAndCalendar: 1,
  TextField: 2
};


(globalThis as any)['NSDatePickerCell'] = (globalThis as any)['NSDatePickerCell'] || {};
(globalThis as any)['NSDatePickerCell']['NSDatePicker'] = (globalThis as any)['NSDatePickerCell']['NSDatePicker'] || {};
(globalThis as any)['NSDatePickerCell']['NSDatePicker']['ElementFlags'] = (globalThis as any)['NSDatePickerCell']['NSDatePicker']['ElementFlags'] || {};
(globalThis as any)['NSDatePickerCell']['NSDatePicker']['ElementFlags'] = {
  HourMinute: 12,
  HourMinuteSecond: 14,
  TimeZone: 16,
  YearMonth: 192,
  YearMonthDay: 224,
  Era: 256
};

(globalThis as any)['NSDatePickerCell']['NSDatePicker'] = (globalThis as any)['NSDatePickerCell']['NSDatePicker'] || {};
(globalThis as any)['NSDatePickerCell']['NSDatePicker']['Mode'] = (globalThis as any)['NSDatePickerCell']['NSDatePicker']['Mode'] || {};
(globalThis as any)['NSDatePickerCell']['NSDatePicker']['Mode'] = {
  Single: 0,
  Range: 1
};

(globalThis as any)['NSDatePickerCell']['NSDatePicker'] = (globalThis as any)['NSDatePickerCell']['NSDatePicker'] || {};
(globalThis as any)['NSDatePickerCell']['NSDatePicker']['Style'] = (globalThis as any)['NSDatePickerCell']['NSDatePicker']['Style'] || {};
(globalThis as any)['NSDatePickerCell']['NSDatePicker']['Style'] = {
  TextFieldAndStepper: 0,
  ClockAndCalendar: 1,
  TextField: 2
};



(globalThis as any)['NSDerivedAttributeDescription'] = (globalThis as any)['NSDerivedAttributeDescription'] || {};

(globalThis as any)['Dictionary'] = (globalThis as any)['Dictionary'] || {};

(globalThis as any)['NSDictionaryController'] = (globalThis as any)['NSDictionaryController'] || {};

(globalThis as any)['NSDistantObject'] = (globalThis as any)['NSDistantObject'] || {};

(globalThis as any)['NSDistributedLock'] = (globalThis as any)['NSDistributedLock'] || {};

(globalThis as any)['NSDockTile'] = (globalThis as any)['NSDockTile'] || {};

(globalThis as any)['NSDocument'] = (globalThis as any)['NSDocument'] || {};
(globalThis as any)['NSDocument']['ChangeType'] = (globalThis as any)['NSDocument']['ChangeType'] || {};
(globalThis as any)['NSDocument']['ChangeType'] = {
  Done: 0,
  Undone: 1,
  Redone: 5,
  Cleared: 2,
  ReadOtherContents: 3,
  Autosaved: 4,
  Discardable: 256
};

(globalThis as any)['NSDocument']['SaveOperationType'] = (globalThis as any)['NSDocument']['SaveOperationType'] || {};
(globalThis as any)['NSDocument']['SaveOperationType'] = {
  SaveOperation: 0,
  SaveAsOperation: 1,
  SaveToOperation: 2,
  AutosaveInPlaceOperation: 4,
  AutosaveElsewhereOperation: 3,
  AutosaveAsOperation: 5,
  AutosaveOperation: 3
};


(globalThis as any)['NSDocumentController'] = (globalThis as any)['NSDocumentController'] || {};

(globalThis as any)['NSDragging'] = (globalThis as any)['NSDragging'] || {};
(globalThis as any)['NSDragging']['NSDragOperation'] = (globalThis as any)['NSDragging']['NSDragOperation'] || {};
(globalThis as any)['NSDragging']['NSDragOperation'] = {
  None: 0,
  Copy: 1,
  Link: 2,
  Generic: 4,
  Private: 8,
  Move: 16,
  Delete: 32,
  Every: -1,
  All_Obsolete: 15,
  All: 15
};

(globalThis as any)['NSDragging']['NSDraggingContext'] = (globalThis as any)['NSDragging']['NSDraggingContext'] || {};
(globalThis as any)['NSDragging']['NSDraggingContext'] = {
  OutsideApplication: 0,
  WithinApplication: 1
};

(globalThis as any)['NSDragging']['NSDraggingFormation'] = (globalThis as any)['NSDragging']['NSDraggingFormation'] || {};
(globalThis as any)['NSDragging']['NSDraggingFormation'] = {
  Default: 0,
  None: 1,
  Pile: 2,
  List: 3,
  Stack: 4
};

(globalThis as any)['NSDragging']['NSDraggingItemEnumerationOptions'] = (globalThis as any)['NSDragging']['NSDraggingItemEnumerationOptions'] || {};
(globalThis as any)['NSDragging']['NSDraggingItemEnumerationOptions'] = {
  oncurrent: 1,
  learNonenumeratedImages: 65536
};

(globalThis as any)['NSDragging']['NSSpringLoadingHighlight'] = (globalThis as any)['NSDragging']['NSSpringLoadingHighlight'] || {};
(globalThis as any)['NSDragging']['NSSpringLoadingHighlight'] = {
  None: 0,
  Standard: 1,
  Emphasized: 2
};

(globalThis as any)['NSDragging']['NSSpringLoadingOptions'] = (globalThis as any)['NSDragging']['NSSpringLoadingOptions'] || {};
(globalThis as any)['NSDragging']['NSSpringLoadingOptions'] = {
  Disabled: 0,
  Enabled: 1,
  ContinuousActivation: 2,
  NoHover: 8
};


(globalThis as any)['NSDraggingItem'] = (globalThis as any)['NSDraggingItem'] || {};

(globalThis as any)['NSDraggingSession'] = (globalThis as any)['NSDraggingSession'] || {};

(globalThis as any)['NSDrawer'] = (globalThis as any)['NSDrawer'] || {};
(globalThis as any)['NSDrawer']['State'] = (globalThis as any)['NSDrawer']['State'] || {};
(globalThis as any)['NSDrawer']['State'] = {
  ClosedState: 0,
  OpeningState: 1,
  OpenState: 2,
  ClosingState: 3
};


(globalThis as any)['NSEPSImageRep'] = (globalThis as any)['NSEPSImageRep'] || {};

(globalThis as any)['NSEntityDescription'] = (globalThis as any)['NSEntityDescription'] || {};

(globalThis as any)['NSEntityMapping'] = (globalThis as any)['NSEntityMapping'] || {};
(globalThis as any)['NSEntityMapping']['NSEntityMappingType'] = (globalThis as any)['NSEntityMapping']['NSEntityMappingType'] || {};
(globalThis as any)['NSEntityMapping']['NSEntityMappingType'] = {
  UndefinedEntityMappingType: 0,
  CustomEntityMappingType: 1,
  AddEntityMappingType: 2,
  RemoveEntityMappingType: 3,
  CopyEntityMappingType: 4,
  TransformEntityMappingType: 5
};


(globalThis as any)['NSEntityMigrationPolicy'] = (globalThis as any)['NSEntityMigrationPolicy'] || {};

(globalThis as any)['NSEnumerator'] = (globalThis as any)['NSEnumerator'] || {};

(globalThis as any)['Error'] = (globalThis as any)['Error'] || {};


(globalThis as any)['NSEvent'] = (globalThis as any)['NSEvent'] || {};
(globalThis as any)['NSEvent']['ButtonMask'] = (globalThis as any)['NSEvent']['ButtonMask'] || {};
(globalThis as any)['NSEvent']['ButtonMask'] = {
  Tip: 1,
  LowerSide: 2,
  UpperSide: 4
};

(globalThis as any)['NSEvent']['EventSubtype'] = (globalThis as any)['NSEvent']['EventSubtype'] || {};
(globalThis as any)['NSEvent']['EventSubtype'] = {
  WindowExposed: 0,
  ApplicationActivated: 1,
  ApplicationDeactivated: 2,
  WindowMoved: 4,
  ScreenChanged: 8,
  PowerOff: 1,
  MouseEvent: 0,
  TabletPoint: 1,
  TabletProximity: 2,
  Touch: 3
};

(globalThis as any)['NSEvent']['EventType'] = (globalThis as any)['NSEvent']['EventType'] || {};
(globalThis as any)['NSEvent']['EventType'] = {
  LeftMouseDown: 1,
  LeftMouseUp: 2,
  RightMouseDown: 3,
  RightMouseUp: 4,
  MouseMoved: 5,
  LeftMouseDragged: 6,
  RightMouseDragged: 7,
  MouseEntered: 8,
  MouseExited: 9,
  KeyDown: 10,
  KeyUp: 11,
  FlagsChanged: 12,
  AppKitDefined: 13,
  SystemDefined: 14,
  ApplicationDefined: 15,
  Periodic: 16,
  CursorUpdate: 17,
  ScrollWheel: 22,
  TabletPoint: 23,
  TabletProximity: 24,
  OtherMouseDown: 25,
  OtherMouseUp: 26,
  OtherMouseDragged: 27,
  Gesture: 29,
  Magnify: 30,
  Swipe: 31,
  Rotate: 18,
  BeginGesture: 19,
  EndGesture: 20,
  SmartMagnify: 32,
  QuickLook: 33,
  Pressure: 34,
  DirectTouch: 37,
  ChangeMode: 38
};

(globalThis as any)['NSEvent']['EventTypeMask'] = (globalThis as any)['NSEvent']['EventTypeMask'] || {};
(globalThis as any)['NSEvent']['EventTypeMask'] = {
  LeftMouseDown: 2,
  LeftMouseUp: 4,
  RightMouseDown: 8,
  RightMouseUp: 16,
  MouseMoved: 32,
  LeftMouseDragged: 64,
  RightMouseDragged: 128,
  MouseEntered: 256,
  MouseExited: 512,
  KeyDown: 1024,
  KeyUp: 2048,
  FlagsChanged: 4096,
  AppKitDefined: 8192,
  SystemDefined: 16384,
  ApplicationDefined: 32768,
  Periodic: 65536,
  CursorUpdate: 131072,
  ScrollWheel: 4194304,
  TabletPoint: 8388608,
  TabletProximity: 16777216,
  OtherMouseDown: 33554432,
  OtherMouseUp: 67108864,
  OtherMouseDragged: 134217728,
  Gesture: 536870912,
  Magnify: 1073741824,
  Swipe: 2147483648,
  Rotate: 262144,
  BeginGesture: 524288,
  EndGesture: 1048576,
  SmartMagnify: 4294967296,
  Pressure: 17179869184,
  DirectTouch: 137438953472,
  ChangeMode: 274877906944,
  Any: -1
};

(globalThis as any)['NSEvent']['GestureAxis'] = (globalThis as any)['NSEvent']['GestureAxis'] || {};
(globalThis as any)['NSEvent']['GestureAxis'] = {
  None: 0,
  Horizontal: 1,
  Vertical: 2
};

(globalThis as any)['NSEvent']['ModifierFlags'] = (globalThis as any)['NSEvent']['ModifierFlags'] || {};
(globalThis as any)['NSEvent']['ModifierFlags'] = {
  CapsLock: 65536,
  Shift: 131072,
  Control: 262144,
  Option: 524288,
  Command: 1048576,
  NumericPad: 2097152,
  Help: 4194304,
  Function: 8388608,
  DeviceIndependentFlagsMask: 4294901760
};

(globalThis as any)['NSEvent']['Phase'] = (globalThis as any)['NSEvent']['Phase'] || {};
(globalThis as any)['NSEvent']['Phase'] = {
  None: 0,
  Began: 1,
  Stationary: 2,
  Changed: 4,
  Ended: 8,
  Cancelled: 16,
  MayBegin: 32
};

(globalThis as any)['NSEvent']['PointingDeviceType'] = (globalThis as any)['NSEvent']['PointingDeviceType'] || {};
(globalThis as any)['NSEvent']['PointingDeviceType'] = {
  Unknown: 0,
  Pen: 1,
  Cursor: 2,
  Eraser: 3
};

(globalThis as any)['NSEvent']['PressureBehavior'] = (globalThis as any)['NSEvent']['PressureBehavior'] || {};
(globalThis as any)['NSEvent']['PressureBehavior'] = {
  Unknown: -1,
  PrimaryDefault: 0,
  PrimaryClick: 1,
  PrimaryGeneric: 2,
  PrimaryAccelerator: 3,
  PrimaryDeepClick: 5,
  PrimaryDeepDrag: 6
};

(globalThis as any)['NSEvent']['SwipeTrackingOptions'] = (globalThis as any)['NSEvent']['SwipeTrackingOptions'] || {};
(globalThis as any)['NSEvent']['SwipeTrackingOptions'] = {
  LockDirection: 1,
  ClampGestureAmount: 2
};


(globalThis as any)['NSException'] = (globalThis as any)['NSException'] || {};

(globalThis as any)['NSExpression'] = (globalThis as any)['NSExpression'] || {};
(globalThis as any)['NSExpression']['ExpressionType'] = (globalThis as any)['NSExpression']['ExpressionType'] || {};
(globalThis as any)['NSExpression']['ExpressionType'] = {
  ConstantValueExpressionType: 0,
  EvaluatedObjectExpressionType: 1,
  VariableExpressionType: 2,
  KeyPathExpressionType: 3,
  FunctionExpressionType: 4,
  UnionSetExpressionType: 5,
  IntersectSetExpressionType: 6,
  MinusSetExpressionType: 7,
  SubqueryExpressionType: 13,
  AggregateExpressionType: 14,
  AnyKeyExpressionType: 15,
  BlockExpressionType: 19,
  ConditionalExpressionType: 20
};


(globalThis as any)['NSExpressionDescription'] = (globalThis as any)['NSExpressionDescription'] || {};

(globalThis as any)['NSExtensionContext'] = (globalThis as any)['NSExtensionContext'] || {};

(globalThis as any)['NSExtensionItem'] = (globalThis as any)['NSExtensionItem'] || {};

(globalThis as any)['NSExtensionRequestHandling'] = (globalThis as any)['NSExtensionRequestHandling'] || {};

(globalThis as any)['NSFetchIndexDescription'] = (globalThis as any)['NSFetchIndexDescription'] || {};

(globalThis as any)['NSFetchIndexElementDescription'] = (globalThis as any)['NSFetchIndexElementDescription'] || {};
(globalThis as any)['NSFetchIndexElementDescription']['NSFetchIndexElementType'] = (globalThis as any)['NSFetchIndexElementDescription']['NSFetchIndexElementType'] || {};
(globalThis as any)['NSFetchIndexElementDescription']['NSFetchIndexElementType'] = {
  Binary: 0,
  RTree: 1
};


(globalThis as any)['NSFetchRequest'] = (globalThis as any)['NSFetchRequest'] || {};
(globalThis as any)['NSFetchRequest']['NSFetchRequestResultType'] = (globalThis as any)['NSFetchRequest']['NSFetchRequestResultType'] || {};
(globalThis as any)['NSFetchRequest']['NSFetchRequestResultType'] = {
  ManagedObjectResultType: 0,
  ManagedObjectIDResultType: 1,
  DictionaryResultType: 2,
  CountResultType: 4
};


(globalThis as any)['NSFetchRequestExpression'] = (globalThis as any)['NSFetchRequestExpression'] || {};

(globalThis as any)['NSFetchedPropertyDescription'] = (globalThis as any)['NSFetchedPropertyDescription'] || {};

(globalThis as any)['NSFetchedResultsController'] = (globalThis as any)['NSFetchedResultsController'] || {};
(globalThis as any)['NSFetchedResultsController']['NSFetchedResultsChangeType'] = (globalThis as any)['NSFetchedResultsController']['NSFetchedResultsChangeType'] || {};
(globalThis as any)['NSFetchedResultsController']['NSFetchedResultsChangeType'] = {
  Insert: 1,
  Delete: 2,
  Move: 3,
  Update: 4
};


(globalThis as any)['NSFileCoordinator'] = (globalThis as any)['NSFileCoordinator'] || {};
(globalThis as any)['NSFileCoordinator']['ReadingOptions'] = (globalThis as any)['NSFileCoordinator']['ReadingOptions'] || {};
(globalThis as any)['NSFileCoordinator']['ReadingOptions'] = {
  WithoutChanges: 1,
  ResolvesSymbolicLink: 2,
  ImmediatelyAvailableMetadataOnly: 4,
  ForUploading: 8
};

(globalThis as any)['NSFileCoordinator']['WritingOptions'] = (globalThis as any)['NSFileCoordinator']['WritingOptions'] || {};
(globalThis as any)['NSFileCoordinator']['WritingOptions'] = {
  ForDeleting: 1,
  ForMoving: 2,
  ForMerging: 4,
  ForReplacing: 8,
  ContentIndependentMetadataOnly: 16
};


(globalThis as any)['FileHandle'] = (globalThis as any)['FileHandle'] || {};

(globalThis as any)['NSFilePresenter'] = (globalThis as any)['NSFilePresenter'] || {};

(globalThis as any)['NSFilePromiseProvider'] = (globalThis as any)['NSFilePromiseProvider'] || {};

(globalThis as any)['NSFilePromiseReceiver'] = (globalThis as any)['NSFilePromiseReceiver'] || {};

(globalThis as any)['NSFileVersion'] = (globalThis as any)['NSFileVersion'] || {};
(globalThis as any)['NSFileVersion']['AddingOptions'] = (globalThis as any)['NSFileVersion']['AddingOptions'] || {};
(globalThis as any)['NSFileVersion']['AddingOptions'] = {
  NSFileVersionAddingByMoving: 1
};

(globalThis as any)['NSFileVersion']['ReplacingOptions'] = (globalThis as any)['NSFileVersion']['ReplacingOptions'] || {};
(globalThis as any)['NSFileVersion']['ReplacingOptions'] = {
  NSFileVersionReplacingByMoving: 1
};


(globalThis as any)['NSFont'] = (globalThis as any)['NSFont'] || {};
(globalThis as any)['NSFont']['NSFontRenderingMode'] = (globalThis as any)['NSFont']['NSFontRenderingMode'] || {};
(globalThis as any)['NSFont']['NSFontRenderingMode'] = {
  DefaultRenderingMode: 0,
  AntialiasedRenderingMode: 1,
  IntegerAdvancementsRenderingMode: 2,
  AntialiasedIntegerAdvancementsRenderingMode: 3
};


(globalThis as any)['NSFontAssetRequest'] = (globalThis as any)['NSFontAssetRequest'] || {};
(globalThis as any)['NSFontAssetRequest']['Options'] = (globalThis as any)['NSFontAssetRequest']['Options'] || {};
(globalThis as any)['NSFontAssetRequest']['Options'] = {
  NSFontAssetRequestOptionUsesStandardUI: 1
};


(globalThis as any)['NSFontCollection'] = (globalThis as any)['NSFontCollection'] || {};
(globalThis as any)['NSFontCollection']['Visibility'] = (globalThis as any)['NSFontCollection']['Visibility'] || {};
(globalThis as any)['NSFontCollection']['Visibility'] = {
  Process: 1,
  User: 2,
  Computer: 4
};


(globalThis as any)['NSFontDescriptor'] = (globalThis as any)['NSFontDescriptor'] || {};
(globalThis as any)['NSFontDescriptor']['SymbolicTraits'] = (globalThis as any)['NSFontDescriptor']['SymbolicTraits'] || {};
(globalThis as any)['NSFontDescriptor']['SymbolicTraits'] = {
  TraitItalic: 1,
  TraitBold: 2,
  TraitExpanded: 32,
  TraitCondensed: 64,
  TraitMonoSpace: 1024,
  TraitVertical: 2048,
  TraitUIOptimized: 4096,
  TraitTightLeading: 32768,
  TraitLooseLeading: 65536,
  ClassMask: 4026531840,
  ClassUnknown: 0,
  ClassOldStyleSerifs: 268435456,
  ClassTransitionalSerifs: 536870912,
  ClassModernSerifs: 805306368,
  ClassClarendonSerifs: 1073741824,
  ClassSlabSerifs: 1342177280,
  ClassFreeformSerifs: 1879048192,
  ClassSansSerif: 2147483648,
  ClassOrnamentals: 2415919104,
  ClassScripts: 2684354560,
  ClassSymbolic: 3221225472
};


(globalThis as any)['NSFontManager'] = (globalThis as any)['NSFontManager'] || {};
(globalThis as any)['NSFontManager']['NSFontAction'] = (globalThis as any)['NSFontManager']['NSFontAction'] || {};
(globalThis as any)['NSFontManager']['NSFontAction'] = {
  NoFontChangeAction: 0,
  ViaPanelFontAction: 1,
  AddTraitFontAction: 2,
  SizeUpFontAction: 3,
  SizeDownFontAction: 4,
  HeavierFontAction: 5,
  LighterFontAction: 6,
  RemoveTraitFontAction: 7
};

(globalThis as any)['NSFontManager']['NSFontCollectionOptions'] = (globalThis as any)['NSFontManager']['NSFontCollectionOptions'] || {};
(globalThis as any)['NSFontManager']['NSFontCollectionOptions'] = {
  NSFontCollectionApplicationOnlyMask: 1
};

(globalThis as any)['NSFontManager']['NSFontTraitMask'] = (globalThis as any)['NSFontManager']['NSFontTraitMask'] || {};
(globalThis as any)['NSFontManager']['NSFontTraitMask'] = {
  ItalicFontMask: 1,
  BoldFontMask: 2,
  UnboldFontMask: 4,
  NonStandardCharacterSetFontMask: 8,
  NarrowFontMask: 16,
  ExpandedFontMask: 32,
  CondensedFontMask: 64,
  SmallCapsFontMask: 128,
  PosterFontMask: 256,
  CompressedFontMask: 512,
  FixedPitchFontMask: 1024,
  UnitalicFontMask: 16777216
};


(globalThis as any)['NSFontPanel'] = (globalThis as any)['NSFontPanel'] || {};
(globalThis as any)['NSFontPanel']['ModeMask'] = (globalThis as any)['NSFontPanel']['ModeMask'] || {};
(globalThis as any)['NSFontPanel']['ModeMask'] = {
  MaskFace: 1,
  MaskSize: 2,
  MaskCollection: 4,
  MaskUnderlineEffect: 256,
  MaskStrikethroughEffect: 512,
  MaskTextColorEffect: 1024,
  MaskDocumentColorEffect: 2048,
  MaskShadowEffect: 4096,
  MaskAllEffects: 1048320,
  sMaskStandardModes: 65535,
  sMaskAllModes: 4294967295
};


(globalThis as any)['NSFormCell'] = (globalThis as any)['NSFormCell'] || {};

(globalThis as any)['NSGarbageCollector'] = (globalThis as any)['NSGarbageCollector'] || {};

(globalThis as any)['NSGeometry'] = (globalThis as any)['NSGeometry'] || {};
(globalThis as any)['NSGeometry']['AlignmentOptions'] = (globalThis as any)['NSGeometry']['AlignmentOptions'] || {};
(globalThis as any)['NSGeometry']['AlignmentOptions'] = {
  MinXInward: 1,
  MinYInward: 2,
  MaxXInward: 4,
  MaxYInward: 8,
  WidthInward: 16,
  HeightInward: 32,
  MinXOutward: 256,
  MinYOutward: 512,
  MaxXOutward: 1024,
  MaxYOutward: 2048,
  WidthOutward: 4096,
  HeightOutward: 8192,
  MinXNearest: 65536,
  MinYNearest: 131072,
  MaxXNearest: 262144,
  MaxYNearest: 524288,
  WidthNearest: 1048576,
  HeightNearest: 2097152,
  RectFlipped: -9223372036854775808,
  AllEdgesInward: 15,
  AllEdgesOutward: 3840,
  AllEdgesNearest: 983040
};

(globalThis as any)['NSGeometry']['NSRectEdge'] = (globalThis as any)['NSGeometry']['NSRectEdge'] || {};
(globalThis as any)['NSGeometry']['NSRectEdge'] = {
  RectEdgeMinX: 0,
  RectEdgeMinY: 1,
  RectEdgeMaxX: 2,
  RectEdgeMaxY: 3,
  MinXEdge: 0,
  MinYEdge: 1,
  MaxXEdge: 2,
  MaxYEdge: 3
};


(globalThis as any)['NSGestureRecognizer'] = (globalThis as any)['NSGestureRecognizer'] || {};
(globalThis as any)['NSGestureRecognizer']['State'] = (globalThis as any)['NSGestureRecognizer']['State'] || {};
(globalThis as any)['NSGestureRecognizer']['State'] = {
  Possible: 0,
  Began: 1,
  Changed: 2,
  Ended: 3,
  Cancelled: 4,
  Failed: 5,
  Recognized: 3
};


(globalThis as any)['NSGlyphGenerator'] = (globalThis as any)['NSGlyphGenerator'] || {};

(globalThis as any)['NSGlyphInfo'] = (globalThis as any)['NSGlyphInfo'] || {};
(globalThis as any)['NSGlyphInfo']['NSCharacterCollection'] = (globalThis as any)['NSGlyphInfo']['NSCharacterCollection'] || {};
(globalThis as any)['NSGlyphInfo']['NSCharacterCollection'] = {
  IdentityMappingCharacterCollection: 0,
  AdobeCNS1CharacterCollection: 1,
  AdobeGB1CharacterCollection: 2,
  AdobeJapan1CharacterCollection: 3,
  AdobeJapan2CharacterCollection: 4,
  AdobeKorea1CharacterCollection: 5
};


(globalThis as any)['NSGradient'] = (globalThis as any)['NSGradient'] || {};
(globalThis as any)['NSGradient']['DrawingOptions'] = (globalThis as any)['NSGradient']['DrawingOptions'] || {};
(globalThis as any)['NSGradient']['DrawingOptions'] = {
  BeforeStartingLocation: 1,
  AfterEndingLocation: 2
};


(globalThis as any)['NSGraphics'] = (globalThis as any)['NSGraphics'] || {};
(globalThis as any)['NSGraphics']['NSWindow'] = (globalThis as any)['NSGraphics']['NSWindow'] || {};
(globalThis as any)['NSGraphics']['NSWindow']['BackingStoreType'] = (globalThis as any)['NSGraphics']['NSWindow']['BackingStoreType'] || {};
(globalThis as any)['NSGraphics']['NSWindow']['BackingStoreType'] = {
  Retained: 0,
  Nonretained: 1,
  Buffered: 2
};

(globalThis as any)['NSGraphics']['NSWindow'] = (globalThis as any)['NSGraphics']['NSWindow'] || {};
(globalThis as any)['NSGraphics']['NSWindow']['Depth'] = (globalThis as any)['NSGraphics']['NSWindow']['Depth'] || {};
(globalThis as any)['NSGraphics']['NSWindow']['Depth'] = {
  TwentyfourBitRGB: 520,
  SixtyfourBitRGB: 528,
  OnehundredtwentyeightBitRGB: 544
};

(globalThis as any)['NSGraphics']['NSWindow'] = (globalThis as any)['NSGraphics']['NSWindow'] || {};
(globalThis as any)['NSGraphics']['NSWindow']['OrderingMode'] = (globalThis as any)['NSGraphics']['NSWindow']['OrderingMode'] || {};
(globalThis as any)['NSGraphics']['NSWindow']['OrderingMode'] = {
  Above: 1,
  Below: -1,
  Out: 0
};

(globalThis as any)['NSGraphics']['NSAnimationEffect'] = (globalThis as any)['NSGraphics']['NSAnimationEffect'] || {};
(globalThis as any)['NSGraphics']['NSAnimationEffect'] = {
  DisappearingItemDefault: 0,
  Poof: 10
};

(globalThis as any)['NSGraphics']['NSColorRenderingIntent'] = (globalThis as any)['NSGraphics']['NSColorRenderingIntent'] || {};
(globalThis as any)['NSGraphics']['NSColorRenderingIntent'] = {
  Default: 0,
  AbsoluteColorimetric: 1,
  RelativeColorimetric: 2,
  Perceptual: 3,
  Saturation: 4
};

(globalThis as any)['NSGraphics']['NSCompositingOperation'] = (globalThis as any)['NSGraphics']['NSCompositingOperation'] || {};
(globalThis as any)['NSGraphics']['NSCompositingOperation'] = {
  Clear: 0,
  Copy: 1,
  SourceOver: 2,
  SourceIn: 3,
  SourceOut: 4,
  SourceAtop: 5,
  DestinationOver: 6,
  DestinationIn: 7,
  DestinationOut: 8,
  DestinationAtop: 9,
  XOR: 10,
  PlusDarker: 11,
  Highlight: 12,
  PlusLighter: 13,
  Multiply: 14,
  Screen: 15,
  Overlay: 16,
  Darken: 17,
  Lighten: 18,
  ColorDodge: 19,
  ColorBurn: 20,
  SoftLight: 21,
  HardLight: 22,
  Difference: 23,
  Exclusion: 24,
  Hue: 25,
  Saturation: 26,
  Color: 27,
  Luminosity: 28
};

(globalThis as any)['NSGraphics']['NSDisplayGamut'] = (globalThis as any)['NSGraphics']['NSDisplayGamut'] || {};
(globalThis as any)['NSGraphics']['NSDisplayGamut'] = {
  SRGB: 1,
  P3: 2
};

(globalThis as any)['NSGraphics']['NSFocusRingPlacement'] = (globalThis as any)['NSGraphics']['NSFocusRingPlacement'] || {};
(globalThis as any)['NSGraphics']['NSFocusRingPlacement'] = {
  Only: 0,
  Below: 1,
  Above: 2
};

(globalThis as any)['NSGraphics']['NSFocusRingType'] = (globalThis as any)['NSGraphics']['NSFocusRingType'] || {};
(globalThis as any)['NSGraphics']['NSFocusRingType'] = {
  Default: 0,
  None: 1,
  Exterior: 2
};


(globalThis as any)['NSGraphicsContext'] = (globalThis as any)['NSGraphicsContext'] || {};
(globalThis as any)['NSGraphicsContext']['NSImageInterpolation'] = (globalThis as any)['NSGraphicsContext']['NSImageInterpolation'] || {};
(globalThis as any)['NSGraphicsContext']['NSImageInterpolation'] = {
  Default: 0,
  None: 1,
  Low: 2,
  Medium: 4,
  High: 3
};


(globalThis as any)['NSGridView'] = (globalThis as any)['NSGridView'] || {};
(globalThis as any)['NSGridView']['NSGridCell'] = (globalThis as any)['NSGridView']['NSGridCell'] || {};
(globalThis as any)['NSGridView']['NSGridCell']['Placement'] = (globalThis as any)['NSGridView']['NSGridCell']['Placement'] || {};
(globalThis as any)['NSGridView']['NSGridCell']['Placement'] = {
  Inherited: 0,
  None: 1,
  Leading: 2,
  Top: 2,
  Trailing: 3,
  Bottom: 3,
  Center: 4,
  Fill: 5
};

(globalThis as any)['NSGridView']['NSGridRow'] = (globalThis as any)['NSGridView']['NSGridRow'] || {};
(globalThis as any)['NSGridView']['NSGridRow']['Alignment'] = (globalThis as any)['NSGridView']['NSGridRow']['Alignment'] || {};
(globalThis as any)['NSGridView']['NSGridRow']['Alignment'] = {
  Inherited: 0,
  None: 1,
  FirstBaseline: 2,
  LastBaseline: 3
};


(globalThis as any)['NSGroupTouchBarItem'] = (globalThis as any)['NSGroupTouchBarItem'] || {};

(globalThis as any)['HTTPCookie'] = (globalThis as any)['HTTPCookie'] || {};
(globalThis as any)['HTTPCookie']['AcceptPolicy'] = (globalThis as any)['HTTPCookie']['AcceptPolicy'] || {};
(globalThis as any)['HTTPCookie']['AcceptPolicy'] = {
  Always: 0,
  Never: 1,
  OnlyFromMainDocumentDomain: 2
};


(globalThis as any)['NSHapticFeedback'] = (globalThis as any)['NSHapticFeedback'] || {};
(globalThis as any)['NSHapticFeedback']['NSHapticFeedbackManager'] = (globalThis as any)['NSHapticFeedback']['NSHapticFeedbackManager'] || {};
(globalThis as any)['NSHapticFeedback']['NSHapticFeedbackManager']['FeedbackPattern'] = (globalThis as any)['NSHapticFeedback']['NSHapticFeedbackManager']['FeedbackPattern'] || {};
(globalThis as any)['NSHapticFeedback']['NSHapticFeedbackManager']['FeedbackPattern'] = {
  Generic: 0,
  Alignment: 1,
  LevelChange: 2
};

(globalThis as any)['NSHapticFeedback']['NSHapticFeedbackManager'] = (globalThis as any)['NSHapticFeedback']['NSHapticFeedbackManager'] || {};
(globalThis as any)['NSHapticFeedback']['NSHapticFeedbackManager']['PerformanceTime'] = (globalThis as any)['NSHapticFeedback']['NSHapticFeedbackManager']['PerformanceTime'] || {};
(globalThis as any)['NSHapticFeedback']['NSHapticFeedbackManager']['PerformanceTime'] = {
  Default: 0,
  Now: 1,
  DrawCompleted: 2
};


(globalThis as any)['NSHashTable'] = (globalThis as any)['NSHashTable'] || {};

(globalThis as any)['NSHelpManager'] = (globalThis as any)['NSHelpManager'] || {};

(globalThis as any)['Host'] = (globalThis as any)['Host'] || {};

(globalThis as any)['NSImage'] = (globalThis as any)['NSImage'] || {};
(globalThis as any)['NSImage']['CacheMode'] = (globalThis as any)['NSImage']['CacheMode'] || {};
(globalThis as any)['NSImage']['CacheMode'] = {
  Default: 0,
  Always: 1,
  BySize: 2,
  Never: 3
};

(globalThis as any)['NSImage']['LayoutDirection'] = (globalThis as any)['NSImage']['LayoutDirection'] || {};
(globalThis as any)['NSImage']['LayoutDirection'] = {
  Unspecified: -1,
  LeftToRight: 2,
  RightToLeft: 3
};

(globalThis as any)['NSImage']['LoadStatus'] = (globalThis as any)['NSImage']['LoadStatus'] || {};
(globalThis as any)['NSImage']['LoadStatus'] = {
  Completed: 0,
  Cancelled: 1,
  InvalidData: 2,
  UnexpectedEOF: 3,
  ReadError: 4
};

(globalThis as any)['NSImage']['ResizingMode'] = (globalThis as any)['NSImage']['ResizingMode'] || {};
(globalThis as any)['NSImage']['ResizingMode'] = {
  Stretch: 0,
  Tile: 1
};


(globalThis as any)['NSImageCell'] = (globalThis as any)['NSImageCell'] || {};
(globalThis as any)['NSImageCell']['NSImageView'] = (globalThis as any)['NSImageCell']['NSImageView'] || {};
(globalThis as any)['NSImageCell']['NSImageView']['FrameStyle'] = (globalThis as any)['NSImageCell']['NSImageView']['FrameStyle'] || {};
(globalThis as any)['NSImageCell']['NSImageView']['FrameStyle'] = {
  None: 0,
  Photo: 1,
  GrayBezel: 2,
  Groove: 3,
  Button: 4
};

(globalThis as any)['NSImageCell']['NSImageAlignment'] = (globalThis as any)['NSImageCell']['NSImageAlignment'] || {};
(globalThis as any)['NSImageCell']['NSImageAlignment'] = {
  Center: 0,
  Top: 1,
  TopLeft: 2,
  TopRight: 3,
  Left: 4,
  Bottom: 5,
  BottomLeft: 6,
  BottomRight: 7,
  Right: 8
};


(globalThis as any)['NSImageRep'] = (globalThis as any)['NSImageRep'] || {};
(globalThis as any)['NSImageRep']['NSImage'] = (globalThis as any)['NSImageRep']['NSImage'] || {};
(globalThis as any)['NSImageRep']['NSImage']['LayoutDirection'] = (globalThis as any)['NSImageRep']['NSImage']['LayoutDirection'] || {};
(globalThis as any)['NSImageRep']['NSImage']['LayoutDirection'] = {
  Unspecified: -1,
  LeftToRight: 2,
  RightToLeft: 3
};


(globalThis as any)['NSImageView'] = (globalThis as any)['NSImageView'] || {};
(globalThis as any)['NSImageView']['FrameStyle'] = (globalThis as any)['NSImageView']['FrameStyle'] || {};
(globalThis as any)['NSImageView']['FrameStyle'] = {
  None: 0,
  Photo: 1,
  GrayBezel: 2,
  Groove: 3,
  Button: 4
};


(globalThis as any)['NSIncrementalStore'] = (globalThis as any)['NSIncrementalStore'] || {};

(globalThis as any)['NSIncrementalStoreNode'] = (globalThis as any)['NSIncrementalStoreNode'] || {};

(globalThis as any)['IndexPath'] = (globalThis as any)['IndexPath'] || {};

(globalThis as any)['IndexSet'] = (globalThis as any)['IndexSet'] || {};

(globalThis as any)['NSInvocation'] = (globalThis as any)['NSInvocation'] || {};

(globalThis as any)['NSItemProvider'] = (globalThis as any)['NSItemProvider'] || {};
(globalThis as any)['NSItemProvider']['ErrorCode'] = (globalThis as any)['NSItemProvider']['ErrorCode'] || {};
(globalThis as any)['NSItemProvider']['ErrorCode'] = {
  UnknownError: -1,
  ItemUnavailableError: -1000,
  UnexpectedValueClassError: -1100,
  UnavailableCoercionError: -1200
};

(globalThis as any)['NSItemProvider']['NSItemProviderFileOptions'] = (globalThis as any)['NSItemProvider']['NSItemProviderFileOptions'] || {};
(globalThis as any)['NSItemProvider']['NSItemProviderFileOptions'] = {
  NSItemProviderFileOptionOpenInPlace: 1
};

(globalThis as any)['NSItemProvider']['NSItemProviderRepresentationVisibility'] = (globalThis as any)['NSItemProvider']['NSItemProviderRepresentationVisibility'] || {};
(globalThis as any)['NSItemProvider']['NSItemProviderRepresentationVisibility'] = {
  All: 0,
  Team: 1,
  Group: 2,
  OwnProcess: 3
};




(globalThis as any)['NSKeyValueObserving'] = (globalThis as any)['NSKeyValueObserving'] || {};
(globalThis as any)['NSKeyValueObserving']['NSKeyValueChange'] = (globalThis as any)['NSKeyValueObserving']['NSKeyValueChange'] || {};
(globalThis as any)['NSKeyValueObserving']['NSKeyValueChange'] = {
  Setting: 1,
  Insertion: 2,
  Removal: 3,
  Replacement: 4
};

(globalThis as any)['NSKeyValueObserving']['NSKeyValueObservingOptions'] = (globalThis as any)['NSKeyValueObserving']['NSKeyValueObservingOptions'] || {};
(globalThis as any)['NSKeyValueObserving']['NSKeyValueObservingOptions'] = {
  New: 1,
  Old: 2,
  Initial: 4,
  Prior: 8
};

(globalThis as any)['NSKeyValueObserving']['NSKeyValueSetMutationKind'] = (globalThis as any)['NSKeyValueObserving']['NSKeyValueSetMutationKind'] || {};
(globalThis as any)['NSKeyValueObserving']['NSKeyValueSetMutationKind'] = {
  UnionSetMutation: 1,
  MinusSetMutation: 2,
  IntersectSetMutation: 3,
  SetSetMutation: 4
};


(globalThis as any)['NSKeyedArchiver'] = (globalThis as any)['NSKeyedArchiver'] || {};

(globalThis as any)['NSLayoutAnchor'] = (globalThis as any)['NSLayoutAnchor'] || {};

(globalThis as any)['NSLayoutConstraint'] = (globalThis as any)['NSLayoutConstraint'] || {};
(globalThis as any)['NSLayoutConstraint']['Attribute'] = (globalThis as any)['NSLayoutConstraint']['Attribute'] || {};
(globalThis as any)['NSLayoutConstraint']['Attribute'] = {
  Left: 1,
  Right: 2,
  Top: 3,
  Bottom: 4,
  Leading: 5,
  Trailing: 6,
  Width: 7,
  Height: 8,
  CenterX: 9,
  CenterY: 10,
  LastBaseline: 11,
  Baseline: 11,
  FirstBaseline: 12,
  NotAnAttribute: 0
};

(globalThis as any)['NSLayoutConstraint']['FormatOptions'] = (globalThis as any)['NSLayoutConstraint']['FormatOptions'] || {};
(globalThis as any)['NSLayoutConstraint']['FormatOptions'] = {
  AlignAllLeft: 2,
  AlignAllRight: 4,
  AlignAllTop: 8,
  AlignAllBottom: 16,
  AlignAllLeading: 32,
  AlignAllTrailing: 64,
  AlignAllCenterX: 512,
  AlignAllCenterY: 1024,
  AlignAllLastBaseline: 2048,
  AlignAllFirstBaseline: 4096,
  AlignAllBaseline: 2048,
  AlignmentMask: 65535,
  DirectionLeadingToTrailing: 0,
  DirectionLeftToRight: 65536,
  DirectionRightToLeft: 131072,
  DirectionMask: 196608
};

(globalThis as any)['NSLayoutConstraint']['Orientation'] = (globalThis as any)['NSLayoutConstraint']['Orientation'] || {};
(globalThis as any)['NSLayoutConstraint']['Orientation'] = {
  Horizontal: 0,
  Vertical: 1
};

(globalThis as any)['NSLayoutConstraint']['Relation'] = (globalThis as any)['NSLayoutConstraint']['Relation'] || {};
(globalThis as any)['NSLayoutConstraint']['Relation'] = {
  LessThanOrEqual: -1,
  Equal: 0,
  GreaterThanOrEqual: 1
};


(globalThis as any)['NSLayoutGuide'] = (globalThis as any)['NSLayoutGuide'] || {};

(globalThis as any)['NSLayoutManager'] = (globalThis as any)['NSLayoutManager'] || {};
(globalThis as any)['NSLayoutManager']['ControlCharacterAction'] = (globalThis as any)['NSLayoutManager']['ControlCharacterAction'] || {};
(globalThis as any)['NSLayoutManager']['ControlCharacterAction'] = {
  ZeroAdvancement: 1,
  Whitespace: 2,
  HorizontalTab: 4,
  LineBreak: 8,
  ParagraphBreak: 16,
  ContainerBreak: 32
};

(globalThis as any)['NSLayoutManager']['GlyphProperty'] = (globalThis as any)['NSLayoutManager']['GlyphProperty'] || {};
(globalThis as any)['NSLayoutManager']['GlyphProperty'] = {
  Null: 1,
  ControlCharacter: 2,
  Elastic: 4,
  NonBaseCharacter: 8
};

(globalThis as any)['NSLayoutManager']['TextLayoutOrientation'] = (globalThis as any)['NSLayoutManager']['TextLayoutOrientation'] || {};
(globalThis as any)['NSLayoutManager']['TextLayoutOrientation'] = {
  Horizontal: 0,
  Vertical: 1
};

(globalThis as any)['NSLayoutManager']['TypesetterBehavior'] = (globalThis as any)['NSLayoutManager']['TypesetterBehavior'] || {};
(globalThis as any)['NSLayoutManager']['TypesetterBehavior'] = {
  LatestBehavior: -1,
  OriginalBehavior: 0,
  Behavior_10_2_WithCompatibility: 1,
  Behavior_10_2: 2,
  Behavior_10_3: 3,
  Behavior_10_4: 4
};


(globalThis as any)['NSLevelIndicator'] = (globalThis as any)['NSLevelIndicator'] || {};
(globalThis as any)['NSLevelIndicator']['PlaceholderVisibility'] = (globalThis as any)['NSLevelIndicator']['PlaceholderVisibility'] || {};
(globalThis as any)['NSLevelIndicator']['PlaceholderVisibility'] = {
  Automatic: 0,
  Always: 1,
  WhileEditing: 2
};

(globalThis as any)['NSLevelIndicator']['Style'] = (globalThis as any)['NSLevelIndicator']['Style'] || {};
(globalThis as any)['NSLevelIndicator']['Style'] = {
  Relevancy: 0,
  ContinuousCapacity: 1,
  DiscreteCapacity: 2,
  Rating: 3
};


(globalThis as any)['NSLevelIndicatorCell'] = (globalThis as any)['NSLevelIndicatorCell'] || {};
(globalThis as any)['NSLevelIndicatorCell']['NSLevelIndicator'] = (globalThis as any)['NSLevelIndicatorCell']['NSLevelIndicator'] || {};
(globalThis as any)['NSLevelIndicatorCell']['NSLevelIndicator']['Style'] = (globalThis as any)['NSLevelIndicatorCell']['NSLevelIndicator']['Style'] || {};
(globalThis as any)['NSLevelIndicatorCell']['NSLevelIndicator']['Style'] = {
  Relevancy: 0,
  ContinuousCapacity: 1,
  DiscreteCapacity: 2,
  Rating: 3
};


(globalThis as any)['NSLinguisticTagger'] = (globalThis as any)['NSLinguisticTagger'] || {};
(globalThis as any)['NSLinguisticTagger']['NSLinguisticTaggerUnit'] = (globalThis as any)['NSLinguisticTagger']['NSLinguisticTaggerUnit'] || {};
(globalThis as any)['NSLinguisticTagger']['NSLinguisticTaggerUnit'] = {
  Word: 0,
  Sentence: 1,
  Paragraph: 2,
  Document: 3
};

(globalThis as any)['NSLinguisticTagger']['Options'] = (globalThis as any)['NSLinguisticTagger']['Options'] || {};
(globalThis as any)['NSLinguisticTagger']['Options'] = {
  OmitWords: 1,
  OmitPunctuation: 2,
  OmitWhitespace: 4,
  OmitOther: 8,
  JoinNames: 16
};


(globalThis as any)['ListFormatter'] = (globalThis as any)['ListFormatter'] || {};

(globalThis as any)['NSLock'] = (globalThis as any)['NSLock'] || {};

(globalThis as any)['NSMagnificationGestureRecognizer'] = (globalThis as any)['NSMagnificationGestureRecognizer'] || {};

(globalThis as any)['NSManagedObject'] = (globalThis as any)['NSManagedObject'] || {};
(globalThis as any)['NSManagedObject']['NSSnapshotEventType'] = (globalThis as any)['NSManagedObject']['NSSnapshotEventType'] || {};
(globalThis as any)['NSManagedObject']['NSSnapshotEventType'] = {
  UndoInsertion: 2,
  UndoDeletion: 4,
  UndoUpdate: 8,
  Rollback: 16,
  Refresh: 32,
  MergePolicy: 64
};


(globalThis as any)['NSManagedObjectContext'] = (globalThis as any)['NSManagedObjectContext'] || {};
(globalThis as any)['NSManagedObjectContext']['NSManagedObjectContextConcurrencyType'] = (globalThis as any)['NSManagedObjectContext']['NSManagedObjectContextConcurrencyType'] || {};
(globalThis as any)['NSManagedObjectContext']['NSManagedObjectContextConcurrencyType'] = {
  ConfinementConcurrencyType: 0,
  PrivateQueueConcurrencyType: 1,
  MainQueueConcurrencyType: 2
};


(globalThis as any)['NSManagedObjectID'] = (globalThis as any)['NSManagedObjectID'] || {};

(globalThis as any)['NSManagedObjectModel'] = (globalThis as any)['NSManagedObjectModel'] || {};

(globalThis as any)['NSMapTable'] = (globalThis as any)['NSMapTable'] || {};

(globalThis as any)['NSMappingModel'] = (globalThis as any)['NSMappingModel'] || {};

(globalThis as any)['NSMatrix'] = (globalThis as any)['NSMatrix'] || {};
(globalThis as any)['NSMatrix']['Mode'] = (globalThis as any)['NSMatrix']['Mode'] || {};
(globalThis as any)['NSMatrix']['Mode'] = {
  RadioModeMatrix: 0,
  HighlightModeMatrix: 1,
  ListModeMatrix: 2,
  TrackModeMatrix: 3
};


(globalThis as any)['Measurement'] = (globalThis as any)['Measurement'] || {};

(globalThis as any)['NSMediaLibraryBrowserController'] = (globalThis as any)['NSMediaLibraryBrowserController'] || {};
(globalThis as any)['NSMediaLibraryBrowserController']['Library'] = (globalThis as any)['NSMediaLibraryBrowserController']['Library'] || {};
(globalThis as any)['NSMediaLibraryBrowserController']['Library'] = {
  Audio: 1,
  Image: 2,
  Movie: 4
};


(globalThis as any)['NSMenu'] = (globalThis as any)['NSMenu'] || {};
(globalThis as any)['NSMenu']['Properties'] = (globalThis as any)['NSMenu']['Properties'] || {};
(globalThis as any)['NSMenu']['Properties'] = {
  Title: 1,
  AttributedTitle: 2,
  KeyEquivalent: 4,
  Image: 8,
  Enabled: 16,
  AccessibilityDescription: 32
};


(globalThis as any)['NSMenuItem'] = (globalThis as any)['NSMenuItem'] || {};

(globalThis as any)['NSMenuItemCell'] = (globalThis as any)['NSMenuItemCell'] || {};

(globalThis as any)['NSMenuToolbarItem'] = (globalThis as any)['NSMenuToolbarItem'] || {};

(globalThis as any)['NSMergePolicy'] = (globalThis as any)['NSMergePolicy'] || {};
(globalThis as any)['NSMergePolicy']['NSMergePolicyType'] = (globalThis as any)['NSMergePolicy']['NSMergePolicyType'] || {};
(globalThis as any)['NSMergePolicy']['NSMergePolicyType'] = {
  ErrorMergePolicyType: 0,
  MergeByPropertyStoreTrumpMergePolicyType: 1,
  MergeByPropertyObjectTrumpMergePolicyType: 2,
  OverwriteMergePolicyType: 3,
  RollbackMergePolicyType: 4
};




(globalThis as any)['NSMethodSignature'] = (globalThis as any)['NSMethodSignature'] || {};

(globalThis as any)['NSMigrationManager'] = (globalThis as any)['NSMigrationManager'] || {};

(globalThis as any)['NSNetServices'] = (globalThis as any)['NSNetServices'] || {};
(globalThis as any)['NSNetServices']['NetService'] = (globalThis as any)['NSNetServices']['NetService'] || {};
(globalThis as any)['NSNetServices']['NetService']['ErrorCode'] = (globalThis as any)['NSNetServices']['NetService']['ErrorCode'] || {};
(globalThis as any)['NSNetServices']['NetService']['ErrorCode'] = {
  UnknownError: -72000,
  CollisionError: -72001,
  NotFoundError: -72002,
  ActivityInProgress: -72003,
  BadArgumentError: -72004,
  CancelledError: -72005,
  InvalidError: -72006,
  TimeoutError: -72007
};

(globalThis as any)['NSNetServices']['NetService'] = (globalThis as any)['NSNetServices']['NetService'] || {};
(globalThis as any)['NSNetServices']['NetService']['Options'] = (globalThis as any)['NSNetServices']['NetService']['Options'] || {};
(globalThis as any)['NSNetServices']['NetService']['Options'] = {
  NoAutoRename: 1,
  ListenForConnections: 2
};


(globalThis as any)['NSNib'] = (globalThis as any)['NSNib'] || {};

(globalThis as any)['Notification'] = (globalThis as any)['Notification'] || {};

(globalThis as any)['NotificationQueue'] = (globalThis as any)['NotificationQueue'] || {};
(globalThis as any)['NotificationQueue']['NotificationCoalescing'] = (globalThis as any)['NotificationQueue']['NotificationCoalescing'] || {};
(globalThis as any)['NotificationQueue']['NotificationCoalescing'] = {
  NoCoalescing: 0,
  CoalescingOnName: 1,
  CoalescingOnSender: 2
};

(globalThis as any)['NotificationQueue']['PostingStyle'] = (globalThis as any)['NotificationQueue']['PostingStyle'] || {};
(globalThis as any)['NotificationQueue']['PostingStyle'] = {
  WhenIdle: 1,
  ASAP: 2,
  Now: 3
};


(globalThis as any)['NumberFormatter'] = (globalThis as any)['NumberFormatter'] || {};
(globalThis as any)['NumberFormatter']['Behavior'] = (globalThis as any)['NumberFormatter']['Behavior'] || {};
(globalThis as any)['NumberFormatter']['Behavior'] = {
  rDefault: 0,
  r10_0: 1000,
  r10_4: 1040
};

(globalThis as any)['NumberFormatter']['PadPosition'] = (globalThis as any)['NumberFormatter']['PadPosition'] || {};
(globalThis as any)['NumberFormatter']['PadPosition'] = {
  BeforePrefix: 0,
  AfterPrefix: 1,
  BeforeSuffix: 2,
  AfterSuffix: 3
};

(globalThis as any)['NumberFormatter']['RoundingMode'] = (globalThis as any)['NumberFormatter']['RoundingMode'] || {};
(globalThis as any)['NumberFormatter']['RoundingMode'] = {
  Ceiling: 0,
  Floor: 1,
  Down: 2,
  Up: 3,
  HalfEven: 4,
  HalfDown: 5,
  HalfUp: 6
};

(globalThis as any)['NumberFormatter']['Style'] = (globalThis as any)['NumberFormatter']['Style'] || {};
(globalThis as any)['NumberFormatter']['Style'] = {
  NoStyle: 0,
  DecimalStyle: 1,
  CurrencyStyle: 2,
  PercentStyle: 3,
  ScientificStyle: 4,
  SpellOutStyle: 5,
  OrdinalStyle: 6,
  CurrencyISOCodeStyle: 8,
  CurrencyPluralStyle: 9,
  CurrencyAccountingStyle: 10
};


(globalThis as any)['NSObjCRuntime'] = (globalThis as any)['NSObjCRuntime'] || {};
(globalThis as any)['NSObjCRuntime']['ComparisonResult'] = (globalThis as any)['NSObjCRuntime']['ComparisonResult'] || {};
(globalThis as any)['NSObjCRuntime']['ComparisonResult'] = {
  Ascending: -1,
  Same: 0,
  Descending: 1
};

(globalThis as any)['NSObjCRuntime']['NSEnumerationOptions'] = (globalThis as any)['NSObjCRuntime']['NSEnumerationOptions'] || {};
(globalThis as any)['NSObjCRuntime']['NSEnumerationOptions'] = {
  Concurrent: 1,
  Reverse: 2
};

(globalThis as any)['NSObjCRuntime']['NSSortOptions'] = (globalThis as any)['NSObjCRuntime']['NSSortOptions'] || {};
(globalThis as any)['NSObjCRuntime']['NSSortOptions'] = {
  Concurrent: 1,
  Stable: 16
};

(globalThis as any)['NSObjCRuntime']['QualityOfService'] = (globalThis as any)['NSObjCRuntime']['QualityOfService'] || {};
(globalThis as any)['NSObjCRuntime']['QualityOfService'] = {
  UserInteractive: 33,
  UserInitiated: 25,
  Utility: 17,
  Background: 9,
  Default: -1
};


(globalThis as any)['NSObjectController'] = (globalThis as any)['NSObjectController'] || {};

(globalThis as any)['NSOpenPanel'] = (globalThis as any)['NSOpenPanel'] || {};

(globalThis as any)['Operation'] = (globalThis as any)['Operation'] || {};
(globalThis as any)['Operation']['QueuePriority'] = (globalThis as any)['Operation']['QueuePriority'] || {};
(globalThis as any)['Operation']['QueuePriority'] = {
  VeryLow: -8,
  Low: -4,
  Normal: 0,
  High: 4,
  VeryHigh: 8
};


(globalThis as any)['NSOrderedCollectionChange'] = (globalThis as any)['NSOrderedCollectionChange'] || {};
(globalThis as any)['NSOrderedCollectionChange']['NSCollectionChangeType'] = (globalThis as any)['NSOrderedCollectionChange']['NSCollectionChangeType'] || {};
(globalThis as any)['NSOrderedCollectionChange']['NSCollectionChangeType'] = {
  Insert: 0,
  Remove: 1
};


(globalThis as any)['NSOrderedSet'] = (globalThis as any)['NSOrderedSet'] || {};

(globalThis as any)['NSOrthography'] = (globalThis as any)['NSOrthography'] || {};

(globalThis as any)['NSOutlineView'] = (globalThis as any)['NSOutlineView'] || {};

(globalThis as any)['NSPDFImageRep'] = (globalThis as any)['NSPDFImageRep'] || {};

(globalThis as any)['NSPDFInfo'] = (globalThis as any)['NSPDFInfo'] || {};

(globalThis as any)['NSPDFPanel'] = (globalThis as any)['NSPDFPanel'] || {};
(globalThis as any)['NSPDFPanel']['Options'] = (globalThis as any)['NSPDFPanel']['Options'] || {};
(globalThis as any)['NSPDFPanel']['Options'] = {
  ShowsPaperSize: 4,
  ShowsOrientation: 8,
  RequestsParentDirectory: 16777216
};


(globalThis as any)['NSPICTImageRep'] = (globalThis as any)['NSPICTImageRep'] || {};

(globalThis as any)['NSPageController'] = (globalThis as any)['NSPageController'] || {};
(globalThis as any)['NSPageController']['TransitionStyle'] = (globalThis as any)['NSPageController']['TransitionStyle'] || {};
(globalThis as any)['NSPageController']['TransitionStyle'] = {
  StackHistory: 0,
  StackBook: 1,
  HorizontalStrip: 2
};


(globalThis as any)['NSPageLayout'] = (globalThis as any)['NSPageLayout'] || {};

(globalThis as any)['NSPanGestureRecognizer'] = (globalThis as any)['NSPanGestureRecognizer'] || {};

(globalThis as any)['NSPanel'] = (globalThis as any)['NSPanel'] || {};

(globalThis as any)['NSParagraphStyle'] = (globalThis as any)['NSParagraphStyle'] || {};
(globalThis as any)['NSParagraphStyle']['NSLineBreakMode'] = (globalThis as any)['NSParagraphStyle']['NSLineBreakMode'] || {};
(globalThis as any)['NSParagraphStyle']['NSLineBreakMode'] = {
  WordWrapping: 0,
  CharWrapping: 1,
  Clipping: 2,
  TruncatingHead: 3,
  TruncatingTail: 4,
  TruncatingMiddle: 5
};

(globalThis as any)['NSParagraphStyle']['TextTabType'] = (globalThis as any)['NSParagraphStyle']['TextTabType'] || {};
(globalThis as any)['NSParagraphStyle']['TextTabType'] = {
  LeftTabStopType: 0,
  RightTabStopType: 1,
  CenterTabStopType: 2,
  DecimalTabStopType: 3
};


(globalThis as any)['NSPasteboard'] = (globalThis as any)['NSPasteboard'] || {};
(globalThis as any)['NSPasteboard']['ContentsOptions'] = (globalThis as any)['NSPasteboard']['ContentsOptions'] || {};
(globalThis as any)['NSPasteboard']['ContentsOptions'] = {
  NSPasteboardContentsCurrentHostOnly: 1
};

(globalThis as any)['NSPasteboard']['ReadingOptions'] = (globalThis as any)['NSPasteboard']['ReadingOptions'] || {};
(globalThis as any)['NSPasteboard']['ReadingOptions'] = {
  Data: 0,
  String: 1,
  PropertyList: 2,
  KeyedArchive: 4
};

(globalThis as any)['NSPasteboard']['WritingOptions'] = (globalThis as any)['NSPasteboard']['WritingOptions'] || {};
(globalThis as any)['NSPasteboard']['WritingOptions'] = {
  NSPasteboardWritingPromised: 512
};


(globalThis as any)['NSPasteboardItem'] = (globalThis as any)['NSPasteboardItem'] || {};

(globalThis as any)['NSPathCell'] = (globalThis as any)['NSPathCell'] || {};
(globalThis as any)['NSPathCell']['NSPathControl'] = (globalThis as any)['NSPathCell']['NSPathControl'] || {};
(globalThis as any)['NSPathCell']['NSPathControl']['Style'] = (globalThis as any)['NSPathCell']['NSPathControl']['Style'] || {};
(globalThis as any)['NSPathCell']['NSPathControl']['Style'] = {
  Standard: 0,
  PopUp: 2,
  NavigationBar: 1
};


(globalThis as any)['NSPathComponentCell'] = (globalThis as any)['NSPathComponentCell'] || {};

(globalThis as any)['NSPathControl'] = (globalThis as any)['NSPathControl'] || {};
(globalThis as any)['NSPathControl']['Style'] = (globalThis as any)['NSPathControl']['Style'] || {};
(globalThis as any)['NSPathControl']['Style'] = {
  Standard: 0,
  PopUp: 2,
  NavigationBar: 1
};


(globalThis as any)['NSPathControlItem'] = (globalThis as any)['NSPathControlItem'] || {};

(globalThis as any)['NSPathUtilities'] = (globalThis as any)['NSPathUtilities'] || {};
(globalThis as any)['NSPathUtilities']['FileManager'] = (globalThis as any)['NSPathUtilities']['FileManager'] || {};
(globalThis as any)['NSPathUtilities']['FileManager']['SearchPathDirectory'] = (globalThis as any)['NSPathUtilities']['FileManager']['SearchPathDirectory'] || {};
(globalThis as any)['NSPathUtilities']['FileManager']['SearchPathDirectory'] = {
  ApplicationDirectory: 1,
  DemoApplicationDirectory: 2,
  DeveloperApplicationDirectory: 3,
  AdminApplicationDirectory: 4,
  LibraryDirectory: 5,
  DeveloperDirectory: 6,
  UserDirectory: 7,
  DocumentationDirectory: 8,
  DocumentDirectory: 9,
  CoreServiceDirectory: 10,
  AutosavedInformationDirectory: 11,
  DesktopDirectory: 12,
  CachesDirectory: 13,
  ApplicationSupportDirectory: 14,
  DownloadsDirectory: 15,
  InputMethodsDirectory: 16,
  MoviesDirectory: 17,
  MusicDirectory: 18,
  PicturesDirectory: 19,
  PrinterDescriptionDirectory: 20,
  SharedPublicDirectory: 21,
  PreferencePanesDirectory: 22,
  ApplicationScriptsDirectory: 23,
  ItemReplacementDirectory: 99,
  AllApplicationsDirectory: 100,
  AllLibrariesDirectory: 101,
  TrashDirectory: 102
};

(globalThis as any)['NSPathUtilities']['FileManager'] = (globalThis as any)['NSPathUtilities']['FileManager'] || {};
(globalThis as any)['NSPathUtilities']['FileManager']['SearchPathDomainMask'] = (globalThis as any)['NSPathUtilities']['FileManager']['SearchPathDomainMask'] || {};
(globalThis as any)['NSPathUtilities']['FileManager']['SearchPathDomainMask'] = {
  UserDomainMask: 1,
  LocalDomainMask: 2,
  NetworkDomainMask: 4,
  SystemDomainMask: 8,
  AllDomainsMask: 65535
};


(globalThis as any)['NSPersistentCloudKitContainer'] = (globalThis as any)['NSPersistentCloudKitContainer'] || {};
(globalThis as any)['NSPersistentCloudKitContainer']['NSPersistentCloudKitContainerSchemaInitializationOptions'] = (globalThis as any)['NSPersistentCloudKitContainer']['NSPersistentCloudKitContainerSchemaInitializationOptions'] || {};
(globalThis as any)['NSPersistentCloudKitContainer']['NSPersistentCloudKitContainerSchemaInitializationOptions'] = {
  None: 0,
  DryRun: 2,
  PrintSchema: 4
};


(globalThis as any)['NSPersistentCloudKitContainerOptions'] = (globalThis as any)['NSPersistentCloudKitContainerOptions'] || {};

(globalThis as any)['NSPersistentContainer'] = (globalThis as any)['NSPersistentContainer'] || {};

(globalThis as any)['NSPersistentDocument'] = (globalThis as any)['NSPersistentDocument'] || {};

(globalThis as any)['NSPersistentHistoryChange'] = (globalThis as any)['NSPersistentHistoryChange'] || {};
(globalThis as any)['NSPersistentHistoryChange']['NSPersistentHistoryChangeType'] = (globalThis as any)['NSPersistentHistoryChange']['NSPersistentHistoryChangeType'] || {};
(globalThis as any)['NSPersistentHistoryChange']['NSPersistentHistoryChangeType'] = {
  Insert: 0,
  Update: 1,
  Delete: 2
};


(globalThis as any)['NSPersistentHistoryChangeRequest'] = (globalThis as any)['NSPersistentHistoryChangeRequest'] || {};

(globalThis as any)['NSPersistentHistoryTransaction'] = (globalThis as any)['NSPersistentHistoryTransaction'] || {};

(globalThis as any)['NSPersistentStore'] = (globalThis as any)['NSPersistentStore'] || {};

(globalThis as any)['NSPersistentStoreCoordinator'] = (globalThis as any)['NSPersistentStoreCoordinator'] || {};

(globalThis as any)['NSPersistentStoreDescription'] = (globalThis as any)['NSPersistentStoreDescription'] || {};

(globalThis as any)['NSPersistentStoreRequest'] = (globalThis as any)['NSPersistentStoreRequest'] || {};
(globalThis as any)['NSPersistentStoreRequest']['NSPersistentStoreRequestType'] = (globalThis as any)['NSPersistentStoreRequest']['NSPersistentStoreRequestType'] || {};
(globalThis as any)['NSPersistentStoreRequest']['NSPersistentStoreRequestType'] = {
  FetchRequestType: 1,
  SaveRequestType: 2,
  BatchInsertRequestType: 5,
  BatchUpdateRequestType: 6,
  BatchDeleteRequestType: 7
};


(globalThis as any)['NSPersistentStoreResult'] = (globalThis as any)['NSPersistentStoreResult'] || {};
(globalThis as any)['NSPersistentStoreResult']['NSBatchDeleteRequestResultType'] = (globalThis as any)['NSPersistentStoreResult']['NSBatchDeleteRequestResultType'] || {};
(globalThis as any)['NSPersistentStoreResult']['NSBatchDeleteRequestResultType'] = {
  StatusOnly: 0,
  ObjectIDs: 1,
  Count: 2
};

(globalThis as any)['NSPersistentStoreResult']['NSBatchInsertRequestResultType'] = (globalThis as any)['NSPersistentStoreResult']['NSBatchInsertRequestResultType'] || {};
(globalThis as any)['NSPersistentStoreResult']['NSBatchInsertRequestResultType'] = {
  StatusOnly: 0,
  ObjectIDs: 1,
  Count: 2
};

(globalThis as any)['NSPersistentStoreResult']['NSBatchUpdateRequestResultType'] = (globalThis as any)['NSPersistentStoreResult']['NSBatchUpdateRequestResultType'] || {};
(globalThis as any)['NSPersistentStoreResult']['NSBatchUpdateRequestResultType'] = {
  StatusOnlyResultType: 0,
  UpdatedObjectIDsResultType: 1,
  UpdatedObjectsCountResultType: 2
};

(globalThis as any)['NSPersistentStoreResult']['NSPersistentHistoryResultType'] = (globalThis as any)['NSPersistentStoreResult']['NSPersistentHistoryResultType'] || {};
(globalThis as any)['NSPersistentStoreResult']['NSPersistentHistoryResultType'] = {
  StatusOnly: 0,
  ObjectIDs: 1,
  Count: 2,
  TransactionsOnly: 3,
  ChangesOnly: 4,
  TransactionsAndChanges: 5
};


(globalThis as any)['PersonNameComponents'] = (globalThis as any)['PersonNameComponents'] || {};

(globalThis as any)['PersonNameComponentsFormatter'] = (globalThis as any)['PersonNameComponentsFormatter'] || {};
(globalThis as any)['PersonNameComponentsFormatter']['Options'] = (globalThis as any)['PersonNameComponentsFormatter']['Options'] || {};
(globalThis as any)['PersonNameComponentsFormatter']['Options'] = {
  NSPersonNameComponentsFormatterPhonetic: 2
};

(globalThis as any)['PersonNameComponentsFormatter']['Style'] = (globalThis as any)['PersonNameComponentsFormatter']['Style'] || {};
(globalThis as any)['PersonNameComponentsFormatter']['Style'] = {
  Default: 0,
  Short: 1,
  Medium: 2,
  Long: 3,
  Abbreviated: 4
};


(globalThis as any)['NSPickerTouchBarItem'] = (globalThis as any)['NSPickerTouchBarItem'] || {};
(globalThis as any)['NSPickerTouchBarItem']['ControlRepresentation'] = (globalThis as any)['NSPickerTouchBarItem']['ControlRepresentation'] || {};
(globalThis as any)['NSPickerTouchBarItem']['ControlRepresentation'] = {
  Automatic: 0,
  Expanded: 1,
  Collapsed: 2
};

(globalThis as any)['NSPickerTouchBarItem']['SelectionMode'] = (globalThis as any)['NSPickerTouchBarItem']['SelectionMode'] || {};
(globalThis as any)['NSPickerTouchBarItem']['SelectionMode'] = {
  SelectOne: 0,
  SelectAny: 1,
  Momentary: 2
};


(globalThis as any)['NSPointerArray'] = (globalThis as any)['NSPointerArray'] || {};

(globalThis as any)['NSPointerFunctions'] = (globalThis as any)['NSPointerFunctions'] || {};
(globalThis as any)['NSPointerFunctions']['Options'] = (globalThis as any)['NSPointerFunctions']['Options'] || {};
(globalThis as any)['NSPointerFunctions']['Options'] = {
  StrongMemory: 0,
  ZeroingWeakMemory: 1,
  OpaqueMemory: 2,
  MallocMemory: 3,
  MachVirtualMemory: 4,
  WeakMemory: 5,
  ObjectPersonality: 0,
  OpaquePersonality: 256,
  ObjectPointerPersonality: 512,
  CStringPersonality: 768,
  StructPersonality: 1024,
  IntegerPersonality: 1280,
  CopyIn: 65536
};


(globalThis as any)['NSPopUpButton'] = (globalThis as any)['NSPopUpButton'] || {};
(globalThis as any)['NSPopUpButton']['ArrowPosition'] = (globalThis as any)['NSPopUpButton']['ArrowPosition'] || {};
(globalThis as any)['NSPopUpButton']['ArrowPosition'] = {
  NoArrow: 0,
  ArrowAtCenter: 1,
  ArrowAtBottom: 2
};


(globalThis as any)['NSPopUpButtonCell'] = (globalThis as any)['NSPopUpButtonCell'] || {};
(globalThis as any)['NSPopUpButtonCell']['NSPopUpButton'] = (globalThis as any)['NSPopUpButtonCell']['NSPopUpButton'] || {};
(globalThis as any)['NSPopUpButtonCell']['NSPopUpButton']['ArrowPosition'] = (globalThis as any)['NSPopUpButtonCell']['NSPopUpButton']['ArrowPosition'] || {};
(globalThis as any)['NSPopUpButtonCell']['NSPopUpButton']['ArrowPosition'] = {
  NoArrow: 0,
  ArrowAtCenter: 1,
  ArrowAtBottom: 2
};


(globalThis as any)['NSPopover'] = (globalThis as any)['NSPopover'] || {};
(globalThis as any)['NSPopover']['Behavior'] = (globalThis as any)['NSPopover']['Behavior'] || {};
(globalThis as any)['NSPopover']['Behavior'] = {
  ApplicationDefined: 0,
  Transient: 1,
  Semitransient: 2
};


(globalThis as any)['NSPopoverTouchBarItem'] = (globalThis as any)['NSPopoverTouchBarItem'] || {};

(globalThis as any)['Port'] = (globalThis as any)['Port'] || {};
(globalThis as any)['Port']['NSMachPort'] = (globalThis as any)['Port']['NSMachPort'] || {};
(globalThis as any)['Port']['NSMachPort']['Options'] = (globalThis as any)['Port']['NSMachPort']['Options'] || {};
(globalThis as any)['Port']['NSMachPort']['Options'] = {
  None: 0,
  SendRight: 1,
  ReceiveRight: 2
};


(globalThis as any)['NSPortCoder'] = (globalThis as any)['NSPortCoder'] || {};

(globalThis as any)['PortMessage'] = (globalThis as any)['PortMessage'] || {};

(globalThis as any)['NSPortNameServer'] = (globalThis as any)['NSPortNameServer'] || {};

(globalThis as any)['NSPredicate'] = (globalThis as any)['NSPredicate'] || {};

(globalThis as any)['NSPredicateEditor'] = (globalThis as any)['NSPredicateEditor'] || {};

(globalThis as any)['NSPredicateEditorRowTemplate'] = (globalThis as any)['NSPredicateEditorRowTemplate'] || {};

(globalThis as any)['NSPressGestureRecognizer'] = (globalThis as any)['NSPressGestureRecognizer'] || {};

(globalThis as any)['NSPressureConfiguration'] = (globalThis as any)['NSPressureConfiguration'] || {};

(globalThis as any)['NSPrintInfo'] = (globalThis as any)['NSPrintInfo'] || {};
(globalThis as any)['NSPrintInfo']['PaginationMode'] = (globalThis as any)['NSPrintInfo']['PaginationMode'] || {};
(globalThis as any)['NSPrintInfo']['PaginationMode'] = {
  Automatic: 0,
  Fit: 1,
  Clip: 2
};

(globalThis as any)['NSPrintInfo']['PaperOrientation'] = (globalThis as any)['NSPrintInfo']['PaperOrientation'] || {};
(globalThis as any)['NSPrintInfo']['PaperOrientation'] = {
  Portrait: 0,
  Landscape: 1
};


(globalThis as any)['NSPrintOperation'] = (globalThis as any)['NSPrintOperation'] || {};
(globalThis as any)['NSPrintOperation']['PageOrder'] = (globalThis as any)['NSPrintOperation']['PageOrder'] || {};
(globalThis as any)['NSPrintOperation']['PageOrder'] = {
  DescendingPageOrder: -1,
  SpecialPageOrder: 0,
  AscendingPageOrder: 1,
  UnknownPageOrder: 2
};

(globalThis as any)['NSPrintOperation']['RenderingQuality'] = (globalThis as any)['NSPrintOperation']['RenderingQuality'] || {};
(globalThis as any)['NSPrintOperation']['RenderingQuality'] = {
  Best: 0,
  Responsive: 1
};


(globalThis as any)['NSPrintPanel'] = (globalThis as any)['NSPrintPanel'] || {};
(globalThis as any)['NSPrintPanel']['Options'] = (globalThis as any)['NSPrintPanel']['Options'] || {};
(globalThis as any)['NSPrintPanel']['Options'] = {
  Copies: 1,
  PageRange: 2,
  PaperSize: 4,
  Orientation: 8,
  Scaling: 16,
  PrintSelection: 32,
  PageSetupAccessory: 256,
  Preview: 131072
};


(globalThis as any)['NSPrinter'] = (globalThis as any)['NSPrinter'] || {};
(globalThis as any)['NSPrinter']['TableStatus'] = (globalThis as any)['NSPrinter']['TableStatus'] || {};
(globalThis as any)['NSPrinter']['TableStatus'] = {
  OK: 0,
  NotFound: 1,
  Error: 2
};


(globalThis as any)['ProcessInfo'] = (globalThis as any)['ProcessInfo'] || {};
(globalThis as any)['ProcessInfo']['ActivityOptions'] = (globalThis as any)['ProcessInfo']['ActivityOptions'] || {};
(globalThis as any)['ProcessInfo']['ActivityOptions'] = {
  IdleDisplaySleepDisabled: 1099511627776,
  IdleSystemSleepDisabled: 1048576,
  SuddenTerminationDisabled: 16384,
  AutomaticTerminationDisabled: 32768,
  UserInitiated: 16777215,
  UserInitiatedAllowingIdleSystemSleep: 15728639,
  Background: 255,
  LatencyCritical: 1095216660480
};

(globalThis as any)['ProcessInfo']['ThermalState'] = (globalThis as any)['ProcessInfo']['ThermalState'] || {};
(globalThis as any)['ProcessInfo']['ThermalState'] = {
  Nominal: 0,
  Fair: 1,
  Serious: 2,
  Critical: 3
};


(globalThis as any)['Progress'] = (globalThis as any)['Progress'] || {};

(globalThis as any)['NSProgressIndicator'] = (globalThis as any)['NSProgressIndicator'] || {};
(globalThis as any)['NSProgressIndicator']['Style'] = (globalThis as any)['NSProgressIndicator']['Style'] || {};
(globalThis as any)['NSProgressIndicator']['Style'] = {
  Bar: 0,
  Spinning: 1
};


(globalThis as any)['NSPropertyDescription'] = (globalThis as any)['NSPropertyDescription'] || {};

(globalThis as any)['NSPropertyList'] = (globalThis as any)['NSPropertyList'] || {};
(globalThis as any)['NSPropertyList']['PropertyListSerialization'] = (globalThis as any)['NSPropertyList']['PropertyListSerialization'] || {};
(globalThis as any)['NSPropertyList']['PropertyListSerialization']['MutabilityOptions'] = (globalThis as any)['NSPropertyList']['PropertyListSerialization']['MutabilityOptions'] || {};
(globalThis as any)['NSPropertyList']['PropertyListSerialization']['MutabilityOptions'] = {
  Immutable: 0,
  MutableContainers: 1,
  MutableContainersAndLeaves: 2
};

(globalThis as any)['NSPropertyList']['PropertyListSerialization'] = (globalThis as any)['NSPropertyList']['PropertyListSerialization'] || {};
(globalThis as any)['NSPropertyList']['PropertyListSerialization']['PropertyListFormat'] = (globalThis as any)['NSPropertyList']['PropertyListSerialization']['PropertyListFormat'] || {};
(globalThis as any)['NSPropertyList']['PropertyListSerialization']['PropertyListFormat'] = {
  OpenStepFormat: 1,
  XMLFormat_v1_0: 100,
  BinaryFormat_v1_0: 200
};


(globalThis as any)['NSPropertyMapping'] = (globalThis as any)['NSPropertyMapping'] || {};

(globalThis as any)['NSProtocolChecker'] = (globalThis as any)['NSProtocolChecker'] || {};

(globalThis as any)['NSProxy'] = (globalThis as any)['NSProxy'] || {};

(globalThis as any)['NSQueryGenerationToken'] = (globalThis as any)['NSQueryGenerationToken'] || {};

(globalThis as any)['NSRegularExpression'] = (globalThis as any)['NSRegularExpression'] || {};
(globalThis as any)['NSRegularExpression']['MatchingFlags'] = (globalThis as any)['NSRegularExpression']['MatchingFlags'] || {};
(globalThis as any)['NSRegularExpression']['MatchingFlags'] = {
  Progress: 1,
  Completed: 2,
  HitEnd: 4,
  RequiredEnd: 8,
  InternalError: 16
};

(globalThis as any)['NSRegularExpression']['MatchingOptions'] = (globalThis as any)['NSRegularExpression']['MatchingOptions'] || {};
(globalThis as any)['NSRegularExpression']['MatchingOptions'] = {
  ReportProgress: 1,
  ReportCompletion: 2,
  Anchored: 4,
  WithTransparentBounds: 8,
  WithoutAnchoringBounds: 16
};

(globalThis as any)['NSRegularExpression']['Options'] = (globalThis as any)['NSRegularExpression']['Options'] || {};
(globalThis as any)['NSRegularExpression']['Options'] = {
  CaseInsensitive: 1,
  AllowCommentsAndWhitespace: 2,
  IgnoreMetacharacters: 4,
  DotMatchesLineSeparators: 8,
  AnchorsMatchLines: 16,
  UseUnixLineSeparators: 32,
  UseUnicodeWordBoundaries: 64
};


(globalThis as any)['NSRelationshipDescription'] = (globalThis as any)['NSRelationshipDescription'] || {};
(globalThis as any)['NSRelationshipDescription']['NSDeleteRule'] = (globalThis as any)['NSRelationshipDescription']['NSDeleteRule'] || {};
(globalThis as any)['NSRelationshipDescription']['NSDeleteRule'] = {
  NoActionDeleteRule: 0,
  NullifyDeleteRule: 1,
  CascadeDeleteRule: 2,
  DenyDeleteRule: 3
};


(globalThis as any)['RelativeDateTimeFormatter'] = (globalThis as any)['RelativeDateTimeFormatter'] || {};
(globalThis as any)['RelativeDateTimeFormatter']['DateTimeStyle'] = (globalThis as any)['RelativeDateTimeFormatter']['DateTimeStyle'] || {};
(globalThis as any)['RelativeDateTimeFormatter']['DateTimeStyle'] = {
  umeric: 0,
  amed: 1
};

(globalThis as any)['RelativeDateTimeFormatter']['UnitsStyle'] = (globalThis as any)['RelativeDateTimeFormatter']['UnitsStyle'] || {};
(globalThis as any)['RelativeDateTimeFormatter']['UnitsStyle'] = {
  Full: 0,
  SpellOut: 1,
  Short: 2,
  Abbreviated: 3
};


(globalThis as any)['NSResponder'] = (globalThis as any)['NSResponder'] || {};

(globalThis as any)['NSRotationGestureRecognizer'] = (globalThis as any)['NSRotationGestureRecognizer'] || {};

(globalThis as any)['NSRuleEditor'] = (globalThis as any)['NSRuleEditor'] || {};
(globalThis as any)['NSRuleEditor']['NestingMode'] = (globalThis as any)['NSRuleEditor']['NestingMode'] || {};
(globalThis as any)['NSRuleEditor']['NestingMode'] = {
  Single: 0,
  List: 1,
  Compound: 2,
  Simple: 3
};

(globalThis as any)['NSRuleEditor']['RowType'] = (globalThis as any)['NSRuleEditor']['RowType'] || {};
(globalThis as any)['NSRuleEditor']['RowType'] = {
  Simple: 0,
  Compound: 1
};


(globalThis as any)['NSRulerMarker'] = (globalThis as any)['NSRulerMarker'] || {};

(globalThis as any)['NSRulerView'] = (globalThis as any)['NSRulerView'] || {};
(globalThis as any)['NSRulerView']['Orientation'] = (globalThis as any)['NSRulerView']['Orientation'] || {};
(globalThis as any)['NSRulerView']['Orientation'] = {
  HorizontalRuler: 0,
  VerticalRuler: 1
};


(globalThis as any)['RunLoop'] = (globalThis as any)['RunLoop'] || {};

(globalThis as any)['NSRunningApplication'] = (globalThis as any)['NSRunningApplication'] || {};
(globalThis as any)['NSRunningApplication']['NSApplication'] = (globalThis as any)['NSRunningApplication']['NSApplication'] || {};
(globalThis as any)['NSRunningApplication']['NSApplication']['ActivationOptions'] = (globalThis as any)['NSRunningApplication']['NSApplication']['ActivationOptions'] || {};
(globalThis as any)['NSRunningApplication']['NSApplication']['ActivationOptions'] = {
  AllWindows: 1,
  IgnoringOtherApps: 2
};

(globalThis as any)['NSRunningApplication']['NSApplication'] = (globalThis as any)['NSRunningApplication']['NSApplication'] || {};
(globalThis as any)['NSRunningApplication']['NSApplication']['ActivationPolicy'] = (globalThis as any)['NSRunningApplication']['NSApplication']['ActivationPolicy'] || {};
(globalThis as any)['NSRunningApplication']['NSApplication']['ActivationPolicy'] = {
  Regular: 0,
  Accessory: 1,
  Prohibited: 2
};


(globalThis as any)['NSSaveChangesRequest'] = (globalThis as any)['NSSaveChangesRequest'] || {};

(globalThis as any)['NSSavePanel'] = (globalThis as any)['NSSavePanel'] || {};

(globalThis as any)['Scanner'] = (globalThis as any)['Scanner'] || {};

(globalThis as any)['NSScreen'] = (globalThis as any)['NSScreen'] || {};

(globalThis as any)['NSScriptClassDescription'] = (globalThis as any)['NSScriptClassDescription'] || {};

(globalThis as any)['NSScriptCoercionHandler'] = (globalThis as any)['NSScriptCoercionHandler'] || {};

(globalThis as any)['NSScriptCommand'] = (globalThis as any)['NSScriptCommand'] || {};

(globalThis as any)['NSScriptCommandDescription'] = (globalThis as any)['NSScriptCommandDescription'] || {};

(globalThis as any)['NSScriptExecutionContext'] = (globalThis as any)['NSScriptExecutionContext'] || {};


(globalThis as any)['NSScriptObjectSpecifiers'] = (globalThis as any)['NSScriptObjectSpecifiers'] || {};
(globalThis as any)['NSScriptObjectSpecifiers']['NSPositionalSpecifier'] = (globalThis as any)['NSScriptObjectSpecifiers']['NSPositionalSpecifier'] || {};
(globalThis as any)['NSScriptObjectSpecifiers']['NSPositionalSpecifier']['InsertionPosition'] = (globalThis as any)['NSScriptObjectSpecifiers']['NSPositionalSpecifier']['InsertionPosition'] || {};
(globalThis as any)['NSScriptObjectSpecifiers']['NSPositionalSpecifier']['InsertionPosition'] = {
  After: 0,
  Before: 1,
  Beginning: 2,
  End: 3,
  Replace: 4
};

(globalThis as any)['NSScriptObjectSpecifiers']['NSRelativeSpecifier'] = (globalThis as any)['NSScriptObjectSpecifiers']['NSRelativeSpecifier'] || {};
(globalThis as any)['NSScriptObjectSpecifiers']['NSRelativeSpecifier']['RelativePosition'] = (globalThis as any)['NSScriptObjectSpecifiers']['NSRelativeSpecifier']['RelativePosition'] || {};
(globalThis as any)['NSScriptObjectSpecifiers']['NSRelativeSpecifier']['RelativePosition'] = {
  After: 0,
  Before: 1
};

(globalThis as any)['NSScriptObjectSpecifiers']['NSWhoseSpecifier'] = (globalThis as any)['NSScriptObjectSpecifiers']['NSWhoseSpecifier'] || {};
(globalThis as any)['NSScriptObjectSpecifiers']['NSWhoseSpecifier']['SubelementIdentifier'] = (globalThis as any)['NSScriptObjectSpecifiers']['NSWhoseSpecifier']['SubelementIdentifier'] || {};
(globalThis as any)['NSScriptObjectSpecifiers']['NSWhoseSpecifier']['SubelementIdentifier'] = {
  IndexSubelement: 0,
  EverySubelement: 1,
  MiddleSubelement: 2,
  RandomSubelement: 3,
  NoSubelement: 4
};


(globalThis as any)['NSScriptStandardSuiteCommands'] = (globalThis as any)['NSScriptStandardSuiteCommands'] || {};
(globalThis as any)['NSScriptStandardSuiteCommands']['NSSaveOptions'] = (globalThis as any)['NSScriptStandardSuiteCommands']['NSSaveOptions'] || {};
(globalThis as any)['NSScriptStandardSuiteCommands']['NSSaveOptions'] = {
  Yes: 0,
  No: 1,
  Ask: 2
};


(globalThis as any)['NSScriptSuiteRegistry'] = (globalThis as any)['NSScriptSuiteRegistry'] || {};

(globalThis as any)['NSScriptWhoseTests'] = (globalThis as any)['NSScriptWhoseTests'] || {};
(globalThis as any)['NSScriptWhoseTests']['NSSpecifierTest'] = (globalThis as any)['NSScriptWhoseTests']['NSSpecifierTest'] || {};
(globalThis as any)['NSScriptWhoseTests']['NSSpecifierTest']['TestComparisonOperation'] = (globalThis as any)['NSScriptWhoseTests']['NSSpecifierTest']['TestComparisonOperation'] || {};
(globalThis as any)['NSScriptWhoseTests']['NSSpecifierTest']['TestComparisonOperation'] = {
  EqualToComparison: 0,
  LessThanOrEqualToComparison: 1,
  LessThanComparison: 2,
  GreaterThanOrEqualToComparison: 3,
  GreaterThanComparison: 4,
  BeginsWithComparison: 5,
  EndsWithComparison: 6,
  ContainsComparison: 7
};


(globalThis as any)['NSScrollView'] = (globalThis as any)['NSScrollView'] || {};
(globalThis as any)['NSScrollView']['Elasticity'] = (globalThis as any)['NSScrollView']['Elasticity'] || {};
(globalThis as any)['NSScrollView']['Elasticity'] = {
  Automatic: 0,
  None: 1,
  Allowed: 2
};

(globalThis as any)['NSScrollView']['FindBarPosition'] = (globalThis as any)['NSScrollView']['FindBarPosition'] || {};
(globalThis as any)['NSScrollView']['FindBarPosition'] = {
  AboveHorizontalRuler: 0,
  AboveContent: 1,
  BelowContent: 2
};


(globalThis as any)['NSScroller'] = (globalThis as any)['NSScroller'] || {};
(globalThis as any)['NSScroller']['KnobStyle'] = (globalThis as any)['NSScroller']['KnobStyle'] || {};
(globalThis as any)['NSScroller']['KnobStyle'] = {
  Default: 0,
  Dark: 1,
  Light: 2
};

(globalThis as any)['NSScroller']['Part'] = (globalThis as any)['NSScroller']['Part'] || {};
(globalThis as any)['NSScroller']['Part'] = {
  NoPart: 0,
  DecrementPage: 1,
  Knob: 2,
  IncrementPage: 3,
  DecrementLine: 4,
  IncrementLine: 5,
  KnobSlot: 6
};

(globalThis as any)['NSScroller']['Style'] = (globalThis as any)['NSScroller']['Style'] || {};
(globalThis as any)['NSScroller']['Style'] = {
  Legacy: 0,
  Overlay: 1
};

(globalThis as any)['NSScroller']['UsableParts'] = (globalThis as any)['NSScroller']['UsableParts'] || {};
(globalThis as any)['NSScroller']['UsableParts'] = {
  NoScrollerParts: 0,
  OnlyScrollerArrows: 1,
  AllScrollerParts: 2
};


(globalThis as any)['NSScrubber'] = (globalThis as any)['NSScrubber'] || {};
(globalThis as any)['NSScrubber']['Alignment'] = (globalThis as any)['NSScrubber']['Alignment'] || {};
(globalThis as any)['NSScrubber']['Alignment'] = {
  None: 0,
  Leading: 1,
  Trailing: 2,
  Center: 3
};

(globalThis as any)['NSScrubber']['Mode'] = (globalThis as any)['NSScrubber']['Mode'] || {};
(globalThis as any)['NSScrubber']['Mode'] = {
  ixed: 0,
  ree: 1
};


(globalThis as any)['NSScrubberLayout'] = (globalThis as any)['NSScrubberLayout'] || {};

(globalThis as any)['NSSearchField'] = (globalThis as any)['NSSearchField'] || {};

(globalThis as any)['NSSearchFieldCell'] = (globalThis as any)['NSSearchFieldCell'] || {};

(globalThis as any)['NSSegmentedCell'] = (globalThis as any)['NSSegmentedCell'] || {};

(globalThis as any)['NSSegmentedControl'] = (globalThis as any)['NSSegmentedControl'] || {};
(globalThis as any)['NSSegmentedControl']['Distribution'] = (globalThis as any)['NSSegmentedControl']['Distribution'] || {};
(globalThis as any)['NSSegmentedControl']['Distribution'] = {
  t: 0,
  ll: 1,
  llEqually: 2,
  llProportionally: 3
};

(globalThis as any)['NSSegmentedControl']['Style'] = (globalThis as any)['NSSegmentedControl']['Style'] || {};
(globalThis as any)['NSSegmentedControl']['Style'] = {
  Automatic: 0,
  Rounded: 1,
  RoundRect: 3,
  TexturedSquare: 4,
  SmallSquare: 6,
  Separated: 8,
  TexturedRounded: 2,
  Capsule: 5
};

(globalThis as any)['NSSegmentedControl']['SwitchTracking'] = (globalThis as any)['NSSegmentedControl']['SwitchTracking'] || {};
(globalThis as any)['NSSegmentedControl']['SwitchTracking'] = {
  SelectOne: 0,
  SelectAny: 1,
  Momentary: 2,
  MomentaryAccelerator: 3
};



(globalThis as any)['NSShadow'] = (globalThis as any)['NSShadow'] || {};

(globalThis as any)['NSSharingService'] = (globalThis as any)['NSSharingService'] || {};
(globalThis as any)['NSSharingService']['CloudKitOptions'] = (globalThis as any)['NSSharingService']['CloudKitOptions'] || {};
(globalThis as any)['NSSharingService']['CloudKitOptions'] = {
  Standard: 0,
  AllowPublic: 1,
  AllowPrivate: 2,
  AllowReadOnly: 16,
  AllowReadWrite: 32
};

(globalThis as any)['NSSharingService']['SharingContentScope'] = (globalThis as any)['NSSharingService']['SharingContentScope'] || {};
(globalThis as any)['NSSharingService']['SharingContentScope'] = {
  Item: 0,
  Partial: 1,
  Full: 2
};


(globalThis as any)['NSSharingServicePickerToolbarItem'] = (globalThis as any)['NSSharingServicePickerToolbarItem'] || {};

(globalThis as any)['NSSharingServicePickerTouchBarItem'] = (globalThis as any)['NSSharingServicePickerTouchBarItem'] || {};

(globalThis as any)['NSSlider'] = (globalThis as any)['NSSlider'] || {};
(globalThis as any)['NSSlider']['SliderType'] = (globalThis as any)['NSSlider']['SliderType'] || {};
(globalThis as any)['NSSlider']['SliderType'] = {
  Linear: 0,
  Circular: 1
};

(globalThis as any)['NSSlider']['TickMarkPosition'] = (globalThis as any)['NSSlider']['TickMarkPosition'] || {};
(globalThis as any)['NSSlider']['TickMarkPosition'] = {
  Below: 0,
  Above: 1,
  Leading: 1,
  Trailing: 0
};


(globalThis as any)['NSSliderAccessory'] = (globalThis as any)['NSSliderAccessory'] || {};

(globalThis as any)['NSSliderCell'] = (globalThis as any)['NSSliderCell'] || {};
(globalThis as any)['NSSliderCell']['NSSlider'] = (globalThis as any)['NSSliderCell']['NSSlider'] || {};
(globalThis as any)['NSSliderCell']['NSSlider']['SliderType'] = (globalThis as any)['NSSliderCell']['NSSlider']['SliderType'] || {};
(globalThis as any)['NSSliderCell']['NSSlider']['SliderType'] = {
  Linear: 0,
  Circular: 1
};

(globalThis as any)['NSSliderCell']['NSSlider'] = (globalThis as any)['NSSliderCell']['NSSlider'] || {};
(globalThis as any)['NSSliderCell']['NSSlider']['TickMarkPosition'] = (globalThis as any)['NSSliderCell']['NSSlider']['TickMarkPosition'] || {};
(globalThis as any)['NSSliderCell']['NSSlider']['TickMarkPosition'] = {
  Below: 0,
  Above: 1,
  Leading: 1,
  Trailing: 0
};


(globalThis as any)['NSSliderTouchBarItem'] = (globalThis as any)['NSSliderTouchBarItem'] || {};

(globalThis as any)['NSSortDescriptor'] = (globalThis as any)['NSSortDescriptor'] || {};

(globalThis as any)['NSSound'] = (globalThis as any)['NSSound'] || {};

(globalThis as any)['NSSpeechRecognizer'] = (globalThis as any)['NSSpeechRecognizer'] || {};

(globalThis as any)['NSSpeechSynthesizer'] = (globalThis as any)['NSSpeechSynthesizer'] || {};
(globalThis as any)['NSSpeechSynthesizer']['Boundary'] = (globalThis as any)['NSSpeechSynthesizer']['Boundary'] || {};
(globalThis as any)['NSSpeechSynthesizer']['Boundary'] = {
  ImmediateBoundary: 0,
  WordBoundary: 1,
  SentenceBoundary: 2
};


(globalThis as any)['NSSpellChecker'] = (globalThis as any)['NSSpellChecker'] || {};
(globalThis as any)['NSSpellChecker']['CorrectionIndicatorType'] = (globalThis as any)['NSSpellChecker']['CorrectionIndicatorType'] || {};
(globalThis as any)['NSSpellChecker']['CorrectionIndicatorType'] = {
  Default: 0,
  Reversion: 1,
  Guesses: 2
};

(globalThis as any)['NSSpellChecker']['CorrectionResponse'] = (globalThis as any)['NSSpellChecker']['CorrectionResponse'] || {};
(globalThis as any)['NSSpellChecker']['CorrectionResponse'] = {
  None: 0,
  Accepted: 1,
  Rejected: 2,
  Ignored: 3,
  Edited: 4,
  Reverted: 5
};


(globalThis as any)['NSSpellServer'] = (globalThis as any)['NSSpellServer'] || {};

(globalThis as any)['NSSplitView'] = (globalThis as any)['NSSplitView'] || {};
(globalThis as any)['NSSplitView']['DividerStyle'] = (globalThis as any)['NSSplitView']['DividerStyle'] || {};
(globalThis as any)['NSSplitView']['DividerStyle'] = {
  Thick: 1,
  Thin: 2,
  PaneSplitter: 3
};


(globalThis as any)['NSSplitViewController'] = (globalThis as any)['NSSplitViewController'] || {};

(globalThis as any)['NSSplitViewItem'] = (globalThis as any)['NSSplitViewItem'] || {};
(globalThis as any)['NSSplitViewItem']['Behavior'] = (globalThis as any)['NSSplitViewItem']['Behavior'] || {};
(globalThis as any)['NSSplitViewItem']['Behavior'] = {
  Default: 0,
  Sidebar: 1,
  ContentList: 2
};

(globalThis as any)['NSSplitViewItem']['CollapseBehavior'] = (globalThis as any)['NSSplitViewItem']['CollapseBehavior'] || {};
(globalThis as any)['NSSplitViewItem']['CollapseBehavior'] = {
  Default: 0,
  PreferResizingSplitViewWithFixedSiblings: 1,
  PreferResizingSiblingsWithFixedSplitView: 2,
  UseConstraints: 3
};


(globalThis as any)['NSStackView'] = (globalThis as any)['NSStackView'] || {};
(globalThis as any)['NSStackView']['Distribution'] = (globalThis as any)['NSStackView']['Distribution'] || {};
(globalThis as any)['NSStackView']['Distribution'] = {
  GravityAreas: -1,
  Fill: 0,
  FillEqually: 1,
  FillProportionally: 2,
  EqualSpacing: 3,
  EqualCentering: 4
};

(globalThis as any)['NSStackView']['Gravity'] = (globalThis as any)['NSStackView']['Gravity'] || {};
(globalThis as any)['NSStackView']['Gravity'] = {
  Top: 1,
  Leading: 1,
  Center: 2,
  Bottom: 3,
  Trailing: 3
};


(globalThis as any)['NSStatusBar'] = (globalThis as any)['NSStatusBar'] || {};

(globalThis as any)['NSStatusBarButton'] = (globalThis as any)['NSStatusBarButton'] || {};

(globalThis as any)['NSStatusItem'] = (globalThis as any)['NSStatusItem'] || {};
(globalThis as any)['NSStatusItem']['Behavior'] = (globalThis as any)['NSStatusItem']['Behavior'] || {};
(globalThis as any)['NSStatusItem']['Behavior'] = {
  RemovalAllowed: 2,
  TerminationOnRemoval: 4
};


(globalThis as any)['NSStepper'] = (globalThis as any)['NSStepper'] || {};

(globalThis as any)['NSStepperCell'] = (globalThis as any)['NSStepperCell'] || {};

(globalThis as any)['NSStepperTouchBarItem'] = (globalThis as any)['NSStepperTouchBarItem'] || {};

(globalThis as any)['NSStoryboard'] = (globalThis as any)['NSStoryboard'] || {};

(globalThis as any)['NSStoryboardSegue'] = (globalThis as any)['NSStoryboardSegue'] || {};

(globalThis as any)['Stream'] = (globalThis as any)['Stream'] || {};
(globalThis as any)['Stream']['Event'] = (globalThis as any)['Stream']['Event'] || {};
(globalThis as any)['Stream']['Event'] = {
  None: 0,
  OpenCompleted: 1,
  HasBytesAvailable: 2,
  HasSpaceAvailable: 4,
  ErrorOccurred: 8,
  EndEncountered: 16
};

(globalThis as any)['Stream']['Status'] = (globalThis as any)['Stream']['Status'] || {};
(globalThis as any)['Stream']['Status'] = {
  NotOpen: 0,
  Opening: 1,
  Open: 2,
  Reading: 3,
  Writing: 4,
  AtEnd: 5,
  Closed: 6,
  Error: 7
};


(globalThis as any)['String'] = (globalThis as any)['String'] || {};
(globalThis as any)['String']['CompareOptions'] = (globalThis as any)['String']['CompareOptions'] || {};
(globalThis as any)['String']['CompareOptions'] = {
  CaseInsensitiveSearch: 1,
  LiteralSearch: 2,
  BackwardsSearch: 4,
  AnchoredSearch: 8,
  NumericSearch: 64,
  DiacriticInsensitiveSearch: 128,
  WidthInsensitiveSearch: 256,
  ForcedOrderingSearch: 512,
  RegularExpressionSearch: 1024
};

(globalThis as any)['String']['DrawingOptions'] = (globalThis as any)['String']['DrawingOptions'] || {};
(globalThis as any)['String']['DrawingOptions'] = {
  UsesLineFragmentOrigin: 1,
  UsesFontLeading: 2,
  UsesDeviceMetrics: 8,
  TruncatesLastVisibleLine: 32,
  DisableScreenFontSubstitution: 4,
  OneShot: 16
};

(globalThis as any)['String']['EncodingConversionOptions'] = (globalThis as any)['String']['EncodingConversionOptions'] || {};
(globalThis as any)['String']['EncodingConversionOptions'] = {
  AllowLossy: 1,
  ExternalRepresentation: 2
};

(globalThis as any)['String']['EnumerationOptions'] = (globalThis as any)['String']['EnumerationOptions'] || {};
(globalThis as any)['String']['EnumerationOptions'] = {
  ByLines: 0,
  ByParagraphs: 1,
  ByComposedCharacterSequences: 2,
  ByWords: 3,
  BySentences: 4,
  Reverse: 256,
  SubstringNotRequired: 512,
  Localized: 1024
};


(globalThis as any)['NSStringDrawing'] = (globalThis as any)['NSStringDrawing'] || {};
(globalThis as any)['NSStringDrawing']['String'] = (globalThis as any)['NSStringDrawing']['String'] || {};
(globalThis as any)['NSStringDrawing']['String']['DrawingOptions'] = (globalThis as any)['NSStringDrawing']['String']['DrawingOptions'] || {};
(globalThis as any)['NSStringDrawing']['String']['DrawingOptions'] = {
  UsesLineFragmentOrigin: 1,
  UsesFontLeading: 2,
  UsesDeviceMetrics: 8,
  TruncatesLastVisibleLine: 32,
  DisableScreenFontSubstitution: 4,
  OneShot: 16
};


(globalThis as any)['NSSwitch'] = (globalThis as any)['NSSwitch'] || {};

(globalThis as any)['NSTabView'] = (globalThis as any)['NSTabView'] || {};
(globalThis as any)['NSTabView']['TabPosition'] = (globalThis as any)['NSTabView']['TabPosition'] || {};
(globalThis as any)['NSTabView']['TabPosition'] = {
  None: 0,
  Top: 1,
  Left: 2,
  Bottom: 3,
  Right: 4
};

(globalThis as any)['NSTabView']['TabType'] = (globalThis as any)['NSTabView']['TabType'] || {};
(globalThis as any)['NSTabView']['TabType'] = {
  TopTabsBezelBorder: 0,
  LeftTabsBezelBorder: 1,
  BottomTabsBezelBorder: 2,
  RightTabsBezelBorder: 3,
  NoTabsBezelBorder: 4,
  NoTabsLineBorder: 5,
  NoTabsNoBorder: 6
};

(globalThis as any)['NSTabView']['TabViewBorderType'] = (globalThis as any)['NSTabView']['TabViewBorderType'] || {};
(globalThis as any)['NSTabView']['TabViewBorderType'] = {
  None: 0,
  Line: 1,
  Bezel: 2
};


(globalThis as any)['NSTabViewController'] = (globalThis as any)['NSTabViewController'] || {};
(globalThis as any)['NSTabViewController']['TabStyle'] = (globalThis as any)['NSTabViewController']['TabStyle'] || {};
(globalThis as any)['NSTabViewController']['TabStyle'] = {
  SegmentedControlOnTop: 0,
  SegmentedControlOnBottom: 1,
  Toolbar: 2,
  Unspecified: -1
};


(globalThis as any)['NSTabViewItem'] = (globalThis as any)['NSTabViewItem'] || {};
(globalThis as any)['NSTabViewItem']['State'] = (globalThis as any)['NSTabViewItem']['State'] || {};
(globalThis as any)['NSTabViewItem']['State'] = {
  SelectedTab: 0,
  BackgroundTab: 1,
  PressedTab: 2
};


(globalThis as any)['NSTableCellView'] = (globalThis as any)['NSTableCellView'] || {};

(globalThis as any)['NSTableColumn'] = (globalThis as any)['NSTableColumn'] || {};
(globalThis as any)['NSTableColumn']['ResizingOptions'] = (globalThis as any)['NSTableColumn']['ResizingOptions'] || {};
(globalThis as any)['NSTableColumn']['ResizingOptions'] = {
  NoResizing: 0,
  AutoresizingMask: 1,
  UserResizingMask: 2
};


(globalThis as any)['NSTableHeaderCell'] = (globalThis as any)['NSTableHeaderCell'] || {};

(globalThis as any)['NSTableHeaderView'] = (globalThis as any)['NSTableHeaderView'] || {};

(globalThis as any)['NSTableRowView'] = (globalThis as any)['NSTableRowView'] || {};

(globalThis as any)['NSTableView'] = (globalThis as any)['NSTableView'] || {};
(globalThis as any)['NSTableView']['AnimationOptions'] = (globalThis as any)['NSTableView']['AnimationOptions'] || {};
(globalThis as any)['NSTableView']['AnimationOptions'] = {
  EffectNone: 0,
  EffectFade: 1,
  EffectGap: 2,
  SlideUp: 16,
  SlideDown: 32,
  SlideLeft: 48,
  SlideRight: 64
};

(globalThis as any)['NSTableView']['ColumnAutoresizingStyle'] = (globalThis as any)['NSTableView']['ColumnAutoresizingStyle'] || {};
(globalThis as any)['NSTableView']['ColumnAutoresizingStyle'] = {
  NoColumnAutoresizing: 0,
  UniformColumnAutoresizingStyle: 1,
  SequentialColumnAutoresizingStyle: 2,
  ReverseSequentialColumnAutoresizingStyle: 3,
  LastColumnOnlyAutoresizingStyle: 4,
  FirstColumnOnlyAutoresizingStyle: 5
};

(globalThis as any)['NSTableView']['DraggingDestinationFeedbackStyle'] = (globalThis as any)['NSTableView']['DraggingDestinationFeedbackStyle'] || {};
(globalThis as any)['NSTableView']['DraggingDestinationFeedbackStyle'] = {
  None: -1,
  Regular: 0,
  SourceList: 1,
  Gap: 2
};

(globalThis as any)['NSTableView']['DropOperation'] = (globalThis as any)['NSTableView']['DropOperation'] || {};
(globalThis as any)['NSTableView']['DropOperation'] = {
  On: 0,
  Above: 1
};

(globalThis as any)['NSTableView']['GridLineStyle'] = (globalThis as any)['NSTableView']['GridLineStyle'] || {};
(globalThis as any)['NSTableView']['GridLineStyle'] = {
  GridNone: 0,
  SolidVerticalGridLineMask: 1,
  SolidHorizontalGridLineMask: 2,
  DashedHorizontalGridLineMask: 8
};

(globalThis as any)['NSTableView']['RowActionEdge'] = (globalThis as any)['NSTableView']['RowActionEdge'] || {};
(globalThis as any)['NSTableView']['RowActionEdge'] = {
  Leading: 0,
  Trailing: 1
};

(globalThis as any)['NSTableView']['RowSizeStyle'] = (globalThis as any)['NSTableView']['RowSizeStyle'] || {};
(globalThis as any)['NSTableView']['RowSizeStyle'] = {
  Default: -1,
  Custom: 0,
  Small: 1,
  Medium: 2,
  Large: 3
};

(globalThis as any)['NSTableView']['SelectionHighlightStyle'] = (globalThis as any)['NSTableView']['SelectionHighlightStyle'] || {};
(globalThis as any)['NSTableView']['SelectionHighlightStyle'] = {
  None: -1,
  Regular: 0,
  SourceList: 1
};


(globalThis as any)['NSTableViewRowAction'] = (globalThis as any)['NSTableViewRowAction'] || {};
(globalThis as any)['NSTableViewRowAction']['Style'] = (globalThis as any)['NSTableViewRowAction']['Style'] || {};
(globalThis as any)['NSTableViewRowAction']['Style'] = {
  Regular: 0,
  Destructive: 1
};


(globalThis as any)['Process'] = (globalThis as any)['Process'] || {};
(globalThis as any)['Process']['TerminationReason'] = (globalThis as any)['Process']['TerminationReason'] || {};
(globalThis as any)['Process']['TerminationReason'] = {
  Exit: 1,
  UncaughtSignal: 2
};


(globalThis as any)['NSText'] = (globalThis as any)['NSText'] || {};
(globalThis as any)['NSText']['NSTextAlignment'] = (globalThis as any)['NSText']['NSTextAlignment'] || {};
(globalThis as any)['NSText']['NSTextAlignment'] = {
  Left: 0,
  Right: 1,
  Center: 2,
  Justified: 3,
  Natural: 4
};

(globalThis as any)['NSText']['NSTextMovement'] = (globalThis as any)['NSText']['NSTextMovement'] || {};
(globalThis as any)['NSText']['NSTextMovement'] = {
  Return: 16,
  Tab: 17,
  Backtab: 18,
  Left: 19,
  Right: 20,
  Up: 21,
  Down: 22,
  Cancel: 23,
  Other: 0
};

(globalThis as any)['NSText']['NSWritingDirection'] = (globalThis as any)['NSText']['NSWritingDirection'] || {};
(globalThis as any)['NSText']['NSWritingDirection'] = {
  Natural: -1,
  LeftToRight: 0,
  RightToLeft: 1
};


(globalThis as any)['NSTextAlternatives'] = (globalThis as any)['NSTextAlternatives'] || {};

(globalThis as any)['NSTextAttachment'] = (globalThis as any)['NSTextAttachment'] || {};

(globalThis as any)['NSTextCheckingClient'] = (globalThis as any)['NSTextCheckingClient'] || {};
(globalThis as any)['NSTextCheckingClient']['NSTextInputTraitType'] = (globalThis as any)['NSTextCheckingClient']['NSTextInputTraitType'] || {};
(globalThis as any)['NSTextCheckingClient']['NSTextInputTraitType'] = {
  Default: 0,
  No: 1,
  Yes: 2
};


(globalThis as any)['NSTextCheckingController'] = (globalThis as any)['NSTextCheckingController'] || {};

(globalThis as any)['NSTextCheckingResult'] = (globalThis as any)['NSTextCheckingResult'] || {};
(globalThis as any)['NSTextCheckingResult']['CheckingType'] = (globalThis as any)['NSTextCheckingResult']['CheckingType'] || {};
(globalThis as any)['NSTextCheckingResult']['CheckingType'] = {
  Orthography: 1,
  Spelling: 2,
  Grammar: 4,
  Date: 8,
  Address: 16,
  Link: 32,
  Quote: 64,
  Dash: 128,
  Replacement: 256,
  Correction: 512,
  RegularExpression: 1024,
  PhoneNumber: 2048,
  TransitInformation: 4096
};


(globalThis as any)['NSTextContainer'] = (globalThis as any)['NSTextContainer'] || {};
(globalThis as any)['NSTextContainer']['NSLineMovementDirection'] = (globalThis as any)['NSTextContainer']['NSLineMovementDirection'] || {};
(globalThis as any)['NSTextContainer']['NSLineMovementDirection'] = {
  DoesntMove: 0,
  MovesLeft: 1,
  MovesRight: 2,
  MovesDown: 3,
  MovesUp: 4
};

(globalThis as any)['NSTextContainer']['NSLineSweepDirection'] = (globalThis as any)['NSTextContainer']['NSLineSweepDirection'] || {};
(globalThis as any)['NSTextContainer']['NSLineSweepDirection'] = {
  Left: 0,
  Right: 1,
  Down: 2,
  Up: 3
};


(globalThis as any)['NSTextField'] = (globalThis as any)['NSTextField'] || {};
(globalThis as any)['NSTextField']['BezelStyle'] = (globalThis as any)['NSTextField']['BezelStyle'] || {};
(globalThis as any)['NSTextField']['BezelStyle'] = {
  SquareBezel: 0,
  RoundedBezel: 1
};


(globalThis as any)['NSTextFieldCell'] = (globalThis as any)['NSTextFieldCell'] || {};
(globalThis as any)['NSTextFieldCell']['NSTextField'] = (globalThis as any)['NSTextFieldCell']['NSTextField'] || {};
(globalThis as any)['NSTextFieldCell']['NSTextField']['BezelStyle'] = (globalThis as any)['NSTextFieldCell']['NSTextField']['BezelStyle'] || {};
(globalThis as any)['NSTextFieldCell']['NSTextField']['BezelStyle'] = {
  SquareBezel: 0,
  RoundedBezel: 1
};


(globalThis as any)['NSTextFinder'] = (globalThis as any)['NSTextFinder'] || {};
(globalThis as any)['NSTextFinder']['Action'] = (globalThis as any)['NSTextFinder']['Action'] || {};
(globalThis as any)['NSTextFinder']['Action'] = {
  ShowFindInterface: 1,
  NextMatch: 2,
  PreviousMatch: 3,
  ReplaceAll: 4,
  Replace: 5,
  ReplaceAndFind: 6,
  SetSearchString: 7,
  ReplaceAllInSelection: 8,
  SelectAll: 9,
  SelectAllInSelection: 10,
  HideFindInterface: 11,
  ShowReplaceInterface: 12,
  HideReplaceInterface: 13
};

(globalThis as any)['NSTextFinder']['MatchingType'] = (globalThis as any)['NSTextFinder']['MatchingType'] || {};
(globalThis as any)['NSTextFinder']['MatchingType'] = {
  Contains: 0,
  StartsWith: 1,
  FullWord: 2,
  EndsWith: 3
};


(globalThis as any)['NSTextInputClient'] = (globalThis as any)['NSTextInputClient'] || {};

(globalThis as any)['NSTextInputContext'] = (globalThis as any)['NSTextInputContext'] || {};

(globalThis as any)['NSTextList'] = (globalThis as any)['NSTextList'] || {};
(globalThis as any)['NSTextList']['Options'] = (globalThis as any)['NSTextList']['Options'] || {};
(globalThis as any)['NSTextList']['Options'] = {
  NSTextListPrependEnclosingMarker: 1
};


(globalThis as any)['NSTextStorage'] = (globalThis as any)['NSTextStorage'] || {};
(globalThis as any)['NSTextStorage']['NSTextStorageEditActions'] = (globalThis as any)['NSTextStorage']['NSTextStorageEditActions'] || {};
(globalThis as any)['NSTextStorage']['NSTextStorageEditActions'] = {
  Attributes: 1,
  Characters: 2
};


(globalThis as any)['NSTextTable'] = (globalThis as any)['NSTextTable'] || {};
(globalThis as any)['NSTextTable']['NSTextBlock'] = (globalThis as any)['NSTextTable']['NSTextBlock'] || {};
(globalThis as any)['NSTextTable']['NSTextBlock']['Dimension'] = (globalThis as any)['NSTextTable']['NSTextBlock']['Dimension'] || {};
(globalThis as any)['NSTextTable']['NSTextBlock']['Dimension'] = {
  Width: 0,
  MinimumWidth: 1,
  MaximumWidth: 2,
  Height: 4,
  MinimumHeight: 5,
  MaximumHeight: 6
};

(globalThis as any)['NSTextTable']['NSTextBlock'] = (globalThis as any)['NSTextTable']['NSTextBlock'] || {};
(globalThis as any)['NSTextTable']['NSTextBlock']['Layer'] = (globalThis as any)['NSTextTable']['NSTextBlock']['Layer'] || {};
(globalThis as any)['NSTextTable']['NSTextBlock']['Layer'] = {
  Padding: -1,
  Border: 0,
  Margin: 1
};

(globalThis as any)['NSTextTable']['NSTextBlock'] = (globalThis as any)['NSTextTable']['NSTextBlock'] || {};
(globalThis as any)['NSTextTable']['NSTextBlock']['ValueType'] = (globalThis as any)['NSTextTable']['NSTextBlock']['ValueType'] || {};
(globalThis as any)['NSTextTable']['NSTextBlock']['ValueType'] = {
  AbsoluteValueType: 0,
  PercentageValueType: 1
};

(globalThis as any)['NSTextTable']['NSTextBlock'] = (globalThis as any)['NSTextTable']['NSTextBlock'] || {};
(globalThis as any)['NSTextTable']['NSTextBlock']['VerticalAlignment'] = (globalThis as any)['NSTextTable']['NSTextBlock']['VerticalAlignment'] || {};
(globalThis as any)['NSTextTable']['NSTextBlock']['VerticalAlignment'] = {
  TopAlignment: 0,
  MiddleAlignment: 1,
  BottomAlignment: 2,
  BaselineAlignment: 3
};

(globalThis as any)['NSTextTable']['LayoutAlgorithm'] = (globalThis as any)['NSTextTable']['LayoutAlgorithm'] || {};
(globalThis as any)['NSTextTable']['LayoutAlgorithm'] = {
  AutomaticLayoutAlgorithm: 0,
  FixedLayoutAlgorithm: 1
};


(globalThis as any)['NSTextView'] = (globalThis as any)['NSTextView'] || {};
(globalThis as any)['NSTextView']['NSFindPanelAction'] = (globalThis as any)['NSTextView']['NSFindPanelAction'] || {};
(globalThis as any)['NSTextView']['NSFindPanelAction'] = {
  ShowFindPanel: 1,
  Next: 2,
  Previous: 3,
  ReplaceAll: 4,
  Replace: 5,
  ReplaceAndFind: 6,
  SetFindString: 7,
  ReplaceAllInSelection: 8,
  SelectAll: 9,
  SelectAllInSelection: 10
};

(globalThis as any)['NSTextView']['NSFindPanelSubstringMatchType'] = (globalThis as any)['NSTextView']['NSFindPanelSubstringMatchType'] || {};
(globalThis as any)['NSTextView']['NSFindPanelSubstringMatchType'] = {
  Contains: 0,
  StartsWith: 1,
  FullWord: 2,
  EndsWith: 3
};

(globalThis as any)['NSTextView']['NSSelectionAffinity'] = (globalThis as any)['NSTextView']['NSSelectionAffinity'] || {};
(globalThis as any)['NSTextView']['NSSelectionAffinity'] = {
  Upstream: 0,
  Downstream: 1
};

(globalThis as any)['NSTextView']['NSSelectionGranularity'] = (globalThis as any)['NSTextView']['NSSelectionGranularity'] || {};
(globalThis as any)['NSTextView']['NSSelectionGranularity'] = {
  Character: 0,
  Word: 1,
  Paragraph: 2
};


(globalThis as any)['Thread'] = (globalThis as any)['Thread'] || {};

(globalThis as any)['TimeZone'] = (globalThis as any)['TimeZone'] || {};
(globalThis as any)['TimeZone']['NameStyle'] = (globalThis as any)['TimeZone']['NameStyle'] || {};
(globalThis as any)['TimeZone']['NameStyle'] = {
  Standard: 0,
  ShortStandard: 1,
  DaylightSaving: 2,
  ShortDaylightSaving: 3,
  Generic: 4,
  ShortGeneric: 5
};


(globalThis as any)['Timer'] = (globalThis as any)['Timer'] || {};

(globalThis as any)['NSTitlebarAccessoryViewController'] = (globalThis as any)['NSTitlebarAccessoryViewController'] || {};

(globalThis as any)['NSTokenField'] = (globalThis as any)['NSTokenField'] || {};
(globalThis as any)['NSTokenField']['TokenStyle'] = (globalThis as any)['NSTokenField']['TokenStyle'] || {};
(globalThis as any)['NSTokenField']['TokenStyle'] = {
  Default: 0,
  None: 1,
  Rounded: 2,
  Squared: 3,
  PlainSquared: 4
};


(globalThis as any)['NSTokenFieldCell'] = (globalThis as any)['NSTokenFieldCell'] || {};
(globalThis as any)['NSTokenFieldCell']['NSTokenField'] = (globalThis as any)['NSTokenFieldCell']['NSTokenField'] || {};
(globalThis as any)['NSTokenFieldCell']['NSTokenField']['TokenStyle'] = (globalThis as any)['NSTokenFieldCell']['NSTokenField']['TokenStyle'] || {};
(globalThis as any)['NSTokenFieldCell']['NSTokenField']['TokenStyle'] = {
  Default: 0,
  None: 1,
  Rounded: 2,
  Squared: 3,
  PlainSquared: 4
};


(globalThis as any)['NSToolbar'] = (globalThis as any)['NSToolbar'] || {};
(globalThis as any)['NSToolbar']['DisplayMode'] = (globalThis as any)['NSToolbar']['DisplayMode'] || {};
(globalThis as any)['NSToolbar']['DisplayMode'] = {
  Default: 0,
  IconAndLabel: 1,
  IconOnly: 2,
  LabelOnly: 3
};

(globalThis as any)['NSToolbar']['SizeMode'] = (globalThis as any)['NSToolbar']['SizeMode'] || {};
(globalThis as any)['NSToolbar']['SizeMode'] = {
  Default: 0,
  Regular: 1,
  Small: 2
};


(globalThis as any)['NSToolbarItem'] = (globalThis as any)['NSToolbarItem'] || {};

(globalThis as any)['NSToolbarItemGroup'] = (globalThis as any)['NSToolbarItemGroup'] || {};
(globalThis as any)['NSToolbarItemGroup']['ControlRepresentation'] = (globalThis as any)['NSToolbarItemGroup']['ControlRepresentation'] || {};
(globalThis as any)['NSToolbarItemGroup']['ControlRepresentation'] = {
  Automatic: 0,
  Expanded: 1,
  Collapsed: 2
};

(globalThis as any)['NSToolbarItemGroup']['SelectionMode'] = (globalThis as any)['NSToolbarItemGroup']['SelectionMode'] || {};
(globalThis as any)['NSToolbarItemGroup']['SelectionMode'] = {
  SelectOne: 0,
  SelectAny: 1,
  Momentary: 2
};


(globalThis as any)['NSTouch'] = (globalThis as any)['NSTouch'] || {};
(globalThis as any)['NSTouch']['Phase'] = (globalThis as any)['NSTouch']['Phase'] || {};
(globalThis as any)['NSTouch']['Phase'] = {
  Began: 1,
  Moved: 2,
  Stationary: 4,
  Ended: 8,
  Cancelled: 16,
  Touching: 7,
  Any: -1
};

(globalThis as any)['NSTouch']['TouchType'] = (globalThis as any)['NSTouch']['TouchType'] || {};
(globalThis as any)['NSTouch']['TouchType'] = {
  Direct: 0,
  Indirect: 1
};

(globalThis as any)['NSTouch']['TouchTypeMask'] = (globalThis as any)['NSTouch']['TouchTypeMask'] || {};
(globalThis as any)['NSTouch']['TouchTypeMask'] = {
  Direct: 1,
  Indirect: 2
};


(globalThis as any)['NSTouchBar'] = (globalThis as any)['NSTouchBar'] || {};

(globalThis as any)['NSTouchBarItem'] = (globalThis as any)['NSTouchBarItem'] || {};

(globalThis as any)['NSTrackingArea'] = (globalThis as any)['NSTrackingArea'] || {};
(globalThis as any)['NSTrackingArea']['Options'] = (globalThis as any)['NSTrackingArea']['Options'] || {};
(globalThis as any)['NSTrackingArea']['Options'] = {
  MouseEnteredAndExited: 1,
  MouseMoved: 2,
  CursorUpdate: 4,
  ActiveWhenFirstResponder: 16,
  ActiveInKeyWindow: 32,
  ActiveInActiveApp: 64,
  ActiveAlways: 128,
  AssumeInside: 256,
  InVisibleRect: 512,
  EnabledDuringMouseDrag: 1024
};


(globalThis as any)['NSTreeController'] = (globalThis as any)['NSTreeController'] || {};

(globalThis as any)['NSTreeNode'] = (globalThis as any)['NSTreeNode'] || {};

(globalThis as any)['NSTypesetter'] = (globalThis as any)['NSTypesetter'] || {};
(globalThis as any)['NSTypesetter']['NSTypesetterControlCharacterAction'] = (globalThis as any)['NSTypesetter']['NSTypesetterControlCharacterAction'] || {};
(globalThis as any)['NSTypesetter']['NSTypesetterControlCharacterAction'] = {
  ZeroAdvancementAction: 1,
  WhitespaceAction: 2,
  HorizontalTabAction: 4,
  LineBreakAction: 8,
  ParagraphBreakAction: 16,
  ContainerBreakAction: 32
};


(globalThis as any)['URL'] = (globalThis as any)['URL'] || {};
(globalThis as any)['URL']['BookmarkCreationOptions'] = (globalThis as any)['URL']['BookmarkCreationOptions'] || {};
(globalThis as any)['URL']['BookmarkCreationOptions'] = {
  PreferFileIDResolution: 256,
  MinimalBookmark: 512,
  SuitableForBookmarkFile: 1024,
  WithSecurityScope: 2048,
  SecurityScopeAllowOnlyReadAccess: 4096
};

(globalThis as any)['URL']['BookmarkResolutionOptions'] = (globalThis as any)['URL']['BookmarkResolutionOptions'] || {};
(globalThis as any)['URL']['BookmarkResolutionOptions'] = {
  outUI: 256,
  outMounting: 512,
  SecurityScope: 1024
};


(globalThis as any)['URLAuthenticationChallenge'] = (globalThis as any)['URLAuthenticationChallenge'] || {};

(globalThis as any)['URLCache'] = (globalThis as any)['URLCache'] || {};
(globalThis as any)['URLCache']['StoragePolicy'] = (globalThis as any)['URLCache']['StoragePolicy'] || {};
(globalThis as any)['URLCache']['StoragePolicy'] = {
  Allowed: 0,
  AllowedInMemoryOnly: 1,
  NotAllowed: 2
};


(globalThis as any)['NSURLConnection'] = (globalThis as any)['NSURLConnection'] || {};

(globalThis as any)['URLCredential'] = (globalThis as any)['URLCredential'] || {};
(globalThis as any)['URLCredential']['Persistence'] = (globalThis as any)['URLCredential']['Persistence'] || {};
(globalThis as any)['URLCredential']['Persistence'] = {
  None: 0,
  ForSession: 1,
  Permanent: 2,
  Synchronizable: 3
};


(globalThis as any)['URLCredentialStorage'] = (globalThis as any)['URLCredentialStorage'] || {};

(globalThis as any)['NSURLDownload'] = (globalThis as any)['NSURLDownload'] || {};

(globalThis as any)['NSURLError'] = (globalThis as any)['NSURLError'] || {};
(globalThis as any)['NSURLError']['NSURLErrorNetworkUnavailableReason'] = (globalThis as any)['NSURLError']['NSURLErrorNetworkUnavailableReason'] || {};
(globalThis as any)['NSURLError']['NSURLErrorNetworkUnavailableReason'] = {
  Cellular: 0,
  Expensive: 1,
  Constrained: 2
};


(globalThis as any)['NSURLHandle'] = (globalThis as any)['NSURLHandle'] || {};
(globalThis as any)['NSURLHandle']['Status'] = (globalThis as any)['NSURLHandle']['Status'] || {};
(globalThis as any)['NSURLHandle']['Status'] = {
  NotLoaded: 0,
  LoadSucceeded: 1,
  LoadInProgress: 2,
  LoadFailed: 3
};


(globalThis as any)['URLProtectionSpace'] = (globalThis as any)['URLProtectionSpace'] || {};

(globalThis as any)['URLProtocol'] = (globalThis as any)['URLProtocol'] || {};

(globalThis as any)['URLRequest'] = (globalThis as any)['URLRequest'] || {};
(globalThis as any)['URLRequest']['CachePolicy'] = (globalThis as any)['URLRequest']['CachePolicy'] || {};
(globalThis as any)['URLRequest']['CachePolicy'] = {
  UseProtocolCachePolicy: 0,
  ReloadIgnoringLocalCacheData: 1,
  ReloadIgnoringLocalAndRemoteCacheData: 4,
  ReloadIgnoringCacheData: 1,
  ReturnCacheDataElseLoad: 2,
  ReturnCacheDataDontLoad: 3,
  ReloadRevalidatingCacheData: 5
};

(globalThis as any)['URLRequest']['NetworkServiceType'] = (globalThis as any)['URLRequest']['NetworkServiceType'] || {};
(globalThis as any)['URLRequest']['NetworkServiceType'] = {
  Default: 0,
  VoIP: 1,
  Video: 2,
  Background: 3,
  Voice: 4,
  ResponsiveData: 6,
  AVStreaming: 8,
  ResponsiveAV: 9,
  CallSignaling: 11
};


(globalThis as any)['URLResponse'] = (globalThis as any)['URLResponse'] || {};

(globalThis as any)['URLSession'] = (globalThis as any)['URLSession'] || {};
(globalThis as any)['URLSession']['URLSessionTask'] = (globalThis as any)['URLSession']['URLSessionTask'] || {};
(globalThis as any)['URLSession']['URLSessionTask']['State'] = (globalThis as any)['URLSession']['URLSessionTask']['State'] || {};
(globalThis as any)['URLSession']['URLSessionTask']['State'] = {
  Running: 0,
  Suspended: 1,
  Canceling: 2,
  Completed: 3
};

(globalThis as any)['URLSession']['URLSessionTaskMetrics'] = (globalThis as any)['URLSession']['URLSessionTaskMetrics'] || {};
(globalThis as any)['URLSession']['URLSessionTaskMetrics']['ResourceFetchType'] = (globalThis as any)['URLSession']['URLSessionTaskMetrics']['ResourceFetchType'] || {};
(globalThis as any)['URLSession']['URLSessionTaskMetrics']['ResourceFetchType'] = {
  Unknown: 0,
  NetworkLoad: 1,
  ServerPush: 2,
  LocalCache: 3
};

(globalThis as any)['URLSession']['URLSessionWebSocketTask'] = (globalThis as any)['URLSession']['URLSessionWebSocketTask'] || {};
(globalThis as any)['URLSession']['URLSessionWebSocketTask']['CloseCode'] = (globalThis as any)['URLSession']['URLSessionWebSocketTask']['CloseCode'] || {};
(globalThis as any)['URLSession']['URLSessionWebSocketTask']['CloseCode'] = {
  Invalid: 0,
  NormalClosure: 1000,
  GoingAway: 1001,
  ProtocolError: 1002,
  UnsupportedData: 1003,
  NoStatusReceived: 1005,
  AbnormalClosure: 1006,
  InvalidFramePayloadData: 1007,
  PolicyViolation: 1008,
  MessageTooBig: 1009,
  MandatoryExtensionMissing: 1010,
  InternalServerError: 1011,
  TLSHandshakeFailure: 1015
};

(globalThis as any)['URLSession']['AuthChallengeDisposition'] = (globalThis as any)['URLSession']['AuthChallengeDisposition'] || {};
(globalThis as any)['URLSession']['AuthChallengeDisposition'] = {
  UseCredential: 0,
  PerformDefaultHandling: 1,
  CancelAuthenticationChallenge: 2,
  RejectProtectionSpace: 3
};

(globalThis as any)['URLSession']['NSURLSessionDelayedRequestDisposition'] = (globalThis as any)['URLSession']['NSURLSessionDelayedRequestDisposition'] || {};
(globalThis as any)['URLSession']['NSURLSessionDelayedRequestDisposition'] = {
  ContinueLoading: 0,
  UseNewRequest: 1,
  Cancel: 2
};

(globalThis as any)['URLSession']['NSURLSessionMultipathServiceType'] = (globalThis as any)['URLSession']['NSURLSessionMultipathServiceType'] || {};
(globalThis as any)['URLSession']['NSURLSessionMultipathServiceType'] = {
  None: 0,
  Handover: 1,
  Interactive: 2,
  Aggregate: 3
};

(globalThis as any)['URLSession']['NSURLSessionWebSocketMessageType'] = (globalThis as any)['URLSession']['NSURLSessionWebSocketMessageType'] || {};
(globalThis as any)['URLSession']['NSURLSessionWebSocketMessageType'] = {
  Data: 0,
  String: 1
};

(globalThis as any)['URLSession']['ResponseDisposition'] = (globalThis as any)['URLSession']['ResponseDisposition'] || {};
(globalThis as any)['URLSession']['ResponseDisposition'] = {
  Cancel: 0,
  Allow: 1,
  BecomeDownload: 2,
  BecomeStream: 3
};


(globalThis as any)['UUID'] = (globalThis as any)['UUID'] || {};

(globalThis as any)['NSUbiquitousKeyValueStore'] = (globalThis as any)['NSUbiquitousKeyValueStore'] || {};

(globalThis as any)['UndoManager'] = (globalThis as any)['UndoManager'] || {};

(globalThis as any)['Unit'] = (globalThis as any)['Unit'] || {};

(globalThis as any)['NSUserActivity'] = (globalThis as any)['NSUserActivity'] || {};

(globalThis as any)['UserDefaults'] = (globalThis as any)['UserDefaults'] || {};

(globalThis as any)['NSUserDefaultsController'] = (globalThis as any)['NSUserDefaultsController'] || {};

(globalThis as any)['NSUserInterfaceCompression'] = (globalThis as any)['NSUserInterfaceCompression'] || {};

(globalThis as any)['NSUserInterfaceItemIdentification'] = (globalThis as any)['NSUserInterfaceItemIdentification'] || {};

(globalThis as any)['NSUserInterfaceItemSearching'] = (globalThis as any)['NSUserInterfaceItemSearching'] || {};

(globalThis as any)['NSUserInterfaceLayout'] = (globalThis as any)['NSUserInterfaceLayout'] || {};
(globalThis as any)['NSUserInterfaceLayout']['NSUserInterfaceLayoutDirection'] = (globalThis as any)['NSUserInterfaceLayout']['NSUserInterfaceLayoutDirection'] || {};
(globalThis as any)['NSUserInterfaceLayout']['NSUserInterfaceLayoutDirection'] = {
  LeftToRight: 0,
  RightToLeft: 1
};

(globalThis as any)['NSUserInterfaceLayout']['NSUserInterfaceLayoutOrientation'] = (globalThis as any)['NSUserInterfaceLayout']['NSUserInterfaceLayoutOrientation'] || {};
(globalThis as any)['NSUserInterfaceLayout']['NSUserInterfaceLayoutOrientation'] = {
  Horizontal: 0,
  Vertical: 1
};


(globalThis as any)['NSUserNotification'] = (globalThis as any)['NSUserNotification'] || {};
(globalThis as any)['NSUserNotification']['ActivationType'] = (globalThis as any)['NSUserNotification']['ActivationType'] || {};
(globalThis as any)['NSUserNotification']['ActivationType'] = {
  None: 0,
  ContentsClicked: 1,
  ActionButtonClicked: 2,
  Replied: 3,
  AdditionalActionClicked: 4
};


(globalThis as any)['NSUserScriptTask'] = (globalThis as any)['NSUserScriptTask'] || {};

(globalThis as any)['NSValue'] = (globalThis as any)['NSValue'] || {};

(globalThis as any)['ValueTransformer'] = (globalThis as any)['ValueTransformer'] || {};

(globalThis as any)['NSView'] = (globalThis as any)['NSView'] || {};
(globalThis as any)['NSView']['AutoresizingMask'] = (globalThis as any)['NSView']['AutoresizingMask'] || {};
(globalThis as any)['NSView']['AutoresizingMask'] = {
  NotSizable: 0,
  MinXMargin: 1,
  WidthSizable: 2,
  MaxXMargin: 4,
  MinYMargin: 8,
  HeightSizable: 16,
  MaxYMargin: 32
};

(globalThis as any)['NSView']['BackgroundStyle'] = (globalThis as any)['NSView']['BackgroundStyle'] || {};
(globalThis as any)['NSView']['BackgroundStyle'] = {
  Normal: 0,
  Emphasized: 1,
  Raised: 2,
  Lowered: 3
};

(globalThis as any)['NSView']['LayerContentsPlacement'] = (globalThis as any)['NSView']['LayerContentsPlacement'] || {};
(globalThis as any)['NSView']['LayerContentsPlacement'] = {
  ScaleAxesIndependently: 0,
  ScaleProportionallyToFit: 1,
  ScaleProportionallyToFill: 2,
  Center: 3,
  Top: 4,
  TopRight: 5,
  Right: 6,
  BottomRight: 7,
  Bottom: 8,
  BottomLeft: 9,
  Left: 10,
  TopLeft: 11
};

(globalThis as any)['NSView']['LayerContentsRedrawPolicy'] = (globalThis as any)['NSView']['LayerContentsRedrawPolicy'] || {};
(globalThis as any)['NSView']['LayerContentsRedrawPolicy'] = {
  Never: 0,
  OnSetNeedsDisplay: 1,
  DuringViewResize: 2,
  BeforeViewResize: 3,
  Crossfade: 4
};

(globalThis as any)['NSView']['NSBorderType'] = (globalThis as any)['NSView']['NSBorderType'] || {};
(globalThis as any)['NSView']['NSBorderType'] = {
  NoBorder: 0,
  LineBorder: 1,
  BezelBorder: 2,
  GrooveBorder: 3
};


(globalThis as any)['NSViewController'] = (globalThis as any)['NSViewController'] || {};
(globalThis as any)['NSViewController']['TransitionOptions'] = (globalThis as any)['NSViewController']['TransitionOptions'] || {};
(globalThis as any)['NSViewController']['TransitionOptions'] = {
  None: 0,
  Crossfade: 1,
  SlideUp: 16,
  SlideDown: 32,
  SlideLeft: 64,
  SlideRight: 128,
  SlideForward: 320,
  SlideBackward: 384,
  AllowUserInteraction: 4096
};


(globalThis as any)['NSVisualEffectView'] = (globalThis as any)['NSVisualEffectView'] || {};
(globalThis as any)['NSVisualEffectView']['BlendingMode'] = (globalThis as any)['NSVisualEffectView']['BlendingMode'] || {};
(globalThis as any)['NSVisualEffectView']['BlendingMode'] = {
  BehindWindow: 0,
  WithinWindow: 1
};

(globalThis as any)['NSVisualEffectView']['Material'] = (globalThis as any)['NSVisualEffectView']['Material'] || {};
(globalThis as any)['NSVisualEffectView']['Material'] = {
  Titlebar: 3,
  Selection: 4,
  Menu: 5,
  Popover: 6,
  Sidebar: 7,
  HeaderView: 10,
  Sheet: 11,
  WindowBackground: 12,
  HUDWindow: 13,
  FullScreenUI: 15,
  ToolTip: 17,
  ContentBackground: 18,
  UnderWindowBackground: 21,
  UnderPageBackground: 22,
  AppearanceBased: 0,
  Light: 1,
  Dark: 2,
  MediumLight: 8,
  UltraDark: 9
};

(globalThis as any)['NSVisualEffectView']['State'] = (globalThis as any)['NSVisualEffectView']['State'] || {};
(globalThis as any)['NSVisualEffectView']['State'] = {
  FollowsWindowActiveState: 0,
  Active: 1,
  Inactive: 2
};


(globalThis as any)['NSWindow'] = (globalThis as any)['NSWindow'] || {};
(globalThis as any)['NSWindow']['AnimationBehavior'] = (globalThis as any)['NSWindow']['AnimationBehavior'] || {};
(globalThis as any)['NSWindow']['AnimationBehavior'] = {
  Default: 0,
  None: 2,
  DocumentWindow: 3,
  UtilityWindow: 4,
  AlertPanel: 5
};

(globalThis as any)['NSWindow']['BackingStoreType'] = (globalThis as any)['NSWindow']['BackingStoreType'] || {};
(globalThis as any)['NSWindow']['BackingStoreType'] = {
  Retained: 0,
  Nonretained: 1,
  Buffered: 2
};

(globalThis as any)['NSWindow']['ButtonType'] = (globalThis as any)['NSWindow']['ButtonType'] || {};
(globalThis as any)['NSWindow']['ButtonType'] = {
  CloseButton: 0,
  MiniaturizeButton: 1,
  ZoomButton: 2,
  ToolbarButton: 3,
  DocumentIconButton: 4,
  DocumentVersionsButton: 6
};

(globalThis as any)['NSWindow']['CollectionBehavior'] = (globalThis as any)['NSWindow']['CollectionBehavior'] || {};
(globalThis as any)['NSWindow']['CollectionBehavior'] = {
  Default: 0,
  CanJoinAllSpaces: 1,
  MoveToActiveSpace: 2,
  Managed: 4,
  Transient: 8,
  Stationary: 16,
  ParticipatesInCycle: 32,
  IgnoresCycle: 64,
  FullScreenPrimary: 128,
  FullScreenAuxiliary: 256,
  FullScreenNone: 512,
  FullScreenAllowsTiling: 2048,
  FullScreenDisallowsTiling: 4096
};

(globalThis as any)['NSWindow']['Depth'] = (globalThis as any)['NSWindow']['Depth'] || {};
(globalThis as any)['NSWindow']['Depth'] = {
  TwentyfourBitRGB: 520,
  SixtyfourBitRGB: 528,
  OnehundredtwentyeightBitRGB: 544
};

(globalThis as any)['NSWindow']['NumberListOptions'] = (globalThis as any)['NSWindow']['NumberListOptions'] || {};
(globalThis as any)['NSWindow']['NumberListOptions'] = {
  Applications: 1,
  Spaces: 16
};

(globalThis as any)['NSWindow']['OcclusionState'] = (globalThis as any)['NSWindow']['OcclusionState'] || {};
(globalThis as any)['NSWindow']['OcclusionState'] = {
  NSWindowOcclusionStateVisible: 2
};

(globalThis as any)['NSWindow']['OrderingMode'] = (globalThis as any)['NSWindow']['OrderingMode'] || {};
(globalThis as any)['NSWindow']['OrderingMode'] = {
  Above: 1,
  Below: -1,
  Out: 0
};

(globalThis as any)['NSWindow']['SelectionDirection'] = (globalThis as any)['NSWindow']['SelectionDirection'] || {};
(globalThis as any)['NSWindow']['SelectionDirection'] = {
  DirectSelection: 0,
  SelectingNext: 1,
  SelectingPrevious: 2
};

(globalThis as any)['NSWindow']['SharingType'] = (globalThis as any)['NSWindow']['SharingType'] || {};
(globalThis as any)['NSWindow']['SharingType'] = {
  None: 0,
  ReadOnly: 1,
  ReadWrite: 2
};

(globalThis as any)['NSWindow']['StyleMask'] = (globalThis as any)['NSWindow']['StyleMask'] || {};
(globalThis as any)['NSWindow']['StyleMask'] = {
  Borderless: 0,
  Titled: 1,
  Closable: 2,
  Miniaturizable: 4,
  Resizable: 8,
  TexturedBackground: 256,
  UnifiedTitleAndToolbar: 4096,
  FullScreen: 16384,
  FullSizeContentView: 32768,
  UtilityWindow: 16,
  DocModalWindow: 64,
  NonactivatingPanel: 128,
  HUDWindow: 8192
};

(globalThis as any)['NSWindow']['TabbingMode'] = (globalThis as any)['NSWindow']['TabbingMode'] || {};
(globalThis as any)['NSWindow']['TabbingMode'] = {
  Automatic: 0,
  Preferred: 1,
  Disallowed: 2
};

(globalThis as any)['NSWindow']['TitleVisibility'] = (globalThis as any)['NSWindow']['TitleVisibility'] || {};
(globalThis as any)['NSWindow']['TitleVisibility'] = {
  Visible: 0,
  Hidden: 1
};

(globalThis as any)['NSWindow']['UserTabbingPreference'] = (globalThis as any)['NSWindow']['UserTabbingPreference'] || {};
(globalThis as any)['NSWindow']['UserTabbingPreference'] = {
  Manual: 0,
  Always: 1,
  InFullScreen: 2
};


(globalThis as any)['NSWindowController'] = (globalThis as any)['NSWindowController'] || {};


(globalThis as any)['NSWindowTab'] = (globalThis as any)['NSWindowTab'] || {};

(globalThis as any)['NSWindowTabGroup'] = (globalThis as any)['NSWindowTabGroup'] || {};

(globalThis as any)['NSWorkspace'] = (globalThis as any)['NSWorkspace'] || {};
(globalThis as any)['NSWorkspace']['AuthorizationType'] = (globalThis as any)['NSWorkspace']['AuthorizationType'] || {};
(globalThis as any)['NSWorkspace']['AuthorizationType'] = {
  CreateSymbolicLink: 0,
  SetAttributes: 1,
  ReplaceFile: 2
};

(globalThis as any)['NSWorkspace']['IconCreationOptions'] = (globalThis as any)['NSWorkspace']['IconCreationOptions'] || {};
(globalThis as any)['NSWorkspace']['IconCreationOptions'] = {
  eQuickDrawElementsIconCreationOption: 2,
  e10_4ElementsIconCreationOption: 4
};

(globalThis as any)['NSWorkspace']['LaunchOptions'] = (globalThis as any)['NSWorkspace']['LaunchOptions'] || {};
(globalThis as any)['NSWorkspace']['LaunchOptions'] = {
  AndPrint: 2,
  WithErrorPresentation: 64,
  InhibitingBackgroundOnly: 128,
  WithoutAddingToRecents: 256,
  WithoutActivation: 512,
  Async: 65536,
  NewInstance: 524288,
  AndHide: 1048576,
  AndHideOthers: 2097152,
  Default: 65536,
  AllowingClassicStartup: 131072,
  PreferringClassic: 262144
};


(globalThis as any)['XMLDTD'] = (globalThis as any)['XMLDTD'] || {};

(globalThis as any)['XMLDTDNode'] = (globalThis as any)['XMLDTDNode'] || {};
(globalThis as any)['XMLDTDNode']['dtdKind'] = (globalThis as any)['XMLDTDNode']['dtdKind'] || {};
(globalThis as any)['XMLDTDNode']['dtdKind'] = {
  EntityGeneralKind: 1,
  EntityParsedKind: 2,
  EntityUnparsedKind: 3,
  EntityParameterKind: 4,
  EntityPredefined: 5,
  AttributeCDATAKind: 6,
  AttributeIDKind: 7,
  AttributeIDRefKind: 8,
  AttributeIDRefsKind: 9,
  AttributeEntityKind: 10,
  AttributeEntitiesKind: 11,
  AttributeNMTokenKind: 12,
  AttributeNMTokensKind: 13,
  AttributeEnumerationKind: 14,
  AttributeNotationKind: 15,
  ElementDeclarationUndefinedKind: 16,
  ElementDeclarationEmptyKind: 17,
  ElementDeclarationAnyKind: 18,
  ElementDeclarationMixedKind: 19,
  ElementDeclarationElementKind: 20
};


(globalThis as any)['XMLDocument'] = (globalThis as any)['XMLDocument'] || {};
(globalThis as any)['XMLDocument']['ContentKind'] = (globalThis as any)['XMLDocument']['ContentKind'] || {};
(globalThis as any)['XMLDocument']['ContentKind'] = {
  XMLKind: 0,
  XHTMLKind: 1,
  HTMLKind: 2,
  TextKind: 3
};


(globalThis as any)['XMLElement'] = (globalThis as any)['XMLElement'] || {};

(globalThis as any)['XMLNode'] = (globalThis as any)['XMLNode'] || {};
(globalThis as any)['XMLNode']['Kind'] = (globalThis as any)['XMLNode']['Kind'] || {};
(globalThis as any)['XMLNode']['Kind'] = {
  InvalidKind: 0,
  DocumentKind: 1,
  ElementKind: 2,
  AttributeKind: 3,
  NamespaceKind: 4,
  ProcessingInstructionKind: 5,
  CommentKind: 6,
  TextKind: 7,
  DTDKind: 8,
  EntityDeclarationKind: 9,
  AttributeDeclarationKind: 10,
  ElementDeclarationKind: 11,
  NotationDeclarationKind: 12
};

(globalThis as any)['XMLNode']['Options'] = (globalThis as any)['XMLNode']['Options'] || {};
(globalThis as any)['XMLNode']['Options'] = {
  NodeOptionsNone: 0,
  NodeIsCDATA: 1,
  NodeExpandEmptyElement: 2,
  NodeCompactEmptyElement: 4,
  NodeUseSingleQuotes: 8,
  NodeUseDoubleQuotes: 16,
  NodeNeverEscapeContents: 32,
  DocumentTidyHTML: 512,
  DocumentTidyXML: 1024,
  DocumentValidate: 8192,
  NodeLoadExternalEntitiesAlways: 16384,
  NodeLoadExternalEntitiesSameOriginOnly: 32768,
  NodeLoadExternalEntitiesNever: 524288,
  DocumentXInclude: 65536,
  NodePrettyPrint: 131072,
  DocumentIncludeContentTypeDeclaration: 262144,
  NodePreserveNamespaceOrder: 1048576,
  NodePreserveAttributeOrder: 2097152,
  NodePreserveEntities: 4194304,
  NodePreservePrefixes: 8388608,
  NodePreserveCDATA: 16777216,
  NodePreserveWhitespace: 33554432,
  NodePreserveDTD: 67108864,
  NodePreserveCharacterReferences: 134217728,
  NodePromoteSignificantWhitespace: 268435456,
  NodePreserveEmptyElements: 6,
  NodePreserveQuotes: 24,
  NodePreserveAll: 4293918750
};


(globalThis as any)['XMLParser'] = (globalThis as any)['XMLParser'] || {};
(globalThis as any)['XMLParser']['ErrorCode'] = (globalThis as any)['XMLParser']['ErrorCode'] || {};
(globalThis as any)['XMLParser']['ErrorCode'] = {
  InternalError: 1,
  OutOfMemoryError: 2,
  DocumentStartError: 3,
  EmptyDocumentError: 4,
  PrematureDocumentEndError: 5,
  InvalidHexCharacterRefError: 6,
  InvalidDecimalCharacterRefError: 7,
  InvalidCharacterRefError: 8,
  InvalidCharacterError: 9,
  CharacterRefAtEOFError: 10,
  CharacterRefInPrologError: 11,
  CharacterRefInEpilogError: 12,
  CharacterRefInDTDError: 13,
  EntityRefAtEOFError: 14,
  EntityRefInPrologError: 15,
  EntityRefInEpilogError: 16,
  EntityRefInDTDError: 17,
  ParsedEntityRefAtEOFError: 18,
  ParsedEntityRefInPrologError: 19,
  ParsedEntityRefInEpilogError: 20,
  ParsedEntityRefInInternalSubsetError: 21,
  EntityReferenceWithoutNameError: 22,
  EntityReferenceMissingSemiError: 23,
  ParsedEntityRefNoNameError: 24,
  ParsedEntityRefMissingSemiError: 25,
  UndeclaredEntityError: 26,
  UnparsedEntityError: 28,
  EntityIsExternalError: 29,
  EntityIsParameterError: 30,
  UnknownEncodingError: 31,
  EncodingNotSupportedError: 32,
  StringNotStartedError: 33,
  StringNotClosedError: 34,
  NamespaceDeclarationError: 35,
  EntityNotStartedError: 36,
  EntityNotFinishedError: 37,
  LessThanSymbolInAttributeError: 38,
  AttributeNotStartedError: 39,
  AttributeNotFinishedError: 40,
  AttributeHasNoValueError: 41,
  AttributeRedefinedError: 42,
  LiteralNotStartedError: 43,
  LiteralNotFinishedError: 44,
  CommentNotFinishedError: 45,
  ProcessingInstructionNotStartedError: 46,
  ProcessingInstructionNotFinishedError: 47,
  NotationNotStartedError: 48,
  NotationNotFinishedError: 49,
  AttributeListNotStartedError: 50,
  AttributeListNotFinishedError: 51,
  MixedContentDeclNotStartedError: 52,
  MixedContentDeclNotFinishedError: 53,
  ElementContentDeclNotStartedError: 54,
  ElementContentDeclNotFinishedError: 55,
  XMLDeclNotStartedError: 56,
  XMLDeclNotFinishedError: 57,
  ConditionalSectionNotStartedError: 58,
  ConditionalSectionNotFinishedError: 59,
  ExternalSubsetNotFinishedError: 60,
  DOCTYPEDeclNotFinishedError: 61,
  MisplacedCDATAEndStringError: 62,
  CDATANotFinishedError: 63,
  MisplacedXMLDeclarationError: 64,
  SpaceRequiredError: 65,
  SeparatorRequiredError: 66,
  NMTOKENRequiredError: 67,
  NAMERequiredError: 68,
  PCDATARequiredError: 69,
  URIRequiredError: 70,
  PublicIdentifierRequiredError: 71,
  LTRequiredError: 72,
  GTRequiredError: 73,
  LTSlashRequiredError: 74,
  EqualExpectedError: 75,
  TagNameMismatchError: 76,
  UnfinishedTagError: 77,
  StandaloneValueError: 78,
  InvalidEncodingNameError: 79,
  CommentContainsDoubleHyphenError: 80,
  InvalidEncodingError: 81,
  ExternalStandaloneEntityError: 82,
  InvalidConditionalSectionError: 83,
  EntityValueRequiredError: 84,
  NotWellBalancedError: 85,
  ExtraContentError: 86,
  InvalidCharacterInEntityError: 87,
  ParsedEntityRefInInternalError: 88,
  EntityRefLoopError: 89,
  EntityBoundaryError: 90,
  InvalidURIError: 91,
  URIFragmentError: 92,
  NoDTDError: 94,
  DelegateAbortedParseError: 512
};

(globalThis as any)['XMLParser']['ExternalEntityResolvingPolicy'] = (globalThis as any)['XMLParser']['ExternalEntityResolvingPolicy'] || {};
(globalThis as any)['XMLParser']['ExternalEntityResolvingPolicy'] = {
  Never: 0,
  NoNetwork: 1,
  SameOriginOnly: 2,
  Always: 3
};


(globalThis as any)['NSXPCConnection'] = (globalThis as any)['NSXPCConnection'] || {};
(globalThis as any)['NSXPCConnection']['Options'] = (globalThis as any)['NSXPCConnection']['Options'] || {};
(globalThis as any)['NSXPCConnection']['Options'] = {
  NSXPCConnectionPrivileged: 4096
};



(globalThis as any)['QCPlugIn'] = (globalThis as any)['QCPlugIn'] || {};
(globalThis as any)['QCPlugIn']['QCPlugInExecutionMode'] = (globalThis as any)['QCPlugIn']['QCPlugInExecutionMode'] || {};
(globalThis as any)['QCPlugIn']['QCPlugInExecutionMode'] = {
  Provider: 1,
  Processor: 2,
  Consumer: 3
};

(globalThis as any)['QCPlugIn']['QCPlugInTimeMode'] = (globalThis as any)['QCPlugIn']['QCPlugInTimeMode'] || {};
(globalThis as any)['QCPlugIn']['QCPlugInTimeMode'] = {
  None: 0,
  Idle: 1,
  TimeBase: 2
};


(globalThis as any)['QLPreviewItem'] = (globalThis as any)['QLPreviewItem'] || {};

(globalThis as any)['QLPreviewPanel'] = (globalThis as any)['QLPreviewPanel'] || {};

(globalThis as any)['QLPreviewView'] = (globalThis as any)['QLPreviewView'] || {};
(globalThis as any)['QLPreviewView']['QLPreviewViewStyle'] = (globalThis as any)['QLPreviewView']['QLPreviewViewStyle'] || {};
(globalThis as any)['QLPreviewView']['QLPreviewViewStyle'] = {
  Normal: 0,
  Compact: 1
};


(globalThis as any)['QLPreviewingController'] = (globalThis as any)['QLPreviewingController'] || {};

(globalThis as any)['QuartzFilter'] = (globalThis as any)['QuartzFilter'] || {};

(globalThis as any)['QuartzFilterManager'] = (globalThis as any)['QuartzFilterManager'] || {};

(globalThis as any)['runtime'] = (globalThis as any)['runtime'] || {};
(globalThis as any)['runtime']['objc_AssociationPolicy'] = (globalThis as any)['runtime']['objc_AssociationPolicy'] || {};
(globalThis as any)['runtime']['objc_AssociationPolicy'] = {
  N_ASSIGN: 0,
  N_RETAIN_NONATOMIC: 1,
  N_COPY_NONATOMIC: 3,
  N_RETAIN: 769,
  N_COPY: 771
};


export {
  AVAnimation,
  AVAsset,
  AVAssetCache,
  AVAssetExportSession,
  AVAssetImageGenerator,
  AVAssetReader,
  AVAssetReaderOutput,
  AVAssetResourceLoader,
  AVAssetTrack,
  AVAssetTrackGroup,
  AVAssetTrackSegment,
  AVAssetWriter,
  AVAssetWriterInput,
  AVAsynchronousKeyValueLoading,
  AVAudioBuffer,
  AVAudioChannelLayout,
  AVAudioConnectionPoint,
  AVAudioConverter,
  AVAudioEngine,
  AVAudioEnvironmentNode,
  AVAudioFile,
  AVAudioFormat,
  AVAudioIONode,
  AVAudioMix,
  AVAudioMixerNode,
  AVAudioMixing,
  AVAudioNode,
  AVAudioPlayer,
  AVAudioPlayerNode,
  AVAudioProcessingSettings,
  AVAudioRecorder,
  AVAudioSequencer,
  AVAudioSession,
  AVAudioSettings,
  AVAudioSinkNode,
  AVAudioSourceNode,
  AVAudioTime,
  AVAudioUnit,
  AVAudioUnitComponent,
  AVAudioUnitDelay,
  AVAudioUnitDistortion,
  AVAudioUnitEQ,
  AVAudioUnitEffect,
  AVAudioUnitGenerator,
  AVAudioUnitMIDIInstrument,
  AVAudioUnitReverb,
  AVAudioUnitSampler,
  AVAudioUnitTimeEffect,
  AVAudioUnitTimePitch,
  AVAudioUnitVarispeed,
  AVCameraCalibrationData,
  AVCaptureAudioDataOutput,
  AVCaptureAudioPreviewOutput,
  AVCaptureDataOutputSynchronizer,
  AVCaptureDepthDataOutput,
  AVCaptureDevice,
  AVCaptureFileOutput,
  AVCaptureInput,
  AVCaptureMetadataOutput,
  AVCaptureOutputBase,
  AVCapturePhotoOutput,
  AVCaptureSession,
  AVCaptureSystemPressure,
  AVCaptureVideoDataOutput,
  AVCaptureVideoPreviewLayer,
  AVCaptureView,
  AVComposition,
  AVCompositionTrack,
  AVCompositionTrackSegment,
  AVContentKeySession,
  AVDepthData,
  AVError,
  AVMIDIPlayer,
  AVMediaFormat,
  AVMediaSelection,
  AVMediaSelectionGroup,
  AVMetadataFormat,
  AVMetadataIdentifiers,
  AVMetadataItem,
  AVMetadataObject,
  AVMovie,
  AVMovieTrack,
  AVOutputSettingsAssistant,
  AVPictureInPictureController,
  AVPlayer,
  AVPlayerItem,
  AVPlayerItemMediaDataCollector,
  AVPlayerItemOutput,
  AVPlayerItemProtectedContentAdditions,
  AVPlayerItemTrack,
  AVPlayerLayer,
  AVPlayerLooper,
  AVPlayerMediaSelectionCriteria,
  AVPlayerView,
  AVPortraitEffectsMatte,
  AVQueuedSampleBufferRendering,
  AVRouteDetector,
  AVRoutePickerView,
  AVSampleBufferAudioRenderer,
  AVSampleBufferDisplayLayer,
  AVSampleBufferGenerator,
  AVSampleBufferRenderSynchronizer,
  AVSampleCursor,
  AVSemanticSegmentationMatte,
  AVSpeechSynthesis,
  AVSynchronizedLayer,
  AVTextStyleRule,
  AVTimedMetadataGroup,
  AVVideoCompositing,
  AVVideoComposition,
  AVVideoSettings,
  ByteCountFormatter,
  CAAnimation,
  CAConstraintLayoutManager,
  CADisplayLink,
  CAEDRMetadata,
  CAEmitterCell,
  CAEmitterLayer,
  CAGradientLayer,
  CALayer,
  CAMediaTiming,
  CAMediaTimingFunction,
  CAMetalLayer,
  CARemoteLayerClient,
  CARemoteLayerServer,
  CARenderer,
  CAReplicatorLayer,
  CAScrollLayer,
  CAShapeLayer,
  CATextLayer,
  CATiledLayer,
  CATransaction,
  CATransform3D,
  CATransformLayer,
  CAValueFunction,
  CFArray,
  CFBag,
  CFBase,
  CFBinaryHeap,
  CFBundle,
  CFByteOrder,
  CFCalendar,
  CFCharacterSet,
  CFData,
  CFDate,
  CFDateFormatter,
  CFDictionary,
  CFError,
  CFFileSecurity,
  CFLocale,
  CFNotificationCenter,
  CFNumber,
  CFNumberFormatter,
  CFPlugIn,
  CFPreferences,
  CFPropertyList,
  CFRunLoop,
  CFSet,
  CFSocket,
  CFStream,
  CFString,
  CFStringEncodingExt,
  CFStringTokenizer,
  CFTimeZone,
  CFURL,
  CFURLEnumerator,
  CFUserNotification,
  CFXMLNode,
  CFXMLParser,
  CGAffineTransform,
  CGColor,
  CGColorConversionInfo,
  CGColorSpace,
  CGContext,
  CGDirectDisplay,
  CGDisplayConfiguration,
  CGDisplayStream,
  CGError,
  CGEventTypes,
  CGFont,
  CGGeometry,
  CGGradient,
  CGImage,
  CGPDFContext,
  CGPDFDocument,
  CGPDFObject,
  CGPDFPage,
  CGPDFStream,
  CGPath,
  CGPattern,
  CGRemoteOperation,
  CGWindow,
  CGWindowLevel,
  CIBarcodeDescriptor,
  CIColor,
  CIContext,
  CIDetector,
  CIFeature,
  CIFilter,
  CIFilterConstructor,
  CIFilterGenerator,
  CIFilterShape,
  CIImage,
  CIImageAccumulator,
  CIImageProvider,
  CIKernel,
  CIPlugIn,
  CIRAWFilter,
  CIRenderDestination,
  CISampler,
  CIVector,
  CKAcceptSharesOperation,
  CKAsset,
  CKContainer,
  CKDatabase,
  CKDatabaseOperation,
  CKDiscoverAllUserIdentitiesOperation,
  CKDiscoverUserIdentitiesOperation,
  CKError,
  CKFetchDatabaseChangesOperation,
  CKFetchRecordZoneChangesOperation,
  CKFetchRecordZonesOperation,
  CKFetchRecordsOperation,
  CKFetchShareMetadataOperation,
  CKFetchShareParticipantsOperation,
  CKFetchSubscriptionsOperation,
  CKFetchWebAuthTokenOperation,
  CKLocationSortDescriptor,
  CKModifyRecordZonesOperation,
  CKModifyRecordsOperation,
  CKModifySubscriptionsOperation,
  CKNotification,
  CKOperation,
  CKOperationGroup,
  CKQuery,
  CKQueryOperation,
  CKRecord,
  CKRecordZone,
  CKServerChangeToken,
  CKShare,
  CKSubscription,
  CKUserIdentity,
  CMFormatDescription,
  CMFormatDescriptionBridge,
  CMIOSampleBuffer,
  CMMemoryPool,
  CMMetadata,
  CMSampleBuffer,
  CMSync,
  CMTextMarkup,
  CMTime,
  CMTimeRange,
  Calendar,
  CollectionDifference,
  CoreDataDefines,
  CoreDataErrors,
  Data,
  DateComponentsFormatter,
  DateFormatter,
  DateIntervalFormatter,
  Decimal,
  DistributedNotificationCenter,
  EnergyFormatter,
  FileManager,
  FileWrapper,
  Formatter,
  HTTPCookieStorage,
  IKCameraDeviceView,
  IKDeviceBrowserView,
  IKFilterBrowserPanel,
  IKFilterBrowserView,
  IKFilterUI,
  IKFilterUIView,
  IKImageBrowserCell,
  IKImageBrowserView,
  IKImageEditPanel,
  IKImageView,
  IKPictureTaker,
  IKSaveOptions,
  IKScannerDeviceView,
  IKSlideshow,
  ISO8601DateFormatter,
  ImageKitDeprecated,
  JSONSerialization,
  LengthFormatter,
  Locale,
  MassFormatter,
  MeasurementFormatter,
  NSATSTypesetter,
  NSAccessibility,
  NSAccessibilityConstants,
  NSAccessibilityCustomAction,
  NSAccessibilityCustomRotor,
  NSAccessibilityElement,
  NSActionCell,
  AffineTransform,
  NSAlert,
  NSAlignmentFeedbackFilter,
  NSAnimation,
  NSAnimationContext,
  NSAppearance,
  NSAppleEventDescriptor,
  NSAppleEventManager,
  NSAppleScript,
  NSApplication,
  NSArrayController,
  NSAtomicStore,
  NSAtomicStoreCacheNode,
  NSAttributeDescription,
  NSAttributedString,
  NSAutoreleasePool,
  NSBackgroundActivityScheduler,
  NSBatchDeleteRequest,
  NSBatchInsertRequest,
  NSBatchUpdateRequest,
  NSBezierPath,
  NSBitmapImageRep,
  NSBox,
  NSBrowser,
  NSBrowserCell,
  Bundle,
  NSButton,
  NSButtonCell,
  NSButtonTouchBarItem,
  NSCIImageRep,
  NSCache,
  NSCalendarDate,
  NSCandidateListTouchBarItem,
  NSCell,
  CharacterSet,
  NSClassDescription,
  NSClickGestureRecognizer,
  NSClipView,
  NSCoder,
  NSCollectionView,
  NSCollectionViewCompositionalLayout,
  NSCollectionViewFlowLayout,
  NSCollectionViewGridLayout,
  NSCollectionViewLayout,
  NSCollectionViewTransitionLayout,
  NSColor,
  NSColorList,
  NSColorPanel,
  NSColorPicker,
  NSColorPickerTouchBarItem,
  NSColorSampler,
  NSColorSpace,
  NSColorWell,
  NSComboBox,
  NSComboBoxCell,
  NSComparisonPredicate,
  NSCompoundPredicate,
  NSConnection,
  NSControl,
  NSController,
  NSCoreDataCoreSpotlightDelegate,
  NSCursor,
  NSCustomImageRep,
  NSCustomTouchBarItem,
  NSDataAsset,
  NSDate as Date,
  DateInterval,
  NSDatePicker,
  NSDatePickerCell,
  NSDebug,
  NSDerivedAttributeDescription,
  Dictionary,
  NSDictionaryController,
  NSDistantObject,
  NSDistributedLock,
  NSDockTile,
  NSDocument,
  NSDocumentController,
  NSDragging,
  NSDraggingItem,
  NSDraggingSession,
  NSDrawer,
  NSEPSImageRep,
  NSEntityDescription,
  NSEntityMapping,
  NSEntityMigrationPolicy,
  NSEnumerator,
  NSError as Error,
  NSErrors,
  NSEvent,
  NSException,
  NSExpression,
  NSExpressionDescription,
  NSExtensionContext,
  NSExtensionItem,
  NSExtensionRequestHandling,
  NSFetchIndexDescription,
  NSFetchIndexElementDescription,
  NSFetchRequest,
  NSFetchRequestExpression,
  NSFetchedPropertyDescription,
  NSFetchedResultsController,
  NSFileCoordinator,
  FileHandle,
  NSFilePresenter,
  NSFilePromiseProvider,
  NSFilePromiseReceiver,
  NSFileVersion,
  NSFont,
  NSFontAssetRequest,
  NSFontCollection,
  NSFontDescriptor,
  NSFontManager,
  NSFontPanel,
  NSFormCell,
  NSGarbageCollector,
  NSGeometry,
  NSGestureRecognizer,
  NSGlyphGenerator,
  NSGlyphInfo,
  NSGradient,
  NSGraphics,
  NSGraphicsContext,
  NSGridView,
  NSGroupTouchBarItem,
  HTTPCookie,
  NSHapticFeedback,
  NSHashTable,
  NSHelpManager,
  Host,
  NSImage,
  NSImageCell,
  NSImageRep,
  NSImageView,
  NSIncrementalStore,
  NSIncrementalStoreNode,
  IndexPath,
  IndexSet,
  NSInvocation,
  NSItemProvider,
  NSKeyValueBinding,
  NSKeyValueCoding,
  NSKeyValueObserving,
  NSKeyedArchiver,
  NSLayoutAnchor,
  NSLayoutConstraint,
  NSLayoutGuide,
  NSLayoutManager,
  NSLevelIndicator,
  NSLevelIndicatorCell,
  NSLinguisticTagger,
  ListFormatter,
  NSLock,
  NSMagnificationGestureRecognizer,
  NSManagedObject,
  NSManagedObjectContext,
  NSManagedObjectID,
  NSManagedObjectModel,
  NSMapTable,
  NSMappingModel,
  NSMatrix,
  Measurement,
  NSMediaLibraryBrowserController,
  NSMenu,
  NSMenuItem,
  NSMenuItemCell,
  NSMenuToolbarItem,
  NSMergePolicy,
  NSMetadata,
  NSMetadataAttributes,
  NSMethodSignature,
  NSMigrationManager,
  NSNetServices,
  NSNib,
  Notification,
  NotificationQueue,
  NSNull,
  NumberFormatter,
  NSObjCRuntime,
  NSObjectController,
  NSOpenPanel,
  Operation,
  NSOrderedCollectionChange,
  NSOrderedSet,
  NSOrthography,
  NSOutlineView,
  NSPDFImageRep,
  NSPDFInfo,
  NSPDFPanel,
  NSPICTImageRep,
  NSPageController,
  NSPageLayout,
  NSPanGestureRecognizer,
  NSPanel,
  NSParagraphStyle,
  NSPasteboard,
  NSPasteboardItem,
  NSPathCell,
  NSPathComponentCell,
  NSPathControl,
  NSPathControlItem,
  NSPathUtilities,
  NSPersistentCloudKitContainer,
  NSPersistentCloudKitContainerOptions,
  NSPersistentContainer,
  NSPersistentDocument,
  NSPersistentHistoryChange,
  NSPersistentHistoryChangeRequest,
  NSPersistentHistoryToken,
  NSPersistentHistoryTransaction,
  NSPersistentStore,
  NSPersistentStoreCoordinator,
  NSPersistentStoreDescription,
  NSPersistentStoreRequest,
  NSPersistentStoreResult,
  PersonNameComponents,
  PersonNameComponentsFormatter,
  NSPickerTouchBarItem,
  NSPointerArray,
  NSPointerFunctions,
  NSPopUpButton,
  NSPopUpButtonCell,
  NSPopover,
  NSPopoverTouchBarItem,
  Port,
  NSPortCoder,
  PortMessage,
  NSPortNameServer,
  NSPredicate,
  NSPredicateEditor,
  NSPredicateEditorRowTemplate,
  NSPressGestureRecognizer,
  NSPressureConfiguration,
  NSPrintInfo,
  NSPrintOperation,
  NSPrintPanel,
  NSPrinter,
  ProcessInfo,
  Progress,
  NSProgressIndicator,
  NSPropertyDescription,
  NSPropertyList,
  NSPropertyMapping,
  NSProtocolChecker,
  NSProxy,
  NSQueryGenerationToken,
  NSRegularExpression,
  NSRelationshipDescription,
  RelativeDateTimeFormatter,
  NSResponder,
  NSRotationGestureRecognizer,
  NSRuleEditor,
  NSRulerMarker,
  NSRulerView,
  RunLoop,
  NSRunningApplication,
  NSSaveChangesRequest,
  NSSavePanel,
  Scanner,
  NSScreen,
  NSScriptClassDescription,
  NSScriptCoercionHandler,
  NSScriptCommand,
  NSScriptCommandDescription,
  NSScriptExecutionContext,
  NSScriptKeyValueCoding,
  NSScriptObjectSpecifiers,
  NSScriptStandardSuiteCommands,
  NSScriptSuiteRegistry,
  NSScriptWhoseTests,
  NSScrollView,
  NSScroller,
  NSScrubber,
  NSScrubberItemView,
  NSScrubberLayout,
  NSSearchField,
  NSSearchFieldCell,
  NSSecureTextField,
  NSSegmentedCell,
  NSSegmentedControl,
  NSShadow,
  NSSharingService,
  NSSharingServicePickerToolbarItem,
  NSSharingServicePickerTouchBarItem,
  NSSlider,
  NSSliderAccessory,
  NSSliderCell,
  NSSliderTouchBarItem,
  NSSortDescriptor,
  NSSound,
  NSSpeechRecognizer,
  NSSpeechSynthesizer,
  NSSpellChecker,
  NSSpellServer,
  NSSplitView,
  NSSplitViewController,
  NSSplitViewItem,
  NSStackView,
  NSStatusBar,
  NSStatusBarButton,
  NSStatusItem,
  NSStepper,
  NSStepperCell,
  NSStepperTouchBarItem,
  NSStoryboard,
  NSStoryboardSegue,
  Stream,
  NSStringDrawing,
  NSSwitch,
  NSTabView,
  NSTabViewController,
  NSTabViewItem,
  NSTableCellView,
  NSTableColumn,
  NSTableHeaderCell,
  NSTableHeaderView,
  NSTableRowView,
  NSTableView,
  NSTableViewRowAction,
  Process,
  NSText,
  NSTextAlternatives,
  NSTextAttachment,
  NSTextCheckingClient,
  NSTextCheckingController,
  NSTextCheckingResult,
  NSTextContainer,
  NSTextField,
  NSTextFieldCell,
  NSTextFinder,
  NSTextInputClient,
  NSTextInputContext,
  NSTextList,
  NSTextStorage,
  NSTextTable,
  NSTextView,
  Thread,
  TimeZone,
  Timer,
  NSTitlebarAccessoryViewController,
  NSTokenField,
  NSTokenFieldCell,
  NSToolbar,
  NSToolbarItem,
  NSToolbarItemGroup,
  NSTouch,
  NSTouchBar,
  NSTouchBarItem,
  NSTrackingArea,
  NSTreeController,
  NSTreeNode,
  NSTypesetter,
  URL,
  URLAuthenticationChallenge,
  URLCache,
  NSURLConnection,
  URLCredential,
  URLCredentialStorage,
  NSURLDownload,
  NSURLError,
  NSURLHandle,
  URLProtectionSpace,
  URLProtocol,
  URLRequest,
  URLResponse,
  URLSession,
  UUID,
  NSUbiquitousKeyValueStore,
  UndoManager,
  Unit,
  NSUserActivity,
  UserDefaults,
  NSUserDefaultsController,
  NSUserInterfaceCompression,
  NSUserInterfaceItemIdentification,
  NSUserInterfaceItemSearching,
  NSUserInterfaceLayout,
  NSUserNotification,
  NSUserScriptTask,
  NSValue,
  ValueTransformer,
  NSView,
  NSViewController,
  NSVisualEffectView,
  NSWindow,
  NSWindowController,
  NSWindowRestoration,
  NSWindowTab,
  NSWindowTabGroup,
  NSWorkspace,
  XMLDTD,
  XMLDTDNode,
  XMLDocument,
  XMLElement,
  XMLNode,
  XMLParser,
  NSXPCConnection,
  QCComposition,
  QCPlugIn,
  QLPreviewItem,
  QLPreviewPanel,
  QLPreviewView,
  QLPreviewingController,
  QuartzFilter,
  QuartzFilterManager,
};
