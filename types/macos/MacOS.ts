/* eslint-disable */

declare global {

  // interface
  class AVAsset extends NSObject /* implements AVAsynchronousKeyValueLoading, NSCopying */ {
    allMediaSelections: AVMediaSelection[];
    availableChapterLocales: NSLocale[];
    availableMediaCharacteristicsWithMediaSelectionOptions: string[];
    availableMetadataFormats: string[];
    canContainFragments: boolean;
    commonMetadata: AVMetadataItem[];
    isCompatibleWithAirPlayVideo: boolean;
    isComposable: boolean;
    containsFragments: boolean;
    creationDate: AVMetadataItem;
    duration: CMTime;
    isExportable: boolean;
    hasProtectedContent: boolean;
    lyrics: string;
    metadata: AVMetadataItem[];
    minimumTimeOffsetFromLive: CMTime;
    overallDurationHint: CMTime;
    isPlayable: boolean;
    preferredMediaSelection: AVMediaSelection;
    preferredRate: number;
    preferredTransform: CGAffineTransform;
    preferredVolume: number;
    providesPreciseDurationAndTiming: boolean;
    isReadable: boolean;
    referenceRestrictions: AVAssetReferenceRestrictions;
    trackGroups: AVAssetTrackGroup[];
    tracks: AVAssetTrack[];
    cancelLoading(): void;
    chapterMetadataGroupsBestMatchingPreferredLanguages(bestMatchingPreferredLanguages: string[]): AVTimedMetadataGroup[];
    chapterMetadataGroupsWithTitleLocaleContainingItemsWithCommonKeys(withTitleLocale: NSLocale, containingItemsWithCommonKeys?: string[]): AVTimedMetadataGroup[];
    mediaSelectionGroupForMediaCharacteristic(forMediaCharacteristic: string): AVMediaSelectionGroup;
    metadataForFormat(forFormat: string): AVMetadataItem[];
    trackWithTrackID(withTrackID: number): AVAssetTrack;
    tracksWithMediaCharacteristic(withMediaCharacteristic: string): AVAssetTrack[];
    tracksWithMediaType(withMediaType: string): AVAssetTrack[];
    unusedTrackID(): number;
  }

  // interface
  class AVAssetCache extends NSObject {
    isPlayableOffline: boolean;
    mediaSelectionOptionsInMediaSelectionGroup(in_: AVMediaSelectionGroup): AVMediaSelectionOption[];
  }

  // interface
  class AVAssetExportSession extends NSObject {
    static allExportPresets(): string[];
    static determineCompatibilityWithOfExportPresetWithOutputFileTypeCompletionHandler(ofExportPreset: string, with_: AVAsset, outputFileType?: string, completionHandler?: (p1: boolean) => void): void;
    static exportPresetsCompatibleWithAsset(compatibleWith: AVAsset): string[];
    asset: AVAsset;
    audioMix: AVAudioMix;
    setAudioMix(_: AVAudioMix)
    audioTimePitchAlgorithm: string;
    setAudioTimePitchAlgorithm(_: string)
    canPerformMultiplePassesOverSourceMediaData: boolean;
    setCanPerformMultiplePassesOverSourceMediaData(_: boolean)
    customVideoCompositor: AVVideoCompositing;
    directoryForTemporaryFiles: NSURL;
    setDirectoryForTemporaryFiles(_: NSURL)
    error: NSError;
    estimatedOutputFileLength: number;
    fileLengthLimit: number;
    setFileLengthLimit(_: number)
    maxDuration: CMTime;
    metadata: AVMetadataItem[];
    setMetadata(_: AVMetadataItem[])
    metadataItemFilter: AVMetadataItemFilter;
    setMetadataItemFilter(_: AVMetadataItemFilter)
    outputFileType: string;
    setOutputFileType(_: string)
    outputURL: NSURL;
    setOutputURL(_: NSURL)
    presetName: string;
    progress: number;
    shouldOptimizeForNetworkUse: boolean;
    setShouldOptimizeForNetworkUse(_: boolean)
    status: AVAssetExportSession.Status;
    supportedFileTypes: string[];
    timeRange: CMTimeRange;
    setTimeRange(_: CMTimeRange)
    videoComposition: AVVideoComposition;
    setVideoComposition(_: AVVideoComposition)
    cancelExport(): void;
    determineCompatibleFileTypesWithCompletionHandler(completionHandler: (p1: string[]) => void): void;
    estimateMaximumDurationWithCompletionHandler(completionHandler?: (p1: CMTime, p2: NSError) => void): void;
    estimateOutputFileLengthWithCompletionHandler(completionHandler?: (p1: number, p2: NSError) => void): void;
    exportAsynchronouslyWithCompletionHandler(completionHandler: () => void): void;
    static createWithAssetPresetName(asset: AVAsset, presetName: string): AVAssetExportSession;
  }

  // interface
  class AVAssetImageGenerator extends NSObject {
    apertureMode: string;
    setApertureMode(_: string)
    appliesPreferredTrackTransform: boolean;
    setAppliesPreferredTrackTransform(_: boolean)
    asset: AVAsset;
    customVideoCompositor: AVVideoCompositing;
    maximumSize: CGSize;
    setMaximumSize(_: CGSize)
    requestedTimeToleranceAfter: CMTime;
    setRequestedTimeToleranceAfter(_: CMTime)
    requestedTimeToleranceBefore: CMTime;
    setRequestedTimeToleranceBefore(_: CMTime)
    videoComposition: AVVideoComposition;
    setVideoComposition(_: AVVideoComposition)
    cancelAllCGImageGeneration(): void;
    copyCGImageAtTimeActualTimeError(actualTime: CMTime, error?: CMTime): any;
    generateCGImagesAsynchronouslyWithForTimesCompletionHandler(forTimes: NSValue[], completionHandler: (p1: CMTime, p2: any, p3: CMTime, p4: AVAssetImageGenerator.Result, p5: NSError) => void): void;
    static createWithAsset(asset: AVAsset): AVAssetImageGenerator;
  }

  // interface
  class AVAssetReader extends NSObject {
    static assetReaderWithAssetError(error: AVAsset): AVAssetReader;
    asset: AVAsset;
    error: NSError;
    outputs: AVAssetReaderOutput[];
    status: AVAssetReader.Status;
    timeRange: CMTimeRange;
    setTimeRange(_: CMTimeRange)
    addOutput(_: AVAssetReaderOutput): void;
    canAddOutput(_: AVAssetReaderOutput): boolean;
    cancelReading(): void;
    static createWithAsset(asset: AVAsset): AVAssetReader;
    startReading(): boolean;
  }

  // interface
  class AVAssetReaderAudioMixOutput extends AVAssetReaderOutput {
    static assetReaderAudioMixOutputWithAudioTracksAudioSettings(audioTracks: AVAssetTrack[], audioSettings?: Map<string, any>): AVAssetReaderAudioMixOutput;
    audioMix: AVAudioMix;
    setAudioMix(_: AVAudioMix)
    audioSettings: Map<string, any>;
    audioTimePitchAlgorithm: string;
    setAudioTimePitchAlgorithm(_: string)
    audioTracks: AVAssetTrack[];
    static createWithAudioTracksAudioSettings(audioTracks: AVAssetTrack[], audioSettings?: Map<string, any>): AVAssetReaderAudioMixOutput;
  }

  // interface
  class AVAssetReaderOutput extends NSObject {
    alwaysCopiesSampleData: boolean;
    setAlwaysCopiesSampleData(_: boolean)
    mediaType: string;
    supportsRandomAccess: boolean;
    setSupportsRandomAccess(_: boolean)
    copyNextSampleBuffer(): any;
    markConfigurationAsFinal(): void;
    resetForReadingTimeRanges(forReadingTimeRanges: NSValue[]): void;
  }

  // interface
  class AVAssetReaderOutputMetadataAdaptor extends NSObject {
    static assetReaderOutputMetadataAdaptorWithAssetReaderTrackOutput(assetReaderTrackOutput: AVAssetReaderTrackOutput): AVAssetReaderOutputMetadataAdaptor;
    assetReaderTrackOutput: AVAssetReaderTrackOutput;
    static createWithAssetReaderTrackOutput(assetReaderTrackOutput: AVAssetReaderTrackOutput): AVAssetReaderOutputMetadataAdaptor;
    nextTimedMetadataGroup(): AVTimedMetadataGroup;
  }

  // interface
  class AVAssetReaderSampleReferenceOutput extends AVAssetReaderOutput {
    static assetReaderSampleReferenceOutputWithTrack(track: AVAssetTrack): AVAssetReaderSampleReferenceOutput;
    track: AVAssetTrack;
    static createWithTrack(track: AVAssetTrack): AVAssetReaderSampleReferenceOutput;
  }

  // interface
  class AVAssetReaderTrackOutput extends AVAssetReaderOutput {
    static assetReaderTrackOutputWithTrackOutputSettings(track: AVAssetTrack, outputSettings?: Map<string, any>): AVAssetReaderTrackOutput;
    audioTimePitchAlgorithm: string;
    setAudioTimePitchAlgorithm(_: string)
    outputSettings: Map<string, any>;
    track: AVAssetTrack;
    static createWithTrackOutputSettings(track: AVAssetTrack, outputSettings?: Map<string, any>): AVAssetReaderTrackOutput;
  }

  // interface
  class AVAssetReaderVideoCompositionOutput extends AVAssetReaderOutput {
    static assetReaderVideoCompositionOutputWithVideoTracksVideoSettings(videoTracks: AVAssetTrack[], videoSettings?: Map<string, any>): AVAssetReaderVideoCompositionOutput;
    customVideoCompositor: AVVideoCompositing;
    videoComposition: AVVideoComposition;
    setVideoComposition(_: AVVideoComposition)
    videoSettings: Map<string, any>;
    videoTracks: AVAssetTrack[];
    static createWithVideoTracksVideoSettings(videoTracks: AVAssetTrack[], videoSettings?: Map<string, any>): AVAssetReaderVideoCompositionOutput;
  }

  // interface
  class AVAssetResourceLoader extends NSObject {
    delegate: AVAssetResourceLoaderDelegate;
    delegateQueue: NSObject;
    preloadsEligibleContentKeys: boolean;
    setPreloadsEligibleContentKeys(_: boolean)
    setDelegateQueue(_?: AVAssetResourceLoaderDelegate, queue?: NSObject): void;
  }

  interface AVAssetResourceLoaderDelegate extends NSObject {
    // instance method
    resourceLoaderDidCancelLoadingRequest?(_: AVAssetResourceLoader, didCancel: AVAssetResourceLoadingRequest): void;
    // instance method
    resourceLoaderShouldWaitForResponseToAuthenticationChallenge?(_: AVAssetResourceLoader, shouldWaitForResponseTo: URLAuthenticationChallenge): boolean;
    // instance method
    resourceLoaderDidCancelAuthenticationChallenge?(_: AVAssetResourceLoader, didCancel: URLAuthenticationChallenge): void;
    // instance method
    resourceLoaderShouldWaitForLoadingOfRequestedResource?(_: AVAssetResourceLoader, shouldWaitForLoadingOfRequestedResource: AVAssetResourceLoadingRequest): boolean;
    // instance method
    resourceLoaderShouldWaitForRenewalOfRequestedResource?(_: AVAssetResourceLoader, shouldWaitForRenewalOfRequestedResource: AVAssetResourceRenewalRequest): boolean;
  }

  // interface
  class AVAssetResourceLoadingContentInformationRequest extends NSObject {
    allowedContentTypes: string[];
    isByteRangeAccessSupported: boolean;
    setByteRangeAccessSupported(_: boolean)
    contentLength: number;
    setContentLength(_: number)
    contentType: string;
    setContentType(_: string)
    renewalDate: Date;
    setRenewalDate(_: Date)
  }

  // interface
  class AVAssetResourceLoadingDataRequest extends NSObject {
    currentOffset: number;
    requestedLength: number;
    requestedOffset: number;
    requestsAllDataToEndOfResource: boolean;
    respondWithData(with_: NSData): void;
  }

  // interface
  class AVAssetResourceLoadingRequest extends NSObject {
    isCancelled: boolean;
    contentInformationRequest: AVAssetResourceLoadingContentInformationRequest;
    dataRequest: AVAssetResourceLoadingDataRequest;
    isFinished: boolean;
    redirect: NSURLRequest;
    setRedirect(_: NSURLRequest)
    request: NSURLRequest;
    requestor: AVAssetResourceLoadingRequestor;
    response: URLResponse;
    setResponse(_: URLResponse)
    finishLoading(): void;
    finishLoadingWithError(with_?: NSError): void;
    persistentContentKeyFromKeyVendorResponseOptionsError(options: NSData, error?: Map<string, any>): NSData;
    streamingContentKeyRequestDataForAppContentIdentifierOptionsError(contentIdentifier: NSData, options: NSData, error?: Map<string, any>): NSData;
  }

  // interface
  class AVAssetResourceLoadingRequestor extends NSObject {
    providesExpiredSessionReports: boolean;
  }

  // interface
  class AVAssetResourceRenewalRequest extends AVAssetResourceLoadingRequest {
  }

  // interface
  class AVAssetTrack extends NSObject /* implements AVAsynchronousKeyValueLoading, NSCopying */ {
    asset: AVAsset;
    availableMetadataFormats: string[];
    availableTrackAssociationTypes: string[];
    canProvideSampleCursors: boolean;
    commonMetadata: AVMetadataItem[];
    isDecodable: boolean;
    isEnabled: boolean;
    estimatedDataRate: number;
    extendedLanguageTag: string;
    formatDescriptions: any[];
    hasAudioSampleDependencies: boolean;
    languageCode: string;
    mediaType: string;
    metadata: AVMetadataItem[];
    minFrameDuration: CMTime;
    naturalSize: CGSize;
    naturalTimeScale: number;
    nominalFrameRate: number;
    isPlayable: boolean;
    preferredTransform: CGAffineTransform;
    preferredVolume: number;
    requiresFrameReordering: boolean;
    segments: AVAssetTrackSegment[];
    isSelfContained: boolean;
    timeRange: CMTimeRange;
    totalSampleDataLength: number;
    trackID: number;
    associatedTracksOfType(ofType: string): AVAssetTrack[];
    hasMediaCharacteristic(_: string): boolean;
    makeSampleCursorAtFirstSampleInDecodeOrder(): AVSampleCursor;
    makeSampleCursorAtLastSampleInDecodeOrder(): AVSampleCursor;
    makeSampleCursorWithPresentationTimeStamp(presentationTimeStamp: CMTime): AVSampleCursor;
    metadataForFormat(forFormat: string): AVMetadataItem[];
    samplePresentationTimeForTrackTime(forTrackTime: CMTime): CMTime;
    segmentForTrackTime(forTrackTime: CMTime): AVAssetTrackSegment;
  }

  // interface
  class AVAssetTrackGroup extends NSObject /* implements NSCopying */ {
    trackIDs: number[];
  }

  // interface
  class AVAssetTrackSegment extends NSObject {
    isEmpty: boolean;
    timeMapping: CMTimeMapping;
  }

  // interface
  class AVAssetWriter extends NSObject {
    static assetWriterWithURLFileTypeError(fileType: NSURL, error: string): AVAssetWriter;
    availableMediaTypes: string[];
    directoryForTemporaryFiles: NSURL;
    setDirectoryForTemporaryFiles(_: NSURL)
    error: NSError;
    inputGroups: AVAssetWriterInputGroup[];
    inputs: AVAssetWriterInput[];
    metadata: AVMetadataItem[];
    setMetadata(_: AVMetadataItem[])
    movieFragmentInterval: CMTime;
    setMovieFragmentInterval(_: CMTime)
    movieTimeScale: number;
    setMovieTimeScale(_: number)
    outputFileType: string;
    outputURL: NSURL;
    overallDurationHint: CMTime;
    setOverallDurationHint(_: CMTime)
    shouldOptimizeForNetworkUse: boolean;
    setShouldOptimizeForNetworkUse(_: boolean)
    status: AVAssetWriter.Status;
    addInput(_: AVAssetWriterInput): void;
    addInputGroup(_: AVAssetWriterInputGroup): void;
    canAddInput(_: AVAssetWriterInput): boolean;
    canAddInputGroup(_: AVAssetWriterInputGroup): boolean;
    canApplyOutputSettingsForMediaType(outputSettings?: Map<string, any>, forMediaType?: string): boolean;
    cancelWriting(): void;
    endSessionAtSourceTime(atSourceTime: CMTime): void;
    finishWritingWithCompletionHandler(completionHandler: () => void): void;
    static createWithUrlFileType(URL: NSURL, fileType: string): AVAssetWriter;
    startSessionAtSourceTime(atSourceTime: CMTime): void;
    startWriting(): boolean;
  }

  // interface
  class AVAssetWriterInput extends NSObject {
    canPerformMultiplePasses: boolean;
    currentPassDescription: AVAssetWriterInputPassDescription;
    expectsMediaDataInRealTime: boolean;
    setExpectsMediaDataInRealTime(_: boolean)
    extendedLanguageTag: string;
    setExtendedLanguageTag(_: string)
    languageCode: string;
    setLanguageCode(_: string)
    marksOutputTrackAsEnabled: boolean;
    setMarksOutputTrackAsEnabled(_: boolean)
    mediaDataLocation: string;
    setMediaDataLocation(_: string)
    mediaTimeScale: number;
    setMediaTimeScale(_: number)
    mediaType: string;
    metadata: AVMetadataItem[];
    setMetadata(_: AVMetadataItem[])
    naturalSize: CGSize;
    setNaturalSize(_: CGSize)
    outputSettings: Map<string, any>;
    performsMultiPassEncodingIfSupported: boolean;
    setPerformsMultiPassEncodingIfSupported(_: boolean)
    preferredMediaChunkAlignment: number;
    setPreferredMediaChunkAlignment(_: number)
    preferredMediaChunkDuration: CMTime;
    setPreferredMediaChunkDuration(_: CMTime)
    preferredVolume: number;
    setPreferredVolume(_: number)
    isReadyForMoreMediaData: boolean;
    sampleReferenceBaseURL: NSURL;
    setSampleReferenceBaseURL(_: NSURL)
    sourceFormatHint: any;
    transform: CGAffineTransform;
    setTransform(_: CGAffineTransform)
    addTrackAssociationWithTrackOfInputType(withTrackOf: AVAssetWriterInput, type: string): void;
    appendSampleBuffer(_: any): boolean;
    canAddTrackAssociationWithTrackOfInputType(withTrackOf: AVAssetWriterInput, type: string): boolean;
    static createWithMediaTypeOutputSettings(mediaType: string, outputSettings?: Map<string, any>): AVAssetWriterInput;
    static createWithMediaTypeOutputSettingsSourceFormatHint(mediaType: string, outputSettings?: Map<string, any>, sourceFormatHint?: any): AVAssetWriterInput;
    markAsFinished(): void;
    markCurrentPassAsFinished(): void;
    requestMediaDataWhenReadyWithOnUsing(on: NSObject, using: () => void): void;
    respondToEachPassDescriptionWithOnUsing(on: NSObject, using: () => void): void;
  }

  // interface
  class AVAssetWriterInputGroup extends AVMediaSelectionGroup {
    static assetWriterInputGroupWithInputsDefaultInput(inputs: AVAssetWriterInput[], defaultInput?: AVAssetWriterInput): AVAssetWriterInputGroup;
    defaultInput: AVAssetWriterInput;
    inputs: AVAssetWriterInput[];
    static createWithInputsDefaultInput(inputs: AVAssetWriterInput[], defaultInput?: AVAssetWriterInput): AVAssetWriterInputGroup;
  }

  // interface
  class AVAssetWriterInputMetadataAdaptor extends NSObject {
    static assetWriterInputMetadataAdaptorWithAssetWriterInput(assetWriterInput: AVAssetWriterInput): AVAssetWriterInputMetadataAdaptor;
    assetWriterInput: AVAssetWriterInput;
    appendTimedMetadataGroup(_: AVTimedMetadataGroup): boolean;
    static createWithAssetWriterInput(assetWriterInput: AVAssetWriterInput): AVAssetWriterInputMetadataAdaptor;
  }

  // interface
  class AVAssetWriterInputPassDescription extends NSObject {
    sourceTimeRanges: NSValue[];
  }

  // interface
  class AVAssetWriterInputPixelBufferAdaptor extends NSObject {
    static assetWriterInputPixelBufferAdaptorWithAssetWriterInputSourcePixelBufferAttributes(assetWriterInput: AVAssetWriterInput, sourcePixelBufferAttributes?: Map<string, any>): AVAssetWriterInputPixelBufferAdaptor;
    assetWriterInput: AVAssetWriterInput;
    pixelBufferPool: any;
    sourcePixelBufferAttributes: Map<string, any>;
    appendPixelBufferWithPresentationTime(_: any, withPresentationTime: CMTime): boolean;
    static createWithAssetWriterInputSourcePixelBufferAttributes(assetWriterInput: AVAssetWriterInput, sourcePixelBufferAttributes?: Map<string, any>): AVAssetWriterInputPixelBufferAdaptor;
  }

  // interface
  class AVAsynchronousCIImageFilteringRequest extends NSObject /* implements NSCopying */ {
    compositionTime: CMTime;
    renderSize: CGSize;
    sourceImage: CIImage;
    finishWithError(with_: NSError): void;
    finishWithImageContext(with_: CIImage, context?: CIContext): void;
  }

  interface AVAsynchronousKeyValueLoading {
    // instance method
    loadValuesAsynchronouslyWithForKeysCompletionHandler(forKeys: string[], completionHandler?: () => void): void;
    // instance method
    statusOfValueForKeyError(forKey: string): AVKeyValueStatus;
  }

  // interface
  class AVAsynchronousVideoCompositionRequest extends NSObject /* implements NSCopying */ {
    compositionTime: CMTime;
    renderContext: AVVideoCompositionRenderContext;
    sourceTrackIDs: number[];
    videoCompositionInstruction: AVVideoCompositionInstruction;
    finishCancelledRequest(): void;
    finishWithComposedVideoFrame(withComposedVideoFrame: any): void;
    finishWithError(with_: NSError): void;
    sourceFrameByTrackID(byTrackID: number): any;
  }

  interface AVAudio3DMixing extends NSObject {
    obstruction: number;
    setObstruction(_: number)
    occlusion: number;
    setOcclusion(_: number)
    pointSourceInHeadMode: AVAudio3DMixingPointSourceInHeadMode;
    setPointSourceInHeadMode(_: AVAudio3DMixingPointSourceInHeadMode)
    // position: AVFAudio.AVAudioTypes;
    // setPosition(_: AVFAudio.AVAudioTypes)
    rate: number;
    setRate(_: number)
    renderingAlgorithm: AVAudio3DMixingRenderingAlgorithm;
    setRenderingAlgorithm(_: AVAudio3DMixingRenderingAlgorithm)
    reverbBlend: number;
    setReverbBlend(_: number)
    sourceMode: AVAudio3DMixingSourceMode;
    setSourceMode(_: AVAudio3DMixingSourceMode)
  }

  // interface
  class AVAudioBuffer extends NSObject /* implements NSCopying, NSMutableCopying */ {
    audioBufferList: AudioBufferList;
    format: AVAudioFormat;
    mutableAudioBufferList: AudioBufferList;
  }

  // interface
  class AVAudioChannelLayout extends NSObject /* implements NSSecureCoding */ {
    channelCount: number;
    layout: AudioChannelLayout;
    layoutTag: number;
    static createWithLayout(layout: AudioChannelLayout): AVAudioChannelLayout;
    static createWithLayoutTag(layoutTag: number): AVAudioChannelLayout;
  }

  // interface
  class AVAudioCompressedBuffer extends AVAudioBuffer {
    byteCapacity: number;
    byteLength: number;
    setByteLength(_: number)
    data: any;
    maximumPacketSize: number;
    packetCapacity: number;
    packetCount: number;
    setPacketCount(_: number)
    packetDescriptions: AudioStreamPacketDescription;
    static createWithFormatPacketCapacity(format: AVAudioFormat, packetCapacity: number): AVAudioCompressedBuffer;
    static createWithFormatPacketCapacityMaximumPacketSize(format: AVAudioFormat, packetCapacity: number, maximumPacketSize: number): AVAudioCompressedBuffer;
  }

  // interface
  class AVAudioConnectionPoint extends NSObject {
    bus: number;
    node: AVAudioNode;
    static createWithNodeBus(node: AVAudioNode, bus: number): AVAudioConnectionPoint;
  }

  // interface
  class AVAudioConverter extends NSObject {
    applicableEncodeBitRates: number[];
    applicableEncodeSampleRates: number[];
    availableEncodeBitRates: number[];
    availableEncodeChannelLayoutTags: number[];
    availableEncodeSampleRates: number[];
    bitRate: number;
    setBitRate(_: number)
    bitRateStrategy: string;
    setBitRateStrategy(_: string)
    channelMap: number[];
    setChannelMap(_: number[])
    dither: boolean;
    setDither(_: boolean)
    downmix: boolean;
    setDownmix(_: boolean)
    inputFormat: AVAudioFormat;
    magicCookie: NSData;
    setMagicCookie(_: NSData)
    maximumOutputPacketSize: number;
    outputFormat: AVAudioFormat;
    primeInfo: AVAudioConverter;
    setPrimeInfo(_: AVAudioConverter)
    primeMethod: AVAudioConverterPrimeMethod;
    setPrimeMethod(_: AVAudioConverterPrimeMethod)
    sampleRateConverterAlgorithm: string;
    setSampleRateConverterAlgorithm(_: string)
    sampleRateConverterQuality: number;
    setSampleRateConverterQuality(_: number)
    convertWithToErrorWithInputFrom(to: AVAudioBuffer, error?: Error, withInputFrom?: (p1: number, p2: AVAudioConverterInputStatus) => AVAudioBuffer): AVAudioConverterOutputStatus;
    convertToBufferFromBufferError(fromBuffer: AVAudioPCMBuffer, error: AVAudioPCMBuffer): boolean;
    static createWithFromFormatToFormat(fromFormat: AVAudioFormat, toFormat: AVAudioFormat): AVAudioConverter;
    reset(): void;
  }

  // interface
  class AVAudioEngine extends NSObject {
    attachedNodes: NSSet<AVAudioNode>;
    isAutoShutdownEnabled: boolean;
    setAutoShutdownEnabled(_: boolean)
    inputNode: AVAudioInputNode;
    isInManualRenderingMode: boolean;
    mainMixerNode: AVAudioMixerNode;
    manualRenderingBlock: (p1: number, p2: AudioBufferList, p3: number) => AVAudioEngineManualRenderingStatus;
    manualRenderingFormat: AVAudioFormat;
    manualRenderingMaximumFrameCount: number;
    manualRenderingMode: AVAudioEngineManualRenderingMode;
    manualRenderingSampleTime: number;
    musicSequence: any;
    setMusicSequence(_: any)
    outputNode: AVAudioOutputNode;
    isRunning: boolean;
    attachNode(_: AVAudioNode): void;
    connectToFormat(_: AVAudioNode, to: AVAudioNode, format?: AVAudioFormat): void;
    connectToFromBusToBusFormat(_: AVAudioNode, to: AVAudioNode, fromBus: number, toBus: number, format?: AVAudioFormat): void;
    connectToConnectionPointsFromBusFormat(_: AVAudioNode, to: AVAudioConnectionPoint[], fromBus: number, format?: AVAudioFormat): void;
    connectMIDIWithToFormatBlock(_: AVAudioNode, to: AVAudioNode, format?: AVAudioFormat, block?: (p1: number, p2: number, p3: number, p4: string) => number): void;
    connectMIDIToFormatBlock(_: AVAudioNode, to: AVAudioNode[], format?: AVAudioFormat, block?: (p1: number, p2: number, p3: number, p4: string) => number): void;
    detachNode(_: AVAudioNode): void;
    disableManualRenderingMode(): void;
    disconnectMIDIFrom(_: AVAudioNode, from: AVAudioNode): void;
    disconnectMIDIFromNodes(_: AVAudioNode, from: AVAudioNode[]): void;
    disconnectMIDIInput(_: AVAudioNode): void;
    disconnectMIDIOutput(_: AVAudioNode): void;
    disconnectNodeInput(_: AVAudioNode): void;
    disconnectNodeInputBus(_: AVAudioNode, bus: number): void;
    disconnectNodeOutput(_: AVAudioNode): void;
    disconnectNodeOutputBus(_: AVAudioNode, bus: number): void;
    enableManualRenderingModeFormatMaximumFrameCountError(format: AVAudioEngineManualRenderingMode, maximumFrameCount: AVAudioFormat, error: number): boolean;
    inputConnectionPointForNodeInputBus(for_: AVAudioNode, inputBus: number): AVAudioConnectionPoint;
    outputConnectionPointsForNodeOutputBus(for_: AVAudioNode, outputBus: number): AVAudioConnectionPoint[];
    pause(): void;
    prepare(): void;
    renderOfflineToBufferError(toBuffer: number, error: AVAudioPCMBuffer): AVAudioEngineManualRenderingStatus;
    reset(): void;
    startAndReturnError(): boolean;
    stop(): void;
  }

  // interface
  class AVAudioEnvironmentDistanceAttenuationParameters extends NSObject {
    distanceAttenuationModel: AVAudioEnvironmentDistanceAttenuationModel;
    setDistanceAttenuationModel(_: AVAudioEnvironmentDistanceAttenuationModel)
    maximumDistance: number;
    setMaximumDistance(_: number)
    referenceDistance: number;
    setReferenceDistance(_: number)
    rolloffFactor: number;
    setRolloffFactor(_: number)
  }

  // interface
  class AVAudioEnvironmentNode extends AVAudioNode /* implements AVAudioMixing */ {
    applicableRenderingAlgorithms: number[];
    distanceAttenuationParameters: AVAudioEnvironmentDistanceAttenuationParameters;
    // listenerAngularOrientation: AVFAudio.AVAudioTypes;
    // setListenerAngularOrientation(_: AVFAudio.AVAudioTypes)
    // listenerPosition: AVFAudio.AVAudioTypes;
    // setListenerPosition(_: AVFAudio.AVAudioTypes)
    // listenerVectorOrientation: AVFAudio.AVAudioTypes;
    // setListenerVectorOrientation(_: AVFAudio.AVAudioTypes)
    nextAvailableInputBus: number;
    outputType: AVAudioEnvironmentOutputType;
    setOutputType(_: AVAudioEnvironmentOutputType)
    outputVolume: number;
    setOutputVolume(_: number)
    reverbParameters: AVAudioEnvironmentReverbParameters;
  }

  // interface
  class AVAudioEnvironmentReverbParameters extends NSObject {
    enable: boolean;
    setEnable(_: boolean)
    filterParameters: AVAudioUnitEQFilterParameters;
    level: number;
    setLevel(_: number)
    loadFactoryReverbPreset(_: AVAudioUnitReverbPreset): void;
  }

  // interface
  class AVAudioFile extends NSObject {
    fileFormat: AVAudioFormat;
    framePosition: number;
    setFramePosition(_: number)
    length: number;
    processingFormat: AVAudioFormat;
    url: NSURL;
    static createWithForReadingCommonFormatInterleaved(forReading: NSURL, commonFormat: AVAudioCommonFormat, interleaved: boolean): AVAudioFile;
    static createWithForReading(forReading: NSURL): AVAudioFile;
    static createWithForWritingSettingsCommonFormatInterleaved(forWriting: NSURL, settings: Map<string, any>, commonFormat: AVAudioCommonFormat, interleaved: boolean): AVAudioFile;
    static createWithForWritingSettings(forWriting: NSURL, settings: Map<string, any>): AVAudioFile;
    readIntoBufferError(error: AVAudioPCMBuffer): boolean;
    readIntoBufferFrameCountError(frameCount: AVAudioPCMBuffer, error: number): boolean;
    writeFromBufferError(error: AVAudioPCMBuffer): boolean;
  }

  // interface
  class AVAudioFormat extends NSObject /* implements NSSecureCoding */ {
    channelCount: number;
    channelLayout: AVAudioChannelLayout;
    commonFormat: AVAudioCommonFormat;
    formatDescription: any;
    isInterleaved: boolean;
    magicCookie: NSData;
    setMagicCookie(_: NSData)
    sampleRate: number;
    settings: Map<string, any>;
    isStandard: boolean;
    streamDescription: AudioStreamBasicDescription;
    static createWithStandardFormatWithSampleRateChannelLayout(standardFormatWithSampleRate: number, channelLayout: AVAudioChannelLayout): AVAudioFormat;
    static createWithStandardFormatWithSampleRateChannels(standardFormatWithSampleRate: number, channels: number): AVAudioFormat;
    static createWithCMAudioFormatDescription(CMAudioFormatDescription: any): AVAudioFormat;
    static createWithCommonFormatSampleRateChannelsInterleaved(commonFormat: AVAudioCommonFormat, sampleRate: number, channels: number, interleaved: boolean): AVAudioFormat;
    static createWithCommonFormatSampleRateInterleavedChannelLayout(commonFormat: AVAudioCommonFormat, sampleRate: number, interleaved: boolean, channelLayout: AVAudioChannelLayout): AVAudioFormat;
    static createWithSettings(settings: Map<string, any>): AVAudioFormat;
    static createWithStreamDescription(streamDescription: AudioStreamBasicDescription): AVAudioFormat;
    static createWithStreamDescriptionChannelLayout(streamDescription: AudioStreamBasicDescription, channelLayout?: AVAudioChannelLayout): AVAudioFormat;
  }

  // interface
  class AVAudioIONode extends AVAudioNode {
    // audioUnit: CarbonCore.Components;
    presentationLatency: number;
    isVoiceProcessingEnabled: boolean;
    setVoiceProcessingEnabledError(error: boolean): boolean;
  }

  // interface
  class AVAudioInputNode extends AVAudioIONode /* implements AVAudioMixing */ {
    isVoiceProcessingAGCEnabled: boolean;
    setVoiceProcessingAGCEnabled(_: boolean)
    isVoiceProcessingBypassed: boolean;
    setVoiceProcessingBypassed(_: boolean)
    isVoiceProcessingInputMuted: boolean;
    setVoiceProcessingInputMuted(_: boolean)
    setManualRenderingInputPCMFormatWithInputBlock(_: AVAudioFormat, inputBlock: (p1: number) => AudioBufferList): boolean;
  }

  // interface
  class AVAudioMix extends NSObject /* implements NSCopying, NSMutableCopying */ {
    inputParameters: AVAudioMixInputParameters[];
  }

  // interface
  class AVAudioMixInputParameters extends NSObject /* implements NSCopying, NSMutableCopying */ {
    audioTapProcessor: any;
    audioTimePitchAlgorithm: string;
    trackID: number;
    getVolumeRampForTimeStartVolumeEndVolumeTimeRange(for_: CMTime, startVolume?: number, endVolume?: number, timeRange?: CMTimeRange): boolean;
  }

  // interface
  class AVAudioMixerNode extends AVAudioNode /* implements AVAudioMixing */ {
    nextAvailableInputBus: number;
    outputVolume: number;
    setOutputVolume(_: number)
  }

  interface AVAudioMixing extends AVAudio3DMixing, AVAudioStereoMixing {
    volume: number;
    setVolume(_: number)
    // instance method
    destinationForMixerBus(forMixer: AVAudioNode, bus: number): AVAudioMixingDestination;
  }

  // interface
  class AVAudioMixingDestination extends NSObject /* implements AVAudioMixing */ {
    connectionPoint: AVAudioConnectionPoint;
  }

  // interface
  class AVAudioNode extends NSObject {
    AUAudioUnit: AUAudioUnit;
    engine: AVAudioEngine;
    lastRenderTime: AVAudioTime;
    latency: number;
    numberOfInputs: number;
    numberOfOutputs: number;
    outputPresentationLatency: number;
    inputFormatForBus(forBus: number): AVAudioFormat;
    installTapWithOnBusBufferSizeFormatBlock(onBus: number, bufferSize: number, format?: AVAudioFormat, block?: (p1: AVAudioPCMBuffer, p2: AVAudioTime) => void): void;
    nameForInputBus(forInputBus: number): string;
    nameForOutputBus(forOutputBus: number): string;
    outputFormatForBus(forBus: number): AVAudioFormat;
    removeTapOnBus(onBus: number): void;
    reset(): void;
  }

  // interface
  class AVAudioOutputNode extends AVAudioIONode {
  }

  // interface
  class AVAudioPCMBuffer extends AVAudioBuffer {
    floatChannelData: number;
    frameCapacity: number;
    frameLength: number;
    setFrameLength(_: number)
    int16ChannelData: number;
    int32ChannelData: number;
    stride: number;
    static createWithPCMFormatFrameCapacity(PCMFormat: AVAudioFormat, frameCapacity: number): AVAudioPCMBuffer;
  }

  // interface
  class AVAudioPlayer extends NSObject {
    currentDevice: string;
    setCurrentDevice(_: string)
    currentTime: number;
    setCurrentTime(_: number)
    data: NSData;
    delegate: AVAudioPlayerDelegate;
    setDelegate(_: AVAudioPlayerDelegate)
    deviceCurrentTime: number;
    duration: number;
    enableRate: boolean;
    setEnableRate(_: boolean)
    format: AVAudioFormat;
    isMeteringEnabled: boolean;
    setMeteringEnabled(_: boolean)
    numberOfChannels: number;
    numberOfLoops: number;
    setNumberOfLoops(_: number)
    pan: number;
    setPan(_: number)
    isPlaying: boolean;
    rate: number;
    setRate(_: number)
    settings: Map<string, any>;
    url: NSURL;
    volume: number;
    setVolume(_: number)
    averagePowerForChannel(forChannel: number): number;
    static createWithContentsOfURL(contentsOfURL: NSURL): AVAudioPlayer;
    static createWithContentsOfURLFileTypeHint(contentsOfURL: NSURL, fileTypeHint?: string): AVAudioPlayer;
    static createWithData(data: NSData): AVAudioPlayer;
    static createWithDataFileTypeHint(data: NSData, fileTypeHint?: string): AVAudioPlayer;
    pause(): void;
    peakPowerForChannel(forChannel: number): number;
    play(): boolean;
    playAtTime(atTime: number): boolean;
    prepareToPlay(): boolean;
    setVolumeFadeDuration(_: number, fadeDuration: number): void;
    stop(): void;
    updateMeters(): void;
  }

  interface AVAudioPlayerDelegate extends NSObject {
    // instance method
    audioPlayerDecodeErrorDidOccurError?(_: AVAudioPlayer, error?: NSError): void;
    // instance method
    audioPlayerDidFinishPlayingSuccessfully?(_: AVAudioPlayer, successfully: boolean): void;
  }

  // interface
  class AVAudioPlayerNode extends AVAudioNode /* implements AVAudioMixing */ {
    isPlaying: boolean;
    nodeTimeForPlayerTime(forPlayerTime: AVAudioTime): AVAudioTime;
    pause(): void;
    play(): void;
    playAtTime(at?: AVAudioTime): void;
    playerTimeForNodeTime(forNodeTime: AVAudioTime): AVAudioTime;
    prepareWithFrameCount(withFrameCount: number): void;
    scheduleBufferAtOptionsCompletionCallbackTypeCompletionHandler(_: AVAudioPCMBuffer, at?: AVAudioTime, options?: AVAudioPlayerNodeBufferOptions, completionCallbackType?: AVAudioPlayerNodeCompletionCallbackType, completionHandler?: (p1: AVAudioPlayerNodeCompletionCallbackType) => void): void;
    scheduleBufferAtOptionsCompletionHandler(_: AVAudioPCMBuffer, at?: AVAudioTime, options?: AVAudioPlayerNodeBufferOptions, completionHandler?: () => void): void;
    scheduleBufferWithCompletionCallbackTypeCompletionHandler(_: AVAudioPCMBuffer, completionCallbackType: AVAudioPlayerNodeCompletionCallbackType, completionHandler?: (p1: AVAudioPlayerNodeCompletionCallbackType) => void): void;
    scheduleBufferWithCompletionHandler(_: AVAudioPCMBuffer, completionHandler?: () => void): void;
    scheduleFileAtCompletionCallbackTypeCompletionHandler(_: AVAudioFile, at?: AVAudioTime, completionCallbackType?: AVAudioPlayerNodeCompletionCallbackType, completionHandler?: (p1: AVAudioPlayerNodeCompletionCallbackType) => void): void;
    scheduleFileAtCompletionHandler(_: AVAudioFile, at?: AVAudioTime, completionHandler?: () => void): void;
    scheduleSegmentStartingFrameFrameCountAtCompletionCallbackTypeCompletionHandler(_: AVAudioFile, startingFrame: number, frameCount: number, at?: AVAudioTime, completionCallbackType?: AVAudioPlayerNodeCompletionCallbackType, completionHandler?: (p1: AVAudioPlayerNodeCompletionCallbackType) => void): void;
    scheduleSegmentStartingFrameFrameCountAtCompletionHandler(_: AVAudioFile, startingFrame: number, frameCount: number, at?: AVAudioTime, completionHandler?: () => void): void;
    stop(): void;
  }

  // interface
  class AVAudioRecorder extends NSObject {
    currentTime: number;
    delegate: AVAudioRecorderDelegate;
    setDelegate(_: AVAudioRecorderDelegate)
    deviceCurrentTime: number;
    format: AVAudioFormat;
    isMeteringEnabled: boolean;
    setMeteringEnabled(_: boolean)
    isRecording: boolean;
    settings: Map<string, any>;
    url: NSURL;
    averagePowerForChannel(forChannel: number): number;
    deleteRecording(): boolean;
    static createWithUrlFormat(URL: NSURL, format: AVAudioFormat): AVAudioRecorder;
    static createWithUrlSettings(URL: NSURL, settings: Map<string, any>): AVAudioRecorder;
    pause(): void;
    peakPowerForChannel(forChannel: number): number;
    prepareToRecord(): boolean;
    record(): boolean;
    recordAtTime(atTime: number): boolean;
    recordAtTimeForDuration(atTime: number, forDuration: number): boolean;
    recordForDuration(forDuration: number): boolean;
    stop(): void;
    updateMeters(): void;
  }

  interface AVAudioRecorderDelegate extends NSObject {
    // instance method
    audioRecorderDidFinishRecordingSuccessfully?(_: AVAudioRecorder, successfully: boolean): void;
    // instance method
    audioRecorderEncodeErrorDidOccurError?(_: AVAudioRecorder, error?: NSError): void;
  }

  // interface
  class AVAudioSequencer extends NSObject {
    currentPositionInBeats: number;
    setCurrentPositionInBeats(_: number)
    currentPositionInSeconds: number;
    setCurrentPositionInSeconds(_: number)
    isPlaying: boolean;
    rate: number;
    setRate(_: number)
    tempoTrack: AVMusicTrack;
    tracks: AVMusicTrack[];
    userInfo: Map<string, any>;
    beatsForHostTimeError(forHostTime: number): number;
    beatsForSeconds(forSeconds: number): number;
    dataWithSMPTEResolutionError(withSMPTEResolution: number): NSData;
    hostTimeForBeatsError(forBeats: number): number;
    static createWithAudioEngine(audioEngine: AVAudioEngine): AVAudioSequencer;
    loadFromDataOptionsError(options: NSData, error: AVMusicSequenceLoadOptions): boolean;
    loadFromURLOptionsError(options: NSURL, error: AVMusicSequenceLoadOptions): boolean;
    prepareToPlay(): void;
    secondsForBeats(forBeats: number): number;
    startAndReturnError(): boolean;
    stop(): void;
    writeToURLSMPTEResolutionReplaceExistingError(SMPTEResolution: NSURL, replaceExisting: number, error: boolean): boolean;
  }

  // interface
  class AVAudioSinkNode extends AVAudioNode {
    static createWithReceiverBlock(receiverBlock: (p1: AudioTimeStamp, p2: number, p3: AudioBufferList) => number): AVAudioSinkNode;
  }

  // interface
  class AVAudioSourceNode extends AVAudioNode /* implements AVAudioMixing */ {
    static createWithFormatRenderBlock(format: AVAudioFormat, renderBlock: (p1: boolean, p2: AudioTimeStamp, p3: number, p4: AudioBufferList) => number): AVAudioSourceNode;
    static createWithRenderBlock(renderBlock: (p1: boolean, p2: AudioTimeStamp, p3: number, p4: AudioBufferList) => number): AVAudioSourceNode;
  }

  interface AVAudioStereoMixing extends NSObject {
    pan: number;
    setPan(_: number)
  }

  // interface
  class AVAudioTime extends NSObject {
    static hostTimeForSeconds(forSeconds: number): number;
    static secondsForHostTime(forHostTime: number): number;
    audioTimeStamp: AudioTimeStamp;
    hostTime: number;
    isHostTimeValid: boolean;
    sampleRate: number;
    sampleTime: number;
    isSampleTimeValid: boolean;
    extrapolateTimeFromAnchor(fromAnchor: AVAudioTime): AVAudioTime;
    static createWithAudioTimeStampSampleRate(audioTimeStamp: AudioTimeStamp, sampleRate: number): AVAudioTime;
    static createWithHostTime(hostTime: number): AVAudioTime;
    static createWithHostTimeSampleTimeAtRate(hostTime: number, sampleTime: number, atRate: number): AVAudioTime;
    static createWithSampleTimeAtRate(sampleTime: number, atRate: number): AVAudioTime;
  }

  // interface
  class AVAudioUnit extends AVAudioNode {
    static instantiateWithWithOptionsCompletionHandler(with_: AudioComponentDescription, options: AudioComponentInstantiationOptions, completionHandler?: (p1: AVAudioUnit, p2: NSError) => void): void;
    audioComponentDescription: AudioComponentDescription;
    // audioUnit: CarbonCore.Components;
    manufacturerName: string;
    name: string;
    loadAudioUnitPresetAtURLError(error: NSURL): boolean;
  }

  // interface
  class AVAudioUnitComponent extends NSObject {
    allTagNames: string[];
    audioComponent: any;
    audioComponentDescription: AudioComponentDescription;
    availableArchitectures: number[];
    configurationDictionary: Map<string, any>;
    hasCustomView: boolean;
    hasMIDIInput: boolean;
    hasMIDIOutput: boolean;
    icon: NSImage;
    iconURL: NSURL;
    localizedTypeName: string;
    manufacturerName: string;
    name: string;
    passesAUVal: boolean;
    isSandboxSafe: boolean;
    typeName: string;
    userTagNames: string[];
    setUserTagNames(_: string[])
    versionString: string;
    supportsNumberInputChannelsOutputChannels(_: number, outputChannels: number): boolean;
  }

  // interface
  class AVAudioUnitComponentManager extends NSObject {
    static sharedAudioUnitComponentManager(): AVAudioUnitComponentManager;
    standardLocalizedTagNames: string[];
    tagNames: string[];
    componentsMatchingDescription(matching: AudioComponentDescription): AVAudioUnitComponent[];
    componentsMatchingPredicate(matching: NSPredicate): AVAudioUnitComponent[];
    componentsWithPassingTest(passingTest: (p1: AVAudioUnitComponent, p2: boolean) => boolean): AVAudioUnitComponent[];
  }

  // interface
  class AVAudioUnitDelay extends AVAudioUnitEffect {
    delayTime: number;
    setDelayTime(_: number)
    feedback: number;
    setFeedback(_: number)
    lowPassCutoff: number;
    setLowPassCutoff(_: number)
    wetDryMix: number;
    setWetDryMix(_: number)
  }

  // interface
  class AVAudioUnitDistortion extends AVAudioUnitEffect {
    preGain: number;
    setPreGain(_: number)
    wetDryMix: number;
    setWetDryMix(_: number)
    loadFactoryPreset(_: AVAudioUnitDistortionPreset): void;
  }

  // interface
  class AVAudioUnitEQ extends AVAudioUnitEffect {
    bands: AVAudioUnitEQFilterParameters[];
    globalGain: number;
    setGlobalGain(_: number)
    static createWithNumberOfBands(numberOfBands: number): AVAudioUnitEQ;
  }

  // interface
  class AVAudioUnitEQFilterParameters extends NSObject {
    bandwidth: number;
    setBandwidth(_: number)
    bypass: boolean;
    setBypass(_: boolean)
    filterType: AVAudioUnitEQFilterType;
    setFilterType(_: AVAudioUnitEQFilterType)
    frequency: number;
    setFrequency(_: number)
    gain: number;
    setGain(_: number)
  }

  // interface
  class AVAudioUnitEffect extends AVAudioUnit {
    bypass: boolean;
    setBypass(_: boolean)
    static createWithAudioComponentDescription(audioComponentDescription: AudioComponentDescription): AVAudioUnitEffect;
  }

  // interface
  class AVAudioUnitGenerator extends AVAudioUnit /* implements AVAudioMixing */ {
    bypass: boolean;
    setBypass(_: boolean)
    static createWithAudioComponentDescription(audioComponentDescription: AudioComponentDescription): AVAudioUnitGenerator;
  }

  // interface
  class AVAudioUnitMIDIInstrument extends AVAudioUnit /* implements AVAudioMixing */ {
    static createWithAudioComponentDescription(audioComponentDescription: AudioComponentDescription): AVAudioUnitMIDIInstrument;
    sendControllerWithValueOnChannel(_: number, withValue: number, onChannel: number): void;
    sendMIDIEventData1(_: number, data1: number): void;
    sendMIDIEventData1Data2(_: number, data1: number, data2: number): void;
    sendMIDISysExEvent(_: NSData): void;
    sendPitchBendOnChannel(_: number, onChannel: number): void;
    sendPressureOnChannel(_: number, onChannel: number): void;
    sendPressureForKeyWithValueOnChannel(forKey: number, withValue: number, onChannel: number): void;
    sendProgramChangeBankMSBBankLSBOnChannel(_: number, bankMSB: number, bankLSB: number, onChannel: number): void;
    sendProgramChangeOnChannel(_: number, onChannel: number): void;
    startNoteWithVelocityOnChannel(_: number, withVelocity: number, onChannel: number): void;
    stopNoteOnChannel(_: number, onChannel: number): void;
  }

  // interface
  class AVAudioUnitReverb extends AVAudioUnitEffect {
    wetDryMix: number;
    setWetDryMix(_: number)
    loadFactoryPreset(_: AVAudioUnitReverbPreset): void;
  }

  // interface
  class AVAudioUnitSampler extends AVAudioUnitMIDIInstrument {
    globalTuning: number;
    setGlobalTuning(_: number)
    masterGain: number;
    setMasterGain(_: number)
    stereoPan: number;
    setStereoPan(_: number)
    loadAudioFilesAtURLsError(error: NSURL[]): boolean;
    loadInstrumentAtURLError(error: NSURL): boolean;
    loadSoundBankInstrumentAtURLProgramBankMSBBankLSBError(program: NSURL, bankMSB: number, bankLSB: number, error: number): boolean;
  }

  // interface
  class AVAudioUnitTimeEffect extends AVAudioUnit {
    bypass: boolean;
    setBypass(_: boolean)
    static createWithAudioComponentDescription(audioComponentDescription: AudioComponentDescription): AVAudioUnitTimeEffect;
  }

  // interface
  class AVAudioUnitTimePitch extends AVAudioUnitTimeEffect {
    overlap: number;
    setOverlap(_: number)
    pitch: number;
    setPitch(_: number)
    rate: number;
    setRate(_: number)
  }

  // interface
  class AVAudioUnitVarispeed extends AVAudioUnitTimeEffect {
    rate: number;
    setRate(_: number)
  }

  // interface
  class AVCameraCalibrationData extends NSObject {
    extrinsicMatrix: simd_float4x3;
    intrinsicMatrix: simd_float3x3;
    intrinsicMatrixReferenceDimensions: CGSize;
    inverseLensDistortionLookupTable: NSData;
    lensDistortionCenter: CGPoint;
    lensDistortionLookupTable: NSData;
    pixelSize: number;
  }

  // interface
  class AVCaptureAudioChannel extends NSObject {
    averagePowerLevel: number;
    isEnabled: boolean;
    setEnabled(_: boolean)
    peakHoldLevel: number;
    volume: number;
    setVolume(_: number)
  }

  // interface
  class AVCaptureAudioDataOutput extends AVCaptureOutput {
    audioSettings: Map<string, any>;
    setAudioSettings(_: Map<string, any>)
    sampleBufferCallbackQueue: NSObject;
    sampleBufferDelegate: AVCaptureAudioDataOutputSampleBufferDelegate;
    recommendedAudioSettingsForAssetWriterWithOutputFileType(writingTo: string): Map<any, any>;
    setSampleBufferDelegateQueue(_?: AVCaptureAudioDataOutputSampleBufferDelegate, queue?: NSObject): void;
  }

  interface AVCaptureAudioDataOutputSampleBufferDelegate extends NSObject {
    // instance method
    captureOutputDidOutputSampleBufferFromConnection?(_: AVCaptureOutput, didOutput: any, from: AVCaptureConnection): void;
  }

  // interface
  class AVCaptureAudioFileOutput extends AVCaptureFileOutput {
    static availableOutputFileTypes(): string[];
    audioSettings: Map<string, any>;
    setAudioSettings(_: Map<string, any>)
    metadata: AVMetadataItem[];
    setMetadata(_: AVMetadataItem[])
    startRecordingToOutputFileURLOutputFileTypeRecordingDelegate(to: NSURL, outputFileType: string, recordingDelegate: AVCaptureFileOutputRecordingDelegate): void;
  }

  // interface
  class AVCaptureAudioPreviewOutput extends AVCaptureOutput {
    outputDeviceUniqueID: string;
    setOutputDeviceUniqueID(_: string)
    volume: number;
    setVolume(_: number)
  }

  // interface
  class AVCaptureConnection extends NSObject {
    static connectionWithInputPortVideoPreviewLayer(inputPort: Port, videoPreviewLayer: AVCaptureVideoPreviewLayer): AVCaptureConnection;
    static connectionWithInputPortsOutput(inputPorts: Port[], output: AVCaptureOutput): AVCaptureConnection;
    isActive: boolean;
    audioChannels: AVCaptureAudioChannel[];
    automaticallyAdjustsVideoMirroring: boolean;
    setAutomaticallyAdjustsVideoMirroring(_: boolean)
    isEnabled: boolean;
    setEnabled(_: boolean)
    inputPorts: Port[];
    output: AVCaptureOutput;
    isVideoFieldModeSupported: boolean;
    isVideoMaxFrameDurationSupported: boolean;
    isVideoMinFrameDurationSupported: boolean;
    isVideoMirroringSupported: boolean;
    isVideoOrientationSupported: boolean;
    videoFieldMode: AVVideoFieldMode;
    setVideoFieldMode(_: AVVideoFieldMode)
    videoMaxFrameDuration: CMTime;
    setVideoMaxFrameDuration(_: CMTime)
    videoMinFrameDuration: CMTime;
    setVideoMinFrameDuration(_: CMTime)
    isVideoMirrored: boolean;
    setVideoMirrored(_: boolean)
    videoOrientation: AVCaptureVideoOrientation;
    setVideoOrientation(_: AVCaptureVideoOrientation)
    videoPreviewLayer: AVCaptureVideoPreviewLayer;
    static createWithInputPortVideoPreviewLayer(inputPort: Port, videoPreviewLayer: AVCaptureVideoPreviewLayer): AVCaptureConnection;
    static createWithInputPortsOutput(inputPorts: Port[], output: AVCaptureOutput): AVCaptureConnection;
  }

  // interface
  class AVCaptureDevice extends NSObject {
    static authorizationStatusForMediaType(for_: string): AVAuthorizationStatus;
    static defaultDeviceWithDeviceTypeMediaTypePosition(_: string, for_?: string, position?: AVCaptureDevice.Position): AVCaptureDevice;
    static defaultDeviceWithMediaType(for_: string): AVCaptureDevice;
    static requestAccessForCompletionHandler(for_: string, completionHandler: (p1: boolean) => void): void;
    activeColorSpace: AVCaptureColorSpace;
    setActiveColorSpace(_: AVCaptureColorSpace)
    activeFormat: Format;
    setActiveFormat(_: Format)
    activeInputSource: InputSource;
    setActiveInputSource(_: InputSource)
    activeVideoMaxFrameDuration: CMTime;
    setActiveVideoMaxFrameDuration(_: CMTime)
    activeVideoMinFrameDuration: CMTime;
    setActiveVideoMinFrameDuration(_: CMTime)
    isAdjustingExposure: boolean;
    isAdjustingFocus: boolean;
    isAdjustingWhiteBalance: boolean;
    isConnected: boolean;
    deviceType: string;
    exposureMode: AVCaptureDevice.ExposureMode;
    setExposureMode(_: AVCaptureDevice.ExposureMode)
    exposurePointOfInterest: CGPoint;
    setExposurePointOfInterest(_: CGPoint)
    isExposurePointOfInterestSupported: boolean;
    isFlashAvailable: boolean;
    flashMode: AVCaptureDevice.FlashMode;
    setFlashMode(_: AVCaptureDevice.FlashMode)
    focusMode: AVCaptureDevice.FocusMode;
    setFocusMode(_: AVCaptureDevice.FocusMode)
    focusPointOfInterest: CGPoint;
    setFocusPointOfInterest(_: CGPoint)
    isFocusPointOfInterestSupported: boolean;
    formats: Format[];
    hasFlash: boolean;
    hasTorch: boolean;
    isInUseByAnotherApplication: boolean;
    inputSources: InputSource[];
    linkedDevices: AVCaptureDevice[];
    localizedName: string;
    manufacturer: string;
    modelID: string;
    position: AVCaptureDevice.Position;
    isSuspended: boolean;
    isTorchActive: boolean;
    isTorchAvailable: boolean;
    torchLevel: number;
    torchMode: AVCaptureDevice.TorchMode;
    setTorchMode(_: AVCaptureDevice.TorchMode)
    transportControlsPlaybackMode: AVCaptureDevice.TransportControlsPlaybackMode;
    transportControlsSpeed: number;
    transportControlsSupported: boolean;
    transportType: number;
    uniqueID: string;
    whiteBalanceMode: AVCaptureDevice.WhiteBalanceMode;
    setWhiteBalanceMode(_: AVCaptureDevice.WhiteBalanceMode)
    hasMediaType(_: string): boolean;
    isExposureModeSupported(_: AVCaptureDevice.ExposureMode): boolean;
    isFlashModeSupported(_: AVCaptureDevice.FlashMode): boolean;
    isFocusModeSupported(_: AVCaptureDevice.FocusMode): boolean;
    isTorchModeSupported(_: AVCaptureDevice.TorchMode): boolean;
    isWhiteBalanceModeSupported(_: AVCaptureDevice.WhiteBalanceMode): boolean;
    lockForConfiguration(): boolean;
    setTorchModeOnWithLevelError(level: number): boolean;
    setTransportControlsPlaybackModeSpeed(_: AVCaptureDevice.TransportControlsPlaybackMode, speed: number): void;
    supportsAVCaptureSessionPreset(_: string): boolean;
    unlockForConfiguration(): void;
  }

  // interface
  class DiscoverySession extends NSObject {
    static discoverySessionWithDeviceTypesMediaTypePosition(_: string[], mediaType?: string, position?: AVCaptureDevice.Position): DiscoverySession;
  }

  // interface
  class Format extends NSObject {
    // autoFocusSystem: AVCaptureDeviceFormat.AutoFocusSystem;
    formatDescription: any;
    mediaType: string;
    supportedColorSpaces: number[];
    videoSupportedFrameRateRanges: AVFrameRateRange[];
  }

  // interface
  class AVCaptureDeviceInput extends AVCaptureInput {
    static deviceInputWithDeviceError(error: AVCaptureDevice): AVCaptureDeviceInput;
    device: AVCaptureDevice;
    static createWithDevice(device: AVCaptureDevice): AVCaptureDeviceInput;
  }

  // interface
  class InputSource extends NSObject {
    inputSourceID: string;
    localizedName: string;
  }

  // interface
  class AVCaptureFileOutput extends AVCaptureOutput {
    delegate: AVCaptureFileOutputDelegate;
    setDelegate(_: AVCaptureFileOutputDelegate)
    maxRecordedDuration: CMTime;
    setMaxRecordedDuration(_: CMTime)
    maxRecordedFileSize: number;
    setMaxRecordedFileSize(_: number)
    minFreeDiskSpaceLimit: number;
    setMinFreeDiskSpaceLimit(_: number)
    outputFileURL: NSURL;
    recordedDuration: CMTime;
    recordedFileSize: number;
    isRecording: boolean;
    isRecordingPaused: boolean;
    pauseRecording(): void;
    resumeRecording(): void;
    startRecordingToOutputFileURLRecordingDelegate(to: NSURL, recordingDelegate: AVCaptureFileOutputRecordingDelegate): void;
    stopRecording(): void;
  }

  interface AVCaptureFileOutputDelegate extends NSObject {
    // instance method
    captureOutputDidOutputSampleBufferFromConnection?(_: AVCaptureFileOutput, didOutputSampleBuffer: any, from: AVCaptureConnection): void;
    // instance method
    captureOutputShouldProvideSampleAccurateRecordingStart(_: AVCaptureOutput): boolean;
  }

  interface AVCaptureFileOutputRecordingDelegate extends NSObject {
    // instance method
    captureOutputDidStartRecordingToOutputFileAtURLFromConnections?(_: AVCaptureFileOutput, didStartRecordingTo: NSURL, from: AVCaptureConnection[]): void;
    // instance method
    captureOutputDidPauseRecordingToOutputFileAtURLFromConnections?(_: AVCaptureFileOutput, didPauseRecordingTo: NSURL, from: AVCaptureConnection[]): void;
    // instance method
    captureOutputDidResumeRecordingToOutputFileAtURLFromConnections?(_: AVCaptureFileOutput, didResumeRecordingTo: NSURL, from: AVCaptureConnection[]): void;
    // instance method
    captureOutputWillFinishRecordingToOutputFileAtURLFromConnectionsError?(_: AVCaptureFileOutput, willFinishRecordingTo: NSURL, from: AVCaptureConnection[], error?: NSError): void;
    // instance method
    captureOutputDidFinishRecordingToOutputFileAtURLFromConnectionsError(_: AVCaptureFileOutput, didFinishRecordingTo: NSURL, from: AVCaptureConnection[], error?: NSError): void;
  }

  // interface
  class AVCaptureInput extends NSObject {
    ports: Port[];
  }

  // interface
  class AVCaptureMovieFileOutput extends AVCaptureFileOutput {
    metadata: AVMetadataItem[];
    setMetadata(_: AVMetadataItem[])
    movieFragmentInterval: CMTime;
    setMovieFragmentInterval(_: CMTime)
    outputSettingsForConnection(for_: AVCaptureConnection): Map<string, any>;
    setOutputSettingsForConnection(_?: Map<string, any>, for_?: AVCaptureConnection): void;
  }

  // interface
  class AVCaptureOutput extends NSObject {
    connections: AVCaptureConnection[];
    connectionWithMediaType(with_: string): AVCaptureConnection;
    metadataOutputRectOfInterestForRect(fromOutputRect: CGRect): CGRect;
    rectForMetadataOutputRectOfInterest(fromMetadataOutputRect: CGRect): CGRect;
    transformedMetadataObjectForMetadataObjectConnection(for_: AVMetadataObject, connection: AVCaptureConnection): AVMetadataObject;
  }

  // interface
  class AVCapturePhoto extends NSObject {
    photoCount: number;
    pixelBuffer: any;
    resolvedSettings: AVCaptureResolvedPhotoSettings;
    timestamp: CMTime;
    CGImageRepresentation(): any;
    fileDataRepresentation(): NSData;
  }

  interface AVCapturePhotoCaptureDelegate extends NSObject {
    // instance method
    captureOutputWillBeginCaptureForResolvedSettings?(_: AVCapturePhotoOutput, willBeginCaptureFor: AVCaptureResolvedPhotoSettings): void;
    // instance method
    captureOutputWillCapturePhotoForResolvedSettings?(_: AVCapturePhotoOutput, willCapturePhotoFor: AVCaptureResolvedPhotoSettings): void;
    // instance method
    captureOutputDidCapturePhotoForResolvedSettings?(_: AVCapturePhotoOutput, didCapturePhotoFor: AVCaptureResolvedPhotoSettings): void;
    // instance method
    captureOutputDidFinishProcessingPhotoError?(_: AVCapturePhotoOutput, didFinishProcessingPhoto: AVCapturePhoto, error?: NSError): void;
    // instance method
    captureOutputDidFinishCaptureForResolvedSettingsError?(_: AVCapturePhotoOutput, didFinishCaptureFor: AVCaptureResolvedPhotoSettings, error?: NSError): void;
  }

  // interface
  class AVCapturePhotoOutput extends AVCaptureOutput {
    availablePhotoCodecTypes: string[];
    availablePhotoFileTypes: string[];
    availablePhotoPixelFormatTypes: number[];
    capturePhotoWithSettingsDelegate(with_: AVCapturePhotoSettings, delegate: AVCapturePhotoCaptureDelegate): void;
    supportedPhotoCodecTypesForFileType(for_: string): string[];
    supportedPhotoPixelFormatTypesForFileType(for_: string): number[];
  }

  // interface
  class AVCapturePhotoSettings extends NSObject /* implements NSCopying */ {
    static photoSettings(): AVCapturePhotoSettings;
    static photoSettingsFromPhotoSettings(from: AVCapturePhotoSettings): AVCapturePhotoSettings;
    static photoSettingsWithFormat(format?: Map<string, any>): AVCapturePhotoSettings;
    format: Map<string, any>;
    processedFileType: string;
    uniqueID: number;
  }

  // interface
  class AVCaptureResolvedPhotoSettings extends NSObject {
    expectedPhotoCount: number;
    photoDimensions: CMVideoDimensions;
    uniqueID: number;
  }

  // interface
  class AVCaptureScreenInput extends AVCaptureInput {
    capturesCursor: boolean;
    setCapturesCursor(_: boolean)
    capturesMouseClicks: boolean;
    setCapturesMouseClicks(_: boolean)
    cropRect: CGRect;
    setCropRect(_: CGRect)
    minFrameDuration: CMTime;
    setMinFrameDuration(_: CMTime)
    scaleFactor: number;
    setScaleFactor(_: number)
    static createWithDisplayID(displayID: number): AVCaptureScreenInput;
  }

  // interface
  class AVCaptureSession extends NSObject {
    connections: AVCaptureConnection[];
    inputs: AVCaptureInput[];
    masterClock: any;
    outputs: AVCaptureOutput[];
    isRunning: boolean;
    sessionPreset: string;
    setSessionPreset(_: string)
    addConnection(_: AVCaptureConnection): void;
    addInput(_: AVCaptureInput): void;
    addInputWithNoConnections(_: AVCaptureInput): void;
    addOutput(_: AVCaptureOutput): void;
    addOutputWithNoConnections(_: AVCaptureOutput): void;
    beginConfiguration(): void;
    canAddConnection(_: AVCaptureConnection): boolean;
    canAddInput(_: AVCaptureInput): boolean;
    canAddOutput(_: AVCaptureOutput): boolean;
    canSetSessionPreset(_: string): boolean;
    commitConfiguration(): void;
    removeConnection(_: AVCaptureConnection): void;
    removeInput(_: AVCaptureInput): void;
    removeOutput(_: AVCaptureOutput): void;
    startRunning(): void;
    stopRunning(): void;
  }

  // interface
  class SystemPressureState extends NSObject {
    // factors: AVCaptureSystemPressureState.Factors;
    level: string;
  }

  // interface
  class AVCaptureVideoDataOutput extends AVCaptureOutput {
    alwaysDiscardsLateVideoFrames: boolean;
    setAlwaysDiscardsLateVideoFrames(_: boolean)
    availableVideoCVPixelFormatTypes: number[];
    availableVideoCodecTypes: string[];
    sampleBufferCallbackQueue: NSObject;
    sampleBufferDelegate: AVCaptureVideoDataOutputSampleBufferDelegate;
    videoSettings: Map<string, any>;
    setVideoSettings(_: Map<string, any>)
    availableVideoCodecTypesForAssetWriterWithOutputFileType(writingTo: string): string[];
    recommendedVideoSettingsForAssetWriterWithOutputFileType(writingTo: string): Map<string, any>;
    recommendedVideoSettingsForVideoCodecTypeAssetWriterOutputFileType(forVideoCodecType: string, assetWriterOutputFileType: string): Map<any, any>;
    setSampleBufferDelegateQueue(_?: AVCaptureVideoDataOutputSampleBufferDelegate, queue?: NSObject): void;
  }

  interface AVCaptureVideoDataOutputSampleBufferDelegate extends NSObject {
    // instance method
    captureOutputDidOutputSampleBufferFromConnection?(_: AVCaptureOutput, didOutput: any, from: AVCaptureConnection): void;
    // instance method
    captureOutputDidDropSampleBufferFromConnection?(_: AVCaptureOutput, didDrop: any, from: AVCaptureConnection): void;
  }

  // interface
  class AVCaptureVideoPreviewLayer extends CALayer {
    connection: AVCaptureConnection;
    session: AVCaptureSession;
    setSession(_: AVCaptureSession)
    videoGravity: string;
    setVideoGravity(_: string)
    captureDevicePointOfInterestForPoint(fromLayerPoint: CGPoint): CGPoint;
    static createWithSession(session: AVCaptureSession): AVCaptureVideoPreviewLayer;
    static createWithSessionWithNoConnection(sessionWithNoConnection: AVCaptureSession): AVCaptureVideoPreviewLayer;
    metadataOutputRectOfInterestForRect(fromLayerRect: CGRect): CGRect;
    pointForCaptureDevicePointOfInterest(fromCaptureDevicePoint: CGPoint): CGPoint;
    rectForMetadataOutputRectOfInterest(fromMetadataOutputRect: CGRect): CGRect;
    setSessionWithNoConnection(_: AVCaptureSession): void;
    transformedMetadataObjectForMetadataObject(for_: AVMetadataObject): AVMetadataObject;
  }

  // interface
  class AVComposition extends AVAsset /* implements NSMutableCopying */ {
    URLAssetInitializationOptions: Map<string, any>;
    naturalSize: CGSize;
  }

  // interface
  class AVCompositionTrack extends AVAssetTrack {
    formatDescriptionReplacements: AVCompositionTrackFormatDescriptionReplacement[];
  }

  // interface
  class AVCompositionTrackFormatDescriptionReplacement extends NSObject /* implements NSSecureCoding */ {
    originalFormatDescription: any;
    replacementFormatDescription: any;
  }

  // interface
  class AVCompositionTrackSegment extends AVAssetTrackSegment {
    sourceTrackID: number;
    sourceURL: NSURL;
    static createWithTimeRange(timeRange: CMTimeRange): AVCompositionTrackSegment;
    static createWithUrlTrackIDSourceTimeRangeTargetTimeRange(URL: NSURL, trackID: number, sourceTimeRange: CMTimeRange, targetTimeRange: CMTimeRange): AVCompositionTrackSegment;
  }

  interface AVContentKeyRecipient {
    mayRequireContentKeysForMediaDataProcessing: boolean;
  }

  // interface
  class AVContentKeyRequest extends NSObject {
    canProvidePersistableContentKey: boolean;
    error: NSError;
    identifier: any;
    initializationData: NSData;
    options: Map<string, any>;
    renewsExpiringResponseData: boolean;
    status: AVContentKeyRequest.Status;
    makeStreamingContentKeyRequestDataWithForAppContentIdentifierOptionsCompletionHandler(forApp: NSData, contentIdentifier?: NSData, options?: Map<string, any>, completionHandler?: (p1: NSData, p2: NSError) => void): void;
    processContentKeyResponse(_: AVContentKeyResponse): void;
    processContentKeyResponseError(_: NSError): void;
    respondByRequestingPersistableContentKeyRequestAndReturnError(): boolean;
  }

  // interface
  class AVContentKeyResponse extends NSObject {
    static contentKeyResponseWithAuthorizationTokenData(authorizationTokenData: NSData): AVContentKeyResponse;
    static contentKeyResponseWithClearKeyDataInitializationVector(clearKeyData: NSData, initializationVector?: NSData): AVContentKeyResponse;
    static contentKeyResponseWithFairPlayStreamingKeyResponseData(fairPlayStreamingKeyResponseData: NSData): AVContentKeyResponse;
  }

  // interface
  class AVContentKeySession extends NSObject {
    static pendingExpiredSessionReportsWithAppIdentifierStorageDirectoryAtURL(withAppIdentifier: NSData, storageDirectoryAt: NSURL): NSData[];
    static removePendingExpiredSessionReportsWithAppIdentifierStorageDirectoryAtURL(_: NSData[], withAppIdentifier: NSData, storageDirectoryAt: NSURL): void;
    contentKeyRecipients: AVContentKeyRecipient[];
    contentProtectionSessionIdentifier: NSData;
    delegate: AVContentKeySessionDelegate;
    delegateQueue: NSObject;
    keySystem: string;
    storageURL: NSURL;
    addContentKeyRecipient(_: AVContentKeyRecipient): void;
    expire(): void;
    invalidateAllPersistableContentKeysWithForAppOptionsCompletionHandler(forApp: NSData, options?: Map<string, any>, completionHandler?: (p1: NSData, p2: NSError) => void): void;
    invalidatePersistableContentKeyWithOptionsCompletionHandler(_: NSData, options?: Map<string, any>, completionHandler?: (p1: NSData, p2: NSError) => void): void;
    makeSecureTokenForExpirationDateWithOfPersistableContentKeyCompletionHandler(ofPersistableContentKey: NSData, completionHandler?: (p1: NSData, p2: NSError) => void): void;
    processContentKeyRequestWithIdentifierInitializationDataOptions(withIdentifier?: any, initializationData?: NSData, options?: Map<string, any>): void;
    removeContentKeyRecipient(_: AVContentKeyRecipient): void;
    renewExpiringResponseDataForContentKeyRequest(for_: AVContentKeyRequest): void;
    setDelegateQueue(_?: AVContentKeySessionDelegate, queue?: NSObject): void;
  }

  interface AVContentKeySessionDelegate extends NSObject {
    // instance method
    contentKeySessionDidProvideContentKeyRequest(_: AVContentKeySession, didProvide: AVContentKeyRequest): void;
    // instance method
    contentKeySessionDidProvidePersistableContentKeyRequest?(_: AVContentKeySession, didProvide: AVPersistableContentKeyRequest): void;
    // instance method
    contentKeySessionShouldRetryContentKeyRequestReason?(_: AVContentKeySession, shouldRetry: AVContentKeyRequest, reason: string): boolean;
    // instance method
    contentKeySessionContentKeyRequestDidFailWithError?(_: AVContentKeySession, contentKeyRequest: AVContentKeyRequest, didFailWithError: NSError): void;
    // instance method
    contentKeySessionContentKeyRequestDidSucceed?(_: AVContentKeySession, contentKeyRequestDidSucceed: AVContentKeyRequest): void;
    // instance method
    contentKeySessionDidProvideRenewingContentKeyRequest?(_: AVContentKeySession, didProvideRenewingContentKeyRequest: AVContentKeyRequest): void;
    // instance method
    contentKeySessionDidUpdatePersistableContentKeyForContentKeyIdentifier?(_: AVContentKeySession, didUpdatePersistableContentKey: NSData, forContentKeyIdentifier: any): void;
    // instance method
    contentKeySessionContentProtectionSessionIdentifierDidChange?(_: AVContentKeySession): void;
    // instance method
    contentKeySessionDidGenerateExpiredSessionReport?(_: AVContentKeySession): void;
  }

  // interface
  class AVDateRangeMetadataGroup extends AVMetadataGroup /* implements NSCopying, NSMutableCopying */ {
    endDate: Date;
    startDate: Date;
    static createWithItemsStartDateEndDate(items: AVMetadataItem[], startDate: Date, endDate?: Date): AVDateRangeMetadataGroup;
  }

  // interface
  class AVDepthData extends NSObject {
    static depthDataFromDictionaryRepresentationError(error: Map<any, any>): AVDepthData;
    availableDepthDataTypes: number[];
    cameraCalibrationData: AVCameraCalibrationData;
    depthDataAccuracy: AVDepthData.Accuracy;
    isDepthDataFiltered: boolean;
    depthDataMap: any;
    depthDataQuality: AVDepthData.Quality;
    depthDataType: number;
    depthDataByApplyingExifOrientation(_: CGImagePropertyOrientation): AVDepthData;
    depthDataByConvertingToDepthDataType(toDepthDataType: number): AVDepthData;
    depthDataByReplacingDepthDataMapWithPixelBufferError(error: any): AVDepthData;
    dictionaryRepresentationForAuxiliaryDataType(forAuxiliaryDataType?: string): Map<any, any>;
  }

  interface AVFragmentMinding {
    isAssociatedWithFragmentMinder: boolean;
  }

  // interface
  class AVFragmentedAsset extends AVURLAsset /* implements AVFragmentMinding */ {
    static fragmentedAssetWithURLOptions(url: NSURL, options?: Map<string, any>): AVFragmentedAsset;
  }

  // interface
  class AVFragmentedAssetMinder extends NSObject {
    static fragmentedAssetMinderWithAssetMindingInterval(asset: AVAsset, mindingInterval: number): AVFragmentedAssetMinder;
    assets: AVAsset[];
    mindingInterval: number;
    setMindingInterval(_: number)
    addFragmentedAsset(_: AVAsset): void;
    static createWithAssetMindingInterval(asset: AVAsset, mindingInterval: number): AVFragmentedAssetMinder;
    removeFragmentedAsset(_: AVAsset): void;
  }

  // interface
  class AVFragmentedAssetTrack extends AVAssetTrack {
  }

  // interface
  class AVFragmentedMovie extends AVMovie /* implements AVFragmentMinding */ {
  }

  // interface
  class AVFragmentedMovieMinder extends AVFragmentedAssetMinder {
    static fragmentedMovieMinderWithMovieMindingInterval(movie: AVFragmentedMovie, mindingInterval: number): AVFragmentedMovieMinder;
    movies: AVFragmentedMovie[];
    addFragmentedMovie(_: AVFragmentedMovie): void;
    static createWithMovieMindingInterval(movie: AVFragmentedMovie, mindingInterval: number): AVFragmentedMovieMinder;
    removeFragmentedMovie(_: AVFragmentedMovie): void;
  }

  // interface
  class AVFragmentedMovieTrack extends AVMovieTrack {
  }

  // interface
  class AVFrameRateRange extends NSObject {
    maxFrameDuration: CMTime;
    maxFrameRate: number;
    minFrameDuration: CMTime;
    minFrameRate: number;
  }

  // interface
  class AVMIDIPlayer extends NSObject {
    currentPosition: number;
    setCurrentPosition(_: number)
    duration: number;
    isPlaying: boolean;
    rate: number;
    setRate(_: number)
    static createWithContentsOfURLSoundBankURL(contentsOfURL: NSURL, soundBankURL?: NSURL): AVMIDIPlayer;
    static createWithDataSoundBankURL(data: NSData, soundBankURL?: NSURL): AVMIDIPlayer;
    play(_?: () => void): void;
    prepareToPlay(): void;
    stop(): void;
  }

  // export function AVMakeRectWithAspectRatioInsideRect(aspectRatio: CGSize, boundingRect: CGRect): CGRect;

  // interface
  class AVMediaDataStorage extends NSObject {
    URL(): NSURL;
    static createWithUrlOptions(URL: NSURL, options?: Map<string, any>): AVMediaDataStorage;
  }

  // interface
  class AVMediaSelection extends NSObject /* implements NSCopying, NSMutableCopying */ {
    asset: AVAsset;
    mediaSelectionCriteriaCanBeAppliedAutomaticallyToMediaSelectionGroup(to: AVMediaSelectionGroup): boolean;
    selectedMediaOptionInMediaSelectionGroup(in_: AVMediaSelectionGroup): AVMediaSelectionOption;
  }

  // interface
  class AVMediaSelectionGroup extends NSObject /* implements NSCopying */ {
    static mediaSelectionOptionsFromArrayFilteredAndSortedAccordingToPreferredLanguages(from: AVMediaSelectionOption[], filteredAndSortedAccordingToPreferredLanguages: string[]): AVMediaSelectionOption[];
    static mediaSelectionOptionsFromArrayWithLocale(from: AVMediaSelectionOption[], with_: NSLocale): AVMediaSelectionOption[];
    static mediaSelectionOptionsFromArrayWithMediaCharacteristics(from: AVMediaSelectionOption[], withMediaCharacteristics: string[]): AVMediaSelectionOption[];
    static mediaSelectionOptionsFromArrayWithoutMediaCharacteristics(from: AVMediaSelectionOption[], withoutMediaCharacteristics: string[]): AVMediaSelectionOption[];
    static playableMediaSelectionOptionsFromArray(from: AVMediaSelectionOption[]): AVMediaSelectionOption[];
    allowsEmptySelection: boolean;
    defaultOption: AVMediaSelectionOption;
    options: AVMediaSelectionOption[];
    mediaSelectionOptionWithPropertyList(withPropertyList: any): AVMediaSelectionOption;
  }

  // interface
  class AVMediaSelectionOption extends NSObject /* implements NSCopying */ {
    availableMetadataFormats: string[];
    commonMetadata: AVMetadataItem[];
    displayName: string;
    extendedLanguageTag: string;
    locale: NSLocale;
    mediaSubTypes: number[];
    mediaType: string;
    isPlayable: boolean;
    associatedMediaSelectionOptionInMediaSelectionGroup(in_: AVMediaSelectionGroup): AVMediaSelectionOption;
    displayNameWithLocale(with_: NSLocale): string;
    hasMediaCharacteristic(_: string): boolean;
    metadataForFormat(forFormat: string): AVMetadataItem[];
    propertyList(): any;
  }

  // interface
  class AVMetadataBodyObject extends AVMetadataObject /* implements NSCopying */ {
    bodyID: number;
  }

  // interface
  class AVMetadataCatBodyObject extends AVMetadataBodyObject /* implements NSCopying */ {
  }

  // interface
  class AVMetadataDogBodyObject extends AVMetadataBodyObject /* implements NSCopying */ {
  }

  // interface
  class AVMetadataFaceObject extends AVMetadataObject /* implements NSCopying */ {
    faceID: number;
    hasRollAngle: boolean;
    hasYawAngle: boolean;
    rollAngle: number;
    yawAngle: number;
  }

  // interface
  class AVMetadataGroup extends NSObject {
    classifyingLabel: string;
    items: AVMetadataItem[];
    uniqueID: string;
  }

  // interface
  class AVMetadataHumanBodyObject extends AVMetadataBodyObject /* implements NSCopying */ {
  }

  // interface
  class AVMetadataItem extends NSObject /* implements AVAsynchronousKeyValueLoading, NSCopying, NSMutableCopying */ {
    static identifierForKeyKeySpace(forKey: any, keySpace: string): string;
    static keyForIdentifier(forIdentifier: string): any;
    static keySpaceForIdentifier(forIdentifier: string): string;
    static metadataItemsFromArrayFilteredAndSortedAccordingToPreferredLanguages(from: AVMetadataItem[], filteredAndSortedAccordingToPreferredLanguages: string[]): AVMetadataItem[];
    static metadataItemsFromArrayFilteredByIdentifier(from: AVMetadataItem[], filteredByIdentifier: string): AVMetadataItem[];
    static metadataItemsFromArrayFilteredByMetadataItemFilter(from: AVMetadataItem[], filteredBy: AVMetadataItemFilter): AVMetadataItem[];
    static metadataItemsFromArrayWithKeyKeySpace(from: AVMetadataItem[], withKey?: any, keySpace?: string): AVMetadataItem[];
    static metadataItemsFromArrayWithLocale(from: AVMetadataItem[], with_: NSLocale): AVMetadataItem[];
    commonKey: string;
    dataType: string;
    dataValue: NSData;
    dateValue: Date;
    duration: CMTime;
    extendedLanguageTag: string;
    extraAttributes: Map<string, any>;
    identifier: string;
    key: any;
    keySpace: string;
    locale: NSLocale;
    numberValue: number;
    startDate: Date;
    stringValue: string;
    time: CMTime;
    value: any;
  }

  // interface
  class AVMetadataItemFilter extends NSObject {
    static metadataItemFilterForSharing(): AVMetadataItemFilter;
  }

  // interface
  class AVMetadataItemValueRequest extends NSObject {
    metadataItem: AVMetadataItem;
    respondWithError(error: NSError): void;
    respondWithValue(value: any): void;
  }

  // interface
  class AVMetadataMachineReadableCodeObject extends AVMetadataObject {
    corners: Map<any, any>[];
    descriptor: CIBarcodeDescriptor;
    stringValue: string;
  }

  // interface
  class AVMetadataObject extends NSObject {
    bounds: CGRect;
    duration: CMTime;
    time: CMTime;
    type: string;
  }

  // interface
  class AVMetadataSalientObject extends AVMetadataObject /* implements NSCopying */ {
    objectID: number;
  }

  // interface
  class AVMovie extends AVAsset /* implements NSCopying, NSMutableCopying */ {
    static movieTypes(): string[];
    URL: NSURL;
    canContainMovieFragments: boolean;
    containsMovieFragments: boolean;
    data: NSData;
    defaultMediaDataStorage: AVMediaDataStorage;
    static createWithDataOptions(data: NSData, options?: Map<string, any>): AVMovie;
    static createWithUrlOptions(URL: NSURL, options?: Map<string, any>): AVMovie;
    isCompatibleWithFileType(compatibleWithFileType: string): boolean;
    movieHeaderWithFileTypeError(fileType: string): NSData;
    writeMovieHeaderToURLFileTypeOptionsError(fileType: NSURL, options: string, error: AVMovieWritingOptions): boolean;
  }

  // interface
  class AVMovieTrack extends AVAssetTrack {
    alternateGroupID: number;
    mediaDataStorage: AVMediaDataStorage;
    mediaDecodeTimeRange: CMTimeRange;
    mediaPresentationTimeRange: CMTimeRange;
  }

  // interface
  class AVMusicTrack extends NSObject {
    destinationAudioUnit: AVAudioUnit;
    setDestinationAudioUnit(_: AVAudioUnit)
    destinationMIDIEndpoint: number;
    setDestinationMIDIEndpoint(_: number)
    lengthInBeats: number;
    setLengthInBeats(_: number)
    lengthInSeconds: number;
    setLengthInSeconds(_: number)
    loopRange: AVAudioSequencer;
    setLoopRange(_: AVAudioSequencer)
    isLoopingEnabled: boolean;
    setLoopingEnabled(_: boolean)
    isMuted: boolean;
    setMuted(_: boolean)
    numberOfLoops: number;
    setNumberOfLoops(_: number)
    offsetTime: number;
    setOffsetTime(_: number)
    isSoloed: boolean;
    setSoloed(_: boolean)
    timeResolution: number;
  }

  // interface
  class AVMutableAudioMix extends AVAudioMix {
    static audioMix(): AVMutableAudioMix;
  }

  // interface
  class AVMutableAudioMixInputParameters extends AVAudioMixInputParameters {
    static audioMixInputParameters(): AVMutableAudioMixInputParameters;
    static audioMixInputParametersWithTrack(track?: AVAssetTrack): AVMutableAudioMixInputParameters;
    setVolumeAtTime(_: number, at: CMTime): void;
    setVolumeRampFromStartVolumeToEndVolumeTimeRange(fromStartVolume: number, toEndVolume: number, timeRange: CMTimeRange): void;
  }

  // interface
  class AVMutableComposition extends AVComposition {
    static composition(): AVMutableComposition;
    static compositionWithURLAssetInitializationOptions(urlAssetInitializationOptions?: Map<string, any>): AVMutableComposition;
    addMutableTrackWithMediaTypePreferredTrackID(withMediaType: string, preferredTrackID: number): AVMutableCompositionTrack;
    insertEmptyTimeRange(_: CMTimeRange): void;
    insertTimeRangeOfAssetAtTimeError(_: CMTimeRange, of: AVAsset, at: CMTime): boolean;
    mutableTrackCompatibleWithTrack(compatibleWith: AVAssetTrack): AVMutableCompositionTrack;
    removeTimeRange(_: CMTimeRange): void;
    removeTrack(_: AVCompositionTrack): void;
    scaleTimeRangeToDuration(_: CMTimeRange, toDuration: CMTime): void;
  }

  // interface
  class AVMutableCompositionTrack extends AVCompositionTrack {
    addTrackAssociationToTrackType(to: AVCompositionTrack, type: string): void;
    insertEmptyTimeRange(_: CMTimeRange): void;
    insertTimeRangeOfTrackAtTimeError(ofTrack: CMTimeRange, atTime: AVAssetTrack, error: CMTime): boolean;
    insertTimeRangesOfTracksAtTimeError(ofTracks: NSValue[], atTime: AVAssetTrack[], error: CMTime): boolean;
    removeTimeRange(_: CMTimeRange): void;
    removeTrackAssociationToTrackType(to: AVCompositionTrack, type: string): void;
    replaceFormatDescriptionWithFormatDescription(_: any, with_?: any): void;
    scaleTimeRangeToDuration(_: CMTimeRange, toDuration: CMTime): void;
    validateTrackSegmentsError(error: AVCompositionTrackSegment[]): boolean;
  }

  // interface
  class AVMutableDateRangeMetadataGroup extends AVDateRangeMetadataGroup {
  }

  // interface
  class AVMutableMediaSelection extends AVMediaSelection {
    selectMediaOptionInMediaSelectionGroup(_?: AVMediaSelectionOption, in_?: AVMediaSelectionGroup): void;
  }

  // interface
  class AVMutableMetadataItem extends AVMetadataItem {
    static metadataItem(): AVMutableMetadataItem;
  }

  // interface
  class AVMutableMovie extends AVMovie {
    static movieWithDataOptionsError(data: NSData, options?: Map<string, any>): AVMutableMovie;
    static movieWithSettingsFromMovieOptionsError(options?: AVMovie, error?: Map<string, any>): AVMutableMovie;
    static movieWithURLOptionsError(url: NSURL, options?: Map<string, any>): AVMutableMovie;
    interleavingPeriod: CMTime;
    setInterleavingPeriod(_: CMTime)
    isModified: boolean;
    setModified(_: boolean)
    timescale: number;
    setTimescale(_: number)
    addMutableTrackWithMediaTypeCopySettingsFromTrackOptions(withMediaType: string, copySettingsFrom?: AVAssetTrack, options?: Map<string, any>): AVMutableMovieTrack;
    addMutableTracksCopyingSettingsFromTracksOptions(from: AVAssetTrack[], options?: Map<string, any>): AVMutableMovieTrack[];
    static createWithSettingsFromMovieOptions(settingsFromMovie?: AVMovie, options?: Map<string, any>): AVMutableMovie;
    insertEmptyTimeRange(_: CMTimeRange): void;
    insertTimeRangeOfAssetAtTimeCopySampleDataError(_: CMTimeRange, of: AVAsset, at: CMTime, copySampleData: boolean): boolean;
    mutableTrackCompatibleWithTrack(compatibleWith: AVAssetTrack): AVMutableMovieTrack;
    removeTimeRange(_: CMTimeRange): void;
    removeTrack(_: AVMovieTrack): void;
    scaleTimeRangeToDuration(_: CMTimeRange, toDuration: CMTime): void;
  }

  // interface
  class AVMutableMovieTrack extends AVMovieTrack {
    cleanApertureDimensions: CGSize;
    setCleanApertureDimensions(_: CGSize)
    encodedPixelsDimensions: CGSize;
    setEncodedPixelsDimensions(_: CGSize)
    hasProtectedContent: boolean;
    layer: number;
    setLayer(_: number)
    isModified: boolean;
    setModified(_: boolean)
    preferredMediaChunkAlignment: number;
    setPreferredMediaChunkAlignment(_: number)
    preferredMediaChunkDuration: CMTime;
    setPreferredMediaChunkDuration(_: CMTime)
    preferredMediaChunkSize: number;
    setPreferredMediaChunkSize(_: number)
    productionApertureDimensions: CGSize;
    setProductionApertureDimensions(_: CGSize)
    sampleReferenceBaseURL: NSURL;
    setSampleReferenceBaseURL(_: NSURL)
    timescale: number;
    setTimescale(_: number)
    addTrackAssociationToTrackType(to: AVMovieTrack, type: string): void;
    appendSampleBufferDecodeTimePresentationTimeError(_: any, decodeTime?: CMTime, presentationTime?: CMTime): boolean;
    insertEmptyTimeRange(_: CMTimeRange): void;
    insertMediaTimeRangeIntoTimeRange(_: CMTimeRange, into: CMTimeRange): boolean;
    insertTimeRangeOfTrackAtTimeCopySampleDataError(ofTrack: CMTimeRange, atTime: AVAssetTrack, copySampleData: CMTime, error: boolean): boolean;
    removeTimeRange(_: CMTimeRange): void;
    removeTrackAssociationToTrackType(to: AVMovieTrack, type: string): void;
    replaceFormatDescriptionWithFormatDescription(_: any, with_: any): void;
    scaleTimeRangeToDuration(_: CMTimeRange, toDuration: CMTime): void;
  }

  // interface
  class AVMutableTimedMetadataGroup extends AVTimedMetadataGroup {
  }

  // interface
  class AVMutableVideoComposition extends AVVideoComposition {
    static videoComposition(): AVMutableVideoComposition;
    static videoCompositionWithPropertiesOfAssetPrototypeInstruction(propertiesOf: AVAsset, prototypeInstruction: AVVideoCompositionInstruction): AVMutableVideoComposition;
  }

  // interface
  class AVMutableVideoCompositionInstruction extends AVVideoCompositionInstruction {
    static videoCompositionInstruction(): AVMutableVideoCompositionInstruction;
    enablePostProcessing: boolean;
    setEnablePostProcessing(_: boolean)
    timeRange: CMTimeRange;
    setTimeRange(_: CMTimeRange)
  }

  // interface
  class AVMutableVideoCompositionLayerInstruction extends AVVideoCompositionLayerInstruction {
    static videoCompositionLayerInstruction(): AVMutableVideoCompositionLayerInstruction;
    static videoCompositionLayerInstructionWithAssetTrack(assetTrack: AVAssetTrack): AVMutableVideoCompositionLayerInstruction;
    setCropRectangleAtTime(_: CGRect, at: CMTime): void;
    setCropRectangleRampFromStartCropRectangleToEndCropRectangleTimeRange(fromStartCropRectangle: CGRect, toEndCropRectangle: CGRect, timeRange: CMTimeRange): void;
    setOpacityAtTime(_: number, at: CMTime): void;
    setOpacityRampFromStartOpacityToEndOpacityTimeRange(fromStartOpacity: number, toEndOpacity: number, timeRange: CMTimeRange): void;
    setTransformAtTime(_: CGAffineTransform, at: CMTime): void;
    setTransformRampFromStartTransformToEndTransformTimeRange(fromStart: CGAffineTransform, toEnd: CGAffineTransform, timeRange: CMTimeRange): void;
  }

  // interface
  class AVOutputSettingsAssistant extends NSObject {
    static availableOutputSettingsPresets(): string[];
    audioSettings: Map<string, any>;
    outputFileType: string;
    sourceAudioFormat: any;
    setSourceAudioFormat(_: any)
    sourceVideoAverageFrameDuration: CMTime;
    setSourceVideoAverageFrameDuration(_: CMTime)
    sourceVideoFormat: any;
    setSourceVideoFormat(_: any)
    sourceVideoMinFrameDuration: CMTime;
    setSourceVideoMinFrameDuration(_: CMTime)
    videoSettings: Map<string, any>;
  }

  // interface
  class AVPersistableContentKeyRequest extends AVContentKeyRequest {
    persistableContentKeyFromKeyVendorResponseOptionsError(options: NSData, error?: Map<string, any>): NSData;
  }

  // interface
  class AVPlayer extends NSObject {
    actionAtItemEnd: AVPlayer.ActionAtItemEnd;
    setActionAtItemEnd(_: AVPlayer.ActionAtItemEnd)
    allowsExternalPlayback: boolean;
    setAllowsExternalPlayback(_: boolean)
    appliesMediaSelectionCriteriaAutomatically: boolean;
    setAppliesMediaSelectionCriteriaAutomatically(_: boolean)
    audioOutputDeviceUniqueID: string;
    setAudioOutputDeviceUniqueID(_: string)
    automaticallyWaitsToMinimizeStalling: boolean;
    setAutomaticallyWaitsToMinimizeStalling(_: boolean)
    currentItem: AVPlayerItem;
    error: NSError;
    isExternalPlaybackActive: boolean;
    masterClock: any;
    setMasterClock(_: any)
    isMuted: boolean;
    setMuted(_: boolean)
    outputObscuredDueToInsufficientExternalProtection: boolean;
    preferredVideoDecoderGPURegistryID: number;
    setPreferredVideoDecoderGPURegistryID(_: number)
    preventsDisplaySleepDuringVideoPlayback: boolean;
    setPreventsDisplaySleepDuringVideoPlayback(_: boolean)
    rate: number;
    setRate(_: number)
    reasonForWaitingToPlay: string;
    status: AVPlayer.Status;
    timeControlStatus: AVPlayer.TimeControlStatus;
    volume: number;
    setVolume(_: number)
    static eligibleForHDRPlayback: boolean;
    addBoundaryTimeObserverWithForTimesQueueUsing(forTimes: NSValue[], queue?: NSObject, using?: () => void): any;
    addPeriodicTimeObserverWithForIntervalQueueUsing(forInterval: CMTime, queue?: NSObject, using?: (p1: CMTime) => void): any;
    cancelPendingPrerolls(): void;
    currentTime(): CMTime;
    static createWithPlayerItem(playerItem?: AVPlayerItem): AVPlayer;
    static createWithUrl(URL: NSURL): AVPlayer;
    mediaSelectionCriteriaForMediaCharacteristic(forMediaCharacteristic: string): AVPlayerMediaSelectionCriteria;
    pause(): void;
    play(): void;
    playImmediatelyAtRate(atRate: number): void;
    prerollWithAtRateCompletionHandler(atRate: number, completionHandler?: (p1: boolean) => void): void;
    removeTimeObserver(_: any): void;
    replaceCurrentItemWithPlayerItem(with_?: AVPlayerItem): void;
    seekToDate(to: Date): void;
    seekWithToCompletionHandler(to: Date, completionHandler: (p1: boolean) => void): void;
    seekToTime(to: CMTime): void;
    seekWithToCompletionHandler(to: CMTime, completionHandler: (p1: boolean) => void): void;
    seekToTimeToleranceBeforeToleranceAfter(to: CMTime, toleranceBefore: CMTime, toleranceAfter: CMTime): void;
    seekWithToToleranceBeforeToleranceAfterCompletionHandler(to: CMTime, toleranceBefore: CMTime, toleranceAfter: CMTime, completionHandler: (p1: boolean) => void): void;
    setMediaSelectionCriteriaForMediaCharacteristic(_?: AVPlayerMediaSelectionCriteria, forMediaCharacteristic?: string): void;
    setRateTimeAtHostTime(_: number, time: CMTime, atHostTime: CMTime): void;
  }

  // interface
  class AVPlayerItem extends NSObject /* implements NSCopying */ {
    isApplicationAuthorizedForPlayback: boolean;
    asset: AVAsset;
    audioMix: AVAudioMix;
    setAudioMix(_: AVAudioMix)
    isAudioSpatializationAllowed: boolean;
    setAudioSpatializationAllowed(_: boolean)
    audioTimePitchAlgorithm: string;
    setAudioTimePitchAlgorithm(_: string)
    isAuthorizationRequiredForPlayback: boolean;
    automaticallyLoadedAssetKeys: string[];
    automaticallyPreservesTimeOffsetFromLive: boolean;
    setAutomaticallyPreservesTimeOffsetFromLive(_: boolean)
    canPlayFastForward: boolean;
    canPlayFastReverse: boolean;
    canPlayReverse: boolean;
    canPlaySlowForward: boolean;
    canPlaySlowReverse: boolean;
    canStepBackward: boolean;
    canStepForward: boolean;
    canUseNetworkResourcesForLiveStreamingWhilePaused: boolean;
    setCanUseNetworkResourcesForLiveStreamingWhilePaused(_: boolean)
    configuredTimeOffsetFromLive: CMTime;
    setConfiguredTimeOffsetFromLive(_: CMTime)
    contentAuthorizationRequestStatus: AVContentAuthorizationStatus;
    isContentAuthorizedForPlayback: boolean;
    currentMediaSelection: AVMediaSelection;
    customVideoCompositor: AVVideoCompositing;
    duration: CMTime;
    error: NSError;
    forwardPlaybackEndTime: CMTime;
    setForwardPlaybackEndTime(_: CMTime)
    loadedTimeRanges: NSValue[];
    mediaDataCollectors: AVPlayerItemMediaDataCollector[];
    outputs: AVPlayerItemOutput[];
    isPlaybackBufferEmpty: boolean;
    isPlaybackBufferFull: boolean;
    isPlaybackLikelyToKeepUp: boolean;
    preferredForwardBufferDuration: number;
    setPreferredForwardBufferDuration(_: number)
    preferredMaximumResolution: CGSize;
    setPreferredMaximumResolution(_: CGSize)
    preferredPeakBitRate: number;
    setPreferredPeakBitRate(_: number)
    presentationSize: CGSize;
    recommendedTimeOffsetFromLive: CMTime;
    reversePlaybackEndTime: CMTime;
    setReversePlaybackEndTime(_: CMTime)
    seekableTimeRanges: NSValue[];
    seekingWaitsForVideoCompositionRendering: boolean;
    setSeekingWaitsForVideoCompositionRendering(_: boolean)
    status: AVPlayerItem.Status;
    textStyleRules: AVTextStyleRule[];
    setTextStyleRules(_: AVTextStyleRule[])
    timebase: any;
    tracks: AVPlayerItemTrack[];
    videoApertureMode: string;
    setVideoApertureMode(_: string)
    videoComposition: AVVideoComposition;
    setVideoComposition(_: AVVideoComposition)
    accessLog(): AVPlayerItemAccessLog;
    addMediaDataCollector(_: AVPlayerItemMediaDataCollector): void;
    addOutput(_: AVPlayerItemOutput): void;
    cancelContentAuthorizationRequest(): void;
    cancelPendingSeeks(): void;
    currentDate(): Date;
    currentTime(): CMTime;
    errorLog(): AVPlayerItemErrorLog;
    static createWithAsset(asset: AVAsset): AVPlayerItem;
    static createWithAssetAutomaticallyLoadedAssetKeys(asset: AVAsset, automaticallyLoadedAssetKeys?: string[]): AVPlayerItem;
    static createWithUrl(URL: NSURL): AVPlayerItem;
    removeMediaDataCollector(_: AVPlayerItemMediaDataCollector): void;
    removeOutput(_: AVPlayerItemOutput): void;
    requestContentAuthorizationAsynchronouslyWithWithTimeoutIntervalCompletionHandler(withTimeoutInterval: number, completionHandler: () => void): void;
    seekWithToCompletionHandler(to: Date, completionHandler?: (p1: boolean) => void): boolean;
    seekWithToCompletionHandler(to: CMTime, completionHandler?: (p1: boolean) => void): void;
    seekWithToToleranceBeforeToleranceAfterCompletionHandler(to: CMTime, toleranceBefore: CMTime, toleranceAfter: CMTime, completionHandler?: (p1: boolean) => void): void;
    selectMediaOptionInMediaSelectionGroup(_?: AVMediaSelectionOption, in_?: AVMediaSelectionGroup): void;
    selectMediaOptionAutomaticallyInMediaSelectionGroup(in_: AVMediaSelectionGroup): void;
    stepByCount(byCount: number): void;
  }

  // interface
  class AVPlayerItemAccessLog extends NSObject /* implements NSCopying */ {
    events: AVPlayerItemAccessLogEvent[];
    extendedLogDataStringEncoding: number;
    extendedLogData(): NSData;
  }

  // interface
  class AVPlayerItemAccessLogEvent extends NSObject /* implements NSCopying */ {
    URI: string;
    averageAudioBitrate: number;
    averageVideoBitrate: number;
    downloadOverdue: number;
    durationWatched: number;
    indicatedAverageBitrate: number;
    indicatedBitrate: number;
    mediaRequestsWWAN: number;
    numberOfBytesTransferred: number;
    numberOfDroppedVideoFrames: number;
    numberOfMediaRequests: number;
    numberOfServerAddressChanges: number;
    numberOfStalls: number;
    observedBitrate: number;
    observedBitrateStandardDeviation: number;
    observedMaxBitrate: number;
    observedMinBitrate: number;
    playbackSessionID: string;
    playbackStartDate: Date;
    playbackStartOffset: number;
    playbackType: string;
    segmentsDownloadedDuration: number;
    serverAddress: string;
    startupTime: number;
    switchBitrate: number;
    transferDuration: number;
  }

  // interface
  class AVPlayerItemErrorLog extends NSObject /* implements NSCopying */ {
    events: AVPlayerItemErrorLogEvent[];
    extendedLogDataStringEncoding: number;
    extendedLogData(): NSData;
  }

  // interface
  class AVPlayerItemErrorLogEvent extends NSObject /* implements NSCopying */ {
    URI: string;
    date: Date;
    errorComment: string;
    errorDomain: string;
    errorStatusCode: number;
    playbackSessionID: string;
    serverAddress: string;
  }

  // interface
  class AVPlayerItemLegibleOutput extends AVPlayerItemOutput {
    advanceIntervalForDelegateInvocation: number;
    setAdvanceIntervalForDelegateInvocation(_: number)
    delegate: AVPlayerItemLegibleOutputPushDelegate;
    delegateQueue: NSObject;
    textStylingResolution: string;
    setTextStylingResolution(_: string)
    static createWithMediaSubtypesForNativeRepresentation(mediaSubtypesForNativeRepresentation: number[]): AVPlayerItemLegibleOutput;
    setDelegateQueue(_?: AVPlayerItemLegibleOutputPushDelegate, queue?: NSObject): void;
  }

  interface AVPlayerItemLegibleOutputPushDelegate extends AVPlayerItemOutputPushDelegate {
    // instance method
    legibleOutputDidOutputAttributedStringsNativeSampleBuffersForItemTime?(_: AVPlayerItemLegibleOutput, didOutputAttributedStrings: NSAttributedString[], nativeSampleBuffers: any[], forItemTime: CMTime): void;
  }

  // interface
  class AVPlayerItemMediaDataCollector extends NSObject {
  }

  // interface
  class AVPlayerItemMetadataCollector extends AVPlayerItemMediaDataCollector {
    delegate: AVPlayerItemMetadataCollectorPushDelegate;
    delegateQueue: NSObject;
    static createWithIdentifiersClassifyingLabels(identifiers?: string[], classifyingLabels?: string[]): AVPlayerItemMetadataCollector;
    setDelegateQueue(_?: AVPlayerItemMetadataCollectorPushDelegate, queue?: NSObject): void;
  }

  interface AVPlayerItemMetadataCollectorPushDelegate extends NSObject {
    // instance method
    metadataCollectorDidCollectDateRangeMetadataGroupsIndexesOfNewGroupsIndexesOfModifiedGroups(_: AVPlayerItemMetadataCollector, didCollect: AVDateRangeMetadataGroup[], indexesOfNewGroups: NSIndexSet, indexesOfModifiedGroups: NSIndexSet): void;
  }

  // interface
  class AVPlayerItemMetadataOutput extends AVPlayerItemOutput {
    advanceIntervalForDelegateInvocation: number;
    setAdvanceIntervalForDelegateInvocation(_: number)
    delegate: AVPlayerItemMetadataOutputPushDelegate;
    delegateQueue: NSObject;
    static createWithIdentifiers(identifiers?: string[]): AVPlayerItemMetadataOutput;
    setDelegateQueue(_?: AVPlayerItemMetadataOutputPushDelegate, queue?: NSObject): void;
  }

  interface AVPlayerItemMetadataOutputPushDelegate extends AVPlayerItemOutputPushDelegate {
    // instance method
    metadataOutputDidOutputTimedMetadataGroupsFromPlayerItemTrack?(_: AVPlayerItemMetadataOutput, didOutputTimedMetadataGroups: AVTimedMetadataGroup[], from?: AVPlayerItemTrack): void;
  }

  // interface
  class AVPlayerItemOutput extends NSObject {
    suppressesPlayerRendering: boolean;
    setSuppressesPlayerRendering(_: boolean)
    itemTimeForCVTimeStamp(for_: CVTimeStamp): CMTime;
    itemTimeForHostTime(forHostTime: number): CMTime;
    itemTimeForMachAbsoluteTime(forMachAbsoluteTime: number): CMTime;
  }

  interface AVPlayerItemOutputPullDelegate extends NSObject {
    // instance method
    outputMediaDataWillChange?(_: AVPlayerItemOutput): void;
    // instance method
    outputSequenceWasFlushed?(_: AVPlayerItemOutput): void;
  }

  interface AVPlayerItemOutputPushDelegate extends NSObject {
    // instance method
    outputSequenceWasFlushed?(_: AVPlayerItemOutput): void;
  }

  // interface
  class AVPlayerItemTrack extends NSObject {
    assetTrack: AVAssetTrack;
    currentVideoFrameRate: number;
    isEnabled: boolean;
    setEnabled(_: boolean)
    videoFieldMode: string;
    setVideoFieldMode(_: string)
  }

  // interface
  class AVPlayerItemVideoOutput extends AVPlayerItemOutput {
    delegate: AVPlayerItemOutputPullDelegate;
    delegateQueue: NSObject;
    copyPixelBufferForItemTimeItemTimeForDisplay(forItemTime: CMTime, itemTimeForDisplay?: CMTime): any;
    hasNewPixelBufferForItemTime(forItemTime: CMTime): boolean;
    static createWithOutputSettings(outputSettings?: Map<string, any>): AVPlayerItemVideoOutput;
    static createWithPixelBufferAttributes(pixelBufferAttributes?: Map<string, any>): AVPlayerItemVideoOutput;
    requestNotificationOfMediaDataChangeWithAdvanceInterval(withAdvanceInterval: number): void;
    setDelegateQueue(_?: AVPlayerItemOutputPullDelegate, queue?: NSObject): void;
  }

  // interface
  class AVPlayerLayer extends CALayer {
    pixelBufferAttributes: Map<string, any>;
    setPixelBufferAttributes(_: Map<string, any>)
    player: AVPlayer;
    setPlayer(_: AVPlayer)
    isReadyForDisplay: boolean;
    videoGravity: string;
    setVideoGravity(_: string)
    videoRect: CGRect;
  }

  // interface
  class AVPlayerLooper extends NSObject {
    error: NSError;
    loopCount: number;
    loopingPlayerItems: AVPlayerItem[];
    status: AVPlayerLooper.Status;
    disableLooping(): void;
    static createWithPlayerTemplateItemTimeRange(player: AVQueuePlayer, templateItem: AVPlayerItem, timeRange: CMTimeRange): AVPlayerLooper;
  }

  // interface
  class AVPlayerMediaSelectionCriteria extends NSObject {
    preferredLanguages: string[];
    preferredMediaCharacteristics: string[];
    principalMediaCharacteristics: string[];
    static createWithPreferredLanguagesPreferredMediaCharacteristics(preferredLanguages?: string[], preferredMediaCharacteristics?: string[]): AVPlayerMediaSelectionCriteria;
    static createWithPrincipalMediaCharacteristicsPreferredLanguagesPreferredMediaCharacteristics(principalMediaCharacteristics?: string[], preferredLanguages?: string[], preferredMediaCharacteristics?: string[]): AVPlayerMediaSelectionCriteria;
  }

  // interface
  class AVPortraitEffectsMatte extends NSObject {
    static portraitEffectsMatteFromDictionaryRepresentationError(error: Map<any, any>): AVPortraitEffectsMatte;
    mattingImage: any;
    pixelFormatType: number;
    dictionaryRepresentationForAuxiliaryDataType(forAuxiliaryDataType?: string): Map<any, any>;
    portraitEffectsMatteByApplyingExifOrientation(_: CGImagePropertyOrientation): AVPortraitEffectsMatte;
    portraitEffectsMatteByReplacingPortraitEffectsMatteWithPixelBufferError(error: any): AVPortraitEffectsMatte;
  }

  // interface
  class AVQueuePlayer extends AVPlayer {
    static queuePlayerWithItems(items: AVPlayerItem[]): AVQueuePlayer;
    advanceToNextItem(): void;
    canInsertItemAfterItem(_: AVPlayerItem, after?: AVPlayerItem): boolean;
    static createWithItems(items: AVPlayerItem[]): AVQueuePlayer;
    insertItemAfterItem(_: AVPlayerItem, after?: AVPlayerItem): void;
    items(): AVPlayerItem[];
    removeAllItems(): void;
    removeItem(_: AVPlayerItem): void;
  }

  interface AVQueuedSampleBufferRendering extends NSObject {
    isReadyForMoreMediaData: boolean;
    timebase: any;
    // instance method
    enqueueSampleBuffer(_: any): void;
    // instance method
    flush(): void;
    // instance method
    requestMediaDataWhenReadyWithOnUsing(on: NSObject, using: () => void): void;
    // instance method
    stopRequestingMediaData(): void;
  }

  // interface
  class AVRouteDetector extends NSObject {
    multipleRoutesDetected: boolean;
    isRouteDetectionEnabled: boolean;
    setRouteDetectionEnabled(_: boolean)
  }

  // interface
  class AVSampleBufferAudioRenderer extends NSObject /* implements AVQueuedSampleBufferRendering */ {
    audioOutputDeviceUniqueID: string;
    setAudioOutputDeviceUniqueID(_: string)
    audioTimePitchAlgorithm: string;
    setAudioTimePitchAlgorithm(_: string)
    error: NSError;
    isMuted: boolean;
    setMuted(_: boolean)
    status: AVQueuedSampleBufferRenderingStatus;
    volume: number;
    setVolume(_: number)
    flushWithFromSourceTimeCompletionHandler(fromSourceTime: CMTime, completionHandler: (p1: boolean) => void): void;
  }

  // interface
  class AVSampleBufferDisplayLayer extends CALayer /* implements AVQueuedSampleBufferRendering */ {
    controlTimebase: any;
    setControlTimebase(_: any)
    error: NSError;
    preventsCapture: boolean;
    setPreventsCapture(_: boolean)
    preventsDisplaySleepDuringVideoPlayback: boolean;
    setPreventsDisplaySleepDuringVideoPlayback(_: boolean)
    status: AVQueuedSampleBufferRenderingStatus;
    videoGravity: string;
    setVideoGravity(_: string)
    flushAndRemoveImage(): void;
  }

  // interface
  class AVSampleBufferGenerator extends NSObject {
    static notifyOfDataReadyForCompletionHandler(for_: any, completionHandler: (p1: boolean, p2: NSError) => void): void;
    createSampleBufferForRequest(for_: AVSampleBufferRequest): any;
    static createWithAssetTimebase(asset: AVAsset, timebase?: any): AVSampleBufferGenerator;
  }

  // interface
  class AVSampleBufferRenderSynchronizer extends NSObject {
    rate: number;
    setRate(_: number)
    renderers: AVQueuedSampleBufferRendering[];
    timebase: any;
    addBoundaryTimeObserverWithForTimesQueueUsing(forTimes: NSValue[], queue?: NSObject, using?: () => void): any;
    addPeriodicTimeObserverWithForIntervalQueueUsing(forInterval: CMTime, queue?: NSObject, using?: (p1: CMTime) => void): any;
    addRenderer(_: AVQueuedSampleBufferRendering): void;
    currentTime(): CMTime;
    removeRendererAtCompletionHandler(_: AVQueuedSampleBufferRendering, at: CMTime, completionHandler?: (p1: boolean) => void): void;
    removeTimeObserver(_: any): void;
    setRateTime(_: number, time: CMTime): void;
  }

  // interface
  class AVSampleBufferRequest extends NSObject {
    direction: AVSampleBufferRequest.Direction;
    setDirection(_: AVSampleBufferRequest.Direction)
    limitCursor: AVSampleCursor;
    setLimitCursor(_: AVSampleCursor)
    maxSampleCount: number;
    setMaxSampleCount(_: number)
    mode: AVSampleBufferRequest.Mode;
    setMode(_: AVSampleBufferRequest.Mode)
    overrideTime: CMTime;
    setOverrideTime(_: CMTime)
    preferredMinSampleCount: number;
    setPreferredMinSampleCount(_: number)
    startCursor: AVSampleCursor;
    static createWithStartCursor(startCursor: AVSampleCursor): AVSampleBufferRequest;
  }

  // interface
  class AVSampleCursor extends NSObject /* implements NSCopying */ {
    currentChunkInfo: AVSampleCursorChunkInfo;
    currentChunkStorageRange: AVSampleCursorStorageRange;
    currentChunkStorageURL: NSURL;
    currentSampleAudioDependencyInfo: AVSampleCursorAudioDependencyInfo;
    currentSampleDependencyInfo: AVSampleCursorDependencyInfo;
    currentSampleDuration: CMTime;
    currentSampleIndexInChunk: number;
    currentSampleStorageRange: AVSampleCursorStorageRange;
    currentSampleSyncInfo: AVSampleCursorSyncInfo;
    decodeTimeStamp: CMTime;
    presentationTimeStamp: CMTime;
    samplesRequiredForDecoderRefresh: number;
    comparePositionInDecodeOrderWithPositionOfCursor(withPositionOf: AVSampleCursor): ComparisonResult;
    copyCurrentSampleFormatDescription(): any;
    samplesWithEarlierDecodeTimeStampsMayHaveLaterPresentationTimeStampsThanCursor(laterThan: AVSampleCursor): boolean;
    samplesWithLaterDecodeTimeStampsMayHaveEarlierPresentationTimeStampsThanCursor(earlierThan: AVSampleCursor): boolean;
    stepByDecodeTimeWasPinned(byDecodeTime: CMTime, wasPinned?: boolean): CMTime;
    stepByPresentationTimeWasPinned(byPresentationTime: CMTime, wasPinned?: boolean): CMTime;
    stepInDecodeOrderByCount(byCount: number): number;
    stepInPresentationOrderByCount(byCount: number): number;
  }

  // interface
  class AVSemanticSegmentationMatte extends NSObject {
    static semanticSegmentationMatteFromImageSourceAuxiliaryDataTypeDictionaryRepresentationError(dictionaryRepresentation: string, error: Map<any, any>): AVSemanticSegmentationMatte;
    matteType: string;
    mattingImage: any;
    pixelFormatType: number;
    dictionaryRepresentationForAuxiliaryDataType(forAuxiliaryDataType?: string): Map<any, any>;
    semanticSegmentationMatteByApplyingExifOrientation(_: CGImagePropertyOrientation): AVSemanticSegmentationMatte;
    semanticSegmentationMatteByReplacingSemanticSegmentationMatteWithPixelBufferError(error: any): AVSemanticSegmentationMatte;
  }

  // interface
  class AVSpeechSynthesisVoice extends NSObject /* implements NSSecureCoding */ {
    static currentLanguageCode(): string;
    static speechVoices(): AVSpeechSynthesisVoice[];
    static voiceWithIdentifier(identifier: string): AVSpeechSynthesisVoice;
    static voiceWithLanguage(language?: string): AVSpeechSynthesisVoice;
    audioFileSettings: Map<string, any>;
    gender: AVSpeechSynthesisVoiceGender;
    identifier: string;
    language: string;
    name: string;
    quality: AVSpeechSynthesisVoiceQuality;
  }

  // interface
  class AVSpeechSynthesizer extends NSObject {
    delegate: AVSpeechSynthesizerDelegate;
    setDelegate(_: AVSpeechSynthesizerDelegate)
    isPaused: boolean;
    isSpeaking: boolean;
    continueSpeaking(): boolean;
    pauseSpeakingAtBoundary(at: AVSpeechBoundary): boolean;
    speakUtterance(_: AVSpeechUtterance): void;
    stopSpeakingAtBoundary(at: AVSpeechBoundary): boolean;
    writeToBufferCallback(_: AVSpeechUtterance, toBufferCallback: (p1: AVAudioBuffer) => void): void;
  }

  interface AVSpeechSynthesizerDelegate extends NSObject {
    // instance method
    speechSynthesizerDidStartSpeechUtterance?(_: AVSpeechSynthesizer, didStart: AVSpeechUtterance): void;
    // instance method
    speechSynthesizerDidFinishSpeechUtterance?(_: AVSpeechSynthesizer, didFinish: AVSpeechUtterance): void;
    // instance method
    speechSynthesizerDidPauseSpeechUtterance?(_: AVSpeechSynthesizer, didPause: AVSpeechUtterance): void;
    // instance method
    speechSynthesizerDidContinueSpeechUtterance?(_: AVSpeechSynthesizer, didContinue: AVSpeechUtterance): void;
    // instance method
    speechSynthesizerDidCancelSpeechUtterance?(_: AVSpeechSynthesizer, didCancel: AVSpeechUtterance): void;
    // instance method
    speechSynthesizerWillSpeakRangeOfSpeechStringUtterance?(_: AVSpeechSynthesizer, willSpeakRangeOfSpeechString: NSRange, utterance: AVSpeechUtterance): void;
  }

  // interface
  class AVSpeechUtterance extends NSObject /* implements NSCopying, NSSecureCoding */ {
    static speechUtteranceWithAttributedString(attributedString: NSAttributedString): AVSpeechUtterance;
    static speechUtteranceWithString(string: string): AVSpeechUtterance;
    attributedSpeechString: NSAttributedString;
    pitchMultiplier: number;
    setPitchMultiplier(_: number)
    postUtteranceDelay: number;
    setPostUtteranceDelay(_: number)
    preUtteranceDelay: number;
    setPreUtteranceDelay(_: number)
    rate: number;
    setRate(_: number)
    speechString: string;
    voice: AVSpeechSynthesisVoice;
    setVoice(_: AVSpeechSynthesisVoice)
    volume: number;
    setVolume(_: number)
    static createWithAttributedString(attributedString: NSAttributedString): AVSpeechUtterance;
    static createWithString(string: string): AVSpeechUtterance;
  }

  // interface
  class AVSynchronizedLayer extends CALayer {
    playerItem: AVPlayerItem;
    setPlayerItem(_: AVPlayerItem)
  }

  // interface
  class AVTextStyleRule extends NSObject /* implements NSCopying */ {
    static propertyListForTextStyleRules(for_: AVTextStyleRule[]): any;
    static textStyleRulesFromPropertyList(fromPropertyList: any): AVTextStyleRule[];
    textMarkupAttributes: Map<string, any>;
    textSelector: string;
    static createWithTextMarkupAttributes(textMarkupAttributes: Map<string, any>): AVTextStyleRule;
    static createWithTextMarkupAttributesTextSelector(textMarkupAttributes: Map<string, any>, textSelector?: string): AVTextStyleRule;
  }

  // interface
  class AVTimedMetadataGroup extends AVMetadataGroup /* implements NSCopying, NSMutableCopying */ {
    timeRange: CMTimeRange;
    copyFormatDescription(): any;
    static createWithItemsTimeRange(items: AVMetadataItem[], timeRange: CMTimeRange): AVTimedMetadataGroup;
    static createWithSampleBuffer(sampleBuffer: any): AVTimedMetadataGroup;
  }

  // interface
  class AVURLAsset extends AVAsset /* implements AVContentKeyRecipient */ {
    static URLAssetWithURLOptions(url: NSURL, options?: Map<string, any>): AVURLAsset;
    static audiovisualMIMETypes(): string[];
    static audiovisualTypes(): string[];
    static isPlayableExtendedMIMEType(_: string): boolean;
    URL: NSURL;
    assetCache: AVAssetCache;
    resourceLoader: AVAssetResourceLoader;
    compatibleTrackForCompositionTrack(for_: AVCompositionTrack): AVAssetTrack;
    static createWithUrlOptions(URL: NSURL, options?: Map<string, any>): AVURLAsset;
  }

  interface AVVideoCompositing extends NSObject {
    requiredPixelBufferAttributesForRenderContext: Map<string, any>;
    sourcePixelBufferAttributes: Map<string, any>;
    supportsWideColorSourceFrames?: boolean;
    // instance method
    anticipateRenderingUsingHint?(using: AVVideoCompositionRenderHint): void;
    // instance method
    cancelAllPendingVideoCompositionRequests?(): void;
    // instance method
    prerollForRenderingUsingHint?(using: AVVideoCompositionRenderHint): void;
    // instance method
    renderContextChanged(_: AVVideoCompositionRenderContext): void;
    // instance method
    startVideoCompositionRequest(_: AVAsynchronousVideoCompositionRequest): void;
  }

  // interface
  class AVVideoComposition extends NSObject /* implements NSCopying, NSMutableCopying */ {
    animationTool: AVVideoCompositionCoreAnimationTool;
    colorPrimaries: string;
    colorTransferFunction: string;
    colorYCbCrMatrix: string;
    customVideoCompositorClass: typeof NSObject;
    frameDuration: CMTime;
    instructions: AVVideoCompositionInstruction[];
    renderScale: number;
    renderSize: CGSize;
    sourceTrackIDForFrameTiming: number;
    isValidForAssetTimeRangeValidationDelegate(for_?: AVAsset, timeRange?: CMTimeRange, validationDelegate?: AVVideoCompositionValidationHandling): boolean;
  }

  // interface
  class AVVideoCompositionCoreAnimationTool extends NSObject {
    static videoCompositionCoreAnimationToolWithAdditionalLayerAsTrackID(additionalLayer: CALayer, asTrackID: number): AVVideoCompositionCoreAnimationTool;
    static videoCompositionCoreAnimationToolWithPostProcessingAsVideoLayerInLayer(postProcessingAsVideoLayer: CALayer, in_: CALayer): AVVideoCompositionCoreAnimationTool;
    static videoCompositionCoreAnimationToolWithPostProcessingAsVideoLayersInLayer(postProcessingAsVideoLayers: CALayer[], in_: CALayer): AVVideoCompositionCoreAnimationTool;
  }

  // interface
  class AVVideoCompositionInstruction extends NSObject /* implements AVVideoCompositionInstruction, NSCopying, NSMutableCopying, NSSecureCoding */ {
    backgroundColor: any;
    layerInstructions: AVVideoCompositionLayerInstruction[];
  }

  interface AVVideoCompositionInstruction extends NSObject {
    containsTweening: boolean;
    enablePostProcessing: boolean;
    passthroughTrackID: number;
    requiredSourceTrackIDs: NSValue[];
    timeRange: CMTimeRange;
  }

  // interface
  class AVVideoCompositionLayerInstruction extends NSObject /* implements NSCopying, NSMutableCopying, NSSecureCoding */ {
    trackID: number;
    getCropRectangleRampForTimeStartCropRectangleEndCropRectangleTimeRange(for_: CMTime, startCropRectangle?: NSRect, endCropRectangle?: NSRect, timeRange?: CMTimeRange): boolean;
    getOpacityRampForTimeStartOpacityEndOpacityTimeRange(for_: CMTime, startOpacity?: number, endOpacity?: number, timeRange?: CMTimeRange): boolean;
    getTransformRampForTimeStartTransformEndTransformTimeRange(for_: CMTime, start?: CGAffineTransform, end?: CGAffineTransform, timeRange?: CMTimeRange): boolean;
  }

  // interface
  class AVVideoCompositionRenderContext extends NSObject {
    edgeWidths: AVEdgeWidths;
    highQualityRendering: boolean;
    pixelAspectRatio: AVPixelAspectRatio;
    renderScale: number;
    renderTransform: CGAffineTransform;
    size: CGSize;
    videoComposition: AVVideoComposition;
    newPixelBuffer(): any;
  }

  // interface
  class AVVideoCompositionRenderHint extends NSObject {
    endCompositionTime: CMTime;
    startCompositionTime: CMTime;
  }

  interface AVVideoCompositionValidationHandling extends NSObject {
    // instance method
    videoCompositionShouldContinueValidatingAfterFindingInvalidTimeRangeInInstruction?(_: AVVideoComposition, shouldContinueValidatingAfterFindingInvalidTimeRangeIn: AVVideoCompositionInstruction): boolean;
    // instance method
    videoCompositionShouldContinueValidatingAfterFindingInvalidTrackIDInInstructionLayerInstructionAsset?(_: AVVideoComposition, shouldContinueValidatingAfterFindingInvalidTrackIDIn: AVVideoCompositionInstruction, layerInstruction: AVVideoCompositionLayerInstruction, asset: AVAsset): boolean;
    // instance method
    videoCompositionShouldContinueValidatingAfterFindingEmptyTimeRange?(_: AVVideoComposition, shouldContinueValidatingAfterFindingEmptyTimeRange: CMTimeRange): boolean;
    // instance method
    videoCompositionShouldContinueValidatingAfterFindingInvalidValueForKey?(_: AVVideoComposition, shouldContinueValidatingAfterFindingInvalidValueForKey: string): boolean;
  }

  // interface
  class AVCaptureView extends NSView {
    controlsStyle: AVCaptureViewControlsStyle;
    setControlsStyle(_: AVCaptureViewControlsStyle)
    delegate: AVCaptureViewDelegate;
    setDelegate(_: AVCaptureViewDelegate)
    fileOutput: AVCaptureFileOutput;
    session: AVCaptureSession;
    videoGravity: string;
    setVideoGravity(_: string)
    setSessionShowVideoPreviewShowAudioPreview(_?: AVCaptureSession, showVideoPreview?: boolean, showAudioPreview?: boolean): void;
  }

  interface AVCaptureViewDelegate extends NSObject {
    // instance method
    captureViewStartRecordingToFileOutput(_: AVCaptureView, startRecordingTo: AVCaptureFileOutput): void;
  }

  // interface
  class AVPictureInPictureController extends NSObject {
    static isPictureInPictureSupported(): boolean;
    delegate: AVPictureInPictureControllerDelegate;
    setDelegate(_: AVPictureInPictureControllerDelegate)
    isPictureInPictureActive: boolean;
    isPictureInPicturePossible: boolean;
    isPictureInPictureSuspended: boolean;
    playerLayer: AVPlayerLayer;
    static pictureInPictureButtonStartImage: NSImage;
    static pictureInPictureButtonStopImage: NSImage;
    static createWithPlayerLayer(playerLayer: AVPlayerLayer): AVPictureInPictureController;
    startPictureInPicture(): void;
    stopPictureInPicture(): void;
  }

  interface AVPictureInPictureControllerDelegate extends NSObject {
    // instance method
    pictureInPictureControllerFailedToStartPictureInPictureWithError?(_: AVPictureInPictureController, failedToStartPictureInPictureWithError: NSError): void;
    // instance method
    pictureInPictureControllerWithRestoreUserInterfaceForPictureInPictureStopWithCompletionHandler?(_: AVPictureInPictureController, restoreUserInterfaceForPictureInPictureStopWithCompletionHandler: (p1: boolean) => void): void;
    // instance method
    pictureInPictureControllerDidStartPictureInPicture?(_: AVPictureInPictureController): void;
    // instance method
    pictureInPictureControllerDidStopPictureInPicture?(_: AVPictureInPictureController): void;
    // instance method
    pictureInPictureControllerWillStartPictureInPicture?(_: AVPictureInPictureController): void;
    // instance method
    pictureInPictureControllerWillStopPictureInPicture?(_: AVPictureInPictureController): void;
  }

  // interface
  class AVPlayerView extends NSView {
    actionPopUpButtonMenu: NSMenu;
    setActionPopUpButtonMenu(_: NSMenu)
    allowsPictureInPicturePlayback: boolean;
    setAllowsPictureInPicturePlayback(_: boolean)
    canBeginTrimming: boolean;
    contentOverlayView: NSView;
    controlsStyle: AVPlayerViewControlsStyle;
    setControlsStyle(_: AVPlayerViewControlsStyle)
    pictureInPictureDelegate: AVPlayerViewPictureInPictureDelegate;
    setPictureInPictureDelegate(_: AVPlayerViewPictureInPictureDelegate)
    player: AVPlayer;
    setPlayer(_: AVPlayer)
    isReadyForDisplay: boolean;
    showsFrameSteppingButtons: boolean;
    setShowsFrameSteppingButtons(_: boolean)
    showsFullScreenToggleButton: boolean;
    setShowsFullScreenToggleButton(_: boolean)
    showsSharingServiceButton: boolean;
    setShowsSharingServiceButton(_: boolean)
    showsTimecodes: boolean;
    setShowsTimecodes(_: boolean)
    updatesNowPlayingInfoCenter: boolean;
    setUpdatesNowPlayingInfoCenter(_: boolean)
    videoBounds: CGRect;
    videoGravity: string;
    setVideoGravity(_: string)
    beginTrimmingWithCompletionHandler(completionHandler?: (p1: AVPlayerViewTrimResult) => void): void;
    flashChapterNumberChapterTitle(_: number, chapterTitle?: string): void;
  }

  interface AVPlayerViewPictureInPictureDelegate extends NSObject {
    // instance method
    playerViewFailedToStartPictureInPictureWithError?(_: AVPlayerView, failedToStartPictureInPictureWithError: NSError): void;
    // instance method
    playerViewWithRestoreUserInterfaceForPictureInPictureStopWithCompletionHandler?(_: AVPlayerView, restoreUserInterfaceForPictureInPictureStopWithCompletionHandler: (p1: boolean) => void): void;
    // instance method
    playerViewDidStartPictureInPicture?(inPicture: AVPlayerView): void;
    // instance method
    playerViewDidStopPictureInPicture?(inPicture: AVPlayerView): void;
    // instance method
    playerViewShouldAutomaticallyDismissAtPictureInPictureStart?(inPictureStart: AVPlayerView): boolean;
    // instance method
    playerViewWillStartPictureInPicture?(inPicture: AVPlayerView): void;
    // instance method
    playerViewWillStopPictureInPicture?(inPicture: AVPlayerView): void;
  }

  // interface
  class AVRoutePickerView extends NSView {
    delegate: AVRoutePickerViewDelegate;
    setDelegate(_: AVRoutePickerViewDelegate)
    player: AVPlayer;
    setPlayer(_: AVPlayer)
    isRoutePickerButtonBordered: boolean;
    setRoutePickerButtonBordered(_: boolean)
    routePickerButtonColorForState(for_: AVRoutePickerViewButtonState): NSColor;
    setRoutePickerButtonColorForState(_?: NSColor, for_?: AVRoutePickerViewButtonState): void;
  }

  interface AVRoutePickerViewDelegate extends NSObject {
    // instance method
    routePickerViewDidEndPresentingRoutes?(_: AVRoutePickerView): void;
    // instance method
    routePickerViewWillBeginPresentingRoutes?(_: AVRoutePickerView): void;
  }

  // interface
  class NSATSTypesetter extends NSTypesetter {
    static sharedTypesetter: NSATSTypesetter;
  }

  interface NSAccessibility extends NSObject {
    accessibilityActivationPoint: CGPoint;
    setAccessibilityActivationPoint(_: CGPoint)
    accessibilityAllowedValues: number[];
    setAccessibilityAllowedValues(_: number[])
    isAccessibilityAlternateUIVisible: boolean;
    setAccessibilityAlternateUIVisible(_: boolean)
    accessibilityApplicationFocusedUIElement: any;
    setAccessibilityApplicationFocusedUIElement(_: any)
    accessibilityCancelButton: any;
    setAccessibilityCancelButton(_: any)
    accessibilityChildren: any[];
    setAccessibilityChildren(_: any[])
    accessibilityChildrenInNavigationOrder: NSAccessibilityElement[];
    setAccessibilityChildrenInNavigationOrder(_: NSAccessibilityElement[])
    accessibilityClearButton: any;
    setAccessibilityClearButton(_: any)
    accessibilityCloseButton: any;
    setAccessibilityCloseButton(_: any)
    accessibilityColumnCount: number;
    setAccessibilityColumnCount(_: number)
    accessibilityColumnHeaderUIElements: any[];
    setAccessibilityColumnHeaderUIElements(_: any[])
    accessibilityColumnIndexRange: NSRange;
    setAccessibilityColumnIndexRange(_: NSRange)
    accessibilityColumns: any[];
    setAccessibilityColumns(_: any[])
    accessibilityColumnTitles: any[];
    setAccessibilityColumnTitles(_: any[])
    accessibilityContents: any[];
    setAccessibilityContents(_: any[])
    accessibilityCriticalValue: any;
    setAccessibilityCriticalValue(_: any)
    accessibilityCustomActions: NSAccessibilityCustomAction[];
    setAccessibilityCustomActions(_: NSAccessibilityCustomAction[])
    accessibilityCustomRotors: NSAccessibilityCustomRotor[];
    setAccessibilityCustomRotors(_: NSAccessibilityCustomRotor[])
    accessibilityDecrementButton: any;
    setAccessibilityDecrementButton(_: any)
    accessibilityDefaultButton: any;
    setAccessibilityDefaultButton(_: any)
    isAccessibilityDisclosed: boolean;
    setAccessibilityDisclosed(_: boolean)
    accessibilityDisclosedByRow: any;
    setAccessibilityDisclosedByRow(_: any)
    accessibilityDisclosedRows: any;
    setAccessibilityDisclosedRows(_: any)
    accessibilityDisclosureLevel: number;
    setAccessibilityDisclosureLevel(_: number)
    accessibilityDocument: string;
    setAccessibilityDocument(_: string)
    isAccessibilityEdited: boolean;
    setAccessibilityEdited(_: boolean)
    isAccessibilityElement: boolean;
    setAccessibilityElement(_: boolean)
    isAccessibilityEnabled: boolean;
    setAccessibilityEnabled(_: boolean)
    isAccessibilityExpanded: boolean;
    setAccessibilityExpanded(_: boolean)
    accessibilityExtrasMenuBar: any;
    setAccessibilityExtrasMenuBar(_: any)
    accessibilityFilename: string;
    setAccessibilityFilename(_: string)
    isAccessibilityFocused: boolean;
    setAccessibilityFocused(_: boolean)
    accessibilityFocusedWindow: any;
    setAccessibilityFocusedWindow(_: any)
    accessibilityFrame: CGRect;
    setAccessibilityFrame(_: CGRect)
    isAccessibilityFrontmost: boolean;
    setAccessibilityFrontmost(_: boolean)
    accessibilityFullScreenButton: any;
    setAccessibilityFullScreenButton(_: any)
    accessibilityGrowArea: any;
    setAccessibilityGrowArea(_: any)
    accessibilityHandles: any[];
    setAccessibilityHandles(_: any[])
    accessibilityHeader: any;
    setAccessibilityHeader(_: any)
    accessibilityHelp: string;
    setAccessibilityHelp(_: string)
    isAccessibilityHidden: boolean;
    setAccessibilityHidden(_: boolean)
    accessibilityHorizontalScrollBar: any;
    setAccessibilityHorizontalScrollBar(_: any)
    accessibilityHorizontalUnitDescription: string;
    setAccessibilityHorizontalUnitDescription(_: string)
    accessibilityHorizontalUnits: NSAccessibility.Units;
    setAccessibilityHorizontalUnits(_: NSAccessibility.Units)
    accessibilityIdentifier: string;
    setAccessibilityIdentifier(_: string)
    accessibilityIncrementButton: any;
    setAccessibilityIncrementButton(_: any)
    accessibilityIndex: number;
    setAccessibilityIndex(_: number)
    accessibilityInsertionPointLineNumber: number;
    setAccessibilityInsertionPointLineNumber(_: number)
    accessibilityLabel: string;
    setAccessibilityLabel(_: string)
    accessibilityLabelUIElements: any[];
    setAccessibilityLabelUIElements(_: any[])
    accessibilityLabelValue: number;
    setAccessibilityLabelValue(_: number)
    accessibilityLinkedUIElements: any[];
    setAccessibilityLinkedUIElements(_: any[])
    isAccessibilityMain: boolean;
    setAccessibilityMain(_: boolean)
    accessibilityMainWindow: any;
    setAccessibilityMainWindow(_: any)
    accessibilityMarkerGroupUIElement: any;
    setAccessibilityMarkerGroupUIElement(_: any)
    accessibilityMarkerTypeDescription: string;
    setAccessibilityMarkerTypeDescription(_: string)
    accessibilityMarkerUIElements: any[];
    setAccessibilityMarkerUIElements(_: any[])
    accessibilityMarkerValues: any;
    setAccessibilityMarkerValues(_: any)
    accessibilityMaxValue: any;
    setAccessibilityMaxValue(_: any)
    accessibilityMenuBar: any;
    setAccessibilityMenuBar(_: any)
    accessibilityMinimizeButton: any;
    setAccessibilityMinimizeButton(_: any)
    isAccessibilityMinimized: boolean;
    setAccessibilityMinimized(_: boolean)
    accessibilityMinValue: any;
    setAccessibilityMinValue(_: any)
    isAccessibilityModal: boolean;
    setAccessibilityModal(_: boolean)
    accessibilityNextContents: any[];
    setAccessibilityNextContents(_: any[])
    accessibilityNumberOfCharacters: number;
    setAccessibilityNumberOfCharacters(_: number)
    isAccessibilityOrderedByRow: boolean;
    setAccessibilityOrderedByRow(_: boolean)
    accessibilityOrientation: NSAccessibility.Orientation;
    setAccessibilityOrientation(_: NSAccessibility.Orientation)
    accessibilityOverflowButton: any;
    setAccessibilityOverflowButton(_: any)
    accessibilityParent: any;
    setAccessibilityParent(_: any)
    accessibilityPlaceholderValue: string;
    setAccessibilityPlaceholderValue(_: string)
    accessibilityPreviousContents: any[];
    setAccessibilityPreviousContents(_: any[])
    isAccessibilityProtectedContent: boolean;
    setAccessibilityProtectedContent(_: boolean)
    accessibilityProxy: any;
    setAccessibilityProxy(_: any)
    isAccessibilityRequired: boolean;
    setAccessibilityRequired(_: boolean)
    accessibilityRole: string;
    setAccessibilityRole(_: string)
    accessibilityRoleDescription: string;
    setAccessibilityRoleDescription(_: string)
    accessibilityRowCount: number;
    setAccessibilityRowCount(_: number)
    accessibilityRowHeaderUIElements: any[];
    setAccessibilityRowHeaderUIElements(_: any[])
    accessibilityRowIndexRange: NSRange;
    setAccessibilityRowIndexRange(_: NSRange)
    accessibilityRows: any[];
    setAccessibilityRows(_: any[])
    accessibilityRulerMarkerType: NSAccessibility.RulerMarkerType;
    setAccessibilityRulerMarkerType(_: NSAccessibility.RulerMarkerType)
    accessibilitySearchButton: any;
    setAccessibilitySearchButton(_: any)
    accessibilitySearchMenu: any;
    setAccessibilitySearchMenu(_: any)
    isAccessibilitySelected: boolean;
    setAccessibilitySelected(_: boolean)
    accessibilitySelectedCells: any[];
    setAccessibilitySelectedCells(_: any[])
    accessibilitySelectedChildren: any[];
    setAccessibilitySelectedChildren(_: any[])
    accessibilitySelectedColumns: any[];
    setAccessibilitySelectedColumns(_: any[])
    accessibilitySelectedRows: any[];
    setAccessibilitySelectedRows(_: any[])
    accessibilitySelectedText: string;
    setAccessibilitySelectedText(_: string)
    accessibilitySelectedTextRange: NSRange;
    setAccessibilitySelectedTextRange(_: NSRange)
    accessibilitySelectedTextRanges: NSValue[];
    setAccessibilitySelectedTextRanges(_: NSValue[])
    accessibilityServesAsTitleForUIElements: any[];
    setAccessibilityServesAsTitleForUIElements(_: any[])
    accessibilitySharedCharacterRange: NSRange;
    setAccessibilitySharedCharacterRange(_: NSRange)
    accessibilitySharedFocusElements: any[];
    setAccessibilitySharedFocusElements(_: any[])
    accessibilitySharedTextUIElements: any[];
    setAccessibilitySharedTextUIElements(_: any[])
    accessibilityShownMenu: any;
    setAccessibilityShownMenu(_: any)
    accessibilitySortDirection: NSAccessibility.SortDirection;
    setAccessibilitySortDirection(_: NSAccessibility.SortDirection)
    accessibilitySplitters: any[];
    setAccessibilitySplitters(_: any[])
    accessibilitySubrole: string;
    setAccessibilitySubrole(_: string)
    accessibilityTabs: any[];
    setAccessibilityTabs(_: any[])
    accessibilityTitle: string;
    setAccessibilityTitle(_: string)
    accessibilityTitleUIElement: any;
    setAccessibilityTitleUIElement(_: any)
    accessibilityToolbarButton: any;
    setAccessibilityToolbarButton(_: any)
    accessibilityTopLevelUIElement: any;
    setAccessibilityTopLevelUIElement(_: any)
    accessibilityUnitDescription: string;
    setAccessibilityUnitDescription(_: string)
    accessibilityUnits: NSAccessibility.Units;
    setAccessibilityUnits(_: NSAccessibility.Units)
    accessibilityURL: NSURL;
    setAccessibilityURL(_: NSURL)
    accessibilityValue: any;
    setAccessibilityValue(_: any)
    accessibilityValueDescription: string;
    setAccessibilityValueDescription(_: string)
    accessibilityVerticalScrollBar: any;
    setAccessibilityVerticalScrollBar(_: any)
    accessibilityVerticalUnitDescription: string;
    setAccessibilityVerticalUnitDescription(_: string)
    accessibilityVerticalUnits: NSAccessibility.Units;
    setAccessibilityVerticalUnits(_: NSAccessibility.Units)
    accessibilityVisibleCells: any[];
    setAccessibilityVisibleCells(_: any[])
    accessibilityVisibleCharacterRange: NSRange;
    setAccessibilityVisibleCharacterRange(_: NSRange)
    accessibilityVisibleChildren: any[];
    setAccessibilityVisibleChildren(_: any[])
    accessibilityVisibleColumns: any[];
    setAccessibilityVisibleColumns(_: any[])
    accessibilityVisibleRows: any[];
    setAccessibilityVisibleRows(_: any[])
    accessibilityWarningValue: any;
    setAccessibilityWarningValue(_: any)
    accessibilityWindow: any;
    setAccessibilityWindow(_: any)
    accessibilityWindows: any[];
    setAccessibilityWindows(_: any[])
    accessibilityZoomButton: any;
    setAccessibilityZoomButton(_: any)
    // instance method
    accessibilityAttributedStringForRange(_: NSRange): NSAttributedString;
    // instance method
    accessibilityCellForColumnRow(_: number, row: number): any;
    // instance method
    accessibilityFrameForRange(_: NSRange): CGRect;
    // instance method
    accessibilityLayoutPointForScreenPoint(_: CGPoint): CGPoint;
    // instance method
    accessibilityLayoutSizeForScreenSize(_: CGSize): CGSize;
    // instance method
    accessibilityLineForIndex(_: number): number;
    // instance method
    accessibilityPerformCancel(): boolean;
    // instance method
    accessibilityPerformConfirm(): boolean;
    // instance method
    accessibilityPerformDecrement(): boolean;
    // instance method
    accessibilityPerformDelete(): boolean;
    // instance method
    accessibilityPerformIncrement(): boolean;
    // instance method
    accessibilityPerformPick(): boolean;
    // instance method
    accessibilityPerformPress(): boolean;
    // instance method
    accessibilityPerformRaise(): boolean;
    // instance method
    accessibilityPerformShowAlternateUI(): boolean;
    // instance method
    accessibilityPerformShowDefaultUI(): boolean;
    // instance method
    accessibilityPerformShowMenu(): boolean;
    // instance method
    accessibilityRangeForIndex(_: number): NSRange;
    // instance method
    accessibilityRangeForLine(_: number): NSRange;
    // instance method
    accessibilityRangeForPosition(_: CGPoint): NSRange;
    // instance method
    accessibilityRTFForRange(_: NSRange): NSData;
    // instance method
    accessibilityScreenPointForLayoutPoint(_: CGPoint): CGPoint;
    // instance method
    accessibilityScreenSizeForLayoutSize(_: CGSize): CGSize;
    // instance method
    accessibilityStringForRange(_: NSRange): string;
    // instance method
    accessibilityStyleRangeForIndex(_: number): NSRange;
    // instance method
    isAccessibilitySelectorAllowed(_: string): boolean;
  }

  // export function NSAccessibilityActionDescription(action: string): string;

  interface NSAccessibilityButton extends NSAccessibilityElement {
    // instance method
    accessibilityLabel(): string;
    // instance method
    accessibilityPerformPress(): boolean;
  }

  interface NSAccessibilityCheckBox extends NSAccessibilityButton {
    // instance method
    accessibilityValue(): number;
  }

  interface NSAccessibilityContainsTransientUI extends NSAccessibilityElement {
    // instance method
    accessibilityPerformShowAlternateUI(): boolean;
    // instance method
    accessibilityPerformShowDefaultUI(): boolean;
    // instance method
    isAccessibilityAlternateUIVisible(): boolean;
  }

  // interface
  class NSAccessibilityCustomAction extends NSObject {
    handler: () => boolean;
    setHandler(_: () => boolean)
    name: string;
    setName(_: string)
    selector: string;
    setSelector(_: string)
    target: NSObject;
    setTarget(_: NSObject)
    static createWithNameHandler(name: string, handler?: () => boolean): NSAccessibilityCustomAction;
    static createWithNameTargetSelector(name: string, target: NSObject, selector: string): NSAccessibilityCustomAction;
  }

  // interface
  class NSAccessibilityCustomRotor extends NSObject {
    itemLoadingDelegate: NSAccessibilityElementLoading;
    setItemLoadingDelegate(_: NSAccessibilityElementLoading)
    itemSearchDelegate: NSAccessibilityCustomRotorItemSearchDelegate;
    setItemSearchDelegate(_: NSAccessibilityCustomRotorItemSearchDelegate)
    label: string;
    setLabel(_: string)
    type: NSAccessibilityCustomRotor.RotorType;
    setType(_: NSAccessibilityCustomRotor.RotorType)
    static createWithLabelItemSearchDelegate(label: string, itemSearchDelegate: NSAccessibilityCustomRotorItemSearchDelegate): NSAccessibilityCustomRotor;
    static createWithRotorTypeItemSearchDelegate(rotorType: NSAccessibilityCustomRotor.RotorType, itemSearchDelegate: NSAccessibilityCustomRotorItemSearchDelegate): NSAccessibilityCustomRotor;
  }

  // interface
  class ItemResult extends NSObject {
    customLabel: string;
    setCustomLabel(_: string)
    itemLoadingToken: any;
    targetElement: NSAccessibilityElement;
    targetRange: NSRange;
    setTargetRange(_: NSRange)
    static createWithItemLoadingTokenCustomLabel(itemLoadingToken: any, customLabel: string): ItemResult;
    static createWithTargetElement(targetElement: NSAccessibilityElement): ItemResult;
  }

  interface NSAccessibilityCustomRotorItemSearchDelegate extends NSObject {
    // instance method
    rotorResultForSearchParameters(_: NSAccessibilityCustomRotor, resultFor: SearchParameters): ItemResult;
  }

  // interface
  class SearchParameters extends NSObject {
    currentItem: ItemResult;
    setCurrentItem(_: ItemResult)
    filterString: string;
    setFilterString(_: string)
    searchDirection: NSAccessibilityCustomRotor.SearchDirection;
    setSearchDirection(_: NSAccessibilityCustomRotor.SearchDirection)
  }

  // interface
  class NSAccessibilityElement extends NSObject /* implements NSAccessibility */ {
    static accessibilityElementWithRoleFrameLabelParent(withRole: string, frame: CGRect, label?: string, parent?: any): any;
    accessibilityFrameInParentSpace: CGRect;
    setAccessibilityFrameInParentSpace(_: CGRect)
    accessibilityAddChildElement(_: NSAccessibilityElement): void;
  }

  interface NSAccessibilityElementLoading extends NSObject {
    // instance method
    accessibilityElementWithToken(withToken: any): NSAccessibilityElement;
    // instance method
    accessibilityRangeInTargetElementWithToken?(withToken: any): NSRange;
  }

  interface NSAccessibilityElement extends NSObject {
    // instance method
    accessibilityFrame(): CGRect;
    // instance method
    accessibilityIdentifier?(): string;
    // instance method
    accessibilityParent(): any;
    // instance method
    isAccessibilityFocused?(): boolean;
  }

  // export function NSAccessibilityFrameInView(parentView: NSView, frame: CGRect): CGRect;

  type NSAccessibilityGroup = NSAccessibilityElement

  interface NSAccessibilityImage extends NSAccessibilityElement {
    // instance method
    accessibilityLabel(): string;
  }

  interface NSAccessibilityLayoutArea extends NSAccessibilityGroup {
    accessibilityFocusedUIElement: any;
    // instance method
    accessibilityChildren(): any[];
    // instance method
    accessibilityLabel(): string;
    // instance method
    accessibilitySelectedChildren(): any[];
  }

  interface NSAccessibilityLayoutItem extends NSAccessibilityGroup {
    // instance method
    setAccessibilityFrame?(_: CGRect): void;
  }

  type NSAccessibilityList = NSAccessibilityTable

  interface NSAccessibilityNavigableStaticText extends NSAccessibilityStaticText {
    // instance method
    accessibilityFrameForRange(for_: NSRange): CGRect;
    // instance method
    accessibilityLineForIndex(for_: number): number;
    // instance method
    accessibilityRangeForLine(forLine: number): NSRange;
    // instance method
    accessibilityStringForRange(for_: NSRange): string;
  }

  type NSAccessibilityOutline = NSAccessibilityTable

  // export function NSAccessibilityPointInView(parentView: NSView, point: CGPoint): CGPoint;

  // export function NSAccessibilityPostNotification(element: any, notification: string): void;

  // export function NSAccessibilityPostNotificationWithUserInfo(element: any, notification: string, userInfo: Map<string, any>): void;

  interface NSAccessibilityProgressIndicator extends NSAccessibilityGroup {
    // instance method
    accessibilityValue(): number;
  }

  interface NSAccessibilityRadioButton extends NSAccessibilityButton {
    // instance method
    accessibilityValue(): number;
  }

  // export function NSAccessibilityRoleDescription(role: string, subrole: string): string;

  // export function NSAccessibilityRoleDescriptionForUIElement(element: any): string;

  interface NSAccessibilityRow extends NSAccessibilityGroup {
    // instance method
    accessibilityDisclosureLevel?(): number;
    // instance method
    accessibilityIndex(): number;
  }

  // export function NSAccessibilitySetMayContainProtectedContent(flag: boolean): boolean;

  interface NSAccessibilitySlider extends NSAccessibilityElement {
    // instance method
    accessibilityLabel(): string;
    // instance method
    accessibilityPerformDecrement(): boolean;
    // instance method
    accessibilityPerformIncrement(): boolean;
    // instance method
    accessibilityValue(): any;
  }

  interface NSAccessibilityStaticText extends NSAccessibilityElement {
    // instance method
    accessibilityAttributedStringForRange?(for_: NSRange): NSAttributedString;
    // instance method
    accessibilityValue(): string;
    // instance method
    accessibilityVisibleCharacterRange?(): NSRange;
  }

  interface NSAccessibilityStepper extends NSAccessibilityElement {
    // instance method
    accessibilityLabel(): string;
    // instance method
    accessibilityPerformDecrement(): boolean;
    // instance method
    accessibilityPerformIncrement(): boolean;
    // instance method
    accessibilityValue?(): any;
  }

  interface NSAccessibilitySwitch extends NSAccessibilityButton {
    // instance method
    accessibilityPerformDecrement?(): boolean;
    // instance method
    accessibilityPerformIncrement?(): boolean;
    // instance method
    accessibilityValue(): string;
  }

  interface NSAccessibilityTable extends NSAccessibilityGroup {
    // instance method
    accessibilityColumnHeaderUIElements?(): any[];
    // instance method
    accessibilityColumns?(): any[];
    // instance method
    accessibilityLabel(): string;
    // instance method
    accessibilityRowHeaderUIElements?(): any[];
    // instance method
    accessibilityRows(): NSAccessibilityRow[];
    // instance method
    accessibilitySelectedCells?(): any[];
    // instance method
    accessibilitySelectedColumns?(): any[];
    // instance method
    accessibilitySelectedRows?(): NSAccessibilityRow[];
    // instance method
    accessibilityVisibleCells?(): any[];
    // instance method
    accessibilityVisibleColumns?(): any[];
    // instance method
    accessibilityVisibleRows?(): NSAccessibilityRow[];
    // instance method
    setAccessibilitySelectedRows?(_: NSAccessibilityRow[]): void;
  }

  // export function NSAccessibilityUnignoredAncestor(element: any): any;

  // export function NSAccessibilityUnignoredChildren(originalChildren: any[]): any[];

  // export function NSAccessibilityUnignoredChildrenForOnlyChild(originalChild: any): any[];

  // export function NSAccessibilityUnignoredDescendant(element: any): any;

  // interface
  class NSActionCell extends NSCell {
  }

  // interface
  class NSAlert extends NSObject {
    accessoryView: NSView;
    setAccessoryView(_: NSView)
    alertStyle: NSAlert.Style;
    setAlertStyle(_: NSAlert.Style)
    buttons: NSButton[];
    delegate: NSAlertDelegate;
    setDelegate(_: NSAlertDelegate)
    helpAnchor: string;
    setHelpAnchor(_: string)
    icon: NSImage;
    setIcon(_: NSImage)
    informativeText: string;
    setInformativeText(_: string)
    messageText: string;
    setMessageText(_: string)
    showsHelp: boolean;
    setShowsHelp(_: boolean)
    showsSuppressionButton: boolean;
    setShowsSuppressionButton(_: boolean)
    suppressionButton: NSButton;
    window: NSWindow;
    addButtonWithTitle(withTitle: string): NSButton;
    beginSheetModalForCompletionHandler(for_: NSWindow, completionHandler?: (p1: number) => void): void;
    layout(): void;
    runModal(): number;
  }

  interface NSAlertDelegate extends NSObject {
    // instance method
    alertShowHelp?(_: NSAlert): boolean;
  }

  // interface
  class NSAlignmentFeedbackFilter extends NSObject {
    static inputEventMask: NSEvent.EventTypeMask;
    alignmentFeedbackTokenForHorizontalMovementInViewPreviousXAlignedXDefaultX(in_?: NSView, previousX?: number, alignedX?: number, defaultX?: number): NSAlignmentFeedbackToken;
    alignmentFeedbackTokenForMovementInViewPreviousPointAlignedPointDefaultPoint(in_?: NSView, previousPoint?: CGPoint, alignedPoint?: CGPoint, defaultPoint?: CGPoint): NSAlignmentFeedbackToken;
    alignmentFeedbackTokenForVerticalMovementInViewPreviousYAlignedYDefaultY(in_?: NSView, previousY?: number, alignedY?: number, defaultY?: number): NSAlignmentFeedbackToken;
    performFeedbackWithPerformanceTime(_: NSAlignmentFeedbackToken[], performanceTime: NSHapticFeedbackManager.PerformanceTime): void;
    updateWithEvent(with_: NSEvent): void;
    updateWithPanRecognizer(withPanRecognizer: NSPanGestureRecognizer): void;
  }

  type NSAlignmentFeedbackToken = NSObject

  interface NSAnimatablePropertyContainer {
    animations: Map<string, any>;
    setAnimations(_: Map<string, any>)
    // instance method
    animationForKey(forKey: string): any;
    // instance method
    animator(): NSAnimatablePropertyContainer;
  }

  // interface
  class NSAnimation extends NSObject /* implements NSCoding, NSCopying */ {
    isAnimating: boolean;
    animationBlockingMode: NSAnimation.BlockingMode;
    setAnimationBlockingMode(_: NSAnimation.BlockingMode)
    animationCurve: NSAnimation.Curve;
    setAnimationCurve(_: NSAnimation.Curve)
    currentProgress: number;
    setCurrentProgress(_: number)
    currentValue: number;
    delegate: NSAnimationDelegate;
    setDelegate(_: NSAnimationDelegate)
    duration: number;
    setDuration(_: number)
    frameRate: number;
    setFrameRate(_: number)
    progressMarks: number[];
    setProgressMarks(_: number[])
    runLoopModesForAnimating: string[];
    addProgressMark(_: number): void;
    clearStartAnimation(): void;
    clearStopAnimation(): void;
    static createWithDurationAnimationCurve(duration: number, animationCurve: NSAnimation.Curve): NSAnimation;
    removeProgressMark(_: number): void;
    startAnimation(): void;
    startWhenAnimationReachesProgress(when: NSAnimation, reachesProgress: number): void;
    stopAnimation(): void;
    stopWhenAnimationReachesProgress(when: NSAnimation, reachesProgress: number): void;
  }

  // interface
  class NSAnimationContext extends NSObject {
    static beginGrouping(): void;
    static endGrouping(): void;
    static runAnimationGroup(_: (p1: NSAnimationContext) => void): void;
    static runAnimationGroupWithCompletionHandler(_: (p1: NSAnimationContext) => void, completionHandler?: () => void): void;
    allowsImplicitAnimation: boolean;
    setAllowsImplicitAnimation(_: boolean)
    completionHandler: () => void;
    setCompletionHandler(_: () => void)
    duration: number;
    setDuration(_: number)
    timingFunction: CAMediaTimingFunction;
    setTimingFunction(_: CAMediaTimingFunction)
    static currentContext: NSAnimationContext;
  }

  interface NSAnimationDelegate extends NSObject {
    // instance method
    animationDidReachProgressMark?(_: NSAnimation, didReachProgressMark: number): void;
    // instance method
    animationValueForProgress?(_: NSAnimation, valueForProgress: number): number;
    // instance method
    animationDidEnd?(_: NSAnimation): void;
    // instance method
    animationDidStop?(_: NSAnimation): void;
    // instance method
    animationShouldStart?(_: NSAnimation): boolean;
  }

  // interface
  class NSAppearance extends NSObject /* implements NSSecureCoding */ {
    allowsVibrancy: boolean;
    name: string;
    static currentAppearance: NSAppearance;
    setCurrentAppearance(_: NSAppearance)
    bestMatchFromAppearancesWithNames(from: string[]): string;
    static createWithAppearanceNamedBundle(appearanceNamed: string, bundle?: Bundle): NSAppearance;
  }

  interface NSAppearanceCustomization extends NSObject {
    appearance: NSAppearance;
    setAppearance(_: NSAppearance)
    effectiveAppearance: NSAppearance;
  }

  // interface
  class NSApplication extends NSResponder /* implements NSAccessibility, NSAccessibilityElement, NSMenuItemValidation, NSUserInterfaceValidations, NSAppearanceCustomization */ {
    static detachDrawingThreadToTargetWithObject(_: string, toTarget: any, with_?: any): void;
    isActive: boolean;
    applicationIconImage: NSImage;
    setApplicationIconImage(_: NSImage)
    isAutomaticCustomizeTouchBarMenuItemEnabled: boolean;
    setAutomaticCustomizeTouchBarMenuItemEnabled(_: boolean)
    currentEvent: NSEvent;
    currentSystemPresentationOptions: NSApplication.PresentationOptions;
    delegate: NSApplicationDelegate;
    setDelegate(_: NSApplicationDelegate)
    dockTile: NSDockTile;
    enabledRemoteNotificationTypes: NSApplication.RemoteNotificationType;
    isFullKeyboardAccessEnabled: boolean;
    helpMenu: NSMenu;
    setHelpMenu(_: NSMenu)
    isHidden: boolean;
    keyWindow: NSWindow;
    mainMenu: NSMenu;
    setMainMenu(_: NSMenu)
    mainWindow: NSWindow;
    modalWindow: NSWindow;
    occlusionState: NSApplication.OcclusionState;
    orderedDocuments: NSDocument[];
    orderedWindows: NSWindow[];
    presentationOptions: NSApplication.PresentationOptions;
    setPresentationOptions(_: NSApplication.PresentationOptions)
    isRegisteredForRemoteNotifications: boolean;
    isRunning: boolean;
    servicesMenu: NSMenu;
    setServicesMenu(_: NSMenu)
    servicesProvider: any;
    setServicesProvider(_: any)
    userInterfaceLayoutDirection: NSUserInterfaceLayoutDirection;
    windows: NSWindow[];
    windowsMenu: NSMenu;
    setWindowsMenu(_: NSMenu)
    static sharedApplication: NSApplication;
    abortModal(): void;
    activateContextHelpMode(_?: any): void;
    activateIgnoringOtherApps(ignoringOtherApps: boolean): void;
    activationPolicy(): NSApplication.ActivationPolicy;
    addWindowsItemTitleFilename(_: NSWindow, title: string, filename: boolean): void;
    arrangeInFront(_?: any): void;
    beginModalSessionForWindow(for_: NSWindow): any;
    cancelUserAttentionRequest(_: number): void;
    changeWindowsItemTitleFilename(_: NSWindow, title: string, filename: boolean): void;
    completeStateRestoration(): void;
    deactivate(): void;
    disableRelaunchOnLogin(): void;
    discardEventsMatchingMaskBeforeEvent(matching: NSEvent.EventTypeMask, before?: NSEvent): void;
    enableRelaunchOnLogin(): void;
    endModalSession(_: any): void;
    enumerateWindowsWithOptionsUsing(options: NSApplication.WindowListOptions, using: (p1: NSWindow, p2: boolean) => void): void;
    extendStateRestoration(): void;
    finishLaunching(): void;
    hide(_?: any): void;
    hideOtherApplications(_?: any): void;
    miniaturizeAll(_?: any): void;
    nextEventMatchingMaskUntilDateInModeDequeue(matching: NSEvent.EventTypeMask, until?: Date, inMode?: string, dequeue?: boolean): NSEvent;
    orderFrontCharacterPalette(_?: any): void;
    orderFrontColorPanel(_?: any): void;
    orderFrontStandardAboutPanel(_?: any): void;
    orderFrontStandardAboutPanelWithOptions(options: Map<string, any>): void;
    postEventAtStart(_: NSEvent, atStart: boolean): void;
    preventWindowOrdering(): void;
    registerForRemoteNotificationTypes(matching: NSApplication.RemoteNotificationType): void;
    registerForRemoteNotifications(): void;
    registerServicesMenuSendTypesReturnTypes(_: string[], returnTypes: string[]): void;
    registerUserInterfaceItemSearchHandler(_: NSUserInterfaceItemSearching): void;
    removeWindowsItem(_: NSWindow): void;
    replyToApplicationShouldTerminate(toApplicationShouldTerminate: boolean): void;
    replyToOpenOrPrint(toOpenOrPrint: NSApplication.DelegateReply): void;
    reportException(_: NSException): void;
    requestUserAttention(_: NSApplication.RequestUserAttentionType): number;
    restoreWindowWithWithIdentifierStateCompletionHandler(withIdentifier: string, state: NSCoder, completionHandler?: (p1: NSWindow, p2: NSError) => void): boolean;
    run(): void;
    runModalForWindow(for_: NSWindow): number;
    runModalSession(_: any): number;
    runPageLayout(_?: any): void;
    searchStringInUserInterfaceItemStringSearchRangeFoundRange(_: string, inUserInterfaceItemString: string, range: NSRange, found?: NSRange): boolean;
    sendActionToFrom(_: string, to?: any, from?: any): boolean;
    sendEvent(_: NSEvent): void;
    setActivationPolicy(_: NSApplication.ActivationPolicy): boolean;
    setWindowsNeedUpdate(_: boolean): void;
    showHelp(_?: any): void;
    stop(_?: any): void;
    stopModal(): void;
    stopModalWithCode(withCode: number): void;
    targetForAction(forAction: string): any;
    targetForActionToFrom(forAction: string, to?: any, from?: any): any;
    terminate(_?: any): void;
    toggleTouchBarCustomizationPalette(_?: any): void;
    unhide(_?: any): void;
    unhideAllApplications(_?: any): void;
    unhideWithoutActivation(): void;
    unregisterForRemoteNotifications(): void;
    unregisterUserInterfaceItemSearchHandler(_: NSUserInterfaceItemSearching): void;
    updateWindows(): void;
    updateWindowsItem(_: NSWindow): void;
    windowWithWindowNumber(withWindowNumber: number): NSWindow;
  }

  interface NSApplicationDelegate extends NSObject {
    // instance method
    applicationContinueRestorationHandler?(_: NSApplication, continue_: NSUserActivity, restorationHandler: (p1: NSUserActivityRestoring[]) => void): boolean;
    // instance method
    applicationOpenURLs?(_: NSApplication, open: NSURL[]): void;
    // instance method
    applicationUserDidAcceptCloudKitShareWithMetadata?(_: NSApplication, userDidAcceptCloudKitShareWith: Metadata): void;
    // instance method
    applicationDidUpdateUserActivity?(_: NSApplication, didUpdate: NSUserActivity): void;
    // instance method
    applicationDelegateHandlesKey?(_: NSApplication, delegateHandlesKey: string): boolean;
    // instance method
    applicationDidDecodeRestorableState?(_: NSApplication, didDecodeRestorableState: NSCoder): void;
    // instance method
    applicationDidFailToContinueUserActivityWithTypeError?(_: NSApplication, didFailToContinueUserActivityWithType: string, error: NSError): void;
    // instance method
    applicationDidFailToRegisterForRemoteNotificationsWithError?(_: NSApplication, didFailToRegisterForRemoteNotificationsWithError: NSError): void;
    // instance method
    applicationDidReceiveRemoteNotification?(_: NSApplication, didReceiveRemoteNotification: Map<string, any>): void;
    // instance method
    applicationDidRegisterForRemoteNotificationsWithDeviceToken?(_: NSApplication, didRegisterForRemoteNotificationsWithDeviceToken: NSData): void;
    // instance method
    applicationOpenFile?(_: NSApplication, openFile: string): boolean;
    // instance method
    applicationOpenFiles?(_: NSApplication, openFiles: string[]): void;
    // instance method
    applicationOpenFileWithoutUI?(_: any, openFileWithoutUI: string): boolean;
    // instance method
    applicationOpenTempFile?(_: NSApplication, openTempFile: string): boolean;
    // instance method
    applicationPrintFile?(_: NSApplication, printFile: string): boolean;
    // instance method
    applicationPrintFilesWithSettingsShowPrintPanels?(_: NSApplication, printFiles: string[], withSettings: Map<string, any>, showPrintPanels: boolean): NSApplication.PrintReply;
    // instance method
    applicationWillContinueUserActivityWithType?(_: NSApplication, willContinueUserActivityWithType: string): boolean;
    // instance method
    applicationWillEncodeRestorableState?(_: NSApplication, willEncodeRestorableState: NSCoder): void;
    // instance method
    applicationWillPresentError?(_: NSApplication, willPresentError: NSError): NSError;
    // instance method
    applicationDidBecomeActive?(_: NSNotification): void;
    // instance method
    applicationDidChangeOcclusionState?(_: NSNotification): void;
    // instance method
    applicationDidChangeScreenParameters?(_: NSNotification): void;
    // instance method
    applicationDidFinishLaunching?(_: NSNotification): void;
    // instance method
    applicationDidHide?(_: NSNotification): void;
    // instance method
    applicationDidResignActive?(_: NSNotification): void;
    // instance method
    applicationDidUnhide?(_: NSNotification): void;
    // instance method
    applicationDidUpdate?(_: NSNotification): void;
    // instance method
    applicationDockMenu?(_: NSApplication): NSMenu;
    // instance method
    applicationOpenUntitledFile?(_: NSApplication): boolean;
    // instance method
    applicationShouldHandleReopenHasVisibleWindows?(_: NSApplication, hasVisibleWindows: boolean): boolean;
    // instance method
    applicationShouldOpenUntitledFile?(_: NSApplication): boolean;
    // instance method
    applicationShouldTerminate?(_: NSApplication): NSApplication.TerminateReply;
    // instance method
    applicationShouldTerminateAfterLastWindowClosed?(_: NSApplication): boolean;
    // instance method
    applicationWillBecomeActive?(_: NSNotification): void;
    // instance method
    applicationWillFinishLaunching?(_: NSNotification): void;
    // instance method
    applicationWillHide?(_: NSNotification): void;
    // instance method
    applicationWillResignActive?(_: NSNotification): void;
    // instance method
    applicationWillTerminate?(_: NSNotification): void;
    // instance method
    applicationWillUnhide?(_: NSNotification): void;
    // instance method
    applicationWillUpdate?(_: NSNotification): void;
  }

  // export function NSApplicationLoad(): boolean;

  // export function NSApplicationMain(argc: number, argv: string): never;

  // interface
  class NSArrayController extends NSObjectController {
    alwaysUsesMultipleValuesMarker: boolean;
    setAlwaysUsesMultipleValuesMarker(_: boolean)
    arrangedObjects: any;
    automaticRearrangementKeyPaths: string[];
    automaticallyRearrangesObjects: boolean;
    setAutomaticallyRearrangesObjects(_: boolean)
    avoidsEmptySelection: boolean;
    setAvoidsEmptySelection(_: boolean)
    canInsert: boolean;
    canSelectNext: boolean;
    canSelectPrevious: boolean;
    clearsFilterPredicateOnInsertion: boolean;
    setClearsFilterPredicateOnInsertion(_: boolean)
    filterPredicate: NSPredicate;
    setFilterPredicate(_: NSPredicate)
    preservesSelection: boolean;
    setPreservesSelection(_: boolean)
    selectionIndex: number;
    selectionIndexes: NSIndexSet;
    selectsInsertedObjects: boolean;
    setSelectsInsertedObjects(_: boolean)
    sortDescriptors: NSSortDescriptor[];
    setSortDescriptors(_: NSSortDescriptor[])
    addObjects(contentsOf: any[]): void;
    addSelectedObjects(_: any[]): boolean;
    addSelectionIndexes(_: NSIndexSet): boolean;
    arrangeObjects(_: any[]): any[];
    didChangeArrangementCriteria(): void;
    insert(_?: any): void;
    insertObjectAtArrangedObjectIndex(_: any, atArrangedObjectIndex: number): void;
    insertObjectsAtArrangedObjectIndexes(contentsOf: any[], atArrangedObjectIndexes: NSIndexSet): void;
    rearrangeObjects(): void;
    removeObjectAtArrangedObjectIndex(atArrangedObjectIndex: number): void;
    removeObjects(contentsOf: any[]): void;
    removeObjectsAtArrangedObjectIndexes(atArrangedObjectIndexes: NSIndexSet): void;
    removeSelectedObjects(_: any[]): boolean;
    removeSelectionIndexes(_: NSIndexSet): boolean;
    selectNext(_?: any): void;
    selectPrevious(_?: any): void;
    setSelectedObjects(_: any[]): boolean;
    setSelectionIndex(_: number): boolean;
    setSelectionIndexes(_: NSIndexSet): boolean;
  }

  // export function NSAvailableWindowDepths(): NSWindow.Depth;

  // export function NSBeep(): void;

  // export function NSBestDepth(colorSpace: string, bps: number, bpp: number, planar: boolean, exactMatch: boolean): NSWindow.Depth;

  // interface
  class NSBezierPath extends NSObject /* implements NSCopying, NSSecureCoding */ {
    static clipRect(_: CGRect): void;
    static drawPackedGlyphsAtPoint(_: string, at: CGPoint): void;
    static fillRect(_: CGRect): void;
    static strokeLineFromPointToPoint(from: CGPoint, to: CGPoint): void;
    static strokeRect(_: CGRect): void;
    bezierPathByFlatteningPath: NSBezierPath;
    bezierPathByReversingPath: NSBezierPath;
    bounds: CGRect;
    controlPointBounds: CGRect;
    currentPoint: CGPoint;
    elementCount: number;
    isEmpty: boolean;
    flatness: number;
    setFlatness(_: number)
    lineCapStyle: NSBezierPath.LineCapStyle;
    setLineCapStyle(_: NSBezierPath.LineCapStyle)
    lineJoinStyle: NSBezierPath.LineJoinStyle;
    setLineJoinStyle(_: NSBezierPath.LineJoinStyle)
    lineWidth: number;
    setLineWidth(_: number)
    miterLimit: number;
    setMiterLimit(_: number)
    windingRule: NSBezierPath.WindingRule;
    setWindingRule(_: NSBezierPath.WindingRule)
    static defaultFlatness: number;
    setDefaultFlatness(_: number)
    static defaultLineCapStyle: NSBezierPath.LineCapStyle;
    setDefaultLineCapStyle(_: NSBezierPath.LineCapStyle)
    static defaultLineJoinStyle: NSBezierPath.LineJoinStyle;
    setDefaultLineJoinStyle(_: NSBezierPath.LineJoinStyle)
    static defaultLineWidth: number;
    setDefaultLineWidth(_: number)
    static defaultMiterLimit: number;
    setDefaultMiterLimit(_: number)
    static defaultWindingRule: NSBezierPath.WindingRule;
    setDefaultWindingRule(_: NSBezierPath.WindingRule)
    addClip(): void;
    appendBezierPath(_: NSBezierPath): void;
    appendBezierPathWithArcFromPointToPointRadius(from: CGPoint, to: CGPoint, radius: number): void;
    appendBezierPathWithArcWithCenterRadiusStartAngleEndAngle(withCenter: CGPoint, radius: number, startAngle: number, endAngle: number): void;
    appendBezierPathWithArcWithCenterRadiusStartAngleEndAngleClockwise(withCenter: CGPoint, radius: number, startAngle: number, endAngle: number, clockwise: boolean): void;
    appendBezierPathWithCGGlyphInFont(withCGGlyph: number, in_: NSFont): void;
    appendBezierPathWithCGGlyphsCountInFont(withCGGlyphs: number, count: number, in_: NSFont): void;
    appendBezierPathWithOvalInRect(in_: CGRect): void;
    appendBezierPathWithPointsCount(_: NSPoint, count: number): void;
    appendBezierPathWithRect(_: CGRect): void;
    appendBezierPathWithRoundedRectXRadiusYRadius(_: CGRect, xRadius: number, yRadius: number): void;
    closePath(): void;
    containsPoint(_: CGPoint): boolean;
    curveToPointControlPoint1ControlPoint2(to: CGPoint, controlPoint1: CGPoint, controlPoint2: CGPoint): void;
    elementAtIndex(at: number): NSBezierPath.ElementType;
    elementAtIndexAssociatedPoints(at: number, associatedPoints?: NSPoint): NSBezierPath.ElementType;
    fill(): void;
    getLineDashCountPhase(_?: number, count?: number, phase?: number): void;
    lineToPoint(to: CGPoint): void;
    moveToPoint(to: CGPoint): void;
    relativeCurveToPointControlPoint1ControlPoint2(to: CGPoint, controlPoint1: CGPoint, controlPoint2: CGPoint): void;
    relativeLineToPoint(to: CGPoint): void;
    relativeMoveToPoint(to: CGPoint): void;
    removeAllPoints(): void;
    setAssociatedPointsAtIndex(_?: NSPoint, at?: number): void;
    setClip(): void;
    setLineDashCountPhase(_?: number, count?: number, phase?: number): void;
    stroke(): void;
    transformUsingAffineTransform(using: NSAffineTransform): void;
  }

  // interface
  class NSBindingSelectionMarker extends NSObject /* implements NSCopying */ {
    static defaultPlaceholderForMarkerOnClassWithBinding(for_?: NSBindingSelectionMarker, on?: typeof NSObject, withBinding?: string): any;
    static setDefaultPlaceholderForMarkerOnClassWithBinding(_?: any, for_?: NSBindingSelectionMarker, on?: typeof NSObject, withBinding?: string): void;
    static multipleValuesSelectionMarker: NSBindingSelectionMarker;
    static noSelectionMarker: NSBindingSelectionMarker;
    static notApplicableSelectionMarker: NSBindingSelectionMarker;
  }

  // interface
  class NSBitmapImageRep extends NSImageRep /* implements NSSecureCoding */ {
    static TIFFRepresentationOfImageRepsInArray(in_: NSImageRep[]): NSData;
    static TIFFRepresentationOfImageRepsInArrayUsingCompressionFactor(in_: NSImageRep[], using: NSBitmapImageRep.TIFFCompression, factor: number): NSData;
    static getTIFFCompressionTypesCount(_?: NSBitmapImageRep.TIFFCompression, count?: number): void;
    static imageRepsWithData(with_: NSData): NSImageRep[];
    static localizedNameForTIFFCompressionType(forTIFFCompressionType: NSBitmapImageRep.TIFFCompression): string;
    static representationOfImageRepsInArrayUsingTypeProperties(in_: NSImageRep[], using: NSBitmapImageRep.FileType, properties: Map<string, any>): NSData;
    CGImage: any;
    TIFFRepresentation: NSData;
    bitmapData: string;
    bitmapFormat: NSBitmapImageRep.Format;
    bitsPerPixel: number;
    bytesPerPlane: number;
    bytesPerRow: number;
    colorSpace: NSColorSpace;
    numberOfPlanes: number;
    isPlanar: boolean;
    samplesPerPixel: number;
    TIFFRepresentationUsingCompressionFactor(using: NSBitmapImageRep.TIFFCompression, factor: number): NSData;
    bitmapImageRepByConvertingToColorSpaceRenderingIntent(to: NSColorSpace, renderingIntent: NSColorRenderingIntent): NSBitmapImageRep;
    bitmapImageRepByRetaggingWithColorSpace(with_: NSColorSpace): NSBitmapImageRep;
    canBeCompressedUsing(using: NSBitmapImageRep.TIFFCompression): boolean;
    colorAtXY(x: number, y: number): NSColor;
    colorizeByMappingGrayToColorBlackMappingWhiteMapping(byMappingGray: number, to?: NSColor, blackMapping?: NSColor, whiteMapping?: NSColor): void;
    getBitmapDataPlanes(_?: string): void;
    getCompressionFactor(_?: NSBitmapImageRep.TIFFCompression, factor?: number): void;
    getPixelAtXY(_: number, atX: number, y: number): void;
    incrementalLoadFromDataComplete(from: NSData, complete: boolean): number;
    static createWithForIncrementalLoad(): NSBitmapImageRep;
    static createWithBitmapDataPlanesPixelsWidePixelsHighBitsPerSampleSamplesPerPixelHasAlphaIsPlanarColorSpaceNameBitmapFormatBytesPerRowBitsPerPixel(bitmapDataPlanes?: string, pixelsWide?: number, pixelsHigh?: number, bitsPerSample?: number, samplesPerPixel?: number, hasAlpha?: boolean, isPlanar?: boolean, colorSpaceName?: string, bitmapFormat?: NSBitmapImageRep.Format, bytesPerRow?: number, bitsPerPixel?: number): NSBitmapImageRep;
    static createWithBitmapDataPlanesPixelsWidePixelsHighBitsPerSampleSamplesPerPixelHasAlphaIsPlanarColorSpaceNameBytesPerRowBitsPerPixel(bitmapDataPlanes?: string, pixelsWide?: number, pixelsHigh?: number, bitsPerSample?: number, samplesPerPixel?: number, hasAlpha?: boolean, isPlanar?: boolean, colorSpaceName?: string, bytesPerRow?: number, bitsPerPixel?: number): NSBitmapImageRep;
    static createWithCGImage(CGImage: any): NSBitmapImageRep;
    static createWithCIImage(CIImage: CIImage): NSBitmapImageRep;
    static createWithData(data: NSData): NSBitmapImageRep;
    representationUsingTypeProperties(using: NSBitmapImageRep.FileType, properties: Map<string, any>): NSData;
    setColorAtXY(_: NSColor, atX: number, y: number): void;
    setCompressionFactor(_: NSBitmapImageRep.TIFFCompression, factor: number): void;
    setPixelAtXY(_: number, atX: number, y: number): void;
    setPropertyWithValue(_: string, withValue?: any): void;
    valueForProperty(forProperty: string): any;
  }

  // export function NSBitsPerPixelFromDepth(depth: NSWindow.Depth): number;

  // export function NSBitsPerSampleFromDepth(depth: NSWindow.Depth): number;

  // interface
  class NSBox extends NSView {
    borderColor: NSColor;
    setBorderColor(_: NSColor)
    borderRect: CGRect;
    borderWidth: number;
    setBorderWidth(_: number)
    boxType: NSBox.BoxType;
    setBoxType(_: NSBox.BoxType)
    contentView: NSView;
    setContentView(_: NSView)
    contentViewMargins: CGSize;
    setContentViewMargins(_: CGSize)
    cornerRadius: number;
    setCornerRadius(_: number)
    fillColor: NSColor;
    setFillColor(_: NSColor)
    title: string;
    setTitle(_: string)
    titleCell: any;
    titleFont: NSFont;
    setTitleFont(_: NSFont)
    titlePosition: NSBox.TitlePosition;
    setTitlePosition(_: NSBox.TitlePosition)
    titleRect: CGRect;
    isTransparent: boolean;
    setTransparent(_: boolean)
    setFrameFromContentFrame(_: CGRect): void;
    sizeToFit(): void;
  }

  // interface
  class NSBrowser extends NSControl {
    static removeSavedColumnsWithAutosaveName(withAutosaveName: string): void;
    allowsBranchSelection: boolean;
    setAllowsBranchSelection(_: boolean)
    allowsEmptySelection: boolean;
    setAllowsEmptySelection(_: boolean)
    allowsMultipleSelection: boolean;
    setAllowsMultipleSelection(_: boolean)
    allowsTypeSelect: boolean;
    setAllowsTypeSelect(_: boolean)
    autohidesScroller: boolean;
    setAutohidesScroller(_: boolean)
    backgroundColor: NSColor;
    setBackgroundColor(_: NSColor)
    cellPrototype: any;
    setCellPrototype(_: any)
    clickedColumn: number;
    clickedRow: number;
    columnResizingType: NSBrowser.ColumnResizingType;
    setColumnResizingType(_: NSBrowser.ColumnResizingType)
    columnsAutosaveName: string;
    setColumnsAutosaveName(_: string)
    delegate: NSBrowserDelegate;
    setDelegate(_: NSBrowserDelegate)
    doubleAction: string;
    setDoubleAction(_: string)
    firstVisibleColumn: number;
    hasHorizontalScroller: boolean;
    setHasHorizontalScroller(_: boolean)
    lastColumn: number;
    setLastColumn(_: number)
    lastVisibleColumn: number;
    isLoaded: boolean;
    maxVisibleColumns: number;
    setMaxVisibleColumns(_: number)
    minColumnWidth: number;
    setMinColumnWidth(_: number)
    numberOfVisibleColumns: number;
    pathSeparator: string;
    setPathSeparator(_: string)
    prefersAllColumnUserResizing: boolean;
    setPrefersAllColumnUserResizing(_: boolean)
    reusesColumns: boolean;
    setReusesColumns(_: boolean)
    rowHeight: number;
    setRowHeight(_: number)
    selectedCells: NSCell[];
    selectedColumn: number;
    selectionIndexPath: NSIndexPath;
    setSelectionIndexPath(_: NSIndexPath)
    selectionIndexPaths: NSIndexPath[];
    setSelectionIndexPaths(_: NSIndexPath[])
    sendsActionOnArrowKeys: boolean;
    setSendsActionOnArrowKeys(_: boolean)
    separatesColumns: boolean;
    setSeparatesColumns(_: boolean)
    takesTitleFromPreviousColumn: boolean;
    setTakesTitleFromPreviousColumn(_: boolean)
    titleHeight: number;
    isTitled: boolean;
    setTitled(_: boolean)
    static cellClass: typeof NSObject;
    addColumn(): void;
    canDragRowsWithIndexesInColumnWithEvent(with_: NSIndexSet, inColumn: number, with_2: NSEvent): boolean;
    columnContentWidthForColumnWidth(forColumnWidth: number): number;
    columnWidthForColumnContentWidth(forColumnContentWidth: number): number;
    defaultColumnWidth(): number;
    doClick(_?: any): void;
    doDoubleClick(_?: any): void;
    draggingImageForRowsWithIndexesInColumnWithEventOffset(with_: NSIndexSet, inColumn: number, with_2: NSEvent, offset?: NSPoint): NSImage;
    drawTitleOfColumnInRect(ofColumn: number, in_: CGRect): void;
    editItemAtIndexPathWithEventSelect(at: NSIndexPath, with_?: NSEvent, select?: boolean): void;
    frameOfColumn(ofColumn: number): CGRect;
    frameOfInsideOfColumn(ofInsideOfColumn: number): CGRect;
    frameOfRowInColumn(ofRow: number, inColumn: number): CGRect;
    getRowColumnForPoint(_?: number, column?: number, for_?: CGPoint): boolean;
    indexPathForColumn(forColumn: number): NSIndexPath;
    isLeafItem(_?: any): boolean;
    itemAtIndexPath(at: NSIndexPath): any;
    itemAtRowInColumn(atRow: number, inColumn: number): any;
    loadColumnZero(): void;
    loadedCellAtRowColumn(atRow: number, column: number): any;
    noteHeightOfRowsWithIndexesChangedInColumn(_: NSIndexSet, inColumn: number): void;
    parentForItemsInColumn(inColumn: number): any;
    path(): string;
    pathToColumn(toColumn: number): string;
    reloadColumn(_: number): void;
    reloadDataForRowIndexesInColumn(forRowIndexes: NSIndexSet, inColumn: number): void;
    scrollColumnToVisible(_: number): void;
    scrollColumnsLeftBy(by: number): void;
    scrollColumnsRightBy(by: number): void;
    scrollRowToVisibleInColumn(_: number, inColumn: number): void;
    selectRowInColumn(_: number, inColumn: number): void;
    selectRowIndexesInColumn(_: NSIndexSet, inColumn: number): void;
    selectedCellInColumn(inColumn: number): any;
    selectedRowInColumn(inColumn: number): number;
    selectedRowIndexesInColumn(inColumn: number): NSIndexSet;
    sendAction(): boolean;
    setCellClass(_: typeof NSObject): void;
    setDefaultColumnWidth(_: number): void;
    setDraggingSourceOperationMaskForLocal(_: NSDragOperation, forLocal: boolean): void;
    setPath(_: string): boolean;
    setTitleOfColumn(_: string, ofColumn: number): void;
    setWidthOfColumn(_: number, ofColumn: number): void;
    tile(): void;
    titleFrameOfColumn(ofColumn: number): CGRect;
    titleOfColumn(ofColumn: number): string;
    validateVisibleColumns(): void;
    widthOfColumn(ofColumn: number): number;
  }

  // interface
  class NSBrowserCell extends NSCell {
    alternateImage: NSImage;
    setAlternateImage(_: NSImage)
    isLeaf: boolean;
    setLeaf(_: boolean)
    isLoaded: boolean;
    setLoaded(_: boolean)
    static branchImage: NSImage;
    static highlightedBranchImage: NSImage;
    highlightColorInView(in_: NSView): NSColor;
    reset(): void;
    set(): void;
  }

  interface NSBrowserDelegate extends NSObject {
    // instance method
    browserCreateRowsForColumnInMatrix?(_: NSBrowser, createRowsForColumn: number, in_: NSMatrix): void;
    // instance method
    browserNextTypeSelectMatchFromRowToRowInColumnForString?(_: NSBrowser, nextTypeSelectMatchFromRow: number, toRow: number, inColumn: number, for_?: string): number;
    // instance method
    browserShouldTypeSelectForEventWithCurrentSearchString?(_: NSBrowser, shouldTypeSelectFor: NSEvent, withCurrentSearch?: string): boolean;
    // instance method
    browserSelectCellWithStringInColumn?(_: NSBrowser, selectCellWith: string, inColumn: number): boolean;
    // instance method
    browserDraggingImageForRowsWithIndexesInColumnWithEventOffset?(_: NSBrowser, draggingImageForRowsWith: NSIndexSet, inColumn: number, with_: NSEvent, offset: NSPoint): NSImage;
    // instance method
    browserCanDragRowsWithIndexesInColumnWithEvent?(_: NSBrowser, canDragRowsWith: NSIndexSet, inColumn: number, with_: NSEvent): boolean;
    // instance method
    browserWriteRowsWithIndexesInColumnToPasteboard?(_: NSBrowser, writeRowsWith: NSIndexSet, inColumn: number, to: NSPasteboard): boolean;
    // instance method
    browserAcceptDropAtRowColumnDropOperation?(_: NSBrowser, acceptDrop: NSDraggingInfo, atRow: number, column: number, dropOperation: NSBrowser.DropOperation): boolean;
    // instance method
    browserChildOfItem?(_: NSBrowser, child: number, ofItem?: any): any;
    // instance method
    browserDidChangeLastColumnToColumn?(_: NSBrowser, didChangeLastColumn: number, toColumn: number): void;
    // instance method
    browserHeaderViewControllerForItem?(_: NSBrowser, headerViewControllerForItem?: any): NSViewController;
    // instance method
    browserHeightOfRowInColumn?(_: NSBrowser, heightOfRow: number, inColumn: number): number;
    // instance method
    browserIsColumnValid?(_: NSBrowser, isColumnValid: number): boolean;
    // instance method
    browserIsLeafItem?(_: NSBrowser, isLeafItem?: any): boolean;
    // instance method
    browserNumberOfChildrenOfItem?(_: NSBrowser, numberOfChildrenOfItem?: any): number;
    // instance method
    browserNumberOfRowsInColumn?(_: NSBrowser, numberOfRowsInColumn: number): number;
    // instance method
    browserObjectValueForItem?(_: NSBrowser, objectValueForItem?: any): any;
    // instance method
    browserPreviewViewControllerForLeafItem?(_: NSBrowser, previewViewControllerForLeafItem: any): NSViewController;
    // instance method
    browserSelectionIndexesForProposedSelectionInColumn?(_: NSBrowser, selectionIndexesForProposedSelection: NSIndexSet, inColumn: number): NSIndexSet;
    // instance method
    browserSelectRowInColumn?(_: NSBrowser, selectRow: number, inColumn: number): boolean;
    // instance method
    browserSetObjectValueForItem?(_: NSBrowser, setObjectValue?: any, forItem?: any): void;
    // instance method
    browserShouldEditItem?(_: NSBrowser, shouldEditItem?: any): boolean;
    // instance method
    browserShouldShowCellExpansionForRowColumn?(_: NSBrowser, shouldShowCellExpansionForRow: number, column: number): boolean;
    // instance method
    browserShouldSizeColumnForUserResizeToWidth?(_: NSBrowser, shouldSizeColumn: number, forUserResize: boolean, toWidth: number): number;
    // instance method
    browserSizeToFitWidthOfColumn?(_: NSBrowser, sizeToFitWidthOfColumn: number): number;
    // instance method
    browserTitleOfColumn?(_: NSBrowser, titleOfColumn: number): string;
    // instance method
    browserTypeSelectStringForRowInColumn?(_: NSBrowser, typeSelectStringForRow: number, inColumn: number): string;
    // instance method
    browserValidateDropProposedRowColumnDropOperation?(_: NSBrowser, validateDrop: NSDraggingInfo, proposedRow: number, column: number, dropOperation: NSBrowser.DropOperation): NSDragOperation;
    // instance method
    browserWillDisplayCellAtRowColumn?(_: NSBrowser, willDisplayCell: any, atRow: number, column: number): void;
    // instance method
    browserColumnConfigurationDidChange?(_: NSNotification): void;
    // instance method
    browserDidScroll?(_: NSBrowser): void;
    // instance method
    browserWillScroll?(_: NSBrowser): void;
    // instance method
    rootItemForBrowser?(for_: NSBrowser): any;
  }

  // interface
  class NSButton extends NSControl /* implements NSAccessibilityButton, NSUserInterfaceCompression, NSUserInterfaceValidations */ {
    static checkboxWithTitleTargetAction(checkboxWithTitle: string, target?: any, action?: string): NSButton;
    static radioButtonWithTitleTargetAction(radioButtonWithTitle: string, target?: any, action?: string): NSButton;
    allowsMixedState: boolean;
    setAllowsMixedState(_: boolean)
    alternateImage: NSImage;
    setAlternateImage(_: NSImage)
    alternateTitle: string;
    setAlternateTitle(_: string)
    attributedAlternateTitle: NSAttributedString;
    setAttributedAlternateTitle(_: NSAttributedString)
    attributedTitle: NSAttributedString;
    setAttributedTitle(_: NSAttributedString)
    bezelColor: NSColor;
    setBezelColor(_: NSColor)
    bezelStyle: NSButton.BezelStyle;
    setBezelStyle(_: NSButton.BezelStyle)
    isBordered: boolean;
    setBordered(_: boolean)
    contentTintColor: NSColor;
    setContentTintColor(_: NSColor)
    image: NSImage;
    setImage(_: NSImage)
    imageHugsTitle: boolean;
    setImageHugsTitle(_: boolean)
    imagePosition: NSControl.ImagePosition;
    setImagePosition(_: NSControl.ImagePosition)
    imageScaling: NSImageScaling;
    setImageScaling(_: NSImageScaling)
    keyEquivalent: string;
    setKeyEquivalent(_: string)
    keyEquivalentModifierMask: NSEvent.ModifierFlags;
    setKeyEquivalentModifierMask(_: NSEvent.ModifierFlags)
    maxAcceleratorLevel: number;
    setMaxAcceleratorLevel(_: number)
    showsBorderOnlyWhileMouseInside: boolean;
    setShowsBorderOnlyWhileMouseInside(_: boolean)
    sound: NSSound;
    setSound(_: NSSound)
    isSpringLoaded: boolean;
    setSpringLoaded(_: boolean)
    state: number;
    setState(_: number)
    title: string;
    setTitle(_: string)
    isTransparent: boolean;
    setTransparent(_: boolean)
    getPeriodicDelayInterval(_: number, interval: number): void;
    highlight(_: boolean): void;
    setButtonType(_: NSButton.ButtonType): void;
    setNextState(): void;
    setPeriodicDelayInterval(_: number, interval: number): void;
  }

  // interface
  class NSButtonCell extends NSActionCell {
    alternateImage: NSImage;
    setAlternateImage(_: NSImage)
    alternateTitle: string;
    setAlternateTitle(_: string)
    attributedAlternateTitle: NSAttributedString;
    setAttributedAlternateTitle(_: NSAttributedString)
    attributedTitle: NSAttributedString;
    setAttributedTitle(_: NSAttributedString)
    backgroundColor: NSColor;
    setBackgroundColor(_: NSColor)
    bezelStyle: NSButton.BezelStyle;
    setBezelStyle(_: NSButton.BezelStyle)
    highlightsBy: NSCell.StyleMask;
    setHighlightsBy(_: NSCell.StyleMask)
    imageDimsWhenDisabled: boolean;
    setImageDimsWhenDisabled(_: boolean)
    imagePosition: NSControl.ImagePosition;
    setImagePosition(_: NSControl.ImagePosition)
    imageScaling: NSImageScaling;
    setImageScaling(_: NSImageScaling)
    keyEquivalentModifierMask: NSEvent.ModifierFlags;
    setKeyEquivalentModifierMask(_: NSEvent.ModifierFlags)
    showsBorderOnlyWhileMouseInside: boolean;
    setShowsBorderOnlyWhileMouseInside(_: boolean)
    showsStateBy: NSCell.StyleMask;
    setShowsStateBy(_: NSCell.StyleMask)
    sound: NSSound;
    setSound(_: NSSound)
    isTransparent: boolean;
    setTransparent(_: boolean)
    drawBezelWithFrameInView(withFrame: CGRect, in_: NSView): void;
    drawImageWithFrameInView(_: NSImage, withFrame: CGRect, in_: NSView): void;
    drawTitleWithFrameInView(_: NSAttributedString, withFrame: CGRect, in_: NSView): CGRect;
    mouseEntered(with_: NSEvent): void;
    mouseExited(with_: NSEvent): void;
    setButtonType(_: NSButton.ButtonType): void;
    setPeriodicDelayInterval(_: number, interval: number): void;
  }

  // interface
  class NSButtonTouchBarItem extends NSTouchBarItem {
    action: string;
    setAction(_: string)
    bezelColor: NSColor;
    setBezelColor(_: NSColor)
    isEnabled: boolean;
    setEnabled(_: boolean)
    image: NSImage;
    setImage(_: NSImage)
    target: any;
    setTarget(_: any)
    title: string;
    setTitle(_: string)
  }

  // interface
  class NSCIImageRep extends NSImageRep {
    CIImage: CIImage;
    static createWithCIImage(CIImage: CIImage): NSCIImageRep;
  }

  // interface
  class NSCandidateListTouchBarItem<CandidateType> extends NSTouchBarItem {
    allowsCollapsing: boolean;
    setAllowsCollapsing(_: boolean)
    allowsTextInputContextCandidates: boolean;
    setAllowsTextInputContextCandidates(_: boolean)
    attributedStringForCandidate: (p1: CandidateType, p2: number) => NSAttributedString;
    setAttributedStringForCandidate(_: (p1: CandidateType, p2: number) => NSAttributedString)
    isCandidateListVisible: boolean;
    candidates: CandidateType[];
    client: NSView;
    setClient(_: NSView)
    isCollapsed: boolean;
    setCollapsed(_: boolean)
    delegate: NSCandidateListTouchBarItemDelegate;
    setDelegate(_: NSCandidateListTouchBarItemDelegate)
    setCandidatesForSelectedRangeInString(_: CandidateType[], forSelectedRange: NSRange, in_?: string): void;
    updateWithInsertionPointVisibility(withInsertionPointVisibility: boolean): void;
  }

  interface NSCandidateListTouchBarItemDelegate extends NSObject {
    // instance method
    candidateListTouchBarItemBeginSelectingCandidateAtIndex?(_: NSCandidateListTouchBarItem<any>, beginSelectingCandidateAt: number): void;
    // instance method
    candidateListTouchBarItemChangeSelectionFromCandidateAtIndexToIndex?(_: NSCandidateListTouchBarItem<any>, changeSelectionFromCandidateAt: number, to: number): void;
    // instance method
    candidateListTouchBarItemEndSelectingCandidateAtIndex?(_: NSCandidateListTouchBarItem<any>, endSelectingCandidateAt: number): void;
    // instance method
    candidateListTouchBarItemChangedCandidateListVisibility?(_: NSCandidateListTouchBarItem<any>, changedCandidateListVisibility: boolean): void;
  }

  // interface
  class NSCell extends NSObject /* implements NSAccessibility, NSAccessibilityElement, NSCoding, NSCopying, NSUserInterfaceItemIdentification */ {
    acceptsFirstResponder: boolean;
    action: string;
    setAction(_: string)
    alignment: NSTextAlignment;
    setAlignment(_: NSTextAlignment)
    allowsEditingTextAttributes: boolean;
    setAllowsEditingTextAttributes(_: boolean)
    allowsMixedState: boolean;
    setAllowsMixedState(_: boolean)
    allowsUndo: boolean;
    setAllowsUndo(_: boolean)
    attributedStringValue: NSAttributedString;
    setAttributedStringValue(_: NSAttributedString)
    backgroundStyle: NSView.BackgroundStyle;
    setBackgroundStyle(_: NSView.BackgroundStyle)
    baseWritingDirection: NSWritingDirection;
    setBaseWritingDirection(_: NSWritingDirection)
    isBezeled: boolean;
    setBezeled(_: boolean)
    isBordered: boolean;
    setBordered(_: boolean)
    cellSize: CGSize;
    isContinuous: boolean;
    setContinuous(_: boolean)
    controlSize: NSControl.ControlSize;
    setControlSize(_: NSControl.ControlSize)
    controlView: NSView;
    setControlView(_: NSView)
    doubleValue: number;
    setDoubleValue(_: number)
    isEditable: boolean;
    setEditable(_: boolean)
    isEnabled: boolean;
    setEnabled(_: boolean)
    floatValue: number;
    setFloatValue(_: number)
    focusRingType: NSFocusRingType;
    setFocusRingType(_: NSFocusRingType)
    font: NSFont;
    setFont(_: NSFont)
    formatter: Formatter;
    setFormatter(_: Formatter)
    hasValidObjectValue: boolean;
    isHighlighted: boolean;
    setHighlighted(_: boolean)
    image: NSImage;
    setImage(_: NSImage)
    importsGraphics: boolean;
    setImportsGraphics(_: boolean)
    intValue: number;
    setIntValue(_: number)
    integerValue: number;
    setIntegerValue(_: number)
    interiorBackgroundStyle: NSView.BackgroundStyle;
    keyEquivalent: string;
    lineBreakMode: NSLineBreakMode;
    setLineBreakMode(_: NSLineBreakMode)
    menu: NSMenu;
    setMenu(_: NSMenu)
    mouseDownFlags: number;
    nextState: number;
    objectValue: any;
    setObjectValue(_: any)
    isOpaque: boolean;
    refusesFirstResponder: boolean;
    setRefusesFirstResponder(_: boolean)
    representedObject: any;
    setRepresentedObject(_: any)
    isScrollable: boolean;
    setScrollable(_: boolean)
    isSelectable: boolean;
    setSelectable(_: boolean)
    sendsActionOnEndEditing: boolean;
    setSendsActionOnEndEditing(_: boolean)
    showsFirstResponder: boolean;
    setShowsFirstResponder(_: boolean)
    state: number;
    setState(_: number)
    stringValue: string;
    setStringValue(_: string)
    tag: number;
    setTag(_: number)
    target: any;
    setTarget(_: any)
    title: string;
    setTitle(_: string)
    truncatesLastVisibleLine: boolean;
    setTruncatesLastVisibleLine(_: boolean)
    type: NSCell.CellType;
    setType(_: NSCell.CellType)
    userInterfaceLayoutDirection: NSUserInterfaceLayoutDirection;
    setUserInterfaceLayoutDirection(_: NSUserInterfaceLayoutDirection)
    usesSingleLineMode: boolean;
    setUsesSingleLineMode(_: boolean)
    wantsNotificationForMarkedText: boolean;
    wraps: boolean;
    setWraps(_: boolean)
    static defaultFocusRingType: NSFocusRingType;
    static defaultMenu: NSMenu;
    static prefersTrackingUntilMouseUp: boolean;
    calcDrawInfo(_: CGRect): void;
    cellAttribute(_: NSCell.Attribute): number;
    cellSizeForBounds(forBounds: CGRect): CGSize;
    compare(_: any): ComparisonResult;
    continueTrackingAtInView(last: CGPoint, current: CGPoint, in_: NSView): boolean;
    draggingImageComponentsWithFrameInView(withFrame: CGRect, in_: NSView): NSDraggingImageComponent[];
    drawFocusRingMaskWithFrameInView(withFrame: CGRect, in_: NSView): void;
    drawInteriorWithFrameInView(withFrame: CGRect, in_: NSView): void;
    drawWithExpansionFrameInView(withExpansionFrame: CGRect, in_: NSView): void;
    drawWithFrameInView(withFrame: CGRect, in_: NSView): void;
    drawingRectForBounds(forBounds: CGRect): CGRect;
    editWithFrameInViewEditorDelegateEvent(withFrame: CGRect, in_: NSView, editor: NSText, delegate?: any, event?: NSEvent): void;
    endEditing(_: NSText): void;
    expansionFrameWithFrameInView(withFrame: CGRect, in_: NSView): CGRect;
    fieldEditorForView(for_: NSView): NSTextView;
    focusRingMaskBoundsForFrameInView(forFrame: CGRect, in_: NSView): CGRect;
    getPeriodicDelayInterval(_: number, interval: number): void;
    highlightWithFrameInView(_: boolean, withFrame: CGRect, in_: NSView): void;
    highlightColorWithFrameInView(withFrame: CGRect, in_: NSView): NSColor;
    hitTestForEventInRectOfView(for_: NSEvent, in_: CGRect, of: NSView): NSCell.HitResult;
    imageRectForBounds(forBounds: CGRect): CGRect;
    static createWithImageCell(imageCell?: NSImage): NSCell;
    static createWithTextCell(textCell: string): NSCell;
    menuForEventInRectOfView(for_: NSEvent, in_: CGRect, of: NSView): NSMenu;
    performClick(_?: any): void;
    resetCursorRectInView(_: CGRect, in_: NSView): void;
    selectWithFrameInViewEditorDelegateStartLength(withFrame: CGRect, in_: NSView, editor: NSText, delegate?: any, start?: number, length?: number): void;
    sendActionOn(on: NSEvent.EventTypeMask): number;
    setCellAttributeTo(_: NSCell.Attribute, to: number): void;
    setNextState(): void;
    setUpFieldEditorAttributes(_: NSText): NSText;
    startTrackingAtInView(at: CGPoint, in_: NSView): boolean;
    stopTrackingAtInViewMouseIsUp(last: CGPoint, current: CGPoint, in_: NSView, mouseIsUp: boolean): void;
    takeDoubleValueFrom(_?: any): void;
    takeFloatValueFrom(_?: any): void;
    takeIntValueFrom(_?: any): void;
    takeIntegerValueFrom(_?: any): void;
    takeObjectValueFrom(_?: any): void;
    takeStringValueFrom(_?: any): void;
    titleRectForBounds(forBounds: CGRect): CGRect;
    trackMouseInRectOfViewUntilMouseUp(with_: NSEvent, in_: CGRect, of: NSView, untilMouseUp: boolean): boolean;
  }

  interface NSChangeSpelling {
    // instance method
    changeSpelling(_?: any): void;
  }

  // interface
  class NSClickGestureRecognizer extends NSGestureRecognizer /* implements NSCoding */ {
    buttonMask: number;
    setButtonMask(_: number)
    numberOfClicksRequired: number;
    setNumberOfClicksRequired(_: number)
    numberOfTouchesRequired: number;
    setNumberOfTouchesRequired(_: number)
  }

  // interface
  class NSClipView extends NSView {
    automaticallyAdjustsContentInsets: boolean;
    setAutomaticallyAdjustsContentInsets(_: boolean)
    backgroundColor: NSColor;
    setBackgroundColor(_: NSColor)
    contentInsets: NSEdgeInsets;
    setContentInsets(_: NSEdgeInsets)
    documentCursor: NSCursor;
    setDocumentCursor(_: NSCursor)
    documentRect: CGRect;
    documentView: NSView;
    setDocumentView(_: NSView)
    documentVisibleRect: CGRect;
    drawsBackground: boolean;
    setDrawsBackground(_: boolean)
    constrainBoundsRect(_: CGRect): CGRect;
    scrollToPoint(to: CGPoint): void;
    viewBoundsChanged(_: NSNotification): void;
    viewFrameChanged(_: NSNotification): void;
  }

  interface NSCloudSharingServiceDelegate extends NSSharingServiceDelegate {
    // instance method
    optionsForSharingServiceShareProvider?(for_: NSSharingService, share: NSItemProvider): NSSharingService.CloudKitOptions;
    // instance method
    sharingServiceDidSaveShare?(_: NSSharingService, didSave: CKShare): void;
    // instance method
    sharingServiceDidCompleteForItemsError?(_: NSSharingService, didCompleteForItems: any[], error?: NSError): void;
    // instance method
    sharingServiceDidStopSharing?(_: NSSharingService, didStopSharing: CKShare): void;
  }

  interface NSCloudSharingValidation extends NSObject {
    // instance method
    cloudShareForUserInterfaceItem(for_: NSValidatedUserInterfaceItem): CKShare;
  }

  // interface
  class NSCollectionLayoutAnchor extends NSObject /* implements NSCopying */ {
    static layoutAnchorWithEdges(edges: NSDirectionalRectEdge): NSCollectionLayoutAnchor;
    static layoutAnchorWithEdgesAbsoluteOffset(edges: NSDirectionalRectEdge, absoluteOffset: CGPoint): NSCollectionLayoutAnchor;
    static layoutAnchorWithEdgesFractionalOffset(edges: NSDirectionalRectEdge, fractionalOffset: CGPoint): NSCollectionLayoutAnchor;
    edges: NSDirectionalRectEdge;
    isAbsoluteOffset: boolean;
    isFractionalOffset: boolean;
    offset: CGPoint;
  }

  // interface
  class NSCollectionLayoutBoundarySupplementaryItem extends NSCollectionLayoutSupplementaryItem /* implements NSCopying */ {
    static boundarySupplementaryItemWithLayoutSizeElementKindAlignment(layoutSize: NSCollectionLayoutSize, elementKind: string, alignment: NSRectAlignment): NSCollectionLayoutBoundarySupplementaryItem;
    static boundarySupplementaryItemWithLayoutSizeElementKindAlignmentAbsoluteOffset(layoutSize: NSCollectionLayoutSize, elementKind: string, alignment: NSRectAlignment, absoluteOffset: CGPoint): NSCollectionLayoutBoundarySupplementaryItem;
    alignment: NSRectAlignment;
    extendsBoundary: boolean;
    setExtendsBoundary(_: boolean)
    offset: CGPoint;
    pinToVisibleBounds: boolean;
    setPinToVisibleBounds(_: boolean)
  }

  interface NSCollectionLayoutContainer extends NSObject {
    contentInsets: NSDirectionalEdgeInsets;
    contentSize: CGSize;
    effectiveContentInsets: NSDirectionalEdgeInsets;
    effectiveContentSize: CGSize;
  }

  // interface
  class NSCollectionLayoutDecorationItem extends NSCollectionLayoutItem /* implements NSCopying */ {
    static backgroundDecorationItemWithElementKind(elementKind: string): NSCollectionLayoutDecorationItem;
    elementKind: string;
    zIndex: number;
    setZIndex(_: number)
  }

  // interface
  class NSCollectionLayoutDimension extends NSObject /* implements NSCopying */ {
    static absoluteDimension(_: number): NSCollectionLayoutDimension;
    static estimatedDimension(_: number): NSCollectionLayoutDimension;
    static fractionalHeightDimension(_: number): NSCollectionLayoutDimension;
    static fractionalWidthDimension(_: number): NSCollectionLayoutDimension;
    dimension: number;
    isAbsolute: boolean;
    isEstimated: boolean;
    isFractionalHeight: boolean;
    isFractionalWidth: boolean;
  }

  // interface
  class NSCollectionLayoutEdgeSpacing extends NSObject /* implements NSCopying */ {
    static spacingForLeadingTopTrailingBottom(leading?: NSCollectionLayoutSpacing, top?: NSCollectionLayoutSpacing, trailing?: NSCollectionLayoutSpacing, bottom?: NSCollectionLayoutSpacing): NSCollectionLayoutEdgeSpacing;
    bottom: NSCollectionLayoutSpacing;
    leading: NSCollectionLayoutSpacing;
    top: NSCollectionLayoutSpacing;
    trailing: NSCollectionLayoutSpacing;
  }

  interface NSCollectionLayoutEnvironment extends NSObject {
    container: NSCollectionLayoutContainer;
  }

  // interface
  class NSCollectionLayoutGroup extends NSCollectionLayoutItem /* implements NSCopying */ {
    static customWithLayoutSizeItemProvider(layoutSize: NSCollectionLayoutSize, itemProvider: (p1: NSCollectionLayoutEnvironment) => NSCollectionLayoutGroupCustomItem[]): NSCollectionLayoutGroup;
    static horizontalGroupWithLayoutSizeSubitemCount(layoutSize: NSCollectionLayoutSize, subitem: NSCollectionLayoutItem, count: number): NSCollectionLayoutGroup;
    static horizontalGroupWithLayoutSizeSubitems(layoutSize: NSCollectionLayoutSize, subitems: NSCollectionLayoutItem[]): NSCollectionLayoutGroup;
    static verticalGroupWithLayoutSizeSubitemCount(layoutSize: NSCollectionLayoutSize, subitem: NSCollectionLayoutItem, count: number): NSCollectionLayoutGroup;
    static verticalGroupWithLayoutSizeSubitems(layoutSize: NSCollectionLayoutSize, subitems: NSCollectionLayoutItem[]): NSCollectionLayoutGroup;
    interItemSpacing: NSCollectionLayoutSpacing;
    setInterItemSpacing(_: NSCollectionLayoutSpacing)
    subitems: NSCollectionLayoutItem[];
    visualDescription(): string;
  }

  // interface
  class NSCollectionLayoutGroupCustomItem extends NSObject /* implements NSCopying */ {
    static customItemWithFrame(frame: CGRect): NSCollectionLayoutGroupCustomItem;
    static customItemWithFrameZIndex(frame: CGRect, zIndex: number): NSCollectionLayoutGroupCustomItem;
    frame: CGRect;
    zIndex: number;
  }

  // interface
  class NSCollectionLayoutItem extends NSObject /* implements NSCopying */ {
    static itemWithLayoutSize(layoutSize: NSCollectionLayoutSize): NSCollectionLayoutItem;
    static itemWithLayoutSizeSupplementaryItems(layoutSize: NSCollectionLayoutSize, supplementaryItems: NSCollectionLayoutSupplementaryItem[]): NSCollectionLayoutItem;
    contentInsets: NSDirectionalEdgeInsets;
    setContentInsets(_: NSDirectionalEdgeInsets)
    edgeSpacing: NSCollectionLayoutEdgeSpacing;
    setEdgeSpacing(_: NSCollectionLayoutEdgeSpacing)
    layoutSize: NSCollectionLayoutSize;
    supplementaryItems: NSCollectionLayoutSupplementaryItem[];
  }

  // interface
  class NSCollectionLayoutSection extends NSObject /* implements NSCopying */ {
    static sectionWithGroup(group: NSCollectionLayoutGroup): NSCollectionLayoutSection;
    boundarySupplementaryItems: NSCollectionLayoutBoundarySupplementaryItem[];
    setBoundarySupplementaryItems(_: NSCollectionLayoutBoundarySupplementaryItem[])
    contentInsets: NSDirectionalEdgeInsets;
    setContentInsets(_: NSDirectionalEdgeInsets)
    decorationItems: NSCollectionLayoutDecorationItem[];
    setDecorationItems(_: NSCollectionLayoutDecorationItem[])
    interGroupSpacing: number;
    setInterGroupSpacing(_: number)
    orthogonalScrollingBehavior: NSCollectionLayoutSectionOrthogonalScrollingBehavior;
    setOrthogonalScrollingBehavior(_: NSCollectionLayoutSectionOrthogonalScrollingBehavior)
    supplementariesFollowContentInsets: boolean;
    setSupplementariesFollowContentInsets(_: boolean)
    visibleItemsInvalidationHandler: (p1: NSCollectionLayoutVisibleItem[], p2: CGPoint, p3: NSCollectionLayoutEnvironment) => void;
    setVisibleItemsInvalidationHandler(_: (p1: NSCollectionLayoutVisibleItem[], p2: CGPoint, p3: NSCollectionLayoutEnvironment) => void)
  }

  // interface
  class NSCollectionLayoutSize extends NSObject /* implements NSCopying */ {
    static sizeWithWidthDimensionHeightDimension(widthDimension: NSCollectionLayoutDimension, heightDimension: NSCollectionLayoutDimension): NSCollectionLayoutSize;
    heightDimension: NSCollectionLayoutDimension;
    widthDimension: NSCollectionLayoutDimension;
  }

  // interface
  class NSCollectionLayoutSpacing extends NSObject /* implements NSCopying */ {
    static fixedSpacing(_: number): NSCollectionLayoutSpacing;
    static flexibleSpacing(_: number): NSCollectionLayoutSpacing;
    isFixedSpacing: boolean;
    isFlexibleSpacing: boolean;
    spacing: number;
  }

  // interface
  class NSCollectionLayoutSupplementaryItem extends NSCollectionLayoutItem /* implements NSCopying */ {
    static supplementaryItemWithLayoutSizeElementKindContainerAnchor(layoutSize: NSCollectionLayoutSize, elementKind: string, containerAnchor: NSCollectionLayoutAnchor): NSCollectionLayoutSupplementaryItem;
    static supplementaryItemWithLayoutSizeElementKindContainerAnchorItemAnchor(layoutSize: NSCollectionLayoutSize, elementKind: string, containerAnchor: NSCollectionLayoutAnchor, itemAnchor: NSCollectionLayoutAnchor): NSCollectionLayoutSupplementaryItem;
    containerAnchor: NSCollectionLayoutAnchor;
    elementKind: string;
    itemAnchor: NSCollectionLayoutAnchor;
    zIndex: number;
    setZIndex(_: number)
  }

  interface NSCollectionLayoutVisibleItem extends NSObject {
    alpha: number;
    setAlpha(_: number)
    bounds: CGRect;
    center: CGPoint;
    setCenter(_: CGPoint)
    frame: CGRect;
    isHidden: boolean;
    setHidden(_: boolean)
    indexPath: NSIndexPath;
    name: string;
    representedElementCategory: NSCollectionElementCategory;
    representedElementKind: string;
    zIndex: number;
    setZIndex(_: number)
  }

  // interface
  class NSCollectionView extends NSView /* implements NSDraggingDestination, NSDraggingSource */ {
    allowsEmptySelection: boolean;
    setAllowsEmptySelection(_: boolean)
    allowsMultipleSelection: boolean;
    setAllowsMultipleSelection(_: boolean)
    backgroundColors: NSColor[];
    setBackgroundColors(_: NSColor[])
    backgroundView: NSView;
    setBackgroundView(_: NSView)
    backgroundViewScrollsWithContent: boolean;
    setBackgroundViewScrollsWithContent(_: boolean)
    collectionViewLayout: NSCollectionViewLayout;
    setCollectionViewLayout(_: NSCollectionViewLayout)
    content: any[];
    setContent(_: any[])
    dataSource: NSCollectionViewDataSource;
    setDataSource(_: NSCollectionViewDataSource)
    delegate: NSCollectionViewDelegate;
    setDelegate(_: NSCollectionViewDelegate)
    isFirstResponder: boolean;
    numberOfSections: number;
    prefetchDataSource: NSCollectionViewPrefetching;
    setPrefetchDataSource(_: NSCollectionViewPrefetching)
    isSelectable: boolean;
    setSelectable(_: boolean)
    selectionIndexPaths: NSSet<IndexPath>;
    setSelectionIndexPaths(_: NSSet<IndexPath>)
    selectionIndexes: NSIndexSet;
    setSelectionIndexes(_: NSIndexSet)
    deleteItemsWithAt(at: NSSet<IndexPath>): void;
    deleteSections(_: NSIndexSet): void;
    deselectAll(_?: any): void;
    deselectItemsWithAt(at: NSSet<IndexPath>): void;
    draggingImageForItemsWithAtWithOffset(at: NSSet<IndexPath>, with_: NSEvent, offset: NSPoint): NSImage;
    draggingImageForItemsAtIndexesWithEventOffset(at: NSIndexSet, with_: NSEvent, offset: NSPoint): NSImage;
    frameForItemAtIndex(at: number): CGRect;
    frameForItemAtIndexWithNumberOfItems(at: number, withNumberOfItems: number): CGRect;
    indexPathForItem(for_: NSCollectionViewItem): NSIndexPath;
    indexPathForItemAtPoint(at: CGPoint): NSIndexPath;
    indexPathsForVisibleItems(): NSSet<IndexPath>;
    indexPathsForVisibleSupplementaryElementsOfKind(ofKind: string): NSSet<IndexPath>;
    insertItemsWithAt(at: NSSet<IndexPath>): void;
    insertSections(_: NSIndexSet): void;
    itemAtIndex(at: number): NSCollectionViewItem;
    itemAtIndexPath(at: NSIndexPath): NSCollectionViewItem;
    layoutAttributesForItemAtIndexPath(at: NSIndexPath): NSCollectionViewLayoutAttributes;
    layoutAttributesForSupplementaryElementOfKindAtIndexPath(ofKind: string, at: NSIndexPath): NSCollectionViewLayoutAttributes;
    makeItemWithIdentifierForIndexPath(withIdentifier: string, for_: NSIndexPath): NSCollectionViewItem;
    makeSupplementaryViewOfKindWithIdentifierForIndexPath(ofKind: string, withIdentifier: string, for_: NSIndexPath): NSView;
    moveItemAtIndexPathToIndexPath(at: NSIndexPath, to: NSIndexPath): void;
    moveSectionToSection(_: number, toSection: number): void;
    numberOfItemsInSection(inSection: number): number;
    performBatchUpdatesWithCompletionHandler(_?: () => void, completionHandler?: (p1: boolean) => void): void;
    registerClassForItemWithIdentifier(_?: typeof NSObject, forItemWithIdentifier?: string): void;
    registerClassForSupplementaryViewOfKindWithIdentifier(_?: typeof NSObject, forSupplementaryViewOfKind?: string, withIdentifier?: string): void;
    registerNibForItemWithIdentifier(_?: NSNib, forItemWithIdentifier?: string): void;
    registerNibForSupplementaryViewOfKindWithIdentifier(_?: NSNib, forSupplementaryViewOfKind?: string, withIdentifier?: string): void;
    reloadData(): void;
    reloadItemsWithAt(at: NSSet<IndexPath>): void;
    reloadSections(_: NSIndexSet): void;
    scrollToItemsWithAtScrollPosition(at: NSSet<IndexPath>, scrollPosition: NSCollectionView.ScrollPosition): void;
    selectItemsWithAtScrollPosition(at: NSSet<IndexPath>, scrollPosition: NSCollectionView.ScrollPosition): void;
    setDraggingSourceOperationMaskForLocal(_: NSDragOperation, forLocal: boolean): void;
    supplementaryViewForElementKindAtIndexPath(forElementKind: string, at: NSIndexPath): NSView;
    toggleSectionCollapse(_: any): void;
    visibleItems(): NSCollectionViewItem[];
    visibleSupplementaryViewsOfKind(ofKind: string): NSView[];
  }

  // interface
  class NSCollectionViewCompositionalLayout extends NSCollectionViewLayout {
    configuration: NSCollectionViewCompositionalLayoutConfiguration;
    setConfiguration(_: NSCollectionViewCompositionalLayoutConfiguration)
    static createWithSection(section: NSCollectionLayoutSection): NSCollectionViewCompositionalLayout;
    static createWithSectionConfiguration(section: NSCollectionLayoutSection, configuration: NSCollectionViewCompositionalLayoutConfiguration): NSCollectionViewCompositionalLayout;
    static createWithSectionProvider(sectionProvider: (p1: number, p2: NSCollectionLayoutEnvironment) => NSCollectionLayoutSection): NSCollectionViewCompositionalLayout;
    static createWithSectionProviderConfiguration(sectionProvider: (p1: number, p2: NSCollectionLayoutEnvironment) => NSCollectionLayoutSection, configuration: NSCollectionViewCompositionalLayoutConfiguration): NSCollectionViewCompositionalLayout;
  }

  // interface
  class NSCollectionViewCompositionalLayoutConfiguration extends NSObject /* implements NSCopying */ {
    boundarySupplementaryItems: NSCollectionLayoutBoundarySupplementaryItem[];
    setBoundarySupplementaryItems(_: NSCollectionLayoutBoundarySupplementaryItem[])
    interSectionSpacing: number;
    setInterSectionSpacing(_: number)
    scrollDirection: NSCollectionView.ScrollDirection;
    setScrollDirection(_: NSCollectionView.ScrollDirection)
  }

  interface NSCollectionViewDataSource extends NSObject {
    // instance method
    collectionViewItemForRepresentedObjectAtIndexPath(_: NSCollectionView, itemForRepresentedObjectAt: NSIndexPath): NSCollectionViewItem;
    // instance method
    collectionViewViewForSupplementaryElementOfKindAtIndexPath?(_: NSCollectionView, viewForSupplementaryElementOfKind: string, at: NSIndexPath): NSView;
    // instance method
    collectionViewNumberOfItemsInSection(_: NSCollectionView, numberOfItemsInSection: number): number;
    // instance method
    numberOfSectionsInCollectionView?(in_: NSCollectionView): number;
  }

  interface NSCollectionViewDelegate extends NSObject {
    // instance method
    collectionViewCanDragItemsAtWith?(_: NSCollectionView, canDragItemsAt: NSSet<IndexPath>, with_: NSEvent): boolean;
    // instance method
    collectionViewCanDragItemsAtIndexesWithEvent?(_: NSCollectionView, canDragItemsAt: NSIndexSet, with_: NSEvent): boolean;
    // instance method
    collectionViewWriteItemsAtTo?(_: NSCollectionView, writeItemsAt: NSSet<IndexPath>, to: NSPasteboard): boolean;
    // instance method
    collectionViewWriteItemsAtIndexesToPasteboard?(_: NSCollectionView, writeItemsAt: NSIndexSet, to: NSPasteboard): boolean;
    // instance method
    collectionViewDraggingImageForItemsAtWithOffset?(_: NSCollectionView, draggingImageForItemsAt: NSSet<IndexPath>, with_: NSEvent, offset: NSPoint): NSImage;
    // instance method
    collectionViewDraggingImageForItemsAtIndexesWithEventOffset?(_: NSCollectionView, draggingImageForItemsAt: NSIndexSet, with_: NSEvent, offset: NSPoint): NSImage;
    // instance method
    collectionViewPasteboardWriterForItemAtIndexPath?(_: NSCollectionView, pasteboardWriterForItemAt: NSIndexPath): NSPasteboardWriting;
    // instance method
    collectionViewPasteboardWriterForItemAtIndex?(_: NSCollectionView, pasteboardWriterForItemAt: number): NSPasteboardWriting;
    // instance method
    collectionViewDraggingSessionWillBeginAtForItemsAt?(_: NSCollectionView, draggingSession: NSDraggingSession, willBeginAt: CGPoint, forItemsAt: NSSet<IndexPath>): void;
    // instance method
    collectionViewDraggingSessionWillBeginAtPointForItemsAtIndexes?(_: NSCollectionView, draggingSession: NSDraggingSession, willBeginAt: CGPoint, forItemsAt: NSIndexSet): void;
    // instance method
    collectionViewDraggingSessionEndedAtPointDragOperation?(_: NSCollectionView, draggingSession: NSDraggingSession, endedAt: CGPoint, dragOperation: NSDragOperation): void;
    // instance method
    collectionViewShouldChangeItemsAtTo?(_: NSCollectionView, shouldChangeItemsAt: NSSet<IndexPath>, to: NSCollectionViewItem.HighlightState): NSSet<IndexPath>;
    // instance method
    collectionViewDidChangeItemsAtTo?(_: NSCollectionView, didChangeItemsAt: NSSet<IndexPath>, to: NSCollectionViewItem.HighlightState): void;
    // instance method
    collectionViewShouldSelectItemsAt?(_: NSCollectionView, shouldSelectItemsAt: NSSet<IndexPath>): NSSet<IndexPath>;
    // instance method
    collectionViewShouldDeselectItemsAt?(_: NSCollectionView, shouldDeselectItemsAt: NSSet<IndexPath>): NSSet<IndexPath>;
    // instance method
    collectionViewDidSelectItemsAt?(_: NSCollectionView, didSelectItemsAt: NSSet<IndexPath>): void;
    // instance method
    collectionViewDidDeselectItemsAt?(_: NSCollectionView, didDeselectItemsAt: NSSet<IndexPath>): void;
    // instance method
    collectionViewWillDisplayItemForRepresentedObjectAtIndexPath?(_: NSCollectionView, willDisplay: NSCollectionViewItem, forRepresentedObjectAt: NSIndexPath): void;
    // instance method
    collectionViewWillDisplaySupplementaryViewForElementKindAtIndexPath?(_: NSCollectionView, willDisplaySupplementaryView: NSView, forElementKind: string, at: NSIndexPath): void;
    // instance method
    collectionViewDidEndDisplayingItemForRepresentedObjectAtIndexPath?(_: NSCollectionView, didEndDisplaying: NSCollectionViewItem, forRepresentedObjectAt: NSIndexPath): void;
    // instance method
    collectionViewDidEndDisplayingSupplementaryViewForElementOfKindAtIndexPath?(_: NSCollectionView, didEndDisplayingSupplementaryView: NSView, forElementOfKind: string, at: NSIndexPath): void;
    // instance method
    collectionViewAcceptDropIndexDropOperation?(_: NSCollectionView, acceptDrop: NSDraggingInfo, index: number, dropOperation: NSCollectionView.DropOperation): boolean;
    // instance method
    collectionViewAcceptDropIndexPathDropOperation?(_: NSCollectionView, acceptDrop: NSDraggingInfo, indexPath: NSIndexPath, dropOperation: NSCollectionView.DropOperation): boolean;
    // instance method
    collectionViewTransitionLayoutForOldLayoutNewLayout?(_: NSCollectionView, transitionLayoutForOldLayout: NSCollectionViewLayout, newLayout: NSCollectionViewLayout): NSCollectionViewTransitionLayout;
    // instance method
    collectionViewUpdateDraggingItemsForDrag?(_: NSCollectionView, updateDraggingItemsForDrag: NSDraggingInfo): void;
    // instance method
    collectionViewValidateDropProposedIndexDropOperation?(_: NSCollectionView, validateDrop: NSDraggingInfo, proposedIndex: number, dropOperation: NSCollectionView.DropOperation): NSDragOperation;
    // instance method
    collectionViewValidateDropProposedIndexPathDropOperation?(_: NSCollectionView, validateDrop: NSDraggingInfo, proposedIndexPath: IndexPath, dropOperation: NSCollectionView.DropOperation): NSDragOperation;
  }

  interface NSCollectionViewDelegateFlowLayout extends NSCollectionViewDelegate {
    // instance method
    collectionViewLayoutSizeForItemAtIndexPath?(_: NSCollectionView, layout: NSCollectionViewLayout, sizeForItemAt: NSIndexPath): CGSize;
    // instance method
    collectionViewLayoutInsetForSectionAtIndex?(_: NSCollectionView, layout: NSCollectionViewLayout, insetForSectionAt: number): NSEdgeInsets;
    // instance method
    collectionViewLayoutMinimumLineSpacingForSectionAtIndex?(_: NSCollectionView, layout: NSCollectionViewLayout, minimumLineSpacingForSectionAt: number): number;
    // instance method
    collectionViewLayoutMinimumInteritemSpacingForSectionAtIndex?(_: NSCollectionView, layout: NSCollectionViewLayout, minimumInteritemSpacingForSectionAt: number): number;
    // instance method
    collectionViewLayoutReferenceSizeForFooterInSection?(_: NSCollectionView, layout: NSCollectionViewLayout, referenceSizeForFooterInSection: number): CGSize;
    // instance method
    collectionViewLayoutReferenceSizeForHeaderInSection?(_: NSCollectionView, layout: NSCollectionViewLayout, referenceSizeForHeaderInSection: number): CGSize;
  }

  // interface
  class NSCollectionViewDiffableDataSourceReference<SectionIdentifierType, ItemIdentifierType> extends NSObject /* implements NSCollectionViewDataSource */ {
    supplementaryViewProvider: (p1: NSCollectionView, p2: string, p3: NSIndexPath) => NSView;
    setSupplementaryViewProvider(_: (p1: NSCollectionView, p2: string, p3: NSIndexPath) => NSView)
    applySnapshotWithAnimatingDifferences(_: NSDiffableDataSourceSnapshotReference<SectionIdentifierType, ItemIdentifierType>, animatingDifferences: boolean): void;
    indexPathForItemIdentifier(_: ItemIdentifierType): NSIndexPath;
    itemIdentifierForIndexPath(_: NSIndexPath): ItemIdentifierType;
    snapshot(): NSDiffableDataSourceSnapshotReference<SectionIdentifierType, ItemIdentifierType>;
  }

  interface NSCollectionViewElement extends NSObject, NSUserInterfaceItemIdentification {
    // instance method
    applyLayoutAttributes?(_: NSCollectionViewLayoutAttributes): void;
    // instance method
    didTransitionFromLayoutToLayout?(from: NSCollectionViewLayout, to: NSCollectionViewLayout): void;
    // instance method
    preferredLayoutAttributesFittingAttributes?(_: NSCollectionViewLayoutAttributes): NSCollectionViewLayoutAttributes;
    // instance method
    prepareForReuse?(): void;
    // instance method
    willTransitionFromLayoutToLayout?(from: NSCollectionViewLayout, to: NSCollectionViewLayout): void;
  }

  // interface
  class NSCollectionViewFlowLayout extends NSCollectionViewLayout {
    estimatedItemSize: CGSize;
    setEstimatedItemSize(_: CGSize)
    footerReferenceSize: CGSize;
    setFooterReferenceSize(_: CGSize)
    headerReferenceSize: CGSize;
    setHeaderReferenceSize(_: CGSize)
    itemSize: CGSize;
    setItemSize(_: CGSize)
    minimumInteritemSpacing: number;
    setMinimumInteritemSpacing(_: number)
    minimumLineSpacing: number;
    setMinimumLineSpacing(_: number)
    scrollDirection: NSCollectionView.ScrollDirection;
    setScrollDirection(_: NSCollectionView.ScrollDirection)
    sectionFootersPinToVisibleBounds: boolean;
    setSectionFootersPinToVisibleBounds(_: boolean)
    sectionHeadersPinToVisibleBounds: boolean;
    setSectionHeadersPinToVisibleBounds(_: boolean)
    sectionInset: NSEdgeInsets;
    setSectionInset(_: NSEdgeInsets)
    collapseSectionAtIndex(at: number): void;
    expandSectionAtIndex(at: number): void;
    sectionAtIndexIsCollapsed(atIndexIsCollapsed: number): boolean;
  }

  // interface
  class NSCollectionViewFlowLayoutInvalidationContext extends NSCollectionViewLayoutInvalidationContext {
    invalidateFlowLayoutAttributes: boolean;
    setInvalidateFlowLayoutAttributes(_: boolean)
    invalidateFlowLayoutDelegateMetrics: boolean;
    setInvalidateFlowLayoutDelegateMetrics(_: boolean)
  }

  // interface
  class NSCollectionViewGridLayout extends NSCollectionViewLayout {
    backgroundColors: NSColor[];
    setBackgroundColors(_: NSColor[])
    margins: NSEdgeInsets;
    setMargins(_: NSEdgeInsets)
    maximumItemSize: CGSize;
    setMaximumItemSize(_: CGSize)
    maximumNumberOfColumns: number;
    setMaximumNumberOfColumns(_: number)
    maximumNumberOfRows: number;
    setMaximumNumberOfRows(_: number)
    minimumInteritemSpacing: number;
    setMinimumInteritemSpacing(_: number)
    minimumItemSize: CGSize;
    setMinimumItemSize(_: CGSize)
    minimumLineSpacing: number;
    setMinimumLineSpacing(_: number)
  }

  // interface
  class NSCollectionViewItem extends NSViewController /* implements NSCollectionViewElement, NSCopying */ {
    collectionView: NSCollectionView;
    draggingImageComponents: NSDraggingImageComponent[];
    highlightState: NSCollectionViewItem.HighlightState;
    setHighlightState(_: NSCollectionViewItem.HighlightState)
    imageView: NSImageView;
    setImageView(_: NSImageView)
    isSelected: boolean;
    setSelected(_: boolean)
    textField: NSTextField;
    setTextField(_: NSTextField)
  }

  // interface
  class NSCollectionViewLayout extends NSObject /* implements NSCoding */ {
    collectionView: NSCollectionView;
    collectionViewContentSize: CGSize;
    static invalidationContextClass: typeof NSObject;
    static layoutAttributesClass: typeof NSObject;
    finalLayoutAttributesForDisappearingDecorationElementOfKindAtIndexPath(ofKind: string, at: NSIndexPath): NSCollectionViewLayoutAttributes;
    finalLayoutAttributesForDisappearingItemAtIndexPath(at: NSIndexPath): NSCollectionViewLayoutAttributes;
    finalLayoutAttributesForDisappearingSupplementaryElementOfKindAtIndexPath(ofKind: string, at: NSIndexPath): NSCollectionViewLayoutAttributes;
    finalizeAnimatedBoundsChange(): void;
    finalizeCollectionViewUpdates(): void;
    finalizeLayoutTransition(): void;
    indexPathsToDeleteForDecorationViewOfKind(ofKind: string): NSSet<IndexPath>;
    indexPathsToDeleteForSupplementaryViewOfKind(ofKind: string): NSSet<IndexPath>;
    indexPathsToInsertForDecorationViewOfKind(ofKind: string): NSSet<IndexPath>;
    indexPathsToInsertForSupplementaryViewOfKind(ofKind: string): NSSet<IndexPath>;
    initialLayoutAttributesForAppearingDecorationElementOfKindAtIndexPath(ofKind: string, at: NSIndexPath): NSCollectionViewLayoutAttributes;
    initialLayoutAttributesForAppearingItemAtIndexPath(at: NSIndexPath): NSCollectionViewLayoutAttributes;
    initialLayoutAttributesForAppearingSupplementaryElementOfKindAtIndexPath(ofKind: string, at: NSIndexPath): NSCollectionViewLayoutAttributes;
    invalidateLayout(): void;
    invalidateLayoutWithContext(with_: NSCollectionViewLayoutInvalidationContext): void;
    invalidationContextForBoundsChange(forBoundsChange: CGRect): NSCollectionViewLayoutInvalidationContext;
    invalidationContextForPreferredLayoutAttributesWithOriginalAttributes(forPreferredLayoutAttributes: NSCollectionViewLayoutAttributes, withOriginalAttributes: NSCollectionViewLayoutAttributes): NSCollectionViewLayoutInvalidationContext;
    layoutAttributesForDecorationViewOfKindAtIndexPath(ofKind: string, at: NSIndexPath): NSCollectionViewLayoutAttributes;
    layoutAttributesForDropTargetAtPoint(at: CGPoint): NSCollectionViewLayoutAttributes;
    layoutAttributesForElementsInRect(in_: CGRect): NSCollectionViewLayoutAttributes[];
    layoutAttributesForInterItemGapBeforeIndexPath(before: NSIndexPath): NSCollectionViewLayoutAttributes;
    layoutAttributesForItemAtIndexPath(at: NSIndexPath): NSCollectionViewLayoutAttributes;
    layoutAttributesForSupplementaryViewOfKindAtIndexPath(ofKind: string, at: NSIndexPath): NSCollectionViewLayoutAttributes;
    prepareForAnimatedBoundsChange(forAnimatedBoundsChange: CGRect): void;
    prepareForCollectionViewUpdates(forCollectionViewUpdates: NSCollectionViewUpdateItem[]): void;
    prepareForTransitionFromLayout(from: NSCollectionViewLayout): void;
    prepareForTransitionToLayout(to: NSCollectionViewLayout): void;
    prepareLayout(): void;
    registerClassForDecorationViewOfKind(_?: typeof NSObject, forDecorationViewOfKind?: string): void;
    registerNibForDecorationViewOfKind(_?: NSNib, forDecorationViewOfKind?: string): void;
    shouldInvalidateLayoutForBoundsChange(forBoundsChange: CGRect): boolean;
    shouldInvalidateLayoutForPreferredLayoutAttributesWithOriginalAttributes(forPreferredLayoutAttributes: NSCollectionViewLayoutAttributes, withOriginalAttributes: NSCollectionViewLayoutAttributes): boolean;
    targetContentOffsetForProposedContentOffset(forProposedContentOffset: CGPoint): CGPoint;
    targetContentOffsetForProposedContentOffsetWithScrollingVelocity(forProposedContentOffset: CGPoint, withScrollingVelocity: CGPoint): CGPoint;
  }

  // interface
  class NSCollectionViewLayoutAttributes extends NSObject /* implements NSCopying */ {
    static layoutAttributesForDecorationViewOfKindWithIndexPath(forDecorationViewOfKind: string, with_: NSIndexPath): NSCollectionViewLayoutAttributes;
    static layoutAttributesForInterItemGapBeforeIndexPath(forInterItemGapBefore: NSIndexPath): NSCollectionViewLayoutAttributes;
    static layoutAttributesForItemWithIndexPath(forItemWith: NSIndexPath): NSCollectionViewLayoutAttributes;
    static layoutAttributesForSupplementaryViewOfKindWithIndexPath(forSupplementaryViewOfKind: string, with_: NSIndexPath): NSCollectionViewLayoutAttributes;
    alpha: number;
    setAlpha(_: number)
    frame: CGRect;
    setFrame(_: CGRect)
    isHidden: boolean;
    setHidden(_: boolean)
    indexPath: NSIndexPath;
    setIndexPath(_: NSIndexPath)
    representedElementCategory: NSCollectionElementCategory;
    representedElementKind: string;
    size: CGSize;
    setSize(_: CGSize)
    zIndex: number;
    setZIndex(_: number)
  }

  // interface
  class NSCollectionViewLayoutInvalidationContext extends NSObject {
    contentOffsetAdjustment: CGPoint;
    setContentOffsetAdjustment(_: CGPoint)
    contentSizeAdjustment: CGSize;
    setContentSizeAdjustment(_: CGSize)
    invalidateDataSourceCounts: boolean;
    invalidateEverything: boolean;
    invalidatedDecorationIndexPaths: Map<string, NSSet<IndexPath>>;
    invalidatedItemIndexPaths: NSSet<IndexPath>;
    invalidatedSupplementaryIndexPaths: Map<string, NSSet<IndexPath>>;
    invalidateDecorationElementsWithOfKindAt(ofKind: string, at: NSSet<IndexPath>): void;
    invalidateItemsWithAt(at: NSSet<IndexPath>): void;
    invalidateSupplementaryElementsWithOfKindAt(ofKind: string, at: NSSet<IndexPath>): void;
  }

  interface NSCollectionViewPrefetching extends NSObject {
    // instance method
    collectionViewPrefetchItemsAtIndexPaths(_: NSCollectionView, prefetchItemsAt: NSIndexPath[]): void;
    // instance method
    collectionViewCancelPrefetchingForItemsAtIndexPaths?(_: NSCollectionView, cancelPrefetchingForItemsAt: NSIndexPath[]): void;
  }

  interface NSCollectionViewSectionHeaderView extends NSCollectionViewElement {
    sectionCollapseButton?: NSButton;
    setSectionCollapseButton(_: NSButton)
  }

  // interface
  class NSCollectionViewTransitionLayout extends NSCollectionViewLayout {
    currentLayout: NSCollectionViewLayout;
    nextLayout: NSCollectionViewLayout;
    transitionProgress: number;
    setTransitionProgress(_: number)
    static createWithCurrentLayoutNextLayout(currentLayout: NSCollectionViewLayout, nextLayout: NSCollectionViewLayout): NSCollectionViewTransitionLayout;
    updateValueForAnimatedKey(_: number, forAnimatedKey: string): void;
    valueForAnimatedKey(forAnimatedKey: string): number;
  }

  // interface
  class NSCollectionViewUpdateItem extends NSObject {
    indexPathAfterUpdate: NSIndexPath;
    indexPathBeforeUpdate: NSIndexPath;
    updateAction: NSCollectionView.UpdateAction;
  }

  // interface
  class NSColor extends NSObject /* implements NSCopying, NSPasteboardReading, NSPasteboardWriting, NSSecureCoding */ {
    CGColor: any;
    alphaComponent: number;
    blackComponent: number;
    blueComponent: number;
    brightnessComponent: number;
    catalogNameComponent: string;
    colorNameComponent: string;
    colorSpace: NSColorSpace;
    cyanComponent: number;
    greenComponent: number;
    hueComponent: number;
    localizedCatalogNameComponent: string;
    localizedColorNameComponent: string;
    magentaComponent: number;
    numberOfComponents: number;
    patternImage: NSImage;
    redComponent: number;
    saturationComponent: number;
    type: NSColor.ColorType;
    whiteComponent: number;
    yellowComponent: number;
    static alternateSelectedControlTextColor: NSColor;
    static alternatingContentBackgroundColors: NSColor[];
    static blackColor: NSColor;
    static blueColor: NSColor;
    static brownColor: NSColor;
    static clearColor: NSColor;
    static controlAccentColor: NSColor;
    static controlBackgroundColor: NSColor;
    static controlColor: NSColor;
    static controlTextColor: NSColor;
    static currentControlTint: NSControlTint;
    static cyanColor: NSColor;
    static darkGrayColor: NSColor;
    static disabledControlTextColor: NSColor;
    static findHighlightColor: NSColor;
    static grayColor: NSColor;
    static greenColor: NSColor;
    static gridColor: NSColor;
    static headerTextColor: NSColor;
    static highlightColor: NSColor;
    static ignoresAlpha: boolean;
    setIgnoresAlpha(_: boolean)
    static keyboardFocusIndicatorColor: NSColor;
    static labelColor: NSColor;
    static lightGrayColor: NSColor;
    static linkColor: NSColor;
    static magentaColor: NSColor;
    static orangeColor: NSColor;
    static placeholderTextColor: NSColor;
    static purpleColor: NSColor;
    static quaternaryLabelColor: NSColor;
    static redColor: NSColor;
    static scrubberTexturedBackgroundColor: NSColor;
    static secondaryLabelColor: NSColor;
    static selectedContentBackgroundColor: NSColor;
    static selectedControlColor: NSColor;
    static selectedControlTextColor: NSColor;
    static selectedMenuItemTextColor: NSColor;
    static selectedTextBackgroundColor: NSColor;
    static selectedTextColor: NSColor;
    static separatorColor: NSColor;
    static shadowColor: NSColor;
    static systemBlueColor: NSColor;
    static systemBrownColor: NSColor;
    static systemGrayColor: NSColor;
    static systemGreenColor: NSColor;
    static systemIndigoColor: NSColor;
    static systemOrangeColor: NSColor;
    static systemPinkColor: NSColor;
    static systemPurpleColor: NSColor;
    static systemRedColor: NSColor;
    static systemTealColor: NSColor;
    static systemYellowColor: NSColor;
    static tertiaryLabelColor: NSColor;
    static textBackgroundColor: NSColor;
    static textColor: NSColor;
    static underPageBackgroundColor: NSColor;
    static unemphasizedSelectedContentBackgroundColor: NSColor;
    static unemphasizedSelectedTextBackgroundColor: NSColor;
    static unemphasizedSelectedTextColor: NSColor;
    static whiteColor: NSColor;
    static windowBackgroundColor: NSColor;
    static windowFrameTextColor: NSColor;
    static yellowColor: NSColor;
    blendedColorWithFractionOfColor(withFraction: number, of: NSColor): NSColor;
    colorUsingColorSpace(_: NSColorSpace): NSColor;
    colorUsingType(_: NSColor.ColorType): NSColor;
    colorWithAlphaComponent(_: number): NSColor;
    colorWithSystemEffect(_: NSColor.SystemEffect): NSColor;
    drawSwatchInRect(in_: CGRect): void;
    getComponents(_: number): void;
    getCyanMagentaYellowBlackAlpha(_?: number, magenta?: number, yellow?: number, black?: number, alpha?: number): void;
    getHueSaturationBrightnessAlpha(_?: number, saturation?: number, brightness?: number, alpha?: number): void;
    getRedGreenBlueAlpha(_?: number, green?: number, blue?: number, alpha?: number): void;
    getWhiteAlpha(_?: number, alpha?: number): void;
    highlightWithLevel(withLevel: number): NSColor;
    set(): void;
    setFill(): void;
    setStroke(): void;
    shadowWithLevel(withLevel: number): NSColor;
    writeToPasteboard(to: NSPasteboard): void;
  }

  interface NSColorChanging extends NSObject {
    // instance method
    changeColor(_?: NSColorPanel): void;
  }

  // interface
  class NSColorList extends NSObject /* implements NSSecureCoding */ {
    allKeys: string[];
    isEditable: boolean;
    name: string;
    static availableColorLists: NSColorList[];
    colorWithKey(withKey: string): NSColor;
    static createWithName(name: string): NSColorList;
    static createWithNameFromFile(name: string, fromFile?: string): NSColorList;
    insertColorKeyAtIndex(_: NSColor, key: string, at: number): void;
    removeColorWithKey(withKey: string): void;
    removeFile(): void;
    setColorForKey(_: NSColor, forKey: string): void;
    writeToURLError(error?: NSURL): boolean;
  }

  // interface
  class NSColorPanel extends NSPanel {
    static dragColorWithEventFromView(_: NSColor, with_: NSEvent, from: NSView): boolean;
    static setPickerMask(_: NSColorPanel.Options): void;
    static setPickerMode(_: NSColorPanel.Mode): void;
    accessoryView: NSView;
    setAccessoryView(_: NSView)
    alpha: number;
    color: NSColor;
    setColor(_: NSColor)
    isContinuous: boolean;
    setContinuous(_: boolean)
    mode: NSColorPanel.Mode;
    setMode(_: NSColorPanel.Mode)
    showsAlpha: boolean;
    setShowsAlpha(_: boolean)
    static sharedColorPanel: NSColorPanel;
    static sharedColorPanelExists: boolean;
    attachColorList(_: NSColorList): void;
    detachColorList(_: NSColorList): void;
    setAction(_?: string): void;
    setTarget(_?: any): void;
  }

  // interface
  class NSColorPicker extends NSObject /* implements NSColorPickingDefault */ {
    buttonToolTip: string;
    colorPanel: NSColorPanel;
    minContentSize: CGSize;
    provideNewButtonImage: NSImage;
  }

  // interface
  class NSColorPickerTouchBarItem extends NSTouchBarItem {
    static colorPickerWithIdentifier(withIdentifier: string): NSColorPickerTouchBarItem;
    static colorPickerWithIdentifierButtonImage(withIdentifier: string, buttonImage: NSImage): NSColorPickerTouchBarItem;
    static strokeColorPickerWithIdentifier(withIdentifier: string): NSColorPickerTouchBarItem;
    static textColorPickerWithIdentifier(withIdentifier: string): NSColorPickerTouchBarItem;
    action: string;
    setAction(_: string)
    allowedColorSpaces: NSColorSpace[];
    setAllowedColorSpaces(_: NSColorSpace[])
    color: NSColor;
    setColor(_: NSColor)
    colorList: NSColorList;
    setColorList(_: NSColorList)
    isEnabled: boolean;
    setEnabled(_: boolean)
    showsAlpha: boolean;
    setShowsAlpha(_: boolean)
    target: any;
    setTarget(_: any)
  }

  interface NSColorPickingCustom extends NSColorPickingDefault {
    // instance method
    currentMode(): NSColorPanel.Mode;
    // instance method
    provideNewView(_: boolean): NSView;
    // instance method
    setColor(_: NSColor): void;
    // instance method
    supportsMode(_: NSColorPanel.Mode): boolean;
  }

  interface NSColorPickingDefault {
    provideNewButtonImage: NSImage;
    buttonToolTip: string;
    minContentSize: CGSize;
    // instance method
    alphaControlAddedOrRemoved(_?: any): void;
    // instance method
    attachColorList(_: NSColorList): void;
    // instance method
    detachColorList(_: NSColorList): void;
    // instance method
    insertNewButtonImageIn(_: NSImage, in_: NSButtonCell): void;
    // instance method
    setMode(_: NSColorPanel.Mode): void;
    // instance method
    viewSizeChanged(_?: any): void;
  }

  // interface
  class NSColorSampler extends NSObject {
    showWithSelectionHandler(selectionHandler?: (p1: NSColor) => void): void;
  }

  // interface
  class NSColorSpace extends NSObject /* implements NSSecureCoding */ {
    static availableColorSpacesWithModel(with_: NSColorSpace.Model): NSColorSpace[];
    CGColorSpace: any;
    ICCProfileData: NSData;
    colorSpaceModel: NSColorSpace.Model;
    colorSyncProfile: any;
    localizedName: string;
    numberOfColorComponents: number;
    static adobeRGB1998ColorSpace: NSColorSpace;
    static deviceCMYKColorSpace: NSColorSpace;
    static deviceGrayColorSpace: NSColorSpace;
    static deviceRGBColorSpace: NSColorSpace;
    static displayP3ColorSpace: NSColorSpace;
    static extendedGenericGamma22GrayColorSpace: NSColorSpace;
    static extendedSRGBColorSpace: NSColorSpace;
    static genericCMYKColorSpace: NSColorSpace;
    static genericGamma22GrayColorSpace: NSColorSpace;
    static genericGrayColorSpace: NSColorSpace;
    static genericRGBColorSpace: NSColorSpace;
    static sRGBColorSpace: NSColorSpace;
    static createWithCGColorSpace(CGColorSpace: any): NSColorSpace;
    static createWithColorSyncProfile(colorSyncProfile: any): NSColorSpace;
    static createWithICCProfileData(ICCProfileData: NSData): NSColorSpace;
  }

  // export function NSColorSpaceFromDepth(depth: NSWindow.Depth): string;

  // interface
  class NSColorWell extends NSControl {
    isActive: boolean;
    isBordered: boolean;
    setBordered(_: boolean)
    color: NSColor;
    setColor(_: NSColor)
    activate(_: boolean): void;
    deactivate(): void;
    drawWellInside(inside: CGRect): void;
    takeColorFrom(_?: any): void;
  }

  // interface
  class NSComboBox extends NSTextField {
    isButtonBordered: boolean;
    setButtonBordered(_: boolean)
    completes: boolean;
    setCompletes(_: boolean)
    dataSource: NSComboBoxDataSource;
    setDataSource(_: NSComboBoxDataSource)
    hasVerticalScroller: boolean;
    setHasVerticalScroller(_: boolean)
    indexOfSelectedItem: number;
    intercellSpacing: CGSize;
    setIntercellSpacing(_: CGSize)
    itemHeight: number;
    setItemHeight(_: number)
    numberOfItems: number;
    numberOfVisibleItems: number;
    setNumberOfVisibleItems(_: number)
    objectValueOfSelectedItem: any;
    objectValues: any[];
    usesDataSource: boolean;
    setUsesDataSource(_: boolean)
    addItemWithObjectValue(withObjectValue: any): void;
    addItemsWithObjectValues(withObjectValues: any[]): void;
    deselectItemAtIndex(at: number): void;
    indexOfItemWithObjectValue(withObjectValue: any): number;
    insertItemWithObjectValueAtIndex(withObjectValue: any, at: number): void;
    itemObjectValueAtIndex(at: number): any;
    noteNumberOfItemsChanged(): void;
    reloadData(): void;
    removeAllItems(): void;
    removeItemAtIndex(at: number): void;
    removeItemWithObjectValue(withObjectValue: any): void;
    scrollItemAtIndexToTop(_: number): void;
    scrollItemAtIndexToVisible(_: number): void;
    selectItemAtIndex(at: number): void;
    selectItemWithObjectValue(withObjectValue?: any): void;
  }

  // interface
  class NSComboBoxCell extends NSTextFieldCell {
    isButtonBordered: boolean;
    setButtonBordered(_: boolean)
    completes: boolean;
    setCompletes(_: boolean)
    dataSource: NSComboBoxCellDataSource;
    setDataSource(_: NSComboBoxCellDataSource)
    hasVerticalScroller: boolean;
    setHasVerticalScroller(_: boolean)
    indexOfSelectedItem: number;
    intercellSpacing: CGSize;
    setIntercellSpacing(_: CGSize)
    itemHeight: number;
    setItemHeight(_: number)
    numberOfItems: number;
    numberOfVisibleItems: number;
    setNumberOfVisibleItems(_: number)
    objectValueOfSelectedItem: any;
    objectValues: any[];
    usesDataSource: boolean;
    setUsesDataSource(_: boolean)
    addItemWithObjectValue(withObjectValue: any): void;
    addItemsWithObjectValues(withObjectValues: any[]): void;
    completedString(_: string): string;
    deselectItemAtIndex(at: number): void;
    indexOfItemWithObjectValue(withObjectValue: any): number;
    insertItemWithObjectValueAtIndex(withObjectValue: any, at: number): void;
    itemObjectValueAtIndex(at: number): any;
    noteNumberOfItemsChanged(): void;
    reloadData(): void;
    removeAllItems(): void;
    removeItemAtIndex(at: number): void;
    removeItemWithObjectValue(withObjectValue: any): void;
    scrollItemAtIndexToTop(_: number): void;
    scrollItemAtIndexToVisible(_: number): void;
    selectItemAtIndex(at: number): void;
    selectItemWithObjectValue(withObjectValue?: any): void;
  }

  interface NSComboBoxCellDataSource extends NSObject {
    // instance method
    comboBoxCellObjectValueForItemAtIndex?(_: NSComboBoxCell, objectValueForItemAt: number): any;
    // instance method
    comboBoxCellCompletedString?(_: NSComboBoxCell, completedString: string): string;
    // instance method
    comboBoxCellIndexOfItemWithStringValue?(_: NSComboBoxCell, indexOfItemWithStringValue: string): number;
    // instance method
    numberOfItemsInComboBoxCell?(in_: NSComboBoxCell): number;
  }

  interface NSComboBoxDataSource extends NSObject {
    // instance method
    comboBoxObjectValueForItemAtIndex?(_: NSComboBox, objectValueForItemAt: number): any;
    // instance method
    comboBoxCompletedString?(_: NSComboBox, completedString: string): string;
    // instance method
    comboBoxIndexOfItemWithStringValue?(_: NSComboBox, indexOfItemWithStringValue: string): number;
    // instance method
    numberOfItemsInComboBox?(in_: NSComboBox): number;
  }

  interface NSComboBoxDelegate extends NSTextFieldDelegate {
    // instance method
    comboBoxSelectionDidChange?(_: NSNotification): void;
    // instance method
    comboBoxSelectionIsChanging?(_: NSNotification): void;
    // instance method
    comboBoxWillDismiss?(_: NSNotification): void;
    // instance method
    comboBoxWillPopUp?(_: NSNotification): void;
  }

  // interface
  class NSControl extends NSView {
    action: string;
    setAction(_: string)
    alignment: NSTextAlignment;
    setAlignment(_: NSTextAlignment)
    allowsExpansionToolTips: boolean;
    setAllowsExpansionToolTips(_: boolean)
    attributedStringValue: NSAttributedString;
    setAttributedStringValue(_: NSAttributedString)
    baseWritingDirection: NSWritingDirection;
    setBaseWritingDirection(_: NSWritingDirection)
    cell: NSCell;
    setCell(_: NSCell)
    isContinuous: boolean;
    setContinuous(_: boolean)
    controlSize: NSControl.ControlSize;
    setControlSize(_: NSControl.ControlSize)
    doubleValue: number;
    setDoubleValue(_: number)
    isEnabled: boolean;
    setEnabled(_: boolean)
    floatValue: number;
    setFloatValue(_: number)
    font: NSFont;
    setFont(_: NSFont)
    formatter: Formatter;
    setFormatter(_: Formatter)
    isHighlighted: boolean;
    setHighlighted(_: boolean)
    ignoresMultiClick: boolean;
    setIgnoresMultiClick(_: boolean)
    intValue: number;
    setIntValue(_: number)
    integerValue: number;
    setIntegerValue(_: number)
    lineBreakMode: NSLineBreakMode;
    setLineBreakMode(_: NSLineBreakMode)
    objectValue: any;
    setObjectValue(_: any)
    refusesFirstResponder: boolean;
    setRefusesFirstResponder(_: boolean)
    stringValue: string;
    setStringValue(_: string)
    target: any;
    setTarget(_: any)
    usesSingleLineMode: boolean;
    setUsesSingleLineMode(_: boolean)
    static cellClass: typeof NSObject;
    setCellClass(_: typeof NSObject)
    abortEditing(): boolean;
    currentEditor(): NSText;
    drawCell(_: NSCell): void;
    drawCellInside(_: NSCell): void;
    drawWithExpansionFrameInView(withExpansionFrame: CGRect, in_: NSView): void;
    editWithFrameEditorDelegateEvent(withFrame: CGRect, editor: NSText, delegate?: any, event?: NSEvent): void;
    endEditing(_: NSText): void;
    expansionFrameWithFrame(withFrame: CGRect): CGRect;
    invalidateIntrinsicContentSizeForCell(for_: NSCell): void;
    performClick(_?: any): void;
    selectCell(_: NSCell): void;
    selectWithFrameEditorDelegateStartLength(withFrame: CGRect, editor: NSText, delegate?: any, start?: number, length?: number): void;
    selectedCell(): NSCell;
    selectedTag(): number;
    sendActionTo(_?: string, to?: any): boolean;
    sendActionOn(on: NSEvent.EventTypeMask): number;
    sizeThatFits(_: CGSize): CGSize;
    sizeToFit(): void;
    takeDoubleValueFrom(_?: any): void;
    takeFloatValueFrom(_?: any): void;
    takeIntValueFrom(_?: any): void;
    takeIntegerValueFrom(_?: any): void;
    takeObjectValueFrom(_?: any): void;
    takeStringValueFrom(_?: any): void;
    updateCell(_: NSCell): void;
    updateCellInside(_: NSCell): void;
    validateEditing(): void;
  }

  interface NSControlTextEditingDelegate extends NSObject {
    // instance method
    controlTextViewDoCommandBySelector?(_: NSControl, textView: NSTextView, doCommandBy: string): boolean;
    // instance method
    controlDidFailToFormatStringErrorDescription?(_: NSControl, didFailToFormatString: string, errorDescription?: string): boolean;
    // instance method
    controlDidFailToValidatePartialStringErrorDescription?(_: NSControl, didFailToValidatePartialString: string, errorDescription?: string): void;
    // instance method
    controlIsValidObject?(_: NSControl, isValidObject?: any): boolean;
    // instance method
    controlTextShouldBeginEditing?(_: NSControl, textShouldBeginEditing: NSText): boolean;
    // instance method
    controlTextShouldEndEditing?(_: NSControl, textShouldEndEditing: NSText): boolean;
    // instance method
    controlTextViewCompletionsForPartialWordRangeIndexOfSelectedItem?(_: NSControl, textView: NSTextView, completions: string[], forPartialWordRange: NSRange, indexOfSelectedItem: number): string[];
    // instance method
    controlTextDidBeginEditing?(_: NSNotification): void;
    // instance method
    controlTextDidChange?(_: NSNotification): void;
    // instance method
    controlTextDidEndEditing?(_: NSNotification): void;
  }

  // interface
  class NSController extends NSObject /* implements NSCoding, NSEditor, NSEditorRegistration */ {
    isEditing: boolean;
  }

  // export function NSCreateFileContentsPboardType(fileType: string): string;

  // export function NSCreateFilenamePboardType(fileType: string): string;

  // interface
  class NSCursor extends NSObject /* implements NSCoding */ {
    static hide(): void;
    static pop(): void;
    static setHiddenUntilMouseMoves(_: boolean): void;
    static unhide(): void;
    hotSpot: CGPoint;
    image: NSImage;
    static IBeamCursor: NSCursor;
    static IBeamCursorForVerticalLayout: NSCursor;
    static arrowCursor: NSCursor;
    static closedHandCursor: NSCursor;
    static contextualMenuCursor: NSCursor;
    static crosshairCursor: NSCursor;
    static currentCursor: NSCursor;
    static currentSystemCursor: NSCursor;
    static disappearingItemCursor: NSCursor;
    static dragCopyCursor: NSCursor;
    static dragLinkCursor: NSCursor;
    static openHandCursor: NSCursor;
    static operationNotAllowedCursor: NSCursor;
    static pointingHandCursor: NSCursor;
    static resizeDownCursor: NSCursor;
    static resizeLeftCursor: NSCursor;
    static resizeLeftRightCursor: NSCursor;
    static resizeRightCursor: NSCursor;
    static resizeUpCursor: NSCursor;
    static resizeUpDownCursor: NSCursor;
    static createWithImageHotSpot(image: NSImage, hotSpot: CGPoint): NSCursor;
    pop(): void;
    push(): void;
    set(): void;
  }

  // interface
  class NSCustomImageRep extends NSImageRep {
    delegate: any;
    drawSelector: string;
    drawingHandler: (p1: CGRect) => boolean;
    static createWithDrawSelectorDelegate(drawSelector: string, delegate: any): NSCustomImageRep;
    static createWithSizeFlippedDrawingHandler(size: CGSize, flipped: boolean, drawingHandler: (p1: CGRect) => boolean): NSCustomImageRep;
  }

  // interface
  class NSCustomTouchBarItem extends NSTouchBarItem {
  }

  // interface
  class NSDataAsset extends NSObject /* implements NSCopying */ {
    data: NSData;
    name: string;
    typeIdentifier: string;
    static createWithName(name: string): NSDataAsset;
    static createWithNameBundle(name: string, bundle: Bundle): NSDataAsset;
  }

  // interface
  class NSDatePicker extends NSControl {
    backgroundColor: NSColor;
    setBackgroundColor(_: NSColor)
    isBezeled: boolean;
    setBezeled(_: boolean)
    isBordered: boolean;
    setBordered(_: boolean)
    calendar: NSCalendar;
    setCalendar(_: NSCalendar)
    datePickerElements: NSDatePicker.ElementFlags;
    setDatePickerElements(_: NSDatePicker.ElementFlags)
    datePickerMode: NSDatePicker.Mode;
    setDatePickerMode(_: NSDatePicker.Mode)
    datePickerStyle: NSDatePicker.Style;
    setDatePickerStyle(_: NSDatePicker.Style)
    dateValue: Date;
    setDateValue(_: Date)
    delegate: NSDatePickerCellDelegate;
    setDelegate(_: NSDatePickerCellDelegate)
    drawsBackground: boolean;
    setDrawsBackground(_: boolean)
    locale: NSLocale;
    setLocale(_: NSLocale)
    maxDate: Date;
    setMaxDate(_: Date)
    minDate: Date;
    setMinDate(_: Date)
    presentsCalendarOverlay: boolean;
    setPresentsCalendarOverlay(_: boolean)
    textColor: NSColor;
    setTextColor(_: NSColor)
    timeInterval: number;
    setTimeInterval(_: number)
    timeZone: NSTimeZone;
    setTimeZone(_: NSTimeZone)
  }

  // interface
  class NSDatePickerCell extends NSActionCell {
    backgroundColor: NSColor;
    setBackgroundColor(_: NSColor)
    calendar: NSCalendar;
    setCalendar(_: NSCalendar)
    datePickerElements: NSDatePicker.ElementFlags;
    setDatePickerElements(_: NSDatePicker.ElementFlags)
    datePickerMode: NSDatePicker.Mode;
    setDatePickerMode(_: NSDatePicker.Mode)
    datePickerStyle: NSDatePicker.Style;
    setDatePickerStyle(_: NSDatePicker.Style)
    dateValue: Date;
    setDateValue(_: Date)
    delegate: NSDatePickerCellDelegate;
    setDelegate(_: NSDatePickerCellDelegate)
    drawsBackground: boolean;
    setDrawsBackground(_: boolean)
    locale: NSLocale;
    setLocale(_: NSLocale)
    maxDate: Date;
    setMaxDate(_: Date)
    minDate: Date;
    setMinDate(_: Date)
    textColor: NSColor;
    setTextColor(_: NSColor)
    timeInterval: number;
    setTimeInterval(_: number)
    timeZone: NSTimeZone;
    setTimeZone(_: NSTimeZone)
  }

  interface NSDatePickerCellDelegate extends NSObject {
    // instance method
    datePickerCellValidateProposedDateValueTimeInterval?(_: NSDatePickerCell, validateProposedDateValue: Date, timeInterval?: number): void;
  }

  // interface
  class NSDictionaryController extends NSArrayController {
    excludedKeys: string[];
    setExcludedKeys(_: string[])
    includedKeys: string[];
    setIncludedKeys(_: string[])
    initialKey: string;
    setInitialKey(_: string)
    initialValue: any;
    setInitialValue(_: any)
    localizedKeyDictionary: Map<string, string>;
    setLocalizedKeyDictionary(_: Map<string, string>)
    localizedKeyTable: string;
    setLocalizedKeyTable(_: string)
  }

  // interface
  class NSDictionaryControllerKeyValuePair extends NSObject {
    isExplicitlyIncluded: boolean;
    key: string;
    setKey(_: string)
    localizedKey: string;
    setLocalizedKey(_: string)
    value: any;
    setValue(_: any)
  }

  // interface
  class NSDiffableDataSourceSnapshotReference<SectionIdentifierType, ItemIdentifierType> extends NSObject /* implements NSCopying */ {
    itemIdentifiers: ItemIdentifierType[];
    numberOfItems: number;
    numberOfSections: number;
    sectionIdentifiers: SectionIdentifierType[];
    appendItemsWithIdentifiers(_: ItemIdentifierType[]): void;
    appendItemsWithIdentifiersIntoSectionWithIdentifier(_: ItemIdentifierType[], intoSectionWithIdentifier: SectionIdentifierType): void;
    appendSectionsWithIdentifiers(_: any[]): void;
    deleteAllItems(): void;
    deleteItemsWithIdentifiers(_: ItemIdentifierType[]): void;
    deleteSectionsWithIdentifiers(_: SectionIdentifierType[]): void;
    indexOfItemIdentifier(_: ItemIdentifierType): number;
    indexOfSectionIdentifier(_: SectionIdentifierType): number;
    insertItemsWithIdentifiersAfterItemWithIdentifier(_: ItemIdentifierType[], afterItemWithIdentifier: ItemIdentifierType): void;
    insertItemsWithIdentifiersBeforeItemWithIdentifier(_: ItemIdentifierType[], beforeItemWithIdentifier: ItemIdentifierType): void;
    insertSectionsWithIdentifiersAfterSectionWithIdentifier(_: SectionIdentifierType[], afterSectionWithIdentifier: SectionIdentifierType): void;
    insertSectionsWithIdentifiersBeforeSectionWithIdentifier(_: SectionIdentifierType[], beforeSectionWithIdentifier: SectionIdentifierType): void;
    itemIdentifiersInSectionWithIdentifier(_: SectionIdentifierType): ItemIdentifierType[];
    moveItemWithIdentifierAfterItemWithIdentifier(_: ItemIdentifierType, afterItemWithIdentifier: ItemIdentifierType): void;
    moveItemWithIdentifierBeforeItemWithIdentifier(_: ItemIdentifierType, beforeItemWithIdentifier: ItemIdentifierType): void;
    moveSectionWithIdentifierAfterSectionWithIdentifier(_: SectionIdentifierType, afterSectionWithIdentifier: SectionIdentifierType): void;
    moveSectionWithIdentifierBeforeSectionWithIdentifier(_: SectionIdentifierType, beforeSectionWithIdentifier: SectionIdentifierType): void;
    numberOfItemsInSection(_: SectionIdentifierType): number;
    reloadItemsWithIdentifiers(_: ItemIdentifierType[]): void;
    reloadSectionsWithIdentifiers(_: SectionIdentifierType[]): void;
    sectionIdentifierForSectionContainingItemIdentifier(_: ItemIdentifierType): SectionIdentifierType;
  }

  // interface
  class NSDockTile extends NSObject {
    badgeLabel: string;
    setBadgeLabel(_: string)
    contentView: NSView;
    setContentView(_: NSView)
    owner: any;
    showsApplicationBadge: boolean;
    setShowsApplicationBadge(_: boolean)
    size: CGSize;
    display(): void;
  }

  interface NSDockTilePlugIn extends NSObject {
    // instance method
    dockMenu?(): NSMenu;
    // instance method
    setDockTile(_?: NSDockTile): void;
  }

  // interface
  class NSDocument extends NSObject /* implements NSEditorRegistration, NSFilePresenter, NSMenuItemValidation, NSUserInterfaceValidations, NSUserActivityRestoring */ {
    static canConcurrentlyReadDocumentsOfType(ofType: string): boolean;
    static isNativeType(_: string): boolean;
    PDFPrintOperation: NSPrintOperation;
    allowsDocumentSharing: boolean;
    autosavedContentsFileURL: NSURL;
    setAutosavedContentsFileURL(_: NSURL)
    autosavingFileType: string;
    autosavingIsImplicitlyCancellable: boolean;
    backupFileURL: NSURL;
    isBrowsingVersions: boolean;
    displayName: string;
    setDisplayName(_: string)
    isDocumentEdited: boolean;
    isDraft: boolean;
    setDraft(_: boolean)
    isEntireFileLoaded: boolean;
    fileModificationDate: Date;
    setFileModificationDate(_: Date)
    fileNameExtensionWasHiddenInLastRunSavePanel: boolean;
    fileType: string;
    setFileType(_: string)
    fileTypeFromLastRunSavePanel: string;
    fileURL: NSURL;
    setFileURL(_: NSURL)
    hasUnautosavedChanges: boolean;
    hasUndoManager: boolean;
    setHasUndoManager(_: boolean)
    isInViewingMode: boolean;
    keepBackupFile: boolean;
    lastComponentOfFileName: string;
    setLastComponentOfFileName(_: string)
    isLocked: boolean;
    printInfo: NSPrintInfo;
    setPrintInfo(_: NSPrintInfo)
    shouldRunSavePanelWithAccessoryView: boolean;
    undoManager: UndoManager;
    setUndoManager(_: UndoManager)
    userActivity: NSUserActivity;
    setUserActivity(_: NSUserActivity)
    windowControllers: NSWindowController[];
    windowForSheet: NSWindow;
    windowNibName: string;
    static autosavesDrafts: boolean;
    static autosavesInPlace: boolean;
    static preservesVersions: boolean;
    static readableTypes: string[];
    static restorableStateKeyPaths: string[];
    static usesUbiquitousStorage: boolean;
    static writableTypes: string[];
    addWindowController(_: NSWindowController): void;
    autosaveDocumentWithDelegateDidAutosaveSelectorContextInfo(withDelegate?: any, didAutosave?: string, contextInfo?: any): void;
    autosaveWithWithImplicitCancellabilityCompletionHandler(withImplicitCancellability: boolean, completionHandler?: (p1: NSError) => void): void;
    browseDocumentVersions(_?: any): void;
    canAsynchronouslyWriteToURLOfTypeForSaveOperation(to: NSURL, ofType: string, for_: NSDocument.SaveOperationType): boolean;
    canCloseDocumentWithDelegateShouldCloseSelectorContextInfo(withDelegate: any, shouldClose?: string, contextInfo?: any): void;
    changeCountTokenForSaveOperation(for_: NSDocument.SaveOperationType): any;
    checkAutosavingSafetyAndReturnError(): boolean;
    close(): void;
    continueActivity(_: () => void): void;
    continueAsynchronousWorkOnMainThread(_: () => void): void;
    dataOfTypeError(error: string): NSData;
    defaultDraftName(): string;
    duplicateAndReturnError(): NSDocument;
    duplicateDocument(_?: any): void;
    duplicateDocumentWithDelegateDidDuplicateSelectorContextInfo(withDelegate?: any, didDuplicate?: string, contextInfo?: any): void;
    encodeRestorableStateWithCoder(with_: NSCoder): void;
    encodeRestorableStateWithCoderBackgroundQueue(with_: NSCoder, backgroundQueue: OperationQueue): void;
    fileAttributesToWriteToURLOfTypeForSaveOperationOriginalContentsURLError(ofType: NSURL, forSaveOperation: string, originalContentsURL: NSDocument.SaveOperationType, error?: NSURL): Map<string, any>;
    fileNameExtensionForTypeSaveOperation(forType: string, saveOperation: NSDocument.SaveOperationType): string;
    fileWrapperOfTypeError(error: string): FileWrapper;
    handleCloseScriptCommand(_: NSCloseCommand): any;
    handlePrintScriptCommand(_: NSScriptCommand): any;
    handleSaveScriptCommand(_: NSScriptCommand): any;
    static createWithForURLWithContentsOfURLOfType(forURL?: NSURL, withContentsOfURL?: NSURL, ofType?: string): NSDocument;
    static createWithContentsOfURLOfType(contentsOfURL: NSURL, ofType: string): NSDocument;
    static createWithType(type: string): NSDocument;
    invalidateRestorableState(): void;
    lockDocument(_?: any): void;
    lockWithCompletionHandler(completionHandler?: (p1: boolean) => void): void;
    lockWithCompletionHandler(completionHandler?: (p1: NSError) => void): void;
    makeWindowControllers(): void;
    moveDocument(_?: any): void;
    moveDocumentToUbiquityContainer(_?: any): void;
    moveWithCompletionHandler(completionHandler?: (p1: boolean) => void): void;
    moveWithToCompletionHandler(to: NSURL, completionHandler?: (p1: NSError) => void): void;
    performActivityWithWithSynchronousWaitingUsing(withSynchronousWaiting: boolean, using: (p1: () => void) => void): void;
    performAsynchronousFileAccess(_: (p1: () => void) => void): void;
    performSynchronousFileAccess(_: () => void): void;
    preparePageLayout(_: NSPageLayout): boolean;
    prepareSavePanel(_: NSSavePanel): boolean;
    prepareSharingServicePicker(_: NSSharingServicePicker): void;
    presentError(_: NSError): boolean;
    presentErrorModalForWindowDelegateDidPresentSelectorContextInfo(_: NSError, modalFor: NSWindow, delegate?: any, didPresent?: string, contextInfo?: any): void;
    printDocument(_?: any): void;
    printDocumentWithSettingsShowPrintPanelDelegateDidPrintSelectorContextInfo(withSettings: Map<string, any>, showPrintPanel: boolean, delegate?: any, didPrint?: string, contextInfo?: any): void;
    printOperationWithSettingsError(error: Map<string, any>): NSPrintOperation;
    readFromDataOfTypeError(ofType: NSData, error: string): boolean;
    readFromFileWrapperOfTypeError(ofType: FileWrapper, error: string): boolean;
    readFromURLOfTypeError(ofType: NSURL, error: string): boolean;
    removeWindowController(_: NSWindowController): void;
    renameDocument(_?: any): void;
    restoreWindowWithWithIdentifierStateCompletionHandler(withIdentifier: string, state: NSCoder, completionHandler?: (p1: NSWindow, p2: NSError) => void): void;
    restoreStateWithCoder(with_: NSCoder): void;
    revertDocumentToSaved(_?: any): void;
    revertToContentsOfURLOfTypeError(ofType: NSURL, error: string): boolean;
    runModalPageLayoutWithPrintInfoDelegateDidRunSelectorContextInfo(with_: NSPrintInfo, delegate?: any, didRun?: string, contextInfo?: any): void;
    runModalPrintOperationDelegateDidRunSelectorContextInfo(_: NSPrintOperation, delegate?: any, didRun?: string, contextInfo?: any): void;
    runModalSavePanelForSaveOperationDelegateDidSaveSelectorContextInfo(for_: NSDocument.SaveOperationType, delegate?: any, didSave?: string, contextInfo?: any): void;
    runPageLayout(_?: any): void;
    saveDocument(_?: any): void;
    saveDocumentAs(_?: any): void;
    saveDocumentTo(_?: any): void;
    saveDocumentToPDF(_?: any): void;
    saveDocumentWithDelegateDidSaveSelectorContextInfo(withDelegate?: any, didSave?: string, contextInfo?: any): void;
    saveWithToOfTypeForCompletionHandler(to: NSURL, ofType: string, for_: NSDocument.SaveOperationType, completionHandler?: (p1: NSError) => void): void;
    saveToURLOfTypeForSaveOperationDelegateDidSaveSelectorContextInfo(to: NSURL, ofType: string, for_: NSDocument.SaveOperationType, delegate?: any, didSave?: string, contextInfo?: any): void;
    scheduleAutosaving(): void;
    setDisplayName(_?: string): void;
    setWindow(_?: NSWindow): void;
    shareWithWithCompletionHandler(with_: NSSharingService, completionHandler?: (p1: boolean) => void): void;
    shouldChangePrintInfo(_: NSPrintInfo): boolean;
    shouldCloseWindowControllerDelegateShouldCloseSelectorContextInfo(_: NSWindowController, delegate?: any, shouldClose?: string, contextInfo?: any): void;
    showWindows(): void;
    stopBrowsingVersionsWithCompletionHandler(completionHandler?: () => void): void;
    unblockUserInteraction(): void;
    unlockDocument(_?: any): void;
    unlockWithCompletionHandler(completionHandler?: (p1: boolean) => void): void;
    unlockWithCompletionHandler(completionHandler?: (p1: NSError) => void): void;
    updateChangeCount(_: NSDocument.ChangeType): void;
    updateChangeCountWithTokenForSaveOperation(withToken: any, for_: NSDocument.SaveOperationType): void;
    updateUserActivityState(_: NSUserActivity): void;
    willNotPresentError(_: NSError): void;
    willPresentError(_: NSError): NSError;
    windowControllerDidLoadNib(_: NSWindowController): void;
    windowControllerWillLoadNib(_: NSWindowController): void;
    writableTypesForSaveOperation(for_: NSDocument.SaveOperationType): string[];
    writeSafelyToURLOfTypeForSaveOperationError(ofType: NSURL, forSaveOperation: string, error: NSDocument.SaveOperationType): boolean;
    writeToURLOfTypeError(ofType: NSURL, error: string): boolean;
    writeToURLOfTypeForSaveOperationOriginalContentsURLError(ofType: NSURL, forSaveOperation: string, originalContentsURL: NSDocument.SaveOperationType, error?: NSURL): boolean;
  }

  // interface
  class NSDocumentController extends NSObject /* implements NSCoding, NSMenuItemValidation, NSUserInterfaceValidations, NSWindowRestoration */ {
    allowsAutomaticShareMenu: boolean;
    autosavingDelay: number;
    setAutosavingDelay(_: number)
    currentDirectory: string;
    currentDocument: NSDocument;
    defaultType: string;
    documentClassNames: string[];
    documents: NSDocument[];
    hasEditedDocuments: boolean;
    maximumRecentDocumentCount: number;
    recentDocumentURLs: NSURL[];
    static sharedDocumentController: NSDocumentController;
    URLsFromRunningOpenPanel(): NSURL[];
    addDocument(_: NSDocument): void;
    beginOpenPanelForTypesCompletionHandler(_: NSOpenPanel, forTypes?: string[], completionHandler?: (p1: number) => void): void;
    beginOpenPanelWithCompletionHandler(completionHandler?: (p1: NSURL[]) => void): void;
    clearRecentDocuments(_?: any): void;
    closeAllDocumentsWithDelegateDidCloseAllSelectorContextInfo(withDelegate?: any, didCloseAllSelector?: string, contextInfo?: any): void;
    displayNameForType(forType: string): string;
    documentClassForType(forType: string): typeof NSObject;
    documentForURL(for_: NSURL): NSDocument;
    documentForWindow(for_: NSWindow): NSDocument;
    duplicateDocumentWithContentsOfURLCopyingDisplayNameError(copying: NSURL, displayName: boolean, error?: string): NSDocument;
    makeDocumentForURLWithContentsOfURLOfTypeError(withContentsOfURL?: NSURL, ofType?: NSURL, error?: string): NSDocument;
    makeDocumentWithContentsOfURLOfTypeError(ofType: NSURL, error: string): NSDocument;
    makeUntitledDocumentOfTypeError(error: string): NSDocument;
    newDocument(_?: any): void;
    noteNewRecentDocument(_: NSDocument): void;
    noteNewRecentDocumentURL(_: NSURL): void;
    openDocument(_?: any): void;
    openDocumentWithWithContentsOfDisplayCompletionHandler(withContentsOf: NSURL, display: boolean, completionHandler?: (p1: NSDocument, p2: boolean, p3: NSError) => void): void;
    openUntitledDocumentAndDisplayError(error: boolean): NSDocument;
    presentError(_: NSError): boolean;
    presentErrorModalForWindowDelegateDidPresentSelectorContextInfo(_: NSError, modalFor: NSWindow, delegate?: any, didPresent?: string, contextInfo?: any): void;
    removeDocument(_: NSDocument): void;
    reopenDocumentForWithContentsOfDisplayCompletionHandler(for_?: NSURL, withContentsOf?: NSURL, display?: boolean, completionHandler?: (p1: NSDocument, p2: boolean, p3: NSError) => void): void;
    reviewUnsavedDocumentsWithAlertTitleCancellableDelegateDidReviewAllSelectorContextInfo(withAlertTitle?: string, cancellable?: boolean, delegate?: any, didReviewAllSelector?: string, contextInfo?: any): void;
    runModalOpenPanelForTypes(_: NSOpenPanel, forTypes?: string[]): number;
    saveAllDocuments(_?: any): void;
    standardShareMenuItem(): NSMenuItem;
    typeForContentsOfURLError(error: NSURL): string;
    willPresentError(_: NSError): NSError;
  }

  // export function NSDottedFrameRect(rect: CGRect): void;

  interface NSDraggingDestination extends NSObject {
    // instance method
    concludeDragOperation?(_?: NSDraggingInfo): void;
    // instance method
    draggingEnded?(_: NSDraggingInfo): void;
    // instance method
    draggingEntered?(_: NSDraggingInfo): NSDragOperation;
    // instance method
    draggingExited?(_?: NSDraggingInfo): void;
    // instance method
    draggingUpdated?(_: NSDraggingInfo): NSDragOperation;
    // instance method
    performDragOperation?(_: NSDraggingInfo): boolean;
    // instance method
    prepareForDragOperation?(_: NSDraggingInfo): boolean;
    // instance method
    updateDraggingItemsForDrag?(_?: NSDraggingInfo): void;
    // instance method
    wantsPeriodicDraggingUpdates?(): boolean;
  }

  // interface
  class NSDraggingImageComponent extends NSObject {
    static draggingImageComponentWithKey(key: string): NSDraggingImageComponent;
    contents: any;
    setContents(_: any)
    frame: CGRect;
    setFrame(_: CGRect)
    key: string;
    setKey(_: string)
    static createWithKey(key: string): NSDraggingImageComponent;
  }

  interface NSDraggingInfo extends NSObject {
    animatesToDestination: boolean;
    setAnimatesToDestination(_: boolean)
    draggedImage: NSImage;
    draggedImageLocation: CGPoint;
    draggingDestinationWindow: NSWindow;
    draggingFormation: NSDraggingFormation;
    setDraggingFormation(_: NSDraggingFormation)
    draggingLocation: CGPoint;
    draggingPasteboard: NSPasteboard;
    draggingSequenceNumber: number;
    draggingSource: any;
    draggingSourceOperationMask: NSDragOperation;
    numberOfValidItemsForDrop: number;
    setNumberOfValidItemsForDrop(_: number)
    springLoadingHighlight: NSSpringLoadingHighlight;
    // instance method
    enumerateDraggingItemsWithOptionsForClassesSearchOptionsUsing(options: NSDraggingItemEnumerationOptions, for_?: NSView, classes?: typeof NSObject[], searchOptions?: Map<string, any>, using?: (p1: NSDraggingItem, p2: number, p3: boolean) => void): void;
    // instance method
    resetSpringLoading(): void;
    // instance method
    slideDraggedImageTo(to: CGPoint): void;
  }

  // interface
  class NSDraggingItem extends NSObject {
    draggingFrame: CGRect;
    setDraggingFrame(_: CGRect)
    imageComponents: NSDraggingImageComponent[];
    imageComponentsProvider: () => NSDraggingImageComponent[];
    setImageComponentsProvider(_: () => NSDraggingImageComponent[])
    item: any;
    static createWithPasteboardWriter(pasteboardWriter: NSPasteboardWriting): NSDraggingItem;
    setDraggingFrameContents(_: CGRect, contents?: any): void;
  }

  // interface
  class NSDraggingSession extends NSObject {
    animatesToStartingPositionsOnCancelOrFail: boolean;
    setAnimatesToStartingPositionsOnCancelOrFail(_: boolean)
    draggingFormation: NSDraggingFormation;
    setDraggingFormation(_: NSDraggingFormation)
    draggingLeaderIndex: number;
    setDraggingLeaderIndex(_: number)
    draggingLocation: CGPoint;
    draggingPasteboard: NSPasteboard;
    draggingSequenceNumber: number;
    enumerateDraggingItemsWithOptionsForClassesSearchOptionsUsing(options: NSDraggingItemEnumerationOptions, for_?: NSView, classes?: typeof NSObject[], searchOptions?: Map<string, any>, using?: (p1: NSDraggingItem, p2: number, p3: boolean) => void): void;
  }

  interface NSDraggingSource extends NSObject {
    // instance method
    draggingSessionSourceOperationMaskForDraggingContext(_: NSDraggingSession, sourceOperationMaskFor: NSDraggingContext): NSDragOperation;
    // instance method
    draggingSessionWillBeginAtPoint?(_: NSDraggingSession, willBeginAt: CGPoint): void;
    // instance method
    draggingSessionMovedToPoint?(_: NSDraggingSession, movedTo: CGPoint): void;
    // instance method
    draggingSessionEndedAtPointOperation?(_: NSDraggingSession, endedAt: CGPoint, operation: NSDragOperation): void;
    // instance method
    ignoreModifierKeysForDraggingSession?(for_: NSDraggingSession): boolean;
  }

  // export function NSDrawBitmap(rect: CGRect, width: number, height: number, bps: number, spp: number, bpp: number, bpr: number, isPlanar: boolean, hasAlpha: boolean, colorSpaceName: string, data: string): void;

  // export function NSDrawButton(rect: CGRect, clipRect: CGRect): void;

  // export function NSDrawColorTiledRects(boundsRect: CGRect, clipRect: CGRect, sides: NSRectEdge, colors: NSColor, count: number): CGRect;

  // export function NSDrawDarkBezel(rect: CGRect, clipRect: CGRect): void;

  // export function NSDrawGrayBezel(rect: CGRect, clipRect: CGRect): void;

  // export function NSDrawGroove(rect: CGRect, clipRect: CGRect): void;

  // export function NSDrawLightBezel(rect: CGRect, clipRect: CGRect): void;

  // export function NSDrawNinePartImage(frame: CGRect, topLeftCorner: NSImage, topEdgeFill: NSImage, topRightCorner: NSImage, leftEdgeFill: NSImage, centerFill: NSImage, rightEdgeFill: NSImage, bottomLeftCorner: NSImage, bottomEdgeFill: NSImage, bottomRightCorner: NSImage, op: NSCompositingOperation, alphaFraction: number, flipped: boolean): void;

  // export function NSDrawThreePartImage(frame: CGRect, startCap: NSImage, centerFill: NSImage, endCap: NSImage, vertical: boolean, op: NSCompositingOperation, alphaFraction: number, flipped: boolean): void;

  // export function NSDrawTiledRects(boundsRect: CGRect, clipRect: CGRect, sides: NSRectEdge, grays: number, count: number): CGRect;

  // export function NSDrawWhiteBezel(rect: CGRect, clipRect: CGRect): void;

  // export function NSDrawWindowBackground(rect: CGRect): void;

  type NSDrawerDelegate = NSObject

  // interface
  class NSEPSImageRep extends NSImageRep {
    EPSRepresentation: NSData;
    boundingBox: CGRect;
    static createWithData(data: NSData): NSEPSImageRep;
  }

  interface NSEditor extends NSObject {
    // instance method
    commitEditing(): boolean;
    // instance method
    commitEditingWithDelegateDidCommitSelectorContextInfo(withDelegate?: any, didCommit?: string, contextInfo?: any): void;
    // instance method
    commitEditingAndReturnError(): boolean;
    // instance method
    discardEditing(): void;
  }

  interface NSEditorRegistration extends NSObject {
    // instance method
    objectDidBeginEditing?(_: NSEditor): void;
    // instance method
    objectDidEndEditing?(_: NSEditor): void;
  }

  // export function NSEraseRect(rect: CGRect): void;

  // interface
  class NSEvent extends NSObject /* implements NSCoding, NSCopying */ {
    static addGlobalMonitorForEventsWithMatchingHandler(matching: NSEvent.EventTypeMask, handler: (p1: NSEvent) => void): any;
    static addLocalMonitorForEventsWithMatchingHandler(matching: NSEvent.EventTypeMask, handler?: (p1: NSEvent) => NSEvent): any;
    static enterExitEventWithTypeLocationModifierFlagsTimestampWindowNumberContextEventNumberTrackingNumberUserData(with_: NSEvent.EventType, location: CGPoint, modifierFlags: NSEvent.ModifierFlags, timestamp: number, windowNumber: number, context?: NSGraphicsContext, eventNumber?: number, trackingNumber?: number, userData?: any): NSEvent;
    static keyEventWithTypeLocationModifierFlagsTimestampWindowNumberContextCharactersCharactersIgnoringModifiersIsARepeatKeyCode(with_: NSEvent.EventType, location: CGPoint, modifierFlags: NSEvent.ModifierFlags, timestamp: number, windowNumber: number, context?: NSGraphicsContext, characters?: string, charactersIgnoringModifiers?: string, isARepeat?: boolean, keyCode?: number): NSEvent;
    static mouseEventWithTypeLocationModifierFlagsTimestampWindowNumberContextEventNumberClickCountPressure(with_: NSEvent.EventType, location: CGPoint, modifierFlags: NSEvent.ModifierFlags, timestamp: number, windowNumber: number, context?: NSGraphicsContext, eventNumber?: number, clickCount?: number, pressure?: number): NSEvent;
    static otherEventWithTypeLocationModifierFlagsTimestampWindowNumberContextSubtypeData1Data2(with_: NSEvent.EventType, location: CGPoint, modifierFlags: NSEvent.ModifierFlags, timestamp: number, windowNumber: number, context?: NSGraphicsContext, subtype?: number, data1?: number, data2?: number): NSEvent;
    static removeMonitor(_: any): void;
    static startPeriodicEventsAfterDelayWithPeriod(afterDelay: number, withPeriod: number): void;
    static stopPeriodicEvents(): void;
    isARepeat: boolean;
    CGEvent: any;
    absoluteX: number;
    absoluteY: number;
    absoluteZ: number;
    associatedEventsMask: NSEvent.EventTypeMask;
    buttonMask: NSEvent.ButtonMask;
    buttonNumber: number;
    capabilityMask: number;
    characters: string;
    charactersIgnoringModifiers: string;
    clickCount: number;
    data1: number;
    data2: number;
    deltaX: number;
    deltaY: number;
    deltaZ: number;
    deviceID: number;
    isDirectionInvertedFromDevice: boolean;
    isEnteringProximity: boolean;
    eventNumber: number;
    eventRef: any;
    hasPreciseScrollingDeltas: boolean;
    keyCode: number;
    locationInWindow: CGPoint;
    magnification: number;
    momentumPhase: NSEvent.Phase;
    phase: NSEvent.Phase;
    pointingDeviceID: number;
    pointingDeviceSerialNumber: number;
    pointingDeviceType: NSEvent.PointingDeviceType;
    pressure: number;
    pressureBehavior: NSEvent.PressureBehavior;
    rotation: number;
    scrollingDeltaX: number;
    scrollingDeltaY: number;
    stage: number;
    stageTransition: number;
    subtype: NSEvent.EventSubtype;
    systemTabletID: number;
    tabletID: number;
    tangentialPressure: number;
    tilt: CGPoint;
    timestamp: number;
    trackingArea: NSTrackingArea;
    trackingNumber: number;
    type: NSEvent.EventType;
    uniqueID: number;
    userData: any;
    vendorDefined: any;
    vendorID: number;
    vendorPointingDeviceType: number;
    window: NSWindow;
    windowNumber: number;
    static doubleClickInterval: number;
    static keyRepeatDelay: number;
    static keyRepeatInterval: number;
    static modifierFlags: NSEvent.ModifierFlags;
    static isMouseCoalescingEnabled: boolean;
    setMouseCoalescingEnabled(_: boolean)
    static mouseLocation: CGPoint;
    static pressedMouseButtons: number;
    static isSwipeTrackingFromScrollEventsEnabled: boolean;
    allTouches(): NSSet<NSTouch>;
    charactersByApplyingModifiers(byApplyingModifiers: NSEvent.ModifierFlags): string;
    coalescedTouchesForTouch(for_: NSTouch): NSTouch[];
    touchesForView(for_: NSView): NSSet<NSTouch>;
    touchesMatchingPhaseInView(matching: NSTouch.Phase, in_?: NSView): NSSet<NSTouch>;
    trackSwipeEventWithOptionsDampenAmountThresholdMinMaxUsingHandler(options: NSEvent.SwipeTrackingOptions, dampenAmountThresholdMin: number, max: number, usingHandler: (p1: number, p2: NSEvent.Phase, p3: boolean, p4: boolean) => void): void;
  }

  // interface
  class NSFilePromiseProvider extends NSObject /* implements NSPasteboardWriting */ {
    delegate: NSFilePromiseProviderDelegate;
    setDelegate(_: NSFilePromiseProviderDelegate)
    fileType: string;
    setFileType(_: string)
    userInfo: any;
    setUserInfo(_: any)
    static createWithFileTypeDelegate(fileType: string, delegate: NSFilePromiseProviderDelegate): NSFilePromiseProvider;
  }

  interface NSFilePromiseProviderDelegate extends NSObject {
    // instance method
    filePromiseProviderWritePromiseToCompletionHandler(_: NSFilePromiseProvider, writePromiseTo: NSURL, completionHandler?: (p1: NSError) => void): void;
    // instance method
    filePromiseProviderFileNameForType(_: NSFilePromiseProvider, fileNameForType: string): string;
    // instance method
    operationQueueForFilePromiseProvider?(for_: NSFilePromiseProvider): OperationQueue;
  }

  // interface
  class NSFilePromiseReceiver extends NSObject /* implements NSPasteboardReading */ {
    fileNames: string[];
    fileTypes: string[];
    static readableDraggedTypes: string[];
    receivePromisedFilesWithAtDestinationOptionsOperationQueueReader(atDestination: NSURL, options: Map<any, any>, operationQueue: OperationQueue, reader?: (p1: NSURL, p2: NSError) => void): void;
  }

  // interface
  class NSFont extends NSObject /* implements NSCopying, NSSecureCoding */ {
    static boldSystemFontOfSize(ofSize: number): NSFont;
    static controlContentFontOfSize(ofSize: number): NSFont;
    static labelFontOfSize(ofSize: number): NSFont;
    static menuBarFontOfSize(ofSize: number): NSFont;
    static menuFontOfSize(ofSize: number): NSFont;
    static messageFontOfSize(ofSize: number): NSFont;
    static monospacedDigitSystemFontOfSizeWeight(ofSize: number, weight: number): NSFont;
    static monospacedSystemFontOfSizeWeight(ofSize: number, weight: number): NSFont;
    static paletteFontOfSize(ofSize: number): NSFont;
    static setUserFixedPitchFont(_?: NSFont): void;
    static setUserFont(_?: NSFont): void;
    static systemFontOfSize(ofSize: number): NSFont;
    static systemFontOfSizeWeight(ofSize: number, weight: number): NSFont;
    static systemFontSizeForControlSize(for_: NSControl.ControlSize): number;
    static titleBarFontOfSize(ofSize: number): NSFont;
    static toolTipsFontOfSize(ofSize: number): NSFont;
    static userFixedPitchFontOfSize(ofSize: number): NSFont;
    static userFontOfSize(ofSize: number): NSFont;
    ascender: number;
    boundingRectForFont: CGRect;
    capHeight: number;
    coveredCharacterSet: NSCharacterSet;
    descender: number;
    displayName: string;
    familyName: string;
    isFixedPitch: boolean;
    fontDescriptor: NSFontDescriptor;
    fontName: string;
    italicAngle: number;
    leading: number;
    matrix: number;
    maximumAdvancement: CGSize;
    mostCompatibleStringEncoding: number;
    numberOfGlyphs: number;
    pointSize: number;
    printerFont: NSFont;
    renderingMode: NSFontRenderingMode;
    screenFont: NSFont;
    textTransform: NSAffineTransform;
    underlinePosition: number;
    underlineThickness: number;
    isVertical: boolean;
    verticalFont: NSFont;
    xHeight: number;
    static labelFontSize: number;
    static smallSystemFontSize: number;
    static systemFontSize: number;
    advancementForCGGlyph(forCGGlyph: number): CGSize;
    advancementForGlyph(forGlyph: number): CGSize;
    boundingRectForCGGlyph(forCGGlyph: number): CGRect;
    boundingRectForGlyph(forGlyph: number): CGRect;
    getAdvancementsForCGGlyphsCount(_: NSSize, forCGGlyphs: number, count: number): void;
    getAdvancementsForGlyphsCount(_: NSSize, forGlyphs: number, count: number): void;
    getAdvancementsForPackedGlyphsLength(_: NSSize, forPackedGlyphs: any, length: number): void;
    getBoundingRectsForCGGlyphsCount(_: NSRect, forCGGlyphs: number, count: number): void;
    getBoundingRectsForGlyphsCount(_: NSRect, forGlyphs: number, count: number): void;
    glyphWithName(withName: string): number;
    screenFontWithRenderingMode(with_: NSFontRenderingMode): NSFont;
    set(): void;
    setInContext(in_: NSGraphicsContext): void;
  }

  // interface
  class NSFontAssetRequest extends NSObject /* implements ProgressReporting */ {
    downloadedFontDescriptors: NSFontDescriptor[];
    downloadWithWithCompletionHandler(withCompletionHandler?: (p1: NSError) => boolean): void;
    static createWithFontDescriptorsOptions(fontDescriptors: NSFontDescriptor[], options: NSFontAssetRequest.Options): NSFontAssetRequest;
  }

  interface NSFontChanging extends NSObject {
    // instance method
    changeFont?(_?: NSFontManager): void;
    // instance method
    validModesForFontPanel?(_: NSFontPanel): NSFontPanel.ModeMask;
  }

  // interface
  class NSFontCollection extends NSObject /* implements NSCoding, NSCopying, NSMutableCopying */ {
    static hideFontCollectionWithNameVisibilityError(visibility: string, error: NSFontCollection.Visibility): boolean;
    static renameFontCollectionWithNameVisibilityToNameError(fromName: string, visibility: NSFontCollection.Visibility, toName: string): boolean;
    static showFontCollectionWithNameVisibilityError(withName: NSFontCollection, visibility: string, error: NSFontCollection.Visibility): boolean;
    exclusionDescriptors: NSFontDescriptor[];
    matchingDescriptors: NSFontDescriptor[];
    queryDescriptors: NSFontDescriptor[];
    static allFontCollectionNames: string[];
    static fontCollectionWithAllAvailableDescriptors: NSFontCollection;
    matchingDescriptorsForFamily(forFamily: string): NSFontDescriptor[];
    matchingDescriptorsForFamilyOptions(forFamily: string, options?: Map<string, number>): NSFontDescriptor[];
    matchingDescriptorsWithOptions(options?: Map<string, number>): NSFontDescriptor[];
  }

  // interface
  class NSFontDescriptor extends NSObject /* implements NSCopying, NSSecureCoding */ {
    fontAttributes: Map<string, any>;
    matrix: NSAffineTransform;
    pointSize: number;
    postscriptName: string;
    requiresFontAssetRequest: boolean;
    symbolicTraits: NSFontDescriptor.SymbolicTraits;
    fontDescriptorByAddingAttributes(_: Map<string, any>): NSFontDescriptor;
    fontDescriptorWithDesign(_: string): NSFontDescriptor;
    fontDescriptorWithFace(_: string): NSFontDescriptor;
    fontDescriptorWithFamily(_: string): NSFontDescriptor;
    fontDescriptorWithMatrix(_: NSAffineTransform): NSFontDescriptor;
    fontDescriptorWithSize(_: number): NSFontDescriptor;
    fontDescriptorWithSymbolicTraits(_: NSFontDescriptor.SymbolicTraits): NSFontDescriptor;
    static createWithFontAttributes(fontAttributes?: Map<string, any>): NSFontDescriptor;
    matchingFontDescriptorWithWithMandatoryKeys(withMandatoryKeys?: NSSet<string>): NSFontDescriptor;
    matchingFontDescriptorsWithWithMandatoryKeys(withMandatoryKeys?: NSSet<string>): NSFontDescriptor[];
    objectForKey(forKey: string): any;
  }

  // interface
  class NSFontManager extends NSObject /* implements NSMenuItemValidation */ {
    static setFontManagerFactory(_?: typeof NSObject): void;
    static setFontPanelFactory(_?: typeof NSObject): void;
    action: string;
    setAction(_: string)
    availableFontFamilies: string[];
    availableFonts: string[];
    currentFontAction: NSFontAction;
    isEnabled: boolean;
    setEnabled(_: boolean)
    isMultiple: boolean;
    selectedFont: NSFont;
    target: any;
    setTarget(_: any)
    static sharedFontManager: NSFontManager;
    addFontTrait(_?: any): void;
    availableFontNamesWithTraits(with_: NSFontTraitMask): string[];
    availableMembersOfFontFamily(ofFontFamily: string): any[][];
    convertAttributes(_: Map<string, any>): Map<string, any>;
    convertFont(_: NSFont): NSFont;
    convertFontToFace(_: NSFont, toFace: string): NSFont;
    convertFontToFamily(_: NSFont, toFamily: string): NSFont;
    convertFontToHaveTrait(_: NSFont, toHaveTrait: NSFontTraitMask): NSFont;
    convertFontToNotHaveTrait(_: NSFont, toNotHaveTrait: NSFontTraitMask): NSFont;
    convertFontToSize(_: NSFont, toSize: number): NSFont;
    convertFontTraits(_: NSFontTraitMask): NSFontTraitMask;
    convertWeightOfFont(_: boolean, of: NSFont): NSFont;
    fontMenu(_: boolean): NSMenu;
    fontNamedHasTraits(_: string, hasTraits: NSFontTraitMask): boolean;
    fontPanel(_: boolean): NSFontPanel;
    fontWithFamilyTraitsWeightSize(withFamily: string, traits: NSFontTraitMask, weight: number, size: number): NSFont;
    localizedNameForFamilyFace(forFamily: string, face?: string): string;
    modifyFont(_?: any): void;
    modifyFontViaPanel(_?: any): void;
    orderFrontFontPanel(_?: any): void;
    orderFrontStylesPanel(_?: any): void;
    removeFontTrait(_?: any): void;
    sendAction(): boolean;
    setFontMenu(_: NSMenu): void;
    setSelectedAttributesIsMultiple(_: Map<string, any>, isMultiple: boolean): void;
    setSelectedFontIsMultiple(_: NSFont, isMultiple: boolean): void;
    traitsOfFont(of: NSFont): NSFontTraitMask;
    weightOfFont(of: NSFont): number;
  }

  // interface
  class NSFontPanel extends NSPanel {
    accessoryView: NSView;
    setAccessoryView(_: NSView)
    isEnabled: boolean;
    setEnabled(_: boolean)
    static sharedFontPanel: NSFontPanel;
    static sharedFontPanelExists: boolean;
    panelConvertFont(_: NSFont): NSFont;
    reloadDefaultFontFamilies(): void;
    setPanelFontIsMultiple(_: NSFont, isMultiple: boolean): void;
  }

  // interface
  class NSFormCell extends NSActionCell {
    attributedTitle: NSAttributedString;
    setAttributedTitle(_: NSAttributedString)
    placeholderAttributedString: NSAttributedString;
    setPlaceholderAttributedString(_: NSAttributedString)
    placeholderString: string;
    setPlaceholderString(_: string)
    preferredTextFieldWidth: number;
    setPreferredTextFieldWidth(_: number)
    titleAlignment: NSTextAlignment;
    setTitleAlignment(_: NSTextAlignment)
    titleBaseWritingDirection: NSWritingDirection;
    setTitleBaseWritingDirection(_: NSWritingDirection)
    titleFont: NSFont;
    setTitleFont(_: NSFont)
    titleWidth: number;
    setTitleWidth(_: number)
  }

  // export function NSFrameRect(rect: CGRect): void;

  // export function NSFrameRectWithWidth(rect: CGRect, frameWidth: number): void;

  // export function NSFrameRectWithWidthUsingOperation(rect: CGRect, frameWidth: number, op: NSCompositingOperation): void;

  // interface
  class NSGestureRecognizer extends NSObject /* implements NSCoding */ {
    action: string;
    setAction(_: string)
    allowedTouchTypes: NSTouch.TouchTypeMask;
    setAllowedTouchTypes(_: NSTouch.TouchTypeMask)
    delaysKeyEvents: boolean;
    setDelaysKeyEvents(_: boolean)
    delaysMagnificationEvents: boolean;
    setDelaysMagnificationEvents(_: boolean)
    delaysOtherMouseButtonEvents: boolean;
    setDelaysOtherMouseButtonEvents(_: boolean)
    delaysPrimaryMouseButtonEvents: boolean;
    setDelaysPrimaryMouseButtonEvents(_: boolean)
    delaysRotationEvents: boolean;
    setDelaysRotationEvents(_: boolean)
    delaysSecondaryMouseButtonEvents: boolean;
    setDelaysSecondaryMouseButtonEvents(_: boolean)
    delegate: NSGestureRecognizerDelegate;
    setDelegate(_: NSGestureRecognizerDelegate)
    isEnabled: boolean;
    setEnabled(_: boolean)
    pressureConfiguration: NSPressureConfiguration;
    setPressureConfiguration(_: NSPressureConfiguration)
    state: NSGestureRecognizer.State;
    setState(_: NSGestureRecognizer.State)
    target: any;
    setTarget(_: any)
    view: NSView;
    canBePreventedByGestureRecognizer(by: NSGestureRecognizer): boolean;
    canPreventGestureRecognizer(_: NSGestureRecognizer): boolean;
    flagsChanged(with_: NSEvent): void;
    static createWithTargetAction(target?: any, action?: string): NSGestureRecognizer;
    keyDown(with_: NSEvent): void;
    keyUp(with_: NSEvent): void;
    locationInView(in_?: NSView): CGPoint;
    magnifyWithEvent(with_: NSEvent): void;
    mouseDown(with_: NSEvent): void;
    mouseDragged(with_: NSEvent): void;
    mouseUp(with_: NSEvent): void;
    otherMouseDown(with_: NSEvent): void;
    otherMouseDragged(with_: NSEvent): void;
    otherMouseUp(with_: NSEvent): void;
    pressureChangeWithEvent(with_: NSEvent): void;
    reset(): void;
    rightMouseDown(with_: NSEvent): void;
    rightMouseDragged(with_: NSEvent): void;
    rightMouseUp(with_: NSEvent): void;
    rotateWithEvent(with_: NSEvent): void;
    shouldBeRequiredToFailByGestureRecognizer(by: NSGestureRecognizer): boolean;
    shouldRequireFailureOfGestureRecognizer(of: NSGestureRecognizer): boolean;
    tabletPoint(with_: NSEvent): void;
    touchesBeganWithEvent(with_: NSEvent): void;
    touchesCancelledWithEvent(with_: NSEvent): void;
    touchesEndedWithEvent(with_: NSEvent): void;
    touchesMovedWithEvent(with_: NSEvent): void;
  }

  interface NSGestureRecognizerDelegate extends NSObject {
    // instance method
    gestureRecognizerShouldAttemptToRecognizeWithEvent?(_: NSGestureRecognizer, shouldAttemptToRecognizeWith: NSEvent): boolean;
    // instance method
    gestureRecognizerShouldRecognizeSimultaneouslyWithGestureRecognizer?(_: NSGestureRecognizer, shouldRecognizeSimultaneouslyWith: NSGestureRecognizer): boolean;
    // instance method
    gestureRecognizerShouldRequireFailureOfGestureRecognizer?(_: NSGestureRecognizer, shouldRequireFailureOf: NSGestureRecognizer): boolean;
    // instance method
    gestureRecognizerShouldBeRequiredToFailByGestureRecognizer?(_: NSGestureRecognizer, shouldBeRequiredToFailBy: NSGestureRecognizer): boolean;
    // instance method
    gestureRecognizerShouldReceiveTouch?(_: NSGestureRecognizer, shouldReceive: NSTouch): boolean;
    // instance method
    gestureRecognizerShouldBegin?(_: NSGestureRecognizer): boolean;
  }

  // export function NSGetFileType(pboardType: string): string;

  // export function NSGetFileTypes(pboardTypes: string[]): string[];

  // interface
  class NSGlyphGenerator extends NSObject {
    static sharedGlyphGenerator: NSGlyphGenerator;
    generateGlyphsForGlyphStorageDesiredNumberOfCharactersGlyphIndexCharacterIndex(for_: NSGlyphStorage, desiredNumberOfCharacters: number, glyphIndex?: number, characterIndex?: number): void;
  }

  // interface
  class NSGlyphInfo extends NSObject /* implements NSCopying, NSSecureCoding */ {
    baseString: string;
    characterCollection: NSCharacterCollection;
    characterIdentifier: number;
    glyphID: number;
    glyphName: string;
  }

  interface NSGlyphStorage {
    // instance method
    attributedString(): NSAttributedString;
    // instance method
    insertGlyphsLengthForStartingGlyphAtIndexCharacterIndex(_: number, length: number, forStartingGlyphAt: number, characterIndex: number): void;
    // instance method
    layoutOptions(): number;
    // instance method
    setIntAttributeValueForGlyphAtIndex(_: number, value: number, forGlyphAt: number): void;
  }

  // interface
  class NSGradient extends NSObject /* implements NSCopying, NSSecureCoding */ {
    colorSpace: NSColorSpace;
    numberOfColorStops: number;
    drawFromCenterRadiusToCenterRadiusOptions(fromCenter: CGPoint, radius: number, toCenter: CGPoint, radius2: number, options: NSGradient.DrawingOptions): void;
    drawFromPointToPointOptions(from: CGPoint, to: CGPoint, options: NSGradient.DrawingOptions): void;
    drawInBezierPathAngle(in_: NSBezierPath, angle: number): void;
    drawInBezierPathRelativeCenterPosition(in_: NSBezierPath, relativeCenterPosition: CGPoint): void;
    drawInRectAngle(in_: CGRect, angle: number): void;
    drawInRectRelativeCenterPosition(in_: CGRect, relativeCenterPosition: CGPoint): void;
    getColorLocationAtIndex(_?: NSColor, location?: number, at?: number): void;
    static createWithColors(colors: NSColor[]): NSGradient;
    static createWithColorsAtLocationsColorSpace(colors: NSColor[], atLocations?: number, colorSpace?: NSColorSpace): NSGradient;
    static createWithColorsAndLocations(colorsAndLocations: NSColor): NSGradient;
    static createWithStartingColorEndingColor(startingColor: NSColor, endingColor: NSColor): NSGradient;
    interpolatedColorAtLocation(atLocation: number): NSColor;
  }

  // interface
  class NSGraphicsContext extends NSObject {
    static currentContextDrawingToScreen(): boolean;
    static restoreGraphicsState(): void;
    static saveGraphicsState(): void;
    CGContext: any;
    CIContext: CIContext;
    attributes: Map<string, any>;
    colorRenderingIntent: NSColorRenderingIntent;
    setColorRenderingIntent(_: NSColorRenderingIntent)
    compositingOperation: NSCompositingOperation;
    setCompositingOperation(_: NSCompositingOperation)
    isDrawingToScreen: boolean;
    isFlipped: boolean;
    imageInterpolation: NSImageInterpolation;
    setImageInterpolation(_: NSImageInterpolation)
    patternPhase: CGPoint;
    setPatternPhase(_: CGPoint)
    shouldAntialias: boolean;
    setShouldAntialias(_: boolean)
    static currentContext: NSGraphicsContext;
    setCurrentContext(_: NSGraphicsContext)
    flushGraphics(): void;
    restoreGraphicsState(): void;
    saveGraphicsState(): void;
  }

  // interface
  class NSGridCell extends NSObject /* implements NSCoding */ {
    column: NSGridColumn;
    contentView: NSView;
    setContentView(_: NSView)
    customPlacementConstraints: NSLayoutConstraint[];
    setCustomPlacementConstraints(_: NSLayoutConstraint[])
    row: NSGridRow;
    rowAlignment: NSGridRow.Alignment;
    setRowAlignment(_: NSGridRow.Alignment)
    xPlacement: NSGridCell.Placement;
    setXPlacement(_: NSGridCell.Placement)
    yPlacement: NSGridCell.Placement;
    setYPlacement(_: NSGridCell.Placement)
    static emptyContentView: NSView;
  }

  // interface
  class NSGridColumn extends NSObject /* implements NSCoding */ {
    gridView: NSGridView;
    isHidden: boolean;
    setHidden(_: boolean)
    leadingPadding: number;
    setLeadingPadding(_: number)
    numberOfCells: number;
    trailingPadding: number;
    setTrailingPadding(_: number)
    width: number;
    setWidth(_: number)
    xPlacement: NSGridCell.Placement;
    setXPlacement(_: NSGridCell.Placement)
    cellAtIndex(at: number): NSGridCell;
    mergeCellsInRange(in_: NSRange): void;
  }

  // interface
  class NSGridRow extends NSObject /* implements NSCoding */ {
    bottomPadding: number;
    setBottomPadding(_: number)
    gridView: NSGridView;
    height: number;
    setHeight(_: number)
    isHidden: boolean;
    setHidden(_: boolean)
    numberOfCells: number;
    rowAlignment: NSGridRow.Alignment;
    setRowAlignment(_: NSGridRow.Alignment)
    topPadding: number;
    setTopPadding(_: number)
    yPlacement: NSGridCell.Placement;
    setYPlacement(_: NSGridCell.Placement)
    cellAtIndex(at: number): NSGridCell;
    mergeCellsInRange(in_: NSRange): void;
  }

  // interface
  class NSGridView extends NSView {
    columnSpacing: number;
    setColumnSpacing(_: number)
    numberOfColumns: number;
    numberOfRows: number;
    rowAlignment: NSGridRow.Alignment;
    setRowAlignment(_: NSGridRow.Alignment)
    rowSpacing: number;
    setRowSpacing(_: number)
    xPlacement: NSGridCell.Placement;
    setXPlacement(_: NSGridCell.Placement)
    yPlacement: NSGridCell.Placement;
    setYPlacement(_: NSGridCell.Placement)
    addColumnWithViews(with_: NSView[]): NSGridColumn;
    addRowWithViews(with_: NSView[]): NSGridRow;
    cellAtColumnIndexRowIndex(atColumnIndex: number, rowIndex: number): NSGridCell;
    cellForView(for_: NSView): NSGridCell;
    columnAtIndex(at: number): NSGridColumn;
    indexOfColumn(of: NSGridColumn): number;
    indexOfRow(of: NSGridRow): number;
    insertColumnAtIndexWithViews(at: number, with_: NSView[]): NSGridColumn;
    insertRowAtIndexWithViews(at: number, with_: NSView[]): NSGridRow;
    mergeCellsInHorizontalRangeVerticalRange(inHorizontalRange: NSRange, verticalRange: NSRange): void;
    moveColumnAtIndexToIndex(at: number, to: number): void;
    moveRowAtIndexToIndex(at: number, to: number): void;
    removeColumnAtIndex(at: number): void;
    removeRowAtIndex(at: number): void;
    rowAtIndex(at: number): NSGridRow;
  }

  // interface
  class NSGroupTouchBarItem extends NSTouchBarItem {
    static alertStyleGroupItemWithIdentifier(alertStyleWithIdentifier: string): NSGroupTouchBarItem;
    static groupItemWithIdentifierItems(identifier: string, items: NSTouchBarItem[]): NSGroupTouchBarItem;
    static groupItemWithIdentifierItemsAllowedCompressionOptions(identifier: string, items: NSTouchBarItem[], allowedCompressionOptions: NSUserInterfaceCompressionOptions): NSGroupTouchBarItem;
    effectiveCompressionOptions: NSUserInterfaceCompressionOptions;
    groupTouchBar: NSTouchBar;
    setGroupTouchBar(_: NSTouchBar)
    groupUserInterfaceLayoutDirection: NSUserInterfaceLayoutDirection;
    setGroupUserInterfaceLayoutDirection(_: NSUserInterfaceLayoutDirection)
    preferredItemWidth: number;
    setPreferredItemWidth(_: number)
    prefersEqualWidths: boolean;
    setPrefersEqualWidths(_: boolean)
    prioritizedCompressionOptions: NSUserInterfaceCompressionOptions[];
    setPrioritizedCompressionOptions(_: NSUserInterfaceCompressionOptions[])
  }

  // interface
  class NSHapticFeedbackManager extends NSObject {
    static defaultPerformer: NSHapticFeedbackPerformer;
  }

  interface NSHapticFeedbackPerformer extends NSObject {
    // instance method
    performFeedbackPatternPerformanceTime(_: NSHapticFeedbackManager.FeedbackPattern, performanceTime: NSHapticFeedbackManager.PerformanceTime): void;
  }

  // interface
  class NSHelpManager extends NSObject {
    static isContextHelpModeActive: boolean;
    setContextHelpModeActive(_: boolean)
    static sharedHelpManager: NSHelpManager;
    contextHelpForObject(for_: any): NSAttributedString;
    findStringInBook(_: string, inBook?: string): void;
    openHelpAnchorInBook(_: string, inBook?: string): void;
    registerBooksInBundle(in_: Bundle): boolean;
    removeContextHelpForObject(for_: any): void;
    setContextHelpForObject(_: NSAttributedString, for_: any): void;
    showContextHelpForObjectLocationHint(for_: any, locationHint: CGPoint): boolean;
  }

  interface NSIgnoreMisspelledWords {
    // instance method
    ignoreSpelling(_?: any): void;
  }

  // interface
  class NSImage extends NSObject /* implements NSCopying, NSPasteboardReading, NSPasteboardWriting, NSSecureCoding */ {
    static canInitWithPasteboard(with_: NSPasteboard): boolean;
    TIFFRepresentation: NSData;
    accessibilityDescription: string;
    setAccessibilityDescription(_: string)
    alignmentRect: CGRect;
    setAlignmentRect(_: CGRect)
    backgroundColor: NSColor;
    setBackgroundColor(_: NSColor)
    cacheMode: NSImage.CacheMode;
    setCacheMode(_: NSImage.CacheMode)
    capInsets: NSEdgeInsets;
    setCapInsets(_: NSEdgeInsets)
    delegate: NSImageDelegate;
    setDelegate(_: NSImageDelegate)
    matchesOnMultipleResolution: boolean;
    setMatchesOnMultipleResolution(_: boolean)
    matchesOnlyOnBestFittingAxis: boolean;
    setMatchesOnlyOnBestFittingAxis(_: boolean)
    prefersColorMatch: boolean;
    setPrefersColorMatch(_: boolean)
    representations: NSImageRep[];
    resizingMode: NSImage.ResizingMode;
    setResizingMode(_: NSImage.ResizingMode)
    size: CGSize;
    setSize(_: CGSize)
    isTemplate: boolean;
    setTemplate(_: boolean)
    usesEPSOnResolutionMismatch: boolean;
    setUsesEPSOnResolutionMismatch(_: boolean)
    isValid: boolean;
    static imageTypes: string[];
    static imageUnfilteredTypes: string[];
    CGImageForProposedRectContextHints(forProposedRect?: NSRect, context?: NSGraphicsContext, hints?: Map<string, any>): any;
    TIFFRepresentationUsingCompressionFactor(using: NSBitmapImageRep.TIFFCompression, factor: number): NSData;
    addRepresentation(_: NSImageRep): void;
    addRepresentations(_: NSImageRep[]): void;
    bestRepresentationForRectContextHints(for_: CGRect, context?: NSGraphicsContext, hints?: Map<string, any>): NSImageRep;
    cancelIncrementalLoad(): void;
    drawAtPointFromRectOperationFraction(at: CGPoint, from: CGRect, operation: NSCompositingOperation, fraction: number): void;
    drawInRect(in_: CGRect): void;
    drawInRectFromRectOperationFraction(in_: CGRect, from: CGRect, operation: NSCompositingOperation, fraction: number): void;
    drawInRectFromRectOperationFractionRespectFlippedHints(in_: CGRect, from: CGRect, operation: NSCompositingOperation, fraction: number, respectFlipped: boolean, hints?: Map<string, any>): void;
    drawRepresentationInRect(_: NSImageRep, in_: CGRect): boolean;
    hitTestRectWithImageDestinationRectContextHintsFlipped(_: CGRect, withDestinationRect: CGRect, context?: NSGraphicsContext, hints?: Map<string, any>, flipped?: boolean): boolean;
    static createWithByReferencingFile(byReferencingFile: string): NSImage;
    static createWithByReferencingURL(byReferencingURL: NSURL): NSImage;
    static createWithCGImageSize(CGImage: any, size: CGSize): NSImage;
    static createWithContentsOfFile(contentsOfFile: string): NSImage;
    static createWithContentsOfURL(contentsOfURL: NSURL): NSImage;
    static createWithData(data: NSData): NSImage;
    static createWithDataIgnoringOrientation(dataIgnoringOrientation: NSData): NSImage;
    static createWithIconRef(iconRef: any): NSImage;
    static createWithPasteboard(pasteboard: NSPasteboard): NSImage;
    static createWithSize(size: CGSize): NSImage;
    layerContentsForContentsScale(forContentsScale: number): any;
    lockFocus(): void;
    lockFocusFlipped(_: boolean): void;
    name(): string;
    recache(): void;
    recommendedLayerContentsScale(_: number): number;
    removeRepresentation(_: NSImageRep): void;
    setName(_?: string): boolean;
    unlockFocus(): void;
  }

  // interface
  class NSImageCell extends NSCell /* implements NSCoding, NSCopying */ {
    imageAlignment: NSImageAlignment;
    setImageAlignment(_: NSImageAlignment)
    imageFrameStyle: NSImageView.FrameStyle;
    setImageFrameStyle(_: NSImageView.FrameStyle)
    imageScaling: NSImageScaling;
    setImageScaling(_: NSImageScaling)
  }

  interface NSImageDelegate extends NSObject {
    // instance method
    imageDidLoadRepresentationWithStatus?(_: NSImage, didLoadRepresentation: NSImageRep, with_: NSImage.LoadStatus): void;
    // instance method
    imageDidLoadPartOfRepresentationWithValidRows?(_: NSImage, didLoadPartOfRepresentation: NSImageRep, withValidRows: number): void;
    // instance method
    imageDidLoadRepresentationHeader?(_: NSImage, didLoadRepresentationHeader: NSImageRep): void;
    // instance method
    imageWillLoadRepresentation?(_: NSImage, willLoadRepresentation: NSImageRep): void;
    // instance method
    imageDidNotDrawInRect?(_: NSImage, in_: CGRect): NSImage;
  }

  // interface
  class NSImageRep extends NSObject /* implements NSCoding, NSCopying */ {
    static canInitWithData(with_: NSData): boolean;
    static canInitWithPasteboard(with_: NSPasteboard): boolean;
    static imageRepClassForData(for_: NSData): typeof NSObject;
    static imageRepClassForType(forType: string): typeof NSObject;
    static imageRepsWithContentsOfFile(withContentsOfFile: string): NSImageRep[];
    static imageRepsWithContentsOfURL(withContentsOf: NSURL): NSImageRep[];
    static imageRepsWithPasteboard(with_: NSPasteboard): NSImageRep[];
    static registerImageRepClass(_: typeof NSObject): void;
    static unregisterImageRepClass(_: typeof NSObject): void;
    hasAlpha: boolean;
    setAlpha(_: boolean)
    bitsPerSample: number;
    setBitsPerSample(_: number)
    colorSpaceName: string;
    setColorSpaceName(_: string)
    layoutDirection: NSImage.LayoutDirection;
    setLayoutDirection(_: NSImage.LayoutDirection)
    isOpaque: boolean;
    setOpaque(_: boolean)
    pixelsHigh: number;
    setPixelsHigh(_: number)
    pixelsWide: number;
    setPixelsWide(_: number)
    size: CGSize;
    setSize(_: CGSize)
    static imageTypes: string[];
    static imageUnfilteredTypes: string[];
    static registeredImageRepClasses: typeof NSObject[];
    CGImageForProposedRectContextHints(forProposedRect?: NSRect, context?: NSGraphicsContext, hints?: Map<string, any>): any;
    draw(): boolean;
    drawAtPoint(at: CGPoint): boolean;
    drawInRect(in_: CGRect): boolean;
    drawInRectFromRectOperationFractionRespectFlippedHints(in_: CGRect, from: CGRect, operation: NSCompositingOperation, fraction: number, respectFlipped: boolean, hints?: Map<string, any>): boolean;
  }

  // interface
  class NSImageView extends NSControl /* implements NSAccessibilityImage, NSMenuItemValidation */ {
    allowsCutCopyPaste: boolean;
    setAllowsCutCopyPaste(_: boolean)
    animates: boolean;
    setAnimates(_: boolean)
    contentTintColor: NSColor;
    setContentTintColor(_: NSColor)
    isEditable: boolean;
    setEditable(_: boolean)
    image: NSImage;
    setImage(_: NSImage)
    imageAlignment: NSImageAlignment;
    setImageAlignment(_: NSImageAlignment)
    imageFrameStyle: NSImageView.FrameStyle;
    setImageFrameStyle(_: NSImageView.FrameStyle)
    imageScaling: NSImageScaling;
    setImageScaling(_: NSImageScaling)
  }

  interface NSInputServerMouseTracker {
  }

  interface NSInputServiceProvider {
  }

  // export function NSIsControllerMarker(object_: any): boolean;

  // interface
  class NSLayoutAnchor<AnchorType> extends NSObject /* implements NSCoding, NSCopying */ {
    constraintsAffectingLayout: NSLayoutConstraint[];
    hasAmbiguousLayout: boolean;
    item: any;
    name: string;
    constraintWithEqualTo(equalTo: NSLayoutAnchor<AnchorType>): NSLayoutConstraint;
    constraintWithEqualToConstant(equalTo: NSLayoutAnchor<AnchorType>, constant: number): NSLayoutConstraint;
    constraintWithGreaterThanOrEqualTo(greaterThanOrEqualTo: NSLayoutAnchor<AnchorType>): NSLayoutConstraint;
    constraintWithGreaterThanOrEqualToConstant(greaterThanOrEqualTo: NSLayoutAnchor<AnchorType>, constant: number): NSLayoutConstraint;
    constraintWithLessThanOrEqualTo(lessThanOrEqualTo: NSLayoutAnchor<AnchorType>): NSLayoutConstraint;
    constraintWithLessThanOrEqualToConstant(lessThanOrEqualTo: NSLayoutAnchor<AnchorType>, constant: number): NSLayoutConstraint;
  }

  // interface
  class NSLayoutConstraint extends NSObject /* implements NSAnimatablePropertyContainer */ {
    static activateConstraints(_: NSLayoutConstraint[]): void;
    static constraintsWithVisualFormatOptionsMetricsViews(withVisualFormat: string, options: NSLayoutConstraint.FormatOptions, metrics?: Map<string, any>, views?: Map<string, any>): NSLayoutConstraint[];
    static deactivateConstraints(_: NSLayoutConstraint[]): void;
    isActive: boolean;
    setActive(_: boolean)
    constant: number;
    setConstant(_: number)
    firstAnchor: NSLayoutAnchor<any>;
    firstAttribute: NSLayoutConstraint.Attribute;
    firstItem: any;
    identifier: string;
    setIdentifier(_: string)
    multiplier: number;
    priority: number;
    setPriority(_: number)
    relation: NSLayoutConstraint.Relation;
    secondAnchor: NSLayoutAnchor<any>;
    secondAttribute: NSLayoutConstraint.Attribute;
    secondItem: any;
    shouldBeArchived: boolean;
    setShouldBeArchived(_: boolean)
  }

  // interface
  class NSLayoutDimension extends NSLayoutAnchor<NSLayoutDimension> {
    constraintEqualToAnchorMultiplier(equalTo: NSLayoutDimension, multiplier: number): NSLayoutConstraint;
    constraintEqualToAnchorMultiplierConstant(equalTo: NSLayoutDimension, multiplier: number, constant: number): NSLayoutConstraint;
    constraintEqualToConstant(equalToConstant: number): NSLayoutConstraint;
    constraintGreaterThanOrEqualToAnchorMultiplier(greaterThanOrEqualTo: NSLayoutDimension, multiplier: number): NSLayoutConstraint;
    constraintGreaterThanOrEqualToAnchorMultiplierConstant(greaterThanOrEqualTo: NSLayoutDimension, multiplier: number, constant: number): NSLayoutConstraint;
    constraintGreaterThanOrEqualToConstant(greaterThanOrEqualToConstant: number): NSLayoutConstraint;
    constraintLessThanOrEqualToAnchorMultiplier(lessThanOrEqualTo: NSLayoutDimension, multiplier: number): NSLayoutConstraint;
    constraintLessThanOrEqualToAnchorMultiplierConstant(lessThanOrEqualTo: NSLayoutDimension, multiplier: number, constant: number): NSLayoutConstraint;
    constraintLessThanOrEqualToConstant(lessThanOrEqualToConstant: number): NSLayoutConstraint;
  }

  // interface
  class NSLayoutGuide extends NSObject /* implements NSCoding, NSUserInterfaceItemIdentification */ {
    bottomAnchor: NSLayoutYAxisAnchor;
    centerXAnchor: NSLayoutXAxisAnchor;
    centerYAnchor: NSLayoutYAxisAnchor;
    frame: CGRect;
    hasAmbiguousLayout: boolean;
    heightAnchor: NSLayoutDimension;
    leadingAnchor: NSLayoutXAxisAnchor;
    leftAnchor: NSLayoutXAxisAnchor;
    owningView: NSView;
    setOwningView(_: NSView)
    rightAnchor: NSLayoutXAxisAnchor;
    topAnchor: NSLayoutYAxisAnchor;
    trailingAnchor: NSLayoutXAxisAnchor;
    widthAnchor: NSLayoutDimension;
    constraintsAffectingLayoutForOrientation(for_: NSLayoutConstraint.Orientation): NSLayoutConstraint[];
  }

  // interface
  class NSLayoutManager extends NSObject /* implements NSSecureCoding, NSGlyphStorage */ {
    allowsNonContiguousLayout: boolean;
    setAllowsNonContiguousLayout(_: boolean)
    backgroundLayoutEnabled: boolean;
    setBackgroundLayoutEnabled(_: boolean)
    defaultAttachmentScaling: NSImageScaling;
    setDefaultAttachmentScaling(_: NSImageScaling)
    delegate: NSLayoutManagerDelegate;
    setDelegate(_: NSLayoutManagerDelegate)
    extraLineFragmentRect: CGRect;
    extraLineFragmentTextContainer: NSTextContainer;
    extraLineFragmentUsedRect: CGRect;
    firstTextView: NSTextView;
    glyphGenerator: NSGlyphGenerator;
    setGlyphGenerator(_: NSGlyphGenerator)
    hasNonContiguousLayout: boolean;
    limitsLayoutForSuspiciousContents: boolean;
    setLimitsLayoutForSuspiciousContents(_: boolean)
    numberOfGlyphs: number;
    showsControlCharacters: boolean;
    setShowsControlCharacters(_: boolean)
    showsInvisibleCharacters: boolean;
    setShowsInvisibleCharacters(_: boolean)
    textContainers: NSTextContainer[];
    textStorage: NSTextStorage;
    setTextStorage(_: NSTextStorage)
    textViewForBeginningOfSelection: NSTextView;
    typesetter: NSTypesetter;
    setTypesetter(_: NSTypesetter)
    typesetterBehavior: NSLayoutManager.TypesetterBehavior;
    setTypesetterBehavior(_: NSLayoutManager.TypesetterBehavior)
    usesDefaultHyphenation: boolean;
    setUsesDefaultHyphenation(_: boolean)
    usesFontLeading: boolean;
    setUsesFontLeading(_: boolean)
    CGGlyphAtIndex(at: number): number;
    CGGlyphAtIndexIsValidIndex(at: number, isValidIndex?: boolean): number;
    addTemporaryAttributeValueForCharacterRange(_: string, value: any, forCharacterRange: NSRange): void;
    addTemporaryAttributesForCharacterRange(_: Map<string, any>, forCharacterRange: NSRange): void;
    addTextContainer(_: NSTextContainer): void;
    attachmentSizeForGlyphAtIndex(forGlyphAt: number): CGSize;
    boundingRectForGlyphRangeInTextContainer(forGlyphRange: NSRange, in_: NSTextContainer): CGRect;
    boundsRectForTextBlockAtIndexEffectiveRange(for_: NSTextBlock, at: number, effectiveRange?: NSRange): CGRect;
    boundsRectForTextBlockGlyphRange(for_: NSTextBlock, glyphRange: NSRange): CGRect;
    characterIndexForGlyphAtIndex(at: number): number;
    characterIndexForPointInTextContainerFractionOfDistanceBetweenInsertionPoints(for_: CGPoint, in_: NSTextContainer, fractionOfDistanceBetweenInsertionPoints?: number): number;
    characterRangeForGlyphRangeActualGlyphRange(forGlyphRange: NSRange, actualGlyphRange?: NSRange): NSRange;
    defaultBaselineOffsetForFont(for_: NSFont): number;
    defaultLineHeightForFont(for_: NSFont): number;
    drawBackgroundForGlyphRangeAtPoint(forGlyphRange: NSRange, at: CGPoint): void;
    drawGlyphsForGlyphRangeAtPoint(forGlyphRange: NSRange, at: CGPoint): void;
    drawStrikethroughForGlyphRangeStrikethroughTypeBaselineOffsetLineFragmentRectLineFragmentGlyphRangeContainerOrigin(forGlyphRange: NSRange, strikethroughType: NSUnderlineStyle, baselineOffset: number, lineFragmentRect: CGRect, lineFragmentGlyphRange: NSRange, containerOrigin: CGPoint): void;
    drawUnderlineForGlyphRangeUnderlineTypeBaselineOffsetLineFragmentRectLineFragmentGlyphRangeContainerOrigin(forGlyphRange: NSRange, underlineType: NSUnderlineStyle, baselineOffset: number, lineFragmentRect: CGRect, lineFragmentGlyphRange: NSRange, containerOrigin: CGPoint): void;
    drawsOutsideLineFragmentForGlyphAtIndex(forGlyphAt: number): boolean;
    ensureGlyphsForCharacterRange(forCharacterRange: NSRange): void;
    ensureGlyphsForGlyphRange(forGlyphRange: NSRange): void;
    ensureLayoutForBoundingRectInTextContainer(forBoundingRect: CGRect, in_: NSTextContainer): void;
    ensureLayoutForCharacterRange(forCharacterRange: NSRange): void;
    ensureLayoutForGlyphRange(forGlyphRange: NSRange): void;
    ensureLayoutForTextContainer(for_: NSTextContainer): void;
    enumerateEnclosingRectsWithForGlyphRangeWithinSelectedGlyphRangeInUsing(forGlyphRange: NSRange, withinSelectedGlyphRange: NSRange, in_: NSTextContainer, using: (p1: CGRect, p2: boolean) => void): void;
    enumerateLineFragmentsWithForGlyphRangeUsing(forGlyphRange: NSRange, using: (p1: CGRect, p2: CGRect, p3: NSTextContainer, p4: NSRange, p5: boolean) => void): void;
    fillBackgroundRectArrayCountForCharacterRangeColor(_: NSRect, count: number, forCharacterRange: NSRange, color: NSColor): void;
    firstUnlaidCharacterIndex(): number;
    firstUnlaidGlyphIndex(): number;
    fractionOfDistanceThroughGlyphForPointInTextContainer(for_: CGPoint, in_: NSTextContainer): number;
    getFirstUnlaidCharacterIndexGlyphIndex(_?: number, glyphIndex?: number): void;
    getGlyphsInRangeGlyphsPropertiesCharacterIndexesBidiLevels(in_: NSRange, glyphs?: number, properties?: NSLayoutManager.GlyphProperty, characterIndexes?: number, bidiLevels?: string): number;
    getLineFragmentInsertionPointsForCharacterAtIndexAlternatePositionsInDisplayOrderPositionsCharacterIndexes(forCharacterAt: number, alternatePositions: boolean, inDisplayOrder: boolean, positions?: number, characterIndexes?: number): number;
    glyphAtIndex(at: number): number;
    glyphAtIndexIsValidIndex(at: number, isValidIndex?: boolean): number;
    glyphIndexForCharacterAtIndex(at: number): number;
    glyphIndexForPointInTextContainer(for_: CGPoint, in_: NSTextContainer): number;
    glyphIndexForPointInTextContainerFractionOfDistanceThroughGlyph(for_: CGPoint, in_: NSTextContainer, fractionOfDistanceThroughGlyph?: number): number;
    glyphRangeForBoundingRectInTextContainer(forBoundingRect: CGRect, in_: NSTextContainer): NSRange;
    glyphRangeForBoundingRectWithoutAdditionalLayoutInTextContainer(forBoundingRectWithoutAdditionalLayout: CGRect, in_: NSTextContainer): NSRange;
    glyphRangeForCharacterRangeActualCharacterRange(forCharacterRange: NSRange, actualCharacterRange?: NSRange): NSRange;
    glyphRangeForTextContainer(for_: NSTextContainer): NSRange;
    insertTextContainerAtIndex(_: NSTextContainer, at: number): void;
    invalidateDisplayForCharacterRange(forCharacterRange: NSRange): void;
    invalidateDisplayForGlyphRange(forGlyphRange: NSRange): void;
    invalidateGlyphsForCharacterRangeChangeInLengthActualCharacterRange(forCharacterRange: NSRange, changeInLength: number, actualCharacterRange?: NSRange): void;
    invalidateLayoutForCharacterRangeActualCharacterRange(forCharacterRange: NSRange, actualCharacterRange?: NSRange): void;
    isValidGlyphIndex(_: number): boolean;
    layoutManagerOwnsFirstResponderInWindow(in_: NSWindow): boolean;
    layoutRectForTextBlockAtIndexEffectiveRange(for_: NSTextBlock, at: number, effectiveRange?: NSRange): CGRect;
    layoutRectForTextBlockGlyphRange(for_: NSTextBlock, glyphRange: NSRange): CGRect;
    lineFragmentRectForGlyphAtIndexEffectiveRange(forGlyphAt: number, effectiveRange?: NSRange): CGRect;
    lineFragmentRectForGlyphAtIndexEffectiveRangeWithoutAdditionalLayout(forGlyphAt: number, effectiveRange?: NSRange, withoutAdditionalLayout?: boolean): CGRect;
    lineFragmentUsedRectForGlyphAtIndexEffectiveRange(forGlyphAt: number, effectiveRange?: NSRange): CGRect;
    lineFragmentUsedRectForGlyphAtIndexEffectiveRangeWithoutAdditionalLayout(forGlyphAt: number, effectiveRange?: NSRange, withoutAdditionalLayout?: boolean): CGRect;
    locationForGlyphAtIndex(forGlyphAt: number): CGPoint;
    notShownAttributeForGlyphAtIndex(forGlyphAt: number): boolean;
    processEditingForTextStorageEditedRangeChangeInLengthInvalidatedRange(for_: NSTextStorage, edited: NSTextStorageEditActions, range: NSRange, changeInLength: number, invalidatedRange: NSRange): void;
    propertyForGlyphAtIndex(at: number): NSLayoutManager.GlyphProperty;
    rangeOfNominallySpacedGlyphsContainingIndex(ofNominallySpacedGlyphsContaining: number): NSRange;
    rectArrayForCharacterRangeWithinSelectedCharacterRangeInTextContainerRectCount(forCharacterRange: NSRange, withinSelectedCharacterRange: NSRange, in_: NSTextContainer, rectCount: number): NSRect;
    rectArrayForGlyphRangeWithinSelectedGlyphRangeInTextContainerRectCount(forGlyphRange: NSRange, withinSelectedGlyphRange: NSRange, in_: NSTextContainer, rectCount: number): NSRect;
    removeTemporaryAttributeForCharacterRange(_: string, forCharacterRange: NSRange): void;
    removeTextContainerAtIndex(at: number): void;
    replaceTextStorage(_: NSTextStorage): void;
    rulerAccessoryViewForTextViewParagraphStyleRulerEnabled(for_: NSTextView, paragraphStyle: NSParagraphStyle, ruler: NSRulerView, enabled: boolean): NSView;
    rulerMarkersForTextViewParagraphStyleRuler(for_: NSTextView, paragraphStyle: NSParagraphStyle, ruler: NSRulerView): NSRulerMarker[];
    setAttachmentSizeForGlyphRange(_: CGSize, forGlyphRange: NSRange): void;
    setBoundsRectForTextBlockGlyphRange(_: CGRect, for_: NSTextBlock, glyphRange: NSRange): void;
    setDrawsOutsideLineFragmentForGlyphAtIndex(_: boolean, forGlyphAt: number): void;
    setExtraLineFragmentRectUsedRectTextContainer(_: CGRect, usedRect: CGRect, textContainer: NSTextContainer): void;
    setGlyphsPropertiesCharacterIndexesFontForGlyphRange(_: number, properties: NSLayoutManager.GlyphProperty, characterIndexes: number, font: NSFont, forGlyphRange: NSRange): void;
    setLayoutRectForTextBlockGlyphRange(_: CGRect, for_: NSTextBlock, glyphRange: NSRange): void;
    setLineFragmentRectForGlyphRangeUsedRect(_: CGRect, forGlyphRange: NSRange, usedRect: CGRect): void;
    setLocationForStartOfGlyphRange(_: CGPoint, forStartOfGlyphRange: NSRange): void;
    setNotShownAttributeForGlyphAtIndex(_: boolean, forGlyphAt: number): void;
    setTemporaryAttributesForCharacterRange(_: Map<string, any>, forCharacterRange: NSRange): void;
    setTextContainerForGlyphRange(_: NSTextContainer, forGlyphRange: NSRange): void;
    showAttachmentCellInRectCharacterIndex(_: NSCell, in_: CGRect, characterIndex: number): void;
    showCGGlyphsPositionsCountFontTextMatrixAttributesInContext(_: number, positions: NSPoint, count: number, font: NSFont, textMatrix: CGAffineTransform, attributes: Map<string, any>, in_: any): void;
    strikethroughGlyphRangeStrikethroughTypeLineFragmentRectLineFragmentGlyphRangeContainerOrigin(_: NSRange, strikethroughType: NSUnderlineStyle, lineFragmentRect: CGRect, lineFragmentGlyphRange: NSRange, containerOrigin: CGPoint): void;
    temporaryAttributeAtCharacterIndexEffectiveRange(_: string, atCharacterIndex: number, effectiveRange?: NSRange): any;
    temporaryAttributeAtCharacterIndexLongestEffectiveRangeInRange(_: string, atCharacterIndex: number, longestEffectiveRange?: NSRange, in_?: NSRange): any;
    temporaryAttributesAtCharacterIndexEffectiveRange(atCharacterIndex: number, effectiveRange?: NSRange): Map<string, any>;
    temporaryAttributesAtCharacterIndexLongestEffectiveRangeInRange(atCharacterIndex: number, longestEffectiveRange?: NSRange, in_?: NSRange): Map<string, any>;
    textContainerChangedGeometry(_: NSTextContainer): void;
    textContainerChangedTextView(_: NSTextContainer): void;
    textContainerForGlyphAtIndexEffectiveRange(forGlyphAt: number, effectiveRange?: NSRange): NSTextContainer;
    textContainerForGlyphAtIndexEffectiveRangeWithoutAdditionalLayout(forGlyphAt: number, effectiveRange?: NSRange, withoutAdditionalLayout?: boolean): NSTextContainer;
    truncatedGlyphRangeInLineFragmentForGlyphAtIndex(inLineFragmentForGlyphAt: number): NSRange;
    underlineGlyphRangeUnderlineTypeLineFragmentRectLineFragmentGlyphRangeContainerOrigin(_: NSRange, underlineType: NSUnderlineStyle, lineFragmentRect: CGRect, lineFragmentGlyphRange: NSRange, containerOrigin: CGPoint): void;
    usedRectForTextContainer(for_: NSTextContainer): CGRect;
  }

  interface NSLayoutManagerDelegate extends NSObject {
    // instance method
    layoutManagerLineSpacingAfterGlyphAtIndexWithProposedLineFragmentRect?(_: NSLayoutManager, lineSpacingAfterGlyphAt: number, withProposedLineFragmentRect: CGRect): number;
    // instance method
    layoutManagerParagraphSpacingBeforeGlyphAtIndexWithProposedLineFragmentRect?(_: NSLayoutManager, paragraphSpacingBeforeGlyphAt: number, withProposedLineFragmentRect: CGRect): number;
    // instance method
    layoutManagerParagraphSpacingAfterGlyphAtIndexWithProposedLineFragmentRect?(_: NSLayoutManager, paragraphSpacingAfterGlyphAt: number, withProposedLineFragmentRect: CGRect): number;
    // instance method
    layoutManagerShouldUseActionForControlCharacterAtIndex?(_: NSLayoutManager, shouldUse: NSLayoutManager.ControlCharacterAction, forControlCharacterAt: number): NSLayoutManager.ControlCharacterAction;
    // instance method
    layoutManagerShouldBreakLineByWordBeforeCharacterAtIndex?(_: NSLayoutManager, shouldBreakLineByWordBeforeCharacterAt: number): boolean;
    // instance method
    layoutManagerShouldBreakLineByHyphenatingBeforeCharacterAtIndex?(_: NSLayoutManager, shouldBreakLineByHyphenatingBeforeCharacterAt: number): boolean;
    // instance method
    layoutManagerBoundingBoxForControlGlyphAtIndexForTextContainerProposedLineFragmentGlyphPositionCharacterIndex?(_: NSLayoutManager, boundingBoxForControlGlyphAt: number, for_: NSTextContainer, proposedLineFragment: CGRect, glyphPosition: CGPoint, characterIndex: number): CGRect;
    // instance method
    layoutManagerShouldSetLineFragmentRectLineFragmentUsedRectBaselineOffsetInTextContainerForGlyphRange?(_: NSLayoutManager, shouldSetLineFragmentRect: NSRect, lineFragmentUsedRect: NSRect, baselineOffset: number, in_: NSTextContainer, forGlyphRange: NSRange): boolean;
    // instance method
    layoutManagerDidCompleteLayoutForTextContainerAtEnd?(_: NSLayoutManager, didCompleteLayoutFor?: NSTextContainer, atEnd?: boolean): void;
    // instance method
    layoutManagerTextContainerDidChangeGeometryFromSize?(_: NSLayoutManager, textContainer: NSTextContainer, didChangeGeometryFrom: CGSize): void;
    // instance method
    layoutManagerShouldGenerateGlyphsPropertiesCharacterIndexesFontForGlyphRange?(_: NSLayoutManager, shouldGenerateGlyphs: number, properties: NSLayoutManager.GlyphProperty, characterIndexes: number, font: NSFont, forGlyphRange: NSRange): number;
    // instance method
    layoutManagerShouldUseTemporaryAttributesForDrawingToScreenAtCharacterIndexEffectiveRange?(_: NSLayoutManager, shouldUseTemporaryAttributes: Map<string, any>, forDrawingToScreen: boolean, atCharacterIndex: number, effectiveRange?: NSRange): Map<string, any>;
    // instance method
    layoutManagerDidInvalidateLayout?(_: NSLayoutManager): void;
  }

  // interface
  class NSLayoutXAxisAnchor extends NSLayoutAnchor<NSLayoutXAxisAnchor> {
    anchorWithOffsetToAnchor(to: NSLayoutXAxisAnchor): NSLayoutDimension;
  }

  // interface
  class NSLayoutYAxisAnchor extends NSLayoutAnchor<NSLayoutYAxisAnchor> {
    anchorWithOffsetToAnchor(to: NSLayoutYAxisAnchor): NSLayoutDimension;
  }

  // interface
  class NSLevelIndicator extends NSControl {
    criticalFillColor: NSColor;
    setCriticalFillColor(_: NSColor)
    criticalValue: number;
    setCriticalValue(_: number)
    drawsTieredCapacityLevels: boolean;
    setDrawsTieredCapacityLevels(_: boolean)
    isEditable: boolean;
    setEditable(_: boolean)
    fillColor: NSColor;
    setFillColor(_: NSColor)
    levelIndicatorStyle: NSLevelIndicator.Style;
    setLevelIndicatorStyle(_: NSLevelIndicator.Style)
    maxValue: number;
    setMaxValue(_: number)
    minValue: number;
    setMinValue(_: number)
    numberOfMajorTickMarks: number;
    setNumberOfMajorTickMarks(_: number)
    numberOfTickMarks: number;
    setNumberOfTickMarks(_: number)
    placeholderVisibility: NSLevelIndicator.PlaceholderVisibility;
    setPlaceholderVisibility(_: NSLevelIndicator.PlaceholderVisibility)
    ratingImage: NSImage;
    setRatingImage(_: NSImage)
    ratingPlaceholderImage: NSImage;
    setRatingPlaceholderImage(_: NSImage)
    tickMarkPosition: NSSlider.TickMarkPosition;
    setTickMarkPosition(_: NSSlider.TickMarkPosition)
    warningFillColor: NSColor;
    setWarningFillColor(_: NSColor)
    warningValue: number;
    setWarningValue(_: number)
    rectOfTickMarkAtIndex(at: number): CGRect;
    tickMarkValueAtIndex(at: number): number;
  }

  // interface
  class NSLevelIndicatorCell extends NSActionCell {
    criticalValue: number;
    setCriticalValue(_: number)
    levelIndicatorStyle: NSLevelIndicator.Style;
    setLevelIndicatorStyle(_: NSLevelIndicator.Style)
    maxValue: number;
    setMaxValue(_: number)
    minValue: number;
    setMinValue(_: number)
    numberOfMajorTickMarks: number;
    setNumberOfMajorTickMarks(_: number)
    numberOfTickMarks: number;
    setNumberOfTickMarks(_: number)
    tickMarkPosition: NSSlider.TickMarkPosition;
    setTickMarkPosition(_: NSSlider.TickMarkPosition)
    warningValue: number;
    setWarningValue(_: number)
    static createWithLevelIndicatorStyle(levelIndicatorStyle: NSLevelIndicator.Style): NSLevelIndicatorCell;
    rectOfTickMarkAtIndex(at: number): CGRect;
    tickMarkValueAtIndex(at: number): number;
  }

  // interface
  class NSMagnificationGestureRecognizer extends NSGestureRecognizer {
    magnification: number;
    setMagnification(_: number)
  }

  // interface
  class NSMatrix extends NSControl /* implements NSUserInterfaceValidations, NSViewToolTipOwner */ {
    allowsEmptySelection: boolean;
    setAllowsEmptySelection(_: boolean)
    autorecalculatesCellSize: boolean;
    setAutorecalculatesCellSize(_: boolean)
    isAutoscroll: boolean;
    setAutoscroll(_: boolean)
    autosizesCells: boolean;
    setAutosizesCells(_: boolean)
    backgroundColor: NSColor;
    setBackgroundColor(_: NSColor)
    cellBackgroundColor: NSColor;
    setCellBackgroundColor(_: NSColor)
    cellClass: typeof NSObject;
    setCellClass(_: typeof NSObject)
    cellSize: CGSize;
    setCellSize(_: CGSize)
    cells: NSCell[];
    delegate: NSMatrixDelegate;
    setDelegate(_: NSMatrixDelegate)
    doubleAction: string;
    setDoubleAction(_: string)
    drawsBackground: boolean;
    setDrawsBackground(_: boolean)
    drawsCellBackground: boolean;
    setDrawsCellBackground(_: boolean)
    intercellSpacing: CGSize;
    setIntercellSpacing(_: CGSize)
    keyCell: NSCell;
    setKeyCell(_: NSCell)
    mode: NSMatrix.Mode;
    setMode(_: NSMatrix.Mode)
    mouseDownFlags: number;
    numberOfColumns: number;
    numberOfRows: number;
    prototype: NSCell;
    setPrototype(_: NSCell)
    selectedCells: NSCell[];
    selectedColumn: number;
    selectedRow: number;
    isSelectionByRect: boolean;
    setSelectionByRect(_: boolean)
    tabKeyTraversesCells: boolean;
    setTabKeyTraversesCells(_: boolean)
    addColumn(): void;
    addColumnWithCells(with_: NSCell[]): void;
    addRow(): void;
    addRowWithCells(with_: NSCell[]): void;
    cellAtRowColumn(atRow: number, column: number): NSCell;
    cellFrameAtRowColumn(atRow: number, column: number): CGRect;
    cellWithTag(withTag: number): NSCell;
    deselectAllCells(): void;
    deselectSelectedCell(): void;
    drawCellAtRowColumn(atRow: number, column: number): void;
    getNumberOfRowsColumns(_?: number, columns?: number): void;
    getRowColumnForPoint(_: number, column: number, for_: CGPoint): boolean;
    getRowColumnOfCell(_: number, column: number, of: NSCell): boolean;
    highlightCellAtRowColumn(_: boolean, atRow: number, column: number): void;
    static createWithFrameModeCellClassNumberOfRowsNumberOfColumns(frame: CGRect, mode: NSMatrix.Mode, cellClass?: typeof NSObject, numberOfRows?: number, numberOfColumns?: number): NSMatrix;
    static createWithFrameModePrototypeNumberOfRowsNumberOfColumns(frame: CGRect, mode: NSMatrix.Mode, prototype: NSCell, numberOfRows: number, numberOfColumns: number): NSMatrix;
    insertColumn(_: number): void;
    insertColumnWithCells(_: number, with_?: NSCell[]): void;
    insertRow(_: number): void;
    insertRowWithCells(_: number, with_?: NSCell[]): void;
    makeCellAtRowColumn(atRow: number, column: number): NSCell;
    putCellAtRowColumn(_: NSCell, atRow: number, column: number): void;
    removeColumn(_: number): void;
    removeRow(_: number): void;
    renewRowsColumns(_: number, columns: number): void;
    scrollCellToVisibleAtRowColumn(atRow: number, column: number): void;
    selectCellAtRowColumn(atRow: number, column: number): void;
    selectCellWithTag(withTag: number): boolean;
    selectText(_?: any): void;
    selectTextAtRowColumn(atRow: number, column: number): NSCell;
    sendAction(): boolean;
    sendActionToForAllCells(_: string, to: any, forAllCells: boolean): void;
    sendDoubleAction(): void;
    setScrollable(_: boolean): void;
    setSelectionFromToAnchorHighlight(_: number, to: number, anchor: number, highlight: boolean): void;
    setStateAtRowColumn(_: number, atRow: number, column: number): void;
    setToolTipForCell(_?: string, for_?: NSCell): void;
    setValidateSize(_: boolean): void;
    sizeToCells(): void;
    sortWithUsingContext(using?: (p1: any, p2: any, p3: any) => number, context?: any): void;
    sortUsingSelector(using: string): void;
    textDidBeginEditing(_: NSNotification): void;
    textDidChange(_: NSNotification): void;
    textDidEndEditing(_: NSNotification): void;
    textShouldBeginEditing(_: NSText): boolean;
    textShouldEndEditing(_: NSText): boolean;
    toolTipForCell(for_: NSCell): string;
  }

  type NSMatrixDelegate = NSControlTextEditingDelegate

  // interface
  class NSMediaLibraryBrowserController extends NSObject {
    frame: CGRect;
    setFrame(_: CGRect)
    mediaLibraries: NSMediaLibraryBrowserController.Library;
    setMediaLibraries(_: NSMediaLibraryBrowserController.Library)
    isVisible: boolean;
    setVisible(_: boolean)
    static sharedMediaLibraryBrowserController: NSMediaLibraryBrowserController;
    togglePanel(_?: any): void;
  }

  // interface
  class NSMenu extends NSObject /* implements NSAccessibility, NSAccessibilityElement, NSCoding, NSCopying, NSUserInterfaceItemIdentification */ {
    static menuBarVisible(): boolean;
    static popUpContextMenuWithEventForView(_: NSMenu, with_: NSEvent, for_: NSView): void;
    static popUpContextMenuWithEventForViewWithFont(_: NSMenu, with_: NSEvent, for_: NSView, with_2?: NSFont): void;
    static setMenuBarVisible(_: boolean): void;
    allowsContextMenuPlugIns: boolean;
    setAllowsContextMenuPlugIns(_: boolean)
    autoenablesItems: boolean;
    setAutoenablesItems(_: boolean)
    delegate: NSMenuDelegate;
    setDelegate(_: NSMenuDelegate)
    font: NSFont;
    setFont(_: NSFont)
    highlightedItem: NSMenuItem;
    itemArray: NSMenuItem[];
    setItemArray(_: NSMenuItem[])
    menuBarHeight: number;
    minimumWidth: number;
    setMinimumWidth(_: number)
    numberOfItems: number;
    propertiesToUpdate: NSMenu.Properties;
    showsStateColumn: boolean;
    setShowsStateColumn(_: boolean)
    size: CGSize;
    supermenu: NSMenu;
    setSupermenu(_: NSMenu)
    title: string;
    setTitle(_: string)
    userInterfaceLayoutDirection: NSUserInterfaceLayoutDirection;
    setUserInterfaceLayoutDirection(_: NSUserInterfaceLayoutDirection)
    addItem(_: NSMenuItem): void;
    addItemWithTitleActionKeyEquivalent(withTitle: string, action?: string, keyEquivalent?: string): NSMenuItem;
    cancelTracking(): void;
    cancelTrackingWithoutAnimation(): void;
    indexOfItem(of: NSMenuItem): number;
    indexOfItemWithRepresentedObject(withRepresentedObject?: any): number;
    indexOfItemWithSubmenu(withSubmenu?: NSMenu): number;
    indexOfItemWithTag(withTag: number): number;
    indexOfItemWithTargetAndAction(withTarget?: any, andAction?: string): number;
    indexOfItemWithTitle(withTitle: string): number;
    static createWithTitle(title: string): NSMenu;
    insertItemAtIndex(_: NSMenuItem, at: number): void;
    insertItemWithTitleActionKeyEquivalentAtIndex(withTitle: string, action?: string, keyEquivalent?: string, at?: number): NSMenuItem;
    itemAtIndex(at: number): NSMenuItem;
    itemChanged(_: NSMenuItem): void;
    itemWithTag(withTag: number): NSMenuItem;
    itemWithTitle(withTitle: string): NSMenuItem;
    performActionForItemAtIndex(at: number): void;
    performKeyEquivalent(with_: NSEvent): boolean;
    popUpMenuPositioningItemAtLocationInView(positioning?: NSMenuItem, at?: CGPoint, in_?: NSView): boolean;
    removeAllItems(): void;
    removeItem(_: NSMenuItem): void;
    removeItemAtIndex(at: number): void;
    setSubmenuForItem(_?: NSMenu, for_?: NSMenuItem): void;
    submenuAction(_?: any): void;
    update(): void;
  }

  interface NSMenuDelegate extends NSObject {
    // instance method
    confinementRectForMenuOnScreen?(for_: NSMenu, on?: NSScreen): CGRect;
    // instance method
    menuUpdateItemAtIndexShouldCancel?(_: NSMenu, update: NSMenuItem, at: number, shouldCancel: boolean): boolean;
    // instance method
    menuWillHighlightItem?(_: NSMenu, willHighlight?: NSMenuItem): void;
    // instance method
    menuDidClose?(_: NSMenu): void;
    // instance method
    menuHasKeyEquivalentForEventTargetAction?(_: NSMenu, for_: NSEvent, target?: any, action?: string): boolean;
    // instance method
    menuNeedsUpdate?(_: NSMenu): void;
    // instance method
    menuWillOpen?(_: NSMenu): void;
    // instance method
    numberOfItemsInMenu?(in_: NSMenu): number;
  }

  // interface
  class NSMenuItem extends NSObject /* implements NSAccessibility, NSAccessibilityElement, NSCoding, NSCopying, NSUserInterfaceItemIdentification, NSValidatedUserInterfaceItem */ {
    static separatorItem(): NSMenuItem;
    action: string;
    setAction(_: string)
    allowsKeyEquivalentWhenHidden: boolean;
    setAllowsKeyEquivalentWhenHidden(_: boolean)
    isAlternate: boolean;
    setAlternate(_: boolean)
    attributedTitle: NSAttributedString;
    setAttributedTitle(_: NSAttributedString)
    isEnabled: boolean;
    setEnabled(_: boolean)
    hasSubmenu: boolean;
    isHidden: boolean;
    setHidden(_: boolean)
    isHiddenOrHasHiddenAncestor: boolean;
    isHighlighted: boolean;
    image: NSImage;
    setImage(_: NSImage)
    indentationLevel: number;
    setIndentationLevel(_: number)
    keyEquivalent: string;
    setKeyEquivalent(_: string)
    keyEquivalentModifierMask: NSEvent.ModifierFlags;
    setKeyEquivalentModifierMask(_: NSEvent.ModifierFlags)
    menu: NSMenu;
    setMenu(_: NSMenu)
    mixedStateImage: NSImage;
    setMixedStateImage(_: NSImage)
    offStateImage: NSImage;
    setOffStateImage(_: NSImage)
    onStateImage: NSImage;
    setOnStateImage(_: NSImage)
    parentItem: NSMenuItem;
    representedObject: any;
    setRepresentedObject(_: any)
    isSeparatorItem: boolean;
    state: number;
    setState(_: number)
    submenu: NSMenu;
    setSubmenu(_: NSMenu)
    tag: number;
    setTag(_: number)
    target: any;
    setTarget(_: any)
    title: string;
    setTitle(_: string)
    toolTip: string;
    setToolTip(_: string)
    userKeyEquivalent: string;
    view: NSView;
    setView(_: NSView)
    static usesUserKeyEquivalents: boolean;
    setUsesUserKeyEquivalents(_: boolean)
    static createWithTitleActionKeyEquivalent(title: string, action?: string, keyEquivalent?: string): NSMenuItem;
  }

  // interface
  class NSMenuItemCell extends NSButtonCell {
    imageWidth: number;
    keyEquivalentWidth: number;
    menuItem: NSMenuItem;
    setMenuItem(_: NSMenuItem)
    needsDisplay: boolean;
    setNeedsDisplay(_: boolean)
    needsSizing: boolean;
    setNeedsSizing(_: boolean)
    stateImageWidth: number;
    titleWidth: number;
    calcSize(): void;
    drawBorderAndBackgroundWithFrameInView(withFrame: CGRect, in_: NSView): void;
    drawKeyEquivalentWithFrameInView(withFrame: CGRect, in_: NSView): void;
    drawSeparatorItemWithFrameInView(withFrame: CGRect, in_: NSView): void;
    drawStateImageWithFrameInView(withFrame: CGRect, in_: NSView): void;
    keyEquivalentRectForBounds(forBounds: CGRect): CGRect;
    stateImageRectForBounds(forBounds: CGRect): CGRect;
  }

  interface NSMenuItemValidation extends NSObject {
    // instance method
    validateMenuItem(_: NSMenuItem): boolean;
  }

  // interface
  class NSMenuToolbarItem extends NSToolbarItem {
    menu: NSMenu;
    setMenu(_: NSMenu)
    showsIndicator: boolean;
    setShowsIndicator(_: boolean)
  }

  // interface
  class NSMutableFontCollection extends NSFontCollection {
    static fontCollectionWithAllAvailableDescriptors: NSMutableFontCollection;
    addQueryForDescriptors(for_: NSFontDescriptor[]): void;
    removeQueryForDescriptors(for_: NSFontDescriptor[]): void;
  }

  // interface
  class NSMutableParagraphStyle extends NSParagraphStyle {
    addTabStop(_: NSTextTab): void;
    removeTabStop(_: NSTextTab): void;
    setParagraphStyle(_: NSParagraphStyle): void;
  }

  // interface
  class NSNib extends NSObject /* implements NSCoding */ {
    static createWithNibDataBundle(nibData: NSData, bundle?: Bundle): NSNib;
    static createWithNibNamedBundle(nibNamed: string, bundle?: Bundle): NSNib;
    instantiateWithOwnerTopLevelObjects(withOwner?: any, topLevelObjects?: any[]): boolean;
  }

  // export function NSNumberOfColorComponents(colorSpaceName: string): number;

  // interface
  class NSObjectController extends NSController {
    automaticallyPreparesContent: boolean;
    setAutomaticallyPreparesContent(_: boolean)
    canAdd: boolean;
    canRemove: boolean;
    content: any;
    setContent(_: any)
    isEditable: boolean;
    setEditable(_: boolean)
    entityName: string;
    setEntityName(_: string)
    fetchPredicate: NSPredicate;
    setFetchPredicate(_: NSPredicate)
    managedObjectContext: NSManagedObjectContext;
    setManagedObjectContext(_: NSManagedObjectContext)
    objectClass: typeof NSObject;
    setObjectClass(_: typeof NSObject)
    selectedObjects: any[];
    selection: any;
    usesLazyFetching: boolean;
    setUsesLazyFetching(_: boolean)
    add(_?: any): void;
    addObject(_: any): void;
    defaultFetchRequest(): NSFetchRequest<any>;
    fetch(_?: any): void;
    fetchWithRequestMergeError(merge?: NSFetchRequest<any>, error?: boolean): boolean;
    static createWithContent(content?: any): NSObjectController;
    newObject(): any;
    prepareContent(): void;
    remove(_?: any): void;
    removeObject(_: any): void;
    validateUserInterfaceItem(_: NSValidatedUserInterfaceItem): boolean;
  }

  // interface
  class NSOpenPanel extends NSSavePanel {
    URLs: NSURL[];
    isAccessoryViewDisclosed: boolean;
    setAccessoryViewDisclosed(_: boolean)
    allowsMultipleSelection: boolean;
    setAllowsMultipleSelection(_: boolean)
    canChooseDirectories: boolean;
    setCanChooseDirectories(_: boolean)
    canChooseFiles: boolean;
    setCanChooseFiles(_: boolean)
    canDownloadUbiquitousContents: boolean;
    setCanDownloadUbiquitousContents(_: boolean)
    canResolveUbiquitousConflicts: boolean;
    setCanResolveUbiquitousConflicts(_: boolean)
    resolvesAliases: boolean;
    setResolvesAliases(_: boolean)
  }

  interface NSOpenSavePanelDelegate extends NSObject {
    // instance method
    panelShouldEnableURL?(_: any, shouldEnable: NSURL): boolean;
    // instance method
    panelDidChangeToDirectoryURL?(_: any, didChangeToDirectoryURL?: NSURL): void;
    // instance method
    panelUserEnteredFilenameConfirmed?(_: any, userEnteredFilename: string, confirmed: boolean): string;
    // instance method
    panelValidateURLError?(validateURL: any, error: NSURL): boolean;
    // instance method
    panelWillExpand?(_: any, willExpand: boolean): void;
    // instance method
    panelSelectionDidChange?(_?: any): void;
  }

  // interface
  class NSOutlineView extends NSTableView /* implements NSAccessibilityOutline */ {
    autoresizesOutlineColumn: boolean;
    setAutoresizesOutlineColumn(_: boolean)
    autosaveExpandedItems: boolean;
    setAutosaveExpandedItems(_: boolean)
    indentationMarkerFollowsCell: boolean;
    setIndentationMarkerFollowsCell(_: boolean)
    indentationPerLevel: number;
    setIndentationPerLevel(_: number)
    outlineTableColumn: NSTableColumn;
    setOutlineTableColumn(_: NSTableColumn)
    stronglyReferencesItems: boolean;
    setStronglyReferencesItems(_: boolean)
    childOfItem(_: number, ofItem?: any): any;
    childIndexForItem(forItem: any): number;
    collapseItem(_?: any): void;
    collapseItemCollapseChildren(_?: any, collapseChildren?: boolean): void;
    expandItem(_?: any): void;
    expandItemExpandChildren(_?: any, expandChildren?: boolean): void;
    frameOfOutlineCellAtRow(atRow: number): CGRect;
    insertItemsAtIndexesInParentWithAnimation(at: NSIndexSet, inParent?: any, withAnimation?: NSTableView.AnimationOptions): void;
    isExpandable(_?: any): boolean;
    isItemExpanded(_?: any): boolean;
    itemAtRow(atRow: number): any;
    levelForItem(forItem?: any): number;
    levelForRow(forRow: number): number;
    moveItemAtIndexInParentToIndexInParent(at: number, inParent?: any, to?: number, inParent2?: any): void;
    numberOfChildrenOfItem(ofItem?: any): number;
    parentForItem(forItem?: any): any;
    reloadItem(_?: any): void;
    reloadItemReloadChildren(_?: any, reloadChildren?: boolean): void;
    removeItemsAtIndexesInParentWithAnimation(at: NSIndexSet, inParent?: any, withAnimation?: NSTableView.AnimationOptions): void;
    rowForItem(forItem?: any): number;
    setDropItemDropChildIndex(_?: any, dropChildIndex?: number): void;
    shouldCollapseAutoExpandedItemsForDeposited(forDeposited: boolean): boolean;
  }

  interface NSOutlineViewDataSource extends NSObject {
    // instance method
    outlineViewObjectValueForTableColumnByItem?(_: NSOutlineView, objectValueFor?: NSTableColumn, byItem?: any): any;
    // instance method
    outlineViewSetObjectValueForTableColumnByItem?(_: NSOutlineView, setObjectValue?: any, for_?: NSTableColumn, byItem?: any): void;
    // instance method
    outlineViewDraggingSessionWillBeginAtPointForItems?(_: NSOutlineView, draggingSession: NSDraggingSession, willBeginAt: CGPoint, forItems: any[]): void;
    // instance method
    outlineViewDraggingSessionEndedAtPointOperation?(_: NSOutlineView, draggingSession: NSDraggingSession, endedAt: CGPoint, operation: NSDragOperation): void;
    // instance method
    outlineViewWriteItemsToPasteboard?(_: NSOutlineView, writeItems: any[], to: NSPasteboard): boolean;
    // instance method
    outlineViewAcceptDropItemChildIndex?(_: NSOutlineView, acceptDrop: NSDraggingInfo, item?: any, childIndex?: number): boolean;
    // instance method
    outlineViewChildOfItem?(_: NSOutlineView, child: number, ofItem?: any): any;
    // instance method
    outlineViewIsItemExpandable?(_: NSOutlineView, isItemExpandable: any): boolean;
    // instance method
    outlineViewItemForPersistentObject?(_: NSOutlineView, itemForPersistentObject: any): any;
    // instance method
    outlineViewNumberOfChildrenOfItem?(_: NSOutlineView, numberOfChildrenOfItem?: any): number;
    // instance method
    outlineViewPasteboardWriterForItem?(_: NSOutlineView, pasteboardWriterForItem: any): NSPasteboardWriting;
    // instance method
    outlineViewPersistentObjectForItem?(_: NSOutlineView, persistentObjectForItem?: any): any;
    // instance method
    outlineViewSortDescriptorsDidChange?(_: NSOutlineView, sortDescriptorsDidChange: NSSortDescriptor[]): void;
    // instance method
    outlineViewUpdateDraggingItemsForDrag?(_: NSOutlineView, updateDraggingItemsForDrag: NSDraggingInfo): void;
    // instance method
    outlineViewValidateDropProposedItemProposedChildIndex?(_: NSOutlineView, validateDrop: NSDraggingInfo, proposedItem?: any, proposedChildIndex?: number): NSDragOperation;
  }

  interface NSOutlineViewDelegate extends NSControlTextEditingDelegate {
    // instance method
    outlineViewViewForTableColumnItem?(_: NSOutlineView, viewFor?: NSTableColumn, item?: any): NSView;
    // instance method
    outlineViewWillDisplayOutlineCellForTableColumnItem?(_: NSOutlineView, willDisplayOutlineCell: any, for_?: NSTableColumn, item?: any): void;
    // instance method
    outlineViewDidAddRowViewForRow?(_: NSOutlineView, didAdd: NSTableRowView, forRow: number): void;
    // instance method
    outlineViewDidRemoveRowViewForRow?(_: NSOutlineView, didRemove: NSTableRowView, forRow: number): void;
    // instance method
    outlineViewWillDisplayCellForTableColumnItem?(_: NSOutlineView, willDisplayCell: any, for_?: NSTableColumn, item?: any): void;
    // instance method
    outlineViewShouldEditTableColumnItem?(_: NSOutlineView, shouldEdit?: NSTableColumn, item?: any): boolean;
    // instance method
    outlineViewDataCellForTableColumnItem?(_: NSOutlineView, dataCellFor?: NSTableColumn, item?: any): NSCell;
    // instance method
    outlineViewShouldTrackCellForTableColumnItem?(_: NSOutlineView, shouldTrackCell: NSCell, for_?: NSTableColumn, item?: any): boolean;
    // instance method
    outlineViewShouldShowCellExpansionForTableColumnItem?(_: NSOutlineView, shouldShowCellExpansionFor?: NSTableColumn, item?: any): boolean;
    // instance method
    outlineViewShouldSelectTableColumn?(_: NSOutlineView, shouldSelect?: NSTableColumn): boolean;
    // instance method
    outlineViewMouseDownInHeaderOfTableColumn?(_: NSOutlineView, mouseDownInHeaderOf: NSTableColumn): void;
    // instance method
    outlineViewDidClickTableColumn?(_: NSOutlineView, didClick: NSTableColumn): void;
    // instance method
    outlineViewDidDragTableColumn?(_: NSOutlineView, didDrag: NSTableColumn): void;
    // instance method
    outlineViewToolTipForCellRectTableColumnItemMouseLocation?(_: NSOutlineView, toolTipFor: NSCell, rect: NSRect, tableColumn?: NSTableColumn, item?: any, mouseLocation?: CGPoint): string;
    // instance method
    outlineViewShouldTypeSelectForEventWithCurrentSearchString?(_: NSOutlineView, shouldTypeSelectFor: NSEvent, withCurrentSearch?: string): boolean;
    // instance method
    outlineViewTypeSelectStringForTableColumnItem?(_: NSOutlineView, typeSelectStringFor?: NSTableColumn, item?: any): string;
    // instance method
    outlineViewNextTypeSelectMatchFromItemToItemForString?(_: NSOutlineView, nextTypeSelectMatchFromItem: any, toItem: any, for_: string): any;
    // instance method
    outlineViewHeightOfRowByItem?(_: NSOutlineView, heightOfRowByItem: any): number;
    // instance method
    outlineViewIsGroupItem?(_: NSOutlineView, isGroupItem: any): boolean;
    // instance method
    outlineViewRowViewForItem?(_: NSOutlineView, rowViewForItem: any): NSTableRowView;
    // instance method
    outlineViewSelectionIndexesForProposedSelection?(_: NSOutlineView, selectionIndexesForProposedSelection: NSIndexSet): NSIndexSet;
    // instance method
    outlineViewShouldCollapseItem?(_: NSOutlineView, shouldCollapseItem: any): boolean;
    // instance method
    outlineViewShouldExpandItem?(_: NSOutlineView, shouldExpandItem: any): boolean;
    // instance method
    outlineViewShouldReorderColumnToColumn?(_: NSOutlineView, shouldReorderColumn: number, toColumn: number): boolean;
    // instance method
    outlineViewShouldSelectItem?(_: NSOutlineView, shouldSelectItem: any): boolean;
    // instance method
    outlineViewShouldShowOutlineCellForItem?(_: NSOutlineView, shouldShowOutlineCellForItem: any): boolean;
    // instance method
    outlineViewSizeToFitWidthOfColumn?(_: NSOutlineView, sizeToFitWidthOfColumn: number): number;
    // instance method
    outlineViewColumnDidMove?(_: NSNotification): void;
    // instance method
    outlineViewColumnDidResize?(_: NSNotification): void;
    // instance method
    outlineViewItemDidCollapse?(_: NSNotification): void;
    // instance method
    outlineViewItemDidExpand?(_: NSNotification): void;
    // instance method
    outlineViewItemWillCollapse?(_: NSNotification): void;
    // instance method
    outlineViewItemWillExpand?(_: NSNotification): void;
    // instance method
    outlineViewSelectionDidChange?(_: NSNotification): void;
    // instance method
    outlineViewSelectionIsChanging?(_: NSNotification): void;
    // instance method
    selectionShouldChangeInOutlineView?(in_: NSOutlineView): boolean;
  }

  // interface
  class NSPDFImageRep extends NSImageRep {
    PDFRepresentation: NSData;
    bounds: CGRect;
    currentPage: number;
    setCurrentPage(_: number)
    pageCount: number;
    static createWithData(data: NSData): NSPDFImageRep;
  }

  // interface
  class NSPDFInfo extends NSObject /* implements NSCoding, NSCopying */ {
    URL: NSURL;
    setURL(_: NSURL)
    attributes: NSMutableDictionary<string, any>;
    isFileExtensionHidden: boolean;
    setFileExtensionHidden(_: boolean)
    orientation: NSPrintInfo.PaperOrientation;
    setOrientation(_: NSPrintInfo.PaperOrientation)
    paperSize: CGSize;
    setPaperSize(_: CGSize)
    tagNames: string[];
    setTagNames(_: string[])
  }

  // interface
  class NSPDFPanel extends NSObject {
    accessoryController: NSViewController;
    setAccessoryController(_: NSViewController)
    defaultFileName: string;
    setDefaultFileName(_: string)
    options: NSPDFPanel.Options;
    setOptions(_: NSPDFPanel.Options)
    beginSheetWithWithModalForCompletionHandler(with_: NSPDFInfo, modalFor?: NSWindow, completionHandler?: (p1: number) => void): void;
  }

  // interface
  class NSPICTImageRep extends NSImageRep {
    PICTRepresentation: NSData;
    boundingBox: CGRect;
    static createWithData(data: NSData): NSPICTImageRep;
  }

  // interface
  class NSPageController extends NSViewController /* implements NSAnimatablePropertyContainer, NSCoding */ {
    arrangedObjects: any[];
    setArrangedObjects(_: any[])
    delegate: NSPageControllerDelegate;
    setDelegate(_: NSPageControllerDelegate)
    selectedIndex: number;
    setSelectedIndex(_: number)
    selectedViewController: NSViewController;
    transitionStyle: NSPageController.TransitionStyle;
    setTransitionStyle(_: NSPageController.TransitionStyle)
    completeTransition(): void;
    navigateBack(_?: any): void;
    navigateForward(_?: any): void;
    navigateForwardToObject(to: any): void;
    takeSelectedIndexFrom(_?: any): void;
  }

  interface NSPageControllerDelegate extends NSObject {
    // instance method
    pageControllerIdentifierForObject?(_: NSPageController, identifierFor: any): string;
    // instance method
    pageControllerFrameForObject?(_: NSPageController, frameFor?: any): CGRect;
    // instance method
    pageControllerPrepareViewControllerWithObject?(_: NSPageController, prepare: NSViewController, with_?: any): void;
    // instance method
    pageControllerDidTransitionToObject?(_: NSPageController, didTransitionTo: any): void;
    // instance method
    pageControllerViewControllerForIdentifier?(_: NSPageController, viewControllerForIdentifier: string): NSViewController;
    // instance method
    pageControllerDidEndLiveTransition?(_: NSPageController): void;
    // instance method
    pageControllerWillStartLiveTransition?(_: NSPageController): void;
  }

  // interface
  class NSPageLayout extends NSObject {
    accessoryControllers: NSViewController[];
    printInfo: NSPrintInfo;
    addAccessoryController(_: NSViewController): void;
    beginSheetWithPrintInfoModalForWindowDelegateDidEndSelectorContextInfo(with_: NSPrintInfo, modalFor: NSWindow, delegate?: any, didEnd?: string, contextInfo?: any): void;
    removeAccessoryController(_: NSViewController): void;
    runModal(): number;
    runModalWithPrintInfo(with_: NSPrintInfo): number;
  }

  // interface
  class NSPanGestureRecognizer extends NSGestureRecognizer /* implements NSCoding */ {
    buttonMask: number;
    setButtonMask(_: number)
    numberOfTouchesRequired: number;
    setNumberOfTouchesRequired(_: number)
    setTranslationInView(_: CGPoint, in_?: NSView): void;
    translationInView(in_?: NSView): CGPoint;
    velocityInView(in_?: NSView): CGPoint;
  }

  // interface
  class NSPanel extends NSWindow {
    becomesKeyOnlyIfNeeded: boolean;
    setBecomesKeyOnlyIfNeeded(_: boolean)
  }

  // interface
  class NSParagraphStyle extends NSObject /* implements NSCopying, NSMutableCopying, NSSecureCoding */ {
    static defaultWritingDirectionForLanguage(forLanguage?: string): NSWritingDirection;
    alignment: NSTextAlignment;
    allowsDefaultTighteningForTruncation: boolean;
    baseWritingDirection: NSWritingDirection;
    defaultTabInterval: number;
    firstLineHeadIndent: number;
    headIndent: number;
    headerLevel: number;
    hyphenationFactor: number;
    lineBreakMode: NSLineBreakMode;
    lineHeightMultiple: number;
    lineSpacing: number;
    maximumLineHeight: number;
    minimumLineHeight: number;
    paragraphSpacing: number;
    paragraphSpacingBefore: number;
    tabStops: NSTextTab[];
    tailIndent: number;
    textBlocks: NSTextBlock[];
    textLists: NSTextList[];
    tighteningFactorForTruncation: number;
    static defaultParagraphStyle: NSParagraphStyle;
  }

  // interface
  class NSPasteboard extends NSObject {
    static pasteboardWithUniqueName(): NSPasteboard;
    static typesFilterableTo(filterableTo: string): string[];
    changeCount: number;
    name: string;
    pasteboardItems: NSPasteboardItem[];
    types: string[];
    static generalPasteboard: NSPasteboard;
    addTypesOwner(_: string[], owner?: any): number;
    availableTypeFromArray(from: string[]): string;
    canReadItemWithDataConformingToTypes(withDataConformingToTypes: string[]): boolean;
    canReadObjectForClassesOptions(forClasses: typeof NSObject[], options?: Map<string, any>): boolean;
    clearContents(): number;
    dataForType(forType: string): NSData;
    declareTypesOwner(_: string[], owner?: any): number;
    indexOfPasteboardItem(of: NSPasteboardItem): number;
    prepareForNewContentsWithOptions(with_: NSPasteboard.ContentsOptions): number;
    propertyListForType(forType: string): any;
    readFileContentsTypeToFile(_?: string, toFile?: string): string;
    readFileWrapper(): FileWrapper;
    readObjectsForClassesOptions(forClasses: typeof NSObject[], options?: Map<string, any>): any[];
    releaseGlobally(): void;
    setDataForType(_?: NSData, forType?: string): boolean;
    setPropertyListForType(_: any, forType: string): boolean;
    setStringForType(_: string, forType: string): boolean;
    stringForType(forType: string): string;
    writeFileContents(_: string): boolean;
    writeFileWrapper(_: FileWrapper): boolean;
    writeObjects(_: NSPasteboardWriting[]): boolean;
  }

  // interface
  class NSPasteboardItem extends NSObject /* implements NSPasteboardReading, NSPasteboardWriting */ {
    types: string[];
    availableTypeFromArray(from: string[]): string;
    dataForType(forType: string): NSData;
    propertyListForType(forType: string): any;
    setDataForType(_: NSData, forType: string): boolean;
    setDataProviderForTypes(_: NSPasteboardItemDataProvider, forTypes: string[]): boolean;
    setPropertyListForType(_: any, forType: string): boolean;
    setStringForType(_: string, forType: string): boolean;
    stringForType(forType: string): string;
  }

  interface NSPasteboardItemDataProvider extends NSObject {
    // instance method
    pasteboardItemProvideDataForType(_?: NSPasteboard, item?: NSPasteboardItem, provideDataForType?: string): void;
    // instance method
    pasteboardFinishedWithDataProvider?(_: NSPasteboard): void;
  }

  type NSPasteboardReading = NSObject

  interface NSPasteboardTypeOwner extends NSObject {
    // instance method
    pasteboardProvideDataForType(_: NSPasteboard, provideDataForType: string): void;
    // instance method
    pasteboardChangedOwner?(_: NSPasteboard): void;
  }

  interface NSPasteboardWriting extends NSObject {
    // instance method
    pasteboardPropertyListForType(forType: string): any;
    // instance method
    writableTypesForPasteboard(for_: NSPasteboard): string[];
    // instance method
    writingOptionsForTypePasteboard?(forType: string, pasteboard: NSPasteboard): NSPasteboard.WritingOptions;
  }

  // interface
  class NSPathCell extends NSActionCell /* implements NSMenuItemValidation, NSOpenSavePanelDelegate */ {
    URL: NSURL;
    setURL(_: NSURL)
    allowedTypes: string[];
    setAllowedTypes(_: string[])
    backgroundColor: NSColor;
    setBackgroundColor(_: NSColor)
    clickedPathComponentCell: NSPathComponentCell;
    delegate: NSPathCellDelegate;
    setDelegate(_: NSPathCellDelegate)
    doubleAction: string;
    setDoubleAction(_: string)
    pathComponentCells: NSPathComponentCell[];
    setPathComponentCells(_: NSPathComponentCell[])
    pathStyle: NSPathControl.Style;
    setPathStyle(_: NSPathControl.Style)
    placeholderAttributedString: NSAttributedString;
    setPlaceholderAttributedString(_: NSAttributedString)
    placeholderString: string;
    setPlaceholderString(_: string)
    static pathComponentCellClass: typeof NSObject;
    mouseEnteredWithFrameInView(with_: NSEvent, frame: CGRect, in_: NSView): void;
    mouseExitedWithFrameInView(with_: NSEvent, frame: CGRect, in_: NSView): void;
    pathComponentCellAtPointWithFrameInView(at: CGPoint, withFrame: CGRect, in_: NSView): NSPathComponentCell;
    rectOfPathComponentCellWithFrameInView(of: NSPathComponentCell, withFrame: CGRect, in_: NSView): CGRect;
    setObjectValue(_?: any): void;
  }

  interface NSPathCellDelegate extends NSObject {
    // instance method
    pathCellWillDisplayOpenPanel?(_: NSPathCell, willDisplay: NSOpenPanel): void;
    // instance method
    pathCellWillPopUpMenu?(_: NSPathCell, willPopUp: NSMenu): void;
  }

  // interface
  class NSPathComponentCell extends NSTextFieldCell {
    URL: NSURL;
    setURL(_: NSURL)
  }

  // interface
  class NSPathControl extends NSControl {
    URL: NSURL;
    setURL(_: NSURL)
    allowedTypes: string[];
    setAllowedTypes(_: string[])
    backgroundColor: NSColor;
    setBackgroundColor(_: NSColor)
    clickedPathItem: NSPathControlItem;
    delegate: NSPathControlDelegate;
    setDelegate(_: NSPathControlDelegate)
    doubleAction: string;
    setDoubleAction(_: string)
    isEditable: boolean;
    setEditable(_: boolean)
    pathItems: NSPathControlItem[];
    setPathItems(_: NSPathControlItem[])
    pathStyle: NSPathControl.Style;
    setPathStyle(_: NSPathControl.Style)
    placeholderAttributedString: NSAttributedString;
    setPlaceholderAttributedString(_: NSAttributedString)
    placeholderString: string;
    setPlaceholderString(_: string)
    setDraggingSourceOperationMaskForLocal(_: NSDragOperation, forLocal: boolean): void;
  }

  interface NSPathControlDelegate extends NSObject {
    // instance method
    pathControlShouldDragItemWithPasteboard?(_: NSPathControl, shouldDrag: NSPathControlItem, with_: NSPasteboard): boolean;
    // instance method
    pathControlShouldDragPathComponentCellWithPasteboard?(_: NSPathControl, shouldDrag: NSPathComponentCell, with_: NSPasteboard): boolean;
    // instance method
    pathControlWillDisplayOpenPanel?(_: NSPathControl, willDisplay: NSOpenPanel): void;
    // instance method
    pathControlWillPopUpMenu?(_: NSPathControl, willPopUp: NSMenu): void;
    // instance method
    pathControlAcceptDrop?(_: NSPathControl, acceptDrop: NSDraggingInfo): boolean;
    // instance method
    pathControlValidateDrop?(_: NSPathControl, validateDrop: NSDraggingInfo): NSDragOperation;
  }

  // interface
  class NSPathControlItem extends NSObject {
    URL: NSURL;
    attributedTitle: NSAttributedString;
    setAttributedTitle(_: NSAttributedString)
    image: NSImage;
    setImage(_: NSImage)
    title: string;
    setTitle(_: string)
  }

  // export function NSPerformService(itemName: string, pboard: NSPasteboard): boolean;

  // interface
  class NSPersistentDocument extends NSDocument {
    managedObjectContext: NSManagedObjectContext;
    setManagedObjectContext(_: NSManagedObjectContext)
    managedObjectModel: NSManagedObjectModel;
    configurePersistentStoreCoordinatorForURLOfTypeModelConfigurationStoreOptionsError(ofType: NSURL, modelConfiguration: string, storeOptions?: string, error?: Map<string, any>): boolean;
    persistentStoreTypeForFileType(forFileType: string): string;
  }

  // interface
  class NSPickerTouchBarItem extends NSTouchBarItem {
    action: string;
    setAction(_: string)
    collapsedRepresentationImage: NSImage;
    setCollapsedRepresentationImage(_: NSImage)
    collapsedRepresentationLabel: string;
    setCollapsedRepresentationLabel(_: string)
    controlRepresentation: NSPickerTouchBarItem.ControlRepresentation;
    setControlRepresentation(_: NSPickerTouchBarItem.ControlRepresentation)
    isEnabled: boolean;
    setEnabled(_: boolean)
    numberOfOptions: number;
    setNumberOfOptions(_: number)
    selectedIndex: number;
    setSelectedIndex(_: number)
    selectionColor: NSColor;
    setSelectionColor(_: NSColor)
    selectionMode: NSPickerTouchBarItem.SelectionMode;
    setSelectionMode(_: NSPickerTouchBarItem.SelectionMode)
    target: any;
    setTarget(_: any)
    imageAtIndex(at: number): NSImage;
    isEnabledAtIndex(at: number): boolean;
    labelAtIndex(at: number): string;
    setEnabledAtIndex(_: boolean, at: number): void;
    setImageAtIndex(_?: NSImage, at?: number): void;
    setLabelAtIndex(_: string, at: number): void;
  }

  // export function NSPlanarFromDepth(depth: NSWindow.Depth): boolean;

  // interface
  class NSPopUpButton extends NSButton {
    autoenablesItems: boolean;
    setAutoenablesItems(_: boolean)
    indexOfSelectedItem: number;
    itemArray: NSMenuItem[];
    itemTitles: string[];
    lastItem: NSMenuItem;
    numberOfItems: number;
    preferredEdge: NSRectEdge;
    setPreferredEdge(_: NSRectEdge)
    pullsDown: boolean;
    setPullsDown(_: boolean)
    selectedItem: NSMenuItem;
    titleOfSelectedItem: string;
    addItemWithTitle(withTitle: string): void;
    addItemsWithTitles(withTitles: string[]): void;
    indexOfItem(of: NSMenuItem): number;
    indexOfItemWithRepresentedObject(withRepresentedObject?: any): number;
    indexOfItemWithTag(withTag: number): number;
    indexOfItemWithTargetAndAction(withTarget?: any, andAction?: string): number;
    indexOfItemWithTitle(withTitle: string): number;
    static createWithFramePullsDown(frame: CGRect, pullsDown: boolean): NSPopUpButton;
    insertItemWithTitleAtIndex(withTitle: string, at: number): void;
    itemAtIndex(at: number): NSMenuItem;
    itemTitleAtIndex(at: number): string;
    itemWithTitle(withTitle: string): NSMenuItem;
    removeAllItems(): void;
    removeItemAtIndex(at: number): void;
    removeItemWithTitle(withTitle: string): void;
    selectItem(_?: NSMenuItem): void;
    selectItemAtIndex(at: number): void;
    selectItemWithTag(withTag: number): boolean;
    selectItemWithTitle(withTitle: string): void;
    setTitle(_: string): void;
    synchronizeTitleAndSelectedItem(): void;
  }

  // interface
  class NSPopUpButtonCell extends NSMenuItemCell /* implements NSMenuItemValidation */ {
    altersStateOfSelectedItem: boolean;
    setAltersStateOfSelectedItem(_: boolean)
    arrowPosition: NSPopUpButton.ArrowPosition;
    setArrowPosition(_: NSPopUpButton.ArrowPosition)
    autoenablesItems: boolean;
    setAutoenablesItems(_: boolean)
    indexOfSelectedItem: number;
    itemArray: NSMenuItem[];
    itemTitles: string[];
    lastItem: NSMenuItem;
    numberOfItems: number;
    preferredEdge: NSRectEdge;
    setPreferredEdge(_: NSRectEdge)
    pullsDown: boolean;
    setPullsDown(_: boolean)
    selectedItem: NSMenuItem;
    titleOfSelectedItem: string;
    usesItemFromMenu: boolean;
    setUsesItemFromMenu(_: boolean)
    addItemWithTitle(withTitle: string): void;
    addItemsWithTitles(withTitles: string[]): void;
    attachPopUpWithFrameInView(withFrame: CGRect, in_: NSView): void;
    dismissPopUp(): void;
    indexOfItem(of: NSMenuItem): number;
    indexOfItemWithRepresentedObject(withRepresentedObject?: any): number;
    indexOfItemWithTag(withTag: number): number;
    indexOfItemWithTargetAndAction(withTarget?: any, andAction?: string): number;
    indexOfItemWithTitle(withTitle: string): number;
    static createWithTextCellPullsDown(textCell: string, pullsDown: boolean): NSPopUpButtonCell;
    insertItemWithTitleAtIndex(withTitle: string, at: number): void;
    itemAtIndex(at: number): NSMenuItem;
    itemTitleAtIndex(at: number): string;
    itemWithTitle(withTitle: string): NSMenuItem;
    performClickWithFrameInView(withFrame: CGRect, in_: NSView): void;
    removeAllItems(): void;
    removeItemAtIndex(at: number): void;
    removeItemWithTitle(withTitle: string): void;
    selectItem(_?: NSMenuItem): void;
    selectItemAtIndex(at: number): void;
    selectItemWithTag(withTag: number): boolean;
    selectItemWithTitle(withTitle: string): void;
    setTitle(_?: string): void;
    synchronizeTitleAndSelectedItem(): void;
  }

  // interface
  class NSPopover extends NSResponder /* implements NSAccessibility, NSAccessibilityElement, NSAppearanceCustomization */ {
    animates: boolean;
    setAnimates(_: boolean)
    behavior: NSPopover.Behavior;
    setBehavior(_: NSPopover.Behavior)
    contentSize: CGSize;
    setContentSize(_: CGSize)
    contentViewController: NSViewController;
    setContentViewController(_: NSViewController)
    delegate: NSPopoverDelegate;
    setDelegate(_: NSPopoverDelegate)
    isDetached: boolean;
    positioningRect: CGRect;
    setPositioningRect(_: CGRect)
    isShown: boolean;
    close(): void;
    performClose(_?: any): void;
    showRelativeToRectOfViewPreferredEdge(relativeTo: CGRect, of: NSView, preferredEdge: NSRectEdge): void;
  }

  interface NSPopoverDelegate extends NSObject {
    // instance method
    detachableWindowForPopover?(for_: NSPopover): NSWindow;
    // instance method
    popoverDidClose?(_: NSNotification): void;
    // instance method
    popoverDidDetach?(_: NSPopover): void;
    // instance method
    popoverDidShow?(_: NSNotification): void;
    // instance method
    popoverShouldClose?(_: NSPopover): boolean;
    // instance method
    popoverShouldDetach?(_: NSPopover): boolean;
    // instance method
    popoverWillClose?(_: NSNotification): void;
    // instance method
    popoverWillShow?(_: NSNotification): void;
  }

  // interface
  class NSPopoverTouchBarItem extends NSTouchBarItem {
    collapsedRepresentation: NSView;
    setCollapsedRepresentation(_: NSView)
    collapsedRepresentationImage: NSImage;
    setCollapsedRepresentationImage(_: NSImage)
    collapsedRepresentationLabel: string;
    setCollapsedRepresentationLabel(_: string)
    popoverTouchBar: NSTouchBar;
    setPopoverTouchBar(_: NSTouchBar)
    pressAndHoldTouchBar: NSTouchBar;
    setPressAndHoldTouchBar(_: NSTouchBar)
    showsCloseButton: boolean;
    setShowsCloseButton(_: boolean)
    dismissPopover(_?: any): void;
    makeStandardActivatePopoverGestureRecognizer(): NSGestureRecognizer;
    showPopover(_?: any): void;
  }

  // interface
  class NSPredicateEditor extends NSRuleEditor {
    rowTemplates: NSPredicateEditorRowTemplate[];
    setRowTemplates(_: NSPredicateEditorRowTemplate[])
  }

  // interface
  class NSPredicateEditorRowTemplate extends NSObject /* implements NSCoding, NSCopying */ {
    static templatesWithAttributeKeyPathsInEntityDescription(withAttributeKeyPaths: string[], in_: NSEntityDescription): NSPredicateEditorRowTemplate[];
    compoundTypes: number[];
    leftExpressions: NSExpression[];
    modifier: NSComparisonPredicate.Modifier;
    operators: number[];
    options: number;
    rightExpressionAttributeType: NSAttributeType;
    rightExpressions: NSExpression[];
    templateViews: NSView[];
    displayableSubpredicatesOfPredicate(of: NSPredicate): NSPredicate[];
    static createWithCompoundTypes(compoundTypes: number[]): NSPredicateEditorRowTemplate;
    static createWithLeftExpressionsRightExpressionAttributeTypeModifierOperatorsOptions(leftExpressions: NSExpression[], rightExpressionAttributeType: NSAttributeType, modifier: NSComparisonPredicate.Modifier, operators: number[], options: number): NSPredicateEditorRowTemplate;
    static createWithLeftExpressionsRightExpressionsModifierOperatorsOptions(leftExpressions: NSExpression[], rightExpressions: NSExpression[], modifier: NSComparisonPredicate.Modifier, operators: number[], options: number): NSPredicateEditorRowTemplate;
    matchForPredicate(for_: NSPredicate): number;
    predicateWithSubpredicates(withSubpredicates?: NSPredicate[]): NSPredicate;
    setPredicate(_: NSPredicate): void;
  }

  // interface
  class NSPressGestureRecognizer extends NSGestureRecognizer /* implements NSCoding */ {
    allowableMovement: number;
    setAllowableMovement(_: number)
    buttonMask: number;
    setButtonMask(_: number)
    minimumPressDuration: number;
    setMinimumPressDuration(_: number)
    numberOfTouchesRequired: number;
    setNumberOfTouchesRequired(_: number)
  }

  // interface
  class NSPressureConfiguration extends NSObject {
    pressureBehavior: NSEvent.PressureBehavior;
    static createWithPressureBehavior(pressureBehavior: NSEvent.PressureBehavior): NSPressureConfiguration;
    set(): void;
  }

  // interface
  class NSPrintInfo extends NSObject /* implements NSCoding, NSCopying */ {
    bottomMargin: number;
    setBottomMargin(_: number)
    horizontalPagination: NSPrintInfo.PaginationMode;
    setHorizontalPagination(_: NSPrintInfo.PaginationMode)
    isHorizontallyCentered: boolean;
    setHorizontallyCentered(_: boolean)
    imageablePageBounds: CGRect;
    jobDisposition: string;
    setJobDisposition(_: string)
    leftMargin: number;
    setLeftMargin(_: number)
    localizedPaperName: string;
    orientation: NSPrintInfo.PaperOrientation;
    setOrientation(_: NSPrintInfo.PaperOrientation)
    paperName: string;
    setPaperName(_: string)
    paperSize: CGSize;
    setPaperSize(_: CGSize)
    printSettings: NSMutableDictionary<string, any>;
    printer: NSPrinter;
    setPrinter(_: NSPrinter)
    rightMargin: number;
    setRightMargin(_: number)
    scalingFactor: number;
    setScalingFactor(_: number)
    isSelectionOnly: boolean;
    setSelectionOnly(_: boolean)
    topMargin: number;
    setTopMargin(_: number)
    verticalPagination: NSPrintInfo.PaginationMode;
    setVerticalPagination(_: NSPrintInfo.PaginationMode)
    isVerticallyCentered: boolean;
    setVerticallyCentered(_: boolean)
    static defaultPrinter: NSPrinter;
    static sharedPrintInfo: NSPrintInfo;
    setSharedPrintInfo(_: NSPrintInfo)
    PMPageFormat(): any;
    PMPrintSession(): any;
    PMPrintSettings(): any;
    dictionary(): NSMutableDictionary<string, any>;
    static createWithDictionary(dictionary: Map<string, any>): NSPrintInfo;
    setUpPrintOperationDefaultValues(): void;
    takeSettingsFromPDFInfo(from: NSPDFInfo): void;
    updateFromPMPageFormat(): void;
    updateFromPMPrintSettings(): void;
  }

  // interface
  class NSPrintOperation extends NSObject {
    static EPSOperationWithViewInsideRectToData(with_: NSView, inside: CGRect, to?: NSMutableData): NSPrintOperation;
    static EPSOperationWithViewInsideRectToDataPrintInfo(with_: NSView, inside: CGRect, to: NSMutableData, printInfo: NSPrintInfo): NSPrintOperation;
    static EPSOperationWithViewInsideRectToPathPrintInfo(with_: NSView, inside: CGRect, toPath: string, printInfo: NSPrintInfo): NSPrintOperation;
    static PDFOperationWithViewInsideRectToData(with_: NSView, inside: CGRect, to: NSMutableData): NSPrintOperation;
    static PDFOperationWithViewInsideRectToDataPrintInfo(with_: NSView, inside: CGRect, to: NSMutableData, printInfo: NSPrintInfo): NSPrintOperation;
    static PDFOperationWithViewInsideRectToPathPrintInfo(with_: NSView, inside: CGRect, toPath: string, printInfo: NSPrintInfo): NSPrintOperation;
    PDFPanel: NSPDFPanel;
    setPDFPanel(_: NSPDFPanel)
    canSpawnSeparateThread: boolean;
    setCanSpawnSeparateThread(_: boolean)
    context: NSGraphicsContext;
    isCopyingOperation: boolean;
    currentPage: number;
    jobTitle: string;
    setJobTitle(_: string)
    pageOrder: NSPrintOperation.PageOrder;
    setPageOrder(_: NSPrintOperation.PageOrder)
    pageRange: NSRange;
    preferredRenderingQuality: NSPrintOperation.RenderingQuality;
    printInfo: NSPrintInfo;
    setPrintInfo(_: NSPrintInfo)
    printPanel: NSPrintPanel;
    setPrintPanel(_: NSPrintPanel)
    showsPrintPanel: boolean;
    setShowsPrintPanel(_: boolean)
    showsProgressPanel: boolean;
    setShowsProgressPanel(_: boolean)
    view: NSView;
    static currentOperation: NSPrintOperation;
    setCurrentOperation(_: NSPrintOperation)
    cleanUpOperation(): void;
    createContext(): NSGraphicsContext;
    deliverResult(): boolean;
    destroyContext(): void;
    runOperation(): boolean;
    runOperationModalForWindowDelegateDidRunSelectorContextInfo(for_: NSWindow, delegate?: any, didRun?: string, contextInfo?: any): void;
  }

  // interface
  class NSPrintPanel extends NSObject {
    accessoryControllers: NSViewController[];
    helpAnchor: string;
    setHelpAnchor(_: string)
    jobStyleHint: string;
    setJobStyleHint(_: string)
    options: NSPrintPanel.Options;
    setOptions(_: NSPrintPanel.Options)
    printInfo: NSPrintInfo;
    addAccessoryController(_: NSViewController): void;
    beginSheetWithPrintInfoModalForWindowDelegateDidEndSelectorContextInfo(with_: NSPrintInfo, modalFor: NSWindow, delegate?: any, didEnd?: string, contextInfo?: any): void;
    defaultButtonTitle(): string;
    removeAccessoryController(_: NSViewController): void;
    runModal(): number;
    runModalWithPrintInfo(with_: NSPrintInfo): number;
    setDefaultButtonTitle(_?: string): void;
  }

  interface NSPrintPanelAccessorizing {
    // instance method
    keyPathsForValuesAffectingPreview?(): NSSet<string>;
    // instance method
    localizedSummaryItems(): Map<string, string>[];
  }

  // interface
  class NSPrinter extends NSObject /* implements NSCoding, NSCopying */ {
    deviceDescription: Map<string, any>;
    languageLevel: number;
    name: string;
    type: string;
    static printerNames: string[];
    static printerTypes: string[];
    pageSizeForPaper(forPaper: string): CGSize;
  }

  // interface
  class NSProgressIndicator extends NSView /* implements NSAccessibilityProgressIndicator */ {
    isBezeled: boolean;
    setBezeled(_: boolean)
    controlSize: NSControl.ControlSize;
    setControlSize(_: NSControl.ControlSize)
    controlTint: NSControlTint;
    setControlTint(_: NSControlTint)
    isDisplayedWhenStopped: boolean;
    setDisplayedWhenStopped(_: boolean)
    doubleValue: number;
    setDoubleValue(_: number)
    isIndeterminate: boolean;
    setIndeterminate(_: boolean)
    maxValue: number;
    setMaxValue(_: number)
    minValue: number;
    setMinValue(_: number)
    style: NSProgressIndicator.Style;
    setStyle(_: NSProgressIndicator.Style)
    usesThreadedAnimation: boolean;
    setUsesThreadedAnimation(_: boolean)
    incrementBy(by: number): void;
    sizeToFit(): void;
    startAnimation(_?: any): void;
    stopAnimation(_?: any): void;
  }

  // export function NSRectClip(rect: CGRect): void;

  // export function NSRectClipList(rects: NSRect, count: number): void;

  // export function NSRectFill(rect: CGRect): void;

  // export function NSRectFillList(rects: NSRect, count: number): void;

  // export function NSRectFillListUsingOperation(rects: NSRect, count: number, op: NSCompositingOperation): void;

  // export function NSRectFillListWithColors(rects: NSRect, colors: NSColor, num: number): void;

  // export function NSRectFillListWithColorsUsingOperation(rects: NSRect, colors: NSColor, num: number, op: NSCompositingOperation): void;

  // export function NSRectFillListWithGrays(rects: NSRect, grays: number, num: number): void;

  // export function NSRectFillUsingOperation(rect: CGRect, op: NSCompositingOperation): void;

  // export function NSRegisterServicesProvider(provider: any, name: string): void;

  // interface
  class NSResponder extends NSObject /* implements NSCoding, NSStandardKeyBindingResponding, NSUserActivityRestoring, NSTouchBarProvider */ {
    acceptsFirstResponder: boolean;
    menu: NSMenu;
    setMenu(_: NSMenu)
    nextResponder: NSResponder;
    setNextResponder(_: NSResponder)
    touchBar: NSTouchBar;
    setTouchBar(_: NSTouchBar)
    undoManager: UndoManager;
    userActivity: NSUserActivity;
    setUserActivity(_: NSUserActivity)
    static restorableStateKeyPaths: string[];
    becomeFirstResponder(): boolean;
    beginGestureWithEvent(with_: NSEvent): void;
    changeModeWithEvent(with_: NSEvent): void;
    cursorUpdate(with_: NSEvent): void;
    encodeRestorableStateWithCoder(with_: NSCoder): void;
    encodeRestorableStateWithCoderBackgroundQueue(with_: NSCoder, backgroundQueue: OperationQueue): void;
    endGestureWithEvent(with_: NSEvent): void;
    flagsChanged(with_: NSEvent): void;
    flushBufferedKeyEvents(): void;
    helpRequested(_: NSEvent): void;
    interpretKeyEvents(_: NSEvent[]): void;
    invalidateRestorableState(): void;
    keyDown(with_: NSEvent): void;
    keyUp(with_: NSEvent): void;
    magnifyWithEvent(with_: NSEvent): void;
    makeTouchBar(): NSTouchBar;
    mouseDown(with_: NSEvent): void;
    mouseDragged(with_: NSEvent): void;
    mouseEntered(with_: NSEvent): void;
    mouseExited(with_: NSEvent): void;
    mouseMoved(with_: NSEvent): void;
    mouseUp(with_: NSEvent): void;
    newWindowForTab(_?: any): void;
    noResponderFor(for_: string): void;
    otherMouseDown(with_: NSEvent): void;
    otherMouseDragged(with_: NSEvent): void;
    otherMouseUp(with_: NSEvent): void;
    performKeyEquivalent(with_: NSEvent): boolean;
    performTextFinderAction(_?: any): void;
    presentError(_: NSError): boolean;
    presentErrorModalForWindowDelegateDidPresentSelectorContextInfo(_: NSError, modalFor: NSWindow, delegate?: any, didPresent?: string, contextInfo?: any): void;
    pressureChangeWithEvent(with_: NSEvent): void;
    quickLookWithEvent(with_: NSEvent): void;
    resignFirstResponder(): boolean;
    restoreStateWithCoder(with_: NSCoder): void;
    rightMouseDown(with_: NSEvent): void;
    rightMouseDragged(with_: NSEvent): void;
    rightMouseUp(with_: NSEvent): void;
    rotateWithEvent(with_: NSEvent): void;
    scrollWheel(with_: NSEvent): void;
    shouldBeTreatedAsInkEvent(_: NSEvent): boolean;
    showContextHelp(_?: any): void;
    smartMagnifyWithEvent(with_: NSEvent): void;
    supplementalTargetForActionSender(forAction: string, sender?: any): any;
    swipeWithEvent(with_: NSEvent): void;
    tabletPoint(with_: NSEvent): void;
    tabletProximity(with_: NSEvent): void;
    touchesBeganWithEvent(with_: NSEvent): void;
    touchesCancelledWithEvent(with_: NSEvent): void;
    touchesEndedWithEvent(with_: NSEvent): void;
    touchesMovedWithEvent(with_: NSEvent): void;
    tryToPerformWith(_: string, with_?: any): boolean;
    updateUserActivityState(_: NSUserActivity): void;
    validRequestorForSendTypeReturnType(forSendType?: string, returnType?: string): any;
    validateProposedFirstResponderForEvent(_: NSResponder, for_?: NSEvent): boolean;
    wantsForwardedScrollEventsForAxis(for_: NSEvent.GestureAxis): boolean;
    wantsScrollEventsForSwipeTrackingOnAxis(on: NSEvent.GestureAxis): boolean;
    willPresentError(_: NSError): NSError;
  }

  // interface
  class NSRotationGestureRecognizer extends NSGestureRecognizer {
    rotation: number;
    setRotation(_: number)
    rotationInDegrees: number;
    setRotationInDegrees(_: number)
  }

  // interface
  class NSRuleEditor extends NSControl {
    canRemoveAllRows: boolean;
    setCanRemoveAllRows(_: boolean)
    criteriaKeyPath: string;
    setCriteriaKeyPath(_: string)
    delegate: NSRuleEditorDelegate;
    setDelegate(_: NSRuleEditorDelegate)
    displayValuesKeyPath: string;
    setDisplayValuesKeyPath(_: string)
    isEditable: boolean;
    setEditable(_: boolean)
    formattingDictionary: Map<string, string>;
    setFormattingDictionary(_: Map<string, string>)
    formattingStringsFilename: string;
    setFormattingStringsFilename(_: string)
    nestingMode: NSRuleEditor.NestingMode;
    setNestingMode(_: NSRuleEditor.NestingMode)
    numberOfRows: number;
    predicate: NSPredicate;
    rowClass: typeof NSObject;
    setRowClass(_: typeof NSObject)
    rowHeight: number;
    setRowHeight(_: number)
    rowTypeKeyPath: string;
    setRowTypeKeyPath(_: string)
    selectedRowIndexes: NSIndexSet;
    subrowsKeyPath: string;
    setSubrowsKeyPath(_: string)
    addRow(_?: any): void;
    criteriaForRow(forRow: number): any[];
    displayValuesForRow(forRow: number): any[];
    insertRowAtIndexWithTypeAsSubrowOfRowAnimate(at: number, with_: NSRuleEditor.RowType, asSubrowOfRow: number, animate: boolean): void;
    parentRowForRow(forRow: number): number;
    predicateForRow(forRow: number): NSPredicate;
    reloadCriteria(): void;
    reloadPredicate(): void;
    removeRowAtIndex(at: number): void;
    removeRowsAtIndexesIncludeSubrows(at: NSIndexSet, includeSubrows: boolean): void;
    rowForDisplayValue(forDisplayValue: any): number;
    rowTypeForRow(forRow: number): NSRuleEditor.RowType;
    selectRowIndexesByExtendingSelection(_: NSIndexSet, byExtendingSelection: boolean): void;
    setCriteriaAndDisplayValuesForRowAtIndex(_: any[], andDisplayValues: any[], forRowAt: number): void;
    subrowIndexesForRow(forRow: number): NSIndexSet;
  }

  interface NSRuleEditorDelegate extends NSObject {
    // instance method
    ruleEditorNumberOfChildrenForCriterionWithRowType(_: NSRuleEditor, numberOfChildrenForCriterion?: any, with_?: NSRuleEditor.RowType): number;
    // instance method
    ruleEditorChildForCriterionWithRowType(_: NSRuleEditor, child: number, forCriterion?: any, with_?: NSRuleEditor.RowType): any;
    // instance method
    ruleEditorDisplayValueForCriterionInRow(_: NSRuleEditor, displayValueForCriterion: any, inRow: number): any;
    // instance method
    ruleEditorPredicatePartsForCriterionWithDisplayValueInRow?(_: NSRuleEditor, predicatePartsForCriterion: any, withDisplayValue: any, inRow: number): Map<string, any>;
    // instance method
    ruleEditorRowsDidChange?(_: NSNotification): void;
  }

  // interface
  class NSRulerMarker extends NSObject /* implements NSCoding, NSCopying */ {
    isDragging: boolean;
    image: NSImage;
    setImage(_: NSImage)
    imageOrigin: CGPoint;
    setImageOrigin(_: CGPoint)
    imageRectInRuler: CGRect;
    markerLocation: number;
    setMarkerLocation(_: number)
    isMovable: boolean;
    setMovable(_: boolean)
    isRemovable: boolean;
    setRemovable(_: boolean)
    representedObject: any;
    setRepresentedObject(_: any)
    ruler: NSRulerView;
    thicknessRequiredInRuler: number;
    drawRect(_: CGRect): void;
    static createWithRulerViewMarkerLocationImageImageOrigin(rulerView: NSRulerView, markerLocation: number, image: NSImage, imageOrigin: CGPoint): NSRulerMarker;
    trackMouseAdding(with_: NSEvent, adding: boolean): boolean;
  }

  // interface
  class NSRulerView extends NSView {
    static registerUnitWithNameAbbreviationUnitToPointsConversionFactorStepUpCycleStepDownCycle(withName: string, abbreviation: string, unitToPointsConversionFactor: number, stepUpCycle: number[], stepDownCycle: number[]): void;
    accessoryView: NSView;
    setAccessoryView(_: NSView)
    baselineLocation: number;
    clientView: NSView;
    setClientView(_: NSView)
    markers: NSRulerMarker[];
    setMarkers(_: NSRulerMarker[])
    measurementUnits: string;
    setMeasurementUnits(_: string)
    orientation: NSRulerView.Orientation;
    setOrientation(_: NSRulerView.Orientation)
    originOffset: number;
    setOriginOffset(_: number)
    requiredThickness: number;
    reservedThicknessForAccessoryView: number;
    setReservedThicknessForAccessoryView(_: number)
    reservedThicknessForMarkers: number;
    setReservedThicknessForMarkers(_: number)
    ruleThickness: number;
    setRuleThickness(_: number)
    scrollView: NSScrollView;
    setScrollView(_: NSScrollView)
    addMarker(_: NSRulerMarker): void;
    drawHashMarksAndLabelsInRect(in_: CGRect): void;
    drawMarkersInRect(in_: CGRect): void;
    static createWithScrollViewOrientation(scrollView?: NSScrollView, orientation?: NSRulerView.Orientation): NSRulerView;
    invalidateHashMarks(): void;
    moveRulerlineFromLocationToLocation(fromLocation: number, toLocation: number): void;
    removeMarker(_: NSRulerMarker): void;
    trackMarkerWithMouseEvent(_: NSRulerMarker, withMouseEvent: NSEvent): boolean;
  }

  // interface
  class NSRunningApplication extends NSObject {
    static runningApplicationsWithBundleIdentifier(withBundleIdentifier: string): NSRunningApplication[];
    static terminateAutomaticallyTerminableApplications(): void;
    activationPolicy: NSApplication.ActivationPolicy;
    isActive: boolean;
    bundleIdentifier: string;
    bundleURL: NSURL;
    executableArchitecture: number;
    executableURL: NSURL;
    isFinishedLaunching: boolean;
    isHidden: boolean;
    icon: NSImage;
    launchDate: Date;
    localizedName: string;
    ownsMenuBar: boolean;
    processIdentifier: number;
    isTerminated: boolean;
    static currentApplication: NSRunningApplication;
    activateWithOptions(options: NSApplication.ActivationOptions): boolean;
    forceTerminate(): boolean;
    hide(): boolean;
    terminate(): boolean;
    unhide(): boolean;
  }

  // interface
  class NSSavePanel extends NSPanel {
    URL: NSURL;
    accessoryView: NSView;
    setAccessoryView(_: NSView)
    allowedFileTypes: string[];
    setAllowedFileTypes(_: string[])
    allowsOtherFileTypes: boolean;
    setAllowsOtherFileTypes(_: boolean)
    canCreateDirectories: boolean;
    setCanCreateDirectories(_: boolean)
    canSelectHiddenExtension: boolean;
    setCanSelectHiddenExtension(_: boolean)
    directoryURL: NSURL;
    setDirectoryURL(_: NSURL)
    isExpanded: boolean;
    isExtensionHidden: boolean;
    setExtensionHidden(_: boolean)
    message: string;
    setMessage(_: string)
    nameFieldLabel: string;
    setNameFieldLabel(_: string)
    nameFieldStringValue: string;
    setNameFieldStringValue(_: string)
    prompt: string;
    setPrompt(_: string)
    showsHiddenFiles: boolean;
    setShowsHiddenFiles(_: boolean)
    showsTagField: boolean;
    setShowsTagField(_: boolean)
    tagNames: string[];
    setTagNames(_: string[])
    treatsFilePackagesAsDirectories: boolean;
    setTreatsFilePackagesAsDirectories(_: boolean)
    beginSheetModalForCompletionHandler(for_: NSWindow, completionHandler: (p1: number) => void): void;
    beginWithCompletionHandler(completionHandler: (p1: number) => void): void;
    cancel(_?: any): void;
    ok(_?: any): void;
    runModal(): number;
    validateVisibleColumns(): void;
  }

  // interface
  class NSScreen extends NSObject {
    backingScaleFactor: number;
    colorSpace: NSColorSpace;
    depth: NSWindow.Depth;
    deviceDescription: Map<string, any>;
    frame: CGRect;
    localizedName: string;
    maximumExtendedDynamicRangeColorComponentValue: number;
    maximumPotentialExtendedDynamicRangeColorComponentValue: number;
    maximumReferenceExtendedDynamicRangeColorComponentValue: number;
    supportedWindowDepths: NSWindow.Depth;
    visibleFrame: CGRect;
    static deepestScreen: NSScreen;
    static mainScreen: NSScreen;
    static screens: NSScreen[];
    static screensHaveSeparateSpaces: boolean;
    backingAlignedRectOptions(_: CGRect, options: AlignmentOptions): CGRect;
    canRepresentDisplayGamut(_: NSDisplayGamut): boolean;
    convertRectFromBacking(_: CGRect): CGRect;
    convertRectToBacking(_: CGRect): CGRect;
  }

  // interface
  class NSScrollView extends NSView /* implements NSTextFinderBarContainer */ {
    static contentSizeForFrameSizeHorizontalScrollerClassVerticalScrollerClassBorderTypeControlSizeScrollerStyle(forFrameSize: CGSize, horizontalScrollerClass?: typeof NSObject, verticalScrollerClass?: typeof NSObject, borderType?: NSBorderType, controlSize?: NSControl.ControlSize, scrollerStyle?: NSScroller.Style): CGSize;
    static frameSizeForContentSizeHorizontalScrollerClassVerticalScrollerClassBorderTypeControlSizeScrollerStyle(forContentSize: CGSize, horizontalScrollerClass?: typeof NSObject, verticalScrollerClass?: typeof NSObject, borderType?: NSBorderType, controlSize?: NSControl.ControlSize, scrollerStyle?: NSScroller.Style): CGSize;
    allowsMagnification: boolean;
    setAllowsMagnification(_: boolean)
    autohidesScrollers: boolean;
    setAutohidesScrollers(_: boolean)
    automaticallyAdjustsContentInsets: boolean;
    setAutomaticallyAdjustsContentInsets(_: boolean)
    backgroundColor: NSColor;
    setBackgroundColor(_: NSColor)
    borderType: NSBorderType;
    setBorderType(_: NSBorderType)
    contentInsets: NSEdgeInsets;
    setContentInsets(_: NSEdgeInsets)
    contentSize: CGSize;
    contentView: NSClipView;
    setContentView(_: NSClipView)
    documentCursor: NSCursor;
    setDocumentCursor(_: NSCursor)
    documentView: NSView;
    setDocumentView(_: NSView)
    documentVisibleRect: CGRect;
    drawsBackground: boolean;
    setDrawsBackground(_: boolean)
    findBarPosition: NSScrollView.FindBarPosition;
    setFindBarPosition(_: NSScrollView.FindBarPosition)
    hasHorizontalRuler: boolean;
    setHasHorizontalRuler(_: boolean)
    hasHorizontalScroller: boolean;
    setHasHorizontalScroller(_: boolean)
    hasVerticalRuler: boolean;
    setHasVerticalRuler(_: boolean)
    hasVerticalScroller: boolean;
    setHasVerticalScroller(_: boolean)
    horizontalLineScroll: number;
    setHorizontalLineScroll(_: number)
    horizontalPageScroll: number;
    setHorizontalPageScroll(_: number)
    horizontalRulerView: NSRulerView;
    setHorizontalRulerView(_: NSRulerView)
    horizontalScrollElasticity: NSScrollView.Elasticity;
    setHorizontalScrollElasticity(_: NSScrollView.Elasticity)
    horizontalScroller: NSScroller;
    setHorizontalScroller(_: NSScroller)
    lineScroll: number;
    setLineScroll(_: number)
    magnification: number;
    setMagnification(_: number)
    maxMagnification: number;
    setMaxMagnification(_: number)
    minMagnification: number;
    setMinMagnification(_: number)
    pageScroll: number;
    setPageScroll(_: number)
    rulersVisible: boolean;
    setRulersVisible(_: boolean)
    scrollerInsets: NSEdgeInsets;
    setScrollerInsets(_: NSEdgeInsets)
    scrollerKnobStyle: NSScroller.KnobStyle;
    setScrollerKnobStyle(_: NSScroller.KnobStyle)
    scrollerStyle: NSScroller.Style;
    setScrollerStyle(_: NSScroller.Style)
    scrollsDynamically: boolean;
    setScrollsDynamically(_: boolean)
    usesPredominantAxisScrolling: boolean;
    setUsesPredominantAxisScrolling(_: boolean)
    verticalLineScroll: number;
    setVerticalLineScroll(_: number)
    verticalPageScroll: number;
    setVerticalPageScroll(_: number)
    verticalRulerView: NSRulerView;
    setVerticalRulerView(_: NSRulerView)
    verticalScrollElasticity: NSScrollView.Elasticity;
    setVerticalScrollElasticity(_: NSScrollView.Elasticity)
    verticalScroller: NSScroller;
    setVerticalScroller(_: NSScroller)
    static rulerViewClass: typeof NSObject;
    setRulerViewClass(_: typeof NSObject)
    addFloatingSubviewForAxis(_: NSView, for_: NSEvent.GestureAxis): void;
    flashScrollers(): void;
    magnifyToFitRect(toFit: CGRect): void;
    setMagnificationCenteredAtPoint(_: number, centeredAt: CGPoint): void;
    tile(): void;
  }

  // interface
  class NSScroller extends NSControl {
    static scrollerWidthForControlSizeScrollerStyle(for_: NSControl.ControlSize, scrollerStyle: NSScroller.Style): number;
    hitPart: NSScroller.Part;
    knobProportion: number;
    setKnobProportion(_: number)
    knobStyle: NSScroller.KnobStyle;
    setKnobStyle(_: NSScroller.KnobStyle)
    scrollerStyle: NSScroller.Style;
    setScrollerStyle(_: NSScroller.Style)
    usableParts: NSScroller.UsableParts;
    static isCompatibleWithOverlayScrollers: boolean;
    static preferredScrollerStyle: NSScroller.Style;
    checkSpaceForParts(): void;
    drawKnob(): void;
    drawKnobSlotInRectHighlight(in_: CGRect, highlight: boolean): void;
    rectForPart(for_: NSScroller.Part): CGRect;
    setKnobProportion(_: number): void;
    testPart(_: CGPoint): NSScroller.Part;
    trackKnob(with_: NSEvent): void;
  }

  // interface
  class NSScrubber extends NSView {
    backgroundColor: NSColor;
    setBackgroundColor(_: NSColor)
    backgroundView: NSView;
    setBackgroundView(_: NSView)
    isContinuous: boolean;
    setContinuous(_: boolean)
    dataSource: NSScrubberDataSource;
    setDataSource(_: NSScrubberDataSource)
    delegate: NSScrubberDelegate;
    setDelegate(_: NSScrubberDelegate)
    floatsSelectionViews: boolean;
    setFloatsSelectionViews(_: boolean)
    highlightedIndex: number;
    itemAlignment: NSScrubber.Alignment;
    setItemAlignment(_: NSScrubber.Alignment)
    mode: NSScrubber.Mode;
    setMode(_: NSScrubber.Mode)
    numberOfItems: number;
    scrubberLayout: NSScrubberLayout;
    setScrubberLayout(_: NSScrubberLayout)
    selectedIndex: number;
    setSelectedIndex(_: number)
    selectionBackgroundStyle: NSScrubberSelectionStyle;
    setSelectionBackgroundStyle(_: NSScrubberSelectionStyle)
    selectionOverlayStyle: NSScrubberSelectionStyle;
    setSelectionOverlayStyle(_: NSScrubberSelectionStyle)
    showsAdditionalContentIndicators: boolean;
    setShowsAdditionalContentIndicators(_: boolean)
    showsArrowButtons: boolean;
    setShowsArrowButtons(_: boolean)
    insertItemsAtIndexes(at: NSIndexSet): void;
    itemViewForItemAtIndex(at: number): NSScrubberItemView;
    makeItemWithIdentifierOwner(withIdentifier: string, owner?: any): NSScrubberItemView;
    moveItemAtIndexToIndex(at: number, to: number): void;
    performSequentialBatchUpdates(_: () => void): void;
    registerClassForItemIdentifier(_?: typeof NSObject, forItemIdentifier?: string): void;
    registerNibForItemIdentifier(_?: NSNib, forItemIdentifier?: string): void;
    reloadData(): void;
    reloadItemsAtIndexes(at: NSIndexSet): void;
    removeItemsAtIndexes(at: NSIndexSet): void;
    scrollItemAtIndexToAlignment(at: number, to: NSScrubber.Alignment): void;
  }

  // interface
  class NSScrubberArrangedView extends NSView {
    isHighlighted: boolean;
    setHighlighted(_: boolean)
    isSelected: boolean;
    setSelected(_: boolean)
    applyLayoutAttributes(_: NSScrubberLayoutAttributes): void;
  }

  interface NSScrubberDataSource extends NSObject {
    // instance method
    numberOfItemsForScrubber(for_: NSScrubber): number;
    // instance method
    scrubberViewForItemAtIndex(_: NSScrubber, viewForItemAt: number): NSScrubberItemView;
  }

  interface NSScrubberDelegate extends NSObject {
    // instance method
    didBeginInteractingWithScrubber?(with_: NSScrubber): void;
    // instance method
    didCancelInteractingWithScrubber?(with_: NSScrubber): void;
    // instance method
    didFinishInteractingWithScrubber?(with_: NSScrubber): void;
    // instance method
    scrubberDidSelectItemAtIndex?(_: NSScrubber, didSelectItemAt: number): void;
    // instance method
    scrubberDidHighlightItemAtIndex?(_: NSScrubber, didHighlightItemAt: number): void;
    // instance method
    scrubberDidChangeVisibleRange?(_: NSScrubber, didChangeVisibleRange: NSRange): void;
  }

  // interface
  class NSScrubberFlowLayout extends NSScrubberLayout {
    itemSize: CGSize;
    setItemSize(_: CGSize)
    itemSpacing: number;
    setItemSpacing(_: number)
    invalidateLayoutForItemsAtIndexes(at: NSIndexSet): void;
  }

  interface NSScrubberFlowLayoutDelegate extends NSScrubberDelegate {
    // instance method
    scrubberLayoutSizeForItemAtIndex?(_: NSScrubber, layout: NSScrubberFlowLayout, sizeForItemAt: number): CGSize;
  }

  // interface
  class NSScrubberImageItemView extends NSScrubberItemView {
    image: NSImage;
    setImage(_: NSImage)
    imageAlignment: NSImageAlignment;
    setImageAlignment(_: NSImageAlignment)
    imageView: NSImageView;
  }

  // interface
  class NSScrubberItemView extends NSScrubberArrangedView {
  }

  // interface
  class NSScrubberLayout extends NSObject /* implements NSCoding */ {
    automaticallyMirrorsInRightToLeftLayout: boolean;
    scrubber: NSScrubber;
    scrubberContentSize: CGSize;
    shouldInvalidateLayoutForHighlightChange: boolean;
    shouldInvalidateLayoutForSelectionChange: boolean;
    visibleRect: CGRect;
    static layoutAttributesClass: typeof NSObject;
    invalidateLayout(): void;
    layoutAttributesForItemAtIndex(at: number): NSScrubberLayoutAttributes;
    layoutAttributesForItemsInRect(in_: CGRect): NSSet<NSScrubberLayoutAttributes>;
    prepareLayout(): void;
    shouldInvalidateLayoutForChangeFromVisibleRectToVisibleRect(fromVisibleRect: CGRect, toVisibleRect: CGRect): boolean;
  }

  // interface
  class NSScrubberLayoutAttributes extends NSObject /* implements NSCopying */ {
    static layoutAttributesForItemAtIndex(forItemAt: number): NSScrubberLayoutAttributes;
    alpha: number;
    setAlpha(_: number)
    frame: CGRect;
    setFrame(_: CGRect)
    itemIndex: number;
    setItemIndex(_: number)
  }

  // interface
  class NSScrubberProportionalLayout extends NSScrubberLayout {
    numberOfVisibleItems: number;
    setNumberOfVisibleItems(_: number)
    static createWithNumberOfVisibleItems(numberOfVisibleItems: number): NSScrubberProportionalLayout;
  }

  // interface
  class NSScrubberSelectionStyle extends NSObject /* implements NSCoding */ {
    static outlineOverlayStyle: NSScrubberSelectionStyle;
    static roundedBackgroundStyle: NSScrubberSelectionStyle;
    makeSelectionView(): NSScrubberSelectionView;
  }

  // interface
  class NSScrubberSelectionView extends NSScrubberArrangedView {
  }

  // interface
  class NSScrubberTextItemView extends NSScrubberItemView {
    textField: NSTextField;
    title: string;
    setTitle(_: string)
  }

  // interface
  class NSSearchField extends NSTextField {
    centersPlaceholder: boolean;
    setCentersPlaceholder(_: boolean)
    maximumRecents: number;
    setMaximumRecents(_: number)
    recentSearches: string[];
    setRecentSearches(_: string[])
    recentsAutosaveName: string;
    setRecentsAutosaveName(_: string)
    searchMenuTemplate: NSMenu;
    setSearchMenuTemplate(_: NSMenu)
    sendsSearchStringImmediately: boolean;
    setSendsSearchStringImmediately(_: boolean)
    sendsWholeSearchString: boolean;
    setSendsWholeSearchString(_: boolean)
    rectForCancelButtonWhenCentered(whenCentered: boolean): CGRect;
    rectForSearchButtonWhenCentered(whenCentered: boolean): CGRect;
    rectForSearchTextWhenCentered(whenCentered: boolean): CGRect;
  }

  // interface
  class NSSearchFieldCell extends NSTextFieldCell {
    cancelButtonCell: NSButtonCell;
    setCancelButtonCell(_: NSButtonCell)
    maximumRecents: number;
    setMaximumRecents(_: number)
    recentSearches: string[];
    setRecentSearches(_: string[])
    recentsAutosaveName: string;
    setRecentsAutosaveName(_: string)
    searchButtonCell: NSButtonCell;
    setSearchButtonCell(_: NSButtonCell)
    searchMenuTemplate: NSMenu;
    setSearchMenuTemplate(_: NSMenu)
    sendsSearchStringImmediately: boolean;
    setSendsSearchStringImmediately(_: boolean)
    sendsWholeSearchString: boolean;
    setSendsWholeSearchString(_: boolean)
    cancelButtonRectForBounds(forBounds: CGRect): CGRect;
    resetCancelButtonCell(): void;
    resetSearchButtonCell(): void;
    searchButtonRectForBounds(forBounds: CGRect): CGRect;
    searchTextRectForBounds(forBounds: CGRect): CGRect;
  }

  interface NSSearchFieldDelegate extends NSTextFieldDelegate {
    // instance method
    searchFieldDidEndSearching?(_: NSSearchField): void;
    // instance method
    searchFieldDidStartSearching?(_: NSSearchField): void;
  }

  // interface
  class NSSecureTextField extends NSTextField {
  }

  // interface
  class NSSecureTextFieldCell extends NSTextFieldCell {
    echosBullets: boolean;
    setEchosBullets(_: boolean)
  }

  // interface
  class NSSegmentedCell extends NSActionCell {
    segmentCount: number;
    setSegmentCount(_: number)
    segmentStyle: NSSegmentedControl.Style;
    setSegmentStyle(_: NSSegmentedControl.Style)
    selectedSegment: number;
    setSelectedSegment(_: number)
    trackingMode: NSSegmentedControl.SwitchTracking;
    setTrackingMode(_: NSSegmentedControl.SwitchTracking)
    drawSegmentInFrameWithView(_: number, inFrame: CGRect, with_: NSView): void;
    imageForSegment(forSegment: number): NSImage;
    imageScalingForSegment(forSegment: number): NSImageScaling;
    interiorBackgroundStyleForSegment(forSegment: number): NSView.BackgroundStyle;
    isEnabledForSegment(forSegment: number): boolean;
    isSelectedForSegment(forSegment: number): boolean;
    labelForSegment(forSegment: number): string;
    makeNextSegmentKey(): void;
    makePreviousSegmentKey(): void;
    menuForSegment(forSegment: number): NSMenu;
    selectSegmentWithTag(withTag: number): boolean;
    setEnabledForSegment(_: boolean, forSegment: number): void;
    setImageForSegment(_?: NSImage, forSegment?: number): void;
    setImageScalingForSegment(_: NSImageScaling, forSegment: number): void;
    setLabelForSegment(_: string, forSegment: number): void;
    setMenuForSegment(_?: NSMenu, forSegment?: number): void;
    setSelectedForSegment(_: boolean, forSegment: number): void;
    setTagForSegment(_: number, forSegment: number): void;
    setToolTipForSegment(_?: string, forSegment?: number): void;
    setWidthForSegment(_: number, forSegment: number): void;
    tagForSegment(forSegment: number): number;
    toolTipForSegment(forSegment: number): string;
    widthForSegment(forSegment: number): number;
  }

  // interface
  class NSSegmentedControl extends NSControl /* implements NSUserInterfaceCompression */ {
    doubleValueForSelectedSegment: number;
    indexOfSelectedItem: number;
    segmentCount: number;
    setSegmentCount(_: number)
    segmentDistribution: NSSegmentedControl.Distribution;
    setSegmentDistribution(_: NSSegmentedControl.Distribution)
    segmentStyle: NSSegmentedControl.Style;
    setSegmentStyle(_: NSSegmentedControl.Style)
    selectedSegment: number;
    setSelectedSegment(_: number)
    selectedSegmentBezelColor: NSColor;
    setSelectedSegmentBezelColor(_: NSColor)
    isSpringLoaded: boolean;
    setSpringLoaded(_: boolean)
    trackingMode: NSSegmentedControl.SwitchTracking;
    setTrackingMode(_: NSSegmentedControl.SwitchTracking)
    alignmentForSegment(forSegment: number): NSTextAlignment;
    imageForSegment(forSegment: number): NSImage;
    imageScalingForSegment(forSegment: number): NSImageScaling;
    isEnabledForSegment(forSegment: number): boolean;
    isSelectedForSegment(forSegment: number): boolean;
    labelForSegment(forSegment: number): string;
    menuForSegment(forSegment: number): NSMenu;
    selectSegmentWithTag(withTag: number): boolean;
    setAlignmentForSegment(_: NSTextAlignment, forSegment: number): void;
    setEnabledForSegment(_: boolean, forSegment: number): void;
    setImageForSegment(_?: NSImage, forSegment?: number): void;
    setImageScalingForSegment(_: NSImageScaling, forSegment: number): void;
    setLabelForSegment(_: string, forSegment: number): void;
    setMenuForSegment(_?: NSMenu, forSegment?: number): void;
    setSelectedForSegment(_: boolean, forSegment: number): void;
    setShowsMenuIndicatorForSegment(_: boolean, forSegment: number): void;
    setTagForSegment(_: number, forSegment: number): void;
    setToolTipForSegment(_?: string, forSegment?: number): void;
    setWidthForSegment(_: number, forSegment: number): void;
    showsMenuIndicatorForSegment(forSegment: number): boolean;
    tagForSegment(forSegment: number): number;
    toolTipForSegment(forSegment: number): string;
    widthForSegment(forSegment: number): number;
  }

  interface NSSeguePerforming extends NSObject {
    // instance method
    performSegueWithIdentifierSender?(withIdentifier: string, sender?: any): void;
    // instance method
    prepareForSegueSender?(for_: NSStoryboardSegue, sender?: any): void;
    // instance method
    shouldPerformSegueWithIdentifierSender?(withIdentifier: string, sender?: any): boolean;
  }

  interface NSServicesMenuRequestor extends NSObject {
    // instance method
    readSelectionFromPasteboard?(from: NSPasteboard): boolean;
    // instance method
    writeSelectionToPasteboardTypes?(to: NSPasteboard, types: string[]): boolean;
  }

  // export function NSSetFocusRingStyle(placement: NSFocusRingPlacement): void;

  // export function NSSetShowsServicesMenuItem(itemName: string, enabled: boolean): number;

  // interface
  class NSShadow extends NSObject /* implements NSCopying, NSSecureCoding */ {
    shadowBlurRadius: number;
    setShadowBlurRadius(_: number)
    shadowColor: NSColor;
    setShadowColor(_: NSColor)
    shadowOffset: CGSize;
    setShadowOffset(_: CGSize)
    set(): void;
  }

  // interface
  class NSSharingService extends NSObject {
    static sharingServicesForItems(forItems: any[]): NSSharingService[];
    accountName: string;
    alternateImage: NSImage;
    attachmentFileURLs: NSURL[];
    delegate: NSSharingServiceDelegate;
    setDelegate(_: NSSharingServiceDelegate)
    image: NSImage;
    menuItemTitle: string;
    setMenuItemTitle(_: string)
    messageBody: string;
    permanentLink: NSURL;
    recipients: string[];
    setRecipients(_: string[])
    subject: string;
    setSubject(_: string)
    title: string;
    canPerformWithItems(withItems?: any[]): boolean;
    static createWithTitleImageAlternateImageHandler(title: string, image: NSImage, alternateImage?: NSImage, handler?: () => void): NSSharingService;
    performWithItems(withItems: any[]): void;
  }

  interface NSSharingServiceDelegate extends NSObject {
    // instance method
    anchoringViewForSharingServiceShowRelativeToRectPreferredEdge?(for_: NSSharingService, showRelativeTo: NSRect, preferredEdge: NSRectEdge): NSView;
    // instance method
    sharingServiceDidFailToShareItemsError?(_: NSSharingService, didFailToShareItems: any[], error: NSError): void;
    // instance method
    sharingServiceDidShareItems?(_: NSSharingService, didShareItems: any[]): void;
    // instance method
    sharingServiceSourceFrameOnScreenForShareItem?(_: NSSharingService, sourceFrameOnScreenForShareItem: any): CGRect;
    // instance method
    sharingServiceSourceWindowForShareItemsSharingContentScope?(_: NSSharingService, sourceWindowForShareItems: any[], sharingContentScope: NSSharingService.SharingContentScope): NSWindow;
    // instance method
    sharingServiceTransitionImageForShareItemContentRect?(_: NSSharingService, transitionImageForShareItem: any, contentRect: NSRect): NSImage;
    // instance method
    sharingServiceWillShareItems?(_: NSSharingService, willShareItems: any[]): void;
  }

  // interface
  class NSSharingServicePicker extends NSObject {
    delegate: NSSharingServicePickerDelegate;
    setDelegate(_: NSSharingServicePickerDelegate)
    static createWithItems(items: any[]): NSSharingServicePicker;
    showRelativeToRectOfViewPreferredEdge(relativeTo: CGRect, of: NSView, preferredEdge: NSRectEdge): void;
  }

  interface NSSharingServicePickerDelegate extends NSObject {
    // instance method
    sharingServicePickerDelegateForSharingService?(_: NSSharingServicePicker, delegateFor: NSSharingService): NSSharingServiceDelegate;
    // instance method
    sharingServicePickerDidChooseSharingService?(_: NSSharingServicePicker, didChoose?: NSSharingService): void;
    // instance method
    sharingServicePickerSharingServicesForItemsProposedSharingServices?(_: NSSharingServicePicker, sharingServicesForItems: any[], proposedSharingServices: NSSharingService[]): NSSharingService[];
  }

  // interface
  class NSSharingServicePickerToolbarItem extends NSToolbarItem {
    delegate: NSSharingServicePickerToolbarItemDelegate;
    setDelegate(_: NSSharingServicePickerToolbarItemDelegate)
  }

  interface NSSharingServicePickerToolbarItemDelegate extends NSSharingServicePickerDelegate {
    // instance method
    itemsForSharingServicePickerToolbarItem(for_: NSSharingServicePickerToolbarItem): any[];
  }

  // interface
  class NSSharingServicePickerTouchBarItem extends NSTouchBarItem {
    buttonImage: NSImage;
    setButtonImage(_: NSImage)
    buttonTitle: string;
    setButtonTitle(_: string)
    delegate: NSSharingServicePickerTouchBarItemDelegate;
    setDelegate(_: NSSharingServicePickerTouchBarItemDelegate)
    isEnabled: boolean;
    setEnabled(_: boolean)
  }

  interface NSSharingServicePickerTouchBarItemDelegate extends NSSharingServicePickerDelegate {
    // instance method
    itemsForSharingServicePickerTouchBarItem(for_: NSSharingServicePickerTouchBarItem): any[];
  }

  // export function NSShowAnimationEffect(animationEffect: NSAnimationEffect, centerLocation: CGPoint, size: CGSize, animationDelegate: any, didEndSelector: string, contextInfo: any): void;

  // export function NSShowsServicesMenuItem(itemName: string): boolean;

  // interface
  class NSSlider extends NSControl /* implements NSAccessibilitySlider */ {
    allowsTickMarkValuesOnly: boolean;
    setAllowsTickMarkValuesOnly(_: boolean)
    altIncrementValue: number;
    setAltIncrementValue(_: number)
    knobThickness: number;
    maxValue: number;
    setMaxValue(_: number)
    minValue: number;
    setMinValue(_: number)
    numberOfTickMarks: number;
    setNumberOfTickMarks(_: number)
    sliderType: NSSlider.SliderType;
    setSliderType(_: NSSlider.SliderType)
    tickMarkPosition: NSSlider.TickMarkPosition;
    setTickMarkPosition(_: NSSlider.TickMarkPosition)
    trackFillColor: NSColor;
    setTrackFillColor(_: NSColor)
    isVertical: boolean;
    closestTickMarkValueToValue(toValue: number): number;
    indexOfTickMarkAtPoint(at: CGPoint): number;
    rectOfTickMarkAtIndex(at: number): CGRect;
    tickMarkValueAtIndex(at: number): number;
  }

  // interface
  class NSSliderAccessory extends NSObject /* implements NSCoding, NSAccessibility, NSAccessibilityElement */ {
    behavior: NSSliderAccessoryBehavior;
    setBehavior(_: NSSliderAccessoryBehavior)
    isEnabled: boolean;
    setEnabled(_: boolean)
  }

  // interface
  class NSSliderAccessoryBehavior extends NSObject /* implements NSCoding, NSCopying */ {
    static initWithHandler(handler: (p1: NSSliderAccessory) => void): NSSliderAccessoryBehavior;
    static behaviorWithTargetAction(target?: any, action?: string): NSSliderAccessoryBehavior;
    static automaticBehavior: NSSliderAccessoryBehavior;
    static valueResetBehavior: NSSliderAccessoryBehavior;
    static valueStepBehavior: NSSliderAccessoryBehavior;
    handleAction(_: NSSliderAccessory): void;
  }

  // interface
  class NSSliderCell extends NSActionCell {
    allowsTickMarkValuesOnly: boolean;
    setAllowsTickMarkValuesOnly(_: boolean)
    altIncrementValue: number;
    setAltIncrementValue(_: number)
    knobThickness: number;
    maxValue: number;
    setMaxValue(_: number)
    minValue: number;
    setMinValue(_: number)
    numberOfTickMarks: number;
    setNumberOfTickMarks(_: number)
    sliderType: NSSlider.SliderType;
    setSliderType(_: NSSlider.SliderType)
    tickMarkPosition: NSSlider.TickMarkPosition;
    setTickMarkPosition(_: NSSlider.TickMarkPosition)
    trackRect: CGRect;
    isVertical: boolean;
    barRectFlipped(flipped: boolean): CGRect;
    closestTickMarkValueToValue(toValue: number): number;
    drawBarInsideFlipped(inside: CGRect, flipped: boolean): void;
    drawKnob(): void;
    drawKnob(_: CGRect): void;
    drawTickMarks(): void;
    indexOfTickMarkAtPoint(at: CGPoint): number;
    knobRectFlipped(flipped: boolean): CGRect;
    rectOfTickMarkAtIndex(at: number): CGRect;
    tickMarkValueAtIndex(at: number): number;
  }

  // interface
  class NSSliderTouchBarItem extends NSTouchBarItem {
    action: string;
    setAction(_: string)
    doubleValue: number;
    setDoubleValue(_: number)
    label: string;
    setLabel(_: string)
    maximumSliderWidth: number;
    setMaximumSliderWidth(_: number)
    maximumValueAccessory: NSSliderAccessory;
    setMaximumValueAccessory(_: NSSliderAccessory)
    minimumSliderWidth: number;
    setMinimumSliderWidth(_: number)
    minimumValueAccessory: NSSliderAccessory;
    setMinimumValueAccessory(_: NSSliderAccessory)
    slider: NSSlider;
    setSlider(_: NSSlider)
    target: any;
    setTarget(_: any)
    valueAccessoryWidth: number;
    setValueAccessoryWidth(_: number)
  }

  // interface
  class NSSound extends NSObject /* implements NSCopying, NSPasteboardReading, NSPasteboardWriting, NSSecureCoding */ {
    static canInitWithPasteboard(with_: NSPasteboard): boolean;
    currentTime: number;
    setCurrentTime(_: number)
    delegate: NSSoundDelegate;
    setDelegate(_: NSSoundDelegate)
    duration: number;
    loops: boolean;
    setLoops(_: boolean)
    name: string;
    playbackDeviceIdentifier: string;
    setPlaybackDeviceIdentifier(_: string)
    isPlaying: boolean;
    volume: number;
    setVolume(_: number)
    static soundUnfilteredTypes: string[];
    static createWithContentsOfFileByReference(contentsOfFile: string, byReference: boolean): NSSound;
    static createWithContentsOfURLByReference(contentsOfURL: NSURL, byReference: boolean): NSSound;
    static createWithData(data: NSData): NSSound;
    static createWithPasteboard(pasteboard: NSPasteboard): NSSound;
    pause(): boolean;
    play(): boolean;
    resume(): boolean;
    setName(_?: string): boolean;
    stop(): boolean;
    writeToPasteboard(to: NSPasteboard): void;
  }

  interface NSSoundDelegate extends NSObject {
    // instance method
    soundDidFinishPlaying?(_: NSSound, didFinishPlaying: boolean): void;
  }

  // interface
  class NSSpeechRecognizer extends NSObject {
    blocksOtherRecognizers: boolean;
    setBlocksOtherRecognizers(_: boolean)
    commands: string[];
    setCommands(_: string[])
    delegate: NSSpeechRecognizerDelegate;
    setDelegate(_: NSSpeechRecognizerDelegate)
    displayedCommandsTitle: string;
    setDisplayedCommandsTitle(_: string)
    listensInForegroundOnly: boolean;
    setListensInForegroundOnly(_: boolean)
    startListening(): void;
    stopListening(): void;
  }

  interface NSSpeechRecognizerDelegate extends NSObject {
    // instance method
    speechRecognizerDidRecognizeCommand?(_: NSSpeechRecognizer, didRecognizeCommand: string): void;
  }

  // interface
  class NSSpeechSynthesizer extends NSObject {
    static attributesForVoice(forVoice: string): Map<string, any>;
    delegate: NSSpeechSynthesizerDelegate;
    setDelegate(_: NSSpeechSynthesizerDelegate)
    rate: number;
    setRate(_: number)
    isSpeaking: boolean;
    usesFeedbackWindow: boolean;
    setUsesFeedbackWindow(_: boolean)
    volume: number;
    setVolume(_: number)
    static isAnyApplicationSpeaking: boolean;
    static availableVoices: string[];
    static defaultVoice: string;
    addSpeechDictionary(_: Map<string, any>): void;
    continueSpeaking(): void;
    static createWithVoice(voice?: string): NSSpeechSynthesizer;
    objectForPropertyError(error: string): any;
    pauseSpeakingAtBoundary(at: NSSpeechSynthesizer.Boundary): void;
    phonemesFromText(from: string): string;
    setObjectForPropertyError(forProperty?: any, error?: string): boolean;
    setVoice(_?: string): boolean;
    startSpeakingString(_: string): boolean;
    startSpeakingStringToURL(_: string, to: NSURL): boolean;
    stopSpeaking(): void;
    stopSpeakingAtBoundary(at: NSSpeechSynthesizer.Boundary): void;
    voice(): string;
  }

  interface NSSpeechSynthesizerDelegate extends NSObject {
    // instance method
    speechSynthesizerWillSpeakWordOfString?(_: NSSpeechSynthesizer, willSpeakWord: NSRange, of: string): void;
    // instance method
    speechSynthesizerDidEncounterErrorAtIndexOfStringMessage?(_: NSSpeechSynthesizer, didEncounterErrorAt: number, of: string, message: string): void;
    // instance method
    speechSynthesizerDidEncounterSyncMessage?(_: NSSpeechSynthesizer, didEncounterSyncMessage: string): void;
    // instance method
    speechSynthesizerDidFinishSpeaking?(_: NSSpeechSynthesizer, didFinishSpeaking: boolean): void;
    // instance method
    speechSynthesizerWillSpeakPhoneme?(_: NSSpeechSynthesizer, willSpeakPhoneme: number): void;
  }

  // interface
  class NSSpellChecker extends NSObject {
    static uniqueSpellDocumentTag(): number;
    accessoryView: NSView;
    setAccessoryView(_: NSView)
    automaticallyIdentifiesLanguages: boolean;
    setAutomaticallyIdentifiesLanguages(_: boolean)
    availableLanguages: string[];
    spellingPanel: NSPanel;
    substitutionsPanel: NSPanel;
    substitutionsPanelAccessoryViewController: NSViewController;
    setSubstitutionsPanelAccessoryViewController(_: NSViewController)
    userPreferredLanguages: string[];
    userReplacementsDictionary: Map<string, string>;
    static isAutomaticCapitalizationEnabled: boolean;
    static isAutomaticDashSubstitutionEnabled: boolean;
    static isAutomaticPeriodSubstitutionEnabled: boolean;
    static isAutomaticQuoteSubstitutionEnabled: boolean;
    static isAutomaticSpellingCorrectionEnabled: boolean;
    static isAutomaticTextCompletionEnabled: boolean;
    static isAutomaticTextReplacementEnabled: boolean;
    static sharedSpellChecker: NSSpellChecker;
    static sharedSpellCheckerExists: boolean;
    checkGrammarOfStringStartingAtLanguageWrapInSpellDocumentWithTagDetails(of: string, startingAt: number, language?: string, wrap?: boolean, inSpellDocumentWithTag?: number, details?: Map<string, any>[]): NSRange;
    checkSpellingOfStringStartingAt(of: string, startingAt: number): NSRange;
    checkSpellingOfStringStartingAtLanguageWrapInSpellDocumentWithTagWordCount(of: string, startingAt: number, language?: string, wrap?: boolean, inSpellDocumentWithTag?: number, wordCount?: number): NSRange;
    checkStringRangeTypesOptionsInSpellDocumentWithTagOrthographyWordCount(_: string, range: NSRange, types: number, options?: Map<string, any>, inSpellDocumentWithTag?: number, orthography?: NSOrthography, wordCount?: number): NSTextCheckingResult[];
    closeSpellDocumentWithTag(withTag: number): void;
    completionsForPartialWordRangeInStringLanguageInSpellDocumentWithTag(forPartialWordRange: NSRange, in_: string, language?: string, inSpellDocumentWithTag?: number): string[];
    correctionForWordRangeInStringLanguageInSpellDocumentWithTag(forWordRange: NSRange, in_: string, language: string, inSpellDocumentWithTag: number): string;
    countWordsInStringLanguage(in_: string, language?: string): number;
    deletesAutospaceBetweenStringAndStringLanguage(_: string, andString: string, language?: string): boolean;
    dismissCorrectionIndicatorForView(for_: NSView): void;
    guessesForWordRangeInStringLanguageInSpellDocumentWithTag(forWordRange: NSRange, in_: string, language?: string, inSpellDocumentWithTag?: number): string[];
    hasLearnedWord(_: string): boolean;
    ignoreWordInSpellDocumentWithTag(_: string, inSpellDocumentWithTag: number): void;
    ignoredWordsInSpellDocumentWithTag(inSpellDocumentWithTag: number): string[];
    language(): string;
    languageForWordRangeInStringOrthography(forWordRange: NSRange, in_: string, orthography?: NSOrthography): string;
    learnWord(_: string): void;
    menuForResultStringOptionsAtLocationInView(for_: NSTextCheckingResult, string: string, options?: Map<string, any>, atLocation?: CGPoint, in_?: NSView): NSMenu;
    preventsAutocorrectionBeforeStringLanguage(before: string, language?: string): boolean;
    recordResponseToCorrectionForWordLanguageInSpellDocumentWithTag(_: NSSpellChecker.CorrectionResponse, toCorrection: string, forWord: string, language?: string, inSpellDocumentWithTag?: number): void;
    requestCandidatesWithForSelectedRangeInTypesOptionsInSpellDocumentWithTagCompletionHandler(forSelectedRange: NSRange, in_: string, types: number, options?: Map<string, any>, inSpellDocumentWithTag?: number, completionHandler?: (p1: number, p2: NSTextCheckingResult[]) => void): number;
    requestCheckingOfRangeTypesOptionsInSpellDocumentWithTagCompletionHandler(of: string, range: NSRange, types: number, options?: Map<string, any>, inSpellDocumentWithTag?: number, completionHandler?: (p1: number, p2: NSTextCheckingResult[], p3: NSOrthography, p4: number) => void): number;
    setIgnoredWordsInSpellDocumentWithTag(_: string[], inSpellDocumentWithTag: number): void;
    setLanguage(_: string): boolean;
    setWordFieldStringValue(_: string): void;
    showCorrectionIndicatorOfPrimaryStringAlternativeStringsForStringInViewCompletionHandler(of: NSSpellChecker.CorrectionIndicatorType, primaryString: string, alternativeStrings: string[], forStringIn: CGRect, view: NSView, completionHandler?: (p1: string) => void): void;
    unlearnWord(_: string): void;
    updatePanels(): void;
    updateSpellingPanelWithGrammarStringDetail(withGrammarString: string, detail: Map<string, any>): void;
    updateSpellingPanelWithMisspelledWord(withMisspelledWord: string): void;
    userQuotesArrayForLanguage(forLanguage: string): string[];
  }

  // interface
  class NSSplitView extends NSView {
    arrangedSubviews: NSView[];
    arrangesAllSubviews: boolean;
    setArrangesAllSubviews(_: boolean)
    autosaveName: string;
    setAutosaveName(_: string)
    delegate: NSSplitViewDelegate;
    setDelegate(_: NSSplitViewDelegate)
    dividerColor: NSColor;
    dividerStyle: NSSplitView.DividerStyle;
    setDividerStyle(_: NSSplitView.DividerStyle)
    dividerThickness: number;
    isVertical: boolean;
    setVertical(_: boolean)
    addArrangedSubview(_: NSView): void;
    adjustSubviews(): void;
    drawDividerInRect(in_: CGRect): void;
    holdingPriorityForSubviewAtIndex(at: number): number;
    insertArrangedSubviewAtIndex(_: NSView, at: number): void;
    isSubviewCollapsed(_: NSView): boolean;
    maxPossiblePositionOfDividerAtIndex(at: number): number;
    minPossiblePositionOfDividerAtIndex(at: number): number;
    removeArrangedSubview(_: NSView): void;
    setHoldingPriorityForSubviewAtIndex(_: number, forSubviewAt: number): void;
    setPositionOfDividerAtIndex(_: number, ofDividerAt: number): void;
  }

  // interface
  class NSSplitViewController extends NSViewController /* implements NSSplitViewDelegate, NSUserInterfaceValidations */ {
    minimumThicknessForInlineSidebars: number;
    setMinimumThicknessForInlineSidebars(_: number)
    splitView: NSSplitView;
    setSplitView(_: NSSplitView)
    splitViewItems: NSSplitViewItem[];
    setSplitViewItems(_: NSSplitViewItem[])
    addSplitViewItem(_: NSSplitViewItem): void;
    insertSplitViewItemAtIndex(_: NSSplitViewItem, at: number): void;
    removeSplitViewItem(_: NSSplitViewItem): void;
    splitViewItemForViewController(for_: NSViewController): NSSplitViewItem;
    toggleSidebar(_?: any): void;
  }

  interface NSSplitViewDelegate extends NSObject {
    // instance method
    splitViewShouldHideDividerAtIndex?(_: NSSplitView, shouldHideDividerAt: number): boolean;
    // instance method
    splitViewEffectiveRectForDrawnRectOfDividerAtIndex?(_: NSSplitView, effectiveRect: CGRect, forDrawnRect: CGRect, ofDividerAt: number): CGRect;
    // instance method
    splitViewAdditionalEffectiveRectOfDividerAtIndex?(_: NSSplitView, additionalEffectiveRectOfDividerAt: number): CGRect;
    // instance method
    splitViewCanCollapseSubview?(_: NSSplitView, canCollapseSubview: NSView): boolean;
    // instance method
    splitViewConstrainMaxCoordinateOfSubviewAt?(_: NSSplitView, constrainMaxCoordinate: number, ofSubviewAt: number): number;
    // instance method
    splitViewConstrainMinCoordinateOfSubviewAt?(_: NSSplitView, constrainMinCoordinate: number, ofSubviewAt: number): number;
    // instance method
    splitViewConstrainSplitPositionOfSubviewAt?(_: NSSplitView, constrainSplitPosition: number, ofSubviewAt: number): number;
    // instance method
    splitViewResizeSubviewsWithOldSize?(_: NSSplitView, resizeSubviewsWithOldSize: CGSize): void;
    // instance method
    splitViewShouldAdjustSizeOfSubview?(_: NSSplitView, shouldAdjustSizeOfSubview: NSView): boolean;
    // instance method
    splitViewDidResizeSubviews?(_: NSNotification): void;
    // instance method
    splitViewWillResizeSubviews?(_: NSNotification): void;
  }

  // interface
  class NSSplitViewItem extends NSObject /* implements NSAnimatablePropertyContainer, NSCoding */ {
    static contentListWithViewController(contentListWithViewController: NSViewController): NSSplitViewItem;
    static sidebarWithViewController(sidebarWithViewController: NSViewController): NSSplitViewItem;
    automaticMaximumThickness: number;
    setAutomaticMaximumThickness(_: number)
    behavior: NSSplitViewItem.Behavior;
    canCollapse: boolean;
    setCanCollapse(_: boolean)
    collapseBehavior: NSSplitViewItem.CollapseBehavior;
    setCollapseBehavior(_: NSSplitViewItem.CollapseBehavior)
    isCollapsed: boolean;
    setCollapsed(_: boolean)
    holdingPriority: number;
    setHoldingPriority(_: number)
    maximumThickness: number;
    setMaximumThickness(_: number)
    minimumThickness: number;
    setMinimumThickness(_: number)
    preferredThicknessFraction: number;
    setPreferredThicknessFraction(_: number)
    isSpringLoaded: boolean;
    setSpringLoaded(_: boolean)
    viewController: NSViewController;
    setViewController(_: NSViewController)
  }

  interface NSSpringLoadingDestination extends NSObject {
    // instance method
    draggingEnded?(_: NSDraggingInfo): void;
    // instance method
    springLoadingActivatedDraggingInfo(_: boolean, draggingInfo: NSDraggingInfo): void;
    // instance method
    springLoadingEntered?(_: NSDraggingInfo): NSSpringLoadingOptions;
    // instance method
    springLoadingExited?(_: NSDraggingInfo): void;
    // instance method
    springLoadingHighlightChanged(_: NSDraggingInfo): void;
    // instance method
    springLoadingUpdated?(_: NSDraggingInfo): NSSpringLoadingOptions;
  }

  // interface
  class NSStackView extends NSView {
    alignment: NSLayoutConstraint.Attribute;
    setAlignment(_: NSLayoutConstraint.Attribute)
    arrangedSubviews: NSView[];
    delegate: NSStackViewDelegate;
    setDelegate(_: NSStackViewDelegate)
    detachedViews: NSView[];
    detachesHiddenViews: boolean;
    setDetachesHiddenViews(_: boolean)
    distribution: NSStackView.Distribution;
    setDistribution(_: NSStackView.Distribution)
    edgeInsets: NSEdgeInsets;
    setEdgeInsets(_: NSEdgeInsets)
    orientation: NSUserInterfaceLayoutOrientation;
    setOrientation(_: NSUserInterfaceLayoutOrientation)
    spacing: number;
    setSpacing(_: number)
    views: NSView[];
    addArrangedSubview(_: NSView): void;
    addViewInGravity(_: NSView, in_: NSStackView.Gravity): void;
    clippingResistancePriorityForOrientation(for_: NSLayoutConstraint.Orientation): number;
    customSpacingAfterView(after: NSView): number;
    huggingPriorityForOrientation(for_: NSLayoutConstraint.Orientation): number;
    insertArrangedSubviewAtIndex(_: NSView, at: number): void;
    insertViewAtIndexInGravity(_: NSView, at: number, in_: NSStackView.Gravity): void;
    removeArrangedSubview(_: NSView): void;
    removeView(_: NSView): void;
    setClippingResistancePriorityForOrientation(_: number, for_: NSLayoutConstraint.Orientation): void;
    setCustomSpacingAfterView(_: number, after: NSView): void;
    setHuggingPriorityForOrientation(_: number, for_: NSLayoutConstraint.Orientation): void;
    setViewsInGravity(_: NSView[], in_: NSStackView.Gravity): void;
    setVisibilityPriorityForView(_: number, for_: NSView): void;
    viewsInGravity(in_: NSStackView.Gravity): NSView[];
    visibilityPriorityForView(for_: NSView): number;
  }

  interface NSStackViewDelegate extends NSObject {
    // instance method
    stackViewWillDetachViews?(_: NSStackView, willDetach: NSView[]): void;
    // instance method
    stackViewDidReattachViews?(_: NSStackView, didReattach: NSView[]): void;
  }

  interface NSStandardKeyBindingResponding extends NSObject {
    // instance method
    cancelOperation?(_?: any): void;
    // instance method
    capitalizeWord?(_?: any): void;
    // instance method
    centerSelectionInVisibleArea?(_?: any): void;
    // instance method
    changeCaseOfLetter?(_?: any): void;
    // instance method
    complete?(_?: any): void;
    // instance method
    deleteBackward?(_?: any): void;
    // instance method
    deleteBackwardByDecomposingPreviousCharacter?(_?: any): void;
    // instance method
    deleteForward?(_?: any): void;
    // instance method
    deleteToBeginningOfLine?(_?: any): void;
    // instance method
    deleteToBeginningOfParagraph?(_?: any): void;
    // instance method
    deleteToEndOfLine?(_?: any): void;
    // instance method
    deleteToEndOfParagraph?(_?: any): void;
    // instance method
    deleteToMark?(_?: any): void;
    // instance method
    deleteWordBackward?(_?: any): void;
    // instance method
    deleteWordForward?(_?: any): void;
    // instance method
    doCommandBySelector?(by: string): void;
    // instance method
    indent?(_?: any): void;
    // instance method
    insertBacktab?(_?: any): void;
    // instance method
    insertContainerBreak?(_?: any): void;
    // instance method
    insertDoubleQuoteIgnoringSubstitution?(_?: any): void;
    // instance method
    insertLineBreak?(_?: any): void;
    // instance method
    insertNewline?(_?: any): void;
    // instance method
    insertNewlineIgnoringFieldEditor?(_?: any): void;
    // instance method
    insertParagraphSeparator?(_?: any): void;
    // instance method
    insertSingleQuoteIgnoringSubstitution?(_?: any): void;
    // instance method
    insertTab?(_?: any): void;
    // instance method
    insertTabIgnoringFieldEditor?(_?: any): void;
    // instance method
    insertText?(_: any): void;
    // instance method
    lowercaseWord?(_?: any): void;
    // instance method
    makeBaseWritingDirectionLeftToRight?(_?: any): void;
    // instance method
    makeBaseWritingDirectionNatural?(_?: any): void;
    // instance method
    makeBaseWritingDirectionRightToLeft?(_?: any): void;
    // instance method
    makeTextWritingDirectionLeftToRight?(_?: any): void;
    // instance method
    makeTextWritingDirectionNatural?(_?: any): void;
    // instance method
    makeTextWritingDirectionRightToLeft?(_?: any): void;
    // instance method
    moveBackward?(_?: any): void;
    // instance method
    moveBackwardAndModifySelection?(_?: any): void;
    // instance method
    moveDown?(_?: any): void;
    // instance method
    moveDownAndModifySelection?(_?: any): void;
    // instance method
    moveForward?(_?: any): void;
    // instance method
    moveForwardAndModifySelection?(_?: any): void;
    // instance method
    moveLeft?(_?: any): void;
    // instance method
    moveLeftAndModifySelection?(_?: any): void;
    // instance method
    moveParagraphBackwardAndModifySelection?(_?: any): void;
    // instance method
    moveParagraphForwardAndModifySelection?(_?: any): void;
    // instance method
    moveRight?(_?: any): void;
    // instance method
    moveRightAndModifySelection?(_?: any): void;
    // instance method
    moveToBeginningOfDocument?(_?: any): void;
    // instance method
    moveToBeginningOfDocumentAndModifySelection?(_?: any): void;
    // instance method
    moveToBeginningOfLine?(_?: any): void;
    // instance method
    moveToBeginningOfLineAndModifySelection?(_?: any): void;
    // instance method
    moveToBeginningOfParagraph?(_?: any): void;
    // instance method
    moveToBeginningOfParagraphAndModifySelection?(_?: any): void;
    // instance method
    moveToEndOfDocument?(_?: any): void;
    // instance method
    moveToEndOfDocumentAndModifySelection?(_?: any): void;
    // instance method
    moveToEndOfLine?(_?: any): void;
    // instance method
    moveToEndOfLineAndModifySelection?(_?: any): void;
    // instance method
    moveToEndOfParagraph?(_?: any): void;
    // instance method
    moveToEndOfParagraphAndModifySelection?(_?: any): void;
    // instance method
    moveToLeftEndOfLine?(_?: any): void;
    // instance method
    moveToLeftEndOfLineAndModifySelection?(_?: any): void;
    // instance method
    moveToRightEndOfLine?(_?: any): void;
    // instance method
    moveToRightEndOfLineAndModifySelection?(_?: any): void;
    // instance method
    moveUp?(_?: any): void;
    // instance method
    moveUpAndModifySelection?(_?: any): void;
    // instance method
    moveWordBackward?(_?: any): void;
    // instance method
    moveWordBackwardAndModifySelection?(_?: any): void;
    // instance method
    moveWordForward?(_?: any): void;
    // instance method
    moveWordForwardAndModifySelection?(_?: any): void;
    // instance method
    moveWordLeft?(_?: any): void;
    // instance method
    moveWordLeftAndModifySelection?(_?: any): void;
    // instance method
    moveWordRight?(_?: any): void;
    // instance method
    moveWordRightAndModifySelection?(_?: any): void;
    // instance method
    pageDown?(_?: any): void;
    // instance method
    pageDownAndModifySelection?(_?: any): void;
    // instance method
    pageUp?(_?: any): void;
    // instance method
    pageUpAndModifySelection?(_?: any): void;
    // instance method
    quickLookPreviewItems?(_?: any): void;
    // instance method
    scrollLineDown?(_?: any): void;
    // instance method
    scrollLineUp?(_?: any): void;
    // instance method
    scrollPageDown?(_?: any): void;
    // instance method
    scrollPageUp?(_?: any): void;
    // instance method
    scrollToBeginningOfDocument?(_?: any): void;
    // instance method
    scrollToEndOfDocument?(_?: any): void;
    // instance method
    selectAll?(_?: any): void;
    // instance method
    selectLine?(_?: any): void;
    // instance method
    selectParagraph?(_?: any): void;
    // instance method
    selectToMark?(_?: any): void;
    // instance method
    selectWord?(_?: any): void;
    // instance method
    setMark?(_?: any): void;
    // instance method
    swapWithMark?(_?: any): void;
    // instance method
    transpose?(_?: any): void;
    // instance method
    transposeWords?(_?: any): void;
    // instance method
    uppercaseWord?(_?: any): void;
    // instance method
    yank?(_?: any): void;
  }

  // interface
  class NSStatusBar extends NSObject {
    thickness: number;
    isVertical: boolean;
    static systemStatusBar: NSStatusBar;
    removeStatusItem(_: NSStatusItem): void;
    statusItemWithLength(withLength: number): NSStatusItem;
  }

  // interface
  class NSStatusBarButton extends NSButton {
    appearsDisabled: boolean;
    setAppearsDisabled(_: boolean)
  }

  // interface
  class NSStatusItem extends NSObject {
    autosaveName: string;
    setAutosaveName(_: string)
    behavior: NSStatusItem.Behavior;
    setBehavior(_: NSStatusItem.Behavior)
    button: NSStatusBarButton;
    length: number;
    setLength(_: number)
    menu: NSMenu;
    setMenu(_: NSMenu)
    statusBar: NSStatusBar;
    isVisible: boolean;
    setVisible(_: boolean)
  }

  // interface
  class NSStepper extends NSControl /* implements NSAccessibilityStepper */ {
    autorepeat: boolean;
    setAutorepeat(_: boolean)
    increment: number;
    setIncrement(_: number)
    maxValue: number;
    setMaxValue(_: number)
    minValue: number;
    setMinValue(_: number)
    valueWraps: boolean;
    setValueWraps(_: boolean)
  }

  // interface
  class NSStepperCell extends NSActionCell {
    autorepeat: boolean;
    setAutorepeat(_: boolean)
    increment: number;
    setIncrement(_: number)
    maxValue: number;
    setMaxValue(_: number)
    minValue: number;
    setMinValue(_: number)
    valueWraps: boolean;
    setValueWraps(_: boolean)
  }

  // interface
  class NSStepperTouchBarItem extends NSTouchBarItem {
    action: string;
    setAction(_: string)
    increment: number;
    setIncrement(_: number)
    maxValue: number;
    setMaxValue(_: number)
    minValue: number;
    setMinValue(_: number)
    target: any;
    setTarget(_: any)
    value: number;
    setValue(_: number)
  }

  // interface
  class NSStoryboard extends NSObject {
    static mainStoryboard: NSStoryboard;
    instantiateControllerWithIdentifier(withIdentifier: string): any;
    instantiateControllerWithIdentifierWithCreator(_: string, creator?: (p1: NSCoder) => any): any;
    instantiateInitialController(): any;
    instantiateInitialControllerWithCreator(_?: (p1: NSCoder) => any): any;
  }

  // interface
  class NSStoryboardSegue extends NSObject {
    destinationController: any;
    identifier: string;
    sourceController: any;
    static createWithIdentifierSourceDestination(identifier: string, source: any, destination: any): NSStoryboardSegue;
    perform(): void;
  }

  // interface
  class NSStringDrawingContext extends NSObject {
    actualScaleFactor: number;
    minimumScaleFactor: number;
    setMinimumScaleFactor(_: number)
    totalBounds: CGRect;
  }

  // interface
  class NSSwitch extends NSControl /* implements NSAccessibilitySwitch */ {
    state: number;
    setState(_: number)
  }

  // interface
  class NSTabView extends NSView {
    allowsTruncatedLabels: boolean;
    setAllowsTruncatedLabels(_: boolean)
    contentRect: CGRect;
    controlSize: NSControl.ControlSize;
    setControlSize(_: NSControl.ControlSize)
    delegate: NSTabViewDelegate;
    setDelegate(_: NSTabViewDelegate)
    drawsBackground: boolean;
    setDrawsBackground(_: boolean)
    font: NSFont;
    setFont(_: NSFont)
    minimumSize: CGSize;
    numberOfTabViewItems: number;
    selectedTabViewItem: NSTabViewItem;
    tabPosition: NSTabView.TabPosition;
    setTabPosition(_: NSTabView.TabPosition)
    tabViewBorderType: NSTabView.TabViewBorderType;
    setTabViewBorderType(_: NSTabView.TabViewBorderType)
    tabViewItems: NSTabViewItem[];
    setTabViewItems(_: NSTabViewItem[])
    tabViewType: NSTabView.TabType;
    setTabViewType(_: NSTabView.TabType)
    addTabViewItem(_: NSTabViewItem): void;
    indexOfTabViewItem(_: NSTabViewItem): number;
    indexOfTabViewItemWithIdentifier(withIdentifier: any): number;
    insertTabViewItemAtIndex(_: NSTabViewItem, at: number): void;
    removeTabViewItem(_: NSTabViewItem): void;
    selectFirstTabViewItem(_?: any): void;
    selectLastTabViewItem(_?: any): void;
    selectNextTabViewItem(_?: any): void;
    selectPreviousTabViewItem(_?: any): void;
    selectTabViewItem(_?: NSTabViewItem): void;
    selectTabViewItemAtIndex(at: number): void;
    selectTabViewItemWithIdentifier(withIdentifier: any): void;
    tabViewItemAtIndex(at: number): NSTabViewItem;
    tabViewItemAtPoint(at: CGPoint): NSTabViewItem;
    takeSelectedTabViewItemFromSender(_?: any): void;
  }

  // interface
  class NSTabViewController extends NSViewController /* implements NSTabViewDelegate, NSToolbarDelegate */ {
    canPropagateSelectedChildViewControllerTitle: boolean;
    setCanPropagateSelectedChildViewControllerTitle(_: boolean)
    selectedTabViewItemIndex: number;
    setSelectedTabViewItemIndex(_: number)
    tabStyle: NSTabViewController.TabStyle;
    setTabStyle(_: NSTabViewController.TabStyle)
    tabView: NSTabView;
    setTabView(_: NSTabView)
    tabViewItems: NSTabViewItem[];
    setTabViewItems(_: NSTabViewItem[])
    transitionOptions: NSViewController.TransitionOptions;
    setTransitionOptions(_: NSViewController.TransitionOptions)
    addTabViewItem(_: NSTabViewItem): void;
    insertTabViewItemAtIndex(_: NSTabViewItem, at: number): void;
    removeTabViewItem(_: NSTabViewItem): void;
    tabViewItemForViewController(for_: NSViewController): NSTabViewItem;
  }

  interface NSTabViewDelegate extends NSObject {
    // instance method
    tabViewShouldSelectTabViewItem?(_: NSTabView, shouldSelect?: NSTabViewItem): boolean;
    // instance method
    tabViewWillSelectTabViewItem?(_: NSTabView, willSelect?: NSTabViewItem): void;
    // instance method
    tabViewDidSelectTabViewItem?(_: NSTabView, didSelect?: NSTabViewItem): void;
    // instance method
    tabViewDidChangeNumberOfTabViewItems?(_: NSTabView): void;
  }

  // interface
  class NSTabViewItem extends NSObject /* implements NSCoding */ {
    color: NSColor;
    setColor(_: NSColor)
    identifier: any;
    setIdentifier(_: any)
    image: NSImage;
    setImage(_: NSImage)
    initialFirstResponder: NSView;
    setInitialFirstResponder(_: NSView)
    label: string;
    setLabel(_: string)
    tabState: NSTabViewItem.State;
    tabView: NSTabView;
    toolTip: string;
    setToolTip(_: string)
    view: NSView;
    setView(_: NSView)
    viewController: NSViewController;
    setViewController(_: NSViewController)
    drawLabelInRect(_: boolean, in_: CGRect): void;
    static createWithIdentifier(identifier?: any): NSTabViewItem;
    sizeOfLabel(_: boolean): CGSize;
  }

  // interface
  class NSTableCellView extends NSView {
    backgroundStyle: NSView.BackgroundStyle;
    setBackgroundStyle(_: NSView.BackgroundStyle)
    draggingImageComponents: NSDraggingImageComponent[];
    imageView: NSImageView;
    setImageView(_: NSImageView)
    objectValue: any;
    setObjectValue(_: any)
    rowSizeStyle: NSTableView.RowSizeStyle;
    setRowSizeStyle(_: NSTableView.RowSizeStyle)
    textField: NSTextField;
    setTextField(_: NSTextField)
  }

  // interface
  class NSTableColumn extends NSObject /* implements NSCoding, NSUserInterfaceItemIdentification */ {
    dataCell: any;
    setDataCell(_: any)
    isEditable: boolean;
    setEditable(_: boolean)
    headerCell: NSTableHeaderCell;
    setHeaderCell(_: NSTableHeaderCell)
    headerToolTip: string;
    setHeaderToolTip(_: string)
    isHidden: boolean;
    setHidden(_: boolean)
    maxWidth: number;
    setMaxWidth(_: number)
    minWidth: number;
    setMinWidth(_: number)
    resizingMask: NSTableColumn.ResizingOptions;
    setResizingMask(_: NSTableColumn.ResizingOptions)
    sortDescriptorPrototype: NSSortDescriptor;
    setSortDescriptorPrototype(_: NSSortDescriptor)
    tableView: NSTableView;
    setTableView(_: NSTableView)
    title: string;
    setTitle(_: string)
    width: number;
    setWidth(_: number)
    dataCellForRow(forRow: number): any;
    static createWithIdentifier(identifier: string): NSTableColumn;
    sizeToFit(): void;
  }

  // interface
  class NSTableHeaderCell extends NSTextFieldCell {
    drawSortIndicatorWithFrameInViewAscendingPriority(withFrame: CGRect, in_: NSView, ascending: boolean, priority: number): void;
    sortIndicatorRectForBounds(forBounds: CGRect): CGRect;
  }

  // interface
  class NSTableHeaderView extends NSView /* implements NSViewToolTipOwner */ {
    draggedColumn: number;
    draggedDistance: number;
    resizedColumn: number;
    tableView: NSTableView;
    setTableView(_: NSTableView)
    columnAtPoint(at: CGPoint): number;
    headerRectOfColumn(ofColumn: number): CGRect;
  }

  // interface
  class NSTableRowView extends NSView /* implements NSAccessibilityRow */ {
    backgroundColor: NSColor;
    setBackgroundColor(_: NSColor)
    draggingDestinationFeedbackStyle: NSTableView.DraggingDestinationFeedbackStyle;
    setDraggingDestinationFeedbackStyle(_: NSTableView.DraggingDestinationFeedbackStyle)
    isEmphasized: boolean;
    setEmphasized(_: boolean)
    isFloating: boolean;
    setFloating(_: boolean)
    isGroupRowStyle: boolean;
    setGroupRowStyle(_: boolean)
    indentationForDropOperation: number;
    setIndentationForDropOperation(_: number)
    interiorBackgroundStyle: NSView.BackgroundStyle;
    isNextRowSelected: boolean;
    setNextRowSelected(_: boolean)
    numberOfColumns: number;
    isPreviousRowSelected: boolean;
    setPreviousRowSelected(_: boolean)
    isSelected: boolean;
    setSelected(_: boolean)
    selectionHighlightStyle: NSTableView.SelectionHighlightStyle;
    setSelectionHighlightStyle(_: NSTableView.SelectionHighlightStyle)
    isTargetForDropOperation: boolean;
    setTargetForDropOperation(_: boolean)
    drawBackgroundInRect(in_: CGRect): void;
    drawDraggingDestinationFeedbackInRect(in_: CGRect): void;
    drawSelectionInRect(in_: CGRect): void;
    drawSeparatorInRect(in_: CGRect): void;
    viewAtColumn(atColumn: number): any;
  }

  // interface
  class NSTableView extends NSControl /* implements NSAccessibilityTable, NSDraggingSource, NSTextViewDelegate, NSUserInterfaceValidations */ {
    allowsColumnReordering: boolean;
    setAllowsColumnReordering(_: boolean)
    allowsColumnResizing: boolean;
    setAllowsColumnResizing(_: boolean)
    allowsColumnSelection: boolean;
    setAllowsColumnSelection(_: boolean)
    allowsEmptySelection: boolean;
    setAllowsEmptySelection(_: boolean)
    allowsMultipleSelection: boolean;
    setAllowsMultipleSelection(_: boolean)
    allowsTypeSelect: boolean;
    setAllowsTypeSelect(_: boolean)
    autosaveName: string;
    setAutosaveName(_: string)
    autosaveTableColumns: boolean;
    setAutosaveTableColumns(_: boolean)
    backgroundColor: NSColor;
    setBackgroundColor(_: NSColor)
    clickedColumn: number;
    clickedRow: number;
    columnAutoresizingStyle: NSTableView.ColumnAutoresizingStyle;
    setColumnAutoresizingStyle(_: NSTableView.ColumnAutoresizingStyle)
    cornerView: NSView;
    setCornerView(_: NSView)
    dataSource: NSTableViewDataSource;
    setDataSource(_: NSTableViewDataSource)
    delegate: NSTableViewDelegate;
    setDelegate(_: NSTableViewDelegate)
    doubleAction: string;
    setDoubleAction(_: string)
    draggingDestinationFeedbackStyle: NSTableView.DraggingDestinationFeedbackStyle;
    setDraggingDestinationFeedbackStyle(_: NSTableView.DraggingDestinationFeedbackStyle)
    editedColumn: number;
    editedRow: number;
    effectiveRowSizeStyle: NSTableView.RowSizeStyle;
    floatsGroupRows: boolean;
    setFloatsGroupRows(_: boolean)
    gridColor: NSColor;
    setGridColor(_: NSColor)
    gridStyleMask: NSTableView.GridLineStyle;
    setGridStyleMask(_: NSTableView.GridLineStyle)
    headerView: NSTableHeaderView;
    setHeaderView(_: NSTableHeaderView)
    hiddenRowIndexes: NSIndexSet;
    highlightedTableColumn: NSTableColumn;
    setHighlightedTableColumn(_: NSTableColumn)
    intercellSpacing: CGSize;
    setIntercellSpacing(_: CGSize)
    numberOfColumns: number;
    numberOfRows: number;
    numberOfSelectedColumns: number;
    numberOfSelectedRows: number;
    registeredNibsByIdentifier: Map<string, NSNib>;
    rowActionsVisible: boolean;
    setRowActionsVisible(_: boolean)
    rowHeight: number;
    setRowHeight(_: number)
    rowSizeStyle: NSTableView.RowSizeStyle;
    setRowSizeStyle(_: NSTableView.RowSizeStyle)
    selectedColumn: number;
    selectedColumnIndexes: NSIndexSet;
    selectedRow: number;
    selectedRowIndexes: NSIndexSet;
    selectionHighlightStyle: NSTableView.SelectionHighlightStyle;
    setSelectionHighlightStyle(_: NSTableView.SelectionHighlightStyle)
    sortDescriptors: NSSortDescriptor[];
    setSortDescriptors(_: NSSortDescriptor[])
    tableColumns: NSTableColumn[];
    usesAlternatingRowBackgroundColors: boolean;
    setUsesAlternatingRowBackgroundColors(_: boolean)
    usesAutomaticRowHeights: boolean;
    setUsesAutomaticRowHeights(_: boolean)
    usesStaticContents: boolean;
    setUsesStaticContents(_: boolean)
    verticalMotionCanBeginDrag: boolean;
    setVerticalMotionCanBeginDrag(_: boolean)
    addTableColumn(_: NSTableColumn): void;
    beginUpdates(): void;
    canDragRowsWithIndexesAtPoint(with_: NSIndexSet, at: CGPoint): boolean;
    columnAtPoint(at: CGPoint): number;
    columnForView(for_: NSView): number;
    columnIndexesInRect(in_: CGRect): NSIndexSet;
    columnWithIdentifier(withIdentifier: string): number;
    deselectAll(_?: any): void;
    deselectColumn(_: number): void;
    deselectRow(_: number): void;
    didAddRowViewForRow(_: NSTableRowView, forRow: number): void;
    didRemoveRowViewForRow(_: NSTableRowView, forRow: number): void;
    dragImageForRowsWithIndexesTableColumnsEventOffset(with_: NSIndexSet, tableColumns: NSTableColumn[], event: NSEvent, offset: NSPoint): NSImage;
    drawBackgroundInClipRect(inClipRect: CGRect): void;
    drawGridInClipRect(inClipRect: CGRect): void;
    drawRowClipRect(_: number, clipRect: CGRect): void;
    editColumnRowWithEventSelect(_: number, row: number, with_?: NSEvent, select?: boolean): void;
    endUpdates(): void;
    enumerateAvailableRowViews(_: (p1: NSTableRowView, p2: number) => void): void;
    frameOfCellAtColumnRow(atColumn: number, row: number): CGRect;
    hideRowsAtIndexesWithAnimation(at: NSIndexSet, withAnimation: NSTableView.AnimationOptions): void;
    highlightSelectionInClipRect(inClipRect: CGRect): void;
    indicatorImageInTableColumn(in_: NSTableColumn): NSImage;
    insertRowsAtIndexesWithAnimation(at: NSIndexSet, withAnimation: NSTableView.AnimationOptions): void;
    isColumnSelected(_: number): boolean;
    isRowSelected(_: number): boolean;
    makeViewWithIdentifierOwner(withIdentifier: string, owner?: any): NSView;
    moveColumnToColumn(_: number, toColumn: number): void;
    moveRowAtIndexToIndex(at: number, to: number): void;
    noteHeightOfRowsWithIndexesChanged(withIndexesChanged: NSIndexSet): void;
    noteNumberOfRowsChanged(): void;
    rectOfColumn(ofColumn: number): CGRect;
    rectOfRow(ofRow: number): CGRect;
    registerNibForIdentifier(_?: NSNib, forIdentifier?: string): void;
    reloadData(): void;
    reloadDataForRowIndexesColumnIndexes(forRowIndexes: NSIndexSet, columnIndexes: NSIndexSet): void;
    removeRowsAtIndexesWithAnimation(at: NSIndexSet, withAnimation: NSTableView.AnimationOptions): void;
    removeTableColumn(_: NSTableColumn): void;
    rowAtPoint(at: CGPoint): number;
    rowForView(for_: NSView): number;
    rowViewAtRowMakeIfNecessary(atRow: number, makeIfNecessary: boolean): NSTableRowView;
    rowsInRect(in_: CGRect): NSRange;
    scrollColumnToVisible(_: number): void;
    scrollRowToVisible(_: number): void;
    selectColumnIndexesByExtendingSelection(_: NSIndexSet, byExtendingSelection: boolean): void;
    selectRowIndexesByExtendingSelection(_: NSIndexSet, byExtendingSelection: boolean): void;
    setDraggingSourceOperationMaskForLocal(_: NSDragOperation, forLocal: boolean): void;
    setDropRowDropOperation(_: number, dropOperation: NSTableView.DropOperation): void;
    setIndicatorImageInTableColumn(_?: NSImage, in_?: NSTableColumn): void;
    sizeLastColumnToFit(): void;
    tableColumnWithIdentifier(withIdentifier: string): NSTableColumn;
    tile(): void;
    unhideRowsAtIndexesWithAnimation(at: NSIndexSet, withAnimation: NSTableView.AnimationOptions): void;
    viewAtColumnRowMakeIfNecessary(atColumn: number, row: number, makeIfNecessary: boolean): NSView;
  }

  interface NSTableViewDataSource extends NSObject {
    // instance method
    numberOfRowsInTableView?(in_: NSTableView): number;
    // instance method
    tableViewObjectValueForTableColumnRow?(_: NSTableView, objectValueFor?: NSTableColumn, row?: number): any;
    // instance method
    tableViewSetObjectValueForTableColumnRow?(_: NSTableView, setObjectValue?: any, for_?: NSTableColumn, row?: number): void;
    // instance method
    tableViewDraggingSessionWillBeginAtPointForRowIndexes?(_: NSTableView, draggingSession: NSDraggingSession, willBeginAt: CGPoint, forRowIndexes: NSIndexSet): void;
    // instance method
    tableViewDraggingSessionEndedAtPointOperation?(_: NSTableView, draggingSession: NSDraggingSession, endedAt: CGPoint, operation: NSDragOperation): void;
    // instance method
    tableViewWriteRowsWithIndexesToPasteboard?(_: NSTableView, writeRowsWith: NSIndexSet, to: NSPasteboard): boolean;
    // instance method
    tableViewAcceptDropRowDropOperation?(_: NSTableView, acceptDrop: NSDraggingInfo, row: number, dropOperation: NSTableView.DropOperation): boolean;
    // instance method
    tableViewPasteboardWriterForRow?(_: NSTableView, pasteboardWriterForRow: number): NSPasteboardWriting;
    // instance method
    tableViewSortDescriptorsDidChange?(_: NSTableView, sortDescriptorsDidChange: NSSortDescriptor[]): void;
    // instance method
    tableViewUpdateDraggingItemsForDrag?(_: NSTableView, updateDraggingItemsForDrag: NSDraggingInfo): void;
    // instance method
    tableViewValidateDropProposedRowProposedDropOperation?(_: NSTableView, validateDrop: NSDraggingInfo, proposedRow: number, proposedDropOperation: NSTableView.DropOperation): NSDragOperation;
  }

  interface NSTableViewDelegate extends NSControlTextEditingDelegate {
    // instance method
    selectionShouldChangeInTableView?(in_: NSTableView): boolean;
    // instance method
    tableViewViewForTableColumnRow?(_: NSTableView, viewFor?: NSTableColumn, row?: number): NSView;
    // instance method
    tableViewDidAddRowViewForRow?(_: NSTableView, didAdd: NSTableRowView, forRow: number): void;
    // instance method
    tableViewDidRemoveRowViewForRow?(_: NSTableView, didRemove: NSTableRowView, forRow: number): void;
    // instance method
    tableViewWillDisplayCellForTableColumnRow?(_: NSTableView, willDisplayCell: any, for_?: NSTableColumn, row?: number): void;
    // instance method
    tableViewShouldEditTableColumnRow?(_: NSTableView, shouldEdit?: NSTableColumn, row?: number): boolean;
    // instance method
    tableViewToolTipForCellRectTableColumnRowMouseLocation?(_: NSTableView, toolTipFor: NSCell, rect: NSRect, tableColumn?: NSTableColumn, row?: number, mouseLocation?: CGPoint): string;
    // instance method
    tableViewShouldShowCellExpansionForTableColumnRow?(_: NSTableView, shouldShowCellExpansionFor?: NSTableColumn, row?: number): boolean;
    // instance method
    tableViewShouldTrackCellForTableColumnRow?(_: NSTableView, shouldTrackCell: NSCell, for_?: NSTableColumn, row?: number): boolean;
    // instance method
    tableViewDataCellForTableColumnRow?(_: NSTableView, dataCellFor?: NSTableColumn, row?: number): NSCell;
    // instance method
    tableViewShouldSelectTableColumn?(_: NSTableView, shouldSelect?: NSTableColumn): boolean;
    // instance method
    tableViewMouseDownInHeaderOfTableColumn?(_: NSTableView, mouseDownInHeaderOf: NSTableColumn): void;
    // instance method
    tableViewDidClickTableColumn?(_: NSTableView, didClick: NSTableColumn): void;
    // instance method
    tableViewDidDragTableColumn?(_: NSTableView, didDrag: NSTableColumn): void;
    // instance method
    tableViewTypeSelectStringForTableColumnRow?(_: NSTableView, typeSelectStringFor?: NSTableColumn, row?: number): string;
    // instance method
    tableViewNextTypeSelectMatchFromRowToRowForString?(_: NSTableView, nextTypeSelectMatchFromRow: number, toRow: number, for_: string): number;
    // instance method
    tableViewShouldTypeSelectForEventWithCurrentSearchString?(_: NSTableView, shouldTypeSelectFor: NSEvent, withCurrentSearch?: string): boolean;
    // instance method
    tableViewHeightOfRow?(_: NSTableView, heightOfRow: number): number;
    // instance method
    tableViewIsGroupRow?(_: NSTableView, isGroupRow: number): boolean;
    // instance method
    tableViewRowActionsForRowEdge?(_: NSTableView, rowActionsForRow: number, edge: NSTableView.RowActionEdge): NSTableViewRowAction[];
    // instance method
    tableViewRowViewForRow?(_: NSTableView, rowViewForRow: number): NSTableRowView;
    // instance method
    tableViewSelectionIndexesForProposedSelection?(_: NSTableView, selectionIndexesForProposedSelection: NSIndexSet): NSIndexSet;
    // instance method
    tableViewShouldReorderColumnToColumn?(_: NSTableView, shouldReorderColumn: number, toColumn: number): boolean;
    // instance method
    tableViewShouldSelectRow?(_: NSTableView, shouldSelectRow: number): boolean;
    // instance method
    tableViewSizeToFitWidthOfColumn?(_: NSTableView, sizeToFitWidthOfColumn: number): number;
    // instance method
    tableViewColumnDidMove?(_: NSNotification): void;
    // instance method
    tableViewColumnDidResize?(_: NSNotification): void;
    // instance method
    tableViewSelectionDidChange?(_: NSNotification): void;
    // instance method
    tableViewSelectionIsChanging?(_: NSNotification): void;
  }

  // interface
  class NSTableViewRowAction extends NSObject /* implements NSCopying */ {
    backgroundColor: NSColor;
    setBackgroundColor(_: NSColor)
    image: NSImage;
    setImage(_: NSImage)
    style: NSTableViewRowAction.Style;
    title: string;
    setTitle(_: string)
  }

  // interface
  class NSText extends NSView /* implements NSChangeSpelling, NSIgnoreMisspelledWords */ {
    alignment: NSTextAlignment;
    setAlignment(_: NSTextAlignment)
    backgroundColor: NSColor;
    setBackgroundColor(_: NSColor)
    baseWritingDirection: NSWritingDirection;
    setBaseWritingDirection(_: NSWritingDirection)
    delegate: NSTextDelegate;
    setDelegate(_: NSTextDelegate)
    drawsBackground: boolean;
    setDrawsBackground(_: boolean)
    isEditable: boolean;
    setEditable(_: boolean)
    isFieldEditor: boolean;
    setFieldEditor(_: boolean)
    font: NSFont;
    setFont(_: NSFont)
    isHorizontallyResizable: boolean;
    setHorizontallyResizable(_: boolean)
    importsGraphics: boolean;
    setImportsGraphics(_: boolean)
    maxSize: CGSize;
    setMaxSize(_: CGSize)
    minSize: CGSize;
    setMinSize(_: CGSize)
    isRichText: boolean;
    setRichText(_: boolean)
    isRulerVisible: boolean;
    isSelectable: boolean;
    setSelectable(_: boolean)
    selectedRange: NSRange;
    setSelectedRange(_: NSRange)
    string: string;
    setString(_: string)
    textColor: NSColor;
    setTextColor(_: NSColor)
    usesFontPanel: boolean;
    setUsesFontPanel(_: boolean)
    isVerticallyResizable: boolean;
    setVerticallyResizable(_: boolean)
    RTFDFromRange(from: NSRange): NSData;
    RTFFromRange(from: NSRange): NSData;
    alignCenter(_?: any): void;
    alignLeft(_?: any): void;
    alignRight(_?: any): void;
    checkSpelling(_?: any): void;
    copyFont(_?: any): void;
    copyRuler(_?: any): void;
    cut(_?: any): void;
    delete(_?: any): void;
    paste(_?: any): void;
    pasteFont(_?: any): void;
    pasteRuler(_?: any): void;
    readRTFDFromFile(fromFile: string): boolean;
    replaceCharactersInRangeWithRTF(in_: NSRange, withRTF: NSData): void;
    replaceCharactersInRangeWithRTFD(in_: NSRange, withRTFD: NSData): void;
    replaceCharactersInRangeWithString(in_: NSRange, with_: string): void;
    scrollRangeToVisible(_: NSRange): void;
    setFontRange(_: NSFont, range: NSRange): void;
    setTextColorRange(_?: NSColor, range?: NSRange): void;
    showGuessPanel(_?: any): void;
    sizeToFit(): void;
    subscript(_?: any): void;
    superscript(_?: any): void;
    toggleRuler(_?: any): void;
    underline(_?: any): void;
    unscript(_?: any): void;
    writeRTFDToFileAtomically(toFile: string, atomically: boolean): boolean;
  }

  // interface
  class NSTextAlternatives extends NSObject /* implements NSSecureCoding */ {
    alternativeStrings: string[];
    primaryString: string;
    static createWithPrimaryStringAlternativeStrings(primaryString: string, alternativeStrings: string[]): NSTextAlternatives;
    noteSelectedAlternativeString(_: string): void;
  }

  // interface
  class NSTextAttachment extends NSObject /* implements NSSecureCoding, NSTextAttachmentContainer */ {
    attachmentCell: NSTextAttachmentCell;
    setAttachmentCell(_: NSTextAttachmentCell)
    bounds: CGRect;
    setBounds(_: CGRect)
    contents: NSData;
    setContents(_: NSData)
    fileType: string;
    setFileType(_: string)
    fileWrapper: FileWrapper;
    setFileWrapper(_: FileWrapper)
    image: NSImage;
    setImage(_: NSImage)
    static createWithDataOfType(data?: NSData, ofType?: string): NSTextAttachment;
    static createWithFileWrapper(fileWrapper?: FileWrapper): NSTextAttachment;
  }

  // interface
  class NSTextAttachmentCell extends NSCell /* implements NSTextAttachmentCell */ {
  }

  interface NSTextAttachmentCell extends NSObject {
    attachment: NSTextAttachment;
    setAttachment(_: NSTextAttachment)
    // instance method
    cellBaselineOffset(): CGPoint;
    // instance method
    cellFrameForTextContainerProposedLineFragmentGlyphPositionCharacterIndex(_: NSTextContainer, proposedLineFragment: CGRect, glyphPosition: CGPoint, characterIndex: number): CGRect;
    // instance method
    cellSize_(): CGSize;
    // instance method
    drawWithFrameInView(_: CGRect, inView?: NSView): void;
    // instance method
    drawWithFrameInViewCharacterIndex(_: CGRect, inView?: NSView, characterIndex?: number): void;
    // instance method
    drawWithFrameInViewCharacterIndexLayoutManager(_: CGRect, inView?: NSView, characterIndex?: number, layoutManager?: NSLayoutManager): void;
    // instance method
    highlightWithFrameInView(_: boolean, withFrame: CGRect, inView?: NSView): void;
    // instance method
    trackMouseInRectOfViewAtCharacterIndexUntilMouseUp(_: NSEvent, inRect: CGRect, ofView?: NSView, atCharacterIndex?: number, untilMouseUp?: boolean): boolean;
    // instance method
    trackMouseInRectOfViewUntilMouseUp(_: NSEvent, inRect: CGRect, ofView?: NSView, untilMouseUp?: boolean): boolean;
    // instance method
    wantsToTrackMouse(): boolean;
    // instance method
    wantsToTrackMouseForEventInRectOfViewAtCharacterIndex(_: NSEvent, inRect: CGRect, ofView?: NSView, atCharacterIndex?: number): boolean;
  }

  interface NSTextAttachmentContainer extends NSObject {
    // instance method
    attachmentBoundsForTextContainerProposedLineFragmentGlyphPositionCharacterIndex(for_?: NSTextContainer, proposedLineFragment?: CGRect, glyphPosition?: CGPoint, characterIndex?: number): CGRect;
    // instance method
    imageForBoundsTextContainerCharacterIndex(forBounds: CGRect, textContainer?: NSTextContainer, characterIndex?: number): NSImage;
  }

  // interface
  class NSTextBlock extends NSObject /* implements NSCopying, NSSecureCoding */ {
    backgroundColor: NSColor;
    setBackgroundColor(_: NSColor)
    contentWidth: number;
    contentWidthValueType: NSTextBlock.ValueType;
    verticalAlignment: NSTextBlock.VerticalAlignment;
    setVerticalAlignment(_: NSTextBlock.VerticalAlignment)
    borderColorForEdge(for_: NSRectEdge): NSColor;
    boundsRectForContentRectInRectTextContainerCharacterRange(forContentRect: CGRect, in_: CGRect, textContainer: NSTextContainer, characterRange: NSRange): CGRect;
    drawBackgroundWithFrameInViewCharacterRangeLayoutManager(withFrame: CGRect, in_: NSView, characterRange: NSRange, layoutManager: NSLayoutManager): void;
    rectForLayoutAtPointInRectTextContainerCharacterRange(at: CGPoint, in_: CGRect, textContainer: NSTextContainer, characterRange: NSRange): CGRect;
    setBorderColor(_?: NSColor): void;
    setBorderColorForEdge(_?: NSColor, for_?: NSRectEdge): void;
    setContentWidthType(_: number, type: NSTextBlock.ValueType): void;
    setValueTypeForDimension(_: number, type: NSTextBlock.ValueType, for_: NSTextBlock.Dimension): void;
    setWidthTypeForLayer(_: number, type: NSTextBlock.ValueType, for_: NSTextBlock.Layer): void;
    setWidthTypeForLayerEdge(_: number, type: NSTextBlock.ValueType, for_: NSTextBlock.Layer, edge: NSRectEdge): void;
    valueForDimension(for_: NSTextBlock.Dimension): number;
    valueTypeForDimension(for_: NSTextBlock.Dimension): NSTextBlock.ValueType;
    widthForLayerEdge(for_: NSTextBlock.Layer, edge: NSRectEdge): number;
    widthValueTypeForLayerEdge(for_: NSTextBlock.Layer, edge: NSRectEdge): NSTextBlock.ValueType;
  }

  interface NSTextCheckingClient extends NSTextInputClient, NSTextInputTraits {
    // instance method
    addAnnotationsRange(_: Map<string, string>, range: NSRange): void;
    // instance method
    annotatedSubstringForProposedRangeActualRange(forProposedRange: NSRange, actualRange?: NSRange): NSAttributedString;
    // instance method
    candidateListTouchBarItem(): NSCandidateListTouchBarItem<any>;
    // instance method
    removeAnnotationRange(_: string, range: NSRange): void;
    // instance method
    replaceCharactersInRangeWithAnnotatedString(in_: NSRange, withAnnotatedString: NSAttributedString): void;
    // instance method
    selectAndShowRange(_: NSRange): void;
    // instance method
    setAnnotationsRange(_: Map<string, string>, range: NSRange): void;
    // instance method
    viewForRangeFirstRectActualRange(for_: NSRange, firstRect?: NSRect, actualRange?: NSRange): NSView;
  }

  // interface
  class NSTextCheckingController extends NSObject {
    client: NSTextCheckingClient;
    spellCheckerDocumentTag: number;
    setSpellCheckerDocumentTag(_: number)
    changeSpelling(_?: any): void;
    checkSpelling(_?: any): void;
    checkTextInDocument(_?: any): void;
    checkTextInRangeTypesOptions(in_: NSRange, types: number, options: Map<string, any>): void;
    checkTextInSelection(_?: any): void;
    considerTextCheckingForRange(for_: NSRange): void;
    didChangeSelectedRange(): void;
    didChangeTextInRange(in_: NSRange): void;
    ignoreSpelling(_?: any): void;
    static createWithClient(client: NSTextCheckingClient): NSTextCheckingController;
    insertedTextInRange(in_: NSRange): void;
    invalidate(): void;
    menuAtIndexClickedOnSelectionEffectiveRange(at: number, clickedOnSelection: boolean, effectiveRange: NSRange): NSMenu;
    orderFrontSubstitutionsPanel(_?: any): void;
    showGuessPanel(_?: any): void;
    updateCandidates(): void;
    validAnnotations(): string[];
  }

  // interface
  class NSTextContainer extends NSObject /* implements NSSecureCoding, NSTextLayoutOrientationProvider */ {
    containerSize: CGSize;
    setContainerSize(_: CGSize)
    exclusionPaths: NSBezierPath[];
    setExclusionPaths(_: NSBezierPath[])
    heightTracksTextView: boolean;
    setHeightTracksTextView(_: boolean)
    layoutManager: NSLayoutManager;
    setLayoutManager(_: NSLayoutManager)
    lineBreakMode: NSLineBreakMode;
    setLineBreakMode(_: NSLineBreakMode)
    lineFragmentPadding: number;
    setLineFragmentPadding(_: number)
    maximumNumberOfLines: number;
    setMaximumNumberOfLines(_: number)
    isSimpleRectangularTextContainer: boolean;
    size: CGSize;
    setSize(_: CGSize)
    textView: NSTextView;
    setTextView(_: NSTextView)
    widthTracksTextView: boolean;
    setWidthTracksTextView(_: boolean)
    static createWithContainerSize(containerSize: CGSize): NSTextContainer;
    static createWithSize(size: CGSize): NSTextContainer;
    lineFragmentRectForProposedRectAtIndexWritingDirectionRemainingRect(forProposedRect: CGRect, at: number, writingDirection: NSWritingDirection, remaining?: NSRect): CGRect;
    lineFragmentRectForProposedRectSweepDirectionMovementDirectionRemainingRect(forProposedRect: CGRect, sweepDirection: NSLineSweepDirection, movementDirection: NSLineMovementDirection, remaining?: NSRect): CGRect;
    replaceLayoutManager(_: NSLayoutManager): void;
  }

  interface NSTextDelegate extends NSObject {
    // instance method
    textDidBeginEditing?(_: NSNotification): void;
    // instance method
    textDidChange?(_: NSNotification): void;
    // instance method
    textDidEndEditing?(_: NSNotification): void;
    // instance method
    textShouldBeginEditing?(_: NSText): boolean;
    // instance method
    textShouldEndEditing?(_: NSText): boolean;
  }

  // interface
  class NSTextField extends NSControl /* implements NSAccessibilityNavigableStaticText, NSUserInterfaceValidations */ {
    static labelWithAttributedString(labelWithAttributedString: NSAttributedString): NSTextField;
    static labelWithString(labelWithString: string): NSTextField;
    static wrappingLabelWithString(wrappingLabelWithString: string): NSTextField;
    allowsCharacterPickerTouchBarItem: boolean;
    setAllowsCharacterPickerTouchBarItem(_: boolean)
    allowsDefaultTighteningForTruncation: boolean;
    setAllowsDefaultTighteningForTruncation(_: boolean)
    allowsEditingTextAttributes: boolean;
    setAllowsEditingTextAttributes(_: boolean)
    isAutomaticTextCompletionEnabled: boolean;
    setAutomaticTextCompletionEnabled(_: boolean)
    backgroundColor: NSColor;
    setBackgroundColor(_: NSColor)
    bezelStyle: NSTextField.BezelStyle;
    setBezelStyle(_: NSTextField.BezelStyle)
    isBezeled: boolean;
    setBezeled(_: boolean)
    isBordered: boolean;
    setBordered(_: boolean)
    delegate: NSTextFieldDelegate;
    setDelegate(_: NSTextFieldDelegate)
    drawsBackground: boolean;
    setDrawsBackground(_: boolean)
    isEditable: boolean;
    setEditable(_: boolean)
    importsGraphics: boolean;
    setImportsGraphics(_: boolean)
    maximumNumberOfLines: number;
    setMaximumNumberOfLines(_: number)
    placeholderAttributedString: NSAttributedString;
    setPlaceholderAttributedString(_: NSAttributedString)
    placeholderString: string;
    setPlaceholderString(_: string)
    preferredMaxLayoutWidth: number;
    setPreferredMaxLayoutWidth(_: number)
    isSelectable: boolean;
    setSelectable(_: boolean)
    textColor: NSColor;
    setTextColor(_: NSColor)
    selectText(_?: any): void;
    textDidBeginEditing(_: NSNotification): void;
    textDidChange(_: NSNotification): void;
    textDidEndEditing(_: NSNotification): void;
    textShouldBeginEditing(_: NSText): boolean;
    textShouldEndEditing(_: NSText): boolean;
  }

  // interface
  class NSTextFieldCell extends NSActionCell {
    allowedInputSourceLocales: string[];
    setAllowedInputSourceLocales(_: string[])
    backgroundColor: NSColor;
    setBackgroundColor(_: NSColor)
    bezelStyle: NSTextField.BezelStyle;
    setBezelStyle(_: NSTextField.BezelStyle)
    drawsBackground: boolean;
    setDrawsBackground(_: boolean)
    placeholderAttributedString: NSAttributedString;
    setPlaceholderAttributedString(_: NSAttributedString)
    placeholderString: string;
    setPlaceholderString(_: string)
    textColor: NSColor;
    setTextColor(_: NSColor)
    setWantsNotificationForMarkedText(_: boolean): void;
  }

  interface NSTextFieldDelegate extends NSControlTextEditingDelegate {
    // instance method
    textFieldTextViewShouldSelectCandidateAtIndex?(_: NSTextField, textView: NSTextView, shouldSelectCandidateAt: number): boolean;
    // instance method
    textFieldTextViewCandidatesForSelectedRange?(_: NSTextField, textView: NSTextView, candidates: NSTextCheckingResult[], forSelectedRange: NSRange): NSTextCheckingResult[];
    // instance method
    textFieldTextViewCandidatesForSelectedRange?(_: NSTextField, textView: NSTextView, candidatesForSelectedRange: NSRange): any[];
  }

  // interface
  class NSTextFinder extends NSObject /* implements NSCoding */ {
    static drawIncrementalMatchHighlightInRect(in_: CGRect): void;
    client: NSTextFinderClient;
    setClient(_: NSTextFinderClient)
    findBarContainer: NSTextFinderBarContainer;
    setFindBarContainer(_: NSTextFinderBarContainer)
    findIndicatorNeedsUpdate: boolean;
    setFindIndicatorNeedsUpdate(_: boolean)
    incrementalMatchRanges: NSValue[];
    isIncrementalSearchingEnabled: boolean;
    setIncrementalSearchingEnabled(_: boolean)
    incrementalSearchingShouldDimContentView: boolean;
    setIncrementalSearchingShouldDimContentView(_: boolean)
    cancelFindIndicator(): void;
    noteClientStringWillChange(): void;
    performAction(_: NSTextFinder.Action): void;
    validateAction(_: NSTextFinder.Action): boolean;
  }

  interface NSTextFinderBarContainer extends NSObject {
    findBarView: NSView;
    setFindBarView(_: NSView)
    isFindBarVisible: boolean;
    setFindBarVisible(_: boolean)
    contentView: NSView;
    // instance method
    findBarViewDidChangeHeight(): void;
  }

  interface NSTextFinderClient extends NSObject {
    allowsMultipleSelection?: boolean;
    isEditable?: boolean;
    firstSelectedRange?: NSRange;
    isSelectable?: boolean;
    selectedRanges?: NSValue[];
    setSelectedRanges(_: NSValue[])
    string?: string;
    visibleCharacterRanges?: NSValue[];
    // instance method
    contentViewAtIndexEffectiveCharacterRange?(at: number, effectiveCharacterRange: NSRange): NSView;
    // instance method
    didReplaceCharacters?(): void;
    // instance method
    drawCharactersInRangeForContentView?(in_: NSRange, forContentView: NSView): void;
    // instance method
    rectsForCharacterRange?(forCharacterRange: NSRange): NSValue[];
    // instance method
    replaceCharactersInRangeWithString?(in_: NSRange, with_: string): void;
    // instance method
    scrollRangeToVisible?(_: NSRange): void;
    // instance method
    shouldReplaceCharactersInRangesWithStrings?(inRanges: NSValue[], with_: string[]): boolean;
    // instance method
    stringAtIndexEffectiveRangeEndsWithSearchBoundary?(at: number, effectiveRange: NSRange, endsWithSearchBoundary: boolean): string;
    // instance method
    stringLength?(): number;
  }

  interface NSTextInput {
  }

  interface NSTextInputClient {
    // instance method
    attributedString?(): NSAttributedString;
    // instance method
    attributedSubstringForProposedRangeActualRange(forProposedRange: NSRange, actualRange?: NSRange): NSAttributedString;
    // instance method
    baselineDeltaForCharacterAtIndex?(at: number): number;
    // instance method
    characterIndexForPoint(for_: CGPoint): number;
    // instance method
    doCommandBySelector(by: string): void;
    // instance method
    drawsVerticallyForCharacterAtIndex?(at: number): boolean;
    // instance method
    firstRectForCharacterRangeActualRange(forCharacterRange: NSRange, actualRange?: NSRange): CGRect;
    // instance method
    fractionOfDistanceThroughGlyphForPoint?(for_: CGPoint): number;
    // instance method
    hasMarkedText(): boolean;
    // instance method
    insertTextReplacementRange(_: any, replacementRange: NSRange): void;
    // instance method
    markedRange(): NSRange;
    // instance method
    selectedRange(): NSRange;
    // instance method
    setMarkedTextSelectedRangeReplacementRange(_: any, selectedRange: NSRange, replacementRange: NSRange): void;
    // instance method
    unmarkText(): void;
    // instance method
    validAttributesForMarkedText(): string[];
    // instance method
    windowLevel?(): number;
  }

  // interface
  class NSTextInputContext extends NSObject {
    static localizedNameForInputSource(forInputSource: string): string;
    acceptsGlyphInfo: boolean;
    setAcceptsGlyphInfo(_: boolean)
    allowedInputSourceLocales: string[];
    setAllowedInputSourceLocales(_: string[])
    client: NSTextInputClient;
    keyboardInputSources: string[];
    selectedKeyboardInputSource: string;
    setSelectedKeyboardInputSource(_: string)
    static currentInputContext: NSTextInputContext;
    activate(): void;
    deactivate(): void;
    discardMarkedText(): void;
    handleEvent(_: NSEvent): boolean;
    static createWithClient(client: NSTextInputClient): NSTextInputContext;
    invalidateCharacterCoordinates(): void;
  }

  interface NSTextInputTraits {
    autocorrectionType?: NSTextInputTraitType;
    setAutocorrectionType(_: NSTextInputTraitType)
    dataDetectionType?: NSTextInputTraitType;
    setDataDetectionType(_: NSTextInputTraitType)
    grammarCheckingType?: NSTextInputTraitType;
    setGrammarCheckingType(_: NSTextInputTraitType)
    linkDetectionType?: NSTextInputTraitType;
    setLinkDetectionType(_: NSTextInputTraitType)
    smartDashesType?: NSTextInputTraitType;
    setSmartDashesType(_: NSTextInputTraitType)
    smartInsertDeleteType?: NSTextInputTraitType;
    setSmartInsertDeleteType(_: NSTextInputTraitType)
    smartQuotesType?: NSTextInputTraitType;
    setSmartQuotesType(_: NSTextInputTraitType)
    spellCheckingType?: NSTextInputTraitType;
    setSpellCheckingType(_: NSTextInputTraitType)
    textCompletionType?: NSTextInputTraitType;
    setTextCompletionType(_: NSTextInputTraitType)
    textReplacementType?: NSTextInputTraitType;
    setTextReplacementType(_: NSTextInputTraitType)
  }

  interface NSTextLayoutOrientationProvider {
    layoutOrientation: NSLayoutManager.TextLayoutOrientation;
  }

  // interface
  class NSTextList extends NSObject /* implements NSCopying, NSSecureCoding */ {
    listOptions: NSTextList.Options;
    markerFormat: string;
    startingItemNumber: number;
    setStartingItemNumber(_: number)
    static createWithMarkerFormatOptions(markerFormat: string, options: number): NSTextList;
    markerForItemNumber(forItemNumber: number): string;
  }

  // interface
  class NSTextStorage extends NSMutableAttributedString /* implements NSSecureCoding */ {
    attributeRuns: NSTextStorage[];
    setAttributeRuns(_: NSTextStorage[])
    changeInLength: number;
    characters: NSTextStorage[];
    setCharacters(_: NSTextStorage[])
    delegate: NSTextStorageDelegate;
    setDelegate(_: NSTextStorageDelegate)
    editedMask: NSTextStorageEditActions;
    editedRange: NSRange;
    fixesAttributesLazily: boolean;
    font: NSFont;
    setFont(_: NSFont)
    foregroundColor: NSColor;
    setForegroundColor(_: NSColor)
    layoutManagers: NSLayoutManager[];
    paragraphs: NSTextStorage[];
    setParagraphs(_: NSTextStorage[])
    words: NSTextStorage[];
    setWords(_: NSTextStorage[])
    addLayoutManager(_: NSLayoutManager): void;
    editedRangeChangeInLength(_: NSTextStorageEditActions, range: NSRange, changeInLength: number): void;
    ensureAttributesAreFixedInRange(in_: NSRange): void;
    invalidateAttributesInRange(in_: NSRange): void;
    processEditing(): void;
    removeLayoutManager(_: NSLayoutManager): void;
  }

  interface NSTextStorageDelegate extends NSObject {
    // instance method
    textStorageDidProcessEditingRangeChangeInLength?(_: NSTextStorage, didProcessEditing: NSTextStorageEditActions, range: NSRange, changeInLength: number): void;
    // instance method
    textStorageWillProcessEditingRangeChangeInLength?(_: NSTextStorage, willProcessEditing: NSTextStorageEditActions, range: NSRange, changeInLength: number): void;
  }

  // interface
  class NSTextTab extends NSObject /* implements NSCoding, NSCopying, NSSecureCoding */ {
    static columnTerminatorsForLocale(for_?: NSLocale): NSCharacterSet;
    alignment: NSTextAlignment;
    location: number;
    options: Map<string, any>;
    tabStopType: NSParagraphStyle.TextTabType;
    static createWithTextAlignmentLocationOptions(textAlignment: NSTextAlignment, location: number, options: Map<string, any>): NSTextTab;
    static createWithTypeLocation(type: NSParagraphStyle.TextTabType, location: number): NSTextTab;
  }

  // interface
  class NSTextTable extends NSTextBlock {
    collapsesBorders: boolean;
    setCollapsesBorders(_: boolean)
    hidesEmptyCells: boolean;
    setHidesEmptyCells(_: boolean)
    layoutAlgorithm: NSTextTable.LayoutAlgorithm;
    setLayoutAlgorithm(_: NSTextTable.LayoutAlgorithm)
    numberOfColumns: number;
    setNumberOfColumns(_: number)
    boundsRectForBlockContentRectInRectTextContainerCharacterRange(for_: NSTextTableBlock, contentRect: CGRect, in_: CGRect, textContainer: NSTextContainer, characterRange: NSRange): CGRect;
    drawBackgroundForBlockWithFrameInViewCharacterRangeLayoutManager(for_: NSTextTableBlock, withFrame: CGRect, in_: NSView, characterRange: NSRange, layoutManager: NSLayoutManager): void;
    rectForBlockLayoutAtPointInRectTextContainerCharacterRange(for_: NSTextTableBlock, layoutAt: CGPoint, in_: CGRect, textContainer: NSTextContainer, characterRange: NSRange): CGRect;
  }

  // interface
  class NSTextTableBlock extends NSTextBlock {
    columnSpan: number;
    rowSpan: number;
    startingColumn: number;
    startingRow: number;
    table: NSTextTable;
    static createWithTableStartingRowRowSpanStartingColumnColumnSpan(table: NSTextTable, startingRow: number, rowSpan: number, startingColumn: number, columnSpan: number): NSTextTableBlock;
  }

  // interface
  class NSTextView extends NSText /* implements NSAccessibilityNavigableStaticText, NSColorChanging, NSDraggingSource, NSMenuItemValidation, NSStandardKeyBindingResponding, NSTextInput, NSTextInputClient, NSTextLayoutOrientationProvider, NSUserInterfaceValidations, NSCandidateListTouchBarItemDelegate, NSTouchBarDelegate */ {
    static fieldEditor(): NSTextView;
    static registerForServices(): void;
    static scrollableDocumentContentTextView(): NSScrollView;
    static scrollablePlainDocumentContentTextView(): NSScrollView;
    static scrollableTextView(): NSScrollView;
    acceptableDragTypes: string[];
    acceptsGlyphInfo: boolean;
    setAcceptsGlyphInfo(_: boolean)
    allowedInputSourceLocales: string[];
    setAllowedInputSourceLocales(_: string[])
    allowsCharacterPickerTouchBarItem: boolean;
    setAllowsCharacterPickerTouchBarItem(_: boolean)
    allowsDocumentBackgroundColorChange: boolean;
    setAllowsDocumentBackgroundColorChange(_: boolean)
    allowsImageEditing: boolean;
    setAllowsImageEditing(_: boolean)
    allowsUndo: boolean;
    setAllowsUndo(_: boolean)
    isAutomaticDashSubstitutionEnabled: boolean;
    setAutomaticDashSubstitutionEnabled(_: boolean)
    isAutomaticDataDetectionEnabled: boolean;
    setAutomaticDataDetectionEnabled(_: boolean)
    isAutomaticLinkDetectionEnabled: boolean;
    setAutomaticLinkDetectionEnabled(_: boolean)
    isAutomaticQuoteSubstitutionEnabled: boolean;
    setAutomaticQuoteSubstitutionEnabled(_: boolean)
    isAutomaticSpellingCorrectionEnabled: boolean;
    setAutomaticSpellingCorrectionEnabled(_: boolean)
    isAutomaticTextCompletionEnabled: boolean;
    setAutomaticTextCompletionEnabled(_: boolean)
    isAutomaticTextReplacementEnabled: boolean;
    setAutomaticTextReplacementEnabled(_: boolean)
    isCoalescingUndo: boolean;
    isContinuousSpellCheckingEnabled: boolean;
    setContinuousSpellCheckingEnabled(_: boolean)
    defaultParagraphStyle: NSParagraphStyle;
    setDefaultParagraphStyle(_: NSParagraphStyle)
    displaysLinkToolTips: boolean;
    setDisplaysLinkToolTips(_: boolean)
    enabledTextCheckingTypes: number;
    setEnabledTextCheckingTypes(_: number)
    isGrammarCheckingEnabled: boolean;
    setGrammarCheckingEnabled(_: boolean)
    isIncrementalSearchingEnabled: boolean;
    setIncrementalSearchingEnabled(_: boolean)
    insertionPointColor: NSColor;
    setInsertionPointColor(_: NSColor)
    layoutManager: NSLayoutManager;
    linkTextAttributes: Map<string, any>;
    setLinkTextAttributes(_: Map<string, any>)
    markedTextAttributes: Map<string, any>;
    setMarkedTextAttributes(_: Map<string, any>)
    rangeForUserCharacterAttributeChange: NSRange;
    rangeForUserCompletion: NSRange;
    rangeForUserParagraphAttributeChange: NSRange;
    rangeForUserTextChange: NSRange;
    rangesForUserCharacterAttributeChange: NSValue[];
    rangesForUserParagraphAttributeChange: NSValue[];
    rangesForUserTextChange: NSValue[];
    readablePasteboardTypes: string[];
    selectedRanges: NSValue[];
    setSelectedRanges(_: NSValue[])
    selectedTextAttributes: Map<string, any>;
    setSelectedTextAttributes(_: Map<string, any>)
    selectionAffinity: NSSelectionAffinity;
    selectionGranularity: NSSelectionGranularity;
    setSelectionGranularity(_: NSSelectionGranularity)
    shouldDrawInsertionPoint: boolean;
    smartInsertDeleteEnabled: boolean;
    setSmartInsertDeleteEnabled(_: boolean)
    spellCheckerDocumentTag: number;
    textContainer: NSTextContainer;
    setTextContainer(_: NSTextContainer)
    textContainerInset: CGSize;
    setTextContainerInset(_: CGSize)
    textContainerOrigin: CGPoint;
    textStorage: NSTextStorage;
    typingAttributes: Map<string, any>;
    setTypingAttributes(_: Map<string, any>)
    usesAdaptiveColorMappingForDarkAppearance: boolean;
    setUsesAdaptiveColorMappingForDarkAppearance(_: boolean)
    usesFindBar: boolean;
    setUsesFindBar(_: boolean)
    usesFindPanel: boolean;
    setUsesFindPanel(_: boolean)
    usesInspectorBar: boolean;
    setUsesInspectorBar(_: boolean)
    usesRolloverButtonForSelection: boolean;
    setUsesRolloverButtonForSelection(_: boolean)
    usesRuler: boolean;
    setUsesRuler(_: boolean)
    writablePasteboardTypes: string[];
    static stronglyReferencesTextStorage: boolean;
    alignJustified(_?: any): void;
    breakUndoCoalescing(): void;
    changeAttributes(_?: any): void;
    changeDocumentBackgroundColor(_?: any): void;
    changeLayoutOrientation(_?: any): void;
    characterIndexForInsertionAtPoint(at: CGPoint): number;
    checkTextInDocument(_?: any): void;
    checkTextInRangeTypesOptions(in_: NSRange, types: number, options: Map<string, any>): void;
    checkTextInSelection(_?: any): void;
    cleanUpAfterDragOperation(): void;
    clickedOnLinkAtIndex(onLink: any, at: number): void;
    completionsForPartialWordRangeIndexOfSelectedItem(forPartialWordRange: NSRange, indexOfSelectedItem: number): string[];
    didChangeText(): void;
    dragImageForSelectionWithEventOrigin(with_: NSEvent, origin?: NSPoint): NSImage;
    dragOperationForDraggingInfoType(for_: NSDraggingInfo, type: string): NSDragOperation;
    dragSelectionWithEventOffsetSlideBack(with_: NSEvent, offset: CGSize, slideBack: boolean): boolean;
    drawInsertionPointInRectColorTurnedOn(in_: CGRect, color: NSColor, turnedOn: boolean): void;
    drawViewBackgroundInRect(in_: CGRect): void;
    handleTextCheckingResultsForRangeTypesOptionsOrthographyWordCount(_: NSTextCheckingResult[], forRange: NSRange, types: number, options: Map<string, any>, orthography: NSOrthography, wordCount: number): void;
    static createWithFrameTextContainer(frame: CGRect, textContainer?: NSTextContainer): NSTextView;
    insertCompletionForPartialWordRangeMovementIsFinal(_: string, forPartialWordRange: NSRange, movement: number, isFinal: boolean): void;
    invalidateTextContainerOrigin(): void;
    loosenKerning(_?: any): void;
    lowerBaseline(_?: any): void;
    orderFrontLinkPanel(_?: any): void;
    orderFrontListPanel(_?: any): void;
    orderFrontSharingServicePicker(_?: any): void;
    orderFrontSpacingPanel(_?: any): void;
    orderFrontSubstitutionsPanel(_?: any): void;
    orderFrontTablePanel(_?: any): void;
    outline(_?: any): void;
    pasteAsPlainText(_?: any): void;
    pasteAsRichText(_?: any): void;
    performFindPanelAction(_?: any): void;
    performValidatedReplacementInRangeWithAttributedString(in_: NSRange, with_: NSAttributedString): boolean;
    preferredPasteboardTypeFromArrayRestrictedToTypesFromArray(from: string[], restrictedToTypesFrom?: string[]): string;
    quickLookPreviewableItemsInRanges(_: NSValue[]): QLPreviewItem[];
    raiseBaseline(_?: any): void;
    readSelectionFromPasteboard(from: NSPasteboard): boolean;
    readSelectionFromPasteboardType(from: NSPasteboard, type: string): boolean;
    replaceTextContainer(_: NSTextContainer): void;
    selectionRangeForProposedRangeGranularity(forProposedRange: NSRange, granularity: NSSelectionGranularity): NSRange;
    setAlignmentRange(_: NSTextAlignment, range: NSRange): void;
    setBaseWritingDirectionRange(_: NSWritingDirection, range: NSRange): void;
    setConstrainedFrameSize(_: CGSize): void;
    setLayoutOrientation(_: NSLayoutManager.TextLayoutOrientation): void;
    setNeedsDisplayInRectAvoidAdditionalLayout(_: CGRect, avoidAdditionalLayout: boolean): void;
    setSelectedRange(_: NSRange): void;
    setSelectedRangeAffinityStillSelecting(_: NSRange, affinity: NSSelectionAffinity, stillSelecting: boolean): void;
    setSelectedRangesAffinityStillSelecting(_: NSValue[], affinity: NSSelectionAffinity, stillSelecting: boolean): void;
    setSpellingStateRange(_: number, range: NSRange): void;
    shouldChangeTextInRangeReplacementString(in_: NSRange, replacementString?: string): boolean;
    shouldChangeTextInRangesReplacementStrings(inRanges: NSValue[], replacementStrings?: string[]): boolean;
    showFindIndicatorForRange(for_: NSRange): void;
    smartDeleteRangeForProposedRange(forProposedRange: NSRange): NSRange;
    smartInsertAfterStringForStringReplacingRange(afterStringFor: string, replacing: NSRange): string;
    smartInsertBeforeStringForStringReplacingRange(beforeStringFor: string, replacing: NSRange): string;
    smartInsertForStringReplacingRangeBeforeStringAfterString(for_: string, replacing: NSRange, before?: string, after?: string): void;
    startSpeaking(_?: any): void;
    stopSpeaking(_?: any): void;
    tightenKerning(_?: any): void;
    toggleAutomaticDashSubstitution(_?: any): void;
    toggleAutomaticDataDetection(_?: any): void;
    toggleAutomaticLinkDetection(_?: any): void;
    toggleAutomaticQuoteSubstitution(_?: any): void;
    toggleAutomaticSpellingCorrection(_?: any): void;
    toggleAutomaticTextCompletion(_?: any): void;
    toggleAutomaticTextReplacement(_?: any): void;
    toggleContinuousSpellChecking(_?: any): void;
    toggleGrammarChecking(_?: any): void;
    toggleQuickLookPreviewPanel(_?: any): void;
    toggleSmartInsertDelete(_?: any): void;
    turnOffKerning(_?: any): void;
    turnOffLigatures(_?: any): void;
    updateCandidates(): void;
    updateDragTypeRegistration(): void;
    updateFontPanel(): void;
    updateInsertionPointStateAndRestartTimer(_: boolean): void;
    updateQuickLookPreviewPanel(): void;
    updateRuler(): void;
    updateTextTouchBarItems(): void;
    updateTouchBarItemIdentifiers(): void;
    useAllLigatures(_?: any): void;
    useStandardKerning(_?: any): void;
    useStandardLigatures(_?: any): void;
    writeSelectionToPasteboardType(to: NSPasteboard, type: string): boolean;
    writeSelectionToPasteboardTypes(to: NSPasteboard, types: string[]): boolean;
  }

  interface NSTextViewDelegate extends NSTextDelegate {
    // instance method
    textViewClickedOnLinkAtIndex?(_: NSTextView, clickedOnLink: any, at: number): boolean;
    // instance method
    textViewClickedOnCellInRectAtIndex?(_: NSTextView, clickedOn: NSTextAttachmentCell, in_: CGRect, at: number): void;
    // instance method
    textViewDoubleClickedOnCellInRectAtIndex?(_: NSTextView, doubleClickedOn: NSTextAttachmentCell, in_: CGRect, at: number): void;
    // instance method
    textViewDraggedCellInRectEventAtIndex?(_: NSTextView, draggedCell: NSTextAttachmentCell, in_: CGRect, event: NSEvent, at: number): void;
    // instance method
    textViewWritablePasteboardTypesForCellAtIndex?(_: NSTextView, writablePasteboardTypesFor: NSTextAttachmentCell, at: number): string[];
    // instance method
    textViewWriteCellAtIndexToPasteboardType?(_: NSTextView, write: NSTextAttachmentCell, at: number, to: NSPasteboard, type: string): boolean;
    // instance method
    textViewWillDisplayToolTipForCharacterAtIndex?(_: NSTextView, willDisplayToolTip: string, forCharacterAt: number): string;
    // instance method
    textViewShouldChangeTextInRangeReplacementString?(_: NSTextView, shouldChangeTextIn: NSRange, replacementString?: string): boolean;
    // instance method
    textViewDoCommandBySelector?(_: NSTextView, doCommandBy: string): boolean;
    // instance method
    textViewMenuForEventAtIndex?(_: NSTextView, menu: NSMenu, for_: NSEvent, at: number): NSMenu;
    // instance method
    textViewWillCheckTextInRangeOptionsTypes?(_: NSTextView, willCheckTextIn: NSRange, options: Map<string, any>, types: number): Map<string, any>;
    // instance method
    textViewDidCheckTextInRangeTypesOptionsResultsOrthographyWordCount?(_: NSTextView, didCheckTextIn: NSRange, types: number, options: Map<string, any>, results: NSTextCheckingResult[], orthography: NSOrthography, wordCount: number): NSTextCheckingResult[];
    // instance method
    textViewURLForContentsOfTextAttachmentAtIndex?(_: NSTextView, urlForContentsOf: NSTextAttachment, at: number): NSURL;
    // instance method
    textViewWillShowSharingServicePickerForItems?(_: NSTextView, willShow: NSSharingServicePicker, forItems: any[]): NSSharingServicePicker;
    // instance method
    textViewShouldSelectCandidateAtIndex?(_: NSTextView, shouldSelectCandidateAt: number): boolean;
    // instance method
    textViewCandidatesForSelectedRange?(_: NSTextView, candidates: NSTextCheckingResult[], forSelectedRange: NSRange): NSTextCheckingResult[];
    // instance method
    textViewCandidatesForSelectedRange?(_: NSTextView, candidatesForSelectedRange: NSRange): any[];
    // instance method
    textViewCompletionsForPartialWordRangeIndexOfSelectedItem?(_: NSTextView, completions: string[], forPartialWordRange: NSRange, indexOfSelectedItem?: number): string[];
    // instance method
    textViewShouldChangeTextInRangesReplacementStrings?(_: NSTextView, shouldChangeTextInRanges: NSValue[], replacementStrings?: string[]): boolean;
    // instance method
    textViewShouldChangeTypingAttributesToAttributes?(_: NSTextView, shouldChangeTypingAttributes: Map<string, any>, toAttributes: Map<string, any>): Map<string, any>;
    // instance method
    textViewShouldSetSpellingStateRange?(_: NSTextView, shouldSetSpellingState: number, range: NSRange): number;
    // instance method
    textViewShouldUpdateTouchBarItemIdentifiers?(_: NSTextView, shouldUpdateTouchBarItemIdentifiers: string[]): string[];
    // instance method
    textViewWillChangeSelectionFromCharacterRangeToCharacterRange?(_: NSTextView, willChangeSelectionFromCharacterRange: NSRange, toCharacterRange: NSRange): NSRange;
    // instance method
    textViewWillChangeSelectionFromCharacterRangesToCharacterRanges?(_: NSTextView, willChangeSelectionFromCharacterRanges: NSValue[], toCharacterRanges: NSValue[]): NSValue[];
    // instance method
    textViewDidChangeSelection?(_: NSNotification): void;
    // instance method
    textViewDidChangeTypingAttributes?(_: NSNotification): void;
    // instance method
    undoManagerForTextView?(for_: NSTextView): UndoManager;
  }

  // interface
  class NSTitlebarAccessoryViewController extends NSViewController /* implements NSAnimatablePropertyContainer, NSAnimationDelegate */ {
    fullScreenMinHeight: number;
    setFullScreenMinHeight(_: number)
    isHidden: boolean;
    setHidden(_: boolean)
    layoutAttribute: NSLayoutConstraint.Attribute;
    setLayoutAttribute(_: NSLayoutConstraint.Attribute)
  }

  // interface
  class NSTokenField extends NSTextField {
    completionDelay: number;
    setCompletionDelay(_: number)
    tokenStyle: NSTokenField.TokenStyle;
    setTokenStyle(_: NSTokenField.TokenStyle)
    tokenizingCharacterSet: NSCharacterSet;
    setTokenizingCharacterSet(_: NSCharacterSet)
    static defaultCompletionDelay: number;
    static defaultTokenizingCharacterSet: NSCharacterSet;
  }

  // interface
  class NSTokenFieldCell extends NSTextFieldCell {
    completionDelay: number;
    setCompletionDelay(_: number)
    delegate: NSTokenFieldCellDelegate;
    setDelegate(_: NSTokenFieldCellDelegate)
    tokenStyle: NSTokenField.TokenStyle;
    setTokenStyle(_: NSTokenField.TokenStyle)
    tokenizingCharacterSet: NSCharacterSet;
    setTokenizingCharacterSet(_: NSCharacterSet)
    static defaultCompletionDelay: number;
    static defaultTokenizingCharacterSet: NSCharacterSet;
  }

  interface NSTokenFieldCellDelegate extends NSObject {
    // instance method
    tokenFieldCellShouldAddObjectsAtIndex?(_: NSTokenFieldCell, shouldAdd: any[], at: number): any[];
    // instance method
    tokenFieldCellRepresentedObjectForEditingString?(_: NSTokenFieldCell, representedObjectForEditing: string): any;
    // instance method
    tokenFieldCellWriteRepresentedObjectsToPasteboard?(_: NSTokenFieldCell, writeRepresentedObjects: any[], to: NSPasteboard): boolean;
    // instance method
    tokenFieldCellReadFromPasteboard?(_: NSTokenFieldCell, readFrom: NSPasteboard): any[];
    // instance method
    tokenFieldCellCompletionsForSubstringIndexOfTokenIndexOfSelectedItem?(_: NSTokenFieldCell, completionsForSubstring: string, indexOfToken: number, indexOfSelectedItem: number): any[];
    // instance method
    tokenFieldCellDisplayStringForRepresentedObject?(_: NSTokenFieldCell, displayStringForRepresentedObject: any): string;
    // instance method
    tokenFieldCellEditingStringForRepresentedObject?(_: NSTokenFieldCell, editingStringForRepresentedObject: any): string;
    // instance method
    tokenFieldCellHasMenuForRepresentedObject?(_: NSTokenFieldCell, hasMenuForRepresentedObject: any): boolean;
    // instance method
    tokenFieldCellMenuForRepresentedObject?(_: NSTokenFieldCell, menuForRepresentedObject: any): NSMenu;
    // instance method
    tokenFieldCellStyleForRepresentedObject?(_: NSTokenFieldCell, styleForRepresentedObject: any): NSTokenField.TokenStyle;
  }

  interface NSTokenFieldDelegate extends NSTextFieldDelegate {
    // instance method
    tokenFieldShouldAddObjectsAtIndex?(_: NSTokenField, shouldAdd: any[], at: number): any[];
    // instance method
    tokenFieldRepresentedObjectForEditingString?(_: NSTokenField, representedObjectForEditing: string): any;
    // instance method
    tokenFieldWriteRepresentedObjectsToPasteboard?(_: NSTokenField, writeRepresentedObjects: any[], to: NSPasteboard): boolean;
    // instance method
    tokenFieldReadFromPasteboard?(_: NSTokenField, readFrom: NSPasteboard): any[];
    // instance method
    tokenFieldCompletionsForSubstringIndexOfTokenIndexOfSelectedItem?(_: NSTokenField, completionsForSubstring: string, indexOfToken: number, indexOfSelectedItem?: number): any[];
    // instance method
    tokenFieldDisplayStringForRepresentedObject?(_: NSTokenField, displayStringForRepresentedObject: any): string;
    // instance method
    tokenFieldEditingStringForRepresentedObject?(_: NSTokenField, editingStringForRepresentedObject: any): string;
    // instance method
    tokenFieldHasMenuForRepresentedObject?(_: NSTokenField, hasMenuForRepresentedObject: any): boolean;
    // instance method
    tokenFieldMenuForRepresentedObject?(_: NSTokenField, menuForRepresentedObject: any): NSMenu;
    // instance method
    tokenFieldStyleForRepresentedObject?(_: NSTokenField, styleForRepresentedObject: any): NSTokenField.TokenStyle;
  }

  // interface
  class NSToolbar extends NSObject {
    allowsExtensionItems: boolean;
    setAllowsExtensionItems(_: boolean)
    allowsUserCustomization: boolean;
    setAllowsUserCustomization(_: boolean)
    autosavesConfiguration: boolean;
    setAutosavesConfiguration(_: boolean)
    centeredItemIdentifier: string;
    setCenteredItemIdentifier(_: string)
    configurationDictionary: Map<string, any>;
    customizationPaletteIsRunning: boolean;
    delegate: NSToolbarDelegate;
    setDelegate(_: NSToolbarDelegate)
    displayMode: NSToolbar.DisplayMode;
    setDisplayMode(_: NSToolbar.DisplayMode)
    identifier: string;
    items: NSToolbarItem[];
    selectedItemIdentifier: string;
    setSelectedItemIdentifier(_: string)
    showsBaselineSeparator: boolean;
    setShowsBaselineSeparator(_: boolean)
    sizeMode: NSToolbar.SizeMode;
    setSizeMode(_: NSToolbar.SizeMode)
    isVisible: boolean;
    setVisible(_: boolean)
    visibleItems: NSToolbarItem[];
    static createWithIdentifier(identifier: string): NSToolbar;
    insertItemWithItemIdentifierAtIndex(withItemIdentifier: string, at: number): void;
    removeItemAtIndex(at: number): void;
    runCustomizationPalette(_?: any): void;
    setConfigurationFromDictionary(_: Map<string, any>): void;
    validateVisibleItems(): void;
  }

  interface NSToolbarDelegate extends NSObject {
    // instance method
    toolbarItemForItemIdentifierWillBeInsertedIntoToolbar?(_: NSToolbar, itemForItemIdentifier: string, willBeInsertedIntoToolbar: boolean): NSToolbarItem;
    // instance method
    toolbarAllowedItemIdentifiers?(_: NSToolbar): string[];
    // instance method
    toolbarDefaultItemIdentifiers?(_: NSToolbar): string[];
    // instance method
    toolbarDidRemoveItem?(_: NSNotification): void;
    // instance method
    toolbarSelectableItemIdentifiers?(_: NSToolbar): string[];
    // instance method
    toolbarWillAddItem?(_: NSNotification): void;
  }

  // interface
  class NSToolbarItem extends NSObject /* implements NSCopying, NSMenuItemValidation, NSValidatedUserInterfaceItem */ {
    action: string;
    setAction(_: string)
    allowsDuplicatesInToolbar: boolean;
    autovalidates: boolean;
    setAutovalidates(_: boolean)
    isBordered: boolean;
    setBordered(_: boolean)
    isEnabled: boolean;
    setEnabled(_: boolean)
    image: NSImage;
    setImage(_: NSImage)
    itemIdentifier: string;
    label: string;
    setLabel(_: string)
    maxSize: CGSize;
    setMaxSize(_: CGSize)
    menuFormRepresentation: NSMenuItem;
    setMenuFormRepresentation(_: NSMenuItem)
    minSize: CGSize;
    setMinSize(_: CGSize)
    paletteLabel: string;
    setPaletteLabel(_: string)
    tag: number;
    setTag(_: number)
    target: any;
    setTarget(_: any)
    title: string;
    setTitle(_: string)
    toolTip: string;
    setToolTip(_: string)
    toolbar: NSToolbar;
    view: NSView;
    setView(_: NSView)
    visibilityPriority: number;
    setVisibilityPriority(_: number)
    static createWithItemIdentifier(itemIdentifier: string): NSToolbarItem;
    validate(): void;
  }

  // interface
  class NSToolbarItemGroup extends NSToolbarItem {
    controlRepresentation: NSToolbarItemGroup.ControlRepresentation;
    setControlRepresentation(_: NSToolbarItemGroup.ControlRepresentation)
    selectedIndex: number;
    setSelectedIndex(_: number)
    selectionMode: NSToolbarItemGroup.SelectionMode;
    setSelectionMode(_: NSToolbarItemGroup.SelectionMode)
    subitems: NSToolbarItem[];
    setSubitems(_: NSToolbarItem[])
    isSelectedAtIndex(at: number): boolean;
    setSelectedAtIndex(_: boolean, at: number): void;
  }

  interface NSToolbarItemValidation extends NSObject {
    // instance method
    validateToolbarItem(_: NSToolbarItem): boolean;
  }

  // interface
  class NSTouch extends NSObject /* implements NSCopying */ {
    device: any;
    deviceSize: CGSize;
    identity: any;
    normalizedPosition: CGPoint;
    phase: NSTouch.Phase;
    isResting: boolean;
    type: NSTouch.TouchType;
    locationInView(in_?: NSView): CGPoint;
    previousLocationInView(in_?: NSView): CGPoint;
  }

  // interface
  class NSTouchBar extends NSObject /* implements NSCoding */ {
    customizationAllowedItemIdentifiers: string[];
    setCustomizationAllowedItemIdentifiers(_: string[])
    customizationIdentifier: string;
    setCustomizationIdentifier(_: string)
    customizationRequiredItemIdentifiers: string[];
    setCustomizationRequiredItemIdentifiers(_: string[])
    defaultItemIdentifiers: string[];
    setDefaultItemIdentifiers(_: string[])
    delegate: NSTouchBarDelegate;
    setDelegate(_: NSTouchBarDelegate)
    escapeKeyReplacementItemIdentifier: string;
    setEscapeKeyReplacementItemIdentifier(_: string)
    itemIdentifiers: string[];
    principalItemIdentifier: string;
    setPrincipalItemIdentifier(_: string)
    templateItems: NSSet<NSTouchBarItem>;
    setTemplateItems(_: NSSet<NSTouchBarItem>)
    isVisible: boolean;
    static isAutomaticCustomizeTouchBarMenuItemEnabled: boolean;
    setAutomaticCustomizeTouchBarMenuItemEnabled(_: boolean)
    itemForIdentifier(forIdentifier: string): NSTouchBarItem;
  }

  interface NSTouchBarDelegate extends NSObject {
    // instance method
    touchBarMakeItemForIdentifier?(_: NSTouchBar, makeItemForIdentifier: string): NSTouchBarItem;
  }

  // interface
  class NSTouchBarItem extends NSObject /* implements NSCoding */ {
    customizationLabel: string;
    identifier: string;
    view: NSView;
    viewController: NSViewController;
    visibilityPriority: number;
    setVisibilityPriority(_: number)
    isVisible: boolean;
    static createWithIdentifier(identifier: string): NSTouchBarItem;
  }

  interface NSTouchBarProvider extends NSObject {
    touchBar: NSTouchBar;
  }

  // interface
  class NSTrackingArea extends NSObject /* implements NSCoding, NSCopying */ {
    options: NSTrackingArea.Options;
    owner: any;
    rect: CGRect;
    userInfo: Map<any, any>;
    static createWithRectOptionsOwnerUserInfo(rect: CGRect, options: NSTrackingArea.Options, owner?: any, userInfo?: Map<any, any>): NSTrackingArea;
  }

  // interface
  class NSTreeController extends NSObjectController {
    alwaysUsesMultipleValuesMarker: boolean;
    setAlwaysUsesMultipleValuesMarker(_: boolean)
    arrangedObjects: NSTreeNode;
    avoidsEmptySelection: boolean;
    setAvoidsEmptySelection(_: boolean)
    canAddChild: boolean;
    canInsert: boolean;
    canInsertChild: boolean;
    childrenKeyPath: string;
    setChildrenKeyPath(_: string)
    countKeyPath: string;
    setCountKeyPath(_: string)
    leafKeyPath: string;
    setLeafKeyPath(_: string)
    preservesSelection: boolean;
    setPreservesSelection(_: boolean)
    selectedNodes: NSTreeNode[];
    selectionIndexPath: NSIndexPath;
    selectionIndexPaths: NSIndexPath[];
    selectsInsertedObjects: boolean;
    setSelectsInsertedObjects(_: boolean)
    sortDescriptors: NSSortDescriptor[];
    setSortDescriptors(_: NSSortDescriptor[])
    addChild(_?: any): void;
    addSelectionIndexPaths(_: NSIndexPath[]): boolean;
    childrenKeyPathForNode(for_: NSTreeNode): string;
    countKeyPathForNode(for_: NSTreeNode): string;
    insert(_?: any): void;
    insertChild(_?: any): void;
    insertObjectAtArrangedObjectIndexPath(_?: any, atArrangedObjectIndexPath?: NSIndexPath): void;
    insertObjectsAtArrangedObjectIndexPaths(_: any[], atArrangedObjectIndexPaths: NSIndexPath[]): void;
    leafKeyPathForNode(for_: NSTreeNode): string;
    moveNodeToIndexPath(_: NSTreeNode, to: NSIndexPath): void;
    moveNodesToIndexPath(_: NSTreeNode[], to: NSIndexPath): void;
    rearrangeObjects(): void;
    removeObjectAtArrangedObjectIndexPath(atArrangedObjectIndexPath: NSIndexPath): void;
    removeObjectsAtArrangedObjectIndexPaths(atArrangedObjectIndexPaths: NSIndexPath[]): void;
    removeSelectionIndexPaths(_: NSIndexPath[]): boolean;
    setSelectionIndexPath(_?: NSIndexPath): boolean;
    setSelectionIndexPaths(_: NSIndexPath[]): boolean;
  }

  // interface
  class NSTreeNode extends NSObject {
    childNodes: NSTreeNode[];
    indexPath: NSIndexPath;
    isLeaf: boolean;
    mutableChildNodes: NSMutableArray<NSTreeNode>;
    parentNode: NSTreeNode;
    representedObject: any;
    descendantNodeAtIndexPath(at: NSIndexPath): NSTreeNode;
    static createWithRepresentedObject(representedObject?: any): NSTreeNode;
    sortWithSortDescriptorsRecursively(with_: NSSortDescriptor[], recursively: boolean): void;
  }

  // interface
  class NSTypesetter extends NSObject {
    static printingAdjustmentInLayoutManagerForNominallySpacedGlyphRangePackedGlyphsCount(in_: NSLayoutManager, forNominallySpacedGlyphRange: NSRange, packedGlyphs: string, count: number): CGSize;
    static sharedSystemTypesetterForBehavior(for_: NSLayoutManager.TypesetterBehavior): any;
    attributedString: NSAttributedString;
    setAttributedString(_: NSAttributedString)
    attributesForExtraLineFragment: Map<string, any>;
    bidiProcessingEnabled: boolean;
    setBidiProcessingEnabled(_: boolean)
    currentParagraphStyle: NSParagraphStyle;
    currentTextContainer: NSTextContainer;
    hyphenationFactor: number;
    setHyphenationFactor(_: number)
    layoutManager: NSLayoutManager;
    lineFragmentPadding: number;
    setLineFragmentPadding(_: number)
    paragraphCharacterRange: NSRange;
    paragraphGlyphRange: NSRange;
    paragraphSeparatorCharacterRange: NSRange;
    paragraphSeparatorGlyphRange: NSRange;
    textContainers: NSTextContainer[];
    typesetterBehavior: NSLayoutManager.TypesetterBehavior;
    setTypesetterBehavior(_: NSLayoutManager.TypesetterBehavior)
    usesFontLeading: boolean;
    setUsesFontLeading(_: boolean)
    static defaultTypesetterBehavior: NSLayoutManager.TypesetterBehavior;
    static sharedSystemTypesetter: NSTypesetter;
    actionForControlCharacterAtIndex(at: number): NSTypesetterControlCharacterAction;
    baselineOffsetInLayoutManagerGlyphIndex(in_: NSLayoutManager, glyphIndex: number): number;
    beginLineWithGlyphAtIndex(withGlyphAt: number): void;
    beginParagraph(): void;
    boundingBoxForControlGlyphAtIndexForTextContainerProposedLineFragmentGlyphPositionCharacterIndex(forControlGlyphAt: number, for_: NSTextContainer, proposedLineFragment: CGRect, glyphPosition: CGPoint, characterIndex: number): CGRect;
    characterRangeForGlyphRangeActualGlyphRange(forGlyphRange: NSRange, actualGlyphRange?: NSRange): NSRange;
    endLineWithGlyphRange(withGlyphRange: NSRange): void;
    endParagraph(): void;
    getLineFragmentRectUsedRectForParagraphSeparatorGlyphRangeAtProposedOrigin(_: NSRect, usedRect: NSRect, forParagraphSeparatorGlyphRange: NSRange, atProposedOrigin: CGPoint): void;
    getLineFragmentRectUsedRectRemainingRectForStartingGlyphAtIndexProposedRectLineSpacingParagraphSpacingBeforeParagraphSpacingAfter(_: NSRect, usedRect: NSRect, remaining: NSRect, forStartingGlyphAt: number, proposedRect: CGRect, lineSpacing: number, paragraphSpacingBefore: number, paragraphSpacingAfter: number): void;
    glyphRangeForCharacterRangeActualCharacterRange(forCharacterRange: NSRange, actualCharacterRange?: NSRange): NSRange;
    hyphenCharacterForGlyphAtIndex(forGlyphAt: number): number;
    hyphenationFactorForGlyphAtIndex(forGlyphAt: number): number;
    layoutCharactersInRangeForLayoutManagerMaximumNumberOfLineFragments(in_: NSRange, for_: NSLayoutManager, maximumNumberOfLineFragments: number): NSRange;
    layoutGlyphsInLayoutManagerStartingAtGlyphIndexMaxNumberOfLineFragmentsNextGlyphIndex(in_: NSLayoutManager, startingAtGlyphIndex: number, maxNumberOfLineFragments: number, nextGlyphIndex: number): void;
    layoutParagraphAtPoint(at: NSPoint): number;
    lineSpacingAfterGlyphAtIndexWithProposedLineFragmentRect(afterGlyphAt: number, withProposedLineFragmentRect: CGRect): number;
    paragraphSpacingAfterGlyphAtIndexWithProposedLineFragmentRect(afterGlyphAt: number, withProposedLineFragmentRect: CGRect): number;
    paragraphSpacingBeforeGlyphAtIndexWithProposedLineFragmentRect(beforeGlyphAt: number, withProposedLineFragmentRect: CGRect): number;
    setAttachmentSizeForGlyphRange(_: CGSize, forGlyphRange: NSRange): void;
    setBidiLevelsForGlyphRange(_: string, forGlyphRange: NSRange): void;
    setDrawsOutsideLineFragmentForGlyphRange(_: boolean, forGlyphRange: NSRange): void;
    setHardInvalidationForGlyphRange(_: boolean, forGlyphRange: NSRange): void;
    setLineFragmentRectForGlyphRangeUsedRectBaselineOffset(_: CGRect, forGlyphRange: NSRange, usedRect: CGRect, baselineOffset: number): void;
    setLocationWithAdvancementsForStartOfGlyphRange(_: CGPoint, withAdvancements: number, forStartOfGlyphRange: NSRange): void;
    setNotShownAttributeForGlyphRange(_: boolean, forGlyphRange: NSRange): void;
    setParagraphGlyphRangeSeparatorGlyphRange(_: NSRange, separatorGlyphRange: NSRange): void;
    shouldBreakLineByHyphenatingBeforeCharacterAtIndex(byHyphenatingBeforeCharacterAt: number): boolean;
    shouldBreakLineByWordBeforeCharacterAtIndex(byWordBeforeCharacterAt: number): boolean;
    substituteFontForFont(for_: NSFont): NSFont;
    textTabForGlyphLocationWritingDirectionMaxLocation(forGlyphLocation: number, writingDirection: NSWritingDirection, maxLocation: number): NSTextTab;
    willSetLineFragmentRectForGlyphRangeUsedRectBaselineOffset(_: NSRect, forGlyphRange: NSRange, usedRect: NSRect, baselineOffset: number): void;
  }

  // export function NSUnregisterServicesProvider(name: string): void;

  // export function NSUpdateDynamicServices(): void;

  interface NSUserActivityRestoring extends NSObject {
    // instance method
    restoreUserActivityState(_: NSUserActivity): void;
  }

  // interface
  class NSUserDefaultsController extends NSController {
    appliesImmediately: boolean;
    setAppliesImmediately(_: boolean)
    defaults: UserDefaults;
    hasUnappliedChanges: boolean;
    initialValues: Map<string, any>;
    setInitialValues(_: Map<string, any>)
    values: any;
    static sharedUserDefaultsController: NSUserDefaultsController;
    static createWithDefaultsInitialValues(defaults?: UserDefaults, initialValues?: Map<string, any>): NSUserDefaultsController;
    revert(_?: any): void;
    revertToInitialValues(_?: any): void;
    save(_?: any): void;
  }

  interface NSUserInterfaceCompression {
    activeCompressionOptions: NSUserInterfaceCompressionOptions;
    // instance method
    compressWithPrioritizedCompressionOptions(withPrioritizedCompressionOptions: NSUserInterfaceCompressionOptions[]): void;
    // instance method
    minimumSizeWithPrioritizedCompressionOptions(withPrioritizedCompressionOptions: NSUserInterfaceCompressionOptions[]): CGSize;
  }

  // interface
  class NSUserInterfaceCompressionOptions extends NSObject /* implements NSCoding, NSCopying */ {
    isEmpty: boolean;
    static breakEqualWidthsOption: NSUserInterfaceCompressionOptions;
    static hideImagesOption: NSUserInterfaceCompressionOptions;
    static hideTextOption: NSUserInterfaceCompressionOptions;
    static reduceMetricsOption: NSUserInterfaceCompressionOptions;
    static standardOptions: NSUserInterfaceCompressionOptions;
    containsOptions(_: NSUserInterfaceCompressionOptions): boolean;
    static createWithCompressionOptions(compressionOptions: NSSet<NSUserInterfaceCompressionOptions>): NSUserInterfaceCompressionOptions;
    static createWithIdentifier(identifier: string): NSUserInterfaceCompressionOptions;
    intersectsOptions(_: NSUserInterfaceCompressionOptions): boolean;
    optionsByAddingOptions(_: NSUserInterfaceCompressionOptions): NSUserInterfaceCompressionOptions;
    optionsByRemovingOptions(_: NSUserInterfaceCompressionOptions): NSUserInterfaceCompressionOptions;
  }

  interface NSUserInterfaceItemIdentification {
    identifier: string;
    setIdentifier(_: string)
  }

  interface NSUserInterfaceItemSearching extends NSObject {
    // instance method
    localizedTitlesForItem(forItem: any): string[];
    // instance method
    performActionForItem?(forItem: any): void;
    // instance method
    searchForItemsWithWithSearchResultLimitMatchedItemHandler(withSearch: string, resultLimit: number, matchedItemHandler: (p1: any[]) => void): void;
    // instance method
    showAllHelpTopicsForSearchString?(forSearch: string): void;
  }

  interface NSUserInterfaceValidations {
    // instance method
    validateUserInterfaceItem(_: NSValidatedUserInterfaceItem): boolean;
  }

  interface NSValidatedUserInterfaceItem {
    action: string;
    tag: number;
  }

  // interface
  class NSView extends NSResponder /* implements NSAccessibility, NSAccessibilityElement, NSAnimatablePropertyContainer, NSAppearanceCustomization, NSDraggingDestination, NSUserInterfaceItemIdentification */ {
    alignmentRectInsets: NSEdgeInsets;
    allowedTouchTypes: NSTouch.TouchTypeMask;
    setAllowedTouchTypes(_: NSTouch.TouchTypeMask)
    allowsVibrancy: boolean;
    alphaValue: number;
    setAlphaValue(_: number)
    autoresizesSubviews: boolean;
    setAutoresizesSubviews(_: boolean)
    autoresizingMask: NSView.AutoresizingMask;
    setAutoresizingMask(_: NSView.AutoresizingMask)
    backgroundFilters: CIFilter[];
    setBackgroundFilters(_: CIFilter[])
    baselineOffsetFromBottom: number;
    bottomAnchor: NSLayoutYAxisAnchor;
    bounds: CGRect;
    setBounds(_: CGRect)
    boundsRotation: number;
    setBoundsRotation(_: number)
    canBecomeKeyView: boolean;
    canDrawConcurrently: boolean;
    setCanDrawConcurrently(_: boolean)
    canDrawSubviewsIntoLayer: boolean;
    setCanDrawSubviewsIntoLayer(_: boolean)
    candidateListTouchBarItem: NSCandidateListTouchBarItem<any>;
    centerXAnchor: NSLayoutXAxisAnchor;
    centerYAnchor: NSLayoutYAxisAnchor;
    compositingFilter: CIFilter;
    setCompositingFilter(_: CIFilter)
    constraints: NSLayoutConstraint[];
    contentFilters: CIFilter[];
    setContentFilters(_: CIFilter[])
    isDrawingFindIndicator: boolean;
    enclosingMenuItem: NSMenuItem;
    enclosingScrollView: NSScrollView;
    firstBaselineAnchor: NSLayoutYAxisAnchor;
    firstBaselineOffsetFromTop: number;
    fittingSize: CGSize;
    isFlipped: boolean;
    focusRingMaskBounds: CGRect;
    focusRingType: NSFocusRingType;
    setFocusRingType(_: NSFocusRingType)
    frame: CGRect;
    setFrame(_: CGRect)
    frameCenterRotation: number;
    setFrameCenterRotation(_: number)
    frameRotation: number;
    setFrameRotation(_: number)
    gestureRecognizers: NSGestureRecognizer[];
    setGestureRecognizers(_: NSGestureRecognizer[])
    hasAmbiguousLayout: boolean;
    heightAdjustLimit: number;
    heightAnchor: NSLayoutDimension;
    isHidden: boolean;
    setHidden(_: boolean)
    isHiddenOrHasHiddenAncestor: boolean;
    isHorizontalContentSizeConstraintActive: boolean;
    setHorizontalContentSizeConstraintActive(_: boolean)
    isInFullScreenMode: boolean;
    inLiveResize: boolean;
    inputContext: NSTextInputContext;
    intrinsicContentSize: CGSize;
    lastBaselineAnchor: NSLayoutYAxisAnchor;
    lastBaselineOffsetFromBottom: number;
    layer: CALayer;
    setLayer(_: CALayer)
    layerContentsPlacement: NSView.LayerContentsPlacement;
    setLayerContentsPlacement(_: NSView.LayerContentsPlacement)
    layerContentsRedrawPolicy: NSView.LayerContentsRedrawPolicy;
    setLayerContentsRedrawPolicy(_: NSView.LayerContentsRedrawPolicy)
    layerUsesCoreImageFilters: boolean;
    setLayerUsesCoreImageFilters(_: boolean)
    layoutGuides: NSLayoutGuide[];
    leadingAnchor: NSLayoutXAxisAnchor;
    leftAnchor: NSLayoutXAxisAnchor;
    mouseDownCanMoveWindow: boolean;
    needsDisplay: boolean;
    setNeedsDisplay(_: boolean)
    needsLayout: boolean;
    setNeedsLayout(_: boolean)
    needsPanelToBecomeKey: boolean;
    needsUpdateConstraints: boolean;
    setNeedsUpdateConstraints(_: boolean)
    nextKeyView: NSView;
    setNextKeyView(_: NSView)
    nextValidKeyView: NSView;
    isOpaque: boolean;
    opaqueAncestor: NSView;
    pageFooter: NSAttributedString;
    pageHeader: NSAttributedString;
    postsBoundsChangedNotifications: boolean;
    setPostsBoundsChangedNotifications(_: boolean)
    postsFrameChangedNotifications: boolean;
    setPostsFrameChangedNotifications(_: boolean)
    preparedContentRect: CGRect;
    setPreparedContentRect(_: CGRect)
    preservesContentDuringLiveResize: boolean;
    pressureConfiguration: NSPressureConfiguration;
    setPressureConfiguration(_: NSPressureConfiguration)
    previousKeyView: NSView;
    previousValidKeyView: NSView;
    printJobTitle: string;
    rectPreservedDuringLiveResize: CGRect;
    registeredDraggedTypes: string[];
    rightAnchor: NSLayoutXAxisAnchor;
    isRotatedFromBase: boolean;
    isRotatedOrScaledFromBase: boolean;
    shadow: NSShadow;
    setShadow(_: NSShadow)
    subviews: NSView[];
    setSubviews(_: NSView[])
    superview: NSView;
    tag: number;
    toolTip: string;
    setToolTip(_: string)
    topAnchor: NSLayoutYAxisAnchor;
    trackingAreas: NSTrackingArea[];
    trailingAnchor: NSLayoutXAxisAnchor;
    translatesAutoresizingMaskIntoConstraints: boolean;
    setTranslatesAutoresizingMaskIntoConstraints(_: boolean)
    userInterfaceLayoutDirection: NSUserInterfaceLayoutDirection;
    setUserInterfaceLayoutDirection(_: NSUserInterfaceLayoutDirection)
    isVerticalContentSizeConstraintActive: boolean;
    setVerticalContentSizeConstraintActive(_: boolean)
    visibleRect: CGRect;
    wantsDefaultClipping: boolean;
    wantsLayer: boolean;
    setWantsLayer(_: boolean)
    wantsRestingTouches: boolean;
    setWantsRestingTouches(_: boolean)
    wantsUpdateLayer: boolean;
    widthAdjustLimit: number;
    widthAnchor: NSLayoutDimension;
    window: NSWindow;
    static isCompatibleWithResponsiveScrolling: boolean;
    static defaultFocusRingType: NSFocusRingType;
    static defaultMenu: NSMenu;
    static focusView: NSView;
    static requiresConstraintBasedLayout: boolean;
    acceptsFirstMouse(for_?: NSEvent): boolean;
    addConstraint(_: NSLayoutConstraint): void;
    addConstraints(_: NSLayoutConstraint[]): void;
    addCursorRectCursor(_: CGRect, cursor: NSCursor): void;
    addGestureRecognizer(_: NSGestureRecognizer): void;
    addLayoutGuide(_: NSLayoutGuide): void;
    addSubview(_: NSView): void;
    addSubviewPositionedRelativeTo(_: NSView, positioned: NSWindow.OrderingMode, relativeTo?: NSView): void;
    addToolTipRectOwnerUserData(_: CGRect, owner: any, userData?: any): number;
    addTrackingArea(_: NSTrackingArea): void;
    addTrackingRectOwnerUserDataAssumeInside(_: CGRect, owner: any, userData?: any, assumeInside?: boolean): number;
    adjustPageHeightNewTopBottomLimit(_: number, top: number, bottom: number, limit: number): void;
    adjustPageWidthNewLeftRightLimit(_: number, left: number, right: number, limit: number): void;
    adjustScroll(_: CGRect): CGRect;
    alignmentRectForFrame(forFrame: CGRect): CGRect;
    ancestorSharedWithView(with_: NSView): NSView;
    autoscroll(with_: NSEvent): boolean;
    backingAlignedRectOptions(_: CGRect, options: AlignmentOptions): CGRect;
    beginDocument(): void;
    beginDraggingSessionWithItemsEventSource(with_: NSDraggingItem[], event: NSEvent, source: NSDraggingSource): NSDraggingSession;
    beginPageInRectAtPlacement(in_: CGRect, atPlacement: CGPoint): void;
    bitmapImageRepForCachingDisplayInRect(in_: CGRect): NSBitmapImageRep;
    cacheDisplayInRectToBitmapImageRep(in_: CGRect, to: NSBitmapImageRep): void;
    centerScanRect(_: CGRect): CGRect;
    constraintsAffectingLayoutForOrientation(for_: NSLayoutConstraint.Orientation): NSLayoutConstraint[];
    contentCompressionResistancePriorityForOrientation(for_: NSLayoutConstraint.Orientation): number;
    contentHuggingPriorityForOrientation(for_: NSLayoutConstraint.Orientation): number;
    convertPointFromView(_: CGPoint, from?: NSView): CGPoint;
    convertPointToView(_: CGPoint, to?: NSView): CGPoint;
    convertPointFromBacking(_: CGPoint): CGPoint;
    convertPointFromLayer(_: CGPoint): CGPoint;
    convertPointToBacking(_: CGPoint): CGPoint;
    convertPointToLayer(_: CGPoint): CGPoint;
    convertRectFromView(_: CGRect, from?: NSView): CGRect;
    convertRectToView(_: CGRect, to?: NSView): CGRect;
    convertRectFromBacking(_: CGRect): CGRect;
    convertRectFromLayer(_: CGRect): CGRect;
    convertRectToBacking(_: CGRect): CGRect;
    convertRectToLayer(_: CGRect): CGRect;
    convertSizeFromView(_: CGSize, from?: NSView): CGSize;
    convertSizeToView(_: CGSize, to?: NSView): CGSize;
    convertSizeFromBacking(_: CGSize): CGSize;
    convertSizeFromLayer(_: CGSize): CGSize;
    convertSizeToBacking(_: CGSize): CGSize;
    convertSizeToLayer(_: CGSize): CGSize;
    dataWithEPSInsideRect(inside: CGRect): NSData;
    dataWithPDFInsideRect(inside: CGRect): NSData;
    didAddSubview(_: NSView): void;
    didCloseMenuWithEvent(_: NSMenu, with_?: NSEvent): void;
    discardCursorRects(): void;
    display(): void;
    displayIfNeeded(): void;
    displayIfNeededIgnoringOpacity(): void;
    displayIfNeededInRect(_: CGRect): void;
    displayIfNeededInRectIgnoringOpacity(_: CGRect): void;
    displayRect(_: CGRect): void;
    displayRectIgnoringOpacity(_: CGRect): void;
    displayRectIgnoringOpacityInContext(_: CGRect, in_: NSGraphicsContext): void;
    drawFocusRingMask(): void;
    drawPageBorderWithSize(with_: CGSize): void;
    drawRect(_: CGRect): void;
    endDocument(): void;
    endPage(): void;
    enterFullScreenModeWithOptions(_: NSScreen, withOptions?: Map<string, any>): boolean;
    exerciseAmbiguityInLayout(): void;
    exitFullScreenModeWithOptions(options?: Map<string, any>): void;
    frameForAlignmentRect(forAlignmentRect: CGRect): CGRect;
    getRectsBeingDrawnCount(_?: NSRect, count?: number): void;
    getRectsExposedDuringLiveResizeCount(_: NSRect, count: number): void;
    hitTest(_: CGPoint): NSView;
    static createWithFrame(frame: CGRect): NSView;
    invalidateIntrinsicContentSize(): void;
    isDescendantOf(of: NSView): boolean;
    knowsPageRange(_: NSRange): boolean;
    layout(): void;
    layoutSubtreeIfNeeded(): void;
    locationOfPrintRect(_: CGRect): CGPoint;
    makeBackingLayer(): CALayer;
    menuForEvent(for_: NSEvent): NSMenu;
    mouseInRect(_: CGPoint, in_: CGRect): boolean;
    needsToDrawRect(_: CGRect): boolean;
    noteFocusRingMaskChanged(): void;
    prepareContentInRect(in_: CGRect): void;
    prepareForReuse(): void;
    print(_?: any): void;
    rectForPage(_: number): CGRect;
    rectForSmartMagnificationAtPointInRect(at: CGPoint, in_: CGRect): CGRect;
    reflectScrolledClipView(_: NSClipView): void;
    registerForDraggedTypes(_: string[]): void;
    removeAllToolTips(): void;
    removeConstraint(_: NSLayoutConstraint): void;
    removeConstraints(_: NSLayoutConstraint[]): void;
    removeCursorRectCursor(_: CGRect, cursor: NSCursor): void;
    removeFromSuperview(): void;
    removeFromSuperviewWithoutNeedingDisplay(): void;
    removeGestureRecognizer(_: NSGestureRecognizer): void;
    removeLayoutGuide(_: NSLayoutGuide): void;
    removeToolTip(_: number): void;
    removeTrackingArea(_: NSTrackingArea): void;
    removeTrackingRect(_: number): void;
    replaceSubviewWith(_: NSView, with_: NSView): void;
    resetCursorRects(): void;
    resizeSubviewsWithOldSize(withOldSize: CGSize): void;
    resizeWithOldSuperviewSize(withOldSuperviewSize: CGSize): void;
    rotateByAngle(byDegrees: number): void;
    rulerViewDidAddMarker(_: NSRulerView, didAdd: NSRulerMarker): void;
    rulerViewDidMoveMarker(_: NSRulerView, didMove: NSRulerMarker): void;
    rulerViewDidRemoveMarker(_: NSRulerView, didRemove: NSRulerMarker): void;
    rulerViewHandleMouseDown(_: NSRulerView, handleMouseDownWith: NSEvent): void;
    rulerViewLocationForPoint(_: NSRulerView, locationFor: CGPoint): number;
    rulerViewPointForLocation(_: NSRulerView, pointForLocation: number): CGPoint;
    rulerViewShouldAddMarker(_: NSRulerView, shouldAdd: NSRulerMarker): boolean;
    rulerViewShouldMoveMarker(_: NSRulerView, shouldMove: NSRulerMarker): boolean;
    rulerViewShouldRemoveMarker(_: NSRulerView, shouldRemove: NSRulerMarker): boolean;
    rulerViewWillAddMarkerAtLocation(_: NSRulerView, willAdd: NSRulerMarker, atLocation: number): number;
    rulerViewWillMoveMarkerToLocation(_: NSRulerView, willMove: NSRulerMarker, toLocation: number): number;
    rulerViewWillSetClientView(_: NSRulerView, willSetClientView: NSView): void;
    scaleUnitSquareToSize(to: CGSize): void;
    scrollClipViewToPoint(_: NSClipView, to: CGPoint): void;
    scrollPoint(_: CGPoint): void;
    scrollRectToVisible(_: CGRect): boolean;
    setBoundsOrigin(_: CGPoint): void;
    setBoundsSize(_: CGSize): void;
    setContentCompressionResistancePriorityForOrientation(_: number, for_: NSLayoutConstraint.Orientation): void;
    setContentHuggingPriorityForOrientation(_: number, for_: NSLayoutConstraint.Orientation): void;
    setFrameOrigin(_: CGPoint): void;
    setFrameSize(_: CGSize): void;
    setKeyboardFocusRingNeedsDisplayInRect(_: CGRect): void;
    setNeedsDisplayInRect(_: CGRect): void;
    shouldDelayWindowOrderingForEvent(for_: NSEvent): boolean;
    showDefinitionForAttributedStringAtPoint(for_?: NSAttributedString, at?: CGPoint): void;
    showDefinitionForRangeOptionsBaselineOriginProvider(for_?: NSAttributedString, range?: NSRange, options?: Map<string, any>, baselineOriginProvider?: (p1: NSRange) => CGPoint): void;
    sortSubviewsContext(_?: (p1: NSView, p2: NSView, p3: any) => ComparisonResult, context?: any): void;
    translateOriginToPoint(to: CGPoint): void;
    translateRectsNeedingDisplayInRectBy(in_: CGRect, by: CGSize): void;
    unregisterDraggedTypes(): void;
    updateConstraints(): void;
    updateConstraintsForSubtreeIfNeeded(): void;
    updateLayer(): void;
    updateTrackingAreas(): void;
    viewDidChangeBackingProperties(): void;
    viewDidChangeEffectiveAppearance(): void;
    viewDidEndLiveResize(): void;
    viewDidHide(): void;
    viewDidMoveToSuperview(): void;
    viewDidMoveToWindow(): void;
    viewDidUnhide(): void;
    viewWillDraw(): void;
    viewWillMoveToSuperview(toSuperview?: NSView): void;
    viewWillMoveToWindow(toWindow?: NSWindow): void;
    viewWillStartLiveResize(): void;
    viewWithTag(_: number): NSView;
    willOpenMenuWithEvent(_: NSMenu, with_: NSEvent): void;
    willRemoveSubview(_: NSView): void;
    writeEPSInsideRectToPasteboard(inside: CGRect, to: NSPasteboard): void;
    writePDFInsideRectToPasteboard(inside: CGRect, to: NSPasteboard): void;
  }

  // interface
  class NSViewAnimation extends NSAnimation {
    viewAnimations: Map<string, any>[];
    setViewAnimations(_: Map<string, any>[])
    static createWithViewAnimations(viewAnimations: Map<string, any>[]): NSViewAnimation;
  }

  // interface
  class NSViewController extends NSResponder /* implements NSEditor, NSSeguePerforming, NSUserInterfaceItemIdentification, NSExtensionRequestHandling */ {
    childViewControllers: NSViewController[];
    setChildViewControllers(_: NSViewController[])
    extensionContext: NSExtensionContext;
    nibBundle: Bundle;
    nibName: string;
    parentViewController: NSViewController;
    preferredContentSize: CGSize;
    setPreferredContentSize(_: CGSize)
    preferredMaximumSize: CGSize;
    preferredMinimumSize: CGSize;
    preferredScreenOrigin: CGPoint;
    setPreferredScreenOrigin(_: CGPoint)
    presentedViewControllers: NSViewController[];
    presentingViewController: NSViewController;
    representedObject: any;
    setRepresentedObject(_: any)
    sourceItemView: NSView;
    setSourceItemView(_: NSView)
    storyboard: NSStoryboard;
    title: string;
    setTitle(_: string)
    view: NSView;
    setView(_: NSView)
    isViewLoaded: boolean;
    addChildViewController(_: NSViewController): void;
    dismissController(_?: any): void;
    dismissViewController(_: NSViewController): void;
    static createWithNibNameBundle(nibName?: string, bundle?: Bundle): NSViewController;
    insertChildViewControllerAtIndex(_: NSViewController, at: number): void;
    loadView(): void;
    preferredContentSizeDidChangeForViewController(for_: NSViewController): void;
    presentViewControllerAnimator(_: NSViewController, animator: NSViewControllerPresentationAnimator): void;
    presentViewControllerAsPopoverRelativeToRectOfViewPreferredEdgeBehavior(_: NSViewController, asPopoverRelativeTo: CGRect, of: NSView, preferredEdge: NSRectEdge, behavior: NSPopover.Behavior): void;
    presentViewControllerAsModalWindow(_: NSViewController): void;
    presentViewControllerAsSheet(_: NSViewController): void;
    removeChildViewControllerAtIndex(at: number): void;
    removeFromParentViewController(): void;
    transitionWithFromToOptionsCompletionHandler(from: NSViewController, to: NSViewController, options: NSViewController.TransitionOptions, completionHandler?: () => void): void;
    updateViewConstraints(): void;
    viewDidAppear(): void;
    viewDidDisappear(): void;
    viewDidLayout(): void;
    viewDidLoad(): void;
    viewWillAppear(): void;
    viewWillDisappear(): void;
    viewWillLayout(): void;
    viewWillTransitionToSize(to: CGSize): void;
  }

  interface NSViewControllerPresentationAnimator extends NSObject {
    // instance method
    animateDismissalOfViewControllerFromViewController(of: NSViewController, from: NSViewController): void;
    // instance method
    animatePresentationOfViewControllerFromViewController(of: NSViewController, from: NSViewController): void;
  }

  interface NSViewLayerContentScaleDelegate extends NSObject {
    // instance method
    layerShouldInheritContentsScaleFromWindow?(_: CALayer, shouldInheritContentsScale: number, from: NSWindow): boolean;
  }

  interface NSViewToolTipOwner extends NSObject {
    // instance method
    viewStringForToolTipPointUserData(_: NSView, stringForToolTip: number, point: CGPoint, userData?: any): string;
  }

  // interface
  class NSVisualEffectView extends NSView {
    blendingMode: NSVisualEffectView.BlendingMode;
    setBlendingMode(_: NSVisualEffectView.BlendingMode)
    isEmphasized: boolean;
    setEmphasized(_: boolean)
    interiorBackgroundStyle: NSView.BackgroundStyle;
    maskImage: NSImage;
    setMaskImage(_: NSImage)
    material: NSVisualEffectView.Material;
    setMaterial(_: NSVisualEffectView.Material)
    state: NSVisualEffectView.State;
    setState(_: NSVisualEffectView.State)
  }

  // interface
  class NSWindow extends NSResponder /* implements NSAccessibility, NSAccessibilityElement, NSAnimatablePropertyContainer, NSAppearanceCustomization, NSMenuItemValidation, NSUserInterfaceItemIdentification, NSUserInterfaceValidations */ {
    static contentRectForFrameRectStyleMask(forFrameRect: CGRect, styleMask: NSWindow.StyleMask): CGRect;
    static frameRectForContentRectStyleMask(forContentRect: CGRect, styleMask: NSWindow.StyleMask): CGRect;
    static minFrameWidthWithTitleStyleMask(withTitle: string, styleMask: NSWindow.StyleMask): number;
    static removeFrameUsingName(usingName: string): void;
    static standardWindowButtonForStyleMask(_: NSWindow.ButtonType, for_: NSWindow.StyleMask): NSButton;
    static windowNumberAtPointBelowWindowWithWindowNumber(at: CGPoint, belowWindowWithWindowNumber: number): number;
    static windowNumbersWithOptions(options: NSWindow.NumberListOptions): number[];
    acceptsMouseMovedEvents: boolean;
    setAcceptsMouseMovedEvents(_: boolean)
    allowsConcurrentViewDrawing: boolean;
    setAllowsConcurrentViewDrawing(_: boolean)
    allowsToolTipsWhenApplicationIsInactive: boolean;
    setAllowsToolTipsWhenApplicationIsInactive(_: boolean)
    alphaValue: number;
    setAlphaValue(_: number)
    animationBehavior: NSWindow.AnimationBehavior;
    setAnimationBehavior(_: NSWindow.AnimationBehavior)
    appearanceSource: NSObject;
    setAppearanceSource(_: NSObject)
    areCursorRectsEnabled: boolean;
    aspectRatio: CGSize;
    setAspectRatio(_: CGSize)
    attachedSheet: NSWindow;
    autorecalculatesKeyViewLoop: boolean;
    setAutorecalculatesKeyViewLoop(_: boolean)
    backgroundColor: NSColor;
    setBackgroundColor(_: NSColor)
    backingScaleFactor: number;
    backingType: NSWindow.BackingStoreType;
    setBackingType(_: NSWindow.BackingStoreType)
    canBecomeKeyWindow: boolean;
    canBecomeMainWindow: boolean;
    canBecomeVisibleWithoutLogin: boolean;
    setCanBecomeVisibleWithoutLogin(_: boolean)
    canHide: boolean;
    setCanHide(_: boolean)
    childWindows: NSWindow[];
    collectionBehavior: NSWindow.CollectionBehavior;
    setCollectionBehavior(_: NSWindow.CollectionBehavior)
    colorSpace: NSColorSpace;
    setColorSpace(_: NSColorSpace)
    contentAspectRatio: CGSize;
    setContentAspectRatio(_: CGSize)
    contentLayoutGuide: any;
    contentLayoutRect: CGRect;
    contentMaxSize: CGSize;
    setContentMaxSize(_: CGSize)
    contentMinSize: CGSize;
    setContentMinSize(_: CGSize)
    contentResizeIncrements: CGSize;
    setContentResizeIncrements(_: CGSize)
    contentView: NSView;
    setContentView(_: NSView)
    contentViewController: NSViewController;
    setContentViewController(_: NSViewController)
    currentEvent: NSEvent;
    deepestScreen: NSScreen;
    defaultButtonCell: NSButtonCell;
    setDefaultButtonCell(_: NSButtonCell)
    delegate: NSWindowDelegate;
    setDelegate(_: NSWindowDelegate)
    depthLimit: NSWindow.Depth;
    setDepthLimit(_: NSWindow.Depth)
    deviceDescription: Map<string, any>;
    displaysWhenScreenProfileChanges: boolean;
    setDisplaysWhenScreenProfileChanges(_: boolean)
    dockTile: NSDockTile;
    isDocumentEdited: boolean;
    setDocumentEdited(_: boolean)
    isExcludedFromWindowsMenu: boolean;
    setExcludedFromWindowsMenu(_: boolean)
    firstResponder: NSResponder;
    isFloatingPanel: boolean;
    frame: CGRect;
    frameAutosaveName: string;
    hasCloseBox: boolean;
    hasDynamicDepthLimit: boolean;
    hasShadow: boolean;
    setHasShadow(_: boolean)
    hasTitleBar: boolean;
    hidesOnDeactivate: boolean;
    setHidesOnDeactivate(_: boolean)
    ignoresMouseEvents: boolean;
    setIgnoresMouseEvents(_: boolean)
    inLiveResize: boolean;
    initialFirstResponder: NSView;
    setInitialFirstResponder(_: NSView)
    keyViewSelectionDirection: NSWindow.SelectionDirection;
    isKeyWindow: boolean;
    level: number;
    setLevel(_: number)
    isMainWindow: boolean;
    maxFullScreenContentSize: CGSize;
    setMaxFullScreenContentSize(_: CGSize)
    maxSize: CGSize;
    setMaxSize(_: CGSize)
    minFullScreenContentSize: CGSize;
    setMinFullScreenContentSize(_: CGSize)
    minSize: CGSize;
    setMinSize(_: CGSize)
    isMiniaturizable: boolean;
    isMiniaturized: boolean;
    miniwindowImage: NSImage;
    setMiniwindowImage(_: NSImage)
    miniwindowTitle: string;
    setMiniwindowTitle(_: string)
    isModalPanel: boolean;
    mouseLocationOutsideOfEventStream: CGPoint;
    isMovable: boolean;
    setMovable(_: boolean)
    isMovableByWindowBackground: boolean;
    setMovableByWindowBackground(_: boolean)
    occlusionState: NSWindow.OcclusionState;
    isOnActiveSpace: boolean;
    isOpaque: boolean;
    setOpaque(_: boolean)
    orderedIndex: number;
    setOrderedIndex(_: number)
    parentWindow: NSWindow;
    setParentWindow(_: NSWindow)
    preservesContentDuringLiveResize: boolean;
    setPreservesContentDuringLiveResize(_: boolean)
    preventsApplicationTerminationWhenModal: boolean;
    setPreventsApplicationTerminationWhenModal(_: boolean)
    isReleasedWhenClosed: boolean;
    setReleasedWhenClosed(_: boolean)
    representedFilename: string;
    setRepresentedFilename(_: string)
    representedURL: NSURL;
    setRepresentedURL(_: NSURL)
    isResizable: boolean;
    resizeFlags: NSEvent.ModifierFlags;
    resizeIncrements: CGSize;
    setResizeIncrements(_: CGSize)
    isRestorable: boolean;
    setRestorable(_: boolean)
    restorationClass: typeof NSObject;
    setRestorationClass(_: typeof NSObject)
    screen: NSScreen;
    sharingType: NSWindow.SharingType;
    setSharingType(_: NSWindow.SharingType)
    isSheet: boolean;
    sheetParent: NSWindow;
    sheets: NSWindow[];
    showsResizeIndicator: boolean;
    setShowsResizeIndicator(_: boolean)
    showsToolbarButton: boolean;
    setShowsToolbarButton(_: boolean)
    stringWithSavedFrame: string;
    styleMask: NSWindow.StyleMask;
    setStyleMask(_: NSWindow.StyleMask)
    tab: NSWindowTab;
    tabGroup: NSWindowTabGroup;
    tabbedWindows: NSWindow[];
    tabbingIdentifier: string;
    setTabbingIdentifier(_: string)
    tabbingMode: NSWindow.TabbingMode;
    setTabbingMode(_: NSWindow.TabbingMode)
    title: string;
    setTitle(_: string)
    titleVisibility: NSWindow.TitleVisibility;
    setTitleVisibility(_: NSWindow.TitleVisibility)
    titlebarAccessoryViewControllers: NSTitlebarAccessoryViewController[];
    setTitlebarAccessoryViewControllers(_: NSTitlebarAccessoryViewController[])
    titlebarAppearsTransparent: boolean;
    setTitlebarAppearsTransparent(_: boolean)
    toolbar: NSToolbar;
    setToolbar(_: NSToolbar)
    viewsNeedDisplay: boolean;
    setViewsNeedDisplay(_: boolean)
    isVisible: boolean;
    windowController: NSWindowController;
    setWindowController(_: NSWindowController)
    windowNumber: number;
    windowRef: any;
    windowTitlebarLayoutDirection: NSUserInterfaceLayoutDirection;
    worksWhenModal: boolean;
    isZoomable: boolean;
    isZoomed: boolean;
    static allowsAutomaticWindowTabbing: boolean;
    setAllowsAutomaticWindowTabbing(_: boolean)
    static defaultDepthLimit: NSWindow.Depth;
    static userTabbingPreference: NSWindow.UserTabbingPreference;
    addChildWindowOrdered(_: NSWindow, ordered: NSWindow.OrderingMode): void;
    addTabbedWindowOrdered(_: NSWindow, ordered: NSWindow.OrderingMode): void;
    addTitlebarAccessoryViewController(_: NSTitlebarAccessoryViewController): void;
    anchorAttributeForOrientation(for_: NSLayoutConstraint.Orientation): NSLayoutConstraint.Attribute;
    animationResizeTime(_: CGRect): number;
    autorecalculatesContentBorderThicknessForEdge(for_: NSRectEdge): boolean;
    backingAlignedRectOptions(_: CGRect, options: AlignmentOptions): CGRect;
    becomeKeyWindow(): void;
    becomeMainWindow(): void;
    beginCriticalSheetWithCompletionHandler(_: NSWindow, completionHandler?: (p1: number) => void): void;
    beginSheetWithCompletionHandler(_: NSWindow, completionHandler?: (p1: number) => void): void;
    canRepresentDisplayGamut(_: NSDisplayGamut): boolean;
    cascadeTopLeftFromPoint(from: CGPoint): CGPoint;
    center(): void;
    close(): void;
    constrainFrameRectToScreen(_: CGRect, to?: NSScreen): CGRect;
    contentBorderThicknessForEdge(for_: NSRectEdge): number;
    contentRectForFrameRect(forFrameRect: CGRect): CGRect;
    convertPointFromBacking(_: CGPoint): CGPoint;
    convertPointFromScreen(fromScreen: CGPoint): CGPoint;
    convertPointToBacking(_: CGPoint): CGPoint;
    convertPointToScreen(toScreen: CGPoint): CGPoint;
    convertRectFromBacking(_: CGRect): CGRect;
    convertRectFromScreen(_: CGRect): CGRect;
    convertRectToBacking(_: CGRect): CGRect;
    convertRectToScreen(_: CGRect): CGRect;
    dataWithEPSInsideRect(inside: CGRect): NSData;
    dataWithPDFInsideRect(inside: CGRect): NSData;
    deminiaturize(_?: any): void;
    disableCursorRects(): void;
    disableKeyEquivalentForDefaultButtonCell(): void;
    disableScreenUpdatesUntilFlush(): void;
    disableSnapshotRestoration(): void;
    discardCursorRects(): void;
    discardEventsMatchingMaskBeforeEvent(matching: NSEvent.EventTypeMask, before?: NSEvent): void;
    display(): void;
    displayIfNeeded(): void;
    dragImageAtOffsetEventPasteboardSourceSlideBack(_: NSImage, at: CGPoint, offset: CGSize, event: NSEvent, pasteboard: NSPasteboard, source: any, slideBack: boolean): void;
    enableCursorRects(): void;
    enableKeyEquivalentForDefaultButtonCell(): void;
    enableSnapshotRestoration(): void;
    endEditingFor(for_?: any): void;
    endSheet(_: NSWindow): void;
    endSheetReturnCode(_: NSWindow, returnCode: number): void;
    fieldEditorForObject(_: boolean, for_?: any): NSText;
    frameRectForContentRect(forContentRect: CGRect): CGRect;
    handleCloseScriptCommand(_: NSCloseCommand): any;
    handlePrintScriptCommand(_: NSScriptCommand): any;
    handleSaveScriptCommand(_: NSScriptCommand): any;
    static createWithContentRectStyleMaskBackingDefer(contentRect: CGRect, styleMask: NSWindow.StyleMask, backing: NSWindow.BackingStoreType, defer: boolean): NSWindow;
    static createWithContentRectStyleMaskBackingDeferScreen(contentRect: CGRect, styleMask: NSWindow.StyleMask, backing: NSWindow.BackingStoreType, defer: boolean, screen?: NSScreen): NSWindow;
    static createWithWindowRef(windowRef: any): NSWindow;
    insertTitlebarAccessoryViewControllerAtIndex(_: NSTitlebarAccessoryViewController, at: number): void;
    invalidateCursorRectsForView(for_: NSView): void;
    invalidateShadow(): void;
    layoutIfNeeded(): void;
    makeFirstResponder(_?: NSResponder): boolean;
    makeKeyAndOrderFront(_?: any): void;
    makeKeyWindow(): void;
    makeMainWindow(): void;
    mergeAllWindows(_?: any): void;
    miniaturize(_?: any): void;
    moveTabToNewWindow(_?: any): void;
    nextEventMatchingMask(matching: NSEvent.EventTypeMask): NSEvent;
    nextEventMatchingMaskUntilDateInModeDequeue(matching: NSEvent.EventTypeMask, until?: Date, inMode?: string, dequeue?: boolean): NSEvent;
    orderBack(_?: any): void;
    orderFront(_?: any): void;
    orderFrontRegardless(): void;
    orderOut(_?: any): void;
    orderWindowRelativeTo(_: NSWindow.OrderingMode, relativeTo: number): void;
    performClose(_?: any): void;
    performMiniaturize(_?: any): void;
    performWindowDragWithEvent(with_: NSEvent): void;
    performZoom(_?: any): void;
    postEventAtStart(_: NSEvent, atStart: boolean): void;
    print(_?: any): void;
    recalculateKeyViewLoop(): void;
    registerForDraggedTypes(_: string[]): void;
    removeChildWindow(_: NSWindow): void;
    removeTitlebarAccessoryViewControllerAtIndex(at: number): void;
    resetCursorRects(): void;
    resignKeyWindow(): void;
    resignMainWindow(): void;
    runToolbarCustomizationPalette(_?: any): void;
    saveFrameUsingName(usingName: string): void;
    selectKeyViewFollowingView(following: NSView): void;
    selectKeyViewPrecedingView(preceding: NSView): void;
    selectNextKeyView(_?: any): void;
    selectNextTab(_?: any): void;
    selectPreviousKeyView(_?: any): void;
    selectPreviousTab(_?: any): void;
    sendEvent(_: NSEvent): void;
    setAnchorAttributeForOrientation(_: NSLayoutConstraint.Attribute, for_: NSLayoutConstraint.Orientation): void;
    setAutorecalculatesContentBorderThicknessForEdge(_: boolean, for_: NSRectEdge): void;
    setContentBorderThicknessForEdge(_: number, for_: NSRectEdge): void;
    setContentSize(_: CGSize): void;
    setDynamicDepthLimit(_: boolean): void;
    setFrameDisplay(_: CGRect, display: boolean): void;
    setFrameDisplayAnimate(_: CGRect, display: boolean, animate: boolean): void;
    setFrameAutosaveName(_: string): boolean;
    setFrameFromString(from: string): void;
    setFrameOrigin(_: CGPoint): void;
    setFrameTopLeftPoint(_: CGPoint): void;
    setFrameUsingName(_: string): boolean;
    setFrameUsingNameForce(_: string, force: boolean): boolean;
    setIsMiniaturized(_: boolean): void;
    setIsVisible(_: boolean): void;
    setIsZoomed(_: boolean): void;
    setTitleWithRepresentedFilename(_: string): void;
    standardWindowButton(_: NSWindow.ButtonType): NSButton;
    toggleFullScreen(_?: any): void;
    toggleTabBar(_?: any): void;
    toggleTabOverview(_?: any): void;
    toggleToolbarShown(_?: any): void;
    trackEventsWithMatchingTimeoutModeHandler(matching: NSEvent.EventTypeMask, timeout: number, mode: string, handler?: (p1: NSEvent, p2: boolean) => void): void;
    unregisterDraggedTypes(): void;
    update(): void;
    updateConstraintsIfNeeded(): void;
    visualizeConstraints(_?: NSLayoutConstraint[]): void;
    zoom(_?: any): void;
  }

  // interface
  class NSWindowController extends NSResponder /* implements NSSeguePerforming */ {
    contentViewController: NSViewController;
    setContentViewController(_: NSViewController)
    document: any;
    setDocument(_: any)
    owner: any;
    shouldCascadeWindows: boolean;
    setShouldCascadeWindows(_: boolean)
    shouldCloseDocument: boolean;
    setShouldCloseDocument(_: boolean)
    storyboard: NSStoryboard;
    window: NSWindow;
    setWindow(_: NSWindow)
    windowFrameAutosaveName: string;
    setWindowFrameAutosaveName(_: string)
    isWindowLoaded: boolean;
    windowNibName: string;
    windowNibPath: string;
    close(): void;
    dismissController(_?: any): void;
    static createWithWindow(window?: NSWindow): NSWindowController;
    static createWithWindowNibName(windowNibName: string): NSWindowController;
    static createWithWindowNibNameOwner(windowNibName: string, owner: any): NSWindowController;
    static createWithWindowNibPathOwner(windowNibPath: string, owner: any): NSWindowController;
    loadWindow(): void;
    setDocumentEdited(_: boolean): void;
    showWindow(_?: any): void;
    synchronizeWindowTitleWithDocumentName(): void;
    windowDidLoad(): void;
    windowTitleForDocumentDisplayName(forDocumentDisplayName: string): string;
    windowWillLoad(): void;
  }

  interface NSWindowDelegate extends NSObject {
    // instance method
    customWindowsToEnterFullScreenForWindow?(for_: NSWindow): NSWindow[];
    // instance method
    customWindowsToEnterFullScreenForWindowOnScreen?(for_: NSWindow, on: NSScreen): NSWindow[];
    // instance method
    customWindowsToExitFullScreenForWindow?(for_: NSWindow): NSWindow[];
    // instance method
    windowWillPositionSheetUsingRect?(_: NSWindow, willPositionSheet: NSWindow, using: CGRect): CGRect;
    // instance method
    windowShouldDragDocumentWithEventFromWithPasteboard?(_: NSWindow, shouldDragDocumentWith: NSEvent, from: CGPoint, with_: NSPasteboard): boolean;
    // instance method
    windowStartCustomAnimationToEnterFullScreenOnScreenWithDuration?(_: NSWindow, startCustomAnimationToEnterFullScreenOn: NSScreen, withDuration: number): void;
    // instance method
    windowDidDecodeRestorableState?(_: NSWindow, didDecodeRestorableState: NSCoder): void;
    // instance method
    windowShouldPopUpDocumentPathMenu?(_: NSWindow, shouldPopUpDocumentPathMenu: NSMenu): boolean;
    // instance method
    windowStartCustomAnimationToEnterFullScreenWithDuration?(_: NSWindow, startCustomAnimationToEnterFullScreenWithDuration: number): void;
    // instance method
    windowStartCustomAnimationToExitFullScreenWithDuration?(_: NSWindow, startCustomAnimationToExitFullScreenWithDuration: number): void;
    // instance method
    windowWillEncodeRestorableState?(_: NSWindow, willEncodeRestorableState: NSCoder): void;
    // instance method
    windowWillResizeForVersionBrowserWithMaxPreferredSizeMaxAllowedSize?(_: NSWindow, willResizeForVersionBrowserWithMaxPreferredSize: CGSize, maxAllowedSize: CGSize): CGSize;
    // instance method
    windowWillUseFullScreenContentSize?(_: NSWindow, willUseFullScreenContentSize: CGSize): CGSize;
    // instance method
    windowWillUseFullScreenPresentationOptions?(_: NSWindow, willUseFullScreenPresentationOptions: NSApplication.PresentationOptions): NSApplication.PresentationOptions;
    // instance method
    windowDidBecomeKey?(_: NSNotification): void;
    // instance method
    windowDidBecomeMain?(_: NSNotification): void;
    // instance method
    windowDidChangeBackingProperties?(_: NSNotification): void;
    // instance method
    windowDidChangeOcclusionState?(_: NSNotification): void;
    // instance method
    windowDidChangeScreen?(_: NSNotification): void;
    // instance method
    windowDidChangeScreenProfile?(_: NSNotification): void;
    // instance method
    windowDidDeminiaturize?(_: NSNotification): void;
    // instance method
    windowDidEndLiveResize?(_: NSNotification): void;
    // instance method
    windowDidEndSheet?(_: NSNotification): void;
    // instance method
    windowDidEnterFullScreen?(_: NSNotification): void;
    // instance method
    windowDidEnterVersionBrowser?(_: NSNotification): void;
    // instance method
    windowDidExitFullScreen?(_: NSNotification): void;
    // instance method
    windowDidExitVersionBrowser?(_: NSNotification): void;
    // instance method
    windowDidExpose?(_: NSNotification): void;
    // instance method
    windowDidFailToEnterFullScreen?(_: NSWindow): void;
    // instance method
    windowDidFailToExitFullScreen?(_: NSWindow): void;
    // instance method
    windowDidMiniaturize?(_: NSNotification): void;
    // instance method
    windowDidMove?(_: NSNotification): void;
    // instance method
    windowDidResignKey?(_: NSNotification): void;
    // instance method
    windowDidResignMain?(_: NSNotification): void;
    // instance method
    windowDidResize?(_: NSNotification): void;
    // instance method
    windowDidUpdate?(_: NSNotification): void;
    // instance method
    windowShouldClose?(_: NSWindow): boolean;
    // instance method
    windowShouldZoomToFrame?(_: NSWindow, toFrame: CGRect): boolean;
    // instance method
    windowWillBeginSheet?(_: NSNotification): void;
    // instance method
    windowWillClose?(_: NSNotification): void;
    // instance method
    windowWillEnterFullScreen?(_: NSNotification): void;
    // instance method
    windowWillEnterVersionBrowser?(_: NSNotification): void;
    // instance method
    windowWillExitFullScreen?(_: NSNotification): void;
    // instance method
    windowWillExitVersionBrowser?(_: NSNotification): void;
    // instance method
    windowWillMiniaturize?(_: NSNotification): void;
    // instance method
    windowWillMove?(_: NSNotification): void;
    // instance method
    windowWillResizeToSize?(_: NSWindow, to: CGSize): CGSize;
    // instance method
    windowWillReturnFieldEditorToObject?(_: NSWindow, to?: any): any;
    // instance method
    windowWillReturnUndoManager?(_: NSWindow): UndoManager;
    // instance method
    windowWillStartLiveResize?(_: NSNotification): void;
    // instance method
    windowWillUseStandardFrameDefaultFrame?(_: NSWindow, defaultFrame: CGRect): CGRect;
  }

  type NSWindowRestoration = NSObject

  // interface
  class NSWindowTab extends NSObject {
    accessoryView: NSView;
    setAccessoryView(_: NSView)
    attributedTitle: NSAttributedString;
    setAttributedTitle(_: NSAttributedString)
    title: string;
    setTitle(_: string)
    toolTip: string;
    setToolTip(_: string)
  }

  // interface
  class NSWindowTabGroup extends NSObject {
    identifier: string;
    isOverviewVisible: boolean;
    setOverviewVisible(_: boolean)
    selectedWindow: NSWindow;
    setSelectedWindow(_: NSWindow)
    isTabBarVisible: boolean;
    windows: NSWindow[];
    addWindow(_: NSWindow): void;
    insertWindowAtIndex(_: NSWindow, at: number): void;
    removeWindow(_: NSWindow): void;
  }

  // interface
  class NSWorkspace extends NSObject {
    accessibilityDisplayShouldDifferentiateWithoutColor: boolean;
    accessibilityDisplayShouldIncreaseContrast: boolean;
    accessibilityDisplayShouldInvertColors: boolean;
    accessibilityDisplayShouldReduceMotion: boolean;
    accessibilityDisplayShouldReduceTransparency: boolean;
    fileLabelColors: NSColor[];
    fileLabels: string[];
    frontmostApplication: NSRunningApplication;
    menuBarOwningApplication: NSRunningApplication;
    notificationCenter: NotificationCenter;
    runningApplications: NSRunningApplication[];
    isSwitchControlEnabled: boolean;
    isVoiceOverEnabled: boolean;
    static sharedWorkspace: NSWorkspace;
    URLForApplicationToOpenURL(toOpen: NSURL): NSURL;
    URLForApplicationWithBundleIdentifier(withBundleIdentifier: string): NSURL;
    activateFileViewerSelectingURLs(_: NSURL[]): void;
    desktopImageOptionsForScreen(for_: NSScreen): Map<string, any>;
    desktopImageURLForScreen(for_: NSScreen): NSURL;
    duplicateCompletionHandler(_: NSURL[], completionHandler?: (p1: Map<NSURL, NSURL>, p2: NSError) => void): void;
    extendPowerOffBy(by: number): number;
    filenameExtensionIsValidForType(_: string, isValidForType: string): boolean;
    getFileSystemInfoForPathIsRemovableIsWritableIsUnmountableDescriptionType(forPath: string, isRemovable?: boolean, isWritable?: boolean, isUnmountable?: boolean, description?: string, type?: string): boolean;
    getInfoForFileApplicationType(_: string, application?: string, type?: string): boolean;
    hideOtherApplications(): void;
    iconForFile(forFile: string): NSImage;
    iconForFileType(forFileType: string): NSImage;
    iconForFiles(forFiles: string[]): NSImage;
    isFilePackageAtPath(atPath: string): boolean;
    launchApplicationAtURLOptionsConfigurationError(options: NSURL, configuration: NSWorkspace.LaunchOptions, error: Map<string, any>): NSRunningApplication;
    localizedDescriptionForType(forType: string): string;
    noteFileSystemChanged(_: string): void;
    openApplicationWithAtConfigurationCompletionHandler(at: NSURL, configuration: OpenConfiguration, completionHandler?: (p1: NSRunningApplication, p2: NSError) => void): void;
    openURL(_: NSURL): boolean;
    openConfigurationCompletionHandler(_: NSURL, configuration: OpenConfiguration, completionHandler?: (p1: NSRunningApplication, p2: NSError) => void): void;
    openURLOptionsConfigurationError(options: NSURL, configuration: NSWorkspace.LaunchOptions, error: Map<string, any>): NSRunningApplication;
    openWithApplicationAtConfigurationCompletionHandler(_: NSURL[], withApplicationAt: NSURL, configuration: OpenConfiguration, completionHandler?: (p1: NSRunningApplication, p2: NSError) => void): void;
    openURLsWithApplicationAtURLOptionsConfigurationError(withApplicationAtURL: NSURL[], options: NSURL, configuration: NSWorkspace.LaunchOptions, error: Map<string, any>): NSRunningApplication;
    preferredFilenameExtensionForType(forType: string): string;
    recycleCompletionHandler(_: NSURL[], completionHandler?: (p1: Map<NSURL, NSURL>, p2: NSError) => void): void;
    requestAuthorizationWithToCompletionHandler(to: NSWorkspace.AuthorizationType, completionHandler?: (p1: Authorization, p2: NSError) => void): void;
    selectFileInFileViewerRootedAtPath(_?: string, inFileViewerRootedAtPath?: string): boolean;
    setDesktopImageURLForScreenOptionsError(forScreen: NSURL, options: NSScreen, error: Map<string, any>): boolean;
    setIconForFileOptions(_?: NSImage, forFile?: string, options?: NSWorkspace.IconCreationOptions): boolean;
    showSearchResultsForQueryString(forQueryString: string): boolean;
    typeConformsToType(_: string, conformsToType: string): boolean;
    typeOfFileError(error: string): string;
    unmountAndEjectDeviceAtPath(atPath: string): boolean;
    unmountAndEjectDeviceAtURLError(error: NSURL): boolean;
  }

  // interface
  class Authorization extends NSObject {
  }

  // interface
  class OpenConfiguration extends NSObject /* implements NSCopying */ {
    static configuration(): OpenConfiguration;
    activates: boolean;
    setActivates(_: boolean)
    addsToRecentItems: boolean;
    setAddsToRecentItems(_: boolean)
    allowsRunningApplicationSubstitution: boolean;
    setAllowsRunningApplicationSubstitution(_: boolean)
    appleEvent: NSAppleEventDescriptor;
    setAppleEvent(_: NSAppleEventDescriptor)
    architecture: number;
    setArchitecture(_: number)
    arguments: string[];
    setArguments(_: string[])
    createsNewApplicationInstance: boolean;
    setCreatesNewApplicationInstance(_: boolean)
    environment: Map<string, string>;
    setEnvironment(_: Map<string, string>)
    isForPrinting: boolean;
    setForPrinting(_: boolean)
    hides: boolean;
    setHides(_: boolean)
    hidesOthers: boolean;
    setHidesOthers(_: boolean)
    promptsUserIfNeeded: boolean;
    setPromptsUserIfNeeded(_: boolean)
    requiresUniversalLinks: boolean;
    setRequiresUniversalLinks(_: boolean)
  }

  // interface
  class NSAsynchronousFetchRequest<ResultType> extends NSPersistentStoreRequest {
    completionBlock: (p1: NSAsynchronousFetchResult<any>) => void;
    estimatedResultCount: number;
    setEstimatedResultCount(_: number)
    fetchRequest: NSFetchRequest<ResultType>;
  }

  // interface
  class NSAsynchronousFetchResult<ResultType> extends NSPersistentStoreAsynchronousResult {
    fetchRequest: NSAsynchronousFetchRequest<ResultType>;
    finalResult: ResultType[];
  }

  // interface
  class NSAtomicStore extends NSPersistentStore {
    addCacheNodes(_: NSSet<NSAtomicStoreCacheNode>): void;
    cacheNodeForObjectID(_: NSManagedObjectID): NSAtomicStoreCacheNode;
    cacheNodes(): NSSet<NSAtomicStoreCacheNode>;
    load(): boolean;
    newCacheNodeForManagedObject(_: NSManagedObject): NSAtomicStoreCacheNode;
    newReferenceObjectForManagedObject(_: NSManagedObject): any;
    objectIDForEntityReferenceObject(for_: NSEntityDescription, withReferenceObject: any): NSManagedObjectID;
    referenceObjectForObjectID(_: NSManagedObjectID): any;
    save(): boolean;
    updateCacheNodeFromManagedObject(_: NSAtomicStoreCacheNode, fromManagedObject: NSManagedObject): void;
    willRemoveCacheNodes(_: NSSet<NSAtomicStoreCacheNode>): void;
  }

  // interface
  class NSAtomicStoreCacheNode extends NSObject {
    objectID: NSManagedObjectID;
    propertyCache: NSMutableDictionary<string, any>;
    setPropertyCache(_: NSMutableDictionary<string, any>)
    static createWithObjectID(objectID: NSManagedObjectID): NSAtomicStoreCacheNode;
  }

  // interface
  class NSAttributeDescription extends NSPropertyDescription {
    allowsExternalBinaryDataStorage: boolean;
    setAllowsExternalBinaryDataStorage(_: boolean)
    attributeType: NSAttributeType;
    setAttributeType(_: NSAttributeType)
    attributeValueClassName: string;
    setAttributeValueClassName(_: string)
    defaultValue: any;
    setDefaultValue(_: any)
    preservesValueInHistoryOnDeletion: boolean;
    setPreservesValueInHistoryOnDeletion(_: boolean)
    valueTransformerName: string;
    setValueTransformerName(_: string)
  }

  // interface
  class NSBatchDeleteRequest extends NSPersistentStoreRequest {
    fetchRequest: NSFetchRequest<any>;
    resultType: NSBatchDeleteRequestResultType;
    setResultType(_: NSBatchDeleteRequestResultType)
    static createWithFetchRequest(fetchRequest: NSFetchRequest<any>): NSBatchDeleteRequest;
    static createWithObjectIDs(objectIDs: NSManagedObjectID[]): NSBatchDeleteRequest;
  }

  // interface
  class NSBatchDeleteResult extends NSPersistentStoreResult {
    result: any;
    resultType: NSBatchDeleteRequestResultType;
  }

  // interface
  class NSBatchInsertRequest extends NSPersistentStoreRequest {
    static batchInsertRequestWithEntityNameObjects(_: string, objects: Map<string, any>[]): NSBatchInsertRequest;
    entity: NSEntityDescription;
    entityName: string;
    objectsToInsert: Map<string, any>[];
    setObjectsToInsert(_: Map<string, any>[])
    resultType: NSBatchInsertRequestResultType;
    setResultType(_: NSBatchInsertRequestResultType)
    static createWithEntityObjects(entity: NSEntityDescription, objects: Map<string, any>[]): NSBatchInsertRequest;
    static createWithEntityNameObjects(entityName: string, objects: Map<string, any>[]): NSBatchInsertRequest;
  }

  // interface
  class NSBatchInsertResult extends NSPersistentStoreResult {
    result: any;
    resultType: NSBatchInsertRequestResultType;
  }

  // interface
  class NSBatchUpdateRequest extends NSPersistentStoreRequest {
    static batchUpdateRequestWithEntityName(_: string): NSBatchUpdateRequest;
    entity: NSEntityDescription;
    entityName: string;
    includesSubentities: boolean;
    setIncludesSubentities(_: boolean)
    predicate: NSPredicate;
    setPredicate(_: NSPredicate)
    propertiesToUpdate: Map<any, any>;
    setPropertiesToUpdate(_: Map<any, any>)
    resultType: NSBatchUpdateRequestResultType;
    setResultType(_: NSBatchUpdateRequestResultType)
    static createWithEntity(entity: NSEntityDescription): NSBatchUpdateRequest;
    static createWithEntityName(entityName: string): NSBatchUpdateRequest;
  }

  // interface
  class NSBatchUpdateResult extends NSPersistentStoreResult {
    result: any;
    resultType: NSBatchUpdateRequestResultType;
  }

  // interface
  class NSConstraintConflict extends NSObject {
    conflictingObjects: NSManagedObject[];
    conflictingSnapshots: Map<any, any>[];
    constraint: string[];
    constraintValues: Map<string, any>;
    databaseObject: NSManagedObject;
    databaseSnapshot: Map<string, any>;
    static createWithConstraintDatabaseObjectDatabaseSnapshotConflictingObjectsConflictingSnapshots(constraint: string[], databaseObject?: NSManagedObject, databaseSnapshot?: Map<any, any>, conflictingObjects?: NSManagedObject[], conflictingSnapshots?: any[]): NSConstraintConflict;
  }

  // interface
  class NSCoreDataCoreSpotlightDelegate extends NSObject {
    attributeSetForObject(_: NSManagedObject): CSSearchableItemAttributeSet;
    domainIdentifier(): string;
    indexName(): string;
    static createWithForStoreWithDescriptionModel(forStoreWithDescription: NSPersistentStoreDescription, model: NSManagedObjectModel): NSCoreDataCoreSpotlightDelegate;
    searchableIndexWithReindexAllSearchableItemsWithAcknowledgementHandler(_: CSSearchableIndex, reindexAllSearchableItemsWithAcknowledgementHandler: () => void): void;
    searchableIndexWithReindexSearchableItemsWithIdentifiersAcknowledgementHandler(_: CSSearchableIndex, reindexSearchableItemsWithIdentifiers: string[], acknowledgementHandler: () => void): void;
  }

  // interface
  class NSDerivedAttributeDescription extends NSAttributeDescription {
    derivationExpression: NSExpression;
    setDerivationExpression(_: NSExpression)
  }

  // interface
  class NSEntityDescription extends NSObject /* implements NSCoding, NSCopying, NSFastEnumeration */ {
    static entityForNameInManagedObjectContext(forEntityName: string, in_: NSManagedObjectContext): NSEntityDescription;
    static insertNewObjectForEntityForNameInManagedObjectContext(forEntityName: string, into: NSManagedObjectContext): NSManagedObject;
    isAbstract: boolean;
    setAbstract(_: boolean)
    attributesByName: Map<string, NSAttributeDescription>;
    coreSpotlightDisplayNameExpression: NSExpression;
    setCoreSpotlightDisplayNameExpression(_: NSExpression)
    indexes: NSFetchIndexDescription[];
    setIndexes(_: NSFetchIndexDescription[])
    managedObjectClassName: string;
    setManagedObjectClassName(_: string)
    managedObjectModel: NSManagedObjectModel;
    name: string;
    setName(_: string)
    properties: NSPropertyDescription[];
    setProperties(_: NSPropertyDescription[])
    propertiesByName: Map<string, NSPropertyDescription>;
    relationshipsByName: Map<string, NSRelationshipDescription>;
    renamingIdentifier: string;
    setRenamingIdentifier(_: string)
    subentities: NSEntityDescription[];
    setSubentities(_: NSEntityDescription[])
    subentitiesByName: Map<string, NSEntityDescription>;
    superentity: NSEntityDescription;
    uniquenessConstraints: any[][];
    setUniquenessConstraints(_: any[][])
    userInfo: Map<any, any>;
    setUserInfo(_: Map<any, any>)
    versionHash: NSData;
    versionHashModifier: string;
    setVersionHashModifier(_: string)
    isKindOfEntity(entity: NSEntityDescription): boolean;
    relationshipsWithDestinationEntity(forDestination: NSEntityDescription): NSRelationshipDescription[];
  }

  // interface
  class NSEntityMapping extends NSObject {
    attributeMappings: NSPropertyMapping[];
    setAttributeMappings(_: NSPropertyMapping[])
    destinationEntityName: string;
    setDestinationEntityName(_: string)
    destinationEntityVersionHash: NSData;
    setDestinationEntityVersionHash(_: NSData)
    entityMigrationPolicyClassName: string;
    setEntityMigrationPolicyClassName(_: string)
    mappingType: NSEntityMappingType;
    setMappingType(_: NSEntityMappingType)
    name: string;
    setName(_: string)
    relationshipMappings: NSPropertyMapping[];
    setRelationshipMappings(_: NSPropertyMapping[])
    sourceEntityName: string;
    setSourceEntityName(_: string)
    sourceEntityVersionHash: NSData;
    setSourceEntityVersionHash(_: NSData)
    sourceExpression: NSExpression;
    setSourceExpression(_: NSExpression)
    userInfo: Map<any, any>;
    setUserInfo(_: Map<any, any>)
  }

  // interface
  class NSEntityMigrationPolicy extends NSObject {
    beginEntityMappingManagerError(_: NSEntityMapping, with_: NSMigrationManager): boolean;
    createDestinationInstancesForSourceInstanceEntityMappingManagerError(forSource: NSManagedObject, in_: NSEntityMapping, manager: NSMigrationManager): boolean;
    createRelationshipsForDestinationInstanceEntityMappingManagerError(forDestination: NSManagedObject, in_: NSEntityMapping, manager: NSMigrationManager): boolean;
    endEntityMappingManagerError(manager: NSEntityMapping, error: NSMigrationManager): boolean;
    endInstanceCreationForEntityMappingManagerError(forMapping: NSEntityMapping, manager: NSMigrationManager): boolean;
    endRelationshipCreationForEntityMappingManagerError(forMapping: NSEntityMapping, manager: NSMigrationManager): boolean;
    performCustomValidationForEntityMappingManagerError(forMapping: NSEntityMapping, manager: NSMigrationManager): boolean;
  }

  // interface
  class NSExpressionDescription extends NSPropertyDescription {
    expression: NSExpression;
    setExpression(_: NSExpression)
    expressionResultType: NSAttributeType;
    setExpressionResultType(_: NSAttributeType)
  }

  // interface
  class NSFetchIndexDescription extends NSObject /* implements NSCoding */ {
    elements: NSFetchIndexElementDescription[];
    setElements(_: NSFetchIndexElementDescription[])
    entity: NSEntityDescription;
    name: string;
    setName(_: string)
    partialIndexPredicate: NSPredicate;
    setPartialIndexPredicate(_: NSPredicate)
    static createWithNameElements(name: string, elements?: NSFetchIndexElementDescription[]): NSFetchIndexDescription;
  }

  // interface
  class NSFetchIndexElementDescription extends NSObject /* implements NSCoding */ {
    isAscending: boolean;
    setAscending(_: boolean)
    collationType: NSFetchIndexElementType;
    setCollationType(_: NSFetchIndexElementType)
    indexDescription: NSFetchIndexDescription;
    property: NSPropertyDescription;
    propertyName: string;
    static createWithPropertyCollationType(property: NSPropertyDescription, collationType: NSFetchIndexElementType): NSFetchIndexElementDescription;
  }

  // interface
  class NSFetchRequest<ResultType> extends NSPersistentStoreRequest /* implements NSCoding */ {
    static fetchRequestWithEntityName<ResultType>(_: string): NSFetchRequest<ResultType>;
    entity: NSEntityDescription;
    setEntity(_: NSEntityDescription)
    entityName: string;
    fetchBatchSize: number;
    setFetchBatchSize(_: number)
    fetchLimit: number;
    setFetchLimit(_: number)
    fetchOffset: number;
    setFetchOffset(_: number)
    havingPredicate: NSPredicate;
    setHavingPredicate(_: NSPredicate)
    includesPendingChanges: boolean;
    setIncludesPendingChanges(_: boolean)
    includesPropertyValues: boolean;
    setIncludesPropertyValues(_: boolean)
    includesSubentities: boolean;
    setIncludesSubentities(_: boolean)
    predicate: NSPredicate;
    setPredicate(_: NSPredicate)
    propertiesToFetch: any[];
    setPropertiesToFetch(_: any[])
    propertiesToGroupBy: any[];
    setPropertiesToGroupBy(_: any[])
    relationshipKeyPathsForPrefetching: string[];
    setRelationshipKeyPathsForPrefetching(_: string[])
    resultType: NSFetchRequestResultType;
    setResultType(_: NSFetchRequestResultType)
    returnsDistinctResults: boolean;
    setReturnsDistinctResults(_: boolean)
    returnsObjectsAsFaults: boolean;
    setReturnsObjectsAsFaults(_: boolean)
    shouldRefreshRefetchedObjects: boolean;
    setShouldRefreshRefetchedObjects(_: boolean)
    sortDescriptors: NSSortDescriptor[];
    setSortDescriptors(_: NSSortDescriptor[])
    execute(): ResultType[];
  }

  // interface
  class NSFetchRequestExpression extends NSExpression {
    static expressionForFetchContextCountOnly(_: NSExpression, context: NSExpression, countOnly: boolean): NSExpression;
    contextExpression: NSExpression;
    isCountOnlyRequest: boolean;
    requestExpression: NSExpression;
  }

  type NSFetchRequestResult = NSObject

  // interface
  class NSFetchedPropertyDescription extends NSPropertyDescription {
    fetchRequest: NSFetchRequest<any>;
    setFetchRequest(_: NSFetchRequest<any>)
  }

  // interface
  class NSFetchedResultsController<ResultType> extends NSObject {
    static deleteCacheWithName(_?: string): void;
    cacheName: string;
    delegate: NSFetchedResultsControllerDelegate;
    setDelegate(_: NSFetchedResultsControllerDelegate)
    fetchRequest: NSFetchRequest<ResultType>;
    fetchedObjects: ResultType[];
    managedObjectContext: NSManagedObjectContext;
    sectionIndexTitles: string[];
    sectionNameKeyPath: string;
    sections: NSFetchedResultsSectionInfo[];
    indexPathForObject(_: ResultType): NSIndexPath;
    objectAtIndexPath(_: NSIndexPath): ResultType;
    performFetch(): boolean;
    sectionForSectionIndexTitleAtIndex(_: string, atIndex: number): number;
    sectionIndexTitleForSectionName(_: string): string;
  }

  interface NSFetchedResultsControllerDelegate extends NSObject {
    // instance method
    controllerWithDidChangeContentWithDifference?(_: NSFetchedResultsController<any>, didChangeContentWithDifference: NSOrderedCollectionDifference<NSManagedObjectID>): void;
    // instance method
    controllerWithDidChangeContentWithSnapshot?(_: NSFetchedResultsController<any>, didChangeContentWithSnapshot: NSDiffableDataSourceSnapshotReference<string, NSManagedObjectID>): void;
    // instance method
    controllerDidChangeObjectAtIndexPathForChangeTypeNewIndexPath?(_: NSFetchedResultsController<any>, didChangeObject: any, atIndexPath?: NSIndexPath, forChangeType?: NSFetchedResultsChangeType, newIndexPath?: NSIndexPath): void;
    // instance method
    controllerDidChangeSectionAtIndexForChangeType?(_: NSFetchedResultsController<any>, didChangeSection: NSFetchedResultsSectionInfo, atIndex: number, forChangeType: NSFetchedResultsChangeType): void;
    // instance method
    controllerSectionIndexTitleForSectionName?(_: NSFetchedResultsController<any>, sectionIndexTitleForSectionName: string): string;
    // instance method
    controllerDidChangeContent?(_: NSFetchedResultsController<any>): void;
    // instance method
    controllerWillChangeContent?(_: NSFetchedResultsController<any>): void;
  }

  interface NSFetchedResultsSectionInfo {
    indexTitle: string;
    name: string;
    numberOfObjects: number;
    objects: any[];
  }

  // interface
  class NSIncrementalStore extends NSPersistentStore {
    static identifierForNewStoreAtURL(_: NSURL): any;
    executeRequestWithContextError(withContext: NSPersistentStoreRequest, error?: NSManagedObjectContext): any;
    managedObjectContextDidRegisterObjectsWithIDs(_: NSManagedObjectID[]): void;
    managedObjectContextDidUnregisterObjectsWithIDs(_: NSManagedObjectID[]): void;
    newObjectIDForEntityReferenceObject(for_: NSEntityDescription, referenceObject: any): NSManagedObjectID;
    newValueForRelationshipForObjectWithIDWithContextError(forObjectWithID: NSRelationshipDescription, withContext: NSManagedObjectID, error?: NSManagedObjectContext): any;
    newValuesForObjectWithIDWithContextError(withContext: NSManagedObjectID, error: NSManagedObjectContext): NSIncrementalStoreNode;
    obtainPermanentIDsForObjectsError(error: NSManagedObject[]): NSManagedObjectID[];
    referenceObjectForObjectID(_: NSManagedObjectID): any;
  }

  // interface
  class NSIncrementalStoreNode extends NSObject {
    objectID: NSManagedObjectID;
    static createWithObjectIDWithValuesVersion(objectID: NSManagedObjectID, withValues: Map<string, any>, version: number): NSIncrementalStoreNode;
    updateWithValuesVersion(_: Map<string, any>, version: number): void;
    valueForPropertyDescription(_: NSPropertyDescription): any;
  }

  // interface
  class NSManagedObject extends NSObject /* implements NSFetchRequestResult */ {
    static entity(): NSEntityDescription;
    static fetchRequest(): NSFetchRequest<any>;
    isDeleted: boolean;
    entity: NSEntityDescription;
    isFault: boolean;
    faultingState: number;
    hasChanges: boolean;
    hasPersistentChangedValues: boolean;
    isInserted: boolean;
    managedObjectContext: NSManagedObjectContext;
    objectID: NSManagedObjectID;
    isUpdated: boolean;
    static contextShouldIgnoreUnmodeledPropertyChanges: boolean;
    awakeFromFetch(): void;
    awakeFromInsert(): void;
    awakeFromSnapshotEvents(_: NSSnapshotEventType): void;
    changedValues(): Map<string, any>;
    changedValuesForCurrentEvent(): Map<string, any>;
    committedValuesForKeys(_?: string[]): Map<string, any>;
    didAccessValueForKey(_?: string): void;
    didSave(): void;
    didTurnIntoFault(): void;
    hasFaultForRelationshipNamed(_: string): boolean;
    static createWithContext(context: NSManagedObjectContext): NSManagedObject;
    static createWithEntityInsertIntoManagedObjectContext(entity: NSEntityDescription, insertIntoManagedObjectContext?: NSManagedObjectContext): NSManagedObject;
    objectIDsForRelationshipNamed(_: string): NSManagedObjectID[];
    prepareForDeletion(): void;
    primitiveValueForKey(_: string): any;
    setObservationInfo(_?: any): void;
    setPrimitiveValueForKey(_?: any, forKey?: string): void;
    validateForDelete(): boolean;
    validateForInsert(): boolean;
    validateForUpdate(): boolean;
    willAccessValueForKey(_?: string): void;
    willSave(): void;
    willTurnIntoFault(): void;
  }

  // interface
  class NSManagedObjectContext extends NSObject /* implements NSCoding, NSLocking, NSEditor, NSEditorRegistration */ {
    static mergeChangesFromRemoteContextSaveIntoContexts(_: Map<any, any>, intoContexts: NSManagedObjectContext[]): void;
    automaticallyMergesChangesFromParent: boolean;
    setAutomaticallyMergesChangesFromParent(_: boolean)
    concurrencyType: NSManagedObjectContextConcurrencyType;
    deletedObjects: NSSet<NSManagedObject>;
    hasChanges: boolean;
    insertedObjects: NSSet<NSManagedObject>;
    mergePolicy: any;
    setMergePolicy(_: any)
    name: string;
    setName(_: string)
    parentContext: NSManagedObjectContext;
    setParentContext(_: NSManagedObjectContext)
    persistentStoreCoordinator: NSPersistentStoreCoordinator;
    setPersistentStoreCoordinator(_: NSPersistentStoreCoordinator)
    propagatesDeletesAtEndOfEvent: boolean;
    setPropagatesDeletesAtEndOfEvent(_: boolean)
    queryGenerationToken: NSQueryGenerationToken;
    registeredObjects: NSSet<NSManagedObject>;
    retainsRegisteredObjects: boolean;
    setRetainsRegisteredObjects(_: boolean)
    shouldDeleteInaccessibleFaults: boolean;
    setShouldDeleteInaccessibleFaults(_: boolean)
    stalenessInterval: number;
    setStalenessInterval(_: number)
    transactionAuthor: string;
    setTransactionAuthor(_: string)
    undoManager: UndoManager;
    setUndoManager(_: UndoManager)
    updatedObjects: NSSet<NSManagedObject>;
    userInfo: NSMutableDictionary<any, any>;
    assignObjectToPersistentStore(_: any, toPersistentStore: NSPersistentStore): void;
    countForFetchRequestError(error: NSFetchRequest<any>): number;
    deleteObject(_: NSManagedObject): void;
    detectConflictsForObject(_: NSManagedObject): void;
    executeFetchRequestError(_: NSFetchRequest<any>): any[];
    executeRequestError(error: NSPersistentStoreRequest): NSPersistentStoreResult;
    existingObjectWithIDError(error: NSManagedObjectID): NSManagedObject;
    static createWithConcurrencyType(concurrencyType: NSManagedObjectContextConcurrencyType): NSManagedObjectContext;
    insertObject(_: NSManagedObject): void;
    mergeChangesFromContextDidSaveNotification(_: NSNotification): void;
    objectRegisteredForID(for_: NSManagedObjectID): NSManagedObject;
    objectWithID(_: NSManagedObjectID): NSManagedObject;
    obtainPermanentIDsForObjectsError(error: NSManagedObject[]): boolean;
    performBlock(_: () => void): void;
    performAndWait(_: () => void): void;
    processPendingChanges(): void;
    redo(): void;
    refreshAllObjects(): void;
    refreshObjectMergeChanges(_: NSManagedObject, mergeChanges: boolean): void;
    reset(): void;
    rollback(): void;
    save(): boolean;
    setQueryGenerationFromTokenError(error?: NSQueryGenerationToken): boolean;
    shouldHandleInaccessibleFaultForObjectIDTriggeredByProperty(_: NSManagedObject, forObjectID: NSManagedObjectID, triggeredByProperty?: NSPropertyDescription): boolean;
    undo(): void;
  }

  // interface
  class NSManagedObjectID extends NSObject /* implements NSCopying, NSFetchRequestResult */ {
    entity: NSEntityDescription;
    persistentStore: NSPersistentStore;
    isTemporaryID: boolean;
    URIRepresentation(): NSURL;
  }

  // interface
  class NSManagedObjectModel extends NSObject /* implements NSCoding, NSCopying, NSFastEnumeration */ {
    static mergedModelFromBundles(_?: Bundle[]): NSManagedObjectModel;
    static mergedModelFromBundlesForStoreMetadata(_?: Bundle[], forStoreMetadata?: Map<string, any>): NSManagedObjectModel;
    static modelByMergingModels(_?: NSManagedObjectModel[]): NSManagedObjectModel;
    static modelByMergingModelsForStoreMetadata(_: NSManagedObjectModel[], forStoreMetadata: Map<string, any>): NSManagedObjectModel;
    configurations: string[];
    entities: NSEntityDescription[];
    setEntities(_: NSEntityDescription[])
    entitiesByName: Map<string, NSEntityDescription>;
    entityVersionHashesByName: Map<string, Data>;
    fetchRequestTemplatesByName: Map<string, NSFetchRequest<any>>;
    localizationDictionary: Map<string, string>;
    setLocalizationDictionary(_: Map<string, string>)
    versionIdentifiers: NSSet<any>;
    setVersionIdentifiers(_: NSSet<any>)
    entitiesForConfiguration(forConfigurationName?: string): NSEntityDescription[];
    fetchRequestFromTemplateWithNameSubstitutionVariables(_: string, substitutionVariables: Map<string, any>): NSFetchRequest<any>;
    fetchRequestTemplateForName(_: string): NSFetchRequest<any>;
    static createWithContentsOfURL(contentsOfURL: NSURL): NSManagedObjectModel;
    isConfigurationCompatibleWithStoreMetadata(withName?: string, compatibleWithStoreMetadata?: Map<string, any>): boolean;
    setEntitiesForConfiguration(_: NSEntityDescription[], forConfigurationName: string): void;
    setFetchRequestTemplateForName(_?: NSFetchRequest<any>, forName?: string): void;
  }

  // interface
  class NSMappingModel extends NSObject {
    static inferredMappingModelForSourceModelDestinationModelError(destinationModel: NSManagedObjectModel, error: NSManagedObjectModel): NSMappingModel;
    static mappingModelFromBundlesForSourceModelDestinationModel(_?: Bundle[], forSourceModel?: NSManagedObjectModel, destinationModel?: NSManagedObjectModel): NSMappingModel;
    entityMappings: NSEntityMapping[];
    setEntityMappings(_: NSEntityMapping[])
    entityMappingsByName: Map<string, NSEntityMapping>;
    static createWithContentsOfURL(contentsOfURL?: NSURL): NSMappingModel;
  }

  // interface
  class NSMergeConflict extends NSObject {
    cachedSnapshot: Map<string, any>;
    newVersionNumber: number;
    objectSnapshot: Map<string, any>;
    oldVersionNumber: number;
    persistedSnapshot: Map<string, any>;
    sourceObject: NSManagedObject;
    static createWithSourceNewVersionOldVersionCachedSnapshotPersistedSnapshot(source: NSManagedObject, newVersion: number, oldVersion: number, cachedSnapshot?: Map<string, any>, persistedSnapshot?: Map<string, any>): NSMergeConflict;
  }

  // interface
  class NSMergePolicy extends NSObject {
    mergeType: NSMergePolicyType;
    static errorMergePolicy: NSMergePolicy;
    static mergeByPropertyObjectTrumpMergePolicy: NSMergePolicy;
    static mergeByPropertyStoreTrumpMergePolicy: NSMergePolicy;
    static overwriteMergePolicy: NSMergePolicy;
    static rollbackMergePolicy: NSMergePolicy;
    static createWithMergeType(mergeType: NSMergePolicyType): NSMergePolicy;
    resolveConflictsError(mergeConflicts: any[]): boolean;
    resolveConstraintConflictsError(constraintConflicts: NSConstraintConflict[]): boolean;
    resolveOptimisticLockingVersionConflictsError(optimisticLockingConflicts: NSMergeConflict[]): boolean;
  }

  // interface
  class NSMigrationManager extends NSObject {
    currentEntityMapping: NSEntityMapping;
    destinationContext: NSManagedObjectContext;
    destinationModel: NSManagedObjectModel;
    mappingModel: NSMappingModel;
    migrationProgress: number;
    sourceContext: NSManagedObjectContext;
    sourceModel: NSManagedObjectModel;
    userInfo: Map<any, any>;
    setUserInfo(_: Map<any, any>)
    usesStoreSpecificMigrationManager: boolean;
    setUsesStoreSpecificMigrationManager(_: boolean)
    associateSourceInstanceWithDestinationInstanceForEntityMapping(sourceInstance: NSManagedObject, withDestinationInstance: NSManagedObject, for_: NSEntityMapping): void;
    cancelMigrationWithError(_: NSError): void;
    destinationEntityForEntityMapping(_: NSEntityMapping): NSEntityDescription;
    destinationInstancesForEntityMappingNamedSourceInstances(forEntityMappingName: string, sourceInstances?: NSManagedObject[]): NSManagedObject[];
    static createWithSourceModelDestinationModel(sourceModel: NSManagedObjectModel, destinationModel: NSManagedObjectModel): NSMigrationManager;
    migrateStoreFromURLTypeOptionsWithMappingModelToDestinationURLDestinationTypeDestinationOptionsError(from: NSURL, sourceType: string, options?: Map<any, any>, with_?: NSMappingModel, toDestinationURL?: NSURL, destinationType?: string, destinationOptions?: Map<any, any>): boolean;
    reset(): void;
    sourceEntityForEntityMapping(_: NSEntityMapping): NSEntityDescription;
    sourceInstancesForEntityMappingNamedDestinationInstances(forEntityMappingName: string, destinationInstances?: NSManagedObject[]): NSManagedObject[];
  }

  // interface
  class NSPersistentCloudKitContainer extends NSPersistentContainer {
    initializeCloudKitSchemaWithOptionsError(error: NSPersistentCloudKitContainerSchemaInitializationOptions): boolean;
    recordForManagedObjectID(_: NSManagedObjectID): CKRecord;
    recordIDForManagedObjectID(_: NSManagedObjectID): ID;
    recordIDsForManagedObjectIDs(_: NSManagedObjectID[]): Map<NSManagedObjectID, ID>;
    recordsForManagedObjectIDs(_: NSManagedObjectID[]): Map<NSManagedObjectID, CKRecord>;
  }

  // interface
  class NSPersistentCloudKitContainerOptions extends NSObject {
    containerIdentifier: string;
    static createWithContainerIdentifier(containerIdentifier: string): NSPersistentCloudKitContainerOptions;
  }

  // interface
  class NSPersistentContainer extends NSObject {
    static defaultDirectoryURL(): NSURL;
    static persistentContainerWithName(_: string): NSPersistentContainer;
    static persistentContainerWithNameManagedObjectModel(_: string, managedObjectModel: NSManagedObjectModel): NSPersistentContainer;
    managedObjectModel: NSManagedObjectModel;
    name: string;
    persistentStoreCoordinator: NSPersistentStoreCoordinator;
    persistentStoreDescriptions: NSPersistentStoreDescription[];
    setPersistentStoreDescriptions(_: NSPersistentStoreDescription[])
    viewContext: NSManagedObjectContext;
    static createWithName(name: string): NSPersistentContainer;
    static createWithNameManagedObjectModel(name: string, managedObjectModel: NSManagedObjectModel): NSPersistentContainer;
    loadPersistentStoresWithCompletionHandler(_?: (p1: NSPersistentStoreDescription, p2: NSError) => void): void;
    newBackgroundContext(): NSManagedObjectContext;
    performBackgroundTask(_: (p1: NSManagedObjectContext) => void): void;
  }

  // interface
  class NSPersistentHistoryChange extends NSObject /* implements NSCopying */ {
    static entityDescriptionWithContext(_: NSManagedObjectContext): NSEntityDescription;
    changeID: number;
    changeType: NSPersistentHistoryChangeType;
    changedObjectID: NSManagedObjectID;
    tombstone: Map<any, any>;
    transaction: NSPersistentHistoryTransaction;
    updatedProperties: NSSet<NSPropertyDescription>;
    static entityDescription: NSEntityDescription;
    static fetchRequest: NSFetchRequest<any>;
  }

  // interface
  class NSPersistentHistoryChangeRequest extends NSPersistentStoreRequest {
    static deleteHistoryBeforeDate(_: Date): NSPersistentHistoryChangeRequest;
    static deleteHistoryBeforeToken(_?: NSPersistentHistoryToken): NSPersistentHistoryChangeRequest;
    static deleteHistoryBeforeTransaction(_?: NSPersistentHistoryTransaction): NSPersistentHistoryChangeRequest;
    static fetchHistoryAfterDate(_: Date): NSPersistentHistoryChangeRequest;
    static fetchHistoryAfterToken(_?: NSPersistentHistoryToken): NSPersistentHistoryChangeRequest;
    static fetchHistoryAfterTransaction(_?: NSPersistentHistoryTransaction): NSPersistentHistoryChangeRequest;
    static fetchHistoryWithFetchRequest(_: NSFetchRequest<any>): NSPersistentHistoryChangeRequest;
    fetchRequest: NSFetchRequest<any>;
    setFetchRequest(_: NSFetchRequest<any>)
    resultType: NSPersistentHistoryResultType;
    setResultType(_: NSPersistentHistoryResultType)
    token: NSPersistentHistoryToken;
  }

  // interface
  class NSPersistentHistoryResult extends NSPersistentStoreResult {
    result: any;
    resultType: NSPersistentHistoryResultType;
  }

  // interface
  class NSPersistentHistoryToken extends NSObject /* implements NSCopying, NSSecureCoding */ {
  }

  // interface
  class NSPersistentHistoryTransaction extends NSObject /* implements NSCopying */ {
    static entityDescriptionWithContext(_: NSManagedObjectContext): NSEntityDescription;
    author: string;
    bundleID: string;
    changes: NSPersistentHistoryChange[];
    contextName: string;
    processID: string;
    storeID: string;
    timestamp: Date;
    token: NSPersistentHistoryToken;
    transactionNumber: number;
    static entityDescription: NSEntityDescription;
    static fetchRequest: NSFetchRequest<any>;
    objectIDNotification(): NSNotification;
  }

  // interface
  class NSPersistentStore extends NSObject {
    static metadataForPersistentStoreWithURLError(error: NSURL): Map<string, any>;
    static migrationManagerClass(): typeof NSObject;
    static setMetadataForPersistentStoreWithURLError(_?: Map<string, any>, forPersistentStoreAt?: NSURL): boolean;
    URL: NSURL;
    setURL(_: NSURL)
    configurationName: string;
    coreSpotlightExporter: NSCoreDataCoreSpotlightDelegate;
    identifier: string;
    setIdentifier(_: string)
    metadata: Map<string, any>;
    setMetadata(_: Map<string, any>)
    options: Map<any, any>;
    persistentStoreCoordinator: NSPersistentStoreCoordinator;
    isReadOnly: boolean;
    setReadOnly(_: boolean)
    type: string;
    didAddToPersistentStoreCoordinator(_: NSPersistentStoreCoordinator): void;
    static createWithPersistentStoreCoordinatorConfigurationNameUrlOptions(persistentStoreCoordinator?: NSPersistentStoreCoordinator, configurationName?: string, URL?: NSURL, options?: Map<any, any>): NSPersistentStore;
    loadMetadata(): boolean;
    willRemoveFromPersistentStoreCoordinator(_?: NSPersistentStoreCoordinator): void;
  }

  // interface
  class NSPersistentStoreAsynchronousResult extends NSPersistentStoreResult {
    managedObjectContext: NSManagedObjectContext;
    operationError: NSError;
    progress: Progress;
    cancel(): void;
  }

  // interface
  class NSPersistentStoreCoordinator extends NSObject /* implements NSLocking */ {
    static elementsDerivedFromExternalRecordURL(fromExternalRecordAt: NSURL): Map<any, any>;
    static metadataForPersistentStoreOfTypeUrlOptionsError(ofType: string, at: NSURL, options?: Map<any, any>): Map<string, any>;
    static registerStoreClassForStoreType(_?: typeof NSObject, forStoreType?: string): void;
    static setMetadataForPersistentStoreOfTypeUrlOptionsError(_?: Map<string, any>, forPersistentStoreOfType?: string, at?: NSURL, options?: Map<any, any>): boolean;
    managedObjectModel: NSManagedObjectModel;
    name: string;
    setName(_: string)
    persistentStores: NSPersistentStore[];
    static registeredStoreTypes: Map<string, NSValue>;
    URLForPersistentStore(_: NSPersistentStore): NSURL;
    addPersistentStoreWithDescriptionWithCompletionHandler(_: NSPersistentStoreDescription, completionHandler?: (p1: NSPersistentStoreDescription, p2: NSError) => void): void;
    addPersistentStoreWithTypeConfigurationUrlOptionsError(ofType: string, configurationName?: string, at?: NSURL, options?: Map<any, any>): NSPersistentStore;
    currentPersistentHistoryTokenFromStores(_?: any[]): NSPersistentHistoryToken;
    destroyPersistentStoreAtURLWithTypeOptionsError(at: NSURL, ofType: string, options?: Map<any, any>): boolean;
    executeRequestWithContextError(withContext: NSPersistentStoreRequest, error: NSManagedObjectContext): any;
    importStoreWithIdentifierFromExternalRecordsDirectoryToURLOptionsWithTypeError(withIdentifier?: string, fromExternalRecordsDirectoryAt?: NSURL, to?: NSURL, options?: Map<any, any>, ofType?: string): NSPersistentStore;
    static createWithManagedObjectModel(managedObjectModel: NSManagedObjectModel): NSPersistentStoreCoordinator;
    managedObjectIDForURIRepresentation(_: NSURL): NSManagedObjectID;
    metadataForPersistentStore(_: NSPersistentStore): Map<string, any>;
    migratePersistentStoreToURLOptionsWithTypeError(toURL: NSPersistentStore, options: NSURL, withType?: Map<any, any>, error?: string): NSPersistentStore;
    performBlock(_: () => void): void;
    performAndWait(_: () => void): void;
    persistentStoreForURL(_: NSURL): NSPersistentStore;
    removePersistentStoreError(_: NSPersistentStore): boolean;
    replacePersistentStoreAtURLDestinationOptionsWithPersistentStoreFromURLSourceOptionsStoreTypeError(at: NSURL, destinationOptions?: Map<any, any>, withPersistentStoreFrom?: NSURL, sourceOptions?: Map<any, any>, ofType?: string): boolean;
    setMetadataForPersistentStore(_?: Map<string, any>, forPersistentStore?: NSPersistentStore): void;
    setURLForPersistentStore(_: NSURL, forPersistentStore: NSPersistentStore): boolean;
  }

  // interface
  class NSPersistentStoreDescription extends NSObject /* implements NSCopying */ {
    static persistentStoreDescriptionWithURL(_: NSURL): NSPersistentStoreDescription;
    URL: NSURL;
    setURL(_: NSURL)
    cloudKitContainerOptions: NSPersistentCloudKitContainerOptions;
    setCloudKitContainerOptions(_: NSPersistentCloudKitContainerOptions)
    configuration: string;
    setConfiguration(_: string)
    options: Map<string, NSObject>;
    isReadOnly: boolean;
    setReadOnly(_: boolean)
    shouldAddStoreAsynchronously: boolean;
    setShouldAddStoreAsynchronously(_: boolean)
    shouldInferMappingModelAutomatically: boolean;
    setShouldInferMappingModelAutomatically(_: boolean)
    shouldMigrateStoreAutomatically: boolean;
    setShouldMigrateStoreAutomatically(_: boolean)
    sqlitePragmas: Map<string, NSObject>;
    timeout: number;
    setTimeout(_: number)
    type: string;
    setType(_: string)
    static createWithUrl(URL: NSURL): NSPersistentStoreDescription;
    setOptionForKey(_?: NSObject, forKey?: string): void;
    setValueForPragmaNamed(_?: NSObject, forPragmaNamed?: string): void;
  }

  // interface
  class NSPersistentStoreRequest extends NSObject /* implements NSCopying */ {
    affectedStores: NSPersistentStore[];
    setAffectedStores(_: NSPersistentStore[])
    requestType: NSPersistentStoreRequestType;
  }

  // interface
  class NSPersistentStoreResult extends NSObject {
  }

  // interface
  class NSPropertyDescription extends NSObject /* implements NSCoding, NSCopying */ {
    entity: NSEntityDescription;
    isIndexedBySpotlight: boolean;
    setIndexedBySpotlight(_: boolean)
    name: string;
    setName(_: string)
    isOptional: boolean;
    setOptional(_: boolean)
    renamingIdentifier: string;
    setRenamingIdentifier(_: string)
    isTransient: boolean;
    setTransient(_: boolean)
    userInfo: Map<any, any>;
    setUserInfo(_: Map<any, any>)
    validationPredicates: NSPredicate[];
    validationWarnings: any[];
    versionHash: NSData;
    versionHashModifier: string;
    setVersionHashModifier(_: string)
    setValidationPredicatesWithValidationWarnings(_?: NSPredicate[], withValidationWarnings?: string[]): void;
  }

  // interface
  class NSPropertyMapping extends NSObject {
    name: string;
    setName(_: string)
    userInfo: Map<any, any>;
    setUserInfo(_: Map<any, any>)
    valueExpression: NSExpression;
    setValueExpression(_: NSExpression)
  }

  // interface
  class NSQueryGenerationToken extends NSObject /* implements NSCopying, NSSecureCoding */ {
    static currentQueryGenerationToken: NSQueryGenerationToken;
  }

  // interface
  class NSRelationshipDescription extends NSPropertyDescription {
    deleteRule: NSDeleteRule;
    setDeleteRule(_: NSDeleteRule)
    destinationEntity: NSEntityDescription;
    setDestinationEntity(_: NSEntityDescription)
    inverseRelationship: NSRelationshipDescription;
    setInverseRelationship(_: NSRelationshipDescription)
    maxCount: number;
    setMaxCount(_: number)
    minCount: number;
    setMinCount(_: number)
    isOrdered: boolean;
    setOrdered(_: boolean)
    isToMany: boolean;
  }

  // interface
  class NSSaveChangesRequest extends NSPersistentStoreRequest {
    deletedObjects: NSSet<NSManagedObject>;
    insertedObjects: NSSet<NSManagedObject>;
    lockedObjects: NSSet<NSManagedObject>;
    updatedObjects: NSSet<NSManagedObject>;
    static createWithInsertedObjectsUpdatedObjectsDeletedObjectsLockedObjects(insertedObjects?: NSSet<NSManagedObject>, updatedObjects?: NSSet<NSManagedObject>, deletedObjects?: NSSet<NSManagedObject>, lockedObjects?: NSSet<NSManagedObject>): NSSaveChangesRequest;
  }

  // export function CFAbsoluteTimeGetCurrent(): number;

  // export function CFAllocatorAllocate(allocator: any, size: number, hint: number): any;

  // export function CFAllocatorCreate(allocator: any, context: CFAllocatorContext): any;

  // export function CFAllocatorDeallocate(allocator: any, ptr: any): void;

  // export function CFAllocatorGetContext(allocator: any, context: CFAllocatorContext): void;

  // export function CFAllocatorGetDefault(): any;

  // export function CFAllocatorGetPreferredSizeForSize(allocator: any, size: number, hint: number): number;

  // export function CFAllocatorGetTypeID(): number;

  // export function CFAllocatorReallocate(allocator: any, ptr: any, newsize: number, hint: number): any;

  // export function CFAllocatorSetDefault(allocator: any): void;

  // export function CFArrayAppendArray(theArray: any[], otherArray: any[], otherRange: CFRange): void;

  // export function CFArrayAppendValue(theArray: any[], value: any): void;

  // export function CFArrayApplyFunction(theArray: any[], range: CFRange, applier: (p1: any, p2: any) => void, context: any): void;

  // export function CFArrayBSearchValues(theArray: any[], range: CFRange, value: any, comparator: (p1: any, p2: any, p3: any) => CFComparisonResult, context: any): number;

  // export function CFArrayContainsValue(theArray: any[], range: CFRange, value: any): boolean;

  // export function CFArrayCreate(allocator: any, values: any, numValues: number, callBacks: CFArrayCallBacks): any[];

  // export function CFArrayCreateCopy(allocator: any, theArray: any[]): any[];

  // export function CFArrayCreateMutable(allocator: any, capacity: number, callBacks: CFArrayCallBacks): any[];

  // export function CFArrayCreateMutableCopy(allocator: any, capacity: number, theArray: any[]): any[];

  // export function CFArrayExchangeValuesAtIndices(theArray: any[], idx1: number, idx2: number): void;

  // export function CFArrayGetCount(theArray: any[]): number;

  // export function CFArrayGetCountOfValue(theArray: any[], range: CFRange, value: any): number;

  // export function CFArrayGetFirstIndexOfValue(theArray: any[], range: CFRange, value: any): number;

  // export function CFArrayGetLastIndexOfValue(theArray: any[], range: CFRange, value: any): number;

  // export function CFArrayGetTypeID(): number;

  // export function CFArrayGetValueAtIndex(theArray: any[], idx: number): any;

  // export function CFArrayGetValues(theArray: any[], range: CFRange, values: any): void;

  // export function CFArrayInsertValueAtIndex(theArray: any[], idx: number, value: any): void;

  // export function CFArrayRemoveAllValues(theArray: any[]): void;

  // export function CFArrayRemoveValueAtIndex(theArray: any[], idx: number): void;

  // export function CFArrayReplaceValues(theArray: any[], range: CFRange, newValues: any, newCount: number): void;

  // export function CFArraySetValueAtIndex(theArray: any[], idx: number, value: any): void;

  // export function CFArraySortValues(theArray: any[], range: CFRange, comparator: (p1: any, p2: any, p3: any) => CFComparisonResult, context: any): void;

  // export function CFAttributedStringBeginEditing(aStr: NSAttributedString): void;

  // export function CFAttributedStringCreate(alloc: any, str: string, attributes: Map<any, any>): NSAttributedString;

  // export function CFAttributedStringCreateCopy(alloc: any, aStr: NSAttributedString): NSAttributedString;

  // export function CFAttributedStringCreateMutable(alloc: any, maxLength: number): NSAttributedString;

  // export function CFAttributedStringCreateMutableCopy(alloc: any, maxLength: number, aStr: NSAttributedString): NSAttributedString;

  // export function CFAttributedStringCreateWithSubstring(alloc: any, aStr: NSAttributedString, range: CFRange): NSAttributedString;

  // export function CFAttributedStringEndEditing(aStr: NSAttributedString): void;

  // export function CFAttributedStringGetAttribute(aStr: NSAttributedString, loc: number, attrName: string, effectiveRange: CFRange): any;

  // export function CFAttributedStringGetAttributeAndLongestEffectiveRange(aStr: NSAttributedString, loc: number, attrName: string, inRange: CFRange, longestEffectiveRange: CFRange): any;

  // export function CFAttributedStringGetAttributes(aStr: NSAttributedString, loc: number, effectiveRange: CFRange): Map<any, any>;

  // export function CFAttributedStringGetAttributesAndLongestEffectiveRange(aStr: NSAttributedString, loc: number, inRange: CFRange, longestEffectiveRange: CFRange): Map<any, any>;

  // export function CFAttributedStringGetLength(aStr: NSAttributedString): number;

  // export function CFAttributedStringGetMutableString(aStr: NSAttributedString): string;

  // export function CFAttributedStringGetString(aStr: NSAttributedString): string;

  // export function CFAttributedStringGetTypeID(): number;

  // export function CFAttributedStringRemoveAttribute(aStr: NSAttributedString, range: CFRange, attrName: string): void;

  // export function CFAttributedStringReplaceAttributedString(aStr: NSAttributedString, range: CFRange, replacement: NSAttributedString): void;

  // export function CFAttributedStringReplaceString(aStr: NSAttributedString, range: CFRange, replacement: string): void;

  // export function CFAttributedStringSetAttribute(aStr: NSAttributedString, range: CFRange, attrName: string, value: any): void;

  // export function CFAttributedStringSetAttributes(aStr: NSAttributedString, range: CFRange, replacement: Map<any, any>, clearOtherAttributes: boolean): void;

  // export function CFAutorelease(arg: any): any;

  // export function CFBagAddValue(theBag: any, value: any): void;

  // export function CFBagApplyFunction(theBag: any, applier: (p1: any, p2: any) => void, context: any): void;

  // export function CFBagContainsValue(theBag: any, value: any): boolean;

  // export function CFBagCreate(allocator: any, values: any, numValues: number, callBacks: CFBagCallBacks): any;

  // export function CFBagCreateCopy(allocator: any, theBag: any): any;

  // export function CFBagCreateMutable(allocator: any, capacity: number, callBacks: CFBagCallBacks): any;

  // export function CFBagCreateMutableCopy(allocator: any, capacity: number, theBag: any): any;

  // export function CFBagGetCount(theBag: any): number;

  // export function CFBagGetCountOfValue(theBag: any, value: any): number;

  // export function CFBagGetTypeID(): number;

  // export function CFBagGetValue(theBag: any, value: any): any;

  // export function CFBagGetValueIfPresent(theBag: any, candidate: any, value: any): boolean;

  // export function CFBagGetValues(theBag: any, values: any): void;

  // export function CFBagRemoveAllValues(theBag: any): void;

  // export function CFBagRemoveValue(theBag: any, value: any): void;

  // export function CFBagReplaceValue(theBag: any, value: any): void;

  // export function CFBagSetValue(theBag: any, value: any): void;

  // export function CFBinaryHeapAddValue(heap: any, value: any): void;

  // export function CFBinaryHeapApplyFunction(heap: any, applier: (p1: any, p2: any) => void, context: any): void;

  // export function CFBinaryHeapContainsValue(heap: any, value: any): boolean;

  // export function CFBinaryHeapCreate(allocator: any, capacity: number, callBacks: CFBinaryHeapCallBacks, compareContext: CFBinaryHeapCompareContext): any;

  // export function CFBinaryHeapCreateCopy(allocator: any, capacity: number, heap: any): any;

  // export function CFBinaryHeapGetCount(heap: any): number;

  // export function CFBinaryHeapGetCountOfValue(heap: any, value: any): number;

  // export function CFBinaryHeapGetMinimum(heap: any): any;

  // export function CFBinaryHeapGetMinimumIfPresent(heap: any, value: any): boolean;

  // export function CFBinaryHeapGetTypeID(): number;

  // export function CFBinaryHeapGetValues(heap: any, values: any): void;

  // export function CFBinaryHeapRemoveAllValues(heap: any): void;

  // export function CFBinaryHeapRemoveMinimumValue(heap: any): void;

  // export function CFBitVectorContainsBit(bv: any, range: CFRange, value: number): boolean;

  // export function CFBitVectorCreate(allocator: any, bytes: string | any, numBits: number): any;

  // export function CFBitVectorCreateCopy(allocator: any, bv: any): any;

  // export function CFBitVectorCreateMutable(allocator: any, capacity: number): any;

  // export function CFBitVectorCreateMutableCopy(allocator: any, capacity: number, bv: any): any;

  // export function CFBitVectorFlipBitAtIndex(bv: any, idx: number): void;

  // export function CFBitVectorFlipBits(bv: any, range: CFRange): void;

  // export function CFBitVectorGetBitAtIndex(bv: any, idx: number): number;

  // export function CFBitVectorGetBits(bv: any, range: CFRange, bytes: string | any): void;

  // export function CFBitVectorGetCount(bv: any): number;

  // export function CFBitVectorGetCountOfBit(bv: any, range: CFRange, value: number): number;

  // export function CFBitVectorGetFirstIndexOfBit(bv: any, range: CFRange, value: number): number;

  // export function CFBitVectorGetLastIndexOfBit(bv: any, range: CFRange, value: number): number;

  // export function CFBitVectorGetTypeID(): number;

  // export function CFBitVectorSetAllBits(bv: any, value: number): void;

  // export function CFBitVectorSetBitAtIndex(bv: any, idx: number, value: number): void;

  // export function CFBitVectorSetBits(bv: any, range: CFRange, value: number): void;

  // export function CFBitVectorSetCount(bv: any, count: number): void;

  // export function CFBooleanGetTypeID(): number;

  // export function CFBooleanGetValue(boolean: number): boolean;

  // export function CFBundleCopyAuxiliaryExecutableURL(bundle: any, executableName: string): NSURL;

  // export function CFBundleCopyBuiltInPlugInsURL(bundle: any): NSURL;

  // export function CFBundleCopyBundleLocalizations(bundle: any): any[];

  // export function CFBundleCopyBundleURL(bundle: any): NSURL;

  // export function CFBundleCopyExecutableArchitectures(bundle: any): any[];

  // export function CFBundleCopyExecutableArchitecturesForURL(url: NSURL): any[];

  // export function CFBundleCopyExecutableURL(bundle: any): NSURL;

  // export function CFBundleCopyInfoDictionaryForURL(url: NSURL): Map<any, any>;

  // export function CFBundleCopyInfoDictionaryInDirectory(bundleURL: NSURL): Map<any, any>;

  // export function CFBundleCopyLocalizationsForPreferences(locArray: any[], prefArray: any[]): any[];

  // export function CFBundleCopyLocalizationsForURL(url: NSURL): any[];

  // export function CFBundleCopyLocalizedString(bundle: any, key: string, value: string, tableName: string): string;

  // export function CFBundleCopyPreferredLocalizationsFromArray(locArray: any[]): any[];

  // export function CFBundleCopyPrivateFrameworksURL(bundle: any): NSURL;

  // export function CFBundleCopyResourceURL(bundle: any, resourceName: string, resourceType: string, subDirName: string): NSURL;

  // export function CFBundleCopyResourceURLForLocalization(bundle: any, resourceName: string, resourceType: string, subDirName: string, localizationName: string): NSURL;

  // export function CFBundleCopyResourceURLInDirectory(bundleURL: NSURL, resourceName: string, resourceType: string, subDirName: string): NSURL;

  // export function CFBundleCopyResourceURLsOfType(bundle: any, resourceType: string, subDirName: string): any[];

  // export function CFBundleCopyResourceURLsOfTypeForLocalization(bundle: any, resourceType: string, subDirName: string, localizationName: string): any[];

  // export function CFBundleCopyResourceURLsOfTypeInDirectory(bundleURL: NSURL, resourceType: string, subDirName: string): any[];

  // export function CFBundleCopyResourcesDirectoryURL(bundle: any): NSURL;

  // export function CFBundleCopySharedFrameworksURL(bundle: any): NSURL;

  // export function CFBundleCopySharedSupportURL(bundle: any): NSURL;

  // export function CFBundleCopySupportFilesDirectoryURL(bundle: any): NSURL;

  // export function CFBundleCreate(allocator: any, bundleURL: NSURL): any;

  // export function CFBundleCreateBundlesFromDirectory(allocator: any, directoryURL: NSURL, bundleType: string): any[];

  // export function CFBundleGetAllBundles(): any[];

  // export function CFBundleGetBundleWithIdentifier(bundleID: string): any;

  // export function CFBundleGetDataPointerForName(bundle: any, symbolName: string): any;

  // export function CFBundleGetDataPointersForNames(bundle: any, symbolNames: any[], stbl: any): void;

  // export function CFBundleGetDevelopmentRegion(bundle: any): string;

  // export function CFBundleGetFunctionPointerForName(bundle: any, functionName: string): any;

  // export function CFBundleGetFunctionPointersForNames(bundle: any, functionNames: any[], ftbl: any): void;

  // export function CFBundleGetIdentifier(bundle: any): string;

  // export function CFBundleGetInfoDictionary(bundle: any): Map<any, any>;

  // export function CFBundleGetLocalInfoDictionary(bundle: any): Map<any, any>;

  // export function CFBundleGetMainBundle(): any;

  // export function CFBundleGetPackageInfo(bundle: any, packageType: number, packageCreator: number): void;

  // export function CFBundleGetPackageInfoInDirectory(url: NSURL, packageType: number, packageCreator: number): boolean;

  // export function CFBundleGetPlugIn(bundle: any): any;

  // export function CFBundleGetTypeID(): number;

  // export function CFBundleGetValueForInfoDictionaryKey(bundle: any, key: string): any;

  // export function CFBundleGetVersionNumber(bundle: any): number;

  // export function CFBundleIsExecutableLoaded(bundle: any): boolean;

  // export function CFBundleLoadExecutable(bundle: any): boolean;

  // export function CFBundleLoadExecutableAndReturnError(bundle: any, error: Error): boolean;

  // export function CFBundlePreflightExecutable(bundle: any, error: Error): boolean;

  // export function CFBundleUnloadExecutable(bundle: any): void;

  // export function CFCalendarCopyCurrent(): NSCalendar;

  // export function CFCalendarCopyLocale(calendar: NSCalendar): NSLocale;

  // export function CFCalendarCopyTimeZone(calendar: NSCalendar): NSTimeZone;

  // export function CFCalendarCreateWithIdentifier(allocator: any, identifier: any): NSCalendar;

  // export function CFCalendarGetFirstWeekday(calendar: NSCalendar): number;

  // export function CFCalendarGetIdentifier(calendar: NSCalendar): any;

  // export function CFCalendarGetMaximumRangeOfUnit(calendar: NSCalendar, unit: CFCalendarUnit): CFRange;

  // export function CFCalendarGetMinimumDaysInFirstWeek(calendar: NSCalendar): number;

  // export function CFCalendarGetMinimumRangeOfUnit(calendar: NSCalendar, unit: CFCalendarUnit): CFRange;

  // export function CFCalendarGetOrdinalityOfUnit(calendar: NSCalendar, smallerUnit: CFCalendarUnit, biggerUnit: CFCalendarUnit, at: number): number;

  // export function CFCalendarGetRangeOfUnit(calendar: NSCalendar, smallerUnit: CFCalendarUnit, biggerUnit: CFCalendarUnit, at: number): CFRange;

  // export function CFCalendarGetTimeRangeOfUnit(calendar: NSCalendar, unit: CFCalendarUnit, at: number, startp: number, tip: number): boolean;

  // export function CFCalendarGetTypeID(): number;

  // export function CFCalendarSetFirstWeekday(calendar: NSCalendar, wkdy: number): void;

  // export function CFCalendarSetLocale(calendar: NSCalendar, locale: NSLocale): void;

  // export function CFCalendarSetMinimumDaysInFirstWeek(calendar: NSCalendar, mwd: number): void;

  // export function CFCalendarSetTimeZone(calendar: NSCalendar, tz: NSTimeZone): void;

  // export function CFCharacterSetAddCharactersInRange(theSet: NSCharacterSet, theRange: CFRange): void;

  // export function CFCharacterSetAddCharactersInString(theSet: NSCharacterSet, theString: string): void;

  // export function CFCharacterSetCreateBitmapRepresentation(alloc: any, theSet: NSCharacterSet): NSData;

  // export function CFCharacterSetCreateCopy(alloc: any, theSet: NSCharacterSet): NSCharacterSet;

  // export function CFCharacterSetCreateInvertedSet(alloc: any, theSet: NSCharacterSet): NSCharacterSet;

  // export function CFCharacterSetCreateMutable(alloc: any): NSCharacterSet;

  // export function CFCharacterSetCreateMutableCopy(alloc: any, theSet: NSCharacterSet): NSCharacterSet;

  // export function CFCharacterSetCreateWithBitmapRepresentation(alloc: any, theData: NSData): NSCharacterSet;

  // export function CFCharacterSetCreateWithCharactersInRange(alloc: any, theRange: CFRange): NSCharacterSet;

  // export function CFCharacterSetCreateWithCharactersInString(alloc: any, theString: string): NSCharacterSet;

  // export function CFCharacterSetGetPredefined(theSetIdentifier: CFCharacterSetPredefinedSet): NSCharacterSet;

  // export function CFCharacterSetGetTypeID(): number;

  // export function CFCharacterSetHasMemberInPlane(theSet: NSCharacterSet, thePlane: number): boolean;

  // export function CFCharacterSetIntersect(theSet: NSCharacterSet, theOtherSet: NSCharacterSet): void;

  // export function CFCharacterSetInvert(theSet: NSCharacterSet): void;

  // export function CFCharacterSetIsCharacterMember(theSet: NSCharacterSet, theChar: number): boolean;

  // export function CFCharacterSetIsLongCharacterMember(theSet: NSCharacterSet, theChar: number): boolean;

  // export function CFCharacterSetIsSupersetOfSet(theSet: NSCharacterSet, theOtherset: NSCharacterSet): boolean;

  // export function CFCharacterSetRemoveCharactersInRange(theSet: NSCharacterSet, theRange: CFRange): void;

  // export function CFCharacterSetRemoveCharactersInString(theSet: NSCharacterSet, theString: string): void;

  // export function CFCharacterSetUnion(theSet: NSCharacterSet, theOtherSet: NSCharacterSet): void;

  // export function CFCopyDescription(cf: any): string;

  // export function CFCopyTypeIDDescription(type_id: number): string;

  // export function CFDataAppendBytes(theData: NSData, bytes: string | any, length: number): void;

  // export function CFDataCreate(allocator: any, bytes: string | any, length: number): NSData;

  // export function CFDataCreateCopy(allocator: any, theData: NSData): NSData;

  // export function CFDataCreateMutable(allocator: any, capacity: number): NSData;

  // export function CFDataCreateMutableCopy(allocator: any, capacity: number, theData: NSData): NSData;

  // export function CFDataCreateWithBytesNoCopy(allocator: any, bytes: string | any, length: number, bytesDeallocator: any): NSData;

  // export function CFDataDeleteBytes(theData: NSData, range: CFRange): void;

  // export function CFDataFind(theData: NSData, dataToFind: NSData, searchRange: CFRange, compareOptions: CFDataSearchFlags): CFRange;

  // export function CFDataGetBytePtr(theData: NSData): string;

  // export function CFDataGetBytes(theData: NSData, range: CFRange, buffer: string | any): void;

  // export function CFDataGetLength(theData: NSData): number;

  // export function CFDataGetMutableBytePtr(theData: NSData): string;

  // export function CFDataGetTypeID(): number;

  // export function CFDataIncreaseLength(theData: NSData, extraLength: number): void;

  // export function CFDataReplaceBytes(theData: NSData, range: CFRange, newBytes: string | any, newLength: number): void;

  // export function CFDataSetLength(theData: NSData, length: number): void;

  // export function CFDateCompare(theDate: Date, otherDate: Date, context: any): CFComparisonResult;

  // export function CFDateCreate(allocator: any, at: number): Date;

  // export function CFDateFormatterCopyProperty(formatter: any, key: any): any;

  // export function CFDateFormatterCreate(allocator: any, locale: NSLocale, dateStyle: CFDateFormatterStyle, timeStyle: CFDateFormatterStyle): any;

  // export function CFDateFormatterCreateDateFormatFromTemplate(allocator: any, tmplate: string, options: number, locale: NSLocale): string;

  // export function CFDateFormatterCreateDateFromString(allocator: any, formatter: any, string: string, rangep: CFRange): Date;

  // export function CFDateFormatterCreateISO8601Formatter(allocator: any, formatOptions: CFISO8601DateFormatOptions): any;

  // export function CFDateFormatterCreateStringWithAbsoluteTime(allocator: any, formatter: any, at: number): string;

  // export function CFDateFormatterCreateStringWithDate(allocator: any, formatter: any, date: Date): string;

  // export function CFDateFormatterGetAbsoluteTimeFromString(formatter: any, string: string, rangep: CFRange, atp: number): boolean;

  // export function CFDateFormatterGetDateStyle(formatter: any): CFDateFormatterStyle;

  // export function CFDateFormatterGetFormat(formatter: any): string;

  // export function CFDateFormatterGetLocale(formatter: any): NSLocale;

  // export function CFDateFormatterGetTimeStyle(formatter: any): CFDateFormatterStyle;

  // export function CFDateFormatterGetTypeID(): number;

  // export function CFDateFormatterSetFormat(formatter: any, formatString: string): void;

  // export function CFDateFormatterSetProperty(formatter: any, key: string, value: any): void;

  // export function CFDateGetAbsoluteTime(theDate: Date): number;

  // export function CFDateGetTimeIntervalSinceDate(theDate: Date, otherDate: Date): number;

  // export function CFDateGetTypeID(): number;

  // export function CFDictionaryAddValue(theDict: Map<any, any>, key: any, value: any): void;

  // export function CFDictionaryApplyFunction(theDict: Map<any, any>, applier: (p1: any, p2: any, p3: any) => void, context: any): void;

  // export function CFDictionaryContainsKey(theDict: Map<any, any>, key: any): boolean;

  // export function CFDictionaryContainsValue(theDict: Map<any, any>, value: any): boolean;

  // export function CFDictionaryCreate(allocator: any, keys: any, values: any, numValues: number, keyCallBacks: CFDictionaryKeyCallBacks, valueCallBacks: CFDictionaryValueCallBacks): Map<any, any>;

  // export function CFDictionaryCreateCopy(allocator: any, theDict: Map<any, any>): Map<any, any>;

  // export function CFDictionaryCreateMutable(allocator: any, capacity: number, keyCallBacks: CFDictionaryKeyCallBacks, valueCallBacks: CFDictionaryValueCallBacks): Map<any, any>;

  // export function CFDictionaryCreateMutableCopy(allocator: any, capacity: number, theDict: Map<any, any>): Map<any, any>;

  // export function CFDictionaryGetCount(theDict: Map<any, any>): number;

  // export function CFDictionaryGetCountOfKey(theDict: Map<any, any>, key: any): number;

  // export function CFDictionaryGetCountOfValue(theDict: Map<any, any>, value: any): number;

  // export function CFDictionaryGetKeysAndValues(theDict: Map<any, any>, keys: any, values: any): void;

  // export function CFDictionaryGetTypeID(): number;

  // export function CFDictionaryGetValue(theDict: Map<any, any>, key: any): any;

  // export function CFDictionaryGetValueIfPresent(theDict: Map<any, any>, key: any, value: any): boolean;

  // export function CFDictionaryRemoveAllValues(theDict: Map<any, any>): void;

  // export function CFDictionaryRemoveValue(theDict: Map<any, any>, key: any): void;

  // export function CFDictionaryReplaceValue(theDict: Map<any, any>, key: any, value: any): void;

  // export function CFDictionarySetValue(theDict: Map<any, any>, key: any, value: any): void;

  // export function CFEqual(cf1: any, cf2: any): boolean;

  // export function CFErrorCopyDescription(err: NSError): string;

  // export function CFErrorCopyFailureReason(err: NSError): string;

  // export function CFErrorCopyRecoverySuggestion(err: NSError): string;

  // export function CFErrorCopyUserInfo(err: NSError): Map<any, any>;

  // export function CFErrorCreate(allocator: any, domain: any, code: number, userInfo: Map<any, any>): NSError;

  // export function CFErrorCreateWithUserInfoKeysAndValues(allocator: any, domain: any, code: number, userInfoKeys: any, userInfoValues: any, numUserInfoValues: number): NSError;

  // export function CFErrorGetCode(err: NSError): number;

  // export function CFErrorGetDomain(err: NSError): any;

  // export function CFErrorGetTypeID(): number;

  // export function CFFileDescriptorCreate(allocator: any, fd: number, closeOnInvalidate: boolean, callout: (p1: any, p2: number, p3: any) => void, context: CFFileDescriptorContext): any;

  // export function CFFileDescriptorCreateRunLoopSource(allocator: any, f: any, order: number): any;

  // export function CFFileDescriptorDisableCallBacks(f: any, callBackTypes: number): void;

  // export function CFFileDescriptorEnableCallBacks(f: any, callBackTypes: number): void;

  // export function CFFileDescriptorGetContext(f: any, context: CFFileDescriptorContext): void;

  // export function CFFileDescriptorGetNativeDescriptor(f: any): number;

  // export function CFFileDescriptorGetTypeID(): number;

  // export function CFFileDescriptorInvalidate(f: any): void;

  // export function CFFileDescriptorIsValid(f: any): boolean;

  // export function CFFileSecurityClearProperties(fileSec: NSFileSecurity, clearPropertyMask: CFFileSecurityClearOptions): boolean;

  // export function CFFileSecurityCopyAccessControlList(fileSec: NSFileSecurity, accessControlList: any): boolean;

  // export function CFFileSecurityCopyGroupUUID(fileSec: NSFileSecurity, groupUUID: any): boolean;

  // export function CFFileSecurityCopyOwnerUUID(fileSec: NSFileSecurity, ownerUUID: any): boolean;

  // export function CFFileSecurityCreate(allocator: any): NSFileSecurity;

  // export function CFFileSecurityCreateCopy(allocator: any, fileSec: NSFileSecurity): NSFileSecurity;

  // export function CFFileSecurityGetGroup(fileSec: NSFileSecurity, group: number): boolean;

  // export function CFFileSecurityGetMode(fileSec: NSFileSecurity, mode: number): boolean;

  // export function CFFileSecurityGetOwner(fileSec: NSFileSecurity, owner: number): boolean;

  // export function CFFileSecurityGetTypeID(): number;

  // export function CFFileSecuritySetAccessControlList(fileSec: NSFileSecurity, accessControlList: any): boolean;

  // export function CFFileSecuritySetGroup(fileSec: NSFileSecurity, group: number): boolean;

  // export function CFFileSecuritySetGroupUUID(fileSec: NSFileSecurity, groupUUID: any): boolean;

  // export function CFFileSecuritySetMode(fileSec: NSFileSecurity, mode: number): boolean;

  // export function CFFileSecuritySetOwner(fileSec: NSFileSecurity, owner: number): boolean;

  // export function CFFileSecuritySetOwnerUUID(fileSec: NSFileSecurity, ownerUUID: any): boolean;

  // export function CFGetAllocator(cf: any): any;

  // export function CFGetRetainCount(cf: any): number;

  // export function CFGetTypeID(cf: any): number;

  // export function CFHash(cf: any): number;

  // export function CFLocaleCopyAvailableLocaleIdentifiers(): any[];

  // export function CFLocaleCopyCommonISOCurrencyCodes(): any[];

  // export function CFLocaleCopyCurrent(): NSLocale;

  // export function CFLocaleCopyDisplayNameForPropertyValue(displayLocale: NSLocale, key: any, value: string): string;

  // export function CFLocaleCopyISOCountryCodes(): any[];

  // export function CFLocaleCopyISOCurrencyCodes(): any[];

  // export function CFLocaleCopyISOLanguageCodes(): any[];

  // export function CFLocaleCopyPreferredLanguages(): any[];

  // export function CFLocaleCreate(allocator: any, localeIdentifier: any): NSLocale;

  // export function CFLocaleCreateCanonicalLanguageIdentifierFromString(allocator: any, localeIdentifier: string): any;

  // export function CFLocaleCreateCanonicalLocaleIdentifierFromScriptManagerCodes(allocator: any, lcode: number, rcode: number): any;

  // export function CFLocaleCreateCanonicalLocaleIdentifierFromString(allocator: any, localeIdentifier: string): any;

  // export function CFLocaleCreateComponentsFromLocaleIdentifier(allocator: any, localeID: any): Map<any, any>;

  // export function CFLocaleCreateCopy(allocator: any, locale: NSLocale): NSLocale;

  // export function CFLocaleCreateLocaleIdentifierFromComponents(allocator: any, dictionary: Map<any, any>): any;

  // export function CFLocaleCreateLocaleIdentifierFromWindowsLocaleCode(allocator: any, lcid: number): any;

  // export function CFLocaleGetIdentifier(locale: NSLocale): any;

  // export function CFLocaleGetLanguageCharacterDirection(isoLangCode: string): CFLocaleLanguageDirection;

  // export function CFLocaleGetLanguageLineDirection(isoLangCode: string): CFLocaleLanguageDirection;

  // export function CFLocaleGetSystem(): NSLocale;

  // export function CFLocaleGetTypeID(): number;

  // export function CFLocaleGetValue(locale: NSLocale, key: any): any;

  // export function CFLocaleGetWindowsLocaleCodeFromLocaleIdentifier(localeIdentifier: any): number;

  // export function CFMachPortCreate(allocator: any, callout: (p1: NSMachPort, p2: any, p3: number, p4: any) => void, context: CFMachPortContext, shouldFreeInfo: string | any): NSMachPort;

  // export function CFMachPortCreateRunLoopSource(allocator: any, port: NSMachPort, order: number): any;

  // export function CFMachPortCreateWithPort(allocator: any, portNum: number, callout: (p1: NSMachPort, p2: any, p3: number, p4: any) => void, context: CFMachPortContext, shouldFreeInfo: string | any): NSMachPort;

  // export function CFMachPortGetContext(port: NSMachPort, context: CFMachPortContext): void;

  // export function CFMachPortGetInvalidationCallBack(port: NSMachPort): (p1: NSMachPort, p2: any) => void;

  // export function CFMachPortGetPort(port: NSMachPort): number;

  // export function CFMachPortGetTypeID(): number;

  // export function CFMachPortInvalidate(port: NSMachPort): void;

  // export function CFMachPortIsValid(port: NSMachPort): boolean;

  // export function CFMachPortSetInvalidationCallBack(port: NSMachPort, callout: (p1: NSMachPort, p2: any) => void): void;

  // export function CFMakeCollectable(cf: any): any;

  // export function CFMessagePortCreateLocal(allocator: any, name: string, callout: (p1: MessagePort, p2: number, p3: NSData, p4: any) => NSData, context: CFMessagePortContext, shouldFreeInfo: string | any): MessagePort;

  // export function CFMessagePortCreateRemote(allocator: any, name: string): MessagePort;

  // export function CFMessagePortCreateRunLoopSource(allocator: any, local: MessagePort, order: number): any;

  // export function CFMessagePortGetContext(ms: MessagePort, context: CFMessagePortContext): void;

  // export function CFMessagePortGetInvalidationCallBack(ms: MessagePort): (p1: MessagePort, p2: any) => void;

  // export function CFMessagePortGetName(ms: MessagePort): string;

  // export function CFMessagePortGetTypeID(): number;

  // export function CFMessagePortInvalidate(ms: MessagePort): void;

  // export function CFMessagePortIsRemote(ms: MessagePort): boolean;

  // export function CFMessagePortIsValid(ms: MessagePort): boolean;

  // export function CFMessagePortSendRequest(remote: MessagePort, msgid: number, data: NSData, sendTimeout: number, rcvTimeout: number, replyMode: string, returnData: Data): number;

  // export function CFMessagePortSetDispatchQueue(ms: MessagePort, queue: NSObject): void;

  // export function CFMessagePortSetInvalidationCallBack(ms: MessagePort, callout: (p1: MessagePort, p2: any) => void): void;

  // export function CFMessagePortSetName(ms: MessagePort, newName: string): boolean;

  // export function CFNotificationCenterAddObserver(center: any, observer: any, callBack: (p1: any, p2: any, p3: any, p4: any, p5: Map<any, any>) => void, name: string, object_: any, suspensionBehavior: CFNotificationSuspensionBehavior): void;

  // export function CFNotificationCenterGetDarwinNotifyCenter(): any;

  // export function CFNotificationCenterGetDistributedCenter(): any;

  // export function CFNotificationCenterGetLocalCenter(): any;

  // export function CFNotificationCenterGetTypeID(): number;

  // export function CFNotificationCenterPostNotification(center: any, name: any, object_: any, userInfo: Map<any, any>, deliverImmediately: boolean): void;

  // export function CFNotificationCenterPostNotificationWithOptions(center: any, name: any, object_: any, userInfo: Map<any, any>, options: number): void;

  // export function CFNotificationCenterRemoveEveryObserver(center: any, observer: any): void;

  // export function CFNotificationCenterRemoveObserver(center: any, observer: any, name: any, object_: any): void;

  // export function CFNullGetTypeID(): number;

  // export function CFNumberCompare(number: number, otherNumber: number, context: any): CFComparisonResult;

  // export function CFNumberCreate(allocator: any, theType: CFNumberType, valuePtr: any): number;

  // export function CFNumberFormatterCopyProperty(formatter: any, key: any): any;

  // export function CFNumberFormatterCreate(allocator: any, locale: NSLocale, style: CFNumberFormatterStyle): any;

  // export function CFNumberFormatterCreateNumberFromString(allocator: any, formatter: any, string: string, rangep: CFRange, options: number): number;

  // export function CFNumberFormatterCreateStringWithNumber(allocator: any, formatter: any, number: number): string;

  // export function CFNumberFormatterCreateStringWithValue(allocator: any, formatter: any, numberType: CFNumberType, valuePtr: any): string;

  // export function CFNumberFormatterGetDecimalInfoForCurrencyCode(currencyCode: string, defaultFractionDigits: number, roundingIncrement: number): boolean;

  // export function CFNumberFormatterGetFormat(formatter: any): string;

  // export function CFNumberFormatterGetLocale(formatter: any): NSLocale;

  // export function CFNumberFormatterGetStyle(formatter: any): CFNumberFormatterStyle;

  // export function CFNumberFormatterGetTypeID(): number;

  // export function CFNumberFormatterGetValueFromString(formatter: any, string: string, rangep: CFRange, numberType: CFNumberType, valuePtr: any): boolean;

  // export function CFNumberFormatterSetFormat(formatter: any, formatString: string): void;

  // export function CFNumberFormatterSetProperty(formatter: any, key: any, value: any): void;

  // export function CFNumberGetByteSize(number: number): number;

  // export function CFNumberGetType(number: number): CFNumberType;

  // export function CFNumberGetTypeID(): number;

  // export function CFNumberGetValue(number: number, theType: CFNumberType, valuePtr: any): boolean;

  // export function CFNumberIsFloatType(number: number): boolean;

  // export function CFPlugInAddInstanceForFactory(factoryID: any): void;

  // export function CFPlugInCreate(allocator: any, plugInURL: NSURL): any;

  // export function CFPlugInFindFactoriesForPlugInType(typeUUID: any): any[];

  // export function CFPlugInFindFactoriesForPlugInTypeInPlugIn(typeUUID: any, plugIn: any): any[];

  // export function CFPlugInGetBundle(plugIn: any): any;

  // export function CFPlugInGetTypeID(): number;

  // export function CFPlugInInstanceCreate(allocator: any, factoryUUID: any, typeUUID: any): any;

  // export function CFPlugInInstanceCreateWithInstanceDataSize(allocator: any, instanceDataSize: number, deallocateInstanceFunction: (p1: any) => void, factoryName: string, getInterfaceFunction: (p1: any, p2: string, p3: any) => boolean): any;

  // export function CFPlugInInstanceGetFactoryName(instance: any): string;

  // export function CFPlugInInstanceGetInstanceData(instance: any): any;

  // export function CFPlugInInstanceGetInterfaceFunctionTable(instance: any, interfaceName: string, ftbl: any): boolean;

  // export function CFPlugInInstanceGetTypeID(): number;

  // export function CFPlugInIsLoadOnDemand(plugIn: any): boolean;

  // export function CFPlugInRegisterFactoryFunction(factoryUUID: any, func: (p1: any, p2: any) => any): boolean;

  // export function CFPlugInRegisterFactoryFunctionByName(factoryUUID: any, plugIn: any, functionName: string): boolean;

  // export function CFPlugInRegisterPlugInType(factoryUUID: any, typeUUID: any): boolean;

  // export function CFPlugInRemoveInstanceForFactory(factoryID: any): void;

  // export function CFPlugInSetLoadOnDemand(plugIn: any, flag: boolean): void;

  // export function CFPlugInUnregisterFactory(factoryUUID: any): boolean;

  // export function CFPlugInUnregisterPlugInType(factoryUUID: any, typeUUID: any): boolean;

  // export function CFPreferencesAddSuitePreferencesToApp(applicationID: string, suiteID: string): void;

  // export function CFPreferencesAppSynchronize(applicationID: string): boolean;

  // export function CFPreferencesAppValueIsForced(key: string, applicationID: string): boolean;

  // export function CFPreferencesCopyAppValue(key: string, applicationID: string): any;

  // export function CFPreferencesCopyKeyList(applicationID: string, userName: string, hostName: string): any[];

  // export function CFPreferencesCopyMultiple(keysToFetch: any[], applicationID: string, userName: string, hostName: string): Map<any, any>;

  // export function CFPreferencesCopyValue(key: string, applicationID: string, userName: string, hostName: string): any;

  // export function CFPreferencesGetAppBooleanValue(key: string, applicationID: string, keyExistsAndHasValidFormat: string | any): boolean;

  // export function CFPreferencesGetAppIntegerValue(key: string, applicationID: string, keyExistsAndHasValidFormat: string | any): number;

  // export function CFPreferencesRemoveSuitePreferencesFromApp(applicationID: string, suiteID: string): void;

  // export function CFPreferencesSetAppValue(key: string, value: any, applicationID: string): void;

  // export function CFPreferencesSetMultiple(keysToSet: Map<any, any>, keysToRemove: any[], applicationID: string, userName: string, hostName: string): void;

  // export function CFPreferencesSetValue(key: string, value: any, applicationID: string, userName: string, hostName: string): void;

  // export function CFPreferencesSynchronize(applicationID: string, userName: string, hostName: string): boolean;

  // export function CFPropertyListCreateData(allocator: any, propertyList: any, format: CFPropertyListFormat, options: number, error: Error): NSData;

  // export function CFPropertyListCreateDeepCopy(allocator: any, propertyList: any, mutabilityOption: number): any;

  // export function CFPropertyListCreateWithData(allocator: any, data: NSData, options: number, format: CFPropertyListFormat, error: Error): any;

  // export function CFPropertyListCreateWithStream(allocator: any, stream: InputStream, streamLength: number, options: number, format: CFPropertyListFormat, error: Error): any;

  // export function CFPropertyListIsValid(plist: any, format: CFPropertyListFormat): boolean;

  // export function CFPropertyListWrite(propertyList: any, stream: OutputStream, format: CFPropertyListFormat, options: number, error: Error): number;

  // export function CFReadStreamClose(stream: InputStream): void;

  // export function CFReadStreamCopyDispatchQueue(stream: InputStream): NSObject;

  // export function CFReadStreamCopyError(stream: InputStream): NSError;

  // export function CFReadStreamCopyProperty(stream: InputStream, propertyName: any): any;

  // export function CFReadStreamCreateWithBytesNoCopy(alloc: any, bytes: string | any, length: number, bytesDeallocator: any): InputStream;

  // export function CFReadStreamCreateWithFile(alloc: any, fileURL: NSURL): InputStream;

  // export function CFReadStreamGetBuffer(stream: InputStream, maxBytesToRead: number, numBytesRead: number): string;

  // export function CFReadStreamGetError(stream: InputStream): CFStreamError;

  // export function CFReadStreamGetStatus(stream: InputStream): CFStreamStatus;

  // export function CFReadStreamGetTypeID(): number;

  // export function CFReadStreamHasBytesAvailable(stream: InputStream): boolean;

  // export function CFReadStreamOpen(stream: InputStream): boolean;

  // export function CFReadStreamRead(stream: InputStream, buffer: string | any, bufferLength: number): number;

  // export function CFReadStreamScheduleWithRunLoop(stream: InputStream, runLoop: any, runLoopMode: any): void;

  // export function CFReadStreamSetClient(stream: InputStream, streamEvents: number, clientCB: (p1: InputStream, p2: CFStreamEventType, p3: any) => void, clientContext: CFStreamClientContext): boolean;

  // export function CFReadStreamSetDispatchQueue(stream: InputStream, q: NSObject): void;

  // export function CFReadStreamSetProperty(stream: InputStream, propertyName: any, propertyValue: any): boolean;

  // export function CFReadStreamUnscheduleFromRunLoop(stream: InputStream, runLoop: any, runLoopMode: any): void;

  // export function CFRelease(cf: any): void;

  // export function CFRetain(cf: any): any;

  // export function CFRunLoopAddCommonMode(rl: any, mode: any): void;

  // export function CFRunLoopAddObserver(rl: any, observer: any, mode: any): void;

  // export function CFRunLoopAddSource(rl: any, source: any, mode: any): void;

  // export function CFRunLoopAddTimer(rl: any, timer: Timer, mode: any): void;

  // export function CFRunLoopContainsObserver(rl: any, observer: any, mode: any): boolean;

  // export function CFRunLoopContainsSource(rl: any, source: any, mode: any): boolean;

  // export function CFRunLoopContainsTimer(rl: any, timer: Timer, mode: any): boolean;

  // export function CFRunLoopCopyAllModes(rl: any): any[];

  // export function CFRunLoopCopyCurrentMode(rl: any): any;

  // export function CFRunLoopGetCurrent(): any;

  // export function CFRunLoopGetMain(): any;

  // export function CFRunLoopGetNextTimerFireDate(rl: any, mode: any): number;

  // export function CFRunLoopGetTypeID(): number;

  // export function CFRunLoopIsWaiting(rl: any): boolean;

  // export function CFRunLoopObserverCreate(allocator: any, activities: number, repeats: boolean, order: number, callout: (p1: any, p2: CFRunLoopActivity, p3: any) => void, context: CFRunLoopObserverContext): any;

  // export function CFRunLoopObserverCreateWithHandler(allocator: any, activities: number, repeats: boolean, order: number, block: (p1: any, p2: CFRunLoopActivity) => void): any;

  // export function CFRunLoopObserverDoesRepeat(observer: any): boolean;

  // export function CFRunLoopObserverGetActivities(observer: any): number;

  // export function CFRunLoopObserverGetContext(observer: any, context: CFRunLoopObserverContext): void;

  // export function CFRunLoopObserverGetOrder(observer: any): number;

  // export function CFRunLoopObserverGetTypeID(): number;

  // export function CFRunLoopObserverInvalidate(observer: any): void;

  // export function CFRunLoopObserverIsValid(observer: any): boolean;

  // export function CFRunLoopPerformBlock(rl: any, mode: any, block: () => void): void;

  // export function CFRunLoopRemoveObserver(rl: any, observer: any, mode: any): void;

  // export function CFRunLoopRemoveSource(rl: any, source: any, mode: any): void;

  // export function CFRunLoopRemoveTimer(rl: any, timer: Timer, mode: any): void;

  // export function CFRunLoopRun(): void;

  // export function CFRunLoopRunInMode(mode: any, seconds: number, returnAfterSourceHandled: boolean): CFRunLoopRunResult;

  // export function CFRunLoopSourceCreate(allocator: any, order: number, context: CFRunLoopSourceContext): any;

  // export function CFRunLoopSourceGetContext(source: any, context: CFRunLoopSourceContext): void;

  // export function CFRunLoopSourceGetOrder(source: any): number;

  // export function CFRunLoopSourceGetTypeID(): number;

  // export function CFRunLoopSourceInvalidate(source: any): void;

  // export function CFRunLoopSourceIsValid(source: any): boolean;

  // export function CFRunLoopSourceSignal(source: any): void;

  // export function CFRunLoopStop(rl: any): void;

  // export function CFRunLoopTimerCreate(allocator: any, fireDate: number, interval: number, flags: number, order: number, callout: (p1: Timer, p2: any) => void, context: CFRunLoopTimerContext): Timer;

  // export function CFRunLoopTimerCreateWithHandler(allocator: any, fireDate: number, interval: number, flags: number, order: number, block: (p1: Timer) => void): Timer;

  // export function CFRunLoopTimerDoesRepeat(timer: Timer): boolean;

  // export function CFRunLoopTimerGetContext(timer: Timer, context: CFRunLoopTimerContext): void;

  // export function CFRunLoopTimerGetInterval(timer: Timer): number;

  // export function CFRunLoopTimerGetNextFireDate(timer: Timer): number;

  // export function CFRunLoopTimerGetOrder(timer: Timer): number;

  // export function CFRunLoopTimerGetTolerance(timer: Timer): number;

  // export function CFRunLoopTimerGetTypeID(): number;

  // export function CFRunLoopTimerInvalidate(timer: Timer): void;

  // export function CFRunLoopTimerIsValid(timer: Timer): boolean;

  // export function CFRunLoopTimerSetNextFireDate(timer: Timer, fireDate: number): void;

  // export function CFRunLoopTimerSetTolerance(timer: Timer, tolerance: number): void;

  // export function CFRunLoopWakeUp(rl: any): void;

  // export function CFSetAddValue(theSet: NSSet<any>, value: any): void;

  // export function CFSetApplyFunction(theSet: NSSet<any>, applier: (p1: any, p2: any) => void, context: any): void;

  // export function CFSetContainsValue(theSet: NSSet<any>, value: any): boolean;

  // export function CFSetCreate(allocator: any, values: any, numValues: number, callBacks: CFSetCallBacks): NSSet<any>;

  // export function CFSetCreateCopy(allocator: any, theSet: NSSet<any>): NSSet<any>;

  // export function CFSetCreateMutable(allocator: any, capacity: number, callBacks: CFSetCallBacks): NSSet<any>;

  // export function CFSetCreateMutableCopy(allocator: any, capacity: number, theSet: NSSet<any>): NSSet<any>;

  // export function CFSetGetCount(theSet: NSSet<any>): number;

  // export function CFSetGetCountOfValue(theSet: NSSet<any>, value: any): number;

  // export function CFSetGetTypeID(): number;

  // export function CFSetGetValue(theSet: NSSet<any>, value: any): any;

  // export function CFSetGetValueIfPresent(theSet: NSSet<any>, candidate: any, value: any): boolean;

  // export function CFSetGetValues(theSet: NSSet<any>, values: any): void;

  // export function CFSetRemoveAllValues(theSet: NSSet<any>): void;

  // export function CFSetRemoveValue(theSet: NSSet<any>, value: any): void;

  // export function CFSetReplaceValue(theSet: NSSet<any>, value: any): void;

  // export function CFSetSetValue(theSet: NSSet<any>, value: any): void;

  // export function CFShow(obj: any): void;

  // export function CFShowStr(str: string): void;

  // export function CFSocketConnectToAddress(s: any, address: NSData, timeout: number): CFSocketError;

  // export function CFSocketCopyAddress(s: any): NSData;

  // export function CFSocketCopyPeerAddress(s: any): NSData;

  // export function CFSocketCopyRegisteredSocketSignature(nameServerSignature: CFSocketSignature, timeout: number, name: string, signature: CFSocketSignature, nameServerAddress: Data): CFSocketError;

  // export function CFSocketCopyRegisteredValue(nameServerSignature: CFSocketSignature, timeout: number, name: string, value: any, nameServerAddress: Data): CFSocketError;

  // export function CFSocketCreate(allocator: any, protocolFamily: number, socketType: number, protocol: number, callBackTypes: number, callout: (p1: any, p2: CFSocketCallBackType, p3: NSData, p4: any, p5: any) => void, context: CFSocketContext): any;

  // export function CFSocketCreateConnectedToSocketSignature(allocator: any, signature: CFSocketSignature, callBackTypes: number, callout: (p1: any, p2: CFSocketCallBackType, p3: NSData, p4: any, p5: any) => void, context: CFSocketContext, timeout: number): any;

  // export function CFSocketCreateRunLoopSource(allocator: any, s: any, order: number): any;

  // export function CFSocketCreateWithNative(allocator: any, sock: number, callBackTypes: number, callout: (p1: any, p2: CFSocketCallBackType, p3: NSData, p4: any, p5: any) => void, context: CFSocketContext): any;

  // export function CFSocketCreateWithSocketSignature(allocator: any, signature: CFSocketSignature, callBackTypes: number, callout: (p1: any, p2: CFSocketCallBackType, p3: NSData, p4: any, p5: any) => void, context: CFSocketContext): any;

  // export function CFSocketDisableCallBacks(s: any, callBackTypes: number): void;

  // export function CFSocketEnableCallBacks(s: any, callBackTypes: number): void;

  // export function CFSocketGetContext(s: any, context: CFSocketContext): void;

  // export function CFSocketGetDefaultNameRegistryPortNumber(): number;

  // export function CFSocketGetNative(s: any): number;

  // export function CFSocketGetSocketFlags(s: any): number;

  // export function CFSocketGetTypeID(): number;

  // export function CFSocketInvalidate(s: any): void;

  // export function CFSocketIsValid(s: any): boolean;

  // export function CFSocketRegisterSocketSignature(nameServerSignature: CFSocketSignature, timeout: number, name: string, signature: CFSocketSignature): CFSocketError;

  // export function CFSocketRegisterValue(nameServerSignature: CFSocketSignature, timeout: number, name: string, value: any): CFSocketError;

  // export function CFSocketSendData(s: any, address: NSData, data: NSData, timeout: number): CFSocketError;

  // export function CFSocketSetAddress(s: any, address: NSData): CFSocketError;

  // export function CFSocketSetDefaultNameRegistryPortNumber(port: number): void;

  // export function CFSocketSetSocketFlags(s: any, flags: number): void;

  // export function CFSocketUnregister(nameServerSignature: CFSocketSignature, timeout: number, name: string): CFSocketError;

  // export function CFStreamCreateBoundPair(alloc: any, readStream: InputStream, writeStream: OutputStream, transferBufferSize: number): void;

  // export function CFStreamCreatePairWithPeerSocketSignature(alloc: any, signature: CFSocketSignature, readStream: InputStream, writeStream: OutputStream): void;

  // export function CFStreamCreatePairWithSocket(alloc: any, sock: number, readStream: InputStream, writeStream: OutputStream): void;

  // export function CFStreamCreatePairWithSocketToHost(alloc: any, host: string, port: number, readStream: InputStream, writeStream: OutputStream): void;

  // export function CFStringAppend(theString: string, appendedString: string): void;

  // export function CFStringAppendCString(theString: string, cStr: string | any, encoding: number): void;

  // export function CFStringAppendCharacters(theString: string, chars: number, numChars: number): void;

  // export function CFStringAppendPascalString(theString: string, pStr: string | any, encoding: number): void;

  // export function CFStringCapitalize(theString: string, locale: NSLocale): void;

  // export function CFStringCompare(theString1: string, theString2: string, compareOptions: CFStringCompareFlags): CFComparisonResult;

  // export function CFStringCompareWithOptions(theString1: string, theString2: string, rangeToCompare: CFRange, compareOptions: CFStringCompareFlags): CFComparisonResult;

  // export function CFStringCompareWithOptionsAndLocale(theString1: string, theString2: string, rangeToCompare: CFRange, compareOptions: CFStringCompareFlags, locale: NSLocale): CFComparisonResult;

  // export function CFStringConvertEncodingToIANACharSetName(encoding: number): string;

  // export function CFStringConvertEncodingToNSStringEncoding(encoding: number): number;

  // export function CFStringConvertEncodingToWindowsCodepage(encoding: number): number;

  // export function CFStringConvertIANACharSetNameToEncoding(theString: string): number;

  // export function CFStringConvertNSStringEncodingToEncoding(encoding: number): number;

  // export function CFStringConvertWindowsCodepageToEncoding(codepage: number): number;

  // export function CFStringCreateArrayBySeparatingStrings(alloc: any, theString: string, separatorString: string): any[];

  // export function CFStringCreateArrayWithFindResults(alloc: any, theString: string, stringToFind: string, rangeToSearch: CFRange, compareOptions: CFStringCompareFlags): any[];

  // export function CFStringCreateByCombiningStrings(alloc: any, theArray: any[], separatorString: string): string;

  // export function CFStringCreateCopy(alloc: any, theString: string): string;

  // export function CFStringCreateExternalRepresentation(alloc: any, theString: string, encoding: number, lossByte: number): NSData;

  // export function CFStringCreateFromExternalRepresentation(alloc: any, data: NSData, encoding: number): string;

  // export function CFStringCreateMutable(alloc: any, maxLength: number): string;

  // export function CFStringCreateMutableCopy(alloc: any, maxLength: number, theString: string): string;

  // export function CFStringCreateMutableWithExternalCharactersNoCopy(alloc: any, chars: number, numChars: number, capacity: number, externalCharactersAllocator: any): string;

  // export function CFStringCreateWithBytes(alloc: any, bytes: string | any, numBytes: number, encoding: number, isExternalRepresentation: boolean): string;

  // export function CFStringCreateWithBytesNoCopy(alloc: any, bytes: string | any, numBytes: number, encoding: number, isExternalRepresentation: boolean, contentsDeallocator: any): string;

  // export function CFStringCreateWithCString(alloc: any, cStr: string | any, encoding: number): string;

  // export function CFStringCreateWithCStringNoCopy(alloc: any, cStr: string | any, encoding: number, contentsDeallocator: any): string;

  // export function CFStringCreateWithCharacters(alloc: any, chars: number, numChars: number): string;

  // export function CFStringCreateWithCharactersNoCopy(alloc: any, chars: number, numChars: number, contentsDeallocator: any): string;

  // export function CFStringCreateWithFileSystemRepresentation(alloc: any, buffer: string | any): string;

  // export function CFStringCreateWithPascalString(alloc: any, pStr: string | any, encoding: number): string;

  // export function CFStringCreateWithPascalStringNoCopy(alloc: any, pStr: string | any, encoding: number, contentsDeallocator: any): string;

  // export function CFStringCreateWithSubstring(alloc: any, str: string, range: CFRange): string;

  // export function CFStringDelete(theString: string, range: CFRange): void;

  // export function CFStringFind(theString: string, stringToFind: string, compareOptions: CFStringCompareFlags): CFRange;

  // export function CFStringFindAndReplace(theString: string, stringToFind: string, replacementString: string, rangeToSearch: CFRange, compareOptions: CFStringCompareFlags): number;

  // export function CFStringFindCharacterFromSet(theString: string, theSet: NSCharacterSet, rangeToSearch: CFRange, searchOptions: CFStringCompareFlags, result: CFRange): boolean;

  // export function CFStringFindWithOptions(theString: string, stringToFind: string, rangeToSearch: CFRange, searchOptions: CFStringCompareFlags, result: CFRange): boolean;

  // export function CFStringFindWithOptionsAndLocale(theString: string, stringToFind: string, rangeToSearch: CFRange, searchOptions: CFStringCompareFlags, locale: NSLocale, result: CFRange): boolean;

  // export function CFStringFold(theString: string, theFlags: CFStringCompareFlags, theLocale: NSLocale): void;

  // export function CFStringGetBytes(theString: string, range: CFRange, encoding: number, lossByte: number, isExternalRepresentation: boolean, buffer: string | any, maxBufLen: number, usedBufLen: number): number;

  // export function CFStringGetCString(theString: string, buffer: string | any, bufferSize: number, encoding: number): boolean;

  // export function CFStringGetCStringPtr(theString: string, encoding: number): string;

  // export function CFStringGetCharacterAtIndex(theString: string, idx: number): number;

  // export function CFStringGetCharacters(theString: string, range: CFRange, buffer: number): void;

  // export function CFStringGetCharactersPtr(theString: string): number;

  // export function CFStringGetDoubleValue(str: string): number;

  // export function CFStringGetFastestEncoding(theString: string): number;

  // export function CFStringGetFileSystemRepresentation(string: string, buffer: string | any, maxBufLen: number): boolean;

  // export function CFStringGetHyphenationLocationBeforeIndex(string: string, location: number, limitRange: CFRange, options: number, locale: NSLocale, character: number): number;

  // export function CFStringGetIntValue(str: string): number;

  // export function CFStringGetLength(theString: string): number;

  // export function CFStringGetLineBounds(theString: string, range: CFRange, lineBeginIndex: number, lineEndIndex: number, contentsEndIndex: number): void;

  // export function CFStringGetListOfAvailableEncodings(): number;

  // export function CFStringGetMaximumSizeForEncoding(length: number, encoding: number): number;

  // export function CFStringGetMaximumSizeOfFileSystemRepresentation(string: string): number;

  // export function CFStringGetMostCompatibleMacStringEncoding(encoding: number): number;

  // export function CFStringGetNameOfEncoding(encoding: number): string;

  // export function CFStringGetParagraphBounds(string: string, range: CFRange, parBeginIndex: number, parEndIndex: number, contentsEndIndex: number): void;

  // export function CFStringGetPascalString(theString: string, buffer: string | any, bufferSize: number, encoding: number): boolean;

  // export function CFStringGetPascalStringPtr(theString: string, encoding: number): string;

  // export function CFStringGetRangeOfComposedCharactersAtIndex(theString: string, theIndex: number): CFRange;

  // export function CFStringGetSmallestEncoding(theString: string): number;

  // export function CFStringGetSystemEncoding(): number;

  // export function CFStringGetTypeID(): number;

  // export function CFStringHasPrefix(theString: string, prefix: string): boolean;

  // export function CFStringHasSuffix(theString: string, suffix: string): boolean;

  // export function CFStringInsert(str: string, idx: number, insertedStr: string): void;

  // export function CFStringIsEncodingAvailable(encoding: number): boolean;

  // export function CFStringIsHyphenationAvailableForLocale(locale: NSLocale): boolean;

  // export function CFStringLowercase(theString: string, locale: NSLocale): void;

  // export function CFStringNormalize(theString: string, theForm: CFStringNormalizationForm): void;

  // export function CFStringPad(theString: string, padString: string, length: number, indexIntoPad: number): void;

  // export function CFStringReplace(theString: string, range: CFRange, replacement: string): void;

  // export function CFStringReplaceAll(theString: string, replacement: string): void;

  // export function CFStringSetExternalCharactersNoCopy(theString: string, chars: number, length: number, capacity: number): void;

  // export function CFStringTokenizerAdvanceToNextToken(tokenizer: any): CFStringTokenizerTokenType;

  // export function CFStringTokenizerCopyBestStringLanguage(string: string, range: CFRange): string;

  // export function CFStringTokenizerCopyCurrentTokenAttribute(tokenizer: any, attribute: number): any;

  // export function CFStringTokenizerCreate(alloc: any, string: string, range: CFRange, options: number, locale: NSLocale): any;

  // export function CFStringTokenizerGetCurrentSubTokens(tokenizer: any, ranges: CFRange, maxRangeLength: number, derivedSubTokens: any[]): number;

  // export function CFStringTokenizerGetCurrentTokenRange(tokenizer: any): CFRange;

  // export function CFStringTokenizerGetTypeID(): number;

  // export function CFStringTokenizerGoToTokenAtIndex(tokenizer: any, index: number): CFStringTokenizerTokenType;

  // export function CFStringTokenizerSetString(tokenizer: any, string: string, range: CFRange): void;

  // export function CFStringTransform(string: string, range: CFRange, transform: string, reverse: boolean): boolean;

  // export function CFStringTrim(theString: string, trimString: string): void;

  // export function CFStringTrimWhitespace(theString: string): void;

  // export function CFStringUppercase(theString: string, locale: NSLocale): void;

  // export function CFTimeZoneCopyAbbreviation(tz: NSTimeZone, at: number): string;

  // export function CFTimeZoneCopyAbbreviationDictionary(): Map<any, any>;

  // export function CFTimeZoneCopyDefault(): NSTimeZone;

  // export function CFTimeZoneCopyKnownNames(): any[];

  // export function CFTimeZoneCopyLocalizedName(tz: NSTimeZone, style: CFTimeZoneNameStyle, locale: NSLocale): string;

  // export function CFTimeZoneCopySystem(): NSTimeZone;

  // export function CFTimeZoneCreate(allocator: any, name: string, data: NSData): NSTimeZone;

  // export function CFTimeZoneCreateWithName(allocator: any, name: string, tryAbbrev: boolean): NSTimeZone;

  // export function CFTimeZoneCreateWithTimeIntervalFromGMT(allocator: any, ti: number): NSTimeZone;

  // export function CFTimeZoneGetData(tz: NSTimeZone): NSData;

  // export function CFTimeZoneGetDaylightSavingTimeOffset(tz: NSTimeZone, at: number): number;

  // export function CFTimeZoneGetName(tz: NSTimeZone): string;

  // export function CFTimeZoneGetNextDaylightSavingTimeTransition(tz: NSTimeZone, at: number): number;

  // export function CFTimeZoneGetSecondsFromGMT(tz: NSTimeZone, at: number): number;

  // export function CFTimeZoneGetTypeID(): number;

  // export function CFTimeZoneIsDaylightSavingTime(tz: NSTimeZone, at: number): boolean;

  // export function CFTimeZoneResetSystem(): void;

  // export function CFTimeZoneSetAbbreviationDictionary(dict: Map<any, any>): void;

  // export function CFTimeZoneSetDefault(tz: NSTimeZone): void;

  // export function CFTreeAppendChild(tree: any, newChild: any): void;

  // export function CFTreeApplyFunctionToChildren(tree: any, applier: (p1: any, p2: any) => void, context: any): void;

  // export function CFTreeCreate(allocator: any, context: CFTreeContext): any;

  // export function CFTreeFindRoot(tree: any): any;

  // export function CFTreeGetChildAtIndex(tree: any, idx: number): any;

  // export function CFTreeGetChildCount(tree: any): number;

  // export function CFTreeGetChildren(tree: any, children: any): void;

  // export function CFTreeGetContext(tree: any, context: CFTreeContext): void;

  // export function CFTreeGetFirstChild(tree: any): any;

  // export function CFTreeGetNextSibling(tree: any): any;

  // export function CFTreeGetParent(tree: any): any;

  // export function CFTreeGetTypeID(): number;

  // export function CFTreeInsertSibling(tree: any, newSibling: any): void;

  // export function CFTreePrependChild(tree: any, newChild: any): void;

  // export function CFTreeRemove(tree: any): void;

  // export function CFTreeRemoveAllChildren(tree: any): void;

  // export function CFTreeSetContext(tree: any, context: CFTreeContext): void;

  // export function CFTreeSortChildren(tree: any, comparator: (p1: any, p2: any, p3: any) => CFComparisonResult, context: any): void;

  // export function CFURLCanBeDecomposed(anURL: NSURL): boolean;

  // export function CFURLClearResourcePropertyCache(url: NSURL): void;

  // export function CFURLClearResourcePropertyCacheForKey(url: NSURL, key: string): void;

  // export function CFURLCopyAbsoluteURL(relativeURL: NSURL): NSURL;

  // export function CFURLCopyFileSystemPath(anURL: NSURL, pathStyle: CFURLPathStyle): string;

  // export function CFURLCopyFragment(anURL: NSURL, charactersToLeaveEscaped: string): string;

  // export function CFURLCopyHostName(anURL: NSURL): string;

  // export function CFURLCopyLastPathComponent(url: NSURL): string;

  // export function CFURLCopyNetLocation(anURL: NSURL): string;

  // export function CFURLCopyPassword(anURL: NSURL): string;

  // export function CFURLCopyPath(anURL: NSURL): string;

  // export function CFURLCopyPathExtension(url: NSURL): string;

  // export function CFURLCopyQueryString(anURL: NSURL, charactersToLeaveEscaped: string): string;

  // export function CFURLCopyResourcePropertiesForKeys(url: NSURL, keys: any[], error: Error): Map<any, any>;

  // export function CFURLCopyResourcePropertyForKey(url: NSURL, key: string, propertyValueTypeRefPtr: any, error: Error): boolean;

  // export function CFURLCopyResourceSpecifier(anURL: NSURL): string;

  // export function CFURLCopyScheme(anURL: NSURL): string;

  // export function CFURLCopyStrictPath(anURL: NSURL, isAbsolute: string | any): string;

  // export function CFURLCopyUserName(anURL: NSURL): string;

  // export function CFURLCreateAbsoluteURLWithBytes(alloc: any, relativeURLBytes: string | any, length: number, encoding: number, baseURL: NSURL, useCompatibilityMode: boolean): NSURL;

  // export function CFURLCreateBookmarkData(allocator: any, url: NSURL, options: CFURLBookmarkCreationOptions, resourcePropertiesToInclude: any[], relativeToURL: NSURL, error: Error): NSData;

  // export function CFURLCreateBookmarkDataFromAliasRecord(allocatorRef: any, aliasRecordDataRef: NSData): NSData;

  // export function CFURLCreateBookmarkDataFromFile(allocator: any, fileURL: NSURL, errorRef: Error): NSData;

  // export function CFURLCreateByResolvingBookmarkData(allocator: any, bookmark: NSData, options: CFURLBookmarkResolutionOptions, relativeToURL: NSURL, resourcePropertiesToInclude: any[], isStale: string | any, error: Error): NSURL;

  // export function CFURLCreateCopyAppendingPathComponent(allocator: any, url: NSURL, pathComponent: string, isDirectory: boolean): NSURL;

  // export function CFURLCreateCopyAppendingPathExtension(allocator: any, url: NSURL, extension: string): NSURL;

  // export function CFURLCreateCopyDeletingLastPathComponent(allocator: any, url: NSURL): NSURL;

  // export function CFURLCreateCopyDeletingPathExtension(allocator: any, url: NSURL): NSURL;

  // export function CFURLCreateData(allocator: any, url: NSURL, encoding: number, escapeWhitespace: boolean): NSData;

  // export function CFURLCreateFilePathURL(allocator: any, url: NSURL, error: Error): NSURL;

  // export function CFURLCreateFileReferenceURL(allocator: any, url: NSURL, error: Error): NSURL;

  // export function CFURLCreateFromFileSystemRepresentation(allocator: any, buffer: string | any, bufLen: number, isDirectory: boolean): NSURL;

  // export function CFURLCreateFromFileSystemRepresentationRelativeToBase(allocator: any, buffer: string | any, bufLen: number, isDirectory: boolean, baseURL: NSURL): NSURL;

  // export function CFURLCreateResourcePropertiesForKeysFromBookmarkData(allocator: any, resourcePropertiesToReturn: any[], bookmark: NSData): Map<any, any>;

  // export function CFURLCreateResourcePropertyForKeyFromBookmarkData(allocator: any, resourcePropertyKey: string, bookmark: NSData): any;

  // export function CFURLCreateStringByReplacingPercentEscapes(allocator: any, originalString: string, charactersToLeaveEscaped: string): string;

  // export function CFURLCreateWithBytes(allocator: any, URLBytes: string | any, length: number, encoding: number, baseURL: NSURL): NSURL;

  // export function CFURLCreateWithFileSystemPath(allocator: any, filePath: string, pathStyle: CFURLPathStyle, isDirectory: boolean): NSURL;

  // export function CFURLCreateWithFileSystemPathRelativeToBase(allocator: any, filePath: string, pathStyle: CFURLPathStyle, isDirectory: boolean, baseURL: NSURL): NSURL;

  // export function CFURLCreateWithString(allocator: any, URLString: string, baseURL: NSURL): NSURL;

  // export function CFURLEnumeratorCreateForDirectoryURL(alloc: any, directoryURL: NSURL, option: CFURLEnumeratorOptions, propertyKeys: any[]): any;

  // export function CFURLEnumeratorCreateForMountedVolumes(alloc: any, option: CFURLEnumeratorOptions, propertyKeys: any[]): any;

  // export function CFURLEnumeratorGetDescendentLevel(enumerator: any): number;

  // export function CFURLEnumeratorGetNextURL(enumerator: any, url: NSURL, error: Error): CFURLEnumeratorResult;

  // export function CFURLEnumeratorGetTypeID(): number;

  // export function CFURLEnumeratorSkipDescendents(enumerator: any): void;

  // export function CFURLGetBaseURL(anURL: NSURL): NSURL;

  // export function CFURLGetByteRangeForComponent(url: NSURL, component: CFURLComponentType, rangeIncludingSeparators: CFRange): CFRange;

  // export function CFURLGetBytes(url: NSURL, buffer: string | any, bufferLength: number): number;

  // export function CFURLGetFileSystemRepresentation(url: NSURL, resolveAgainstBase: boolean, buffer: string | any, maxBufLen: number): boolean;

  // export function CFURLGetPortNumber(anURL: NSURL): number;

  // export function CFURLGetString(anURL: NSURL): string;

  // export function CFURLGetTypeID(): number;

  // export function CFURLHasDirectoryPath(anURL: NSURL): boolean;

  // export function CFURLIsFileReferenceURL(url: NSURL): boolean;

  // export function CFURLResourceIsReachable(url: NSURL, error: Error): boolean;

  // export function CFURLSetResourcePropertiesForKeys(url: NSURL, keyedPropertyValues: Map<any, any>, error: Error): boolean;

  // export function CFURLSetResourcePropertyForKey(url: NSURL, key: string, propertyValue: any, error: Error): boolean;

  // export function CFURLSetTemporaryResourcePropertyForKey(url: NSURL, key: string, propertyValue: any): void;

  // export function CFURLStartAccessingSecurityScopedResource(url: NSURL): boolean;

  // export function CFURLStopAccessingSecurityScopedResource(url: NSURL): void;

  // export function CFURLWriteBookmarkDataToFile(bookmarkRef: NSData, fileURL: NSURL, options: number, errorRef: Error): boolean;

  // export function CFUUIDCreate(alloc: any): any;

  // export function CFUUIDCreateFromString(alloc: any, uuidStr: string): any;

  // export function CFUUIDCreateFromUUIDBytes(alloc: any, bytes: CFUUIDBytes): any;

  // export function CFUUIDCreateString(alloc: any, uuid: any): string;

  // export function CFUUIDCreateWithBytes(alloc: any, byte0: number, byte1: number, byte2: number, byte3: number, byte4: number, byte5: number, byte6: number, byte7: number, byte8: number, byte9: number, byte10: number, byte11: number, byte12: number, byte13: number, byte14: number, byte15: number): any;

  // export function CFUUIDGetConstantUUIDWithBytes(alloc: any, byte0: number, byte1: number, byte2: number, byte3: number, byte4: number, byte5: number, byte6: number, byte7: number, byte8: number, byte9: number, byte10: number, byte11: number, byte12: number, byte13: number, byte14: number, byte15: number): any;

  // export function CFUUIDGetTypeID(): number;

  // export function CFUUIDGetUUIDBytes(uuid: any): CFUUIDBytes;

  // export function CFUserNotificationCancel(userNotification: any): number;

  // export function CFUserNotificationCreate(allocator: any, timeout: number, flags: number, error: number, dictionary: Map<any, any>): any;

  // export function CFUserNotificationCreateRunLoopSource(allocator: any, userNotification: any, callout: (p1: any, p2: number) => void, order: number): any;

  // export function CFUserNotificationDisplayAlert(timeout: number, flags: number, iconURL: NSURL, soundURL: NSURL, localizationURL: NSURL, alertHeader: string, alertMessage: string, defaultButtonTitle: string, alternateButtonTitle: string, otherButtonTitle: string, responseFlags: number): number;

  // export function CFUserNotificationDisplayNotice(timeout: number, flags: number, iconURL: NSURL, soundURL: NSURL, localizationURL: NSURL, alertHeader: string, alertMessage: string, defaultButtonTitle: string): number;

  // export function CFUserNotificationGetResponseDictionary(userNotification: any): Map<any, any>;

  // export function CFUserNotificationGetResponseValue(userNotification: any, key: string, idx: number): string;

  // export function CFUserNotificationGetTypeID(): number;

  // export function CFUserNotificationReceiveResponse(userNotification: any, timeout: number, responseFlags: number): number;

  // export function CFUserNotificationUpdate(userNotification: any, timeout: number, flags: number, dictionary: Map<any, any>): number;

  // export function CFWriteStreamCanAcceptBytes(stream: OutputStream): boolean;

  // export function CFWriteStreamClose(stream: OutputStream): void;

  // export function CFWriteStreamCopyDispatchQueue(stream: OutputStream): NSObject;

  // export function CFWriteStreamCopyError(stream: OutputStream): NSError;

  // export function CFWriteStreamCopyProperty(stream: OutputStream, propertyName: any): any;

  // export function CFWriteStreamCreateWithAllocatedBuffers(alloc: any, bufferAllocator: any): OutputStream;

  // export function CFWriteStreamCreateWithBuffer(alloc: any, buffer: string | any, bufferCapacity: number): OutputStream;

  // export function CFWriteStreamCreateWithFile(alloc: any, fileURL: NSURL): OutputStream;

  // export function CFWriteStreamGetError(stream: OutputStream): CFStreamError;

  // export function CFWriteStreamGetStatus(stream: OutputStream): CFStreamStatus;

  // export function CFWriteStreamGetTypeID(): number;

  // export function CFWriteStreamOpen(stream: OutputStream): boolean;

  // export function CFWriteStreamScheduleWithRunLoop(stream: OutputStream, runLoop: any, runLoopMode: any): void;

  // export function CFWriteStreamSetClient(stream: OutputStream, streamEvents: number, clientCB: (p1: OutputStream, p2: CFStreamEventType, p3: any) => void, clientContext: CFStreamClientContext): boolean;

  // export function CFWriteStreamSetDispatchQueue(stream: OutputStream, q: NSObject): void;

  // export function CFWriteStreamSetProperty(stream: OutputStream, propertyName: any, propertyValue: any): boolean;

  // export function CFWriteStreamUnscheduleFromRunLoop(stream: OutputStream, runLoop: any, runLoopMode: any): void;

  // export function CFWriteStreamWrite(stream: OutputStream, buffer: string | any, bufferLength: number): number;

  // export function CFXMLCreateStringByEscapingEntities(allocator: any, string: string, entitiesDictionary: Map<any, any>): string;

  // export function CFXMLCreateStringByUnescapingEntities(allocator: any, string: string, entitiesDictionary: Map<any, any>): string;

  // export function __CFRangeMake(loc: number, len: number): CFRange;

  // export function __CFStringMakeConstantString(cStr: string | any): string;

  // export function CGAcquireDisplayFadeReservation(seconds: number, token: number): CGError;

  // export function CGAffineTransformConcat(t1: CGAffineTransform, t2: CGAffineTransform): CGAffineTransform;

  // export function CGAffineTransformEqualToTransform(t1: CGAffineTransform, t2: CGAffineTransform): boolean;

  // export function CGAffineTransformInvert(t: CGAffineTransform): CGAffineTransform;

  // export function CGAffineTransformIsIdentity(t: CGAffineTransform): boolean;

  // export function CGAffineTransformMake(a: number, b: number, c: number, d: number, tx: number, ty: number): CGAffineTransform;

  // export function CGAffineTransformMakeRotation(angle: number): CGAffineTransform;

  // export function CGAffineTransformMakeScale(sx: number, sy: number): CGAffineTransform;

  // export function CGAffineTransformMakeTranslation(tx: number, ty: number): CGAffineTransform;

  // export function CGAffineTransformRotate(t: CGAffineTransform, angle: number): CGAffineTransform;

  // export function CGAffineTransformScale(t: CGAffineTransform, sx: number, sy: number): CGAffineTransform;

  // export function CGAffineTransformTranslate(t: CGAffineTransform, tx: number, ty: number): CGAffineTransform;

  // export function CGAssociateMouseAndMouseCursorPosition(connected: number): CGError;

  // export function CGBeginDisplayConfiguration(config: any): CGError;

  // export function CGBitmapContextCreate(data: any, width: number, height: number, bitsPerComponent: number, bytesPerRow: number, space: any, bitmapInfo: number): any;

  // export function CGBitmapContextCreateImage(context: any): any;

  // export function CGBitmapContextCreateWithData(data: any, width: number, height: number, bitsPerComponent: number, bytesPerRow: number, space: any, bitmapInfo: number, releaseCallback: (p1: any, p2: any) => void, releaseInfo: any): any;

  // export function CGBitmapContextGetAlphaInfo(context: any): CGImageAlphaInfo;

  // export function CGBitmapContextGetBitmapInfo(context: any): CGBitmapInfo;

  // export function CGBitmapContextGetBitsPerComponent(context: any): number;

  // export function CGBitmapContextGetBitsPerPixel(context: any): number;

  // export function CGBitmapContextGetBytesPerRow(context: any): number;

  // export function CGBitmapContextGetColorSpace(context: any): any;

  // export function CGBitmapContextGetData(context: any): any;

  // export function CGBitmapContextGetHeight(context: any): number;

  // export function CGBitmapContextGetWidth(context: any): number;

  // export function CGCancelDisplayConfiguration(config: any): CGError;

  // export function CGCaptureAllDisplays(): CGError;

  // export function CGCaptureAllDisplaysWithOptions(options: CGCaptureOptions): CGError;

  // export function CGColorConversionInfoCreate(src: any, dst: any): any;

  // export function CGColorConversionInfoCreateWithOptions(src: any, dst: any, options: Map<any, any>): any;

  // export function typeID(): number;

  // export function CGColorCreate(space: any, components: number): any;

  // export function CGColorCreateCopy(color: any): any;

  // export function CGColorCreateCopyByMatchingToColorSpace(p1: any, intent: CGColorRenderingIntent, color: any, options: Map<any, any>): any;

  // export function CGColorCreateCopyWithAlpha(color: any, alpha: number): any;

  // export function CGColorCreateGenericCMYK(cyan: number, magenta: number, yellow: number, black: number, alpha: number): any;

  // export function CGColorCreateGenericGray(gray: number, alpha: number): any;

  // export function CGColorCreateGenericGrayGamma2_2(gray: number, alpha: number): any;

  // export function CGColorCreateGenericRGB(red: number, green: number, blue: number, alpha: number): any;

  // export function CGColorCreateSRGB(red: number, green: number, blue: number, alpha: number): any;

  // export function CGColorCreateWithPattern(space: any, pattern: any, components: number): any;

  // export function CGColorEqualToColor(color1: any, color2: any): boolean;

  // export function CGColorGetAlpha(color: any): number;

  // export function CGColorGetColorSpace(color: any): any;

  // export function CGColorGetComponents(color: any): number;

  // export function CGColorGetConstantColor(colorName: string): any;

  // export function CGColorGetNumberOfComponents(color: any): number;

  // export function CGColorGetPattern(color: any): any;

  // export function typeID(): number;

  // export function CGColorRelease(color: any): void;

  // export function CGColorRetain(color: any): any;

  // export function CGColorSpaceCopyICCData(space: any): NSData;

  // export function CGColorSpaceCopyName(space: any): string;

  // export function CGColorSpaceCopyPropertyList(space: any): any;

  // export function CGColorSpaceCreateCalibratedGray(whitePoint: number, blackPoint: number, gamma: number): any;

  // export function CGColorSpaceCreateCalibratedRGB(whitePoint: number, blackPoint: number, gamma: number, matrix: number): any;

  // export function CGColorSpaceCreateDeviceCMYK(): any;

  // export function CGColorSpaceCreateDeviceGray(): any;

  // export function CGColorSpaceCreateDeviceRGB(): any;

  // export function CGColorSpaceCreateICCBased(nComponents: number, range: number, profile: any, alternate: any): any;

  // export function CGColorSpaceCreateIndexed(baseSpace: any, lastIndex: number, colorTable: string | any): any;

  // export function CGColorSpaceCreateLab(whitePoint: number, blackPoint: number, range: number): any;

  // export function CGColorSpaceCreatePattern(baseSpace: any): any;

  // export function CGColorSpaceCreateWithICCData(data: any): any;

  // export function CGColorSpaceCreateWithName(name: string): any;

  // export function CGColorSpaceCreateWithPlatformColorSpace(ref: any): any;

  // export function CGColorSpaceCreateWithPropertyList(plist: any): any;

  // export function CGColorSpaceGetBaseColorSpace(space: any): any;

  // export function CGColorSpaceGetColorTable(space: any, table: string | any): void;

  // export function CGColorSpaceGetColorTableCount(space: any): number;

  // export function CGColorSpaceGetModel(space: any): CGColorSpaceModel;

  // export function CGColorSpaceGetName(space: any): string;

  // export function CGColorSpaceGetNumberOfComponents(space: any): number;

  // export function typeID(): number;

  // export function CGColorSpaceIsWideGamutRGB(p1: any): boolean;

  // export function CGColorSpaceRelease(space: any): void;

  // export function CGColorSpaceRetain(space: any): any;

  // export function CGColorSpaceSupportsOutput(space: any): boolean;

  // export function CGCompleteDisplayConfiguration(config: any, option: CGConfigureOption): CGError;

  // export function CGConfigureDisplayFadeEffect(config: any, fadeOutSeconds: number, fadeInSeconds: number, fadeRed: number, fadeGreen: number, fadeBlue: number): CGError;

  // export function CGConfigureDisplayMirrorOfDisplay(config: any, display: number, master: number): CGError;

  // export function CGConfigureDisplayOrigin(config: any, display: number, x: number, y: number): CGError;

  // export function CGConfigureDisplayStereoOperation(config: any, display: number, stereo: number, forceBlueLine: number): CGError;

  // export function CGConfigureDisplayWithDisplayMode(config: any, display: number, mode: any, options: Map<any, any>): CGError;

  // export function CGContextAddArc(c: any, x: number, y: number, radius: number, startAngle: number, endAngle: number, clockwise: number): void;

  // export function CGContextAddArcToPoint(c: any, x1: number, y1: number, x2: number, y2: number, radius: number): void;

  // export function CGContextAddCurveToPoint(c: any, cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number): void;

  // export function CGContextAddEllipseInRect(c: any, rect: CGRect): void;

  // export function CGContextAddLineToPoint(c: any, x: number, y: number): void;

  // export function CGContextAddLines(c: any, points: NSPoint, count: number): void;

  // export function CGContextAddPath(c: any, path: any): void;

  // export function CGContextAddQuadCurveToPoint(c: any, cpx: number, cpy: number, x: number, y: number): void;

  // export function CGContextAddRect(c: any, rect: CGRect): void;

  // export function CGContextAddRects(c: any, rects: NSRect, count: number): void;

  // export function CGContextBeginPage(c: any, mediaBox: NSRect): void;

  // export function CGContextBeginPath(c: any): void;

  // export function CGContextBeginTransparencyLayer(c: any, auxiliaryInfo: Map<any, any>): void;

  // export function CGContextBeginTransparencyLayerWithRect(c: any, rect: CGRect, auxInfo: Map<any, any>): void;

  // export function CGContextClearRect(c: any, rect: CGRect): void;

  // export function CGContextClip(c: any): void;

  // export function CGContextClipToMask(c: any, rect: CGRect, mask: any): void;

  // export function CGContextClipToRect(c: any, rect: CGRect): void;

  // export function CGContextClipToRects(c: any, rects: NSRect, count: number): void;

  // export function CGContextClosePath(c: any): void;

  // export function CGContextConcatCTM(c: any, transform: CGAffineTransform): void;

  // export function CGContextConvertPointToDeviceSpace(c: any, point: CGPoint): CGPoint;

  // export function CGContextConvertPointToUserSpace(c: any, point: CGPoint): CGPoint;

  // export function CGContextConvertRectToDeviceSpace(c: any, rect: CGRect): CGRect;

  // export function CGContextConvertRectToUserSpace(c: any, rect: CGRect): CGRect;

  // export function CGContextConvertSizeToDeviceSpace(c: any, size: CGSize): CGSize;

  // export function CGContextConvertSizeToUserSpace(c: any, size: CGSize): CGSize;

  // export function CGContextCopyPath(c: any): any;

  // export function CGContextDrawImage(c: any, rect: CGRect, image: any): void;

  // export function CGContextDrawLayerAtPoint(context: any, point: CGPoint, layer: any): void;

  // export function CGContextDrawLayerInRect(context: any, rect: CGRect, layer: any): void;

  // export function CGContextDrawLinearGradient(c: any, gradient: any, startPoint: CGPoint, endPoint: CGPoint, options: CGGradientDrawingOptions): void;

  // export function CGContextDrawPDFPage(c: any, page: any): void;

  // export function CGContextDrawPath(c: any, mode: CGPathDrawingMode): void;

  // export function CGContextDrawRadialGradient(c: any, gradient: any, startCenter: CGPoint, startRadius: number, endCenter: CGPoint, endRadius: number, options: CGGradientDrawingOptions): void;

  // export function CGContextDrawShading(c: any, shading: any): void;

  // export function CGContextDrawTiledImage(c: any, rect: CGRect, image: any): void;

  // export function CGContextEOClip(c: any): void;

  // export function CGContextEOFillPath(c: any): void;

  // export function CGContextEndPage(c: any): void;

  // export function CGContextEndTransparencyLayer(c: any): void;

  // export function CGContextFillEllipseInRect(c: any, rect: CGRect): void;

  // export function CGContextFillPath(c: any): void;

  // export function CGContextFillRect(c: any, rect: CGRect): void;

  // export function CGContextFillRects(c: any, rects: NSRect, count: number): void;

  // export function CGContextFlush(c: any): void;

  // export function CGContextGetCTM(c: any): CGAffineTransform;

  // export function CGContextGetClipBoundingBox(c: any): CGRect;

  // export function CGContextGetInterpolationQuality(c: any): CGInterpolationQuality;

  // export function CGContextGetPathBoundingBox(c: any): CGRect;

  // export function CGContextGetPathCurrentPoint(c: any): CGPoint;

  // export function CGContextGetTextMatrix(c: any): CGAffineTransform;

  // export function CGContextGetTextPosition(c: any): CGPoint;

  // export function typeID(): number;

  // export function CGContextGetUserSpaceToDeviceSpaceTransform(c: any): CGAffineTransform;

  // export function CGContextIsPathEmpty(c: any): boolean;

  // export function CGContextMoveToPoint(c: any, x: number, y: number): void;

  // export function CGContextPathContainsPoint(c: any, point: CGPoint, mode: CGPathDrawingMode): boolean;

  // export function CGContextRelease(c: any): void;

  // export function CGContextReplacePathWithStrokedPath(c: any): void;

  // export function CGContextResetClip(c: any): void;

  // export function CGContextRestoreGState(c: any): void;

  // export function CGContextRetain(c: any): any;

  // export function CGContextRotateCTM(c: any, angle: number): void;

  // export function CGContextSaveGState(c: any): void;

  // export function CGContextScaleCTM(c: any, sx: number, sy: number): void;

  // export function CGContextSetAllowsAntialiasing(c: any, allowsAntialiasing: boolean): void;

  // export function CGContextSetAllowsFontSmoothing(c: any, allowsFontSmoothing: boolean): void;

  // export function CGContextSetAllowsFontSubpixelPositioning(c: any, allowsFontSubpixelPositioning: boolean): void;

  // export function CGContextSetAllowsFontSubpixelQuantization(c: any, allowsFontSubpixelQuantization: boolean): void;

  // export function CGContextSetAlpha(c: any, alpha: number): void;

  // export function CGContextSetBlendMode(c: any, mode: CGBlendMode): void;

  // export function CGContextSetCMYKFillColor(c: any, cyan: number, magenta: number, yellow: number, black: number, alpha: number): void;

  // export function CGContextSetCMYKStrokeColor(c: any, cyan: number, magenta: number, yellow: number, black: number, alpha: number): void;

  // export function CGContextSetCharacterSpacing(c: any, spacing: number): void;

  // export function CGContextSetFillColor(c: any, components: number): void;

  // export function CGContextSetFillColorSpace(c: any, space: any): void;

  // export function CGContextSetFillColorWithColor(c: any, color: any): void;

  // export function CGContextSetFillPattern(c: any, pattern: any, components: number): void;

  // export function CGContextSetFlatness(c: any, flatness: number): void;

  // export function CGContextSetFont(c: any, font: any): void;

  // export function CGContextSetFontSize(c: any, size: number): void;

  // export function CGContextSetGrayFillColor(c: any, gray: number, alpha: number): void;

  // export function CGContextSetGrayStrokeColor(c: any, gray: number, alpha: number): void;

  // export function CGContextSetInterpolationQuality(c: any, quality: CGInterpolationQuality): void;

  // export function CGContextSetLineCap(c: any, cap: CGLineCap): void;

  // export function CGContextSetLineDash(c: any, phase: number, lengths: number, count: number): void;

  // export function CGContextSetLineJoin(c: any, join: CGLineJoin): void;

  // export function CGContextSetLineWidth(c: any, width: number): void;

  // export function CGContextSetMiterLimit(c: any, limit: number): void;

  // export function CGContextSetPatternPhase(c: any, phase: CGSize): void;

  // export function CGContextSetRGBFillColor(c: any, red: number, green: number, blue: number, alpha: number): void;

  // export function CGContextSetRGBStrokeColor(c: any, red: number, green: number, blue: number, alpha: number): void;

  // export function CGContextSetRenderingIntent(c: any, intent: CGColorRenderingIntent): void;

  // export function CGContextSetShadow(c: any, offset: CGSize, blur: number): void;

  // export function CGContextSetShadowWithColor(c: any, offset: CGSize, blur: number, color: any): void;

  // export function CGContextSetShouldAntialias(c: any, shouldAntialias: boolean): void;

  // export function CGContextSetShouldSmoothFonts(c: any, shouldSmoothFonts: boolean): void;

  // export function CGContextSetShouldSubpixelPositionFonts(c: any, shouldSubpixelPositionFonts: boolean): void;

  // export function CGContextSetShouldSubpixelQuantizeFonts(c: any, shouldSubpixelQuantizeFonts: boolean): void;

  // export function CGContextSetStrokeColor(c: any, components: number): void;

  // export function CGContextSetStrokeColorSpace(c: any, space: any): void;

  // export function CGContextSetStrokeColorWithColor(c: any, color: any): void;

  // export function CGContextSetStrokePattern(c: any, pattern: any, components: number): void;

  // export function CGContextSetTextDrawingMode(c: any, mode: CGTextDrawingMode): void;

  // export function CGContextSetTextMatrix(c: any, t: CGAffineTransform): void;

  // export function CGContextSetTextPosition(c: any, x: number, y: number): void;

  // export function CGContextShowGlyphsAtPositions(c: any, glyphs: number, Lpositions: NSPoint, count: number): void;

  // export function CGContextStrokeEllipseInRect(c: any, rect: CGRect): void;

  // export function CGContextStrokeLineSegments(c: any, points: NSPoint, count: number): void;

  // export function CGContextStrokePath(c: any): void;

  // export function CGContextStrokeRect(c: any, rect: CGRect): void;

  // export function CGContextStrokeRectWithWidth(c: any, rect: CGRect, width: number): void;

  // export function CGContextSynchronize(c: any): void;

  // export function CGContextTranslateCTM(c: any, tx: number, ty: number): void;

  // export function CGDataConsumerCreate(info: any, cbks: CGDataConsumerCallbacks): any;

  // export function CGDataConsumerCreateWithCFData(data: NSData): any;

  // export function CGDataConsumerCreateWithURL(url: NSURL): any;

  // export function typeID(): number;

  // export function CGDataConsumerRelease(consumer: any): void;

  // export function CGDataConsumerRetain(consumer: any): any;

  // export function CGDataProviderCopyData(provider: any): NSData;

  // export function CGDataProviderCreateDirect(info: any, size: number, callbacks: CGDataProviderDirectCallbacks): any;

  // export function CGDataProviderCreateSequential(info: any, callbacks: CGDataProviderSequentialCallbacks): any;

  // export function CGDataProviderCreateWithCFData(data: NSData): any;

  // export function CGDataProviderCreateWithData(info: any, data: any, size: number, releaseData: (p1: any, p2: any, p3: number) => void): any;

  // export function CGDataProviderCreateWithFilename(filename: string | any): any;

  // export function CGDataProviderCreateWithURL(url: NSURL): any;

  // export function CGDataProviderGetInfo(provider: any): any;

  // export function typeID(): number;

  // export function CGDataProviderRelease(provider: any): void;

  // export function CGDataProviderRetain(provider: any): any;

  // export function CGDirectDisplayCopyCurrentMetalDevice(display: number): MTLDevice;

  // export function CGDisplayBounds(display: number): CGRect;

  // export function CGDisplayCapture(display: number): CGError;

  // export function CGDisplayCaptureWithOptions(display: number, options: CGCaptureOptions): CGError;

  // export function CGDisplayCopyAllDisplayModes(display: number, options: Map<any, any>): any[];

  // export function CGDisplayCopyColorSpace(display: number): any;

  // export function CGDisplayCopyDisplayMode(display: number): any;

  // export function CGDisplayCreateImage(displayID: number): any;

  // export function CGDisplayCreateImageForRect(display: number, rect: CGRect): any;

  // export function CGDisplayFade(token: number, duration: number, startBlend: number, endBlend: number, redBlend: number, greenBlend: number, blueBlend: number, synchronous: number): CGError;

  // export function CGDisplayGammaTableCapacity(display: number): number;

  // export function CGDisplayGetDrawingContext(display: number): any;

  // export function CGDisplayHideCursor(display: number): CGError;

  // export function CGDisplayIDToOpenGLDisplayMask(display: number): number;

  // export function CGDisplayIsActive(display: number): number;

  // export function CGDisplayIsAlwaysInMirrorSet(display: number): number;

  // export function CGDisplayIsAsleep(display: number): number;

  // export function CGDisplayIsBuiltin(display: number): number;

  // export function CGDisplayIsInHWMirrorSet(display: number): number;

  // export function CGDisplayIsInMirrorSet(display: number): number;

  // export function CGDisplayIsMain(display: number): number;

  // export function CGDisplayIsOnline(display: number): number;

  // export function CGDisplayIsStereo(display: number): number;

  // export function CGDisplayMirrorsDisplay(display: number): number;

  // export function CGDisplayModeGetHeight(mode: any): number;

  // export function CGDisplayModeGetIODisplayModeID(mode: any): number;

  // export function CGDisplayModeGetIOFlags(mode: any): number;

  // export function CGDisplayModeGetPixelHeight(mode: any): number;

  // export function CGDisplayModeGetPixelWidth(mode: any): number;

  // export function CGDisplayModeGetRefreshRate(mode: any): number;

  // export function typeID(): number;

  // export function CGDisplayModeGetWidth(mode: any): number;

  // export function CGDisplayModeIsUsableForDesktopGUI(mode: any): boolean;

  // export function CGDisplayModeRelease(mode: any): void;

  // export function CGDisplayModeRetain(mode: any): any;

  // export function CGDisplayModelNumber(display: number): number;

  // export function CGDisplayMoveCursorToPoint(display: number, point: CGPoint): CGError;

  // export function CGDisplayPixelsHigh(display: number): number;

  // export function CGDisplayPixelsWide(display: number): number;

  // export function CGDisplayPrimaryDisplay(display: number): number;

  // export function CGDisplayRegisterReconfigurationCallback(callback: (p1: number, p2: CGDisplayChangeSummaryFlags, p3: any) => void, userInfo: any): CGError;

  // export function CGDisplayRelease(display: number): CGError;

  // export function CGDisplayRemoveReconfigurationCallback(callback: (p1: number, p2: CGDisplayChangeSummaryFlags, p3: any) => void, userInfo: any): CGError;

  // export function CGDisplayRestoreColorSyncSettings(): void;

  // export function CGDisplayRotation(display: number): number;

  // export function CGDisplayScreenSize(display: number): CGSize;

  // export function CGDisplaySerialNumber(display: number): number;

  // export function CGDisplaySetDisplayMode(display: number, mode: any, options: Map<any, any>): CGError;

  // export function CGDisplaySetStereoOperation(display: number, stereo: number, forceBlueLine: number, option: CGConfigureOption): CGError;

  // export function CGDisplayShowCursor(display: number): CGError;

  // export function CGDisplayStreamCreate(display: number, outputWidth: number, outputHeight: number, pixelFormat: number, properties: Map<any, any>, handler: (p1: CGDisplayStreamFrameStatus, p2: number, p3: any, p4: any) => void): any;

  // export function CGDisplayStreamCreateWithDispatchQueue(display: number, outputWidth: number, outputHeight: number, pixelFormat: number, properties: Map<any, any>, queue: NSObject, handler: (p1: CGDisplayStreamFrameStatus, p2: number, p3: any, p4: any) => void): any;

  // export function CGDisplayStreamGetRunLoopSource(displayStream: any): any;

  // export function typeID(): number;

  // export function CGDisplayStreamStart(displayStream: any): CGError;

  // export function CGDisplayStreamStop(displayStream: any): CGError;

  // export function CGDisplayStreamUpdateCreateMergedUpdate(firstUpdate: any, secondUpdate: any): any;

  // export function CGDisplayStreamUpdateGetDropCount(updateRef: any): number;

  // export function CGDisplayStreamUpdateGetMovedRectsDelta(updateRef: any, dx: number, dy: number): void;

  // export function CGDisplayStreamUpdateGetRects(updateRef: any, rectType: CGDisplayStreamUpdateRectType, rectCount: number): NSRect;

  // export function typeID(): number;

  // export function CGDisplayUnitNumber(display: number): number;

  // export function CGDisplayUsesOpenGLAcceleration(display: number): number;

  // export function CGDisplayVendorNumber(display: number): number;

  // export function CGEventCreate(source: any): any;

  // export function CGEventCreateCopy(event: any): any;

  // export function CGEventCreateData(allocator: any, event: any): NSData;

  // export function CGEventCreateFromData(allocator: any, data: NSData): any;

  // export function CGEventCreateKeyboardEvent(source: any, virtualKey: number, keyDown: boolean): any;

  // export function CGEventCreateMouseEvent(source: any, mouseType: CGEventType, mouseCursorPosition: CGPoint, mouseButton: CGMouseButton): any;

  // export function CGEventCreateScrollWheelEvent2(source: any, units: CGScrollEventUnit, wheelCount: number, wheel1: number, wheel2: number, wheel3: number): any;

  // export function CGEventCreateSourceFromEvent(event: any): any;

  // export function CGEventGetDoubleValueField(event: any, field: CGEventField): number;

  // export function CGEventGetFlags(event: any): CGEventFlags;

  // export function CGEventGetIntegerValueField(event: any, field: CGEventField): number;

  // export function CGEventGetLocation(event: any): CGPoint;

  // export function CGEventGetTimestamp(event: any): number;

  // export function CGEventGetType(event: any): CGEventType;

  // export function typeID(): number;

  // export function CGEventGetUnflippedLocation(event: any): CGPoint;

  // export function CGEventKeyboardGetUnicodeString(event: any, maxStringLength: number, actualStringLength: number, unicodeString: number): void;

  // export function CGEventKeyboardSetUnicodeString(event: any, stringLength: number, unicodeString: number): void;

  // export function CGEventPost(tap: CGEventTapLocation, event: any): void;

  // export function CGEventPostToPSN(processSerialNumber: any, event: any): void;

  // export function CGEventPostToPid(pid: number, event: any): void;

  // export function CGEventSetDoubleValueField(event: any, field: CGEventField, value: number): void;

  // export function CGEventSetFlags(event: any, flags: CGEventFlags): void;

  // export function CGEventSetIntegerValueField(event: any, field: CGEventField, value: number): void;

  // export function CGEventSetLocation(event: any, location: CGPoint): void;

  // export function CGEventSetSource(event: any, source: any): void;

  // export function CGEventSetTimestamp(event: any, timestamp: number): void;

  // export function CGEventSetType(event: any, type: CGEventType): void;

  // export function CGEventSourceButtonState(stateID: CGEventSourceStateID, button: CGMouseButton): boolean;

  // export function CGEventSourceCounterForEventType(stateID: CGEventSourceStateID, eventType: CGEventType): number;

  // export function CGEventSourceCreate(stateID: CGEventSourceStateID): any;

  // export function CGEventSourceFlagsState(stateID: CGEventSourceStateID): CGEventFlags;

  // export function CGEventSourceGetKeyboardType(source: any): number;

  // export function CGEventSourceGetLocalEventsFilterDuringSuppressionState(source: any, state: CGEventSuppressionState): CGEventFilterMask;

  // export function CGEventSourceGetLocalEventsSuppressionInterval(source: any): number;

  // export function CGEventSourceGetPixelsPerLine(source: any): number;

  // export function CGEventSourceGetSourceStateID(source: any): CGEventSourceStateID;

  // export function typeID(): number;

  // export function CGEventSourceGetUserData(source: any): number;

  // export function CGEventSourceKeyState(stateID: CGEventSourceStateID, key: number): boolean;

  // export function CGEventSourceSecondsSinceLastEventType(stateID: CGEventSourceStateID, eventType: CGEventType): number;

  // export function CGEventSourceSetKeyboardType(source: any, keyboardType: number): void;

  // export function CGEventSourceSetLocalEventsFilterDuringSuppressionState(source: any, filter: CGEventFilterMask, state: CGEventSuppressionState): void;

  // export function CGEventSourceSetLocalEventsSuppressionInterval(source: any, seconds: number): void;

  // export function CGEventSourceSetPixelsPerLine(source: any, pixelsPerLine: number): void;

  // export function CGEventSourceSetUserData(source: any, userData: number): void;

  // export function CGEventTapCreate(tap: CGEventTapLocation, place: CGEventTapPlacement, options: CGEventTapOptions, eventsOfInterest: number, callback: (p1: any, p2: CGEventType, p3: any, p4: any) => any, userInfo: any): NSMachPort;

  // export function CGEventTapCreateForPSN(processSerialNumber: any, place: CGEventTapPlacement, options: CGEventTapOptions, eventsOfInterest: number, callback: (p1: any, p2: CGEventType, p3: any, p4: any) => any, userInfo: any): NSMachPort;

  // export function CGEventTapCreateForPid(pid: number, place: CGEventTapPlacement, options: CGEventTapOptions, eventsOfInterest: number, callback: (p1: any, p2: CGEventType, p3: any, p4: any) => any, userInfo: any): NSMachPort;

  // export function CGEventTapEnable(tap: NSMachPort, enable: boolean): void;

  // export function CGEventTapIsEnabled(tap: NSMachPort): boolean;

  // export function CGEventTapPostEvent(proxy: any, event: any): void;

  // export function CGFontCanCreatePostScriptSubset(font: any, format: CGFontPostScriptFormat): boolean;

  // export function CGFontCopyFullName(font: any): string;

  // export function CGFontCopyGlyphNameForGlyph(font: any, glyph: number): string;

  // export function CGFontCopyPostScriptName(font: any): string;

  // export function CGFontCopyTableForTag(font: any, tag: number): NSData;

  // export function CGFontCopyTableTags(font: any): any[];

  // export function CGFontCopyVariationAxes(font: any): any[];

  // export function CGFontCopyVariations(font: any): Map<any, any>;

  // export function CGFontCreateCopyWithVariations(font: any, variations: Map<any, any>): any;

  // export function CGFontCreatePostScriptEncoding(font: any, encoding: number): NSData;

  // export function CGFontCreatePostScriptSubset(font: any, subsetName: string, format: CGFontPostScriptFormat, glyphs: number, count: number, encoding: number): NSData;

  // export function CGFontCreateWithDataProvider(provider: any): any;

  // export function CGFontCreateWithFontName(name: string): any;

  // export function CGFontGetAscent(font: any): number;

  // export function CGFontGetCapHeight(font: any): number;

  // export function CGFontGetDescent(font: any): number;

  // export function CGFontGetFontBBox(font: any): CGRect;

  // export function CGFontGetGlyphAdvances(font: any, glyphs: number, count: number, advances: number): boolean;

  // export function CGFontGetGlyphBBoxes(font: any, glyphs: number, count: number, bboxes: NSRect): boolean;

  // export function CGFontGetGlyphWithGlyphName(font: any, name: string): number;

  // export function CGFontGetItalicAngle(font: any): number;

  // export function CGFontGetLeading(font: any): number;

  // export function CGFontGetNumberOfGlyphs(font: any): number;

  // export function CGFontGetStemV(font: any): number;

  // export function typeID(): number;

  // export function CGFontGetUnitsPerEm(font: any): number;

  // export function CGFontGetXHeight(font: any): number;

  // export function CGFontRelease(font: any): void;

  // export function CGFontRetain(font: any): any;

  // export function CGFunctionCreate(info: any, domainDimension: number, domain: number, rangeDimension: number, range: number, callbacks: CGFunctionCallbacks): any;

  // export function typeID(): number;

  // export function CGFunctionRelease(function_: any): void;

  // export function CGFunctionRetain(function_: any): any;

  // export function CGGetActiveDisplayList(maxDisplays: number, activeDisplays: number, displayCount: number): CGError;

  // export function CGGetDisplayTransferByFormula(display: number, redMin: number, redMax: number, redGamma: number, greenMin: number, greenMax: number, greenGamma: number, blueMin: number, blueMax: number, blueGamma: number): CGError;

  // export function CGGetDisplayTransferByTable(display: number, capacity: number, redTable: number, greenTable: number, blueTable: number, sampleCount: number): CGError;

  // export function CGGetDisplaysWithOpenGLDisplayMask(mask: number, maxDisplays: number, displays: number, matchingDisplayCount: number): CGError;

  // export function CGGetDisplaysWithPoint(point: CGPoint, maxDisplays: number, displays: number, matchingDisplayCount: number): CGError;

  // export function CGGetDisplaysWithRect(rect: CGRect, maxDisplays: number, displays: number, matchingDisplayCount: number): CGError;

  // export function CGGetEventTapList(maxNumberOfTaps: number, tapList: __CGEventTapInformation, eventTapCount: number): CGError;

  // export function CGGetLastMouseDelta(deltaX: number, deltaY: number): void;

  // export function CGGetOnlineDisplayList(maxDisplays: number, onlineDisplays: number, displayCount: number): CGError;

  // export function CGGradientCreateWithColorComponents(space: any, components: number, locations: number, count: number): any;

  // export function CGGradientCreateWithColors(space: any, colors: any[], locations: number): any;

  // export function typeID(): number;

  // export function CGGradientRelease(gradient: any): void;

  // export function CGGradientRetain(gradient: any): any;

  // export function CGImageCreate(width: number, height: number, bitsPerComponent: number, bitsPerPixel: number, bytesPerRow: number, space: any, bitmapInfo: CGBitmapInfo, provider: any, decode: number, shouldInterpolate: boolean, intent: CGColorRenderingIntent): any;

  // export function CGImageCreateCopy(image: any): any;

  // export function CGImageCreateCopyWithColorSpace(image: any, space: any): any;

  // export function CGImageCreateWithImageInRect(image: any, rect: CGRect): any;

  // export function CGImageCreateWithJPEGDataProvider(source: any, decode: number, shouldInterpolate: boolean, intent: CGColorRenderingIntent): any;

  // export function CGImageCreateWithMask(image: any, mask: any): any;

  // export function CGImageCreateWithMaskingColors(image: any, components: number): any;

  // export function CGImageCreateWithPNGDataProvider(source: any, decode: number, shouldInterpolate: boolean, intent: CGColorRenderingIntent): any;

  // export function CGImageGetAlphaInfo(image: any): CGImageAlphaInfo;

  // export function CGImageGetBitmapInfo(image: any): CGBitmapInfo;

  // export function CGImageGetBitsPerComponent(image: any): number;

  // export function CGImageGetBitsPerPixel(image: any): number;

  // export function CGImageGetByteOrderInfo(image: any): CGImageByteOrderInfo;

  // export function CGImageGetBytesPerRow(image: any): number;

  // export function CGImageGetColorSpace(image: any): any;

  // export function CGImageGetDataProvider(image: any): any;

  // export function CGImageGetDecode(image: any): number;

  // export function CGImageGetHeight(image: any): number;

  // export function CGImageGetPixelFormatInfo(image: any): CGImagePixelFormatInfo;

  // export function CGImageGetRenderingIntent(image: any): CGColorRenderingIntent;

  // export function CGImageGetShouldInterpolate(image: any): boolean;

  // export function typeID(): number;

  // export function CGImageGetUTType(image: any): string;

  // export function CGImageGetWidth(image: any): number;

  // export function CGImageIsMask(image: any): boolean;

  // export function CGImageMaskCreate(width: number, height: number, bitsPerComponent: number, bitsPerPixel: number, bytesPerRow: number, provider: any, decode: number, shouldInterpolate: boolean): any;

  // export function CGImageRelease(image: any): void;

  // export function CGImageRetain(image: any): any;

  // export function CGLayerCreateWithContext(context: any, size: CGSize, auxiliaryInfo: Map<any, any>): any;

  // export function CGLayerGetContext(layer: any): any;

  // export function CGLayerGetSize(layer: any): CGSize;

  // export function typeID(): number;

  // export function CGLayerRelease(layer: any): void;

  // export function CGLayerRetain(layer: any): any;

  // export function CGMainDisplayID(): number;

  // export function CGOpenGLDisplayMaskToDisplayID(mask: number): number;

  // export function CGPDFArrayApplyBlock(array: any, block: (p1: number, p2: any, p3: any) => boolean, info: any): void;

  // export function CGPDFArrayGetArray(array: any, index: number, value: any): boolean;

  // export function CGPDFArrayGetBoolean(array: any, index: number, value: string | any): boolean;

  // export function CGPDFArrayGetCount(array: any): number;

  // export function CGPDFArrayGetDictionary(array: any, index: number, value: any): boolean;

  // export function CGPDFArrayGetInteger(array: any, index: number, value: number): boolean;

  // export function CGPDFArrayGetName(array: any, index: number, value: string): boolean;

  // export function CGPDFArrayGetNull(array: any, index: number): boolean;

  // export function CGPDFArrayGetNumber(array: any, index: number, value: number): boolean;

  // export function CGPDFArrayGetObject(array: any, index: number, value: any): boolean;

  // export function CGPDFArrayGetStream(array: any, index: number, value: any): boolean;

  // export function CGPDFArrayGetString(array: any, index: number, value: any): boolean;

  // export function CGPDFContentStreamCreateWithPage(page: any): any;

  // export function CGPDFContentStreamCreateWithStream(stream: any, streamResources: any, parent: any): any;

  // export function CGPDFContentStreamGetResource(cs: any, category: string | any, name: string | any): any;

  // export function CGPDFContentStreamGetStreams(cs: any): any[];

  // export function CGPDFContentStreamRelease(cs: any): void;

  // export function CGPDFContentStreamRetain(cs: any): any;

  // export function CGPDFContextAddDestinationAtPoint(context: any, name: string, point: CGPoint): void;

  // export function CGPDFContextAddDocumentMetadata(context: any, metadata: NSData): void;

  // export function CGPDFContextBeginPage(context: any, pageInfo: Map<any, any>): void;

  // export function CGPDFContextBeginTag(context: any, tagType: CGPDFTagType, tagProperties: Map<any, any>): void;

  // export function CGPDFContextClose(context: any): void;

  // export function CGPDFContextCreate(consumer: any, mediaBox: NSRect, auxiliaryInfo: Map<any, any>): any;

  // export function CGPDFContextCreateWithURL(url: NSURL, mediaBox: NSRect, auxiliaryInfo: Map<any, any>): any;

  // export function CGPDFContextEndPage(context: any): void;

  // export function CGPDFContextEndTag(context: any): void;

  // export function CGPDFContextSetDestinationForRect(context: any, name: string, rect: CGRect): void;

  // export function CGPDFContextSetOutline(context: any, outline: Map<any, any>): void;

  // export function CGPDFContextSetURLForRect(context: any, url: NSURL, rect: CGRect): void;

  // export function CGPDFDictionaryApplyBlock(dict: any, block: (p1: string, p2: any, p3: any) => boolean, info: any): void;

  // export function CGPDFDictionaryApplyFunction(dict: any, function_: (p1: string, p2: any, p3: any) => void, info: any): void;

  // export function CGPDFDictionaryGetArray(dict: any, key: string | any, value: any): boolean;

  // export function CGPDFDictionaryGetBoolean(dict: any, key: string | any, value: string | any): boolean;

  // export function CGPDFDictionaryGetCount(dict: any): number;

  // export function CGPDFDictionaryGetDictionary(dict: any, key: string | any, value: any): boolean;

  // export function CGPDFDictionaryGetInteger(dict: any, key: string | any, value: number): boolean;

  // export function CGPDFDictionaryGetName(dict: any, key: string | any, value: string): boolean;

  // export function CGPDFDictionaryGetNumber(dict: any, key: string | any, value: number): boolean;

  // export function CGPDFDictionaryGetObject(dict: any, key: string | any, value: any): boolean;

  // export function CGPDFDictionaryGetStream(dict: any, key: string | any, value: any): boolean;

  // export function CGPDFDictionaryGetString(dict: any, key: string | any, value: any): boolean;

  // export function CGPDFDocumentAllowsCopying(document: any): boolean;

  // export function CGPDFDocumentAllowsPrinting(document: any): boolean;

  // export function CGPDFDocumentCreateWithProvider(provider: any): any;

  // export function CGPDFDocumentCreateWithURL(url: NSURL): any;

  // export function CGPDFDocumentGetAccessPermissions(document: any): CGPDFAccessPermissions;

  // export function CGPDFDocumentGetCatalog(document: any): any;

  // export function CGPDFDocumentGetID(document: any): any;

  // export function CGPDFDocumentGetInfo(document: any): any;

  // export function CGPDFDocumentGetNumberOfPages(document: any): number;

  // export function CGPDFDocumentGetOutline(document: any): Map<any, any>;

  // export function CGPDFDocumentGetPage(document: any, pageNumber: number): any;

  // export function typeID(): number;

  // export function CGPDFDocumentGetVersion(document: any, majorVersion: number, minorVersion: number): void;

  // export function CGPDFDocumentIsEncrypted(document: any): boolean;

  // export function CGPDFDocumentIsUnlocked(document: any): boolean;

  // export function CGPDFDocumentRelease(document: any): void;

  // export function CGPDFDocumentRetain(document: any): any;

  // export function CGPDFDocumentUnlockWithPassword(document: any, password: string | any): boolean;

  // export function CGPDFObjectGetType(object_: any): CGPDFObjectType;

  // export function CGPDFObjectGetValue(object_: any, type: CGPDFObjectType, value: any): boolean;

  // export function CGPDFOperatorTableCreate(): any;

  // export function CGPDFOperatorTableRelease(table: any): void;

  // export function CGPDFOperatorTableRetain(table: any): any;

  // export function CGPDFOperatorTableSetCallback(table: any, name: string | any, callback: (p1: any, p2: any) => void): void;

  // export function CGPDFPageGetBoxRect(page: any, box: CGPDFBox): CGRect;

  // export function CGPDFPageGetDictionary(page: any): any;

  // export function CGPDFPageGetDocument(page: any): any;

  // export function CGPDFPageGetDrawingTransform(page: any, box: CGPDFBox, rect: CGRect, rotate: number, preserveAspectRatio: boolean): CGAffineTransform;

  // export function CGPDFPageGetPageNumber(page: any): number;

  // export function CGPDFPageGetRotationAngle(page: any): number;

  // export function typeID(): number;

  // export function CGPDFPageRelease(page: any): void;

  // export function CGPDFPageRetain(page: any): any;

  // export function CGPDFScannerCreate(cs: any, table: any, info: any): any;

  // export function CGPDFScannerGetContentStream(scanner: any): any;

  // export function CGPDFScannerPopArray(scanner: any, value: any): boolean;

  // export function CGPDFScannerPopBoolean(scanner: any, value: string | any): boolean;

  // export function CGPDFScannerPopDictionary(scanner: any, value: any): boolean;

  // export function CGPDFScannerPopInteger(scanner: any, value: number): boolean;

  // export function CGPDFScannerPopName(scanner: any, value: string): boolean;

  // export function CGPDFScannerPopNumber(scanner: any, value: number): boolean;

  // export function CGPDFScannerPopObject(scanner: any, value: any): boolean;

  // export function CGPDFScannerPopStream(scanner: any, value: any): boolean;

  // export function CGPDFScannerPopString(scanner: any, value: any): boolean;

  // export function CGPDFScannerRelease(scanner: any): void;

  // export function CGPDFScannerRetain(scanner: any): any;

  // export function CGPDFScannerScan(scanner: any): boolean;

  // export function CGPDFStreamCopyData(stream: any, format: CGPDFDataFormat): NSData;

  // export function CGPDFStreamGetDictionary(stream: any): any;

  // export function CGPDFStringCopyDate(string: any): Date;

  // export function CGPDFStringCopyTextString(string: any): string;

  // export function CGPDFStringGetBytePtr(string: any): string;

  // export function CGPDFStringGetLength(string: any): number;

  // export function CGPDFTagTypeGetName(tagType: CGPDFTagType): string;

  // export function CGPSConverterAbort(converter: any): boolean;

  // export function CGPSConverterConvert(converter: any, provider: any, consumer: any, options: Map<any, any>): boolean;

  // export function CGPSConverterCreate(info: any, callbacks: CGPSConverterCallbacks, options: Map<any, any>): any;

  // export function typeID(): number;

  // export function CGPSConverterIsConverting(converter: any): boolean;

  // export function CGPathAddArc(path: any, m: CGAffineTransform, x: number, y: number, radius: number, startAngle: number, endAngle: number, clockwise: boolean): void;

  // export function CGPathAddArcToPoint(path: any, m: CGAffineTransform, x1: number, y1: number, x2: number, y2: number, radius: number): void;

  // export function CGPathAddCurveToPoint(path: any, m: CGAffineTransform, cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number): void;

  // export function CGPathAddEllipseInRect(path: any, m: CGAffineTransform, rect: CGRect): void;

  // export function CGPathAddLineToPoint(path: any, m: CGAffineTransform, x: number, y: number): void;

  // export function CGPathAddLines(path: any, m: CGAffineTransform, points: NSPoint, count: number): void;

  // export function CGPathAddPath(path1: any, m: CGAffineTransform, path2: any): void;

  // export function CGPathAddQuadCurveToPoint(path: any, m: CGAffineTransform, cpx: number, cpy: number, x: number, y: number): void;

  // export function CGPathAddRect(path: any, m: CGAffineTransform, rect: CGRect): void;

  // export function CGPathAddRects(path: any, m: CGAffineTransform, rects: NSRect, count: number): void;

  // export function CGPathAddRelativeArc(path: any, matrix: CGAffineTransform, x: number, y: number, radius: number, startAngle: number, delta: number): void;

  // export function CGPathAddRoundedRect(path: any, transform: CGAffineTransform, rect: CGRect, cornerWidth: number, cornerHeight: number): void;

  // export function apply(path: any, info: any, function_: (p1: any, p2: CGPathElement) => void): void;

  // export function CGPathApplyWithBlock(path: any, block: (p1: CGPathElement) => void): void;

  // export function CGPathCloseSubpath(path: any): void;

  // export function CGPathContainsPoint(path: any, m: CGAffineTransform, point: CGPoint, eoFill: boolean): boolean;

  // export function CGPathCreateCopy(path: any): any;

  // export function CGPathCreateCopyByDashingPath(path: any, transform: CGAffineTransform, phase: number, lengths: number, count: number): any;

  // export function CGPathCreateCopyByStrokingPath(path: any, transform: CGAffineTransform, lineWidth: number, lineCap: CGLineCap, lineJoin: CGLineJoin, miterLimit: number): any;

  // export function CGPathCreateCopyByTransformingPath(path: any, transform: CGAffineTransform): any;

  // export function create(): any;

  // export function CGPathCreateMutableCopy(path: any): any;

  // export function CGPathCreateMutableCopyByTransformingPath(path: any, transform: CGAffineTransform): any;

  // export function CGPathCreateWithEllipseInRect(rect: CGRect, transform: CGAffineTransform): any;

  // export function CGPathCreateWithRect(rect: CGRect, transform: CGAffineTransform): any;

  // export function CGPathCreateWithRoundedRect(rect: CGRect, cornerWidth: number, cornerHeight: number, transform: CGAffineTransform): any;

  // export function CGPathEqualToPath(path1: any, path2: any): boolean;

  // export function CGPathGetBoundingBox(path: any): CGRect;

  // export function CGPathGetCurrentPoint(path: any): CGPoint;

  // export function CGPathGetPathBoundingBox(path: any): CGRect;

  // export function typeID(): number;

  // export function CGPathIsEmpty(path: any): boolean;

  // export function CGPathIsRect(path: any, rect: NSRect): boolean;

  // export function CGPathMoveToPoint(path: any, m: CGAffineTransform, x: number, y: number): void;

  // export function CGPathRelease(path: any): void;

  // export function CGPathRetain(path: any): any;

  // export function CGPatternCreate(info: any, bounds: CGRect, matrix: CGAffineTransform, xStep: number, yStep: number, tiling: CGPatternTiling, isColored: boolean, callbacks: CGPatternCallbacks): any;

  // export function typeID(): number;

  // export function CGPatternRelease(pattern: any): void;

  // export function CGPatternRetain(pattern: any): any;

  // export function CGPointApplyAffineTransform(point: CGPoint, t: CGAffineTransform): CGPoint;

  // export function CGPointCreateDictionaryRepresentation(point: CGPoint): Map<any, any>;

  // export function CGPointEqualToPoint(point1: CGPoint, point2: CGPoint): boolean;

  // export function CGPointMake(x: number, y: number): CGPoint;

  // export function CGPointMakeWithDictionaryRepresentation(dict: Map<any, any>, point: NSPoint): boolean;

  // export function CGRectApplyAffineTransform(rect: CGRect, t: CGAffineTransform): CGRect;

  // export function CGRectContainsPoint(rect: CGRect, point: CGPoint): boolean;

  // export function CGRectContainsRect(rect1: CGRect, rect2: CGRect): boolean;

  // export function CGRectCreateDictionaryRepresentation(p1: CGRect): Map<any, any>;

  // export function CGRectDivide(rect: CGRect, slice: NSRect, remainder: NSRect, amount: number, edge: CGRectEdge): void;

  // export function CGRectEqualToRect(rect1: CGRect, rect2: CGRect): boolean;

  // export function CGRectGetHeight(rect: CGRect): number;

  // export function CGRectGetMaxX(rect: CGRect): number;

  // export function CGRectGetMaxY(rect: CGRect): number;

  // export function CGRectGetMidX(rect: CGRect): number;

  // export function CGRectGetMidY(rect: CGRect): number;

  // export function CGRectGetMinX(rect: CGRect): number;

  // export function CGRectGetMinY(rect: CGRect): number;

  // export function CGRectGetWidth(rect: CGRect): number;

  // export function CGRectInset(rect: CGRect, dx: number, dy: number): CGRect;

  // export function CGRectIntegral(rect: CGRect): CGRect;

  // export function CGRectIntersection(r1: CGRect, r2: CGRect): CGRect;

  // export function CGRectIntersectsRect(rect1: CGRect, rect2: CGRect): boolean;

  // export function CGRectIsEmpty(rect: CGRect): boolean;

  // export function CGRectIsInfinite(rect: CGRect): boolean;

  // export function CGRectIsNull(rect: CGRect): boolean;

  // export function CGRectMake(x: number, y: number, width: number, height: number): CGRect;

  // export function CGRectMakeWithDictionaryRepresentation(dict: Map<any, any>, rect: NSRect): boolean;

  // export function CGRectOffset(rect: CGRect, dx: number, dy: number): CGRect;

  // export function CGRectStandardize(rect: CGRect): CGRect;

  // export function CGRectUnion(r1: CGRect, r2: CGRect): CGRect;

  // export function CGReleaseAllDisplays(): CGError;

  // export function CGReleaseDisplayFadeReservation(token: number): CGError;

  // export function CGRestorePermanentDisplayConfiguration(): void;

  // export function CGSessionCopyCurrentDictionary(): Map<any, any>;

  // export function CGSetDisplayTransferByByteTable(display: number, tableSize: number, redTable: string | any, greenTable: string | any, blueTable: string | any): CGError;

  // export function CGSetDisplayTransferByFormula(display: number, redMin: number, redMax: number, redGamma: number, greenMin: number, greenMax: number, greenGamma: number, blueMin: number, blueMax: number, blueGamma: number): CGError;

  // export function CGSetDisplayTransferByTable(display: number, tableSize: number, redTable: number, greenTable: number, blueTable: number): CGError;

  // export function CGShadingCreateAxial(space: any, start: CGPoint, end: CGPoint, function_: any, extendStart: boolean, extendEnd: boolean): any;

  // export function CGShadingCreateRadial(space: any, start: CGPoint, startRadius: number, end: CGPoint, endRadius: number, function_: any, extendStart: boolean, extendEnd: boolean): any;

  // export function typeID(): number;

  // export function CGShadingRelease(shading: any): void;

  // export function CGShadingRetain(shading: any): any;

  // export function CGShieldingWindowID(display: number): number;

  // export function CGShieldingWindowLevel(): number;

  // export function CGSizeApplyAffineTransform(size: CGSize, t: CGAffineTransform): CGSize;

  // export function CGSizeCreateDictionaryRepresentation(size: CGSize): Map<any, any>;

  // export function CGSizeEqualToSize(size1: CGSize, size2: CGSize): boolean;

  // export function CGSizeMake(width: number, height: number): CGSize;

  // export function CGSizeMakeWithDictionaryRepresentation(dict: Map<any, any>, size: NSSize): boolean;

  // export function CGVectorMake(dx: number, dy: number): CGVector;

  // export function CGWarpMouseCursorPosition(newCursorPosition: CGPoint): CGError;

  // export function CGWindowLevelForKey(key: CGWindowLevelKey): number;

  // export function CGWindowListCopyWindowInfo(option: CGWindowListOption, relativeToWindow: number): any[];

  // export function CGWindowListCreateDescriptionFromArray(windowArray: any[]): any[];

  // export function CGWindowListCreateImage(screenBounds: CGRect, listOption: CGWindowListOption, windowID: number, imageOption: CGWindowImageOption): any;

  // export function CGWindowListCreateImageFromArray(screenBounds: CGRect, windowArray: any[], imageOption: CGWindowImageOption): any;

  // export function CGWindowServerCreateServerPort(): NSMachPort;

  interface CIAccordionFoldTransition extends CITransitionFilter {
    bottomHeight: number;
    setBottomHeight(_: number)
    foldShadowAmount: number;
    setFoldShadowAmount(_: number)
    numberOfFolds: number;
    setNumberOfFolds(_: number)
  }

  interface CIAffineClamp extends CIFilter {
    inputImage: CIImage;
    setInputImage(_: CIImage)
    transform: CGAffineTransform;
    setTransform(_: CGAffineTransform)
  }

  interface CIAffineTile extends CIFilter {
    inputImage: CIImage;
    setInputImage(_: CIImage)
    transform: CGAffineTransform;
    setTransform(_: CGAffineTransform)
  }

  interface CIAttributedTextImageGenerator extends CIFilter {
    scaleFactor: number;
    setScaleFactor(_: number)
    text: NSAttributedString;
    setText(_: NSAttributedString)
  }

  // interface
  class CIAztecCodeDescriptor extends CIBarcodeDescriptor {
    static descriptorWithPayloadIsCompactLayerCountDataCodewordCount(payload: NSData, isCompact: boolean, layerCount: number, dataCodewordCount: number): CIAztecCodeDescriptor;
    dataCodewordCount: number;
    errorCorrectedPayload: NSData;
    isCompact: boolean;
    layerCount: number;
    static createWithPayloadIsCompactLayerCountDataCodewordCount(payload: NSData, isCompact: boolean, layerCount: number, dataCodewordCount: number): CIAztecCodeDescriptor;
  }

  interface CIAztecCodeGenerator extends CIFilter {
    compactStyle: number;
    setCompactStyle(_: number)
    correctionLevel: number;
    setCorrectionLevel(_: number)
    layers: number;
    setLayers(_: number)
    message: NSData;
    setMessage(_: NSData)
  }

  // interface
  class CIBarcodeDescriptor extends NSObject /* implements NSCopying, NSSecureCoding */ {
  }

  interface CIBarcodeGenerator extends CIFilter {
    barcodeDescriptor: CIBarcodeDescriptor;
    setBarcodeDescriptor(_: CIBarcodeDescriptor)
  }

  interface CIBarsSwipeTransition extends CITransitionFilter {
    angle: number;
    setAngle(_: number)
    barOffset: number;
    setBarOffset(_: number)
    width: number;
    setWidth(_: number)
  }

  interface CIBicubicScaleTransform extends CIFilter {
    aspectRatio: number;
    setAspectRatio(_: number)
    inputImage: CIImage;
    setInputImage(_: CIImage)
    parameterB: number;
    setParameterB(_: number)
    parameterC: number;
    setParameterC(_: number)
    scale: number;
    setScale(_: number)
  }

  // interface
  class CIBlendKernel extends CIColorKernel {
    static clear: CIBlendKernel;
    static color: CIBlendKernel;
    static colorBurn: CIBlendKernel;
    static colorDodge: CIBlendKernel;
    static componentAdd: CIBlendKernel;
    static componentMax: CIBlendKernel;
    static componentMin: CIBlendKernel;
    static componentMultiply: CIBlendKernel;
    static darken: CIBlendKernel;
    static darkerColor: CIBlendKernel;
    static destination: CIBlendKernel;
    static destinationAtop: CIBlendKernel;
    static destinationIn: CIBlendKernel;
    static destinationOut: CIBlendKernel;
    static destinationOver: CIBlendKernel;
    static difference: CIBlendKernel;
    static divide: CIBlendKernel;
    static exclusion: CIBlendKernel;
    static exclusiveOr: CIBlendKernel;
    static hardLight: CIBlendKernel;
    static hardMix: CIBlendKernel;
    static hue: CIBlendKernel;
    static lighten: CIBlendKernel;
    static lighterColor: CIBlendKernel;
    static linearBurn: CIBlendKernel;
    static linearDodge: CIBlendKernel;
    static linearLight: CIBlendKernel;
    static luminosity: CIBlendKernel;
    static multiply: CIBlendKernel;
    static overlay: CIBlendKernel;
    static pinLight: CIBlendKernel;
    static saturation: CIBlendKernel;
    static screen: CIBlendKernel;
    static softLight: CIBlendKernel;
    static source: CIBlendKernel;
    static sourceAtop: CIBlendKernel;
    static sourceIn: CIBlendKernel;
    static sourceOut: CIBlendKernel;
    static sourceOver: CIBlendKernel;
    static subtract: CIBlendKernel;
    static vividLight: CIBlendKernel;
    applyWithForegroundBackground(foreground: CIImage, background: CIImage): CIImage;
    applyWithForegroundBackgroundColorSpace(foreground: CIImage, background: CIImage, colorSpace: any): CIImage;
  }

  interface CIBlendWithMask extends CIFilter {
    backgroundImage: CIImage;
    setBackgroundImage(_: CIImage)
    inputImage: CIImage;
    setInputImage(_: CIImage)
    maskImage: CIImage;
    setMaskImage(_: CIImage)
  }

  interface CIBloom extends CIFilter {
    inputImage: CIImage;
    setInputImage(_: CIImage)
    intensity: number;
    setIntensity(_: number)
    radius: number;
    setRadius(_: number)
  }

  interface CIBokehBlur extends CIFilter {
    inputImage: CIImage;
    setInputImage(_: CIImage)
    radius: number;
    setRadius(_: number)
    ringAmount: number;
    setRingAmount(_: number)
    ringSize: number;
    setRingSize(_: number)
    softness: number;
    setSoftness(_: number)
  }

  interface CIBoxBlur extends CIFilter {
    inputImage: CIImage;
    setInputImage(_: CIImage)
    radius: number;
    setRadius(_: number)
  }

  interface CICMYKHalftone extends CIFilter {
    angle: number;
    setAngle(_: number)
    center: CGPoint;
    setCenter(_: CGPoint)
    grayComponentReplacement: number;
    setGrayComponentReplacement(_: number)
    inputImage: CIImage;
    setInputImage(_: CIImage)
    sharpness: number;
    setSharpness(_: number)
    underColorRemoval: number;
    setUnderColorRemoval(_: number)
    width: number;
    setWidth(_: number)
  }

  interface CICheckerboardGenerator extends CIFilter {
    center: CGPoint;
    setCenter(_: CGPoint)
    color0: CIColor;
    setColor0(_: CIColor)
    color1: CIColor;
    setColor1(_: CIColor)
    sharpness: number;
    setSharpness(_: number)
    width: number;
    setWidth(_: number)
  }

  interface CICircularScreen extends CIFilter {
    center: CGPoint;
    setCenter(_: CGPoint)
    inputImage: CIImage;
    setInputImage(_: CIImage)
    sharpness: number;
    setSharpness(_: number)
    width: number;
    setWidth(_: number)
  }

  interface CICode128BarcodeGenerator extends CIFilter {
    barcodeHeight: number;
    setBarcodeHeight(_: number)
    message: NSData;
    setMessage(_: NSData)
    quietSpace: number;
    setQuietSpace(_: number)
  }

  // interface
  class CIColor extends NSObject /* implements NSCopying, NSSecureCoding */ {
    alpha: number;
    blue: number;
    colorSpace: any;
    components: number;
    green: number;
    numberOfComponents: number;
    red: number;
    stringRepresentation: string;
    static blackColor: CIColor;
    static blueColor: CIColor;
    static clearColor: CIColor;
    static cyanColor: CIColor;
    static grayColor: CIColor;
    static greenColor: CIColor;
    static magentaColor: CIColor;
    static redColor: CIColor;
    static whiteColor: CIColor;
    static yellowColor: CIColor;
    static createWithCGColor(CGColor: any): CIColor;
    static createWithColor(color: NSColor): CIColor;
    static createWithRedGreenBlue(red: number, green: number, blue: number): CIColor;
    static createWithRedGreenBlueAlpha(red: number, green: number, blue: number, alpha: number): CIColor;
    static createWithRedGreenBlueAlphaColorSpace(red: number, green: number, blue: number, alpha: number, colorSpace: any): CIColor;
    static createWithRedGreenBlueColorSpace(red: number, green: number, blue: number, colorSpace: any): CIColor;
  }

  interface CIColorClamp extends CIFilter {
    inputImage: CIImage;
    setInputImage(_: CIImage)
    maxComponents: CIVector;
    setMaxComponents(_: CIVector)
    minComponents: CIVector;
    setMinComponents(_: CIVector)
  }

  interface CIColorControls extends CIFilter {
    brightness: number;
    setBrightness(_: number)
    contrast: number;
    setContrast(_: number)
    inputImage: CIImage;
    setInputImage(_: CIImage)
    saturation: number;
    setSaturation(_: number)
  }

  interface CIColorCrossPolynomial extends CIFilter {
    blueCoefficients: CIVector;
    setBlueCoefficients(_: CIVector)
    greenCoefficients: CIVector;
    setGreenCoefficients(_: CIVector)
    inputImage: CIImage;
    setInputImage(_: CIImage)
    redCoefficients: CIVector;
    setRedCoefficients(_: CIVector)
  }

  interface CIColorCube extends CIFilter {
    cubeData: NSData;
    setCubeData(_: NSData)
    cubeDimension: number;
    setCubeDimension(_: number)
    inputImage: CIImage;
    setInputImage(_: CIImage)
  }

  interface CIColorCubeWithColorSpace extends CIFilter {
    colorSpace: any;
    setColorSpace(_: any)
    cubeData: NSData;
    setCubeData(_: NSData)
    cubeDimension: number;
    setCubeDimension(_: number)
    inputImage: CIImage;
    setInputImage(_: CIImage)
  }

  interface CIColorCubesMixedWithMask extends CIFilter {
    colorSpace: any;
    setColorSpace(_: any)
    cube0Data: NSData;
    setCube0Data(_: NSData)
    cube1Data: NSData;
    setCube1Data(_: NSData)
    cubeDimension: number;
    setCubeDimension(_: number)
    inputImage: CIImage;
    setInputImage(_: CIImage)
    maskImage: CIImage;
    setMaskImage(_: CIImage)
  }

  interface CIColorCurves extends CIFilter {
    colorSpace: any;
    setColorSpace(_: any)
    curvesData: NSData;
    setCurvesData(_: NSData)
    curvesDomain: CIVector;
    setCurvesDomain(_: CIVector)
    inputImage: CIImage;
    setInputImage(_: CIImage)
  }

  interface CIColorInvert extends CIFilter {
    inputImage: CIImage;
    setInputImage(_: CIImage)
  }

  // interface
  class CIColorKernel extends CIKernel {
    applyWithExtentArguments(extent: CGRect, arguments_?: any[]): CIImage;
  }

  interface CIColorMap extends CIFilter {
    gradientImage: CIImage;
    setGradientImage(_: CIImage)
    inputImage: CIImage;
    setInputImage(_: CIImage)
  }

  interface CIColorMatrix extends CIFilter {
    AVector: CIVector;
    setAVector(_: CIVector)
    biasVector: CIVector;
    setBiasVector(_: CIVector)
    BVector: CIVector;
    setBVector(_: CIVector)
    GVector: CIVector;
    setGVector(_: CIVector)
    inputImage: CIImage;
    setInputImage(_: CIImage)
    RVector: CIVector;
    setRVector(_: CIVector)
  }

  interface CIColorMonochrome extends CIFilter {
    color: CIColor;
    setColor(_: CIColor)
    inputImage: CIImage;
    setInputImage(_: CIImage)
    intensity: number;
    setIntensity(_: number)
  }

  interface CIColorPolynomial extends CIFilter {
    alphaCoefficients: CIVector;
    setAlphaCoefficients(_: CIVector)
    blueCoefficients: CIVector;
    setBlueCoefficients(_: CIVector)
    greenCoefficients: CIVector;
    setGreenCoefficients(_: CIVector)
    inputImage: CIImage;
    setInputImage(_: CIImage)
    redCoefficients: CIVector;
    setRedCoefficients(_: CIVector)
  }

  interface CIColorPosterize extends CIFilter {
    inputImage: CIImage;
    setInputImage(_: CIImage)
    levels: number;
    setLevels(_: number)
  }

  interface CIComicEffect extends CIFilter {
    inputImage: CIImage;
    setInputImage(_: CIImage)
  }

  interface CICompositeOperation extends CIFilter {
    backgroundImage: CIImage;
    setBackgroundImage(_: CIImage)
    inputImage: CIImage;
    setInputImage(_: CIImage)
  }

  // interface
  class CIContext extends NSObject {
    static offlineGPUCount(): number;
    workingColorSpace: any;
    workingFormat: number;
    HEIFRepresentationOfImageFormatColorSpaceOptions(of: CIImage, format: number, colorSpace: any, options: Map<string, any>): NSData;
    JPEGRepresentationOfImageColorSpaceOptions(of: CIImage, colorSpace: any, options: Map<string, any>): NSData;
    PNGRepresentationOfImageFormatColorSpaceOptions(of: CIImage, format: number, colorSpace: any, options: Map<string, any>): NSData;
    TIFFRepresentationOfImageFormatColorSpaceOptions(of: CIImage, format: number, colorSpace: any, options: Map<string, any>): NSData;
    clearCaches(): void;
    createCGImageFromRect(_: CIImage, from: CGRect): any;
    createCGImageFromRectFormatColorSpace(_: CIImage, from: CGRect, format: number, colorSpace?: any): any;
    createCGImageFromRectFormatColorSpaceDeferred(_: CIImage, from: CGRect, format: number, colorSpace?: any, deferred?: boolean): any;
    depthBlurEffectFilterForImageDisparityImagePortraitEffectsMatteHairSemanticSegmentationOrientationOptions(for_: CIImage, disparityImage: CIImage, portraitEffectsMatte?: CIImage, hairSemanticSegmentation?: CIImage, orientation?: CGImagePropertyOrientation, options?: Map<any, any>): CIFilter;
    depthBlurEffectFilterForImageDisparityImagePortraitEffectsMatteOrientationOptions(for_: CIImage, disparityImage: CIImage, portraitEffectsMatte?: CIImage, orientation?: CGImagePropertyOrientation, options?: Map<any, any>): CIFilter;
    depthBlurEffectFilterForImageDataOptions(forImageData: NSData, options?: Map<any, any>): CIFilter;
    depthBlurEffectFilterForImageURLOptions(forImageURL: NSURL, options?: Map<any, any>): CIFilter;
    drawImageInRectFromRect(_: CIImage, in_: CGRect, from: CGRect): void;
    static createWithOptions(options?: Map<string, any>): CIContext;
    prepareRenderFromRectToDestinationAtPointError(fromRect: CIImage, toDestination: CGRect, atPoint: CIRenderDestination, error: CGPoint): boolean;
    reclaimResources(): void;
    renderToBitmapRowBytesBoundsFormatColorSpace(_: CIImage, toBitmap: any, rowBytes: number, bounds: CGRect, format: number, colorSpace?: any): void;
    renderToCVPixelBuffer(_: CIImage, to: any): void;
    renderToCVPixelBufferBoundsColorSpace(_: CIImage, to: any, bounds: CGRect, colorSpace?: any): void;
    renderToIOSurfaceBoundsColorSpace(_: CIImage, to: any, bounds: CGRect, colorSpace?: any): void;
    // renderToMTLTextureCommandBufferBoundsColorSpace(_: CIImage, to: MTLTexture, commandBuffer?: MTLCommandBuffer, bounds?: CGRect, colorSpace?: any): void;
    startTaskToClearError(error: CIRenderDestination): CIRenderTask;
    startTaskToRenderFromRectToDestinationAtPointError(fromRect: CIImage, toDestination: CGRect, atPoint: CIRenderDestination, error: CGPoint): CIRenderTask;
    startTaskToRenderToDestinationError(toDestination: CIImage, error: CIRenderDestination): CIRenderTask;
    writeHEIFRepresentationOfImageToURLFormatColorSpaceOptionsError(toURL: CIImage, format: NSURL, colorSpace: number, options: any, error: Map<string, any>): boolean;
    writeJPEGRepresentationOfImageToURLColorSpaceOptionsError(toURL: CIImage, colorSpace: NSURL, options: any, error: Map<string, any>): boolean;
    writePNGRepresentationOfImageToURLFormatColorSpaceOptionsError(toURL: CIImage, format: NSURL, colorSpace: number, options: any, error: Map<string, any>): boolean;
    writeTIFFRepresentationOfImageToURLFormatColorSpaceOptionsError(toURL: CIImage, format: NSURL, colorSpace: number, options: any, error: Map<string, any>): boolean;
  }

  interface CIConvolution extends CIFilter {
    bias: number;
    setBias(_: number)
    inputImage: CIImage;
    setInputImage(_: CIImage)
    weights: CIVector;
    setWeights(_: CIVector)
  }

  interface CICopyMachineTransition extends CITransitionFilter {
    angle: number;
    setAngle(_: number)
    color: CIColor;
    setColor(_: CIColor)
    extent: CGRect;
    setExtent(_: CGRect)
    opacity: number;
    setOpacity(_: number)
    width: number;
    setWidth(_: number)
  }

  interface CICoreMLModel extends CIFilter {
    headIndex: number;
    setHeadIndex(_: number)
    inputImage: CIImage;
    setInputImage(_: CIImage)
    model: MLModel;
    setModel(_: MLModel)
    softmaxNormalization: boolean;
    setSoftmaxNormalization(_: boolean)
  }

  interface CICrystallize extends CIFilter {
    center: CGPoint;
    setCenter(_: CGPoint)
    inputImage: CIImage;
    setInputImage(_: CIImage)
    radius: number;
    setRadius(_: number)
  }

  // interface
  class CIDataMatrixCodeDescriptor extends CIBarcodeDescriptor {
    static descriptorWithPayloadRowCountColumnCountEccVersion(payload: NSData, rowCount: number, columnCount: number, eccVersion: CIDataMatrixCodeECCVersion): CIDataMatrixCodeDescriptor;
    columnCount: number;
    eccVersion: CIDataMatrixCodeECCVersion;
    errorCorrectedPayload: NSData;
    rowCount: number;
    static createWithPayloadRowCountColumnCountEccVersion(payload: NSData, rowCount: number, columnCount: number, eccVersion: CIDataMatrixCodeECCVersion): CIDataMatrixCodeDescriptor;
  }

  interface CIDepthOfField extends CIFilter {
    inputImage: CIImage;
    setInputImage(_: CIImage)
    point0: CGPoint;
    setPoint0(_: CGPoint)
    point1: CGPoint;
    setPoint1(_: CGPoint)
    radius: number;
    setRadius(_: number)
    saturation: number;
    setSaturation(_: number)
    unsharpMaskIntensity: number;
    setUnsharpMaskIntensity(_: number)
    unsharpMaskRadius: number;
    setUnsharpMaskRadius(_: number)
  }

  interface CIDepthToDisparity extends CIFilter {
    inputImage: CIImage;
    setInputImage(_: CIImage)
  }

  // interface
  class CIDetector extends NSObject {
    featuresInImage(in_: CIImage): CIFeature[];
    featuresInImageOptions(in_: CIImage, options?: Map<string, any>): CIFeature[];
  }

  interface CIDiscBlur extends CIFilter {
    inputImage: CIImage;
    setInputImage(_: CIImage)
    radius: number;
    setRadius(_: number)
  }

  interface CIDisintegrateWithMaskTransition extends CITransitionFilter {
    maskImage: CIImage;
    setMaskImage(_: CIImage)
    shadowDensity: number;
    setShadowDensity(_: number)
    shadowOffset: CGPoint;
    setShadowOffset(_: CGPoint)
    shadowRadius: number;
    setShadowRadius(_: number)
  }

  interface CIDisparityToDepth extends CIFilter {
    inputImage: CIImage;
    setInputImage(_: CIImage)
  }

  type CIDissolveTransition = CITransitionFilter

  interface CIDither extends CIFilter {
    inputImage: CIImage;
    setInputImage(_: CIImage)
    intensity: number;
    setIntensity(_: number)
  }

  interface CIDocumentEnhancer extends CIFilter {
    amount: number;
    setAmount(_: number)
    inputImage: CIImage;
    setInputImage(_: CIImage)
  }

  interface CIDotScreen extends CIFilter {
    angle: number;
    setAngle(_: number)
    center: CGPoint;
    setCenter(_: CGPoint)
    inputImage: CIImage;
    setInputImage(_: CIImage)
    sharpness: number;
    setSharpness(_: number)
    width: number;
    setWidth(_: number)
  }

  interface CIEdgePreserveUpsample extends CIFilter {
    inputImage: CIImage;
    setInputImage(_: CIImage)
    lumaSigma: number;
    setLumaSigma(_: number)
    smallImage: CIImage;
    setSmallImage(_: CIImage)
    spatialSigma: number;
    setSpatialSigma(_: number)
  }

  interface CIEdgeWork extends CIFilter {
    inputImage: CIImage;
    setInputImage(_: CIImage)
    radius: number;
    setRadius(_: number)
  }

  interface CIEdges extends CIFilter {
    inputImage: CIImage;
    setInputImage(_: CIImage)
    intensity: number;
    setIntensity(_: number)
  }

  interface CIEightfoldReflectedTile extends CIFilter {
    angle: number;
    setAngle(_: number)
    center: CGPoint;
    setCenter(_: CGPoint)
    inputImage: CIImage;
    setInputImage(_: CIImage)
    width: number;
    setWidth(_: number)
  }

  interface CIExposureAdjust extends CIFilter {
    EV: number;
    setEV(_: number)
    inputImage: CIImage;
    setInputImage(_: CIImage)
  }

  // interface
  class CIFaceFeature extends CIFeature {
    faceAngle: number;
    hasFaceAngle: boolean;
    hasLeftEyePosition: boolean;
    hasMouthPosition: boolean;
    hasRightEyePosition: boolean;
    hasSmile: boolean;
    hasTrackingFrameCount: boolean;
    hasTrackingID: boolean;
    leftEyeClosed: boolean;
    leftEyePosition: CGPoint;
    mouthPosition: CGPoint;
    rightEyeClosed: boolean;
    rightEyePosition: CGPoint;
    trackingFrameCount: number;
    trackingID: number;
  }

  interface CIFalseColor extends CIFilter {
    color0: CIColor;
    setColor0(_: CIColor)
    color1: CIColor;
    setColor1(_: CIColor)
    inputImage: CIImage;
    setInputImage(_: CIImage)
  }

  // interface
  class CIFeature extends NSObject {
    bounds: CGRect;
    type: string;
  }

  // interface
  class CIFilter extends NSObject /* implements NSCopying, NSSecureCoding */ {
    static CMYKHalftone(): CIFilter;
    static LabDeltaE(): CIFilter;
    static PDF417BarcodeGenerator(): CIFilter;
    static QRCodeGenerator(): CIFilter;
    static accordionFoldTransitionFilter(): CIFilter;
    static additionCompositingFilter(): CIFilter;
    static affineClampFilter(): CIFilter;
    static affineTileFilter(): CIFilter;
    static attributedTextImageGeneratorFilter(): CIFilter;
    static aztecCodeGeneratorFilter(): CIFilter;
    static barcodeGeneratorFilter(): CIFilter;
    static barsSwipeTransitionFilter(): CIFilter;
    static bicubicScaleTransformFilter(): CIFilter;
    static blendWithAlphaMaskFilter(): CIFilter;
    static blendWithBlueMaskFilter(): CIFilter;
    static blendWithMaskFilter(): CIFilter;
    static blendWithRedMaskFilter(): CIFilter;
    static bloomFilter(): CIFilter;
    static bokehBlurFilter(): CIFilter;
    static boxBlurFilter(): CIFilter;
    static checkerboardGeneratorFilter(): CIFilter;
    static circularScreenFilter(): CIFilter;
    static code128BarcodeGeneratorFilter(): CIFilter;
    static colorBlendModeFilter(): CIFilter;
    static colorBurnBlendModeFilter(): CIFilter;
    static colorClampFilter(): CIFilter;
    static colorControlsFilter(): CIFilter;
    static colorCrossPolynomialFilter(): CIFilter;
    static colorCubeFilter(): CIFilter;
    static colorCubeWithColorSpaceFilter(): CIFilter;
    static colorCubesMixedWithMaskFilter(): CIFilter;
    static colorCurvesFilter(): CIFilter;
    static colorDodgeBlendModeFilter(): CIFilter;
    static colorInvertFilter(): CIFilter;
    static colorMapFilter(): CIFilter;
    static colorMatrixFilter(): CIFilter;
    static colorMonochromeFilter(): CIFilter;
    static colorPolynomialFilter(): CIFilter;
    static colorPosterizeFilter(): CIFilter;
    static comicEffectFilter(): CIFilter;
    static convolution3X3Filter(): CIFilter;
    static convolution5X5Filter(): CIFilter;
    static convolution7X7Filter(): CIFilter;
    static convolution9HorizontalFilter(): CIFilter;
    static convolution9VerticalFilter(): CIFilter;
    static copyMachineTransitionFilter(): CIFilter;
    static coreMLModelFilter(): CIFilter;
    static crystallizeFilter(): CIFilter;
    static darkenBlendModeFilter(): CIFilter;
    static depthOfFieldFilter(): CIFilter;
    static depthToDisparityFilter(): CIFilter;
    static differenceBlendModeFilter(): CIFilter;
    static discBlurFilter(): CIFilter;
    static disintegrateWithMaskTransitionFilter(): CIFilter;
    static disparityToDepthFilter(): CIFilter;
    static dissolveTransitionFilter(): CIFilter;
    static ditherFilter(): CIFilter;
    static divideBlendModeFilter(): CIFilter;
    static documentEnhancerFilter(): CIFilter;
    static dotScreenFilter(): CIFilter;
    static edgePreserveUpsampleFilter(): CIFilter;
    static edgeWorkFilter(): CIFilter;
    static edgesFilter(): CIFilter;
    static eightfoldReflectedTileFilter(): CIFilter;
    static exclusionBlendModeFilter(): CIFilter;
    static exposureAdjustFilter(): CIFilter;
    static falseColorFilter(): CIFilter;
    static filterArrayFromSerializedXMPInputImageExtentError(fromSerializedXMP: NSData, inputImageExtent: CGRect): CIFilter[];
    static filterNamesInCategories(inCategories?: string[]): string[];
    static filterNamesInCategory(inCategory?: string): string[];
    static flashTransitionFilter(): CIFilter;
    static fourfoldReflectedTileFilter(): CIFilter;
    static fourfoldRotatedTileFilter(): CIFilter;
    static fourfoldTranslatedTileFilter(): CIFilter;
    static gaborGradientsFilter(): CIFilter;
    static gammaAdjustFilter(): CIFilter;
    static gaussianBlurFilter(): CIFilter;
    static gaussianGradientFilter(): CIFilter;
    static glideReflectedTileFilter(): CIFilter;
    static gloomFilter(): CIFilter;
    static hardLightBlendModeFilter(): CIFilter;
    static hatchedScreenFilter(): CIFilter;
    static heightFieldFromMaskFilter(): CIFilter;
    static hexagonalPixellateFilter(): CIFilter;
    static highlightShadowAdjustFilter(): CIFilter;
    static hueAdjustFilter(): CIFilter;
    static hueBlendModeFilter(): CIFilter;
    static hueSaturationValueGradientFilter(): CIFilter;
    static kaleidoscopeFilter(): CIFilter;
    static keystoneCorrectionCombinedFilter(): CIFilter;
    static keystoneCorrectionHorizontalFilter(): CIFilter;
    static keystoneCorrectionVerticalFilter(): CIFilter;
    static lanczosScaleTransformFilter(): CIFilter;
    static lenticularHaloGeneratorFilter(): CIFilter;
    static lightenBlendModeFilter(): CIFilter;
    static lineOverlayFilter(): CIFilter;
    static lineScreenFilter(): CIFilter;
    static linearBurnBlendModeFilter(): CIFilter;
    static linearDodgeBlendModeFilter(): CIFilter;
    static linearGradientFilter(): CIFilter;
    static linearToSRGBToneCurveFilter(): CIFilter;
    static localizedDescriptionForFilterName(forFilterName: string): string;
    static localizedNameForCategory(forCategory: string): string;
    static localizedNameForFilterName(forFilterName: string): string;
    static localizedReferenceDocumentationForFilterName(forFilterName: string): NSURL;
    static luminosityBlendModeFilter(): CIFilter;
    static maskToAlphaFilter(): CIFilter;
    static maskedVariableBlurFilter(): CIFilter;
    static maximumComponentFilter(): CIFilter;
    static maximumCompositingFilter(): CIFilter;
    static medianFilter(): CIFilter;
    static meshGeneratorFilter(): CIFilter;
    static minimumComponentFilter(): CIFilter;
    static minimumCompositingFilter(): CIFilter;
    static mixFilter(): CIFilter;
    static modTransitionFilter(): CIFilter;
    static morphologyGradientFilter(): CIFilter;
    static morphologyMaximumFilter(): CIFilter;
    static morphologyMinimumFilter(): CIFilter;
    static morphologyRectangleMaximumFilter(): CIFilter;
    static morphologyRectangleMinimumFilter(): CIFilter;
    static motionBlurFilter(): CIFilter;
    static multiplyBlendModeFilter(): CIFilter;
    static multiplyCompositingFilter(): CIFilter;
    static noiseReductionFilter(): CIFilter;
    static opTileFilter(): CIFilter;
    static overlayBlendModeFilter(): CIFilter;
    static pageCurlTransitionFilter(): CIFilter;
    static pageCurlWithShadowTransitionFilter(): CIFilter;
    static paletteCentroidFilter(): CIFilter;
    static palettizeFilter(): CIFilter;
    static parallelogramTileFilter(): CIFilter;
    static perspectiveCorrectionFilter(): CIFilter;
    static perspectiveRotateFilter(): CIFilter;
    static perspectiveTileFilter(): CIFilter;
    static perspectiveTransformFilter(): CIFilter;
    static perspectiveTransformWithExtentFilter(): CIFilter;
    static photoEffectChromeFilter(): CIFilter;
    static photoEffectFadeFilter(): CIFilter;
    static photoEffectInstantFilter(): CIFilter;
    static photoEffectMonoFilter(): CIFilter;
    static photoEffectNoirFilter(): CIFilter;
    static photoEffectProcessFilter(): CIFilter;
    static photoEffectTonalFilter(): CIFilter;
    static photoEffectTransferFilter(): CIFilter;
    static pinLightBlendModeFilter(): CIFilter;
    static pixellateFilter(): CIFilter;
    static pointillizeFilter(): CIFilter;
    static radialGradientFilter(): CIFilter;
    static randomGeneratorFilter(): CIFilter;
    static registerFilterNameConstructorClassAttributes(_: string, constructor: CIFilterConstructor, classAttributes: Map<string, any>): void;
    static rippleTransitionFilter(): CIFilter;
    static roundedRectangleGeneratorFilter(): CIFilter;
    static sRGBToneCurveToLinearFilter(): CIFilter;
    static saliencyMapFilter(): CIFilter;
    static saturationBlendModeFilter(): CIFilter;
    static screenBlendModeFilter(): CIFilter;
    static sepiaToneFilter(): CIFilter;
    static serializedXMPFromFiltersInputImageExtent(from: CIFilter[], inputImageExtent: CGRect): NSData;
    static shadedMaterialFilter(): CIFilter;
    static sharpenLuminanceFilter(): CIFilter;
    static sixfoldReflectedTileFilter(): CIFilter;
    static sixfoldRotatedTileFilter(): CIFilter;
    static smoothLinearGradientFilter(): CIFilter;
    static softLightBlendModeFilter(): CIFilter;
    static sourceAtopCompositingFilter(): CIFilter;
    static sourceInCompositingFilter(): CIFilter;
    static sourceOutCompositingFilter(): CIFilter;
    static sourceOverCompositingFilter(): CIFilter;
    static spotColorFilter(): CIFilter;
    static spotLightFilter(): CIFilter;
    static starShineGeneratorFilter(): CIFilter;
    static straightenFilter(): CIFilter;
    static stripesGeneratorFilter(): CIFilter;
    static subtractBlendModeFilter(): CIFilter;
    static sunbeamsGeneratorFilter(): CIFilter;
    static supportedRawCameraModels(): string[];
    static swipeTransitionFilter(): CIFilter;
    static temperatureAndTintFilter(): CIFilter;
    static textImageGeneratorFilter(): CIFilter;
    static thermalFilter(): CIFilter;
    static toneCurveFilter(): CIFilter;
    static triangleKaleidoscopeFilter(): CIFilter;
    static triangleTileFilter(): CIFilter;
    static twelvefoldReflectedTileFilter(): CIFilter;
    static unsharpMaskFilter(): CIFilter;
    static vibranceFilter(): CIFilter;
    static vignetteEffectFilter(): CIFilter;
    static vignetteFilter(): CIFilter;
    static whitePointAdjustFilter(): CIFilter;
    static xRayFilter(): CIFilter;
    static zoomBlurFilter(): CIFilter;
    attributes: Map<string, any>;
    isEnabled: boolean;
    setEnabled(_: boolean)
    inputKeys: string[];
    name: string;
    setName(_: string)
    outputImage: CIImage;
    outputKeys: string[];
    applyArgumentsOptions(_: CIKernel, arguments_?: any[], options?: Map<string, any>): CIImage;
    setDefaults(): void;
    setName(_: string): void;
    viewForUIConfigurationExcludedKeys(_: Map<any, any>, excludedKeys: any[]): IKFilterUIView;
  }

  interface CIFilterConstructor {
    // instance method
    filterWithName(withName: string): CIFilter;
  }

  // interface
  class CIFilterGenerator extends NSObject /* implements CIFilterConstructor, NSCopying, NSSecureCoding */ {
    classAttributes: Map<any, any>;
    setClassAttributes(_: Map<any, any>)
    exportedKeys: Map<any, any>;
    connectObjectWithKeyToObjectWithKey(_: any, withKey?: string, to?: any, withKey2?: string): void;
    disconnectObjectWithKeyToObjectWithKey(_: any, withKey: string, to: any, withKey2: string): void;
    exportKeyFromObjectWithName(_: string, from: any, withName?: string): void;
    filter(): CIFilter;
    static createWithContentsOfURL(contentsOfURL: NSURL): CIFilterGenerator;
    registerFilterName(_: string): void;
    removeExportedKey(_: string): void;
    setAttributesForExportedKey(_: Map<any, any>, forExportedKey: string): void;
    writeToURLAtomically(to: NSURL, atomically: boolean): boolean;
  }

  interface CIFilter {
    outputImage: CIImage;
  }

  // interface
  class CIFilterShape extends NSObject /* implements NSCopying */ {
    extent: CGRect;
    static createWithRect(rect: CGRect): CIFilterShape;
    insetByXY(x: number, y: number): CIFilterShape;
    intersectWith(with_: CIFilterShape): CIFilterShape;
    intersectWithRect(with_: CGRect): CIFilterShape;
    transformByInterior(by: CGAffineTransform, interior: boolean): CIFilterShape;
    unionWith(with_: CIFilterShape): CIFilterShape;
    unionWithRect(with_: CGRect): CIFilterShape;
  }

  interface CIFlashTransition extends CITransitionFilter {
    center: CGPoint;
    setCenter(_: CGPoint)
    color: CIColor;
    setColor(_: CIColor)
    extent: CGRect;
    setExtent(_: CGRect)
    fadeThreshold: number;
    setFadeThreshold(_: number)
    maxStriationRadius: number;
    setMaxStriationRadius(_: number)
    striationContrast: number;
    setStriationContrast(_: number)
    striationStrength: number;
    setStriationStrength(_: number)
  }

  interface CIFourCoordinateGeometryFilter extends CIFilter {
    bottomLeft: CGPoint;
    setBottomLeft(_: CGPoint)
    bottomRight: CGPoint;
    setBottomRight(_: CGPoint)
    inputImage: CIImage;
    setInputImage(_: CIImage)
    topLeft: CGPoint;
    setTopLeft(_: CGPoint)
    topRight: CGPoint;
    setTopRight(_: CGPoint)
  }

  interface CIFourfoldReflectedTile extends CIFilter {
    acuteAngle: number;
    setAcuteAngle(_: number)
    angle: number;
    setAngle(_: number)
    center: CGPoint;
    setCenter(_: CGPoint)
    inputImage: CIImage;
    setInputImage(_: CIImage)
    width: number;
    setWidth(_: number)
  }

  interface CIFourfoldRotatedTile extends CIFilter {
    angle: number;
    setAngle(_: number)
    center: CGPoint;
    setCenter(_: CGPoint)
    inputImage: CIImage;
    setInputImage(_: CIImage)
    width: number;
    setWidth(_: number)
  }

  interface CIFourfoldTranslatedTile extends CIFilter {
    acuteAngle: number;
    setAcuteAngle(_: number)
    angle: number;
    setAngle(_: number)
    center: CGPoint;
    setCenter(_: CGPoint)
    inputImage: CIImage;
    setInputImage(_: CIImage)
    width: number;
    setWidth(_: number)
  }

  interface CIGaborGradients extends CIFilter {
    inputImage: CIImage;
    setInputImage(_: CIImage)
  }

  interface CIGammaAdjust extends CIFilter {
    inputImage: CIImage;
    setInputImage(_: CIImage)
  }

  interface CIGaussianBlur extends CIFilter {
    inputImage: CIImage;
    setInputImage(_: CIImage)
    radius: number;
    setRadius(_: number)
  }

  interface CIGaussianGradient extends CIFilter {
    center: CGPoint;
    setCenter(_: CGPoint)
    color0: CIColor;
    setColor0(_: CIColor)
    color1: CIColor;
    setColor1(_: CIColor)
    radius: number;
    setRadius(_: number)
  }

  interface CIGlideReflectedTile extends CIFilter {
    angle: number;
    setAngle(_: number)
    center: CGPoint;
    setCenter(_: CGPoint)
    inputImage: CIImage;
    setInputImage(_: CIImage)
    width: number;
    setWidth(_: number)
  }

  interface CIGloom extends CIFilter {
    inputImage: CIImage;
    setInputImage(_: CIImage)
    intensity: number;
    setIntensity(_: number)
    radius: number;
    setRadius(_: number)
  }

  interface CIHatchedScreen extends CIFilter {
    angle: number;
    setAngle(_: number)
    center: CGPoint;
    setCenter(_: CGPoint)
    inputImage: CIImage;
    setInputImage(_: CIImage)
    sharpness: number;
    setSharpness(_: number)
    width: number;
    setWidth(_: number)
  }

  interface CIHeightFieldFromMask extends CIFilter {
    inputImage: CIImage;
    setInputImage(_: CIImage)
    radius: number;
    setRadius(_: number)
  }

  interface CIHexagonalPixellate extends CIFilter {
    center: CGPoint;
    setCenter(_: CGPoint)
    inputImage: CIImage;
    setInputImage(_: CIImage)
    scale: number;
    setScale(_: number)
  }

  interface CIHighlightShadowAdjust extends CIFilter {
    highlightAmount: number;
    setHighlightAmount(_: number)
    inputImage: CIImage;
    setInputImage(_: CIImage)
    radius: number;
    setRadius(_: number)
    shadowAmount: number;
    setShadowAmount(_: number)
  }

  interface CIHueAdjust extends CIFilter {
    angle: number;
    setAngle(_: number)
    inputImage: CIImage;
    setInputImage(_: CIImage)
  }

  interface CIHueSaturationValueGradient extends CIFilter {
    colorSpace: any;
    setColorSpace(_: any)
    dither: number;
    setDither(_: number)
    radius: number;
    setRadius(_: number)
    softness: number;
    setSoftness(_: number)
    value: number;
    setValue(_: number)
  }

  // interface
  class CIImage extends NSObject /* implements NSCopying, NSSecureCoding */ {
    static emptyImage(): CIImage;
    static imageWithDepthData(_: AVDepthData): CIImage;
    static imageWithDepthDataOptions(_: AVDepthData, options?: Map<string, any>): CIImage;
    static imageWithImageProviderSizeFormatColorSpaceOptions(_: any, _2: number, size: number, format: number, colorSpace?: any, options?: Map<string, any>): CIImage;
    static imageWithPortaitEffectsMatte(_: AVPortraitEffectsMatte): CIImage;
    static imageWithPortaitEffectsMatteOptions(_: AVPortraitEffectsMatte, options?: Map<string, any>): CIImage;
    static imageWithSemanticSegmentationMatte(_: AVSemanticSegmentationMatte): CIImage;
    static imageWithSemanticSegmentationMatteOptions(_: AVSemanticSegmentationMatte, options?: Map<string, any>): CIImage;
    CGImage: any;
    colorSpace: any;
    definition: CIFilterShape;
    depthData: AVDepthData;
    extent: CGRect;
    pixelBuffer: any;
    portraitEffectsMatte: AVPortraitEffectsMatte;
    properties: Map<string, any>;
    semanticSegmentationMatte: AVSemanticSegmentationMatte;
    url: NSURL;
    static blackImage: CIImage;
    static blueImage: CIImage;
    static clearImage: CIImage;
    static cyanImage: CIImage;
    static grayImage: CIImage;
    static greenImage: CIImage;
    static magentaImage: CIImage;
    static redImage: CIImage;
    static whiteImage: CIImage;
    static yellowImage: CIImage;
    autoAdjustmentFilters(): CIFilter[];
    autoAdjustmentFiltersWithOptions(options?: Map<string, any>): CIFilter[];
    drawAtPointFromRectOperationFraction(at: CGPoint, from: CGRect, operation: NSCompositingOperation, fraction: number): void;
    drawInRectFromRectOperationFraction(in_: CGRect, from: CGRect, operation: NSCompositingOperation, fraction: number): void;
    imageByApplyingCGOrientation(_: CGImagePropertyOrientation): CIImage;
    imageByApplyingFilter(_: string): CIImage;
    imageByApplyingFilterWithInputParameters(_: string, parameters?: Map<string, any>): CIImage;
    imageByApplyingGaussianBlurWithSigma(sigma: number): CIImage;
    imageByApplyingOrientation(forExifOrientation: number): CIImage;
    imageByApplyingTransform(by: CGAffineTransform): CIImage;
    imageByApplyingTransformHighQualityDownsample(by: CGAffineTransform, highQualityDownsample: boolean): CIImage;
    imageByClampingToExtent(): CIImage;
    imageByClampingToRect(to: CGRect): CIImage;
    imageByColorMatchingColorSpaceToWorkingSpace(from: any): CIImage;
    imageByColorMatchingWorkingSpaceToColorSpace(to: any): CIImage;
    imageByCompositingOverImage(over: CIImage): CIImage;
    imageByCroppingToRect(to: CGRect): CIImage;
    imageByInsertingIntermediate(): CIImage;
    imageByInsertingIntermediate(cache: boolean): CIImage;
    imageByPremultiplyingAlpha(): CIImage;
    imageBySamplingLinear(): CIImage;
    imageBySamplingNearest(): CIImage;
    imageBySettingAlphaOneInExtent(in_: CGRect): CIImage;
    imageBySettingProperties(_: Map<any, any>): CIImage;
    imageByUnpremultiplyingAlpha(): CIImage;
    imageTransformForCGOrientation(for_: CGImagePropertyOrientation): CGAffineTransform;
    imageTransformForOrientation(forExifOrientation: number): CGAffineTransform;
    static createWithBitmapDataBytesPerRowSizeFormatColorSpace(bitmapData: NSData, bytesPerRow: number, size: CGSize, format: number, colorSpace?: any): CIImage;
    static createWithBitmapImageRep(bitmapImageRep: NSBitmapImageRep): CIImage;
    static createWithCGImage(CGImage: any): CIImage;
    static createWithCGImageOptions(CGImage: any, options?: Map<string, any>): CIImage;
    static createWithCGImageSourceIndexOptions(CGImageSource: any, index: number, options?: Map<string, any>): CIImage;
    static createWithCVImageBuffer(CVImageBuffer: any): CIImage;
    static createWithCVImageBufferOptions(CVImageBuffer: any, options?: Map<string, any>): CIImage;
    static createWithCVPixelBuffer(CVPixelBuffer: any): CIImage;
    static createWithCVPixelBufferOptions(CVPixelBuffer: any, options?: Map<string, any>): CIImage;
    static createWithColor(color: CIColor): CIImage;
    static createWithContentsOfURL(contentsOfURL: NSURL): CIImage;
    static createWithContentsOfURLOptions(contentsOfURL: NSURL, options?: Map<string, any>): CIImage;
    static createWithData(data: NSData): CIImage;
    static createWithDataOptions(data: NSData, options?: Map<string, any>): CIImage;
    static createWithDepthData(depthData: AVDepthData): CIImage;
    static createWithDepthDataOptions(depthData: AVDepthData, options?: Map<string, any>): CIImage;
    static createWithIOSurface(IOSurface: any): CIImage;
    static createWithIOSurfaceOptions(IOSurface: any, options?: Map<string, any>): CIImage;
    static createWithImageProviderSizeFormatColorSpaceOptions(_: any, imageProvider: number, size: number, format: number, colorSpace?: any, options?: Map<string, any>): CIImage;
    // static createWithMTLTextureOptions(MTLTexture: MTLTexture, options?: Map<string, any>): CIImage;
    static createWithPortaitEffectsMatte(portaitEffectsMatte: AVPortraitEffectsMatte): CIImage;
    static createWithPortaitEffectsMatteOptions(portaitEffectsMatte: AVPortraitEffectsMatte, options?: Map<string, any>): CIImage;
    static createWithSemanticSegmentationMatte(semanticSegmentationMatte: AVSemanticSegmentationMatte): CIImage;
    static createWithSemanticSegmentationMatteOptions(semanticSegmentationMatte: AVSemanticSegmentationMatte, options?: Map<string, any>): CIImage;
    regionOfInterestForImageInRect(for_: CIImage, in_: CGRect): CGRect;
  }

  // interface
  class CIImageAccumulator extends NSObject {
    extent: CGRect;
    format: number;
    clear(): void;
    image(): CIImage;
    static createWithExtentFormat(extent: CGRect, format: number): CIImageAccumulator;
    static createWithExtentFormatColorSpace(extent: CGRect, format: number, colorSpace: any): CIImageAccumulator;
    setImage(_: CIImage): void;
    setImageDirtyRect(_: CIImage, dirtyRect: CGRect): void;
  }

  interface CIImageProcessorInput {
    baseAddress: any;
    bytesPerRow: number;
    format: number;
    // metalTexture: MTLTexture;
    pixelBuffer: any;
    region: CGRect;
    surface: any;
  }

  // interface
  class CIImageProcessorKernel extends NSObject {
    static applyWithExtentInputsArgumentsError(inputs: CGRect, arguments_?: CIImage[], error?: Map<string, any>): CIImage;
    static formatForInputAtIndex(at: number): number;
    static processWithInputsWithArgumentsOutputError(arguments_?: CIImageProcessorInput[], output?: Map<string, any>, error?: CIImageProcessorOutput): boolean;
    static roiForInputArgumentsOutputRect(forInput: number, arguments_?: Map<string, any>, outputRect?: CGRect): CGRect;
    static outputFormat: number;
    static outputIsOpaque: boolean;
    static synchronizeInputs: boolean;
  }

  interface CIImageProcessorOutput {
    baseAddress: any;
    bytesPerRow: number;
    format: number;
    // metalCommandBuffer: MTLCommandBuffer;
    // metalTexture: MTLTexture;
    pixelBuffer: any;
    region: CGRect;
    surface: any;
  }

  interface CIKaleidoscope extends CIFilter {
    angle: number;
    setAngle(_: number)
    center: CGPoint;
    setCenter(_: CGPoint)
    count: number;
    setCount(_: number)
    inputImage: CIImage;
    setInputImage(_: CIImage)
  }

  // interface
  class CIKernel extends NSObject {
    static kernelWithFunctionNameFromMetalLibraryDataError(fromMetalLibraryData: string, error: NSData): CIKernel;
    static kernelWithFunctionNameFromMetalLibraryDataOutputPixelFormatError(fromMetalLibraryData: string, outputPixelFormat: NSData, error: number): CIKernel;
    name: string;
    applyWithExtentRoiCallbackArguments(extent: CGRect, roiCallback: (p1: number, p2: CGRect) => CGRect, arguments_?: any[]): CIImage;
    setROISelector(_: string): void;
  }

  interface CIKeystoneCorrectionCombined extends CIFourCoordinateGeometryFilter {
    focalLength: number;
    setFocalLength(_: number)
  }

  interface CIKeystoneCorrectionHorizontal extends CIFourCoordinateGeometryFilter {
    focalLength: number;
    setFocalLength(_: number)
  }

  interface CIKeystoneCorrectionVertical extends CIFourCoordinateGeometryFilter {
    focalLength: number;
    setFocalLength(_: number)
  }

  interface CILabDeltaE extends CIFilter {
    image2: CIImage;
    setImage2(_: CIImage)
    inputImage: CIImage;
    setInputImage(_: CIImage)
  }

  interface CILanczosScaleTransform extends CIFilter {
    aspectRatio: number;
    setAspectRatio(_: number)
    inputImage: CIImage;
    setInputImage(_: CIImage)
    scale: number;
    setScale(_: number)
  }

  interface CILenticularHaloGenerator extends CIFilter {
    center: CGPoint;
    setCenter(_: CGPoint)
    color: CIColor;
    setColor(_: CIColor)
    haloOverlap: number;
    setHaloOverlap(_: number)
    haloRadius: number;
    setHaloRadius(_: number)
    haloWidth: number;
    setHaloWidth(_: number)
    striationContrast: number;
    setStriationContrast(_: number)
    striationStrength: number;
    setStriationStrength(_: number)
    time: number;
    setTime(_: number)
  }

  interface CILineOverlay extends CIFilter {
    contrast: number;
    setContrast(_: number)
    edgeIntensity: number;
    setEdgeIntensity(_: number)
    inputImage: CIImage;
    setInputImage(_: CIImage)
    NRNoiseLevel: number;
    setNRNoiseLevel(_: number)
    NRSharpness: number;
    setNRSharpness(_: number)
    threshold: number;
    setThreshold(_: number)
  }

  interface CILineScreen extends CIFilter {
    angle: number;
    setAngle(_: number)
    center: CGPoint;
    setCenter(_: CGPoint)
    inputImage: CIImage;
    setInputImage(_: CIImage)
    sharpness: number;
    setSharpness(_: number)
    width: number;
    setWidth(_: number)
  }

  interface CILinearGradient extends CIFilter {
    color0: CIColor;
    setColor0(_: CIColor)
    color1: CIColor;
    setColor1(_: CIColor)
    point0: CGPoint;
    setPoint0(_: CGPoint)
    point1: CGPoint;
    setPoint1(_: CGPoint)
  }

  interface CILinearToSRGBToneCurve extends CIFilter {
    inputImage: CIImage;
    setInputImage(_: CIImage)
  }

  interface CIMaskToAlpha extends CIFilter {
    inputImage: CIImage;
    setInputImage(_: CIImage)
  }

  interface CIMaskedVariableBlur extends CIFilter {
    inputImage: CIImage;
    setInputImage(_: CIImage)
    mask: CIImage;
    setMask(_: CIImage)
    radius: number;
    setRadius(_: number)
  }

  interface CIMaximumComponent extends CIFilter {
    inputImage: CIImage;
    setInputImage(_: CIImage)
  }

  interface CIMedian extends CIFilter {
    inputImage: CIImage;
    setInputImage(_: CIImage)
  }

  interface CIMeshGenerator extends CIFilter {
    color: CIColor;
    setColor(_: CIColor)
    mesh: any[];
    setMesh(_: any[])
    width: number;
    setWidth(_: number)
  }

  interface CIMinimumComponent extends CIFilter {
    inputImage: CIImage;
    setInputImage(_: CIImage)
  }

  interface CIMix extends CIFilter {
    amount: number;
    setAmount(_: number)
    backgroundImage: CIImage;
    setBackgroundImage(_: CIImage)
    inputImage: CIImage;
    setInputImage(_: CIImage)
  }

  interface CIModTransition extends CITransitionFilter {
    angle: number;
    setAngle(_: number)
    center: CGPoint;
    setCenter(_: CGPoint)
    compression: number;
    setCompression(_: number)
    radius: number;
    setRadius(_: number)
  }

  interface CIMorphologyGradient extends CIFilter {
    inputImage: CIImage;
    setInputImage(_: CIImage)
    radius: number;
    setRadius(_: number)
  }

  interface CIMorphologyMaximum extends CIFilter {
    inputImage: CIImage;
    setInputImage(_: CIImage)
    radius: number;
    setRadius(_: number)
  }

  interface CIMorphologyMinimum extends CIFilter {
    inputImage: CIImage;
    setInputImage(_: CIImage)
    radius: number;
    setRadius(_: number)
  }

  interface CIMorphologyRectangleMaximum extends CIFilter {
    height: number;
    setHeight(_: number)
    inputImage: CIImage;
    setInputImage(_: CIImage)
    width: number;
    setWidth(_: number)
  }

  interface CIMorphologyRectangleMinimum extends CIFilter {
    height: number;
    setHeight(_: number)
    inputImage: CIImage;
    setInputImage(_: CIImage)
    width: number;
    setWidth(_: number)
  }

  interface CIMotionBlur extends CIFilter {
    angle: number;
    setAngle(_: number)
    inputImage: CIImage;
    setInputImage(_: CIImage)
    radius: number;
    setRadius(_: number)
  }

  interface CINoiseReduction extends CIFilter {
    inputImage: CIImage;
    setInputImage(_: CIImage)
    noiseLevel: number;
    setNoiseLevel(_: number)
    sharpness: number;
    setSharpness(_: number)
  }

  interface CIOpTile extends CIFilter {
    angle: number;
    setAngle(_: number)
    center: CGPoint;
    setCenter(_: CGPoint)
    inputImage: CIImage;
    setInputImage(_: CIImage)
    scale: number;
    setScale(_: number)
    width: number;
    setWidth(_: number)
  }

  interface CIPDF417BarcodeGenerator extends CIFilter {
    alwaysSpecifyCompaction: number;
    setAlwaysSpecifyCompaction(_: number)
    compactionMode: number;
    setCompactionMode(_: number)
    compactStyle: number;
    setCompactStyle(_: number)
    correctionLevel: number;
    setCorrectionLevel(_: number)
    dataColumns: number;
    setDataColumns(_: number)
    maxHeight: number;
    setMaxHeight(_: number)
    maxWidth: number;
    setMaxWidth(_: number)
    message: NSData;
    setMessage(_: NSData)
    minHeight: number;
    setMinHeight(_: number)
    minWidth: number;
    setMinWidth(_: number)
    preferredAspectRatio: number;
    setPreferredAspectRatio(_: number)
    rows: number;
    setRows(_: number)
  }

  // interface
  class CIPDF417CodeDescriptor extends CIBarcodeDescriptor {
    static descriptorWithPayloadIsCompactRowCountColumnCount(payload: NSData, isCompact: boolean, rowCount: number, columnCount: number): CIPDF417CodeDescriptor;
    columnCount: number;
    errorCorrectedPayload: NSData;
    isCompact: boolean;
    rowCount: number;
    static createWithPayloadIsCompactRowCountColumnCount(payload: NSData, isCompact: boolean, rowCount: number, columnCount: number): CIPDF417CodeDescriptor;
  }

  interface CIPageCurlTransition extends CITransitionFilter {
    angle: number;
    setAngle(_: number)
    backsideImage: CIImage;
    setBacksideImage(_: CIImage)
    extent: CGRect;
    setExtent(_: CGRect)
    radius: number;
    setRadius(_: number)
    shadingImage: CIImage;
    setShadingImage(_: CIImage)
  }

  interface CIPageCurlWithShadowTransition extends CITransitionFilter {
    angle: number;
    setAngle(_: number)
    backsideImage: CIImage;
    setBacksideImage(_: CIImage)
    extent: CGRect;
    setExtent(_: CGRect)
    radius: number;
    setRadius(_: number)
    shadowAmount: number;
    setShadowAmount(_: number)
    shadowExtent: CGRect;
    setShadowExtent(_: CGRect)
    shadowSize: number;
    setShadowSize(_: number)
  }

  interface CIPaletteCentroid extends CIFilter {
    inputImage: CIImage;
    setInputImage(_: CIImage)
    paletteImage: CIImage;
    setPaletteImage(_: CIImage)
    perceptual: boolean;
    setPerceptual(_: boolean)
  }

  interface CIPalettize extends CIFilter {
    inputImage: CIImage;
    setInputImage(_: CIImage)
    paletteImage: CIImage;
    setPaletteImage(_: CIImage)
    perceptual: boolean;
    setPerceptual(_: boolean)
  }

  interface CIParallelogramTile extends CIFilter {
    acuteAngle: number;
    setAcuteAngle(_: number)
    angle: number;
    setAngle(_: number)
    center: CGPoint;
    setCenter(_: CGPoint)
    inputImage: CIImage;
    setInputImage(_: CIImage)
    width: number;
    setWidth(_: number)
  }

  interface CIPerspectiveCorrection extends CIFourCoordinateGeometryFilter {
    crop: boolean;
    setCrop(_: boolean)
  }

  interface CIPerspectiveRotate extends CIFilter {
    focalLength: number;
    setFocalLength(_: number)
    inputImage: CIImage;
    setInputImage(_: CIImage)
    pitch: number;
    setPitch(_: number)
    roll: number;
    setRoll(_: number)
    yaw: number;
    setYaw(_: number)
  }

  interface CIPerspectiveTile extends CIFilter {
    bottomLeft: CGPoint;
    setBottomLeft(_: CGPoint)
    bottomRight: CGPoint;
    setBottomRight(_: CGPoint)
    inputImage: CIImage;
    setInputImage(_: CIImage)
    topLeft: CGPoint;
    setTopLeft(_: CGPoint)
    topRight: CGPoint;
    setTopRight(_: CGPoint)
  }

  type CIPerspectiveTransform = CIFourCoordinateGeometryFilter

  interface CIPerspectiveTransformWithExtent extends CIFourCoordinateGeometryFilter {
    extent: CGRect;
    setExtent(_: CGRect)
  }

  interface CIPhotoEffect extends CIFilter {
    inputImage: CIImage;
    setInputImage(_: CIImage)
  }

  interface CIPixellate extends CIFilter {
    center: CGPoint;
    setCenter(_: CGPoint)
    inputImage: CIImage;
    setInputImage(_: CIImage)
    scale: number;
    setScale(_: number)
  }

  // interface
  class CIPlugIn extends NSObject {
    static loadNonExecutablePlugIn(_: NSURL): void;
    static loadNonExecutablePlugIns(): void;
  }

  interface CIPlugInRegistration {
    // instance method
    load(_: any): boolean;
  }

  interface CIPointillize extends CIFilter {
    center: CGPoint;
    setCenter(_: CGPoint)
    inputImage: CIImage;
    setInputImage(_: CIImage)
    radius: number;
    setRadius(_: number)
  }

  // interface
  class CIQRCodeDescriptor extends CIBarcodeDescriptor {
    static descriptorWithPayloadSymbolVersionMaskPatternErrorCorrectionLevel(payload: NSData, symbolVersion: number, maskPattern: number, errorCorrectionLevel: CIQRCodeErrorCorrectionLevel): CIQRCodeDescriptor;
    errorCorrectedPayload: NSData;
    errorCorrectionLevel: CIQRCodeErrorCorrectionLevel;
    maskPattern: number;
    symbolVersion: number;
    static createWithPayloadSymbolVersionMaskPatternErrorCorrectionLevel(payload: NSData, symbolVersion: number, maskPattern: number, errorCorrectionLevel: CIQRCodeErrorCorrectionLevel): CIQRCodeDescriptor;
  }

  // interface
  class CIQRCodeFeature extends CIFeature /* implements NSCopying, NSSecureCoding */ {
    bottomLeft: CGPoint;
    bottomRight: CGPoint;
    messageString: string;
    symbolDescriptor: CIQRCodeDescriptor;
    topLeft: CGPoint;
    topRight: CGPoint;
  }

  interface CIQRCodeGenerator extends CIFilter {
    correctionLevel: string;
    setCorrectionLevel(_: string)
    message: NSData;
    setMessage(_: NSData)
  }

  interface CIRadialGradient extends CIFilter {
    center: CGPoint;
    setCenter(_: CGPoint)
    color0: CIColor;
    setColor0(_: CIColor)
    color1: CIColor;
    setColor1(_: CIColor)
    radius0: number;
    setRadius0(_: number)
    radius1: number;
    setRadius1(_: number)
  }

  type CIRandomGenerator = CIFilter

  // interface
  class CIRectangleFeature extends CIFeature {
    bottomLeft: CGPoint;
    bottomRight: CGPoint;
    topLeft: CGPoint;
    topRight: CGPoint;
  }

  // interface
  class CIRenderDestination extends NSObject {
    alphaMode: CIRenderDestinationAlphaMode;
    setAlphaMode(_: CIRenderDestinationAlphaMode)
    blendKernel: CIBlendKernel;
    setBlendKernel(_: CIBlendKernel)
    blendsInDestinationColorSpace: boolean;
    setBlendsInDestinationColorSpace(_: boolean)
    isClamped: boolean;
    setClamped(_: boolean)
    colorSpace: any;
    setColorSpace(_: any)
    isDithered: boolean;
    setDithered(_: boolean)
    isFlipped: boolean;
    setFlipped(_: boolean)
    height: number;
    width: number;
    static createWithBitmapDataWidthHeightBytesPerRowFormat(bitmapData: any, width: number, height: number, bytesPerRow: number, format: number): CIRenderDestination;
    static createWithGLTextureTargetWidthHeight(GLTexture: number, target: number, width: number, height: number): CIRenderDestination;
    static createWithIOSurface(IOSurface: IOSurface): CIRenderDestination;
    // static createWithMTLTextureCommandBuffer(MTLTexture: MTLTexture, commandBuffer?: MTLCommandBuffer): CIRenderDestination;
    static createWithPixelBuffer(pixelBuffer: any): CIRenderDestination;
    // static createWithWidthHeightPixelFormatCommandBufferMtlTextureProvider(width: number, height: number, pixelFormat: MTLPixelFormat, commandBuffer?: MTLCommandBuffer, mtlTextureProvider?: () => MTLTexture): CIRenderDestination;
  }

  // interface
  class CIRenderInfo extends NSObject {
    kernelExecutionTime: number;
    passCount: number;
    pixelsProcessed: number;
  }

  // interface
  class CIRenderTask extends NSObject {
    waitUntilCompletedAndReturnError(): CIRenderInfo;
  }

  interface CIRippleTransition extends CITransitionFilter {
    center: CGPoint;
    setCenter(_: CGPoint)
    extent: CGRect;
    setExtent(_: CGRect)
    scale: number;
    setScale(_: number)
    shadingImage: CIImage;
    setShadingImage(_: CIImage)
    width: number;
    setWidth(_: number)
  }

  interface CIRoundedRectangleGenerator extends CIFilter {
    color: CIColor;
    setColor(_: CIColor)
    extent: CGRect;
    setExtent(_: CGRect)
    radius: number;
    setRadius(_: number)
  }

  interface CISRGBToneCurveToLinear extends CIFilter {
    inputImage: CIImage;
    setInputImage(_: CIImage)
  }

  interface CISaliencyMap extends CIFilter {
    inputImage: CIImage;
    setInputImage(_: CIImage)
  }

  // interface
  class CISampler extends NSObject /* implements NSCopying */ {
    static samplerWithImageKeysAndValues(_: CIImage, keysAndValues: any): CISampler;
    definition: CIFilterShape;
    extent: CGRect;
    static createWithImage(image: CIImage): CISampler;
    static createWithImageOptions(image: CIImage, options?: Map<any, any>): CISampler;
  }

  interface CISepiaTone extends CIFilter {
    inputImage: CIImage;
    setInputImage(_: CIImage)
    intensity: number;
    setIntensity(_: number)
  }

  interface CIShadedMaterial extends CIFilter {
    inputImage: CIImage;
    setInputImage(_: CIImage)
    scale: number;
    setScale(_: number)
    shadingImage: CIImage;
    setShadingImage(_: CIImage)
  }

  interface CISharpenLuminance extends CIFilter {
    inputImage: CIImage;
    setInputImage(_: CIImage)
    radius: number;
    setRadius(_: number)
    sharpness: number;
    setSharpness(_: number)
  }

  interface CISixfoldReflectedTile extends CIFilter {
    angle: number;
    setAngle(_: number)
    center: CGPoint;
    setCenter(_: CGPoint)
    inputImage: CIImage;
    setInputImage(_: CIImage)
    width: number;
    setWidth(_: number)
  }

  interface CISixfoldRotatedTile extends CIFilter {
    angle: number;
    setAngle(_: number)
    center: CGPoint;
    setCenter(_: CGPoint)
    inputImage: CIImage;
    setInputImage(_: CIImage)
    width: number;
    setWidth(_: number)
  }

  interface CISmoothLinearGradient extends CIFilter {
    color0: CIColor;
    setColor0(_: CIColor)
    color1: CIColor;
    setColor1(_: CIColor)
    point0: CGPoint;
    setPoint0(_: CGPoint)
    point1: CGPoint;
    setPoint1(_: CGPoint)
  }

  interface CISpotColor extends CIFilter {
    centerColor1: CIColor;
    setCenterColor1(_: CIColor)
    centerColor2: CIColor;
    setCenterColor2(_: CIColor)
    centerColor3: CIColor;
    setCenterColor3(_: CIColor)
    closeness1: number;
    setCloseness1(_: number)
    closeness2: number;
    setCloseness2(_: number)
    closeness3: number;
    setCloseness3(_: number)
    contrast1: number;
    setContrast1(_: number)
    contrast2: number;
    setContrast2(_: number)
    contrast3: number;
    setContrast3(_: number)
    inputImage: CIImage;
    setInputImage(_: CIImage)
    replacementColor1: CIColor;
    setReplacementColor1(_: CIColor)
    replacementColor2: CIColor;
    setReplacementColor2(_: CIColor)
    replacementColor3: CIColor;
    setReplacementColor3(_: CIColor)
  }

  interface CISpotLight extends CIFilter {
    brightness: number;
    setBrightness(_: number)
    color: CIColor;
    setColor(_: CIColor)
    concentration: number;
    setConcentration(_: number)
    inputImage: CIImage;
    setInputImage(_: CIImage)
    lightPointsAt: CIVector;
    setLightPointsAt(_: CIVector)
    lightPosition: CIVector;
    setLightPosition(_: CIVector)
  }

  interface CIStarShineGenerator extends CIFilter {
    center: CGPoint;
    setCenter(_: CGPoint)
    color: CIColor;
    setColor(_: CIColor)
    crossAngle: number;
    setCrossAngle(_: number)
    crossOpacity: number;
    setCrossOpacity(_: number)
    crossScale: number;
    setCrossScale(_: number)
    crossWidth: number;
    setCrossWidth(_: number)
    epsilon: number;
    setEpsilon(_: number)
    radius: number;
    setRadius(_: number)
  }

  interface CIStraighten extends CIFilter {
    angle: number;
    setAngle(_: number)
    inputImage: CIImage;
    setInputImage(_: CIImage)
  }

  interface CIStripesGenerator extends CIFilter {
    center: CGPoint;
    setCenter(_: CGPoint)
    color0: CIColor;
    setColor0(_: CIColor)
    color1: CIColor;
    setColor1(_: CIColor)
    sharpness: number;
    setSharpness(_: number)
    width: number;
    setWidth(_: number)
  }

  interface CISunbeamsGenerator extends CIFilter {
    center: CGPoint;
    setCenter(_: CGPoint)
    color: CIColor;
    setColor(_: CIColor)
    maxStriationRadius: number;
    setMaxStriationRadius(_: number)
    striationContrast: number;
    setStriationContrast(_: number)
    striationStrength: number;
    setStriationStrength(_: number)
    sunRadius: number;
    setSunRadius(_: number)
    time: number;
    setTime(_: number)
  }

  interface CISwipeTransition extends CITransitionFilter {
    angle: number;
    setAngle(_: number)
    color: CIColor;
    setColor(_: CIColor)
    extent: CGRect;
    setExtent(_: CGRect)
    opacity: number;
    setOpacity(_: number)
    width: number;
    setWidth(_: number)
  }

  interface CITemperatureAndTint extends CIFilter {
    inputImage: CIImage;
    setInputImage(_: CIImage)
    neutral: CIVector;
    setNeutral(_: CIVector)
    targetNeutral: CIVector;
    setTargetNeutral(_: CIVector)
  }

  // interface
  class CITextFeature extends CIFeature {
    bottomLeft: CGPoint;
    bottomRight: CGPoint;
    subFeatures: any[];
    topLeft: CGPoint;
    topRight: CGPoint;
  }

  interface CITextImageGenerator extends CIFilter {
    fontName: string;
    setFontName(_: string)
    fontSize: number;
    setFontSize(_: number)
    scaleFactor: number;
    setScaleFactor(_: number)
    text: string;
    setText(_: string)
  }

  interface CIThermal extends CIFilter {
    inputImage: CIImage;
    setInputImage(_: CIImage)
  }

  interface CIToneCurve extends CIFilter {
    inputImage: CIImage;
    setInputImage(_: CIImage)
    point0: CGPoint;
    setPoint0(_: CGPoint)
    point1: CGPoint;
    setPoint1(_: CGPoint)
    point2: CGPoint;
    setPoint2(_: CGPoint)
    point3: CGPoint;
    setPoint3(_: CGPoint)
    point4: CGPoint;
    setPoint4(_: CGPoint)
  }

  interface CITransitionFilter extends CIFilter {
    inputImage: CIImage;
    setInputImage(_: CIImage)
    targetImage: CIImage;
    setTargetImage(_: CIImage)
    time: number;
    setTime(_: number)
  }

  interface CITriangleKaleidoscope extends CIFilter {
    decay: number;
    setDecay(_: number)
    inputImage: CIImage;
    setInputImage(_: CIImage)
    point: CGPoint;
    setPoint(_: CGPoint)
    rotation: number;
    setRotation(_: number)
    size: number;
    setSize(_: number)
  }

  interface CITriangleTile extends CIFilter {
    angle: number;
    setAngle(_: number)
    center: CGPoint;
    setCenter(_: CGPoint)
    inputImage: CIImage;
    setInputImage(_: CIImage)
    width: number;
    setWidth(_: number)
  }

  interface CITwelvefoldReflectedTile extends CIFilter {
    angle: number;
    setAngle(_: number)
    center: CGPoint;
    setCenter(_: CGPoint)
    inputImage: CIImage;
    setInputImage(_: CIImage)
    width: number;
    setWidth(_: number)
  }

  interface CIUnsharpMask extends CIFilter {
    inputImage: CIImage;
    setInputImage(_: CIImage)
    intensity: number;
    setIntensity(_: number)
    radius: number;
    setRadius(_: number)
  }

  // interface
  class CIVector extends NSObject /* implements NSCopying, NSSecureCoding */ {
    CGAffineTransformValue: CGAffineTransform;
    CGPointValue: CGPoint;
    CGRectValue: CGRect;
    W: number;
    X: number;
    Y: number;
    Z: number;
    count: number;
    stringRepresentation: string;
    static createWithCGAffineTransform(CGAffineTransform: CGAffineTransform): CIVector;
    static createWithCGPoint(CGPoint: CGPoint): CIVector;
    static createWithCGRect(CGRect: CGRect): CIVector;
    static createWithString(string: string): CIVector;
    static createWithValuesCount(values: number, count: number): CIVector;
    static createWithX(x: number): CIVector;
    static createWithXY(x: number, y: number): CIVector;
    static createWithXYZ(x: number, y: number, z: number): CIVector;
    static createWithXYZW(x: number, y: number, z: number, w: number): CIVector;
    valueAtIndex(at: number): number;
  }

  interface CIVibrance extends CIFilter {
    amount: number;
    setAmount(_: number)
    inputImage: CIImage;
    setInputImage(_: CIImage)
  }

  interface CIVignette extends CIFilter {
    inputImage: CIImage;
    setInputImage(_: CIImage)
    intensity: number;
    setIntensity(_: number)
    radius: number;
    setRadius(_: number)
  }

  interface CIVignetteEffect extends CIFilter {
    center: CGPoint;
    setCenter(_: CGPoint)
    falloff: number;
    setFalloff(_: number)
    inputImage: CIImage;
    setInputImage(_: CIImage)
    intensity: number;
    setIntensity(_: number)
    radius: number;
    setRadius(_: number)
  }

  // interface
  class CIWarpKernel extends CIKernel {
    applyWithExtentRoiCallbackImageArguments(extent: CGRect, roiCallback: (p1: number, p2: CGRect) => CGRect, image: CIImage, arguments_?: any[]): CIImage;
  }

  interface CIWhitePointAdjust extends CIFilter {
    color: CIColor;
    setColor(_: CIColor)
    inputImage: CIImage;
    setInputImage(_: CIImage)
  }

  interface CIXRay extends CIFilter {
    inputImage: CIImage;
    setInputImage(_: CIImage)
  }

  interface CIZoomBlur extends CIFilter {
    amount: number;
    setAmount(_: number)
    center: CGPoint;
    setCenter(_: CGPoint)
    inputImage: CIImage;
    setInputImage(_: CIImage)
  }

  // export function CMAudioDeviceClockCreate(allocator: any, deviceUID: string, clockOut: any): number;

  // export function CMAudioDeviceClockCreateFromAudioDeviceID(allocator: any, deviceID: number, clockOut: any): number;

  // export function CMAudioDeviceClockGetAudioDevice(clock: any, deviceUIDOut: string, deviceIDOut: number, trackingDefaultDeviceOut: string | any): number;

  // export function CMAudioDeviceClockSetAudioDeviceID(clock: any, deviceID: number): number;

  // export function CMAudioDeviceClockSetAudioDeviceUID(clock: any, deviceUID: string): number;

  // export function CMAudioFormatDescriptionCopyAsBigEndianSoundDescriptionBlockBuffer(allocator: any, audioFormatDescription: any, flavor: any, blockBufferOut: any): number;

  // export function CMAudioFormatDescriptionCreate(allocator: any, asbd: AudioStreamBasicDescription, layoutSize: number, layout: AudioChannelLayout, magicCookieSize: number, magicCookie: any, extensions: Map<any, any>, formatDescriptionOut: any): number;

  // export function CMAudioFormatDescriptionCreateFromBigEndianSoundDescriptionBlockBuffer(allocator: any, soundDescriptionBlockBuffer: any, flavor: any, formatDescriptionOut: any): number;

  // export function CMAudioFormatDescriptionCreateFromBigEndianSoundDescriptionData(allocator: any, soundDescriptionData: string | any, size: number, flavor: any, formatDescriptionOut: any): number;

  // export function CMAudioFormatDescriptionCreateSummary(allocator: any, formatDescriptionArray: any[], flags: number, formatDescriptionOut: any): number;

  // export function CMAudioFormatDescriptionEqual(formatDescription: any, otherFormatDescription: any, equalityMask: number, equalityMaskOut: number): boolean;

  // export function CMAudioFormatDescriptionGetChannelLayout(desc: any, sizeOut: number): AudioChannelLayout;

  // export function CMAudioFormatDescriptionGetFormatList(desc: any, sizeOut: number): AudioFormatListItem;

  // export function CMAudioFormatDescriptionGetMagicCookie(desc: any, sizeOut: number): any;

  // export function CMAudioFormatDescriptionGetMostCompatibleFormat(desc: any): AudioFormatListItem;

  // export function CMAudioFormatDescriptionGetRichestDecodableFormat(desc: any): AudioFormatListItem;

  // export function CMAudioFormatDescriptionGetStreamBasicDescription(desc: any): AudioStreamBasicDescription;

  // export function CMAudioSampleBufferCreateReadyWithPacketDescriptions(allocator: any, dataBuffer: any, formatDescription: any, numSamples: number, presentationTimeStamp: CMTime, packetDescriptions: AudioStreamPacketDescription, sampleBufferOut: any): number;

  // export function CMAudioSampleBufferCreateWithPacketDescriptions(allocator: any, dataBuffer: any, dataReady: boolean, makeDataReadyCallback: (p1: any, p2: any) => number, makeDataReadyRefcon: any, formatDescription: any, numSamples: number, presentationTimeStamp: CMTime, packetDescriptions: AudioStreamPacketDescription, sampleBufferOut: any): number;

  // export function CMAudioSampleBufferCreateWithPacketDescriptionsAndMakeDataReadyHandler(allocator: any, dataBuffer: any, dataReady: boolean, formatDescription: any, numSamples: number, presentationTimeStamp: CMTime, packetDescriptions: AudioStreamPacketDescription, sampleBufferOut: any, makeDataReadyHandler: (p1: any) => number): number;

  // export function CMBlockBufferAccessDataBytes(theBuffer: any, offset: number, length: number, temporaryBlock: any, returnedPointerOut: string): number;

  // export function CMBlockBufferAppendBufferReference(theBuffer: any, targetBBuf: any, offsetToData: number, dataLength: number, flags: number): number;

  // export function CMBlockBufferAppendMemoryBlock(theBuffer: any, memoryBlock: any, blockLength: number, blockAllocator: any, customBlockSource: CMBlockBufferCustomBlockSource, offsetToData: number, dataLength: number, flags: number): number;

  // export function CMBlockBufferAssureBlockMemory(theBuffer: any): number;

  // export function CMBlockBufferCopyDataBytes(theSourceBuffer: any, offsetToData: number, dataLength: number, destination: any): number;

  // export function CMBlockBufferCreateContiguous(structureAllocator: any, sourceBuffer: any, blockAllocator: any, customBlockSource: CMBlockBufferCustomBlockSource, offsetToData: number, dataLength: number, flags: number, blockBufferOut: any): number;

  // export function CMBlockBufferCreateEmpty(structureAllocator: any, subBlockCapacity: number, flags: number, blockBufferOut: any): number;

  // export function CMBlockBufferCreateWithBufferReference(structureAllocator: any, bufferReference: any, offsetToData: number, dataLength: number, flags: number, blockBufferOut: any): number;

  // export function CMBlockBufferCreateWithMemoryBlock(structureAllocator: any, memoryBlock: any, blockLength: number, blockAllocator: any, customBlockSource: CMBlockBufferCustomBlockSource, offsetToData: number, dataLength: number, flags: number, blockBufferOut: any): number;

  // export function CMBlockBufferFillDataBytes(fillByte: number, destinationBuffer: any, offsetIntoDestination: number, dataLength: number): number;

  // export function CMBlockBufferGetDataLength(theBuffer: any): number;

  // export function CMBlockBufferGetDataPointer(theBuffer: any, offset: number, lengthAtOffsetOut: number, totalLengthOut: number, dataPointerOut: string): number;

  // export function CMBlockBufferGetTypeID(): number;

  // export function CMBlockBufferIsEmpty(theBuffer: any): boolean;

  // export function CMBlockBufferIsRangeContiguous(theBuffer: any, offset: number, length: number): boolean;

  // export function CMBlockBufferReplaceDataBytes(sourceBytes: any, destinationBuffer: any, offsetIntoDestination: number, dataLength: number): number;

  // export function CMBufferQueueCallForEachBuffer(queue: any, callback: (p1: any, p2: any) => number, refcon: any): number;

  // export function CMBufferQueueContainsEndOfData(queue: any): boolean;

  // export function CMBufferQueueCreate(allocator: any, capacity: number, callbacks: CMBufferCallbacks, queueOut: any): number;

  // export function CMBufferQueueCreateWithHandlers(allocator: any, capacity: number, handlers: CMBufferHandlers, queueOut: any): number;

  // export function CMBufferQueueDequeueAndRetain(queue: any): any;

  // export function CMBufferQueueDequeueIfDataReadyAndRetain(queue: any): any;

  // export function CMBufferQueueEnqueue(queue: any, buf: any): number;

  // export function CMBufferQueueGetBufferCount(queue: any): number;

  // export function CMBufferQueueGetCallbacksForSampleBuffersSortedByOutputPTS(): CMBufferCallbacks;

  // export function CMBufferQueueGetCallbacksForUnsortedSampleBuffers(): CMBufferCallbacks;

  // export function CMBufferQueueGetDuration(queue: any): CMTime;

  // export function CMBufferQueueGetEndPresentationTimeStamp(queue: any): CMTime;

  // export function CMBufferQueueGetFirstDecodeTimeStamp(queue: any): CMTime;

  // export function CMBufferQueueGetFirstPresentationTimeStamp(queue: any): CMTime;

  // export function CMBufferQueueGetHead(queue: any): any;

  // export function CMBufferQueueGetMaxPresentationTimeStamp(queue: any): CMTime;

  // export function CMBufferQueueGetMinDecodeTimeStamp(queue: any): CMTime;

  // export function CMBufferQueueGetMinPresentationTimeStamp(queue: any): CMTime;

  // export function CMBufferQueueGetTotalSize(queue: any): number;

  // export function CMBufferQueueGetTypeID(): number;

  // export function CMBufferQueueInstallTrigger(queue: any, callback: (p1: any, p2: any) => void, refcon: any, condition: number, time: CMTime, triggerTokenOut: any): number;

  // export function CMBufferQueueInstallTriggerHandler(queue: any, condition: number, time: CMTime, triggerTokenOut: any, handler: (p1: any) => void): number;

  // export function CMBufferQueueInstallTriggerHandlerWithIntegerThreshold(queue: any, condition: number, threshold: number, triggerTokenOut: any, handler: (p1: any) => void): number;

  // export function CMBufferQueueInstallTriggerWithIntegerThreshold(queue: any, callback: (p1: any, p2: any) => void, refcon: any, condition: number, threshold: number, triggerTokenOut: any): number;

  // export function CMBufferQueueIsAtEndOfData(queue: any): boolean;

  // export function CMBufferQueueIsEmpty(queue: any): boolean;

  // export function CMBufferQueueMarkEndOfData(queue: any): number;

  // export function CMBufferQueueRemoveTrigger(queue: any, triggerToken: any): number;

  // export function CMBufferQueueReset(queue: any): number;

  // export function CMBufferQueueResetWithCallback(queue: any, callback: (p1: any, p2: any) => void, refcon: any): number;

  // export function CMBufferQueueSetValidationCallback(queue: any, callback: (p1: any, p2: any, p3: any) => number, refcon: any): number;

  // export function CMBufferQueueSetValidationHandler(queue: any, handler: (p1: any, p2: any) => number): number;

  // export function CMBufferQueueTestTrigger(queue: any, triggerToken: any): boolean;

  // export function CMClockConvertHostTimeToSystemUnits(hostTime: CMTime): number;

  // export function CMClockGetAnchorTime(clock: any, clockTimeOut: CMTime, referenceClockTimeOut: CMTime): number;

  // export function CMClockGetHostTimeClock(): any;

  // export function CMClockGetTime(clock: any): CMTime;

  // export function CMClockGetTypeID(): number;

  // export function CMClockInvalidate(clock: any): void;

  // export function CMClockMakeHostTimeFromSystemUnits(hostTime: number): CMTime;

  // export function CMClockMightDrift(clock: any, otherClock: any): boolean;

  // export function CMClosedCaptionFormatDescriptionCopyAsBigEndianClosedCaptionDescriptionBlockBuffer(allocator: any, closedCaptionFormatDescription: any, flavor: any, blockBufferOut: any): number;

  // export function CMClosedCaptionFormatDescriptionCreateFromBigEndianClosedCaptionDescriptionBlockBuffer(allocator: any, closedCaptionDescriptionBlockBuffer: any, flavor: any, formatDescriptionOut: any): number;

  // export function CMClosedCaptionFormatDescriptionCreateFromBigEndianClosedCaptionDescriptionData(allocator: any, closedCaptionDescriptionData: string | any, size: number, flavor: any, formatDescriptionOut: any): number;

  // export function CMCopyDictionaryOfAttachments(allocator: any, target: any, attachmentMode: number): Map<any, any>;

  // export function CMDoesBigEndianSoundDescriptionRequireLegacyCBRSampleTableLayout(soundDescriptionBlockBuffer: any, flavor: any): boolean;

  // export function CMFormatDescriptionCreate(allocator: any, mediaType: number, mediaSubType: number, extensions: Map<any, any>, formatDescriptionOut: any): number;

  // export function CMFormatDescriptionEqual(formatDescription: any, otherFormatDescription: any): boolean;

  // export function CMFormatDescriptionEqualIgnoringExtensionKeys(formatDescription: any, otherFormatDescription: any, formatDescriptionExtensionKeysToIgnore: any, sampleDescriptionExtensionAtomKeysToIgnore: any): boolean;

  // export function CMFormatDescriptionGetExtension(desc: any, extensionKey: string): any;

  // export function CMFormatDescriptionGetExtensions(desc: any): Map<any, any>;

  // export function CMFormatDescriptionGetMediaSubType(desc: any): number;

  // export function CMFormatDescriptionGetMediaType(desc: any): number;

  // export function CMFormatDescriptionGetTypeID(): number;

  // export function CMGetAttachment(target: any, key: string, attachmentModeOut: number): any;

  // export function CMMemoryPoolCreate(options: Map<any, any>): any;

  // export function CMMemoryPoolFlush(pool: any): void;

  // export function CMMemoryPoolGetAllocator(pool: any): any;

  // export function CMMemoryPoolGetTypeID(): number;

  // export function CMMemoryPoolInvalidate(pool: any): void;

  // export function CMMetadataCreateIdentifierForKeyAndKeySpace(allocator: any, key: any, keySpace: string, identifierOut: string): number;

  // export function CMMetadataCreateKeyFromIdentifier(allocator: any, identifier: string, keyOut: any): number;

  // export function CMMetadataCreateKeyFromIdentifierAsCFData(allocator: any, identifier: string, keyOut: Data): number;

  // export function CMMetadataCreateKeySpaceFromIdentifier(allocator: any, identifier: string, keySpaceOut: string): number;

  // export function CMMetadataDataTypeRegistryDataTypeConformsToDataType(dataType: string, conformsToDataType: string): boolean;

  // export function CMMetadataDataTypeRegistryDataTypeIsBaseDataType(dataType: string): boolean;

  // export function CMMetadataDataTypeRegistryDataTypeIsRegistered(dataType: string): boolean;

  // export function CMMetadataDataTypeRegistryGetBaseDataTypeForConformingDataType(dataType: string): string;

  // export function CMMetadataDataTypeRegistryGetBaseDataTypes(): any[];

  // export function CMMetadataDataTypeRegistryGetConformingDataTypes(dataType: string): any[];

  // export function CMMetadataDataTypeRegistryGetDataTypeDescription(dataType: string): string;

  // export function CMMetadataDataTypeRegistryRegisterDataType(dataType: string, description: string, conformingDataTypes: any[]): number;

  // export function CMMetadataFormatDescriptionCopyAsBigEndianMetadataDescriptionBlockBuffer(allocator: any, metadataFormatDescription: any, flavor: any, blockBufferOut: any): number;

  // export function CMMetadataFormatDescriptionCreateByMergingMetadataFormatDescriptions(allocator: any, sourceDescription: any, otherSourceDescription: any, formatDescriptionOut: any): number;

  // export function CMMetadataFormatDescriptionCreateFromBigEndianMetadataDescriptionBlockBuffer(allocator: any, metadataDescriptionBlockBuffer: any, flavor: any, formatDescriptionOut: any): number;

  // export function CMMetadataFormatDescriptionCreateFromBigEndianMetadataDescriptionData(allocator: any, metadataDescriptionData: string | any, size: number, flavor: any, formatDescriptionOut: any): number;

  // export function CMMetadataFormatDescriptionCreateWithKeys(allocator: any, metadataType: number, keys: any[], formatDescriptionOut: any): number;

  // export function CMMetadataFormatDescriptionCreateWithMetadataFormatDescriptionAndMetadataSpecifications(allocator: any, sourceDescription: any, metadataSpecifications: any[], formatDescriptionOut: any): number;

  // export function CMMetadataFormatDescriptionCreateWithMetadataSpecifications(allocator: any, metadataType: number, metadataSpecifications: any[], formatDescriptionOut: any): number;

  // export function CMMetadataFormatDescriptionGetIdentifiers(desc: any): any[];

  // export function CMMetadataFormatDescriptionGetKeyWithLocalID(desc: any, localKeyID: number): Map<any, any>;

  // export function CMMuxedFormatDescriptionCreate(allocator: any, muxType: number, extensions: Map<any, any>, formatDescriptionOut: any): number;

  // export function CMPropagateAttachments(source: any, destination: any): void;

  // export function CMRemoveAllAttachments(target: any): void;

  // export function CMRemoveAttachment(target: any, key: string): void;

  // export function CMSampleBufferCallBlockForEachSample(sbuf: any, handler: (p1: any, p2: number) => number): number;

  // export function CMSampleBufferCallForEachSample(sbuf: any, callback: (p1: any, p2: number, p3: any) => number, refcon: any): number;

  // export function CMSampleBufferCopyPCMDataIntoAudioBufferList(sbuf: any, frameOffset: number, numFrames: number, bufferList: AudioBufferList): number;

  // export function CMSampleBufferCopySampleBufferForRange(allocator: any, sbuf: any, sampleRange: CFRange, sampleBufferOut: any): number;

  // export function CMSampleBufferCreate(allocator: any, dataBuffer: any, dataReady: boolean, makeDataReadyCallback: (p1: any, p2: any) => number, makeDataReadyRefcon: any, formatDescription: any, numSamples: number, numSampleTimingEntries: number, sampleTimingArray: CMSampleTimingInfo, numSampleSizeEntries: number, sampleSizeArray: number, sampleBufferOut: any): number;

  // export function CMSampleBufferCreateCopy(allocator: any, sbuf: any, sampleBufferOut: any): number;

  // export function CMSampleBufferCreateCopyWithNewTiming(allocator: any, originalSBuf: any, numSampleTimingEntries: number, sampleTimingArray: CMSampleTimingInfo, sampleBufferOut: any): number;

  // export function CMSampleBufferCreateForImageBuffer(allocator: any, imageBuffer: any, dataReady: boolean, makeDataReadyCallback: (p1: any, p2: any) => number, makeDataReadyRefcon: any, formatDescription: any, sampleTiming: CMSampleTimingInfo, sampleBufferOut: any): number;

  // export function CMSampleBufferCreateForImageBufferWithMakeDataReadyHandler(allocator: any, imageBuffer: any, dataReady: boolean, formatDescription: any, sampleTiming: CMSampleTimingInfo, sampleBufferOut: any, makeDataReadyHandler: (p1: any) => number): number;

  // export function CMSampleBufferCreateReady(allocator: any, dataBuffer: any, formatDescription: any, numSamples: number, numSampleTimingEntries: number, sampleTimingArray: CMSampleTimingInfo, numSampleSizeEntries: number, sampleSizeArray: number, sampleBufferOut: any): number;

  // export function CMSampleBufferCreateReadyWithImageBuffer(allocator: any, imageBuffer: any, formatDescription: any, sampleTiming: CMSampleTimingInfo, sampleBufferOut: any): number;

  // export function CMSampleBufferCreateWithMakeDataReadyHandler(allocator: any, dataBuffer: any, dataReady: boolean, formatDescription: any, numSamples: number, numSampleTimingEntries: number, sampleTimingArray: CMSampleTimingInfo, numSampleSizeEntries: number, sampleSizeArray: number, sampleBufferOut: any, makeDataReadyHandler: (p1: any) => number): number;

  // export function CMSampleBufferDataIsReady(sbuf: any): boolean;

  // export function CMSampleBufferGetAudioBufferListWithRetainedBlockBuffer(sbuf: any, bufferListSizeNeededOut: number, bufferListOut: AudioBufferList, bufferListSize: number, blockBufferStructureAllocator: any, blockBufferBlockAllocator: any, flags: number, blockBufferOut: any): number;

  // export function CMSampleBufferGetAudioStreamPacketDescriptions(sbuf: any, packetDescriptionsSize: number, packetDescriptionsOut: AudioStreamPacketDescription, packetDescriptionsSizeNeededOut: number): number;

  // export function CMSampleBufferGetAudioStreamPacketDescriptionsPtr(sbuf: any, packetDescriptionsPointerOut: AudioStreamPacketDescription, packetDescriptionsSizeOut: number): number;

  // export function CMSampleBufferGetDataBuffer(sbuf: any): any;

  // export function CMSampleBufferGetDecodeTimeStamp(sbuf: any): CMTime;

  // export function CMSampleBufferGetDuration(sbuf: any): CMTime;

  // export function CMSampleBufferGetFormatDescription(sbuf: any): any;

  // export function CMSampleBufferGetImageBuffer(sbuf: any): any;

  // export function CMSampleBufferGetNumSamples(sbuf: any): number;

  // export function CMSampleBufferGetOutputDecodeTimeStamp(sbuf: any): CMTime;

  // export function CMSampleBufferGetOutputDuration(sbuf: any): CMTime;

  // export function CMSampleBufferGetOutputPresentationTimeStamp(sbuf: any): CMTime;

  // export function CMSampleBufferGetOutputSampleTimingInfoArray(sbuf: any, timingArrayEntries: number, timingArrayOut: CMSampleTimingInfo, timingArrayEntriesNeededOut: number): number;

  // export function CMSampleBufferGetPresentationTimeStamp(sbuf: any): CMTime;

  // export function CMSampleBufferGetSampleAttachmentsArray(sbuf: any, createIfNecessary: boolean): any[];

  // export function CMSampleBufferGetSampleSize(sbuf: any, sampleIndex: number): number;

  // export function CMSampleBufferGetSampleSizeArray(sbuf: any, sizeArrayEntries: number, sizeArrayOut: number, sizeArrayEntriesNeededOut: number): number;

  // export function CMSampleBufferGetSampleTimingInfo(sbuf: any, sampleIndex: number, timingInfoOut: CMSampleTimingInfo): number;

  // export function CMSampleBufferGetSampleTimingInfoArray(sbuf: any, numSampleTimingEntries: number, timingArrayOut: CMSampleTimingInfo, timingArrayEntriesNeededOut: number): number;

  // export function CMSampleBufferGetTotalSampleSize(sbuf: any): number;

  // export function CMSampleBufferGetTypeID(): number;

  // export function CMSampleBufferHasDataFailed(sbuf: any, statusOut: number): boolean;

  // export function CMSampleBufferInvalidate(sbuf: any): number;

  // export function CMSampleBufferIsValid(sbuf: any): boolean;

  // export function CMSampleBufferMakeDataReady(sbuf: any): number;

  // export function CMSampleBufferSetDataBuffer(sbuf: any, dataBuffer: any): number;

  // export function CMSampleBufferSetDataBufferFromAudioBufferList(sbuf: any, blockBufferStructureAllocator: any, blockBufferBlockAllocator: any, flags: number, bufferList: AudioBufferList): number;

  // export function CMSampleBufferSetDataFailed(sbuf: any, status: number): number;

  // export function CMSampleBufferSetDataReady(sbuf: any): number;

  // export function CMSampleBufferSetInvalidateCallback(sbuf: any, invalidateCallback: (p1: any, p2: number) => void, invalidateRefCon: number): number;

  // export function CMSampleBufferSetInvalidateHandler(sbuf: any, invalidateHandler: (p1: any) => void): number;

  // export function CMSampleBufferSetOutputPresentationTimeStamp(sbuf: any, outputPresentationTimeStamp: CMTime): number;

  // export function CMSampleBufferTrackDataReadiness(sbuf: any, sampleBufferToTrack: any): number;

  // export function CMSetAttachment(target: any, key: string, value: any, attachmentMode: number): void;

  // export function CMSetAttachments(target: any, theAttachments: Map<any, any>, attachmentMode: number): void;

  // export function CMSimpleQueueCreate(allocator: any, capacity: number, queueOut: any): number;

  // export function CMSimpleQueueDequeue(queue: any): any;

  // export function CMSimpleQueueEnqueue(queue: any, element: any): number;

  // export function CMSimpleQueueGetCapacity(queue: any): number;

  // export function CMSimpleQueueGetCount(queue: any): number;

  // export function CMSimpleQueueGetHead(queue: any): any;

  // export function CMSimpleQueueGetTypeID(): number;

  // export function CMSimpleQueueReset(queue: any): number;

  // export function CMSwapBigEndianClosedCaptionDescriptionToHost(closedCaptionDescriptionData: string | any, closedCaptionDescriptionSize: number): number;

  // export function CMSwapBigEndianImageDescriptionToHost(imageDescriptionData: string | any, imageDescriptionSize: number): number;

  // export function CMSwapBigEndianMetadataDescriptionToHost(metadataDescriptionData: string | any, metadataDescriptionSize: number): number;

  // export function CMSwapBigEndianSoundDescriptionToHost(soundDescriptionData: string | any, soundDescriptionSize: number): number;

  // export function CMSwapBigEndianTextDescriptionToHost(textDescriptionData: string | any, textDescriptionSize: number): number;

  // export function CMSwapBigEndianTimeCodeDescriptionToHost(timeCodeDescriptionData: string | any, timeCodeDescriptionSize: number): number;

  // export function CMSwapHostEndianClosedCaptionDescriptionToBig(closedCaptionDescriptionData: string | any, closedCaptionDescriptionSize: number): number;

  // export function CMSwapHostEndianImageDescriptionToBig(imageDescriptionData: string | any, imageDescriptionSize: number): number;

  // export function CMSwapHostEndianMetadataDescriptionToBig(metadataDescriptionData: string | any, metadataDescriptionSize: number): number;

  // export function CMSwapHostEndianSoundDescriptionToBig(soundDescriptionData: string | any, soundDescriptionSize: number): number;

  // export function CMSwapHostEndianTextDescriptionToBig(textDescriptionData: string | any, textDescriptionSize: number): number;

  // export function CMSwapHostEndianTimeCodeDescriptionToBig(timeCodeDescriptionData: string | any, timeCodeDescriptionSize: number): number;

  // export function CMSyncConvertTime(time: CMTime, fromClockOrTimebase: any, toClockOrTimebase: any): CMTime;

  // export function CMSyncGetRelativeRate(ofClockOrTimebase: any, relativeToClockOrTimebase: any): number;

  // export function CMSyncGetRelativeRateAndAnchorTime(ofClockOrTimebase: any, relativeToClockOrTimebase: any, outRelativeRate: number, outOfClockOrTimebaseAnchorTime: CMTime, outRelativeToClockOrTimebaseAnchorTime: CMTime): number;

  // export function CMSyncGetTime(clockOrTimebase: any): CMTime;

  // export function CMSyncMightDrift(clockOrTimebase1: any, clockOrTimebase2: any): boolean;

  // export function CMTextFormatDescriptionCopyAsBigEndianTextDescriptionBlockBuffer(allocator: any, textFormatDescription: any, flavor: any, blockBufferOut: any): number;

  // export function CMTextFormatDescriptionCreateFromBigEndianTextDescriptionBlockBuffer(allocator: any, textDescriptionBlockBuffer: any, flavor: any, mediaType: number, formatDescriptionOut: any): number;

  // export function CMTextFormatDescriptionCreateFromBigEndianTextDescriptionData(allocator: any, textDescriptionData: string | any, size: number, flavor: any, mediaType: number, formatDescriptionOut: any): number;

  // export function CMTextFormatDescriptionGetDefaultStyle(desc: any, localFontIDOut: number, boldOut: string | any, italicOut: string | any, underlineOut: string | any, fontSizeOut: number, colorComponentsOut: number): number;

  // export function CMTextFormatDescriptionGetDefaultTextBox(desc: any, originIsAtTopLeft: boolean, heightOfTextTrack: number, defaultTextBoxOut: NSRect): number;

  // export function CMTextFormatDescriptionGetDisplayFlags(desc: any, displayFlagsOut: number): number;

  // export function CMTextFormatDescriptionGetFontName(desc: any, localFontID: number, fontNameOut: string): number;

  // export function CMTextFormatDescriptionGetJustification(desc: any, horizontaJustificationlOut: number, verticalJustificationOut: number): number;

  // export function CMTimeAbsoluteValue(time: CMTime): CMTime;

  // export function CMTimeAdd(lhs: CMTime, rhs: CMTime): CMTime;

  // export function CMTimeClampToRange(time: CMTime, range: CMTimeRange): CMTime;

  // export function CMTimeCodeFormatDescriptionCopyAsBigEndianTimeCodeDescriptionBlockBuffer(allocator: any, timeCodeFormatDescription: any, flavor: any, blockBufferOut: any): number;

  // export function CMTimeCodeFormatDescriptionCreate(allocator: any, timeCodeFormatType: number, frameDuration: CMTime, frameQuanta: number, flags: number, extensions: Map<any, any>, formatDescriptionOut: any): number;

  // export function CMTimeCodeFormatDescriptionCreateFromBigEndianTimeCodeDescriptionBlockBuffer(allocator: any, timeCodeDescriptionBlockBuffer: any, flavor: any, formatDescriptionOut: any): number;

  // export function CMTimeCodeFormatDescriptionCreateFromBigEndianTimeCodeDescriptionData(allocator: any, timeCodeDescriptionData: string | any, size: number, flavor: any, formatDescriptionOut: any): number;

  // export function CMTimeCodeFormatDescriptionGetFrameDuration(timeCodeFormatDescription: any): CMTime;

  // export function CMTimeCodeFormatDescriptionGetFrameQuanta(timeCodeFormatDescription: any): number;

  // export function CMTimeCodeFormatDescriptionGetTimeCodeFlags(desc: any): number;

  // export function CMTimeCompare(time1: CMTime, time2: CMTime): number;

  // export function CMTimeConvertScale(time: CMTime, newTimescale: number, method: CMTimeRoundingMethod): CMTime;

  // export function CMTimeCopyAsDictionary(time: CMTime, allocator: any): Map<any, any>;

  // export function CMTimeCopyDescription(allocator: any, time: CMTime): string;

  // export function CMTimeFoldIntoRange(time: CMTime, foldRange: CMTimeRange): CMTime;

  // export function CMTimeGetSeconds(time: CMTime): number;

  // export function CMTimeMake(value: number, timescale: number): CMTime;

  // export function CMTimeMakeFromDictionary(dictionaryRepresentation: Map<any, any>): CMTime;

  // export function CMTimeMakeWithEpoch(value: number, timescale: number, epoch: number): CMTime;

  // export function CMTimeMakeWithSeconds(seconds: number, preferredTimescale: number): CMTime;

  // export function CMTimeMapDurationFromRangeToRange(dur: CMTime, fromRange: CMTimeRange, toRange: CMTimeRange): CMTime;

  // export function CMTimeMapTimeFromRangeToRange(t: CMTime, fromRange: CMTimeRange, toRange: CMTimeRange): CMTime;

  // export function CMTimeMappingCopyAsDictionary(mapping: CMTimeMapping, allocator: any): Map<any, any>;

  // export function CMTimeMappingCopyDescription(allocator: any, mapping: CMTimeMapping): string;

  // export function CMTimeMappingMake(source: CMTimeRange, target: CMTimeRange): CMTimeMapping;

  // export function CMTimeMappingMakeEmpty(target: CMTimeRange): CMTimeMapping;

  // export function CMTimeMappingMakeFromDictionary(dictionaryRepresentation: Map<any, any>): CMTimeMapping;

  // export function CMTimeMappingShow(mapping: CMTimeMapping): void;

  // export function CMTimeMaximum(time1: CMTime, time2: CMTime): CMTime;

  // export function CMTimeMinimum(time1: CMTime, time2: CMTime): CMTime;

  // export function CMTimeMultiply(time: CMTime, multiplier: number): CMTime;

  // export function CMTimeMultiplyByFloat64(time: CMTime, multiplier: number): CMTime;

  // export function CMTimeMultiplyByRatio(time: CMTime, multiplier: number, divisor: number): CMTime;

  // export function CMTimeRangeContainsTime(range: CMTimeRange, time: CMTime): boolean;

  // export function CMTimeRangeContainsTimeRange(range: CMTimeRange, otherRange: CMTimeRange): boolean;

  // export function CMTimeRangeCopyAsDictionary(range: CMTimeRange, allocator: any): Map<any, any>;

  // export function CMTimeRangeCopyDescription(allocator: any, range: CMTimeRange): string;

  // export function CMTimeRangeEqual(range1: CMTimeRange, range2: CMTimeRange): boolean;

  // export function CMTimeRangeFromTimeToTime(start: CMTime, end: CMTime): CMTimeRange;

  // export function CMTimeRangeGetEnd(range: CMTimeRange): CMTime;

  // export function CMTimeRangeGetIntersection(range: CMTimeRange, otherRange: CMTimeRange): CMTimeRange;

  // export function CMTimeRangeGetUnion(range: CMTimeRange, otherRange: CMTimeRange): CMTimeRange;

  // export function CMTimeRangeMake(start: CMTime, duration: CMTime): CMTimeRange;

  // export function CMTimeRangeMakeFromDictionary(dictionaryRepresentation: Map<any, any>): CMTimeRange;

  // export function CMTimeRangeShow(range: CMTimeRange): void;

  // export function CMTimeShow(time: CMTime): void;

  // export function CMTimeSubtract(lhs: CMTime, rhs: CMTime): CMTime;

  // export function CMTimebaseAddTimer(timebase: any, timer: Timer, runloop: any): number;

  // export function CMTimebaseAddTimerDispatchSource(timebase: any, timerSource: NSObject): number;

  // export function CMTimebaseCopyMaster(timebase: any): any;

  // export function CMTimebaseCopyMasterClock(timebase: any): any;

  // export function CMTimebaseCopyMasterTimebase(timebase: any): any;

  // export function CMTimebaseCopyUltimateMasterClock(timebase: any): any;

  // export function CMTimebaseCreateWithMasterClock(allocator: any, masterClock: any, timebaseOut: any): number;

  // export function CMTimebaseCreateWithMasterTimebase(allocator: any, masterTimebase: any, timebaseOut: any): number;

  // export function CMTimebaseGetEffectiveRate(timebase: any): number;

  // export function CMTimebaseGetRate(timebase: any): number;

  // export function CMTimebaseGetTime(timebase: any): CMTime;

  // export function CMTimebaseGetTimeAndRate(timebase: any, timeOut: CMTime, rateOut: number): number;

  // export function CMTimebaseGetTimeWithTimeScale(timebase: any, timescale: number, method: CMTimeRoundingMethod): CMTime;

  // export function CMTimebaseGetTypeID(): number;

  // export function CMTimebaseNotificationBarrier(timebase: any): number;

  // export function CMTimebaseRemoveTimer(timebase: any, timer: Timer): number;

  // export function CMTimebaseRemoveTimerDispatchSource(timebase: any, timerSource: NSObject): number;

  // export function CMTimebaseSetAnchorTime(timebase: any, timebaseTime: CMTime, immediateMasterTime: CMTime): number;

  // export function CMTimebaseSetMasterClock(timebase: any, newMasterClock: any): number;

  // export function CMTimebaseSetMasterTimebase(timebase: any, newMasterTimebase: any): number;

  // export function CMTimebaseSetRate(timebase: any, rate: number): number;

  // export function CMTimebaseSetRateAndAnchorTime(timebase: any, rate: number, timebaseTime: CMTime, immediateMasterTime: CMTime): number;

  // export function CMTimebaseSetTime(timebase: any, time: CMTime): number;

  // export function CMTimebaseSetTimerDispatchSourceNextFireTime(timebase: any, timerSource: NSObject, fireTime: CMTime, flags: number): number;

  // export function CMTimebaseSetTimerDispatchSourceToFireImmediately(timebase: any, timerSource: NSObject): number;

  // export function CMTimebaseSetTimerNextFireTime(timebase: any, timer: Timer, fireTime: CMTime, flags: number): number;

  // export function CMTimebaseSetTimerToFireImmediately(timebase: any, timer: Timer): number;

  // export function CMVideoFormatDescriptionCopyAsBigEndianImageDescriptionBlockBuffer(allocator: any, videoFormatDescription: any, stringEncoding: number, flavor: any, blockBufferOut: any): number;

  // export function CMVideoFormatDescriptionCreate(allocator: any, codecType: number, width: number, height: number, extensions: Map<any, any>, formatDescriptionOut: any): number;

  // export function CMVideoFormatDescriptionCreateForImageBuffer(allocator: any, imageBuffer: any, formatDescriptionOut: any): number;

  // export function CMVideoFormatDescriptionCreateFromBigEndianImageDescriptionBlockBuffer(allocator: any, imageDescriptionBlockBuffer: any, stringEncoding: number, flavor: any, formatDescriptionOut: any): number;

  // export function CMVideoFormatDescriptionCreateFromBigEndianImageDescriptionData(allocator: any, imageDescriptionData: string | any, size: number, stringEncoding: number, flavor: any, formatDescriptionOut: any): number;

  // export function CMVideoFormatDescriptionCreateFromH264ParameterSets(allocator: any, parameterSetCount: number, parameterSetPointers: string, parameterSetSizes: number, NALUnitHeaderLength: number, formatDescriptionOut: any): number;

  // export function CMVideoFormatDescriptionCreateFromHEVCParameterSets(allocator: any, parameterSetCount: number, parameterSetPointers: string, parameterSetSizes: number, NALUnitHeaderLength: number, extensions: Map<any, any>, formatDescriptionOut: any): number;

  // export function CMVideoFormatDescriptionGetCleanAperture(videoDesc: any, originIsAtTopLeft: boolean): CGRect;

  // export function CMVideoFormatDescriptionGetDimensions(videoDesc: any): CMVideoDimensions;

  // export function CMVideoFormatDescriptionGetExtensionKeysCommonWithImageBuffers(): any[];

  // export function CMVideoFormatDescriptionGetH264ParameterSetAtIndex(videoDesc: any, parameterSetIndex: number, parameterSetPointerOut: string, parameterSetSizeOut: number, parameterSetCountOut: number, NALUnitHeaderLengthOut: number): number;

  // export function CMVideoFormatDescriptionGetHEVCParameterSetAtIndex(videoDesc: any, parameterSetIndex: number, parameterSetPointerOut: string, parameterSetSizeOut: number, parameterSetCountOut: number, NALUnitHeaderLengthOut: number): number;

  // export function CMVideoFormatDescriptionGetPresentationDimensions(videoDesc: any, usePixelAspectRatio: boolean, useCleanAperture: boolean): CGSize;

  // export function CMVideoFormatDescriptionMatchesImageBuffer(desc: any, imageBuffer: any): boolean;

  // export function CMIODeviceProcessAVCCommand(deviceID: number, ioAVCCommand: CMIODeviceAVCCommand): number;

  // export function CMIODeviceProcessRS422Command(deviceID: number, ioRS422Command: CMIODeviceRS422Command): number;

  // export function CMIODeviceStartStream(deviceID: number, streamID: number): number;

  // export function CMIODeviceStopStream(deviceID: number, streamID: number): number;

  // export function CMIOObjectAddPropertyListener(objectID: number, address: CMIOObjectPropertyAddress, listener: (p1: number, p2: number, p3: CMIOObjectPropertyAddress, p4: any) => number, clientData: any): number;

  // export function CMIOObjectAddPropertyListenerBlock(objectID: number, address: CMIOObjectPropertyAddress, dispatchQueue: NSObject, listener: (p1: number, p2: CMIOObjectPropertyAddress) => void): number;

  // export function CMIOObjectCreate(owningPlugIn: CMIOHardwarePlugInInterface, owningObjectID: number, classID: number, objectID: number): number;

  // export function CMIOObjectGetPropertyData(objectID: number, address: CMIOObjectPropertyAddress, qualifierDataSize: number, qualifierData: any, dataSize: number, dataUsed: number, data: any): number;

  // export function CMIOObjectGetPropertyDataSize(objectID: number, address: CMIOObjectPropertyAddress, qualifierDataSize: number, qualifierData: any, dataSize: number): number;

  // export function CMIOObjectHasProperty(objectID: number, address: CMIOObjectPropertyAddress): boolean;

  // export function CMIOObjectIsPropertySettable(objectID: number, address: CMIOObjectPropertyAddress, isSettable: string | any): number;

  // export function CMIOObjectPropertiesChanged(owningPlugIn: CMIOHardwarePlugInInterface, objectID: number, numberAddresses: number, addresses: CMIOObjectPropertyAddress): number;

  // export function CMIOObjectRemovePropertyListener(objectID: number, address: CMIOObjectPropertyAddress, listener: (p1: number, p2: number, p3: CMIOObjectPropertyAddress, p4: any) => number, clientData: any): number;

  // export function CMIOObjectRemovePropertyListenerBlock(objectID: number, address: CMIOObjectPropertyAddress, dispatchQueue: NSObject, listener: (p1: number, p2: CMIOObjectPropertyAddress) => void): number;

  // export function CMIOObjectSetPropertyData(objectID: number, address: CMIOObjectPropertyAddress, qualifierDataSize: number, qualifierData: any, dataSize: number, data: any): number;

  // export function CMIOObjectShow(objectID: number): void;

  // export function CMIOObjectsPublishedAndDied(owningPlugIn: CMIOHardwarePlugInInterface, owningObjectID: number, numberPublishedCMIOObjects: number, publishedCMIOObjects: number, numberDeadCMIOObjects: number, deadCMIOObjects: number): number;

  // export function CMIOSampleBufferCopyNonRequiredAttachments(sourceSBuf: any, destSBuf: any, attachmentMode: number): number;

  // export function CMIOSampleBufferCopySampleAttachments(sourceSBuf: any, destSBuf: any): number;

  // export function CMIOSampleBufferCreate(allocator: any, dataBuffer: any, formatDescription: any, numSamples: number, numSampleTimingEntries: number, sampleTimingArray: CMSampleTimingInfo, numSampleSizeEntries: number, sampleSizeArray: number, sequenceNumber: number, discontinuityFlags: number, sBufOut: any): number;

  // export function CMIOSampleBufferCreateForImageBuffer(allocator: any, imageBuffer: any, formatDescription: any, sampleTiming: CMSampleTimingInfo, sequenceNumber: number, discontinuityFlags: number, sBufOut: any): number;

  // export function CMIOSampleBufferCreateNoDataMarker(allocator: any, noDataEvent: number, formatDescription: any, sequenceNumber: number, discontinuityFlags: number, sBufOut: any): number;

  // export function CMIOSampleBufferGetDiscontinuityFlags(sbuf: any): number;

  // export function CMIOSampleBufferGetSequenceNumber(sbuf: any): number;

  // export function CMIOSampleBufferSetDiscontinuityFlags(allocator: any, sbuf: any, discontinuityFlags: number): void;

  // export function CMIOSampleBufferSetSequenceNumber(allocator: any, sbuf: any, sequenceNumber: number): void;

  // export function CMIOStreamClockConvertHostTimeToDeviceTime(hostTime: number, clock: any): CMTime;

  // export function CMIOStreamClockCreate(allocator: any, clockName: string, sourceIdentifier: any, getTimeCallMinimumInterval: CMTime, numberOfEventsForRateSmoothing: number, numberOfAveragesForRateSmoothing: number, clock: any): number;

  // export function CMIOStreamClockInvalidate(clock: any): number;

  // export function CMIOStreamClockPostTimingEvent(eventTime: CMTime, hostTime: number, resynchronize: boolean, clock: any): number;

  // export function CMIOStreamCopyBufferQueue(streamID: number, queueAlteredProc: (p1: number, p2: any, p3: any) => void, queueAlteredRefCon: any, queue: any): number;

  // export function CMIOStreamDeckCueTo(streamID: number, frameNumber: number, playOnCue: boolean): number;

  // export function CMIOStreamDeckJog(streamID: number, speed: number): number;

  // export function CMIOStreamDeckPlay(streamID: number): number;

  // export function CMIOStreamDeckStop(streamID: number): number;

  // interface
  class NSAffineTransform extends NSObject /* implements NSCopying, NSSecureCoding */ {
    transformStruct: NSAffineTransformStruct;
    setTransformStruct(_: NSAffineTransformStruct)
    appendTransform(_: NSAffineTransform): void;
    concat(): void;
    static createWithTransform(transform: NSAffineTransform): NSAffineTransform;
    invert(): void;
    prependTransform(_: NSAffineTransform): void;
    rotateByDegrees(byDegrees: number): void;
    rotateByRadians(byRadians: number): void;
    scaleBy(by: number): void;
    scaleXByYBy(by: number, yBy: number): void;
    set(): void;
    transformBezierPath(_: NSBezierPath): NSBezierPath;
    transformPoint(_: CGPoint): CGPoint;
    transformSize(_: CGSize): CGSize;
    translateXByYBy(by: number, yBy: number): void;
  }

  // export function NSAllHashTableObjects(table: NSHashTable<any>): any[];

  // export function NSAllMapTableKeys(table: NSMapTable<any, any>): any[];

  // export function NSAllMapTableValues(table: NSMapTable<any, any>): any[];

  // export function NSAllocateMemoryPages(bytes: number): any;

  // export function NSAllocateObject(aClass: typeof NSObject, extraBytes: number, zone: any): any;

  // interface
  class NSAppleEventDescriptor extends NSObject /* implements NSCopying, NSSecureCoding */ {
    static appleEventWithEventClassEventIDTargetDescriptorReturnIDTransactionID(withEventClass: number, eventID: number, targetDescriptor?: NSAppleEventDescriptor, returnID?: number, transactionID?: number): NSAppleEventDescriptor;
    static currentProcessDescriptor(): NSAppleEventDescriptor;
    static listDescriptor(): NSAppleEventDescriptor;
    static nullDescriptor(): NSAppleEventDescriptor;
    static recordDescriptor(): NSAppleEventDescriptor;
    aeDesc: AE.AEDataModel;
    booleanValue: boolean;
    data: NSData;
    dateValue: Date;
    descriptorType: number;
    doubleValue: number;
    enumCodeValue: number;
    eventClass: number;
    eventID: number;
    fileURLValue: NSURL;
    int32Value: number;
    isRecordDescriptor: boolean;
    numberOfItems: number;
    returnID: number;
    stringValue: string;
    transactionID: number;
    typeCodeValue: number;
    attributeDescriptorForKeyword(forKeyword: number): NSAppleEventDescriptor;
    coerceToDescriptorType(toDescriptorType: number): NSAppleEventDescriptor;
    descriptorAtIndex(_: number): NSAppleEventDescriptor;
    descriptorForKeyword(_: number): NSAppleEventDescriptor;
    static createWithListDescriptor(): NSAppleEventDescriptor;
    static createWithRecordDescriptor(): NSAppleEventDescriptor;
    static createWithAEDescNoCopy(AEDescNoCopy: AE.AEDataModel): NSAppleEventDescriptor;
    static createWithDescriptorTypeBytesLength(descriptorType: number, bytes?: any, length?: number): NSAppleEventDescriptor;
    static createWithDescriptorTypeData(descriptorType: number, data?: NSData): NSAppleEventDescriptor;
    static createWithEventClassEventIDTargetDescriptorReturnIDTransactionID(eventClass: number, eventID: number, targetDescriptor?: NSAppleEventDescriptor, returnID?: number, transactionID?: number): NSAppleEventDescriptor;
    insertDescriptorAtIndex(_: NSAppleEventDescriptor, at: number): void;
    keywordForDescriptorAtIndex(at: number): number;
    paramDescriptorForKeyword(forKeyword: number): NSAppleEventDescriptor;
    removeDescriptorAtIndex(at: number): void;
    removeDescriptorWithKeyword(withKeyword: number): void;
    removeParamDescriptorWithKeyword(withKeyword: number): void;
    sendEventWithOptionsTimeoutError(timeout: NSAppleEventDescriptor.SendOptions, error: number): NSAppleEventDescriptor;
    setAttributeDescriptorForKeyword(_: NSAppleEventDescriptor, forKeyword: number): void;
    setDescriptorForKeyword(_: NSAppleEventDescriptor, forKeyword: number): void;
    setParamDescriptorForKeyword(_: NSAppleEventDescriptor, forKeyword: number): void;
  }

  // interface
  class NSAppleEventManager extends NSObject {
    static sharedAppleEventManager(): NSAppleEventManager;
    currentAppleEvent: NSAppleEventDescriptor;
    currentReplyAppleEvent: NSAppleEventDescriptor;
    appleEventForSuspensionID(forSuspensionID: any): NSAppleEventDescriptor;
    dispatchRawAppleEventWithRawReplyHandlerRefCon(_: AE.AEDataModel, withRawReply: AE.AEDataModel, handlerRefCon: any): number;
    removeEventHandlerForEventClassAndEventID(forEventClass: number, andEventID: number): void;
    replyAppleEventForSuspensionID(forSuspensionID: any): NSAppleEventDescriptor;
    resumeWithSuspensionID(withSuspensionID: any): void;
    setCurrentAppleEventAndReplyEventWithSuspensionID(_: any): void;
    setEventHandlerAndSelectorForEventClassAndEventID(_: any, andSelector: string, forEventClass: number, andEventID: number): void;
    suspendCurrentAppleEvent(): any;
  }

  // interface
  class NSAppleScript extends NSObject /* implements NSCopying */ {
    isCompiled: boolean;
    richTextSource: NSAttributedString;
    source: string;
    compileAndReturnError(_?: Map<string, any>): boolean;
    executeAndReturnError(_?: Map<string, any>): NSAppleEventDescriptor;
    executeAppleEventError(_: NSAppleEventDescriptor, error?: Map<string, any>): NSAppleEventDescriptor;
    static createWithContentsOfURLError(contentsOfURL: NSURL, error?: Map<string, any>): NSAppleScript;
    static createWithSource(source: string): NSAppleScript;
  }

  // interface
  class NSArray<ObjectType> extends NSObject /* implements NSCopying, NSFastEnumeration, NSMutableCopying, NSSecureCoding */ {
    static arrayWithObjects<ObjectType>(_: ObjectType): NSArray<ObjectType>;
    count: number;
    firstObject: ObjectType;
    lastObject: ObjectType;
    sortedArrayHint: NSData;
    addObserverToObjectsAtIndexesForKeyPathOptionsContext(_: NSObject, toObjectsAt: NSIndexSet, forKeyPath: string, options: NSKeyValueObservingOptions, context?: any): void;
    arrayByAddingObject(_: ObjectType): ObjectType[];
    arrayByAddingObjectsFromArray(from: ObjectType[]): ObjectType[];
    componentsJoinedByString(by: string): string;
    containsObject(_: ObjectType): boolean;
    descriptionWithLocale(withLocale?: any): string;
    descriptionWithLocaleIndent(withLocale?: any, indent?: number): string;
    enumerateObjectsWithAtOptionsUsing(at: NSIndexSet, options: NSEnumerationOptions, using: (p1: ObjectType, p2: number, p3: boolean) => void): void;
    enumerateObjects(_: (p1: ObjectType, p2: number, p3: boolean) => void): void;
    enumerateObjectsWithOptionsUsing(options: NSEnumerationOptions, using: (p1: ObjectType, p2: number, p3: boolean) => void): void;
    filteredArrayUsingPredicate(using: NSPredicate): ObjectType[];
    firstObjectCommonWithArray(with_: ObjectType[]): ObjectType;
    indexOfObject(of: ObjectType): number;
    indexOfObjectInRange(of: ObjectType, in_: NSRange): number;
    indexOfInSortedRangeOptionsUsingComparator(of: ObjectType, inSortedRange: NSRange, options: NSBinarySearchingOptions, usingComparator: (p1: any, p2: any) => ComparisonResult): number;
    indexOfObjectWithAtOptionsPassingTest(at: NSIndexSet, options: NSEnumerationOptions, passingTest: (p1: ObjectType, p2: number, p3: boolean) => boolean): number;
    indexOfObjectIdenticalTo(to: ObjectType): number;
    indexOfObjectIdenticalToInRange(to: ObjectType, in_: NSRange): number;
    indexOfObjectWithPassingTest(passingTest: (p1: ObjectType, p2: number, p3: boolean) => boolean): number;
    indexOfObjectWithOptionsPassingTest(options: NSEnumerationOptions, passingTest: (p1: ObjectType, p2: number, p3: boolean) => boolean): number;
    indexesOfObjectsWithAtOptionsPassingTest(at: NSIndexSet, options: NSEnumerationOptions, passingTest: (p1: ObjectType, p2: number, p3: boolean) => boolean): NSIndexSet;
    indexesOfObjectsWithPassingTest(passingTest: (p1: ObjectType, p2: number, p3: boolean) => boolean): NSIndexSet;
    indexesOfObjectsWithOptionsPassingTest(options: NSEnumerationOptions, passingTest: (p1: ObjectType, p2: number, p3: boolean) => boolean): NSIndexSet;
    isEqualToArray(to: ObjectType[]): boolean;
    objectAtIndex(at: number): ObjectType;
    objectEnumerator(): NSEnumerator<ObjectType>;
    objectsAtIndexes(at: NSIndexSet): ObjectType[];
    pathsMatchingExtensions(_: string[]): string[];
    removeObserverFromObjectsAtIndexesForKeyPath(_: NSObject, fromObjectsAt: NSIndexSet, forKeyPath: string): void;
    removeObserverFromObjectsAtIndexesForKeyPathContext(_: NSObject, fromObjectsAt: NSIndexSet, forKeyPath: string, context?: any): void;
    reverseObjectEnumerator(): NSEnumerator<ObjectType>;
    sortedArrayWithComparator(comparator: (p1: any, p2: any) => ComparisonResult): ObjectType[];
    sortedArrayUsingDescriptors(using: NSSortDescriptor[]): ObjectType[];
    sortedArrayContext(_?: (p1: ObjectType, p2: ObjectType, p3: any) => number, context?: any): ObjectType[];
    sortedArrayContextHint(_?: (p1: ObjectType, p2: ObjectType, p3: any) => number, context?: any, hint?: NSData): ObjectType[];
    sortedArrayUsingSelector(using: string): ObjectType[];
    sortedArrayWithOptionsUsingComparator(options: NSSortOptions, usingComparator: (p1: any, p2: any) => ComparisonResult): ObjectType[];
    subarrayWithRange(with_: NSRange): ObjectType[];
    writeToFileAtomically(toFile: string, atomically: boolean): boolean;
    writeToURLAtomically(to: NSURL, atomically: boolean): boolean;
    writeToURLError(error: NSURL): boolean;
  }

  // interface
  class NSAssertionHandler extends NSObject {
    static currentHandler: NSAssertionHandler;
  }

  // interface
  class NSAttributedString extends NSObject /* implements NSCopying, NSMutableCopying, NSSecureCoding, NSPasteboardReading, NSPasteboardWriting */ {
    containsAttachments: boolean;
    length: number;
    string: string;
    static textTypes: string[];
    static textUnfilteredTypes: string[];
    RTFDFileWrapperFromRangeDocumentAttributes(from: NSRange, documentAttributes: Map<string, any>): FileWrapper;
    RTFDFromRangeDocumentAttributes(from: NSRange, documentAttributes: Map<string, any>): NSData;
    RTFFromRangeDocumentAttributes(from: NSRange, documentAttributes: Map<string, any>): NSData;
    attributeAtIndexEffectiveRange(_: string, at: number, effectiveRange?: NSRange): any;
    attributeAtIndexLongestEffectiveRangeInRange(_: string, at: number, longestEffectiveRange?: NSRange, in_?: NSRange): any;
    attributedSubstringFromRange(from: NSRange): NSAttributedString;
    attributesAtIndexEffectiveRange(at: number, effectiveRange?: NSRange): Map<string, any>;
    attributesAtIndexLongestEffectiveRangeInRange(at: number, longestEffectiveRange?: NSRange, in_?: NSRange): Map<string, any>;
    boundingRectWithSizeOptions(with_: CGSize, options: NSString.DrawingOptions): CGRect;
    boundingRectWithSizeOptionsContext(with_: CGSize, options: NSString.DrawingOptions, context?: NSStringDrawingContext): CGRect;
    containsAttachmentsInRange(in_: NSRange): boolean;
    dataFromRangeDocumentAttributesError(documentAttributes: NSRange, error: Map<string, any>): NSData;
    docFormatFromRangeDocumentAttributes(from: NSRange, documentAttributes: Map<string, any>): NSData;
    doubleClickAtIndex(at: number): NSRange;
    drawAtPoint(at: CGPoint): void;
    drawInRect(in_: CGRect): void;
    drawWithRectOptions(with_: CGRect, options: NSString.DrawingOptions): void;
    drawWithRectOptionsContext(with_: CGRect, options: NSString.DrawingOptions, context?: NSStringDrawingContext): void;
    enumerateAttributeInOptionsUsing(_: string, in_: NSRange, options: NSAttributedString.EnumerationOptions, using?: (p1: any, p2: NSRange, p3: boolean) => void): void;
    enumerateAttributesWithInOptionsUsing(in_: NSRange, options: NSAttributedString.EnumerationOptions, using: (p1: Map<string, any>, p2: NSRange, p3: boolean) => void): void;
    fileWrapperFromRangeDocumentAttributesError(documentAttributes: NSRange, error: Map<string, any>): FileWrapper;
    fontAttributesInRange(in_: NSRange): Map<string, any>;
    static createWithAttributedString(attributedString: NSAttributedString): NSAttributedString;
    static createWithDataOptionsDocumentAttributes(data: NSData, options: Map<string, any>, documentAttributes?: Map<string, any>): NSAttributedString;
    static createWithDocFormatDocumentAttributes(docFormat: NSData, documentAttributes?: Map<string, any>): NSAttributedString;
    static createWithHtmlBaseURLDocumentAttributes(HTML: NSData, baseURL: NSURL, documentAttributes?: Map<string, any>): NSAttributedString;
    static createWithHtmlDocumentAttributes(HTML: NSData, documentAttributes?: Map<string, any>): NSAttributedString;
    static createWithHtmlOptionsDocumentAttributes(HTML: NSData, options: Map<string, any>, documentAttributes?: Map<string, any>): NSAttributedString;
    static createWithRtfDocumentAttributes(RTF: NSData, documentAttributes?: Map<string, any>): NSAttributedString;
    static createWithRtfdDocumentAttributes(RTFD: NSData, documentAttributes?: Map<string, any>): NSAttributedString;
    static createWithRTFDFileWrapperDocumentAttributes(RTFDFileWrapper: FileWrapper, documentAttributes?: Map<string, any>): NSAttributedString;
    static createWithString(string: string): NSAttributedString;
    static createWithStringAttributes(string: string, attributes?: Map<string, any>): NSAttributedString;
    static createWithUrlOptionsDocumentAttributes(URL: NSURL, options: Map<string, any>, documentAttributes?: Map<string, any>): NSAttributedString;
    isEqualToAttributedString(to: NSAttributedString): boolean;
    itemNumberInTextListAtIndex(in_: NSTextList, at: number): number;
    lineBreakBeforeIndexWithinRange(before: number, within: NSRange): number;
    lineBreakByHyphenatingBeforeIndexWithinRange(before: number, within: NSRange): number;
    nextWordFromIndexForward(from: number, forward: boolean): number;
    rangeOfTextBlockAtIndex(of: NSTextBlock, at: number): NSRange;
    rangeOfTextListAtIndex(of: NSTextList, at: number): NSRange;
    rangeOfTextTableAtIndex(of: NSTextTable, at: number): NSRange;
    rulerAttributesInRange(in_: NSRange): Map<string, any>;
    size(): CGSize;
  }

  // interface
  class NSAutoreleasePool extends NSObject {
    static addObject(_: any): void;
    static showPools(): void;
    addObject(_: any): void;
    drain(): void;
  }

  // interface
  class NSBackgroundActivityScheduler extends NSObject {
    identifier: string;
    interval: number;
    setInterval(_: number)
    qualityOfService: QualityOfService;
    setQualityOfService(_: QualityOfService)
    repeats: boolean;
    setRepeats(_: boolean)
    shouldDefer: boolean;
    tolerance: number;
    setTolerance(_: number)
    static createWithIdentifier(identifier: string): NSBackgroundActivityScheduler;
    invalidate(): void;
    schedule(_: (p1: (p1: NSBackgroundActivityScheduler.Result) => void) => void): void;
  }

  // interface
  class BlockOperation extends Operation {
    static blockOperationWithBlock(_: () => void): BlockOperation;
    executionBlocks: () => void[];
    addExecutionBlock(_: () => void): void;
  }

  // interface
  class Bundle extends NSObject {
    static URLForResourceWithExtensionSubdirectoryInBundleWithURL(forResource?: string, withExtension?: string, subdirectory?: string, in_?: NSURL): NSURL;
    static URLsForResourcesWithExtensionSubdirectoryInBundleWithURL(forResourcesWithExtension?: string, subdirectory?: string, in_?: NSURL): NSURL[];
    static pathForResourceOfTypeInDirectory(forResource?: string, ofType?: string, inDirectory?: string): string;
    static pathsForResourcesOfTypeInDirectory(forResourcesOfType?: string, inDirectory?: string): string[];
    static preferredLocalizationsFromArray(_: string[]): string[];
    static preferredLocalizationsFromArrayForPreferences(_: string[], forPreferences?: string[]): string[];
    appStoreReceiptURL: NSURL;
    builtInPlugInsPath: string;
    builtInPlugInsURL: NSURL;
    bundleIdentifier: string;
    bundlePath: string;
    bundleURL: NSURL;
    developmentLocalization: string;
    executableArchitectures: number[];
    executablePath: string;
    executableURL: NSURL;
    infoDictionary: Map<string, any>;
    isLoaded: boolean;
    localizations: string[];
    localizedInfoDictionary: Map<string, any>;
    preferredLocalizations: string[];
    principalClass: typeof NSObject;
    privateFrameworksPath: string;
    privateFrameworksURL: NSURL;
    resourcePath: string;
    resourceURL: NSURL;
    sharedFrameworksPath: string;
    sharedFrameworksURL: NSURL;
    sharedSupportPath: string;
    sharedSupportURL: NSURL;
    static allBundles: Bundle[];
    static allFrameworks: Bundle[];
    static mainBundle: Bundle;
    URLForAuxiliaryExecutable(forAuxiliaryExecutable: string): NSURL;
    URLForImageResource(_: string): NSURL;
    URLForResourceWithExtension(forResource?: string, withExtension?: string): NSURL;
    URLForResourceWithExtensionSubdirectory(forResource?: string, withExtension?: string, subdirectory?: string): NSURL;
    URLForResourceWithExtensionSubdirectoryLocalization(_?: string, withExtension?: string, subdirectory?: string, localization?: string): NSURL;
    URLsForResourcesWithExtensionSubdirectory(forResourcesWithExtension?: string, subdirectory?: string): NSURL[];
    URLsForResourcesWithExtensionSubdirectoryLocalization(forResourcesWithExtension?: string, subdirectory?: string, localization?: string): NSURL[];
    classNamed(_: string): typeof NSObject;
    contextHelpForKey(_: string): NSAttributedString;
    imageForResource(_: string): NSImage;
    static createWithPath(path: string): Bundle;
    static createWithUrl(URL: NSURL): Bundle;
    loadAndReturnError(): boolean;
    loadNibNamedOwnerTopLevelObjects(_: string, owner?: any, topLevelObjects?: any[]): boolean;
    localizedStringForKeyValueTable(_: string, value?: string, table?: string): string;
    objectForInfoDictionaryKey(forInfoDictionaryKey: string): any;
    pathForAuxiliaryExecutable(forAuxiliaryExecutable: string): string;
    pathForImageResource(_: string): string;
    pathForResourceOfType(forResource?: string, ofType?: string): string;
    pathForResourceOfTypeInDirectory(forResource?: string, ofType?: string, inDirectory?: string): string;
    pathForResourceOfTypeInDirectoryForLocalization(forResource?: string, ofType?: string, inDirectory?: string, forLocalization?: string): string;
    pathForSoundResource(_: string): string;
    pathsForResourcesOfTypeInDirectory(forResourcesOfType?: string, inDirectory?: string): string[];
    pathsForResourcesOfTypeInDirectoryForLocalization(forResourcesOfType?: string, inDirectory?: string, forLocalization?: string): string[];
    preflightAndReturnError(): boolean;
    unload(): boolean;
  }

  // interface
  class ByteCountFormatter extends Formatter {
    static stringFromByteCountCountStyle(_: number, countStyle: ByteCountFormatter.CountStyle): string;
    static stringFromMeasurementWithCountStyle(_: NSMeasurement<NSUnitInformationStorage>, countStyle: ByteCountFormatter.CountStyle): string;
    isAdaptive: boolean;
    setAdaptive(_: boolean)
    allowedUnits: ByteCountFormatter.Units;
    setAllowedUnits(_: ByteCountFormatter.Units)
    allowsNonnumericFormatting: boolean;
    setAllowsNonnumericFormatting(_: boolean)
    countStyle: ByteCountFormatter.CountStyle;
    setCountStyle(_: ByteCountFormatter.CountStyle)
    formattingContext: Formatter.Context;
    setFormattingContext(_: Formatter.Context)
    includesActualByteCount: boolean;
    setIncludesActualByteCount(_: boolean)
    includesCount: boolean;
    setIncludesCount(_: boolean)
    includesUnit: boolean;
    setIncludesUnit(_: boolean)
    zeroPadsFractionDigits: boolean;
    setZeroPadsFractionDigits(_: boolean)
    stringFromByteCount(fromByteCount: number): string;
    stringFromMeasurement(_: NSMeasurement<NSUnitInformationStorage>): string;
  }

  // interface
  class NSCache<KeyType, ObjectType> extends NSObject {
    countLimit: number;
    setCountLimit(_: number)
    delegate: NSCacheDelegate;
    setDelegate(_: NSCacheDelegate)
    evictsObjectsWithDiscardedContent: boolean;
    setEvictsObjectsWithDiscardedContent(_: boolean)
    name: string;
    setName(_: string)
    totalCostLimit: number;
    setTotalCostLimit(_: number)
    objectForKey(forKey: KeyType): ObjectType;
    removeAllObjects(): void;
    removeObjectForKey(forKey: KeyType): void;
    setObjectForKey(_: ObjectType, forKey: KeyType): void;
    setObjectForKeyCost(_: ObjectType, forKey: KeyType, cost: number): void;
  }

  interface NSCacheDelegate extends NSObject {
    // instance method
    cacheWillEvictObject?(_: NSCache<any, any>, willEvictObject: any): void;
  }

  // interface
  class CachedURLResponse extends NSObject /* implements NSCopying, NSSecureCoding */ {
    data: NSData;
    response: URLResponse;
    storagePolicy: URLCache.StoragePolicy;
    userInfo: Map<any, any>;
    static createWithResponseData(response: URLResponse, data: NSData): CachedURLResponse;
    static createWithResponseDataUserInfoStoragePolicy(response: URLResponse, data: NSData, userInfo?: Map<any, any>, storagePolicy?: URLCache.StoragePolicy): CachedURLResponse;
  }

  // interface
  class NSCalendar extends NSObject /* implements NSCopying, NSSecureCoding */ {
    AMSymbol: string;
    PMSymbol: string;
    calendarIdentifier: string;
    eraSymbols: string[];
    firstWeekday: number;
    setFirstWeekday(_: number)
    locale: NSLocale;
    setLocale(_: NSLocale)
    longEraSymbols: string[];
    minimumDaysInFirstWeek: number;
    setMinimumDaysInFirstWeek(_: number)
    monthSymbols: string[];
    quarterSymbols: string[];
    shortMonthSymbols: string[];
    shortQuarterSymbols: string[];
    shortStandaloneMonthSymbols: string[];
    shortStandaloneQuarterSymbols: string[];
    shortStandaloneWeekdaySymbols: string[];
    shortWeekdaySymbols: string[];
    standaloneMonthSymbols: string[];
    standaloneQuarterSymbols: string[];
    standaloneWeekdaySymbols: string[];
    timeZone: NSTimeZone;
    setTimeZone(_: NSTimeZone)
    veryShortMonthSymbols: string[];
    veryShortStandaloneMonthSymbols: string[];
    veryShortStandaloneWeekdaySymbols: string[];
    veryShortWeekdaySymbols: string[];
    weekdaySymbols: string[];
    static autoupdatingCurrentCalendar: NSCalendar;
    static currentCalendar: NSCalendar;
    compareDateToDateToUnitGranularity(_: Date, to: Date, toUnitGranularity: NSCalendar.Unit): ComparisonResult;
    componentFromDate(_: NSCalendar.Unit, from: Date): number;
    componentsFromDate(_: NSCalendar.Unit, from: Date): NSDateComponents;
    componentsFromDateToDateOptions(_: NSCalendar.Unit, from: Date, to: Date, options: NSCalendar.Options): NSDateComponents;
    componentsFromDateComponentsToDateComponentsOptions(_: NSCalendar.Unit, from: NSDateComponents, to: NSDateComponents, options: NSCalendar.Options): NSDateComponents;
    componentsInTimeZoneFromDate(in_: NSTimeZone, from: Date): NSDateComponents;
    dateMatchesComponents(_: Date, matchesComponents: NSDateComponents): boolean;
    dateByAddingComponentsToDateOptions(byAdding: NSDateComponents, to: Date, options: NSCalendar.Options): Date;
    dateByAddingUnitValueToDateOptions(byAdding: NSCalendar.Unit, value: number, to: Date, options: NSCalendar.Options): Date;
    dateBySettingHourMinuteSecondOfDateOptions(bySettingHour: number, minute: number, second: number, of: Date, options: NSCalendar.Options): Date;
    dateBySettingUnitValueOfDateOptions(bySettingUnit: NSCalendar.Unit, value: number, of: Date, options: NSCalendar.Options): Date;
    dateFromComponents(from: NSDateComponents): Date;
    dateWithEraYearMonthDayHourMinuteSecondNanosecond(era: number, year: number, month: number, day: number, hour: number, minute: number, second: number, nanosecond: number): Date;
    dateWithEraYearForWeekOfYearWeekOfYearWeekdayHourMinuteSecondNanosecond(era: number, yearForWeekOfYear: number, weekOfYear: number, weekday: number, hour: number, minute: number, second: number, nanosecond: number): Date;
    enumerateDatesWithStartingAfterMatchingOptionsUsing(startingAfter: Date, matching: NSDateComponents, options: NSCalendar.Options, using?: (p1: Date, p2: boolean, p3: boolean) => void): void;
    getEraYearMonthDayFromDate(_?: number, year?: number, month?: number, day?: number, from?: Date): void;
    getEraYearForWeekOfYearWeekOfYearWeekdayFromDate(_?: number, yearForWeekOfYear?: number, weekOfYear?: number, weekday?: number, from?: Date): void;
    getHourMinuteSecondNanosecondFromDate(_?: number, minute?: number, second?: number, nanosecond?: number, from?: Date): void;
    static createWithCalendarIdentifier(calendarIdentifier: string): NSCalendar;
    isDateEqualToDateToUnitGranularity(_: Date, equalTo: Date, toUnitGranularity: NSCalendar.Unit): boolean;
    isDateInSameDayAsDate(_: Date, inSameDayAs: Date): boolean;
    isDateInToday(_: Date): boolean;
    isDateInTomorrow(_: Date): boolean;
    isDateInWeekend(_: Date): boolean;
    isDateInYesterday(_: Date): boolean;
    maximumRangeOfUnit(of: NSCalendar.Unit): NSRange;
    minimumRangeOfUnit(of: NSCalendar.Unit): NSRange;
    nextDateAfterDateMatchingComponentsOptions(after: Date, matching: NSDateComponents, options: NSCalendar.Options): Date;
    nextDateAfterDateMatchingHourMinuteSecondOptions(after: Date, matchingHour: number, minute: number, second: number, options: NSCalendar.Options): Date;
    nextDateAfterDateMatchingUnitValueOptions(after: Date, matching: NSCalendar.Unit, value: number, options: NSCalendar.Options): Date;
    nextWeekendStartDateIntervalOptionsAfterDate(_?: Date, interval?: number, options?: NSCalendar.Options, after?: Date): boolean;
    ordinalityOfUnitInUnitForDate(of: NSCalendar.Unit, in_: NSCalendar.Unit, for_: Date): number;
    rangeOfUnitInUnitForDate(of: NSCalendar.Unit, in_: NSCalendar.Unit, for_: Date): NSRange;
    rangeOfUnitStartDateIntervalForDate(of: NSCalendar.Unit, start?: Date, interval?: number, for_?: Date): boolean;
    rangeOfWeekendStartDateIntervalContainingDate(ofWeekendStart?: Date, interval?: number, containing?: Date): boolean;
    startOfDayForDate(for_: Date): Date;
  }

  // interface
  class NSCharacterSet extends NSObject /* implements NSCopying, NSMutableCopying, NSSecureCoding */ {
    bitmapRepresentation: NSData;
    invertedSet: NSCharacterSet;
    static URLFragmentAllowedCharacterSet: NSCharacterSet;
    static URLHostAllowedCharacterSet: NSCharacterSet;
    static URLPasswordAllowedCharacterSet: NSCharacterSet;
    static URLPathAllowedCharacterSet: NSCharacterSet;
    static URLQueryAllowedCharacterSet: NSCharacterSet;
    static URLUserAllowedCharacterSet: NSCharacterSet;
    static alphanumericCharacterSet: NSCharacterSet;
    static capitalizedLetterCharacterSet: NSCharacterSet;
    static controlCharacterSet: NSCharacterSet;
    static decimalDigitCharacterSet: NSCharacterSet;
    static decomposableCharacterSet: NSCharacterSet;
    static illegalCharacterSet: NSCharacterSet;
    static letterCharacterSet: NSCharacterSet;
    static lowercaseLetterCharacterSet: NSCharacterSet;
    static newlineCharacterSet: NSCharacterSet;
    static nonBaseCharacterSet: NSCharacterSet;
    static punctuationCharacterSet: NSCharacterSet;
    static symbolCharacterSet: NSCharacterSet;
    static uppercaseLetterCharacterSet: NSCharacterSet;
    static whitespaceAndNewlineCharacterSet: NSCharacterSet;
    static whitespaceCharacterSet: NSCharacterSet;
    characterIsMember(_: string): boolean;
    hasMemberInPlane(_: number): boolean;
    isSupersetOfSet(of: NSCharacterSet): boolean;
    longCharacterIsMember(_: number): boolean;
  }

  // interface
  class NSClassDescription extends NSObject {
    static invalidateClassDescriptionCache(): void;
    static registerClassDescriptionForClass(_: NSClassDescription, for_: typeof NSObject): void;
  }

  // export function NSClassFromString(aClassName: string): typeof NSObject;

  // interface
  class NSCloneCommand extends NSScriptCommand {
    keySpecifier: NSScriptObjectSpecifier;
    setReceiversSpecifier(_?: NSScriptObjectSpecifier): void;
  }

  // interface
  class NSCloseCommand extends NSScriptCommand {
    saveOptions: NSSaveOptions;
  }

  // interface
  class NSCoder extends NSObject {
    allowedClasses: NSSet<typeof NSObject>;
    allowsKeyedCoding: boolean;
    decodingFailurePolicy: NSCoder.DecodingFailurePolicy;
    error: NSError;
    requiresSecureCoding: boolean;
    systemVersion: number;
    containsValueForKey(forKey: string): boolean;
    decodeArrayOfObjCTypeCountAt(ofObjCType: string, count: number, at: any): void;
    decodeBoolForKey(forKey: string): boolean;
    decodeBytesForKeyReturnedLength(forKey: string, returnedLength?: number): string;
    decodeBytesWithReturnedLength(withReturnedLength: number): any;
    decodeCMTimeForKey(forKey: string): CMTime;
    decodeCMTimeMappingForKey(forKey: string): CMTimeMapping;
    decodeCMTimeRangeForKey(forKey: string): CMTimeRange;
    decodeDataObject(): NSData;
    decodeDoubleForKey(forKey: string): number;
    decodeFloatForKey(forKey: string): number;
    decodeInt32ForKey(forKey: string): number;
    decodeInt64ForKey(forKey: string): number;
    decodeIntForKey(forKey: string): number;
    decodeIntegerForKey(forKey: string): number;
    decodeObject(): any;
    decodeObjectForKey(forKey: string): any;
    decodePoint(): CGPoint;
    decodePointForKey(forKey: string): CGPoint;
    decodePropertyList(): any;
    decodePropertyListForKey(forKey: string): any;
    decodeRect(): CGRect;
    decodeRectForKey(forKey: string): CGRect;
    decodeSize(): CGSize;
    decodeSizeForKey(forKey: string): CGSize;
    decodeValueOfObjCTypeAt(ofObjCType: string, at: any): void;
    decodeValueOfObjCTypeAtSize(ofObjCType: string, at: any, size: number): void;
    encodeArrayOfObjCTypeCountAt(ofObjCType: string, count: number, at: any): void;
    encodeBoolForKey(_: boolean, forKey: string): void;
    encodeBycopyObject(_?: any): void;
    encodeByrefObject(_?: any): void;
    encodeBytesLength(_?: any, length?: number): void;
    encodeBytesLengthForKey(_?: string, length?: number, forKey?: string): void;
    encodeCMTimeForKey(_: CMTime, forKey: string): void;
    encodeCMTimeMappingForKey(_: CMTimeMapping, forKey: string): void;
    encodeCMTimeRangeForKey(_: CMTimeRange, forKey: string): void;
    encodeConditionalObject(_?: any): void;
    encodeConditionalObjectForKey(_?: any, forKey?: string): void;
    encodeDataObject(_: NSData): void;
    encodeDoubleForKey(_: number, forKey: string): void;
    encodeFloatForKey(_: number, forKey: string): void;
    encodeInt32ForKey(_: number, forKey: string): void;
    encodeInt64ForKey(_: number, forKey: string): void;
    encodeIntForKey(_: number, forKey: string): void;
    encodeIntegerForKey(_: number, forKey: string): void;
    encodeObject(_?: any): void;
    encodeObjectForKey(_?: any, forKey?: string): void;
    encodePoint(_: CGPoint): void;
    encodePointForKey(_: CGPoint, forKey: string): void;
    encodePropertyList(_: any): void;
    encodeRect(_: CGRect): void;
    encodeRectForKey(_: CGRect, forKey: string): void;
    encodeRootObject(_: any): void;
    encodeSize(_: CGSize): void;
    encodeSizeForKey(_: CGSize, forKey: string): void;
    encodeValueOfObjCTypeAt(ofObjCType: string, at: any): void;
    failWithError(_: NSError): void;
    versionForClassName(forClassName: string): number;
  }

  interface NSCoding {
    // instance method
    encodeWithCoder(with_: NSCoder): void;
  }

  // export function NSCompareHashTables(table1: NSHashTable<any>, table2: NSHashTable<any>): boolean;

  // export function NSCompareMapTables(table1: NSMapTable<any, any>, table2: NSMapTable<any, any>): boolean;

  // interface
  class NSComparisonPredicate extends NSPredicate {
    comparisonPredicateModifier: NSComparisonPredicate.Modifier;
    customSelector: string;
    leftExpression: NSExpression;
    options: NSComparisonPredicate.Options;
    predicateOperatorType: NSComparisonPredicate.Operator;
    rightExpression: NSExpression;
    static createWithLeftExpressionRightExpressionCustomSelector(leftExpression: NSExpression, rightExpression: NSExpression, customSelector: string): NSComparisonPredicate;
    static createWithLeftExpressionRightExpressionModifierTypeOptions(leftExpression: NSExpression, rightExpression: NSExpression, modifier: NSComparisonPredicate.Modifier, type: NSComparisonPredicate.Operator, options: NSComparisonPredicate.Options): NSComparisonPredicate;
  }

  // interface
  class NSCompoundPredicate extends NSPredicate {
    compoundPredicateType: NSCompoundPredicate.LogicalType;
    subpredicates: any[];
    static createWithTypeSubpredicates(type: NSCompoundPredicate.LogicalType, subpredicates: NSPredicate[]): NSCompoundPredicate;
  }

  // interface
  class NSCondition extends NSObject /* implements NSLocking */ {
    name: string;
    setName(_: string)
    broadcast(): void;
    signal(): void;
    wait(): void;
    waitUntilDate(until: Date): boolean;
  }

  // interface
  class NSConditionLock extends NSObject /* implements NSLocking */ {
    condition: number;
    name: string;
    setName(_: string)
    static createWithCondition(condition: number): NSConditionLock;
    lockBeforeDate(before: Date): boolean;
    lockWhenCondition(whenCondition: number): void;
    lockWhenConditionBeforeDate(whenCondition: number, before: Date): boolean;
    tryLock(): boolean;
    tryLockWhenCondition(whenCondition: number): boolean;
    unlockWithCondition(withCondition: number): void;
  }

  // export function NSContainsRect(aRect: CGRect, bRect: CGRect): boolean;

  // export function NSCopyHashTableWithZone(table: NSHashTable<any>, zone: any): NSHashTable<any>;

  // export function NSCopyMapTableWithZone(table: NSMapTable<any, any>, zone: any): NSMapTable<any, any>;

  // export function NSCopyMemoryPages(source: any, dest: any, bytes: number): void;

  interface NSCopying {
  }

  // interface
  class NSCountCommand extends NSScriptCommand {
  }

  // export function NSCountFrames(): number;

  // export function NSCountHashTable(table: NSHashTable<any>): number;

  // export function NSCountMapTable(table: NSMapTable<any, any>): number;

  // interface
  class NSCountedSet<ObjectType> extends NSMutableSet<ObjectType> {
    countForObject(for_: ObjectType): number;
  }

  // interface
  class NSCreateCommand extends NSScriptCommand {
    createClassDescription: NSScriptClassDescription;
    resolvedKeyDictionary: Map<string, any>;
  }

  // export function NSCreateHashTable(callBacks: NSHashTableCallBacks, capacity: number): NSHashTable<any>;

  // export function NSCreateHashTableWithZone(callBacks: NSHashTableCallBacks, capacity: number, zone: any): NSHashTable<any>;

  // export function NSCreateMapTable(keyCallBacks: NSMapTableKeyCallBacks, valueCallBacks: NSMapTableValueCallBacks, capacity: number): NSMapTable<any, any>;

  // export function NSCreateMapTableWithZone(keyCallBacks: NSMapTableKeyCallBacks, valueCallBacks: NSMapTableValueCallBacks, capacity: number, zone: any): NSMapTable<any, any>;

  // interface
  class NSData extends NSObject /* implements NSCopying, NSMutableCopying, NSSecureCoding */ {
    static dataWithContentsOfFileOptionsError(options: string, error: NSData.ReadingOptions): NSData;
    static dataWithContentsOfURLOptionsError(options: NSURL, error: NSData.ReadingOptions): NSData;
    bytes: any;
    length: number;
    base64EncodedDataWithOptions(options: NSData.Base64EncodingOptions): NSData;
    base64EncodedStringWithOptions(options: NSData.Base64EncodingOptions): string;
    compressedDataUsingAlgorithmError(using: NSData.CompressionAlgorithm): NSData;
    decompressedDataUsingAlgorithmError(using: NSData.CompressionAlgorithm): NSData;
    enumerateBytes(_: (p1: any, p2: NSRange, p3: boolean) => void): void;
    getBytesLength(_: any, length: number): void;
    getBytesRange(_: any, range: NSRange): void;
    static createWithBase64EncodedDataOptions(base64EncodedData: NSData, options: NSData.Base64DecodingOptions): NSData;
    static createWithBase64EncodedStringOptions(base64EncodedString: string, options: NSData.Base64DecodingOptions): NSData;
    static createWithBytesLength(bytes?: any, length?: number): NSData;
    static createWithBytesNoCopyLength(bytesNoCopy: any, length: number): NSData;
    static createWithBytesNoCopyLengthDeallocator(bytesNoCopy: any, length: number, deallocator?: (p1: any, p2: number) => void): NSData;
    static createWithBytesNoCopyLengthFreeWhenDone(bytesNoCopy: any, length: number, freeWhenDone: boolean): NSData;
    static createWithContentsOfFile(contentsOfFile: string): NSData;
    static createWithContentsOfFileOptions(contentsOfFile: string, options: NSData.ReadingOptions): NSData;
    static createWithContentsOfURL(contentsOfURL: NSURL): NSData;
    static createWithContentsOfURLOptions(contentsOfURL: NSURL, options: NSData.ReadingOptions): NSData;
    static createWithData(data: NSData): NSData;
    isEqualToData(to: NSData): boolean;
    rangeOfDataOptionsRange(of: NSData, options: NSData.SearchOptions, in_: NSRange): NSRange;
    subdataWithRange(with_: NSRange): NSData;
    writeToFileAtomically(toFile: string, atomically: boolean): boolean;
    writeToFileOptionsError(options: string, error: NSData.WritingOptions): boolean;
    writeToURLAtomically(to: NSURL, atomically: boolean): boolean;
    writeToURLOptionsError(options: NSURL, error: NSData.WritingOptions): boolean;
  }

  // interface
  class NSDataDetector extends NSRegularExpression {
    static dataDetectorWithTypesError(error: number): NSDataDetector;
    checkingTypes: number;
    static createWithTypes(types: number): NSDataDetector;
  }

  // interface
  class NSDate extends NSObject /* implements NSCopying, NSSecureCoding */ {
    timeIntervalSince1970: number;
    timeIntervalSinceNow: number;
    static distantFuture: Date;
    static distantPast: Date;
    static now: Date;
    static timeIntervalSinceReferenceDate: number;
    compare(_: Date): ComparisonResult;
    dateByAddingTimeInterval(_: number): NSDate;
    descriptionWithLocale(with_?: any): string;
    earlierDate(_: Date): Date;
    static createWithTimeIntervalSinceDate(timeInterval: number, sinceDate: Date): NSDate;
    static createWithTimeIntervalSince1970(timeIntervalSince1970: number): NSDate;
    static createWithTimeIntervalSinceNow(timeIntervalSinceNow: number): NSDate;
    static createWithTimeIntervalSinceReferenceDate(timeIntervalSinceReferenceDate: number): NSDate;
    isEqualToDate(to: Date): boolean;
    laterDate(_: Date): Date;
    timeIntervalSinceDate(_: Date): number;
  }

  // interface
  class NSDateComponents extends NSObject /* implements NSCopying, NSSecureCoding */ {
    calendar: NSCalendar;
    setCalendar(_: NSCalendar)
    date: Date;
    day: number;
    setDay(_: number)
    era: number;
    setEra(_: number)
    hour: number;
    setHour(_: number)
    isLeapMonth: boolean;
    setLeapMonth(_: boolean)
    minute: number;
    setMinute(_: number)
    month: number;
    setMonth(_: number)
    nanosecond: number;
    setNanosecond(_: number)
    quarter: number;
    setQuarter(_: number)
    second: number;
    setSecond(_: number)
    timeZone: NSTimeZone;
    setTimeZone(_: NSTimeZone)
    isValidDate: boolean;
    weekOfMonth: number;
    setWeekOfMonth(_: number)
    weekOfYear: number;
    setWeekOfYear(_: number)
    weekday: number;
    setWeekday(_: number)
    weekdayOrdinal: number;
    setWeekdayOrdinal(_: number)
    year: number;
    setYear(_: number)
    yearForWeekOfYear: number;
    setYearForWeekOfYear(_: number)
    isValidDateInCalendar(in_: NSCalendar): boolean;
    setValueForComponent(_: number, forComponent: NSCalendar.Unit): void;
    valueForComponent(forComponent: NSCalendar.Unit): number;
  }

  // interface
  class DateComponentsFormatter extends Formatter {
    static localizedStringFromDateComponentsUnitsStyle(_: NSDateComponents, unitsStyle: DateComponentsFormatter.UnitsStyle): string;
    allowedUnits: NSCalendar.Unit;
    setAllowedUnits(_: NSCalendar.Unit)
    allowsFractionalUnits: boolean;
    setAllowsFractionalUnits(_: boolean)
    calendar: NSCalendar;
    setCalendar(_: NSCalendar)
    collapsesLargestUnit: boolean;
    setCollapsesLargestUnit(_: boolean)
    formattingContext: Formatter.Context;
    setFormattingContext(_: Formatter.Context)
    includesApproximationPhrase: boolean;
    setIncludesApproximationPhrase(_: boolean)
    includesTimeRemainingPhrase: boolean;
    setIncludesTimeRemainingPhrase(_: boolean)
    maximumUnitCount: number;
    setMaximumUnitCount(_: number)
    referenceDate: Date;
    setReferenceDate(_: Date)
    unitsStyle: DateComponentsFormatter.UnitsStyle;
    setUnitsStyle(_: DateComponentsFormatter.UnitsStyle)
    zeroFormattingBehavior: DateComponentsFormatter.ZeroFormattingBehavior;
    setZeroFormattingBehavior(_: DateComponentsFormatter.ZeroFormattingBehavior)
    stringFromDateToDate(_: Date, toDate: Date): string;
    stringFromDateComponents(_: NSDateComponents): string;
    stringFromTimeInterval(from: number): string;
  }

  // interface
  class DateFormatter extends Formatter {
    static dateFormatFromTemplateOptionsLocale(_: string, options: number, locale?: NSLocale): string;
    static localizedStringFromDateDateStyleTimeStyle(from: Date, dateStyle: DateFormatter.Style, timeStyle: DateFormatter.Style): string;
    AMSymbol: string;
    setAMSymbol(_: string)
    PMSymbol: string;
    setPMSymbol(_: string)
    calendar: NSCalendar;
    setCalendar(_: NSCalendar)
    dateFormat: string;
    setDateFormat(_: string)
    dateStyle: DateFormatter.Style;
    setDateStyle(_: DateFormatter.Style)
    defaultDate: Date;
    setDefaultDate(_: Date)
    doesRelativeDateFormatting: boolean;
    setDoesRelativeDateFormatting(_: boolean)
    eraSymbols: string[];
    setEraSymbols(_: string[])
    formatterBehavior: DateFormatter.Behavior;
    setFormatterBehavior(_: DateFormatter.Behavior)
    formattingContext: Formatter.Context;
    setFormattingContext(_: Formatter.Context)
    generatesCalendarDates: boolean;
    setGeneratesCalendarDates(_: boolean)
    gregorianStartDate: Date;
    setGregorianStartDate(_: Date)
    isLenient: boolean;
    setLenient(_: boolean)
    locale: NSLocale;
    setLocale(_: NSLocale)
    longEraSymbols: string[];
    setLongEraSymbols(_: string[])
    monthSymbols: string[];
    setMonthSymbols(_: string[])
    quarterSymbols: string[];
    setQuarterSymbols(_: string[])
    shortMonthSymbols: string[];
    setShortMonthSymbols(_: string[])
    shortQuarterSymbols: string[];
    setShortQuarterSymbols(_: string[])
    shortStandaloneMonthSymbols: string[];
    setShortStandaloneMonthSymbols(_: string[])
    shortStandaloneQuarterSymbols: string[];
    setShortStandaloneQuarterSymbols(_: string[])
    shortStandaloneWeekdaySymbols: string[];
    setShortStandaloneWeekdaySymbols(_: string[])
    shortWeekdaySymbols: string[];
    setShortWeekdaySymbols(_: string[])
    standaloneMonthSymbols: string[];
    setStandaloneMonthSymbols(_: string[])
    standaloneQuarterSymbols: string[];
    setStandaloneQuarterSymbols(_: string[])
    standaloneWeekdaySymbols: string[];
    setStandaloneWeekdaySymbols(_: string[])
    timeStyle: DateFormatter.Style;
    setTimeStyle(_: DateFormatter.Style)
    timeZone: NSTimeZone;
    setTimeZone(_: NSTimeZone)
    twoDigitStartDate: Date;
    setTwoDigitStartDate(_: Date)
    veryShortMonthSymbols: string[];
    setVeryShortMonthSymbols(_: string[])
    veryShortStandaloneMonthSymbols: string[];
    setVeryShortStandaloneMonthSymbols(_: string[])
    veryShortStandaloneWeekdaySymbols: string[];
    setVeryShortStandaloneWeekdaySymbols(_: string[])
    veryShortWeekdaySymbols: string[];
    setVeryShortWeekdaySymbols(_: string[])
    weekdaySymbols: string[];
    setWeekdaySymbols(_: string[])
    static defaultFormatterBehavior: DateFormatter.Behavior;
    setDefaultFormatterBehavior(_: DateFormatter.Behavior)
    dateFromString(_: string): Date;
    getObjectValueForStringRangeError(forString?: any, range?: string, error?: NSRange): boolean;
    setLocalizedDateFormatFromTemplate(_: string): void;
    stringFromDate(_: Date): string;
  }

  // interface
  class NSDateInterval extends NSObject /* implements NSCopying, NSSecureCoding */ {
    duration: number;
    endDate: Date;
    startDate: Date;
    compare(_: NSDateInterval): ComparisonResult;
    containsDate(_: Date): boolean;
    static createWithStartDateDuration(startDate: Date, duration: number): NSDateInterval;
    static createWithStartDateEndDate(startDate: Date, endDate: Date): NSDateInterval;
    intersectionWithDateInterval(with_: NSDateInterval): NSDateInterval;
    intersectsDateInterval(_: NSDateInterval): boolean;
    isEqualToDateInterval(to: NSDateInterval): boolean;
  }

  // interface
  class DateIntervalFormatter extends Formatter {
    calendar: NSCalendar;
    setCalendar(_: NSCalendar)
    dateStyle: DateIntervalFormatter.Style;
    setDateStyle(_: DateIntervalFormatter.Style)
    dateTemplate: string;
    setDateTemplate(_: string)
    locale: NSLocale;
    setLocale(_: NSLocale)
    timeStyle: DateIntervalFormatter.Style;
    setTimeStyle(_: DateIntervalFormatter.Style)
    timeZone: NSTimeZone;
    setTimeZone(_: NSTimeZone)
    stringFromDateToDate(_: Date, toDate: Date): string;
    stringFromDateInterval(_: NSDateInterval): string;
  }

  // export function NSDeallocateMemoryPages(ptr: any, bytes: number): void;

  // export function NSDeallocateObject(object_: any): void;

  // export function NSDecimalAdd(result: number, leftOperand: number, rightOperand: number, roundingMode: NSDecimalNumber.RoundingMode): NSDecimalNumber.CalculationError;

  // export function NSDecimalCompact(number: number): void;

  // export function NSDecimalCompare(leftOperand: number, rightOperand: number): ComparisonResult;

  // export function NSDecimalCopy(destination: number, source: number): void;

  // export function NSDecimalDivide(result: number, leftOperand: number, rightOperand: number, roundingMode: NSDecimalNumber.RoundingMode): NSDecimalNumber.CalculationError;

  // export function NSDecimalMultiply(result: number, leftOperand: number, rightOperand: number, roundingMode: NSDecimalNumber.RoundingMode): NSDecimalNumber.CalculationError;

  // export function NSDecimalMultiplyByPowerOf10(result: number, number: number, power: number, roundingMode: NSDecimalNumber.RoundingMode): NSDecimalNumber.CalculationError;

  // export function NSDecimalNormalize(number1: number, number2: number, roundingMode: NSDecimalNumber.RoundingMode): NSDecimalNumber.CalculationError;

  // interface
  class NSDecimalNumber extends NSNumber {
    static defaultBehavior: NSDecimalNumberBehaviors;
    setDefaultBehavior(_: NSDecimalNumberBehaviors)
    static maximumDecimalNumber: NSDecimalNumber;
    static minimumDecimalNumber: NSDecimalNumber;
    static notANumber: NSDecimalNumber;
    static one: NSDecimalNumber;
    static zero: NSDecimalNumber;
    decimalNumberByAdding(_: NSDecimalNumber): NSDecimalNumber;
    decimalNumberByAddingWithBehavior(_: NSDecimalNumber, withBehavior?: NSDecimalNumberBehaviors): NSDecimalNumber;
    decimalNumberByDividingBy(by: NSDecimalNumber): NSDecimalNumber;
    decimalNumberByDividingByWithBehavior(by: NSDecimalNumber, withBehavior?: NSDecimalNumberBehaviors): NSDecimalNumber;
    decimalNumberByMultiplyingBy(by: NSDecimalNumber): NSDecimalNumber;
    decimalNumberByMultiplyingByWithBehavior(by: NSDecimalNumber, withBehavior?: NSDecimalNumberBehaviors): NSDecimalNumber;
    decimalNumberByMultiplyingByPowerOf10(byPowerOf10: number): NSDecimalNumber;
    decimalNumberByMultiplyingByPowerOf10WithBehavior(byPowerOf10: number, withBehavior?: NSDecimalNumberBehaviors): NSDecimalNumber;
    decimalNumberByRaisingToPower(toPower: number): NSDecimalNumber;
    decimalNumberByRaisingToPowerWithBehavior(toPower: number, withBehavior?: NSDecimalNumberBehaviors): NSDecimalNumber;
    decimalNumberByRoundingAccordingToBehavior(accordingToBehavior?: NSDecimalNumberBehaviors): NSDecimalNumber;
    decimalNumberBySubtracting(_: NSDecimalNumber): NSDecimalNumber;
    decimalNumberBySubtractingWithBehavior(_: NSDecimalNumber, withBehavior?: NSDecimalNumberBehaviors): NSDecimalNumber;
    static createWithDecimal(decimal: number): NSDecimalNumber;
    static createWithMantissaExponentIsNegative(mantissa: number, exponent: number, isNegative: boolean): NSDecimalNumber;
    static createWithString(string?: string): NSDecimalNumber;
    static createWithStringLocale(string?: string, locale?: any): NSDecimalNumber;
  }

  interface NSDecimalNumberBehaviors {
    // instance method
    exceptionDuringOperationErrorLeftOperandRightOperand(_: string, error: NSDecimalNumber.CalculationError, leftOperand: NSDecimalNumber, rightOperand?: NSDecimalNumber): NSDecimalNumber;
    // instance method
    roundingMode(): NSDecimalNumber.RoundingMode;
    // instance method
    scale(): number;
  }

  // interface
  class NSDecimalNumberHandler extends NSObject /* implements NSCoding, NSDecimalNumberBehaviors */ {
    static decimalNumberHandlerWithRoundingModeScaleRaiseOnExactnessRaiseOnOverflowRaiseOnUnderflowRaiseOnDivideByZero(roundingMode: NSDecimalNumber.RoundingMode, scale: number, raiseOnExactness: boolean, raiseOnOverflow: boolean, raiseOnUnderflow: boolean, raiseOnDivideByZero: boolean): NSDecimalNumberHandler;
    static defaultDecimalNumberHandler: NSDecimalNumberHandler;
    static createWithRoundingModeScaleRaiseOnExactnessRaiseOnOverflowRaiseOnUnderflowRaiseOnDivideByZero(roundingMode: NSDecimalNumber.RoundingMode, scale: number, raiseOnExactness: boolean, raiseOnOverflow: boolean, raiseOnUnderflow: boolean, raiseOnDivideByZero: boolean): NSDecimalNumberHandler;
  }

  // export function NSDecimalPower(result: number, number: number, power: number, roundingMode: NSDecimalNumber.RoundingMode): NSDecimalNumber.CalculationError;

  // export function NSDecimalRound(result: number, number: number, scale: number, roundingMode: NSDecimalNumber.RoundingMode): void;

  // export function NSDecimalString(dcm: number, locale: any): string;

  // export function NSDecimalSubtract(result: number, leftOperand: number, rightOperand: number, roundingMode: NSDecimalNumber.RoundingMode): NSDecimalNumber.CalculationError;

  // export function NSDecrementExtraRefCountWasZero(object_: any): boolean;

  // interface
  class NSDeleteCommand extends NSScriptCommand {
    keySpecifier: NSScriptObjectSpecifier;
    setReceiversSpecifier(_?: NSScriptObjectSpecifier): void;
  }

  // interface
  class NSDictionary<KeyType, ObjectType> extends NSObject /* implements NSCopying, NSFastEnumeration, NSMutableCopying, NSSecureCoding, NSFastEnumeration, NSFetchRequestResult */ {
    static sharedKeySetWithForKeys<KeyType>(forKeys: KeyType[]): any;
    allKeys: KeyType[];
    allValues: ObjectType[];
    count: number;
    descriptionInStringsFileFormat: string;
    allKeysForObject(for_: ObjectType): KeyType[];
    countByEnumeratingWithStateObjectsCount(with_: NSFastEnumerationState, objects?: K, count?: number): number;
    descriptionWithLocale(withLocale?: any): string;
    descriptionWithLocaleIndent(withLocale?: any, indent?: number): string;
    enumerateKeysAndObjects(_: (p1: KeyType, p2: ObjectType, p3: boolean) => void): void;
    enumerateKeysAndObjectsWithOptionsUsing(options: NSEnumerationOptions, using: (p1: KeyType, p2: ObjectType, p3: boolean) => void): void;
    fileCreationDate(): Date;
    fileExtensionHidden(): boolean;
    fileGroupOwnerAccountID(): number;
    fileGroupOwnerAccountName(): string;
    fileHFSCreatorCode(): number;
    fileHFSTypeCode(): number;
    fileIsAppendOnly(): boolean;
    fileIsImmutable(): boolean;
    fileModificationDate(): Date;
    fileOwnerAccountID(): number;
    fileOwnerAccountName(): string;
    filePosixPermissions(): number;
    fileSize(): number;
    fileSystemFileNumber(): number;
    fileSystemNumber(): number;
    fileType(): string;
    isEqualToDictionary(to: Map<KeyType, ObjectType>): boolean;
    keyEnumerator(): NSEnumerator<KeyType>;
    keysOfEntriesWithPassingTest(passingTest: (p1: KeyType, p2: ObjectType, p3: boolean) => boolean): NSSet<KeyType>;
    keysOfEntriesWithOptionsPassingTest(options: NSEnumerationOptions, passingTest: (p1: KeyType, p2: ObjectType, p3: boolean) => boolean): NSSet<KeyType>;
    keysSortedByValueWithComparator(comparator: (p1: any, p2: any) => ComparisonResult): KeyType[];
    keysSortedByValueUsingSelector(using: string): KeyType[];
    keysSortedByValueWithOptionsUsingComparator(options: NSSortOptions, usingComparator: (p1: any, p2: any) => ComparisonResult): KeyType[];
    objectEnumerator(): NSEnumerator<ObjectType>;
    objectForKey(forKey: KeyType): ObjectType;
    objectsForKeysNotFoundMarker(forKeys: KeyType[], notFoundMarker: ObjectType): ObjectType[];
    writeToFileAtomically(toFile: string, atomically: boolean): boolean;
    writeToURLAtomically(to: NSURL, atomically: boolean): boolean;
    writeToURLError(error: NSURL): boolean;
  }

  // interface
  class Dimension extends Unit /* implements NSSecureCoding */ {
    static baseUnit(): Dimension;
    converter: UnitConverter;
    static createWithSymbolConverter(symbol: string, converter: UnitConverter): Dimension;
  }

  // interface
  class DirectoryEnumerator<ObjectType> extends NSEnumerator<ObjectType> {
    directoryAttributes: Map<string, any>;
    fileAttributes: Map<string, any>;
    isEnumeratingDirectoryPostOrder: boolean;
    level: number;
    skipDescendants(): void;
    skipDescendents(): void;
  }

  interface NSDiscardableContent {
    // instance method
    beginContentAccess(): boolean;
    // instance method
    discardContentIfPossible(): void;
    // instance method
    endContentAccess(): void;
    // instance method
    isContentDiscarded(): boolean;
  }

  // interface
  class NSDistributedLock extends NSObject {
    lockDate: Date;
    breakLock(): void;
    static createWithPath(path: string): NSDistributedLock;
    tryLock(): boolean;
    unlock(): void;
  }

  // interface
  class DistributedNotificationCenter extends NotificationCenter {
    suspended: boolean;
    setSuspended(_: boolean)
    addObserverSelectorNameObjectSuspensionBehavior(_: any, selector: string, name?: string, object_?: string, suspensionBehavior?: DistributedNotificationCenter.SuspensionBehavior): void;
    postNotificationNameObjectUserInfoDeliverImmediately(_: string, object_?: string, userInfo?: Map<any, any>, deliverImmediately?: boolean): void;
    postNotificationNameObjectUserInfoOptions(_: string, object_?: string, userInfo?: Map<any, any>, options?: DistributedNotificationCenter.Options): void;
  }

  // export function NSDivideRect(inRect: CGRect, slice: NSRect, rem: NSRect, amount: number, edge: NSRectEdge): void;

  // export function NSEdgeInsetsEqual(aInsets: NSEdgeInsets, bInsets: NSEdgeInsets): boolean;

  // export function NSEndHashTableEnumeration(enumerator: NSHashEnumerator): void;

  // export function NSEndMapTableEnumeration(enumerator: NSMapEnumerator): void;

  // interface
  class EnergyFormatter extends Formatter {
    isForFoodEnergyUse: boolean;
    setForFoodEnergyUse(_: boolean)
    numberFormatter: NumberFormatter;
    setNumberFormatter(_: NumberFormatter)
    unitStyle: Formatter.UnitStyle;
    setUnitStyle(_: Formatter.UnitStyle)
    stringFromJoules(_: number): string;
    stringFromValueUnit(_: number, unit: EnergyFormatter.Unit): string;
    unitStringFromJoulesUsedUnit(_: number, usedUnit?: EnergyFormatter.Unit): string;
    unitStringFromValueUnit(_: number, unit: EnergyFormatter.Unit): string;
  }

  // export function NSEnumerateHashTable(table: NSHashTable<any>): NSHashEnumerator;

  // export function NSEnumerateMapTable(table: NSMapTable<any, any>): NSMapEnumerator;

  // interface
  class NSEnumerator<ObjectType> extends NSObject /* implements NSFastEnumeration */ {
    allObjects: ObjectType[];
    nextObject(): ObjectType;
  }

  // export function NSEqualPoints(aPoint: CGPoint, bPoint: CGPoint): boolean;

  // export function NSEqualRects(aRect: CGRect, bRect: CGRect): boolean;

  // export function NSEqualSizes(aSize: CGSize, bSize: CGSize): boolean;

  // interface
  class NSError extends NSObject /* implements NSCopying, NSSecureCoding */ {
    static setUserInfoValueProviderWithForDomainProvider(forDomain: string, provider?: (p1: NSError, p2: string) => any): void;
    static userInfoValueProviderForDomain(forDomain: string): (p1: NSError, p2: string) => any;
    code: number;
    domain: string;
    helpAnchor: string;
    localizedDescription: string;
    localizedFailureReason: string;
    localizedRecoveryOptions: string[];
    localizedRecoverySuggestion: string;
    recoveryAttempter: any;
    userInfo: Map<string, any>;
    static createWithDomainCodeUserInfo(domain: string, code: number, userInfo?: Map<string, any>): NSError;
  }

  // interface
  class NSException extends NSObject /* implements NSCopying, NSSecureCoding */ {
    callStackReturnAddresses: number[];
    callStackSymbols: string[];
    name: string;
    reason: string;
    userInfo: Map<any, any>;
    static createWithNameReasonUserInfo(name: string, reason?: string, userInfo?: Map<any, any>): NSException;
    raise(): void;
  }

  // interface
  class NSExistsCommand extends NSScriptCommand {
  }

  // interface
  class NSExpression extends NSObject /* implements NSCopying, NSSecureCoding */ {
    static expressionForAnyKey(): NSExpression;
    static expressionForEvaluatedObject(): NSExpression;
    arguments: NSExpression[];
    collection: any;
    constantValue: any;
    expressionBlock: (p1: any, p2: NSExpression[], p3: NSMutableDictionary<any, any>) => any;
    expressionType: NSExpression.ExpressionType;
    falseExpression: NSExpression;
    function: string;
    keyPath: string;
    leftExpression: NSExpression;
    operand: NSExpression;
    predicate: NSPredicate;
    rightExpression: NSExpression;
    trueExpression: NSExpression;
    variable: string;
    allowEvaluation(): void;
    expressionValueWithObjectContext(with_?: any, context?: NSMutableDictionary<any, any>): any;
    static createWithExpressionType(expressionType: NSExpression.ExpressionType): NSExpression;
  }

  // interface
  class NSExtensionContext extends NSObject {
    inputItems: any[];
    cancelRequestWithError(withError: NSError): void;
    completeRequestWithReturningItemsCompletionHandler(returningItems?: any[], completionHandler?: (p1: boolean) => void): void;
    openCompletionHandler(_: NSURL, completionHandler?: (p1: boolean) => void): void;
  }

  // interface
  class NSExtensionItem extends NSObject /* implements NSCopying, NSSecureCoding */ {
    attachments: NSItemProvider[];
    setAttachments(_: NSItemProvider[])
    attributedContentText: NSAttributedString;
    setAttributedContentText(_: NSAttributedString)
    attributedTitle: NSAttributedString;
    setAttributedTitle(_: NSAttributedString)
    userInfo: Map<any, any>;
    setUserInfo(_: Map<any, any>)
  }

  interface NSExtensionRequestHandling extends NSObject {
    // instance method
    beginRequestWithExtensionContext(with_: NSExtensionContext): void;
  }

  // export function NSExtraRefCount(object_: any): number;

  interface NSFastEnumeration {
    // instance method
    countByEnumeratingWithStateObjectsCount(with_: NSFastEnumerationState, objects?: any, count?: number): number;
  }

  // interface
  class NSFileAccessIntent extends NSObject {
    static readingIntentWithURLOptions(with_: NSURL, options: NSFileCoordinator.ReadingOptions): NSFileAccessIntent;
    static writingIntentWithURLOptions(with_: NSURL, options: NSFileCoordinator.WritingOptions): NSFileAccessIntent;
    URL: NSURL;
  }

  // interface
  class NSFileCoordinator extends NSObject {
    static addFilePresenter(_: NSFilePresenter): void;
    static removeFilePresenter(_: NSFilePresenter): void;
    purposeIdentifier: string;
    setPurposeIdentifier(_: string)
    static filePresenters: NSFilePresenter[];
    cancel(): void;
    coordinateWithWithQueueByAccessor(with_: NSFileAccessIntent[], queue: OperationQueue, byAccessor?: (p1: NSError) => void): void;
    coordinateWithReadingItemAtOptionsErrorByAccessor(readingItemAt: NSURL, options: NSFileCoordinator.ReadingOptions, error?: Error, byAccessor?: (p1: NSURL) => void): void;
    coordinateWithReadingItemAtOptionsWritingItemAtOptionsErrorByAccessor(readingItemAt: NSURL, options: NSFileCoordinator.ReadingOptions, writingItemAt: NSURL, options2: NSFileCoordinator.WritingOptions, error?: Error, byAccessor?: (p1: NSURL, p2: NSURL) => void): void;
    coordinateWithWritingItemAtOptionsErrorByAccessor(writingItemAt: NSURL, options: NSFileCoordinator.WritingOptions, error?: Error, byAccessor?: (p1: NSURL) => void): void;
    coordinateWithWritingItemAtOptionsWritingItemAtOptionsErrorByAccessor(writingItemAt: NSURL, options: NSFileCoordinator.WritingOptions, writingItemAt2: NSURL, options2: NSFileCoordinator.WritingOptions, error?: Error, byAccessor?: (p1: NSURL, p2: NSURL) => void): void;
    static createWithFilePresenter(filePresenter?: NSFilePresenter): NSFileCoordinator;
    itemWithAtDidChangeUbiquityAttributes(at: NSURL, didChangeUbiquityAttributes: NSSet<string>): void;
    itemAtURLDidMoveToURL(at: NSURL, didMoveTo: NSURL): void;
    itemAtURLWillMoveToURL(at: NSURL, willMoveTo: NSURL): void;
    prepareWithForReadingItemsAtOptionsWritingItemsAtOptionsErrorByAccessor(forReadingItemsAt: NSURL[], options: NSFileCoordinator.ReadingOptions, writingItemsAt: NSURL[], options2: NSFileCoordinator.WritingOptions, error?: Error, byAccessor?: (p1: () => void) => void): void;
  }

  // interface
  class FileHandle extends NSObject /* implements NSSecureCoding */ {
    static fileHandleForReadingFromURLError(error: NSURL): FileHandle;
    static fileHandleForUpdatingURLError(error: NSURL): FileHandle;
    static fileHandleForWritingToURLError(error: NSURL): FileHandle;
    availableData: NSData;
    fileDescriptor: number;
    offsetInFile: number;
    readabilityHandler: (p1: FileHandle) => void;
    setReadabilityHandler(_: (p1: FileHandle) => void)
    writeabilityHandler: (p1: FileHandle) => void;
    setWriteabilityHandler(_: (p1: FileHandle) => void)
    static fileHandleWithNullDevice: FileHandle;
    static fileHandleWithStandardError: FileHandle;
    static fileHandleWithStandardInput: FileHandle;
    static fileHandleWithStandardOutput: FileHandle;
    acceptConnectionInBackgroundAndNotify(): void;
    acceptConnectionInBackgroundAndNotifyForModes(_?: string[]): void;
    closeAndReturnError(): boolean;
    closeFile(): void;
    getOffsetError(error: number): boolean;
    static createWithFileDescriptor(fileDescriptor: number): FileHandle;
    static createWithFileDescriptorCloseOnDealloc(fileDescriptor: number, closeOnDealloc: boolean): FileHandle;
    readDataOfLength(_: number): NSData;
    readDataToEndOfFile(): NSData;
    readDataToEndOfFileAndReturnError(): NSData;
    readDataUpToLengthError(error: number): NSData;
    readInBackgroundAndNotify(): void;
    readInBackgroundAndNotifyForModes(_?: string[]): void;
    readToEndOfFileInBackgroundAndNotify(): void;
    readToEndOfFileInBackgroundAndNotifyForModes(_?: string[]): void;
    seekToEndOfFile(): number;
    seekToEndReturningOffsetError(error?: number): boolean;
    seekToFileOffset(_: number): void;
    seekToOffsetError(error: number): boolean;
    synchronizeAndReturnError(): boolean;
    synchronizeFile(): void;
    truncateAtOffsetError(error: number): boolean;
    truncateFileAtOffset(_: number): void;
    waitForDataInBackgroundAndNotify(): void;
    waitForDataInBackgroundAndNotifyForModes(_?: string[]): void;
    writeData(_: NSData): void;
    writeDataError(error: NSData): boolean;
  }

  // interface
  class FileManager extends NSObject {
    currentDirectoryPath: string;
    delegate: FileManagerDelegate;
    setDelegate(_: FileManagerDelegate)
    homeDirectoryForCurrentUser: NSURL;
    temporaryDirectory: NSURL;
    ubiquityIdentityToken: any;
    static defaultManager: FileManager;
    URLForDirectoryInDomainAppropriateForURLCreateError(for_: FileManager.SearchPathDirectory, in_: FileManager.SearchPathDomainMask, appropriateFor?: NSURL, create?: boolean): NSURL;
    URLForPublishingUbiquitousItemAtURLExpirationDateError(forPublishingUbiquitousItemAt: NSURL, expiration?: Date): NSURL;
    URLForUbiquityContainerIdentifier(forUbiquityContainerIdentifier?: string): NSURL;
    URLsForDirectoryInDomains(for_: FileManager.SearchPathDirectory, in_: FileManager.SearchPathDomainMask): NSURL[];
    attributesOfFileSystemForPathError(error: string): Map<string, any>;
    attributesOfItemAtPathError(error: string): Map<string, any>;
    changeCurrentDirectoryPath(_: string): boolean;
    componentsToDisplayForPath(_: string): string[];
    containerURLForSecurityApplicationGroupIdentifier(forSecurityApplicationGroupIdentifier: string): NSURL;
    contentsAtPath(_: string): NSData;
    contentsEqualAtPathAndPath(_: string, andPath: string): boolean;
    contentsOfDirectoryAtPathError(error: string): string[];
    contentsOfDirectoryAtURLIncludingPropertiesForKeysOptionsError(includingPropertiesForKeys: NSURL, options?: string[], error?: FileManager.DirectoryEnumerationOptions): NSURL[];
    copyItemAtPathToPathError(toPath: string, error: string): boolean;
    copyItemAtURLToURLError(toURL: NSURL, error: NSURL): boolean;
    createDirectoryAtPathWithIntermediateDirectoriesAttributesError(withIntermediateDirectories: string, attributes: boolean, error?: Map<string, any>): boolean;
    createDirectoryAtURLWithIntermediateDirectoriesAttributesError(withIntermediateDirectories: NSURL, attributes: boolean, error?: Map<string, any>): boolean;
    createFileAtPathContentsAttributes(_: string, contents?: NSData, attributes?: Map<string, any>): boolean;
    createSymbolicLinkAtPathWithDestinationPathError(withDestinationPath: string, error: string): boolean;
    createSymbolicLinkAtURLWithDestinationURLError(withDestinationURL: NSURL, error: NSURL): boolean;
    destinationOfSymbolicLinkAtPathError(error: string): string;
    displayNameAtPath(_: string): string;
    enumeratorAtPath(_: string): DirectoryEnumerator<string>;
    enumeratorAtURLWithIncludingPropertiesForKeysOptionsErrorHandler(_: NSURL, includingPropertiesForKeys?: string[], options?: FileManager.DirectoryEnumerationOptions, errorHandler?: (p1: NSURL, p2: NSError) => boolean): DirectoryEnumerator<NSURL>;
    evictUbiquitousItemAtURLError(error: NSURL): boolean;
    fileExistsAtPath(_: string): boolean;
    fileExistsAtPathIsDirectory(_: string, isDirectory?: boolean): boolean;
    fileSystemRepresentationWithPath(_: string): string;
    getFileProviderServicesForItemAtURLWithCompletionHandler(_: NSURL, completionHandler?: (p1: Map<string, NSFileProviderService>, p2: NSError) => void): void;
    getRelationshipOfDirectoryInDomainToItemAtURLError(ofDirectory: FileManager.URLRelationship, inDomain: FileManager.SearchPathDirectory, toItemAtURL: FileManager.SearchPathDomainMask, error: NSURL): boolean;
    getRelationshipOfDirectoryAtURLToItemAtURLError(ofDirectoryAtURL: FileManager.URLRelationship, toItemAtURL: NSURL, error: NSURL): boolean;
    homeDirectoryForUser(_: string): NSURL;
    isDeletableFileAtPath(_: string): boolean;
    isExecutableFileAtPath(_: string): boolean;
    isReadableFileAtPath(_: string): boolean;
    isUbiquitousItemAtURL(_: NSURL): boolean;
    isWritableFileAtPath(_: string): boolean;
    linkItemAtPathToPathError(toPath: string, error: string): boolean;
    linkItemAtURLToURLError(toURL: NSURL, error: NSURL): boolean;
    mountedVolumeURLsIncludingResourceValuesForKeysOptions(includingResourceValuesForKeys?: string[], options?: FileManager.VolumeEnumerationOptions): NSURL[];
    moveItemAtPathToPathError(toPath: string, error: string): boolean;
    moveItemAtURLToURLError(toURL: NSURL, error: NSURL): boolean;
    removeItemAtPathError(error: string): boolean;
    removeItemAtURLError(error: NSURL): boolean;
    replaceItemAtURLWithItemAtURLBackupItemNameOptionsResultingItemURLError(withItemAtURL: NSURL, backupItemName: NSURL, options?: string, resultingItemURL?: FileManager.ItemReplacementOptions, error?: NSURL): boolean;
    setAttributesOfItemAtPathError(ofItemAtPath: Map<string, any>, error: string): boolean;
    setUbiquitousItemAtURLDestinationURLError(itemAtURL: boolean, destinationURL: NSURL, error: NSURL): boolean;
    startDownloadingUbiquitousItemAtURLError(error: NSURL): boolean;
    stringWithFileSystemRepresentationLength(_: string, length: number): string;
    subpathsAtPath(_: string): string[];
    subpathsOfDirectoryAtPathError(error: string): string[];
    trashItemAtURLResultingItemURLError(resultingItemURL: NSURL, error?: NSURL): boolean;
    unmountVolumeAtURLWithOptionsCompletionHandler(_: NSURL, options: FileManager.UnmountOptions, completionHandler?: (p1: NSError) => void): void;
  }

  interface FileManagerDelegate extends NSObject {
    // instance method
    fileManagerShouldCopyItemAtPathToPath?(_: FileManager, shouldCopyItemAtPath: string, toPath: string): boolean;
    // instance method
    fileManagerShouldCopyItemAtURLToURL?(_: FileManager, shouldCopyItemAtURL: NSURL, toURL: NSURL): boolean;
    // instance method
    fileManagerShouldLinkItemAtPathToPath?(_: FileManager, shouldLinkItemAtPath: string, toPath: string): boolean;
    // instance method
    fileManagerShouldLinkItemAtURLToURL?(_: FileManager, shouldLinkItemAtURL: NSURL, toURL: NSURL): boolean;
    // instance method
    fileManagerShouldMoveItemAtPathToPath?(_: FileManager, shouldMoveItemAtPath: string, toPath: string): boolean;
    // instance method
    fileManagerShouldMoveItemAtURLToURL?(_: FileManager, shouldMoveItemAtURL: NSURL, toURL: NSURL): boolean;
    // instance method
    fileManagerShouldProceedAfterErrorCopyingItemAtPathToPath?(_: FileManager, shouldProceedAfterError: NSError, copyingItemAtPath: string, toPath: string): boolean;
    // instance method
    fileManagerShouldProceedAfterErrorCopyingItemAtURLToURL?(_: FileManager, shouldProceedAfterError: NSError, copyingItemAtURL: NSURL, toURL: NSURL): boolean;
    // instance method
    fileManagerShouldProceedAfterErrorLinkingItemAtPathToPath?(_: FileManager, shouldProceedAfterError: NSError, linkingItemAtPath: string, toPath: string): boolean;
    // instance method
    fileManagerShouldProceedAfterErrorLinkingItemAtURLToURL?(_: FileManager, shouldProceedAfterError: NSError, linkingItemAtURL: NSURL, toURL: NSURL): boolean;
    // instance method
    fileManagerShouldProceedAfterErrorMovingItemAtPathToPath?(_: FileManager, shouldProceedAfterError: NSError, movingItemAtPath: string, toPath: string): boolean;
    // instance method
    fileManagerShouldProceedAfterErrorMovingItemAtURLToURL?(_: FileManager, shouldProceedAfterError: NSError, movingItemAtURL: NSURL, toURL: NSURL): boolean;
    // instance method
    fileManagerShouldProceedAfterErrorRemovingItemAtPath?(_: FileManager, shouldProceedAfterError: NSError, removingItemAtPath: string): boolean;
    // instance method
    fileManagerShouldProceedAfterErrorRemovingItemAtURL?(_: FileManager, shouldProceedAfterError: NSError, removingItemAtURL: NSURL): boolean;
    // instance method
    fileManagerShouldRemoveItemAtPath?(_: FileManager, shouldRemoveItemAtPath: string): boolean;
    // instance method
    fileManagerShouldRemoveItemAtURL?(_: FileManager, shouldRemoveItemAtURL: NSURL): boolean;
  }

  interface NSFilePresenter extends NSObject {
    observedPresentedItemUbiquityAttributes?: NSSet<string>;
    presentedItemOperationQueue: OperationQueue;
    presentedItemURL: NSURL;
    primaryPresentedItemURL?: NSURL;
    // instance method
    accommodatePresentedItemDeletionWithCompletionHandler?(completionHandler?: (p1: NSError) => void): void;
    // instance method
    accommodatePresentedSubitemDeletionWithAtCompletionHandler?(at: NSURL, completionHandler?: (p1: NSError) => void): void;
    // instance method
    presentedItemDidChange?(): void;
    // instance method
    presentedItemDidChangeUbiquityAttributes?(_: NSSet<string>): void;
    // instance method
    presentedItemDidGainVersion?(_: NSFileVersion): void;
    // instance method
    presentedItemDidLoseVersion?(_: NSFileVersion): void;
    // instance method
    presentedItemDidMoveToURL?(to: NSURL): void;
    // instance method
    presentedItemDidResolveConflictVersion?(_: NSFileVersion): void;
    // instance method
    presentedSubitemAtURLDidMoveToURL?(at: NSURL, didMoveTo: NSURL): void;
    // instance method
    presentedSubitemAtURLDidGainVersion?(at: NSURL, didGain: NSFileVersion): void;
    // instance method
    presentedSubitemAtURLDidLoseVersion?(at: NSURL, didLose: NSFileVersion): void;
    // instance method
    presentedSubitemAtURLDidResolveConflictVersion?(at: NSURL, didResolve: NSFileVersion): void;
    // instance method
    presentedSubitemDidAppearAtURL?(at: NSURL): void;
    // instance method
    presentedSubitemDidChangeAtURL?(at: NSURL): void;
    // instance method
    relinquishPresentedItemWithToReader?(toReader?: (p1: () => void) => void): void;
    // instance method
    relinquishPresentedItemWithToWriter?(toWriter?: (p1: () => void) => void): void;
    // instance method
    savePresentedItemChangesWithCompletionHandler?(completionHandler?: (p1: NSError) => void): void;
  }

  // interface
  class NSFileProviderService extends NSObject {
    name: string;
    getFileProviderConnectionWithCompletionHandler(completionHandler?: (p1: NSXPCConnection, p2: NSError) => void): void;
  }

  // interface
  class NSFileSecurity extends NSObject /* implements NSCopying, NSSecureCoding */ {
  }

  // export function NSFileTypeForHFSTypeCode(hfsFileTypeCode: number): string;

  // interface
  class NSFileVersion extends NSObject {
    static addVersionOfItemAtURLWithContentsOfURLOptionsError(withContentsOfURL: NSURL, options: NSURL, error: NSFileVersion.AddingOptions): NSFileVersion;
    static currentVersionOfItemAtURL(at: NSURL): NSFileVersion;
    static getNonlocalVersionsOfItemWithAtCompletionHandler(at: NSURL, completionHandler?: (p1: NSFileVersion[], p2: NSError) => void): void;
    static otherVersionsOfItemAtURL(at: NSURL): NSFileVersion[];
    static removeOtherVersionsOfItemAtURLError(error: NSURL): boolean;
    static temporaryDirectoryURLForNewVersionOfItemAtURL(at: NSURL): NSURL;
    static unresolvedConflictVersionsOfItemAtURL(at: NSURL): NSFileVersion[];
    URL: NSURL;
    isConflict: boolean;
    isDiscardable: boolean;
    setDiscardable(_: boolean)
    hasLocalContents: boolean;
    hasThumbnail: boolean;
    localizedName: string;
    localizedNameOfSavingComputer: string;
    modificationDate: Date;
    originatorNameComponents: NSPersonNameComponents;
    persistentIdentifier: NSCoding;
    isResolved: boolean;
    setResolved(_: boolean)
    removeAndReturnError(): boolean;
    replaceItemAtURLOptionsError(options: NSURL, error: NSFileVersion.ReplacingOptions): NSURL;
  }

  // interface
  class FileWrapper extends NSObject /* implements NSSecureCoding */ {
    isDirectory: boolean;
    fileAttributes: Map<string, any>;
    setFileAttributes(_: Map<string, any>)
    fileWrappers: Map<string, FileWrapper>;
    filename: string;
    setFilename(_: string)
    icon: NSImage;
    setIcon(_: NSImage)
    preferredFilename: string;
    setPreferredFilename(_: string)
    isRegularFile: boolean;
    regularFileContents: NSData;
    serializedRepresentation: NSData;
    isSymbolicLink: boolean;
    symbolicLinkDestinationURL: NSURL;
    addFileWrapper(_: FileWrapper): string;
    addRegularFileWithContentsPreferredFilename(_: NSData, preferredFilename: string): string;
    static createWithDirectoryWithFileWrappers(directoryWithFileWrappers: Map<string, FileWrapper>): FileWrapper;
    static createWithRegularFileWithContents(regularFileWithContents: NSData): FileWrapper;
    static createWithSymbolicLinkWithDestinationURL(symbolicLinkWithDestinationURL: NSURL): FileWrapper;
    static createWithSerializedRepresentation(serializedRepresentation: NSData): FileWrapper;
    static createWithUrlOptions(URL: NSURL, options: FileWrapper.ReadingOptions): FileWrapper;
    keyForFileWrapper(_: FileWrapper): string;
    matchesContentsOfURL(_: NSURL): boolean;
    readFromURLOptionsError(options: NSURL, error: FileWrapper.ReadingOptions): boolean;
    removeFileWrapper(_: FileWrapper): void;
    writeToURLOptionsOriginalContentsURLError(options: NSURL, originalContentsURL: FileWrapper.WritingOptions, error?: NSURL): boolean;
  }

  // interface
  class Formatter extends NSObject /* implements NSCoding, NSCopying */ {
    attributedStringForObjectValueWithDefaultAttributes(_: any, withDefaultAttributes?: Map<string, any>): NSAttributedString;
    editingStringForObjectValue(_: any): string;
    getObjectValueForStringErrorDescription(_?: any, forString?: string, errorDescription?: string): boolean;
    isPartialStringValidNewEditingStringErrorDescription(_: string, newEditingString?: string, errorDescription?: string): boolean;
    isPartialStringValidProposedSelectedRangeOriginalStringOriginalSelectedRangeErrorDescription(_: string, proposedSelectedRange?: NSRange, originalString?: string, originalSelectedRange?: NSRange, errorDescription?: string): boolean;
    stringForObjectValue(_?: any): string;
  }

  // export function NSFrameAddress(frame: number): any;

  // export function NSFreeHashTable(table: NSHashTable<any>): void;

  // export function NSFreeMapTable(table: NSMapTable<any, any>): void;

  // export function NSFullUserName(): string;

  // interface
  class NSGetCommand extends NSScriptCommand {
  }

  // export function NSGetSizeAndAlignment(typePtr: string | any, sizep: number, alignp: number): string;

  // export function NSGetUncaughtExceptionHandler(): (p1: NSException) => void;

  // export function NSHFSTypeCodeFromFileType(fileTypeString: string): number;

  // export function NSHFSTypeOfFile(fullFilePath: string): string;

  // interface
  class HTTPCookie extends NSObject {
    static cookiesWithResponseHeaderFieldsForURL(_: Map<string, string>, forURL: NSURL): HTTPCookie[];
    static requestHeaderFieldsWithCookies(_: HTTPCookie[]): Map<string, string>;
    isHTTPOnly: boolean;
    comment: string;
    commentURL: NSURL;
    domain: string;
    expiresDate: Date;
    name: string;
    path: string;
    portList: number[];
    properties: Map<string, any>;
    sameSitePolicy: string;
    isSecure: boolean;
    isSessionOnly: boolean;
    value: string;
    static createWithProperties(properties: Map<string, any>): HTTPCookie;
  }

  // interface
  class HTTPCookieStorage extends NSObject {
    static sharedCookieStorageForGroupContainerIdentifier(_: string): HTTPCookieStorage;
    cookieAcceptPolicy: HTTPCookie.AcceptPolicy;
    setCookieAcceptPolicy(_: HTTPCookie.AcceptPolicy)
    cookies: HTTPCookie[];
    static sharedHTTPCookieStorage: HTTPCookieStorage;
    cookiesForURL(_: NSURL): HTTPCookie[];
    deleteCookie(_: HTTPCookie): void;
    getCookiesForTaskWithCompletionHandler(_: URLSessionTask, completionHandler?: (p1: HTTPCookie[]) => void): void;
    removeCookiesSinceDate(_: Date): void;
    setCookie(_: HTTPCookie): void;
    setCookiesForURLMainDocumentURL(_: HTTPCookie[], forURL?: NSURL, mainDocumentURL?: NSURL): void;
    sortedCookiesUsingDescriptors(_: NSSortDescriptor[]): HTTPCookie[];
    storeCookiesForTask(_: HTTPCookie[], forTask: URLSessionTask): void;
  }

  // interface
  class HTTPURLResponse extends URLResponse {
    static localizedStringForStatusCode(_: number): string;
    allHeaderFields: Map<any, any>;
    statusCode: number;
    static createWithUrlStatusCodeHTTPVersionHeaderFields(URL: NSURL, statusCode: number, HTTPVersion?: string, headerFields?: Map<string, string>): HTTPURLResponse;
    valueForHTTPHeaderField(_: string): string;
  }

  // export function NSHashGet(table: NSHashTable<any>, pointer: any): any;

  // export function NSHashInsert(table: NSHashTable<any>, pointer: any): void;

  // export function NSHashInsertIfAbsent(table: NSHashTable<any>, pointer: any): any;

  // export function NSHashInsertKnownAbsent(table: NSHashTable<any>, pointer: any): void;

  // export function NSHashRemove(table: NSHashTable<any>, pointer: any): void;

  // interface
  class NSHashTable<ObjectType> extends NSObject /* implements NSCopying, NSFastEnumeration, NSSecureCoding */ {
    static weakObjectsHashTable<ObjectType>(): NSHashTable<ObjectType>;
    allObjects: ObjectType[];
    anyObject: ObjectType;
    count: number;
    pointerFunctions: NSPointerFunctions;
    setRepresentation: NSSet<ObjectType>;
    addObject(_?: ObjectType): void;
    containsObject(_?: ObjectType): boolean;
    intersect(_: NSHashTable<ObjectType>): void;
    intersects(_: NSHashTable<ObjectType>): boolean;
    isEqualWithTo(to: NSHashTable<ObjectType>): boolean;
    isSubsetOf(of: NSHashTable<ObjectType>): boolean;
    member(_?: ObjectType): ObjectType;
    minus(_: NSHashTable<ObjectType>): void;
    objectEnumerator(): NSEnumerator<ObjectType>;
    removeAllObjects(): void;
    removeObject(_?: ObjectType): void;
    union(_: NSHashTable<ObjectType>): void;
  }

  // export function NSHomeDirectory(): string;

  // export function NSHomeDirectoryForUser(userName: string): string;

  // interface
  class Host extends NSObject {
    static currentHost(): Host;
    address: string;
    addresses: string[];
    localizedName: string;
    name: string;
    names: string[];
    isEqualToHost(_: Host): boolean;
  }

  // interface
  class ISO8601DateFormatter extends Formatter /* implements NSSecureCoding */ {
    static stringFromDateTimeZoneFormatOptions(_: Date, timeZone: NSTimeZone, formatOptions: ISO8601DateFormatter.Options): string;
    formatOptions: ISO8601DateFormatter.Options;
    setFormatOptions(_: ISO8601DateFormatter.Options)
    timeZone: NSTimeZone;
    setTimeZone(_: NSTimeZone)
    dateFromString(_: string): Date;
    stringFromDate(_: Date): string;
  }

  // export function NSIncrementExtraRefCount(object_: any): void;

  // interface
  class NSIndexPath extends NSObject /* implements NSCopying, NSSecureCoding */ {
    item: number;
    length: number;
    section: number;
    compare(_: NSIndexPath): ComparisonResult;
    getIndexes(_: number): void;
    getIndexesRange(_: number, range: NSRange): void;
    indexAtPosition(atPosition: number): number;
    indexPathByAddingIndex(_: number): NSIndexPath;
    indexPathByRemovingLastIndex(): NSIndexPath;
    static createWithIndex(index: number): NSIndexPath;
    static createWithIndexesLength(indexes?: number, length?: number): NSIndexPath;
  }

  // interface
  class NSIndexSet extends NSObject /* implements NSCopying, NSMutableCopying, NSSecureCoding */ {
    count: number;
    firstIndex: number;
    lastIndex: number;
    containsIndex(_: number): boolean;
    containsIndexes(_: NSIndexSet): boolean;
    containsIndexesInRange(in_: NSRange): boolean;
    countOfIndexesInRange(in_: NSRange): number;
    enumerateWithInOptionsUsing(in_: NSRange, options: NSEnumerationOptions, using: (p1: number, p2: boolean) => void): void;
    enumerate(_: (p1: number, p2: boolean) => void): void;
    enumerateWithOptionsUsing(options: NSEnumerationOptions, using: (p1: number, p2: boolean) => void): void;
    enumerateRangesWithInOptionsUsing(in_: NSRange, options: NSEnumerationOptions, using: (p1: NSRange, p2: boolean) => void): void;
    enumerateRanges(_: (p1: NSRange, p2: boolean) => void): void;
    enumerateRangesWithOptionsUsing(options: NSEnumerationOptions, using: (p1: NSRange, p2: boolean) => void): void;
    getIndexesMaxCountInIndexRange(_: number, maxCount: number, inIndexRange?: NSRange): number;
    indexGreaterThanIndex(_: number): number;
    indexGreaterThanOrEqualToIndex(to: number): number;
    indexWithInOptionsPassingTest(in_: NSRange, options: NSEnumerationOptions, passingTest: (p1: number, p2: boolean) => boolean): number;
    indexLessThanIndex(_: number): number;
    indexLessThanOrEqualToIndex(to: number): number;
    indexWithPassingTest(passingTest: (p1: number, p2: boolean) => boolean): number;
    indexWithOptionsPassingTest(options: NSEnumerationOptions, passingTest: (p1: number, p2: boolean) => boolean): number;
    indexesWithInOptionsPassingTest(in_: NSRange, options: NSEnumerationOptions, passingTest: (p1: number, p2: boolean) => boolean): NSIndexSet;
    indexesWithPassingTest(passingTest: (p1: number, p2: boolean) => boolean): NSIndexSet;
    indexesWithOptionsPassingTest(options: NSEnumerationOptions, passingTest: (p1: number, p2: boolean) => boolean): NSIndexSet;
    static createWithIndex(index: number): NSIndexSet;
    static createWithIndexSet(indexSet: NSIndexSet): NSIndexSet;
    static createWithIndexesInRange(indexesInRange: NSRange): NSIndexSet;
    intersectsIndexesInRange(in_: NSRange): boolean;
    isEqualToIndexSet(to: NSIndexSet): boolean;
  }

  // interface
  class NSIndexSpecifier extends NSScriptObjectSpecifier {
    index: number;
    setIndex(_: number)
    static createWithContainerClassDescriptionContainerSpecifierKeyIndex(containerClassDescription: NSScriptClassDescription, containerSpecifier?: NSScriptObjectSpecifier, key?: string, index?: number): NSIndexSpecifier;
  }

  // interface
  class InputStream extends Stream {
    static inputStreamWithData(_: NSData): InputStream;
    static inputStreamWithFileAtPath(_: string): InputStream;
    static inputStreamWithURL(_: NSURL): InputStream;
    hasBytesAvailable: boolean;
    getBufferLength(_?: string, length?: number): boolean;
    static createWithData(data: NSData): InputStream;
    static createWithFileAtPath(fileAtPath: string): InputStream;
    static createWithUrl(URL: NSURL): InputStream;
    readMaxLength(_: string, maxLength: number): number;
  }

  // export function NSInsetRect(aRect: CGRect, dX: number, dY: number): CGRect;

  // export function NSIntegralRect(aRect: CGRect): CGRect;

  // export function NSIntegralRectWithOptions(aRect: CGRect, opts: AlignmentOptions): CGRect;

  // export function NSIntersectionRange(range1: NSRange, range2: NSRange): NSRange;

  // export function NSIntersectionRect(aRect: CGRect, bRect: CGRect): CGRect;

  // export function NSIntersectsRect(aRect: CGRect, bRect: CGRect): boolean;

  // export function NSIsEmptyRect(aRect: CGRect): boolean;

  // export function NSIsFreedObject(anObject: any): boolean;

  // interface
  class NSItemProvider extends NSObject /* implements NSCopying */ {
    containerFrame: CGRect;
    preferredPresentationSize: CGSize;
    previewImageHandler: (p1: (p1: NSSecureCoding, p2: NSError) => void, p2: typeof NSObject, p3: Map<any, any>) => void;
    setPreviewImageHandler(_: (p1: (p1: NSSecureCoding, p2: NSError) => void, p2: typeof NSObject, p3: Map<any, any>) => void)
    registeredTypeIdentifiers: string[];
    sourceFrame: CGRect;
    suggestedName: string;
    setSuggestedName(_: string)
    canLoadObjectOfClass(ofClass: typeof NSObject): boolean;
    hasItemConformingToTypeIdentifier(_: string): boolean;
    hasRepresentationConformingToTypeIdentifierFileOptions(toTypeIdentifier: string, fileOptions: NSItemProviderFileOptions): boolean;
    static createWithContentsOfURL(contentsOfURL: NSURL): NSItemProvider;
    static createWithItemTypeIdentifier(item?: NSSecureCoding, typeIdentifier?: string): NSItemProvider;
    static createWithObject(object_: NSItemProviderWriting): NSItemProvider;
    loadDataRepresentationWithForTypeIdentifierCompletionHandler(forTypeIdentifier: string, completionHandler?: (p1: NSData, p2: NSError) => void): Progress;
    loadFileRepresentationWithForTypeIdentifierCompletionHandler(forTypeIdentifier: string, completionHandler?: (p1: NSURL, p2: NSError) => void): Progress;
    loadInPlaceFileRepresentationWithForTypeIdentifierCompletionHandler(forTypeIdentifier: string, completionHandler?: (p1: NSURL, p2: boolean, p3: NSError) => void): Progress;
    loadItemWithForTypeIdentifierOptionsCompletionHandler(forTypeIdentifier: string, options?: Map<any, any>, completionHandler?: (p1: NSSecureCoding, p2: NSError) => void): void;
    loadObjectWithOfClassCompletionHandler(ofClass: typeof NSObject, completionHandler?: (p1: NSItemProviderReading, p2: NSError) => void): Progress;
    loadPreviewImageWithOptionsCompletionHandler(options: Map<any, any>, completionHandler: (p1: NSSecureCoding, p2: NSError) => void): void;
    registerCloudKitShareContainer(_: CKShare, container: CKContainer): void;
    registerCloudKitShareWithPreparationHandler(preparationHandler?: (p1: (p1: CKShare, p2: CKContainer, p3: NSError) => void) => void): void;
    registerDataRepresentationWithForTypeIdentifierVisibilityLoadHandler(forTypeIdentifier: string, visibility: NSItemProviderRepresentationVisibility, loadHandler?: (p1: (p1: NSData, p2: NSError) => void) => Progress): void;
    registerFileRepresentationWithForTypeIdentifierFileOptionsVisibilityLoadHandler(forTypeIdentifier: string, fileOptions: NSItemProviderFileOptions, visibility: NSItemProviderRepresentationVisibility, loadHandler?: (p1: (p1: NSURL, p2: boolean, p3: NSError) => void) => Progress): void;
    registerItemWithForTypeIdentifierLoadHandler(forTypeIdentifier: string, loadHandler: (p1: (p1: NSSecureCoding, p2: NSError) => void, p2: typeof NSObject, p3: Map<any, any>) => void): void;
    registerObjectVisibility(_: NSItemProviderWriting, visibility: NSItemProviderRepresentationVisibility): void;
    registerObjectWithOfClassVisibilityLoadHandler(ofClass: typeof NSObject, visibility: NSItemProviderRepresentationVisibility, loadHandler?: (p1: (p1: NSItemProviderWriting, p2: NSError) => void) => Progress): void;
    registeredTypeIdentifiersWithFileOptions(fileOptions: NSItemProviderFileOptions): string[];
  }

  type NSItemProviderReading = NSObject

  interface NSItemProviderWriting extends NSObject {
    writableTypeIdentifiersForItemProvider?: string[];
    // instance method
    itemProviderVisibilityForRepresentationWithTypeIdentifier?(withTypeIdentifier: string): NSItemProviderRepresentationVisibility;
    // instance method
    loadDataWithWithTypeIdentifierForItemProviderCompletionHandler(withTypeIdentifier: string, forItemProviderCompletionHandler?: (p1: NSData, p2: NSError) => void): Progress;
  }

  // interface
  class JSONSerialization extends NSObject {
    static JSONObjectWithDataOptionsError(options: NSData, error: JSONSerialization.ReadingOptions): any;
    static JSONObjectWithStreamOptionsError(options: InputStream, error: JSONSerialization.ReadingOptions): any;
    static dataWithJSONObjectOptionsError(options: any, error: JSONSerialization.WritingOptions): NSData;
    static isValidJSONObject(_: any): boolean;
    static writeJSONObjectToStreamOptionsError(toStream: any, options: OutputStream, error: JSONSerialization.WritingOptions): number;
  }

  // interface
  class NSKeyedArchiver extends NSCoder {
    static archivedDataWithRootObjectRequiringSecureCodingError(requiringSecureCoding: any, error: boolean): NSData;
    static classNameForClass(for_: typeof NSObject): string;
    static setClassNameForClass(_?: string, for_?: typeof NSObject): void;
    delegate: NSKeyedArchiverDelegate;
    setDelegate(_: NSKeyedArchiverDelegate)
    encodedData: NSData;
    outputFormat: PropertyListSerialization.PropertyListFormat;
    setOutputFormat(_: PropertyListSerialization.PropertyListFormat)
    classNameForClass(for_: typeof NSObject): string;
    finishEncoding(): void;
    static createWithRequiringSecureCoding(requiringSecureCoding: boolean): NSKeyedArchiver;
    setClassNameForClass(_?: string, for_?: typeof NSObject): void;
  }

  interface NSKeyedArchiverDelegate extends NSObject {
    // instance method
    archiverWillEncodeObject?(_: NSKeyedArchiver, willEncode: any): any;
    // instance method
    archiverDidEncodeObject?(_: NSKeyedArchiver, didEncode?: any): void;
    // instance method
    archiverWillReplaceObjectWithObject?(_: NSKeyedArchiver, willReplace?: any, with_?: any): void;
    // instance method
    archiverDidFinish?(_: NSKeyedArchiver): void;
    // instance method
    archiverWillFinish?(_: NSKeyedArchiver): void;
  }

  // interface
  class NSKeyedUnarchiver extends NSCoder {
    static classForClassName(forClassName: string): typeof NSObject;
    static setClassForClassName(_?: typeof NSObject, forClassName?: string): void;
    static unarchivedObjectOfClassFromDataError(fromData: typeof NSObject, error: NSData): any;
    static unarchivedObjectOfClassesWithFromDataError(fromData: NSSet<typeof NSObject>, error: NSData): any;
    delegate: NSKeyedUnarchiverDelegate;
    setDelegate(_: NSKeyedUnarchiverDelegate)
    classForClassName(forClassName: string): typeof NSObject;
    finishDecoding(): void;
    static createWithForReadingFromData(forReadingFromData: NSData): NSKeyedUnarchiver;
    setClassForClassName(_?: typeof NSObject, forClassName?: string): void;
  }

  interface NSKeyedUnarchiverDelegate extends NSObject {
    // instance method
    unarchiverDidDecodeObject?(_: NSKeyedUnarchiver, didDecode?: any): any;
    // instance method
    unarchiverWillReplaceObjectWithObject?(_: NSKeyedUnarchiver, willReplace: any, with_: any): void;
    // instance method
    unarchiverCannotDecodeObjectOfClassNameOriginalClasses?(_: NSKeyedUnarchiver, cannotDecodeObjectOfClassName: string, originalClasses: string[]): typeof NSObject;
    // instance method
    unarchiverDidFinish?(_: NSKeyedUnarchiver): void;
    // instance method
    unarchiverWillFinish?(_: NSKeyedUnarchiver): void;
  }

  // interface
  class LengthFormatter extends Formatter {
    isForPersonHeightUse: boolean;
    setForPersonHeightUse(_: boolean)
    numberFormatter: NumberFormatter;
    setNumberFormatter(_: NumberFormatter)
    unitStyle: Formatter.UnitStyle;
    setUnitStyle(_: Formatter.UnitStyle)
    stringFromMeters(_: number): string;
    stringFromValueUnit(_: number, unit: LengthFormatter.Unit): string;
    unitStringFromMetersUsedUnit(_: number, usedUnit?: LengthFormatter.Unit): string;
    unitStringFromValueUnit(_: number, unit: LengthFormatter.Unit): string;
  }

  // interface
  class NSLinguisticTagger extends NSObject {
    static availableTagSchemesForLanguage(forLanguage: string): string[];
    static availableTagSchemesForUnitLanguage(for_: NSLinguisticTaggerUnit, language: string): string[];
    static dominantLanguageForString(for_: string): string;
    static enumerateTagsForRangeUnitSchemeOptionsOrthographyUsing(for_: string, range: NSRange, unit: NSLinguisticTaggerUnit, scheme: string, options: NSLinguisticTagger.Options, orthography?: NSOrthography, using?: (p1: string, p2: NSRange, p3: boolean) => void): void;
    static tagForStringAtIndexUnitSchemeOrthographyTokenRange(for_: string, at: number, unit: NSLinguisticTaggerUnit, scheme: string, orthography?: NSOrthography, tokenRange?: NSRange): string;
    static tagsForStringRangeUnitSchemeOptionsOrthographyTokenRanges(for_: string, range: NSRange, unit: NSLinguisticTaggerUnit, scheme: string, options: NSLinguisticTagger.Options, orthography?: NSOrthography, tokenRanges?: NSValue[]): string[];
    dominantLanguage: string;
    string: string;
    setString(_: string)
    tagSchemes: string[];
    enumerateTagsWithInSchemeOptionsUsing(in_: NSRange, scheme: string, options: NSLinguisticTagger.Options, using?: (p1: string, p2: NSRange, p3: NSRange, p4: boolean) => void): void;
    enumerateTagsWithInUnitSchemeOptionsUsing(in_: NSRange, unit: NSLinguisticTaggerUnit, scheme: string, options: NSLinguisticTagger.Options, using?: (p1: string, p2: NSRange, p3: boolean) => void): void;
    static createWithTagSchemesOptions(tagSchemes: string[], options: number): NSLinguisticTagger;
    orthographyAtIndexEffectiveRange(at: number, effectiveRange?: NSRange): NSOrthography;
    possibleTagsAtIndexSchemeTokenRangeSentenceRangeScores(at: number, scheme: string, tokenRange?: NSRange, sentenceRange?: NSRange, scores?: NSValue[]): string[];
    sentenceRangeForRange(for_: NSRange): NSRange;
    setOrthographyRange(_?: NSOrthography, range?: NSRange): void;
    stringEditedInRangeChangeInLength(in_: NSRange, changeInLength: number): void;
    tagAtIndexSchemeTokenRangeSentenceRange(at: number, scheme: string, tokenRange?: NSRange, sentenceRange?: NSRange): string;
    tagAtIndexUnitSchemeTokenRange(at: number, unit: NSLinguisticTaggerUnit, scheme: string, tokenRange?: NSRange): string;
    tagsInRangeSchemeOptionsTokenRanges(in_: NSRange, scheme: string, options: NSLinguisticTagger.Options, tokenRanges?: NSValue[]): string[];
    tagsInRangeUnitSchemeOptionsTokenRanges(in_: NSRange, unit: NSLinguisticTaggerUnit, scheme: string, options: NSLinguisticTagger.Options, tokenRanges?: NSValue[]): string[];
    tokenRangeAtIndexUnit(at: number, unit: NSLinguisticTaggerUnit): NSRange;
  }

  // interface
  class ListFormatter extends Formatter {
    static localizedStringByJoiningStrings(_: string[]): string;
    itemFormatter: Formatter;
    setItemFormatter(_: Formatter)
    locale: NSLocale;
    setLocale(_: NSLocale)
    stringFromItems(from: any[]): string;
  }

  // interface
  class NSLocale extends NSObject /* implements NSCopying, NSSecureCoding */ {
    static canonicalLanguageIdentifierFromString(from: string): string;
    static canonicalLocaleIdentifierFromString(from: string): string;
    static characterDirectionForLanguage(forLanguage: string): NSLocale.LanguageDirection;
    static componentsFromLocaleIdentifier(fromLocaleIdentifier: string): Map<string, string>;
    static lineDirectionForLanguage(forLanguage: string): NSLocale.LanguageDirection;
    static localeIdentifierFromComponents(fromComponents: Map<string, string>): string;
    static localeIdentifierFromWindowsLocaleCode(fromWindowsLocaleCode: number): string;
    static windowsLocaleCodeFromLocaleIdentifier(fromLocaleIdentifier: string): number;
    alternateQuotationBeginDelimiter: string;
    alternateQuotationEndDelimiter: string;
    calendarIdentifier: string;
    collationIdentifier: string;
    collatorIdentifier: string;
    countryCode: string;
    currencyCode: string;
    currencySymbol: string;
    decimalSeparator: string;
    exemplarCharacterSet: NSCharacterSet;
    groupingSeparator: string;
    languageCode: string;
    localeIdentifier: string;
    quotationBeginDelimiter: string;
    quotationEndDelimiter: string;
    scriptCode: string;
    usesMetricSystem: boolean;
    variantCode: string;
    static ISOCountryCodes: string[];
    static ISOCurrencyCodes: string[];
    static ISOLanguageCodes: string[];
    static autoupdatingCurrentLocale: NSLocale;
    static availableLocaleIdentifiers: string[];
    static commonISOCurrencyCodes: string[];
    static currentLocale: NSLocale;
    static preferredLanguages: string[];
    static systemLocale: NSLocale;
    displayNameForKeyValue(forKey: string, value: any): string;
    static createWithLocaleIdentifier(localeIdentifier: string): NSLocale;
    localizedStringForCalendarIdentifier(forCalendarIdentifier: string): string;
    localizedStringForCollationIdentifier(forCollationIdentifier: string): string;
    localizedStringForCollatorIdentifier(forCollatorIdentifier: string): string;
    localizedStringForCountryCode(forCountryCode: string): string;
    localizedStringForCurrencyCode(forCurrencyCode: string): string;
    localizedStringForLanguageCode(forLanguageCode: string): string;
    localizedStringForLocaleIdentifier(forLocaleIdentifier: string): string;
    localizedStringForScriptCode(forScriptCode: string): string;
    localizedStringForVariantCode(forVariantCode: string): string;
    objectForKey(forKey: string): any;
  }

  // interface
  class NSLock extends NSObject /* implements NSLocking */ {
    name: string;
    setName(_: string)
    lockBeforeDate(before: Date): boolean;
    tryLock(): boolean;
  }

  interface NSLocking {
    // instance method
    lock(): void;
    // instance method
    unlock(): void;
  }

  // export function NSLogPageSize(): number;

  // interface
  class NSLogicalTest extends NSScriptWhoseTest {
    static createWithAndTestWithTests(andTestWithTests: NSSpecifierTest[]): NSLogicalTest;
    static createWithNotTestWithTest(notTestWithTest: NSScriptWhoseTest): NSLogicalTest;
    static createWithOrTestWithTests(orTestWithTests: NSSpecifierTest[]): NSLogicalTest;
  }

  // interface
  class NSMachPort extends Port {
    static portWithMachPort(withMachPort: number): Port;
    static portWithMachPortOptions(withMachPort: number, options: NSMachPort.Options): Port;
    machPort: number;
    static createWithMachPort(machPort: number): NSMachPort;
    static createWithMachPortOptions(machPort: number, options: NSMachPort.Options): NSMachPort;
  }

  interface NSMachPortDelegate extends PortDelegate {
    // instance method
    handleMachMessage?(_: any): void;
  }

  // export function NSMapGet(table: NSMapTable<any, any>, key: any): any;

  // export function NSMapInsert(table: NSMapTable<any, any>, key: any, value: any): void;

  // export function NSMapInsertIfAbsent(table: NSMapTable<any, any>, key: any, value: any): any;

  // export function NSMapInsertKnownAbsent(table: NSMapTable<any, any>, key: any, value: any): void;

  // export function NSMapMember(table: NSMapTable<any, any>, key: any, originalKey: any, value: any): boolean;

  // export function NSMapRemove(table: NSMapTable<any, any>, key: any): void;

  // interface
  class NSMapTable<KeyType, ObjectType> extends NSObject /* implements NSCopying, NSFastEnumeration, NSSecureCoding */ {
    static strongToStrongObjectsMapTable<KeyType, ObjectType>(): NSMapTable<KeyType, ObjectType>;
    static strongToWeakObjectsMapTable<KeyType, ObjectType>(): NSMapTable<KeyType, ObjectType>;
    static weakToStrongObjectsMapTable<KeyType, ObjectType>(): NSMapTable<KeyType, ObjectType>;
    static weakToWeakObjectsMapTable<KeyType, ObjectType>(): NSMapTable<KeyType, ObjectType>;
    count: number;
    keyPointerFunctions: NSPointerFunctions;
    valuePointerFunctions: NSPointerFunctions;
    dictionaryRepresentation(): Map<KeyType, ObjectType>;
    keyEnumerator(): NSEnumerator<KeyType>;
    objectEnumerator(): NSEnumerator<ObjectType>;
    objectForKey(forKey?: KeyType): ObjectType;
    removeAllObjects(): void;
    removeObjectForKey(forKey?: KeyType): void;
    setObjectForKey(_?: ObjectType, forKey?: KeyType): void;
  }

  // interface
  class MassFormatter extends Formatter {
    isForPersonMassUse: boolean;
    setForPersonMassUse(_: boolean)
    numberFormatter: NumberFormatter;
    setNumberFormatter(_: NumberFormatter)
    unitStyle: Formatter.UnitStyle;
    setUnitStyle(_: Formatter.UnitStyle)
    stringFromKilograms(_: number): string;
    stringFromValueUnit(_: number, unit: MassFormatter.Unit): string;
    unitStringFromKilogramsUsedUnit(_: number, usedUnit?: MassFormatter.Unit): string;
    unitStringFromValueUnit(_: number, unit: MassFormatter.Unit): string;
  }

  // interface
  class NSMeasurement<UnitType> extends NSObject /* implements NSCopying, NSSecureCoding */ {
    doubleValue: number;
    unit: UnitType;
    canBeConvertedToUnit(to: Unit): boolean;
    adding(_: NSMeasurement<UnitType>): NSMeasurement<UnitType>;
    measurementByConvertingToUnit(to: Unit): NSMeasurement<any>;
    subtracting(_: NSMeasurement<UnitType>): NSMeasurement<UnitType>;
  }

  // interface
  class MeasurementFormatter extends Formatter /* implements NSSecureCoding */ {
    locale: NSLocale;
    setLocale(_: NSLocale)
    numberFormatter: NumberFormatter;
    setNumberFormatter(_: NumberFormatter)
    unitOptions: MeasurementFormatter.UnitOptions;
    setUnitOptions(_: MeasurementFormatter.UnitOptions)
    unitStyle: Formatter.UnitStyle;
    setUnitStyle(_: Formatter.UnitStyle)
    stringFromMeasurement(_: NSMeasurement<any>): string;
    stringFromUnit(_: Unit): string;
  }

  // interface
  class MessagePort extends Port {
  }

  // interface
  class NSMetadataItem extends NSObject {
    attributes: string[];
    static createWithUrl(URL: NSURL): NSMetadataItem;
    valueForAttribute(forAttribute: string): any;
    valuesForAttributes(forAttributes: string[]): Map<string, any>;
  }

  // interface
  class NSMetadataQuery extends NSObject {
    delegate: NSMetadataQueryDelegate;
    setDelegate(_: NSMetadataQueryDelegate)
    isGathering: boolean;
    groupedResults: NSMetadataQueryResultGroup[];
    groupingAttributes: string[];
    setGroupingAttributes(_: string[])
    notificationBatchingInterval: number;
    setNotificationBatchingInterval(_: number)
    operationQueue: OperationQueue;
    setOperationQueue(_: OperationQueue)
    predicate: NSPredicate;
    setPredicate(_: NSPredicate)
    resultCount: number;
    results: any[];
    searchItems: any[];
    setSearchItems(_: any[])
    searchScopes: any[];
    setSearchScopes(_: any[])
    sortDescriptors: NSSortDescriptor[];
    setSortDescriptors(_: NSSortDescriptor[])
    isStarted: boolean;
    isStopped: boolean;
    valueListAttributes: string[];
    setValueListAttributes(_: string[])
    valueLists: Map<string, NSMetadataQueryAttributeValueTuple[]>;
    disableUpdates(): void;
    enableUpdates(): void;
    enumerateResults(_: (p1: any, p2: number, p3: boolean) => void): void;
    enumerateResultsWithOptionsUsing(options: NSEnumerationOptions, using: (p1: any, p2: number, p3: boolean) => void): void;
    indexOfResult(ofResult: any): number;
    resultAtIndex(at: number): any;
    startQuery(): boolean;
    stopQuery(): void;
    valueOfAttributeForResultAtIndex(ofAttribute: string, forResultAt: number): any;
  }

  // interface
  class NSMetadataQueryAttributeValueTuple extends NSObject {
    attribute: string;
    count: number;
    value: any;
  }

  interface NSMetadataQueryDelegate extends NSObject {
    // instance method
    metadataQueryReplacementObjectForResultObject?(_: NSMetadataQuery, replacementObjectForResultObject: NSMetadataItem): any;
    // instance method
    metadataQueryReplacementValueForAttributeValue?(_: NSMetadataQuery, replacementValueForAttribute: string, value: any): any;
  }

  // interface
  class NSMetadataQueryResultGroup extends NSObject {
    attribute: string;
    resultCount: number;
    results: any[];
    subgroups: NSMetadataQueryResultGroup[];
    value: any;
    resultAtIndex(at: number): any;
  }

  // interface
  class NSMiddleSpecifier extends NSScriptObjectSpecifier {
  }

  // export function NSMouseInRect(aPoint: CGPoint, aRect: CGRect, flipped: boolean): boolean;

  // interface
  class NSMoveCommand extends NSScriptCommand {
    keySpecifier: NSScriptObjectSpecifier;
    setReceiversSpecifier(_?: NSScriptObjectSpecifier): void;
  }

  // interface
  class NSMutableArray<ObjectType> extends NSArray<ObjectType> {
    static arrayWithCapacity<ObjectType>(capacity: number): NSMutableArray<ObjectType>;
    addObject(_: ObjectType): void;
    addObjectsFromArray(from: ObjectType[]): void;
    exchangeObjectAtIndexWithObjectAtIndex(at: number, withObjectAt: number): void;
    filterUsingPredicate(using: NSPredicate): void;
    insertObjectAtIndex(_: ObjectType, at: number): void;
    insertObjectsAtIndexes(_: ObjectType[], at: NSIndexSet): void;
    removeAllObjects(): void;
    removeLastObject(): void;
    removeObject(_: ObjectType): void;
    removeObjectInRange(_: ObjectType, in_: NSRange): void;
    removeObjectAtIndex(at: number): void;
    removeObjectIdenticalTo(identicalTo: ObjectType): void;
    removeObjectIdenticalToInRange(identicalTo: ObjectType, in_: NSRange): void;
    removeObjectsAtIndexes(at: NSIndexSet): void;
    removeObjectsInArray(in_: ObjectType[]): void;
    removeObjectsInRange(in_: NSRange): void;
    replaceObjectAtIndexWithObject(at: number, with_: ObjectType): void;
    replaceObjectsAtIndexesWithObjects(at: NSIndexSet, with_: ObjectType[]): void;
    replaceObjectsInRangeWithObjectsFromArray(in_: NSRange, withObjectsFrom: ObjectType[]): void;
    replaceObjectsInRangeWithObjectsFromArrayRange(in_: NSRange, withObjectsFrom: ObjectType[], range: NSRange): void;
    setArray(_: ObjectType[]): void;
    setObjectAtIndexedSubscript(_: ObjectType, atIndexedSubscript: number): void;
    sortWithComparator(comparator: (p1: any, p2: any) => ComparisonResult): void;
    sortUsingDescriptors(using: NSSortDescriptor[]): void;
    sortContext(_?: (p1: ObjectType, p2: ObjectType, p3: any) => number, context?: any): void;
    sortUsingSelector(using: string): void;
    sortWithOptionsUsingComparator(options: NSSortOptions, usingComparator: (p1: any, p2: any) => ComparisonResult): void;
  }

  // interface
  class NSMutableAttributedString extends NSAttributedString {
    mutableString: NSMutableString;
    addAttributeValueRange(_: string, value: any, range: NSRange): void;
    addAttributesRange(_: Map<string, any>, range: NSRange): void;
    appendAttributedString(_: NSAttributedString): void;
    applyFontTraitsRange(_: NSFontTraitMask, range: NSRange): void;
    beginEditing(): void;
    deleteCharactersInRange(in_: NSRange): void;
    endEditing(): void;
    fixAttachmentAttributeInRange(in_: NSRange): void;
    fixAttributesInRange(in_: NSRange): void;
    fixFontAttributeInRange(in_: NSRange): void;
    fixParagraphStyleAttributeInRange(in_: NSRange): void;
    insertAttributedStringAtIndex(_: NSAttributedString, at: number): void;
    readFromDataOptionsDocumentAttributesError(from: NSData, options: Map<string, any>, documentAttributes?: Map<string, any>): boolean;
    readFromURLOptionsDocumentAttributesError(from: NSURL, options: Map<string, any>, documentAttributes?: Map<string, any>): boolean;
    removeAttributeRange(_: string, range: NSRange): void;
    replaceCharactersInRangeWithAttributedString(in_: NSRange, with_: NSAttributedString): void;
    replaceCharactersInRangeWithString(in_: NSRange, with_: string): void;
    setAlignmentRange(_: NSTextAlignment, range: NSRange): void;
    setAttributedString(_: NSAttributedString): void;
    setAttributesRange(_?: Map<string, any>, range?: NSRange): void;
    setBaseWritingDirectionRange(_: NSWritingDirection, range: NSRange): void;
    subscriptRange(_: NSRange): void;
    superscriptRange(_: NSRange): void;
    unscriptRange(_: NSRange): void;
    updateAttachmentsFromPath(fromPath: string): void;
  }

  // interface
  class NSMutableCharacterSet extends NSCharacterSet /* implements NSCopying, NSMutableCopying, NSSecureCoding */ {
    addCharactersInRange(in_: NSRange): void;
    addCharactersInString(in_: string): void;
    formIntersectionWithCharacterSet(with_: NSCharacterSet): void;
    formUnionWithCharacterSet(with_: NSCharacterSet): void;
    invert(): void;
    removeCharactersInRange(in_: NSRange): void;
    removeCharactersInString(in_: string): void;
  }

  interface NSMutableCopying {
  }

  // interface
  class NSMutableData extends NSData {
    static dataWithCapacity(capacity: number): NSMutableData;
    static dataWithLength(length: number): NSMutableData;
    mutableBytes: any;
    appendBytesLength(_: any, length: number): void;
    appendData(_: NSData): void;
    compressUsingAlgorithmError(error: NSData.CompressionAlgorithm): boolean;
    decompressUsingAlgorithmError(error: NSData.CompressionAlgorithm): boolean;
    increaseLengthBy(by: number): void;
    static createWithCapacity(capacity: number): NSMutableData;
    static createWithLength(length: number): NSMutableData;
    replaceBytesInRangeWithBytes(in_: NSRange, withBytes: any): void;
    replaceBytesInRangeWithBytesLength(in_: NSRange, withBytes?: any, length?: number): void;
    resetBytesInRange(in_: NSRange): void;
    setData(_: NSData): void;
  }

  // interface
  class NSMutableDictionary<KeyType, ObjectType> extends NSDictionary<KeyType, ObjectType> {
    static dictionaryWithCapacity<KeyType, ObjectType>(capacity: number): NSMutableDictionary<KeyType, ObjectType>;
    static dictionaryWithSharedKeySet<KeyType, ObjectType>(sharedKeySet: any): NSMutableDictionary<KeyType, ObjectType>;
    addEntriesFromDictionary(from: Map<KeyType, ObjectType>): void;
    removeAllObjects(): void;
    removeObjectForKey(forKey: KeyType): void;
    removeObjectsForKeys(forKeys: KeyType[]): void;
    setDictionary(_: Map<KeyType, ObjectType>): void;
    setObjectForKey(_: ObjectType, forKey: KeyType): void;
    setObjectForKeyedSubscript(_?: ObjectType, forKeyedSubscript?: KeyType): void;
  }

  // interface
  class NSMutableIndexSet extends NSIndexSet {
    addIndex(_: number): void;
    addIndexes(_: NSIndexSet): void;
    addIndexesInRange(in_: NSRange): void;
    removeAllIndexes(): void;
    removeIndex(_: number): void;
    removeIndexes(_: NSIndexSet): void;
    removeIndexesInRange(in_: NSRange): void;
    shiftIndexesStartingAtIndexBy(at: number, by: number): void;
  }

  // interface
  class NSMutableOrderedSet<ObjectType> extends NSOrderedSet<ObjectType> {
    static orderedSetWithCapacity<ObjectType>(capacity: number): NSMutableOrderedSet<ObjectType>;
    addObject(_: ObjectType): void;
    addObjectsCount(_?: ObjectType, count?: number): void;
    addObjectsFromArray(from: ObjectType[]): void;
    exchangeObjectAtIndexWithObjectAtIndex(at: number, withObjectAt: number): void;
    filterUsingPredicate(using: NSPredicate): void;
    insertObjectAtIndex(_: ObjectType, at: number): void;
    insertObjectsAtIndexes(_: ObjectType[], at: NSIndexSet): void;
    intersect(_: NSOrderedSet<ObjectType>): void;
    intersectSet(_: NSSet<ObjectType>): void;
    minus(_: NSOrderedSet<ObjectType>): void;
    minusSet(_: NSSet<ObjectType>): void;
    moveObjectsAtIndexesToIndex(at: NSIndexSet, to: number): void;
    removeAllObjects(): void;
    removeObject(_: ObjectType): void;
    removeObjectAtIndex(at: number): void;
    removeObjectsAtIndexes(at: NSIndexSet): void;
    removeObjectsInArray(in_: ObjectType[]): void;
    removeObjectsInRange(in_: NSRange): void;
    replaceObjectAtIndexWithObject(at: number, with_: ObjectType): void;
    replaceObjectsAtIndexesWithObjects(at: NSIndexSet, with_: ObjectType[]): void;
    replaceObjectsInRangeWithObjectsCount(in_: NSRange, with_?: ObjectType, count?: number): void;
    setObjectAtIndex(_: ObjectType, at: number): void;
    setObjectAtIndexedSubscript(_: ObjectType, atIndexedSubscript: number): void;
    sortRangeWithOptionsUsingComparator(_: NSRange, options: NSSortOptions, usingComparator: (p1: any, p2: any) => ComparisonResult): void;
    sortWithComparator(comparator: (p1: any, p2: any) => ComparisonResult): void;
    sortUsingDescriptors(using: NSSortDescriptor[]): void;
    sortWithOptionsUsingComparator(options: NSSortOptions, usingComparator: (p1: any, p2: any) => ComparisonResult): void;
    union(_: NSOrderedSet<ObjectType>): void;
    unionSet(_: NSSet<ObjectType>): void;
  }

  // interface
  class NSMutableSet<ObjectType> extends NSSet<ObjectType> {
    static setWithCapacity<ObjectType>(capacity: number): NSMutableSet<ObjectType>;
    addObject(_: ObjectType): void;
    addObjectsFromArray(from: ObjectType[]): void;
    filterUsingPredicate(using: NSPredicate): void;
    intersect(_: NSSet<ObjectType>): void;
    minus(_: NSSet<ObjectType>): void;
    removeAllObjects(): void;
    removeObject(_: ObjectType): void;
    setSet(_: NSSet<ObjectType>): void;
    union(_: NSSet<ObjectType>): void;
  }

  // interface
  class NSMutableString extends NSString {
    static stringWithCapacity(capacity: number): NSMutableString;
    appendString(_: string): void;
    applyTransformReverseRangeUpdatedRange(_: string, reverse: boolean, range: NSRange, updatedRange?: NSRange): boolean;
    deleteCharactersInRange(in_: NSRange): void;
    static createWithCapacity(capacity: number): NSMutableString;
    insertStringAtIndex(_: string, at: number): void;
    replaceCharactersInRangeWithString(in_: NSRange, with_: string): void;
    replaceOccurrencesOfStringWithStringOptionsRange(of: string, with_: string, options: NSString.CompareOptions, range: NSRange): number;
    setString(_: string): void;
  }

  // interface
  class NSMutableURLRequest extends NSURLRequest {
    addValueForHTTPHeaderField(_: string, forHTTPHeaderField: string): void;
    setValueForHTTPHeaderField(_?: string, forHTTPHeaderField?: string): void;
  }

  // interface
  class NSNameSpecifier extends NSScriptObjectSpecifier {
    name: string;
    setName(_: string)
    static createWithContainerClassDescriptionContainerSpecifierKeyName(containerClassDescription: NSScriptClassDescription, containerSpecifier?: NSScriptObjectSpecifier, key?: string, name?: string): NSNameSpecifier;
  }

  // interface
  class NetService extends NSObject {
    static dataFromTXTRecordDictionary(_: Map<string, Data>): NSData;
    static dictionaryFromTXTRecordData(_: NSData): Map<string, Data>;
    addresses: NSData[];
    delegate: NetServiceDelegate;
    setDelegate(_: NetServiceDelegate)
    domain: string;
    hostName: string;
    includesPeerToPeer: boolean;
    setIncludesPeerToPeer(_: boolean)
    name: string;
    port: number;
    type: string;
    TXTRecordData(): NSData;
    getInputStreamOutputStream(_?: InputStream, outputStream?: OutputStream): boolean;
    static createWithDomainTypeName(domain: string, type: string, name: string): NetService;
    static createWithDomainTypeNamePort(domain: string, type: string, name: string, port: number): NetService;
    publish(): void;
    publishWithOptions(_: NetService.Options): void;
    removeFromRunLoopForMode(_: RunLoop, forMode: string): void;
    resolveWithTimeout(_: number): void;
    scheduleInRunLoopForMode(_: RunLoop, forMode: string): void;
    setTXTRecordData(_?: NSData): boolean;
    startMonitoring(): void;
    stop(): void;
    stopMonitoring(): void;
  }

  // interface
  class NetServiceBrowser extends NSObject {
    delegate: NetServiceBrowserDelegate;
    setDelegate(_: NetServiceBrowserDelegate)
    includesPeerToPeer: boolean;
    setIncludesPeerToPeer(_: boolean)
    removeFromRunLoopForMode(_: RunLoop, forMode: string): void;
    scheduleInRunLoopForMode(_: RunLoop, forMode: string): void;
    searchForBrowsableDomains(): void;
    searchForRegistrationDomains(): void;
    searchForServicesOfTypeInDomain(_: string, inDomain: string): void;
    stop(): void;
  }

  interface NetServiceBrowserDelegate extends NSObject {
    // instance method
    netServiceBrowserDidFindDomainMoreComing?(_: NetServiceBrowser, didFindDomain: string, moreComing: boolean): void;
    // instance method
    netServiceBrowserDidFindServiceMoreComing?(_: NetServiceBrowser, didFindService: NetService, moreComing: boolean): void;
    // instance method
    netServiceBrowserDidNotSearch?(_: NetServiceBrowser, didNotSearch: Map<string, number>): void;
    // instance method
    netServiceBrowserDidRemoveDomainMoreComing?(_: NetServiceBrowser, didRemoveDomain: string, moreComing: boolean): void;
    // instance method
    netServiceBrowserDidRemoveServiceMoreComing?(_: NetServiceBrowser, didRemoveService: NetService, moreComing: boolean): void;
    // instance method
    netServiceBrowserDidStopSearch?(_: NetServiceBrowser): void;
    // instance method
    netServiceBrowserWillSearch?(_: NetServiceBrowser): void;
  }

  interface NetServiceDelegate extends NSObject {
    // instance method
    netServiceDidAcceptConnectionWithInputStreamOutputStream?(_: NetService, didAcceptConnectionWithInputStream: InputStream, outputStream: OutputStream): void;
    // instance method
    netServiceDidNotPublish?(_: NetService, didNotPublish: Map<string, number>): void;
    // instance method
    netServiceDidNotResolve?(_: NetService, didNotResolve: Map<string, number>): void;
    // instance method
    netServiceDidUpdateTXTRecordData?(_: NetService, didUpdateTXTRecordData: NSData): void;
    // instance method
    netServiceDidPublish?(_: NetService): void;
    // instance method
    netServiceDidResolveAddress?(_: NetService): void;
    // instance method
    netServiceDidStop?(_: NetService): void;
    // instance method
    netServiceWillPublish?(_: NetService): void;
    // instance method
    netServiceWillResolve?(_: NetService): void;
  }

  // export function NSNextHashEnumeratorItem(enumerator: NSHashEnumerator): any;

  // export function NSNextMapEnumeratorPair(enumerator: NSMapEnumerator, key: any, value: any): boolean;

  // interface
  class NSNotification extends NSObject /* implements NSCoding, NSCopying */ {
    name: string;
    object: any;
    userInfo: Map<any, any>;
    static createWithNameObjectUserInfo(name: string, object_?: any, userInfo?: Map<any, any>): NSNotification;
  }

  // interface
  class NotificationCenter extends NSObject {
    static defaultCenter: NotificationCenter;
    addObserverSelectorNameObject(_: any, selector: string, name?: string, object_?: any): void;
    addObserverForNameWithObjectQueueUsingBlock(_?: string, object_?: any, queue?: OperationQueue, usingBlock?: (p1: NSNotification) => void): NSObject;
    postNotification(_: NSNotification): void;
    postNotificationNameObject(name: string, object_?: any): void;
    postNotificationNameObjectUserInfo(name: string, object_?: any, userInfo?: Map<any, any>): void;
    removeObserver(_: any): void;
    removeObserverNameObject(_: any, name?: string, object_?: any): void;
  }

  // interface
  class NotificationQueue extends NSObject {
    static defaultQueue: NotificationQueue;
    dequeueNotificationsMatchingCoalesceMask(_: NSNotification, coalesceMask: number): void;
    enqueueNotificationPostingStyle(_: NSNotification, postingStyle: NotificationQueue.PostingStyle): void;
    enqueueNotificationPostingStyleCoalesceMaskForModes(_: NSNotification, postingStyle: NotificationQueue.PostingStyle, coalesceMask: NotificationQueue.NotificationCoalescing, forModes?: string[]): void;
    static createWithNotificationCenter(notificationCenter: NotificationCenter): NotificationQueue;
  }

  // interface
  class NSNull extends NSObject /* implements NSCopying, NSSecureCoding, CAAction */ {
  }

  // interface
  class NSNumber extends NSValue /* implements NSFetchRequestResult */ {
    static numberWithBool(bool: boolean): number;
    static numberWithChar(char: number): number;
    static numberWithDouble(double: number): number;
    static numberWithFloat(float: number): number;
    static numberWithInt(int: number): number;
    static numberWithInteger(integer: number): number;
    static numberWithLong(long: number): number;
    static numberWithLongLong(longLong: number): number;
    static numberWithShort(short: number): number;
    static numberWithUnsignedChar(unsignedChar: number): number;
    static numberWithUnsignedInt(unsignedInt: number): number;
    static numberWithUnsignedInteger(unsignedInteger: number): number;
    static numberWithUnsignedLong(unsignedLong: number): number;
    static numberWithUnsignedLongLong(unsignedLongLong: number): number;
    static numberWithUnsignedShort(unsignedShort: number): number;
    boolValue: boolean;
    charValue: number;
    decimalValue: number;
    doubleValue: number;
    floatValue: number;
    intValue: number;
    integerValue: number;
    longLongValue: number;
    longValue: number;
    shortValue: number;
    stringValue: string;
    unsignedCharValue: number;
    unsignedIntValue: number;
    unsignedIntegerValue: number;
    unsignedLongLongValue: number;
    unsignedLongValue: number;
    unsignedShortValue: number;
    compare(_: number): ComparisonResult;
    descriptionWithLocale(withLocale?: any): string;
    static createWithBool(bool: boolean): NSNumber;
    static createWithChar(char: number): NSNumber;
    static createWithDouble(double: number): NSNumber;
    static createWithFloat(float: number): NSNumber;
    static createWithInt(int: number): NSNumber;
    static createWithInteger(integer: number): NSNumber;
    static createWithLong(long: number): NSNumber;
    static createWithLongLong(longLong: number): NSNumber;
    static createWithShort(short: number): NSNumber;
    static createWithUnsignedChar(unsignedChar: number): NSNumber;
    static createWithUnsignedInt(unsignedInt: number): NSNumber;
    static createWithUnsignedInteger(unsignedInteger: number): NSNumber;
    static createWithUnsignedLong(unsignedLong: number): NSNumber;
    static createWithUnsignedLongLong(unsignedLongLong: number): NSNumber;
    static createWithUnsignedShort(unsignedShort: number): NSNumber;
    isEqualToNumber(to: number): boolean;
  }

  // interface
  class NumberFormatter extends Formatter {
    static defaultFormatterBehavior(): NumberFormatter.Behavior;
    static localizedStringFromNumberNumberStyle(_: number, numberStyle: NumberFormatter.Style): string;
    static setDefaultFormatterBehavior(_: NumberFormatter.Behavior): void;
    allowsFloats: boolean;
    setAllowsFloats(_: boolean)
    alwaysShowsDecimalSeparator: boolean;
    setAlwaysShowsDecimalSeparator(_: boolean)
    attributedStringForNil: NSAttributedString;
    setAttributedStringForNil(_: NSAttributedString)
    attributedStringForNotANumber: NSAttributedString;
    setAttributedStringForNotANumber(_: NSAttributedString)
    attributedStringForZero: NSAttributedString;
    setAttributedStringForZero(_: NSAttributedString)
    currencyCode: string;
    setCurrencyCode(_: string)
    currencyDecimalSeparator: string;
    setCurrencyDecimalSeparator(_: string)
    currencyGroupingSeparator: string;
    setCurrencyGroupingSeparator(_: string)
    currencySymbol: string;
    setCurrencySymbol(_: string)
    decimalSeparator: string;
    setDecimalSeparator(_: string)
    exponentSymbol: string;
    setExponentSymbol(_: string)
    format: string;
    setFormat(_: string)
    formatWidth: number;
    setFormatWidth(_: number)
    formatterBehavior: NumberFormatter.Behavior;
    setFormatterBehavior(_: NumberFormatter.Behavior)
    formattingContext: Formatter.Context;
    setFormattingContext(_: Formatter.Context)
    generatesDecimalNumbers: boolean;
    setGeneratesDecimalNumbers(_: boolean)
    groupingSeparator: string;
    setGroupingSeparator(_: string)
    groupingSize: number;
    setGroupingSize(_: number)
    hasThousandSeparators: boolean;
    setHasThousandSeparators(_: boolean)
    internationalCurrencySymbol: string;
    setInternationalCurrencySymbol(_: string)
    isLenient: boolean;
    setLenient(_: boolean)
    locale: NSLocale;
    setLocale(_: NSLocale)
    localizesFormat: boolean;
    setLocalizesFormat(_: boolean)
    maximum: number;
    setMaximum(_: number)
    maximumFractionDigits: number;
    setMaximumFractionDigits(_: number)
    maximumIntegerDigits: number;
    setMaximumIntegerDigits(_: number)
    maximumSignificantDigits: number;
    setMaximumSignificantDigits(_: number)
    minimum: number;
    setMinimum(_: number)
    minimumFractionDigits: number;
    setMinimumFractionDigits(_: number)
    minimumIntegerDigits: number;
    setMinimumIntegerDigits(_: number)
    minimumSignificantDigits: number;
    setMinimumSignificantDigits(_: number)
    minusSign: string;
    setMinusSign(_: string)
    multiplier: number;
    setMultiplier(_: number)
    negativeFormat: string;
    setNegativeFormat(_: string)
    negativeInfinitySymbol: string;
    setNegativeInfinitySymbol(_: string)
    negativePrefix: string;
    setNegativePrefix(_: string)
    negativeSuffix: string;
    setNegativeSuffix(_: string)
    nilSymbol: string;
    setNilSymbol(_: string)
    notANumberSymbol: string;
    setNotANumberSymbol(_: string)
    numberStyle: NumberFormatter.Style;
    setNumberStyle(_: NumberFormatter.Style)
    paddingCharacter: string;
    setPaddingCharacter(_: string)
    paddingPosition: NumberFormatter.PadPosition;
    setPaddingPosition(_: NumberFormatter.PadPosition)
    isPartialStringValidationEnabled: boolean;
    setPartialStringValidationEnabled(_: boolean)
    perMillSymbol: string;
    setPerMillSymbol(_: string)
    percentSymbol: string;
    setPercentSymbol(_: string)
    plusSign: string;
    setPlusSign(_: string)
    positiveFormat: string;
    setPositiveFormat(_: string)
    positiveInfinitySymbol: string;
    setPositiveInfinitySymbol(_: string)
    positivePrefix: string;
    setPositivePrefix(_: string)
    positiveSuffix: string;
    setPositiveSuffix(_: string)
    roundingBehavior: NSDecimalNumberHandler;
    setRoundingBehavior(_: NSDecimalNumberHandler)
    roundingIncrement: number;
    setRoundingIncrement(_: number)
    roundingMode: NumberFormatter.RoundingMode;
    setRoundingMode(_: NumberFormatter.RoundingMode)
    secondaryGroupingSize: number;
    setSecondaryGroupingSize(_: number)
    textAttributesForNegativeInfinity: Map<string, any>;
    setTextAttributesForNegativeInfinity(_: Map<string, any>)
    textAttributesForNegativeValues: Map<string, any>;
    setTextAttributesForNegativeValues(_: Map<string, any>)
    textAttributesForNil: Map<string, any>;
    setTextAttributesForNil(_: Map<string, any>)
    textAttributesForNotANumber: Map<string, any>;
    setTextAttributesForNotANumber(_: Map<string, any>)
    textAttributesForPositiveInfinity: Map<string, any>;
    setTextAttributesForPositiveInfinity(_: Map<string, any>)
    textAttributesForPositiveValues: Map<string, any>;
    setTextAttributesForPositiveValues(_: Map<string, any>)
    textAttributesForZero: Map<string, any>;
    setTextAttributesForZero(_: Map<string, any>)
    thousandSeparator: string;
    setThousandSeparator(_: string)
    usesGroupingSeparator: boolean;
    setUsesGroupingSeparator(_: boolean)
    usesSignificantDigits: boolean;
    setUsesSignificantDigits(_: boolean)
    zeroSymbol: string;
    setZeroSymbol(_: string)
    getObjectValueForStringRangeError(forString?: any, range?: string, error?: NSRange): boolean;
    numberFromString(_: string): number;
    stringFromNumber(_: number): string;
  }

  // export function NSOffsetRect(aRect: CGRect, dX: number, dY: number): CGRect;

  // export function NSOpenStepRootDirectory(): string;

  // interface
  class Operation extends NSObject {
    isAsynchronous: boolean;
    isCancelled: boolean;
    completionBlock: () => void;
    setCompletionBlock(_: () => void)
    isConcurrent: boolean;
    dependencies: Operation[];
    isExecuting: boolean;
    isFinished: boolean;
    name: string;
    setName(_: string)
    qualityOfService: QualityOfService;
    setQualityOfService(_: QualityOfService)
    queuePriority: Operation.QueuePriority;
    setQueuePriority(_: Operation.QueuePriority)
    isReady: boolean;
    addDependency(_: Operation): void;
    cancel(): void;
    main(): void;
    removeDependency(_: Operation): void;
    start(): void;
    waitUntilFinished(): void;
  }

  // interface
  class OperationQueue extends NSObject /* implements ProgressReporting */ {
    maxConcurrentOperationCount: number;
    setMaxConcurrentOperationCount(_: number)
    name: string;
    setName(_: string)
    operationCount: number;
    operations: Operation[];
    qualityOfService: QualityOfService;
    setQualityOfService(_: QualityOfService)
    isSuspended: boolean;
    setSuspended(_: boolean)
    underlyingQueue: NSObject;
    setUnderlyingQueue(_: NSObject)
    static currentQueue: OperationQueue;
    static mainQueue: OperationQueue;
    addBarrierBlock(_: () => void): void;
    addOperation(_: Operation): void;
    addOperationWithBlock(_: () => void): void;
    addOperationsWaitUntilFinished(_: Operation[], waitUntilFinished: boolean): void;
    cancelAllOperations(): void;
    waitUntilAllOperationsAreFinished(): void;
  }

  // interface
  class NSOrderedCollectionChange<ObjectType> extends NSObject {
    associatedIndex: number;
    changeType: NSCollectionChangeType;
    index: number;
    object: ObjectType;
  }

  // interface
  class NSOrderedCollectionDifference<ObjectType> extends NSObject /* implements NSFastEnumeration */ {
    hasChanges: boolean;
    insertions: NSOrderedCollectionChange<ObjectType>[];
    removals: NSOrderedCollectionChange<ObjectType>[];
    transformingChanges(_: (p1: NSOrderedCollectionChange<ObjectType>) => NSOrderedCollectionChange<any>): NSOrderedCollectionDifference<any>;
    inverseDifference(): NSOrderedCollectionDifference<ObjectType>;
  }

  // interface
  class NSOrderedSet<ObjectType> extends NSObject /* implements NSCopying, NSFastEnumeration, NSMutableCopying, NSSecureCoding */ {
    static orderedSetWithObjects<ObjectType>(_: ObjectType): NSOrderedSet<ObjectType>;
    array: ObjectType[];
    count: number;
    firstObject: ObjectType;
    lastObject: ObjectType;
    reversedOrderedSet: NSOrderedSet<ObjectType>;
    set: NSSet<ObjectType>;
    containsObject(_: ObjectType): boolean;
    descriptionWithLocale(withLocale?: any): string;
    descriptionWithLocaleIndent(withLocale?: any, indent?: number): string;
    enumerateObjectsWithAtOptionsUsing(at: NSIndexSet, options: NSEnumerationOptions, using: (p1: ObjectType, p2: number, p3: boolean) => void): void;
    enumerateObjects(_: (p1: ObjectType, p2: number, p3: boolean) => void): void;
    enumerateObjectsWithOptionsUsing(options: NSEnumerationOptions, using: (p1: ObjectType, p2: number, p3: boolean) => void): void;
    filteredOrderedSetUsingPredicate(using: NSPredicate): NSOrderedSet<ObjectType>;
    indexOfObject(of: ObjectType): number;
    indexOfInSortedRangeOptionsUsingComparator(of: ObjectType, inSortedRange: NSRange, options: NSBinarySearchingOptions, usingComparator: (p1: any, p2: any) => ComparisonResult): number;
    indexWithOfObjectAtOptionsPassingTest(ofObjectAt: NSIndexSet, options: NSEnumerationOptions, passingTest: (p1: ObjectType, p2: number, p3: boolean) => boolean): number;
    indexWithOfObjectPassingTest(ofObjectPassingTest: (p1: ObjectType, p2: number, p3: boolean) => boolean): number;
    indexOfObjectPassingTest(_: NSEnumerationOptions, ofObjectPassingTest: (p1: ObjectType, p2: number, p3: boolean) => boolean): number;
    indexesWithOfObjectsAtOptionsPassingTest(ofObjectsAt: NSIndexSet, options: NSEnumerationOptions, passingTest: (p1: ObjectType, p2: number, p3: boolean) => boolean): NSIndexSet;
    indexesWithOfObjectsPassingTest(ofObjectsPassingTest: (p1: ObjectType, p2: number, p3: boolean) => boolean): NSIndexSet;
    indexesWithOptionsOfObjectsPassingTest(options: NSEnumerationOptions, ofObjectsPassingTest: (p1: ObjectType, p2: number, p3: boolean) => boolean): NSIndexSet;
    intersects(_: NSOrderedSet<ObjectType>): boolean;
    intersectsSet(_: NSSet<ObjectType>): boolean;
    isEqualWithTo(to: NSOrderedSet<ObjectType>): boolean;
    isSubsetOf(of: NSOrderedSet<ObjectType>): boolean;
    isSubsetOf(of: NSSet<ObjectType>): boolean;
    objectAtIndex(at: number): ObjectType;
    objectEnumerator(): NSEnumerator<ObjectType>;
    objectsAtIndexes(at: NSIndexSet): ObjectType[];
    reverseObjectEnumerator(): NSEnumerator<ObjectType>;
    sortedArrayWithComparator(comparator: (p1: any, p2: any) => ComparisonResult): ObjectType[];
    sortedArrayUsingDescriptors(using: NSSortDescriptor[]): ObjectType[];
    sortedArrayWithOptionsUsingComparator(options: NSSortOptions, usingComparator: (p1: any, p2: any) => ComparisonResult): ObjectType[];
  }

  // interface
  class NSOrthography extends NSObject /* implements NSCopying, NSSecureCoding */ {
    static defaultOrthographyForLanguage(forLanguage: string): NSOrthography;
    allLanguages: string[];
    allScripts: string[];
    dominantLanguage: string;
    dominantScript: string;
    languageMap: Map<string, string[]>;
    dominantLanguageForScript(forScript: string): string;
    static createWithDominantScriptLanguageMap(dominantScript: string, languageMap: Map<string, string[]>): NSOrthography;
    languagesForScript(forScript: string): string[];
  }

  // interface
  class OutputStream extends Stream {
    static outputStreamToBufferCapacity(_: string, capacity: number): OutputStream;
    static outputStreamToFileAtPathAppend(_: string, append: boolean): OutputStream;
    static outputStreamToMemory(): OutputStream;
    static outputStreamWithURLAppend(_: NSURL, append: boolean): OutputStream;
    hasSpaceAvailable: boolean;
    static createWithToBufferCapacity(toBuffer: string, capacity: number): OutputStream;
    static createWithToFileAtPathAppend(toFileAtPath: string, append: boolean): OutputStream;
    static createWithToMemory(): OutputStream;
    static createWithUrlAppend(URL: NSURL, append: boolean): OutputStream;
    writeMaxLength(_: string, maxLength: number): number;
  }

  // export function NSPageSize(): number;

  // interface
  class NSPersonNameComponents extends NSObject /* implements NSCopying, NSSecureCoding */ {
    familyName: string;
    setFamilyName(_: string)
    givenName: string;
    setGivenName(_: string)
    middleName: string;
    setMiddleName(_: string)
    namePrefix: string;
    setNamePrefix(_: string)
    nameSuffix: string;
    setNameSuffix(_: string)
    nickname: string;
    setNickname(_: string)
    phoneticRepresentation: NSPersonNameComponents;
    setPhoneticRepresentation(_: NSPersonNameComponents)
  }

  // interface
  class PersonNameComponentsFormatter extends Formatter {
    static localizedStringFromPersonNameComponentsStyleOptions(_: NSPersonNameComponents, style: PersonNameComponentsFormatter.Style, options: PersonNameComponentsFormatter.Options): string;
    isPhonetic: boolean;
    setPhonetic(_: boolean)
    style: PersonNameComponentsFormatter.Style;
    setStyle(_: PersonNameComponentsFormatter.Style)
    annotatedStringFromPersonNameComponents(_: NSPersonNameComponents): NSAttributedString;
    personNameComponentsFromString(_: string): NSPersonNameComponents;
    stringFromPersonNameComponents(_: NSPersonNameComponents): string;
  }

  // interface
  class Pipe extends NSObject {
    static pipe(): Pipe;
    fileHandleForReading: FileHandle;
    fileHandleForWriting: FileHandle;
  }

  // export function NSPointFromString(aString: string): CGPoint;

  // export function NSPointInRect(aPoint: CGPoint, aRect: CGRect): boolean;

  // interface
  class NSPointerArray extends NSObject /* implements NSCopying, NSFastEnumeration, NSSecureCoding */ {
    static strongObjectsPointerArray(): NSPointerArray;
    static weakObjectsPointerArray(): NSPointerArray;
    allObjects: any[];
    count: number;
    setCount(_: number)
    pointerFunctions: NSPointerFunctions;
    addPointer(_?: any): void;
    compact(): void;
    static createWithOptions(options: NSPointerFunctions.Options): NSPointerArray;
    static createWithPointerFunctions(pointerFunctions: NSPointerFunctions): NSPointerArray;
    insertPointerAtIndex(_?: any, at?: number): void;
    pointerAtIndex(at: number): any;
    removePointerAtIndex(at: number): void;
    replacePointerAtIndexWithPointer(at: number, withPointer?: any): void;
  }

  // interface
  class NSPointerFunctions extends NSObject /* implements NSCopying */ {
    acquireFunction: (p1: any, p2: (p1: any) => number, p3: boolean) => any;
    setAcquireFunction(_: (p1: any, p2: (p1: any) => number, p3: boolean) => any)
    descriptionFunction: (p1: any) => string;
    setDescriptionFunction(_: (p1: any) => string)
    hashFunction: (p1: any, p2: (p1: any) => number) => number;
    setHashFunction(_: (p1: any, p2: (p1: any) => number) => number)
    isEqualFunction: (p1: any, p2: any, p3: (p1: any) => number) => boolean;
    setIsEqualFunction(_: (p1: any, p2: any, p3: (p1: any) => number) => boolean)
    relinquishFunction: (p1: any, p2: (p1: any) => number) => void;
    setRelinquishFunction(_: (p1: any, p2: (p1: any) => number) => void)
    sizeFunction: (p1: any) => number;
    setSizeFunction(_: (p1: any) => number)
    static createWithOptions(options: NSPointerFunctions.Options): NSPointerFunctions;
  }

  // interface
  class Port extends NSObject /* implements NSCoding, NSCopying */ {
    reservedSpaceLength: number;
    isValid: boolean;
    delegate(): PortDelegate;
    invalidate(): void;
    removeFromRunLoopForMode(_: RunLoop, forMode: string): void;
    scheduleInRunLoopForMode(_: RunLoop, forMode: string): void;
    sendBeforeDateComponentsFromReserved(_: Date, components?: NSMutableArray<any>, from?: Port, reserved?: number): boolean;
    sendBeforeDateMsgidComponentsFromReserved(_: Date, msgid: number, components?: NSMutableArray<any>, from?: Port, reserved?: number): boolean;
    setDelegate(_?: PortDelegate): void;
  }

  interface PortDelegate extends NSObject {
    // instance method
    handlePortMessage?(_: PortMessage): void;
  }

  // interface
  class PortMessage extends NSObject {
    components: any[];
    msgid: number;
    setMsgid(_: number)
    receivePort: Port;
    sendPort: Port;
    static createWithSendPortReceivePortComponents(sendPort?: Port, receivePort?: Port, components?: any[]): PortMessage;
    sendBeforeDate(_: Date): boolean;
  }

  // interface
  class NSPositionalSpecifier extends NSObject {
    insertionContainer: any;
    insertionIndex: number;
    insertionKey: string;
    insertionReplaces: boolean;
    position: NSPositionalSpecifier.InsertionPosition;
    evaluate(): void;
    static createWithPositionObjectSpecifier(position: NSPositionalSpecifier.InsertionPosition, objectSpecifier: NSScriptObjectSpecifier): NSPositionalSpecifier;
    setInsertionClassDescription(_: NSScriptClassDescription): void;
  }

  // interface
  class NSPredicate extends NSObject /* implements NSCopying, NSSecureCoding */ {
    predicateFormat: string;
    allowEvaluation(): void;
    evaluateWithObject(with_?: any): boolean;
    evaluateWithObjectSubstitutionVariables(with_?: any, substitutionVariables?: Map<string, any>): boolean;
    predicateWithSubstitutionVariables(_: Map<string, any>): NSPredicate;
  }

  // interface
  class ProcessInfo extends NSObject {
    activeProcessorCount: number;
    arguments: string[];
    automaticTerminationSupportEnabled: boolean;
    setAutomaticTerminationSupportEnabled(_: boolean)
    environment: Map<string, string>;
    fullUserName: string;
    globallyUniqueString: string;
    hostName: string;
    isMacCatalystApp: boolean;
    operatingSystemVersion: OperatingSystemVersion;
    operatingSystemVersionString: string;
    physicalMemory: number;
    processIdentifier: number;
    processName: string;
    setProcessName(_: string)
    processorCount: number;
    systemUptime: number;
    thermalState: ProcessInfo.ThermalState;
    userName: string;
    static processInfo: ProcessInfo;
    beginActivityWithOptionsReason(_: ProcessInfo.ActivityOptions, reason: string): NSObject;
    disableAutomaticTermination(_: string): void;
    disableSuddenTermination(): void;
    enableAutomaticTermination(_: string): void;
    enableSuddenTermination(): void;
    endActivity(_: NSObject): void;
    isOperatingSystemAtLeastVersion(_: OperatingSystemVersion): boolean;
    performActivityWithOptionsWithReasonUsingBlock(_: ProcessInfo.ActivityOptions, reason: string, usingBlock: () => void): void;
  }

  // interface
  class Progress extends NSObject {
    static addSubscriberForFileURLWithWithPublishingHandler(_: NSURL, withPublishingHandler: (p1: Progress) => () => void): any;
    static currentProgress(): Progress;
    static discreteProgressWithTotalUnitCount(totalUnitCount: number): Progress;
    static removeSubscriber(_: any): void;
    isCancellable: boolean;
    setCancellable(_: boolean)
    cancellationHandler: () => void;
    setCancellationHandler(_: () => void)
    isCancelled: boolean;
    completedUnitCount: number;
    setCompletedUnitCount(_: number)
    estimatedTimeRemaining: number;
    setEstimatedTimeRemaining(_: number)
    fileCompletedCount: number;
    setFileCompletedCount(_: number)
    fileOperationKind: string;
    setFileOperationKind(_: string)
    fileTotalCount: number;
    setFileTotalCount(_: number)
    fileURL: NSURL;
    setFileURL(_: NSURL)
    isFinished: boolean;
    fractionCompleted: number;
    isIndeterminate: boolean;
    kind: string;
    setKind(_: string)
    localizedAdditionalDescription: string;
    setLocalizedAdditionalDescription(_: string)
    localizedDescription: string;
    setLocalizedDescription(_: string)
    isOld: boolean;
    isPausable: boolean;
    setPausable(_: boolean)
    isPaused: boolean;
    pausingHandler: () => void;
    setPausingHandler(_: () => void)
    resumingHandler: () => void;
    setResumingHandler(_: () => void)
    throughput: number;
    setThroughput(_: number)
    totalUnitCount: number;
    setTotalUnitCount(_: number)
    userInfo: Map<string, any>;
    addChildWithPendingUnitCount(_: Progress, withPendingUnitCount: number): void;
    becomeCurrentWithPendingUnitCount(_: number): void;
    cancel(): void;
    static createWithParentUserInfo(parent?: Progress, userInfo?: Map<string, any>): Progress;
    pause(): void;
    performAsCurrentWithPendingUnitCountWithUsingBlock(_: number, usingBlock: () => void): void;
    publish(): void;
    resignCurrent(): void;
    resume(): void;
    setUserInfoObjectForKey(_?: any, forKey?: string): void;
    unpublish(): void;
  }

  interface ProgressReporting extends NSObject {
    progress: Progress;
  }

  // interface
  class PropertyListSerialization extends NSObject {
    static dataWithPropertyListFormatOptionsError(fromPropertyList: any, format: PropertyListSerialization.PropertyListFormat, options: number): NSData;
    static propertyListIsValidForFormat(_: any, isValidForFormat: PropertyListSerialization.PropertyListFormat): boolean;
    static propertyListWithDataOptionsFormatError(from: NSData, options: PropertyListSerialization.MutabilityOptions, format?: PropertyListSerialization.PropertyListFormat): any;
    static propertyListWithStreamOptionsFormatError(options: InputStream, format: PropertyListSerialization.MutabilityOptions, error?: PropertyListSerialization.PropertyListFormat): any;
    static writePropertyListToStreamFormatOptionsError(toStream: any, format: OutputStream, options: PropertyListSerialization.PropertyListFormat, error: number): number;
  }

  // interface
  class NSPropertySpecifier extends NSScriptObjectSpecifier {
  }

  // interface
  class NSProtocolChecker extends NSProxy {
    protocol: any /* Protocol */;
    target: NSObject;
    static createWithTargetProtocol(target: NSObject, protocol: any /* Protocol */): NSProtocolChecker;
  }

  // export function NSProtocolFromString(namestr: string): any /* Protocol */;

  // interface
  class NSProxy /* implements NSObject */ {
    static alloc(): NSProxy;
    static class(): typeof NSObject;
    static respondsToSelector(to: string): boolean;
    dealloc(): void;
    finalize(): void;
  }

  // interface
  class NSPurgeableData extends NSMutableData /* implements NSDiscardableContent */ {
  }

  // interface
  class NSQuitCommand extends NSScriptCommand {
    saveOptions: NSSaveOptions;
  }

  // interface
  class NSRandomSpecifier extends NSScriptObjectSpecifier {
  }

  // export function NSRangeFromString(aString: string): NSRange;

  // interface
  class NSRangeSpecifier extends NSScriptObjectSpecifier {
    endSpecifier: NSScriptObjectSpecifier;
    setEndSpecifier(_: NSScriptObjectSpecifier)
    startSpecifier: NSScriptObjectSpecifier;
    setStartSpecifier(_: NSScriptObjectSpecifier)
    static createWithContainerClassDescriptionContainerSpecifierKeyStartSpecifierEndSpecifier(containerClassDescription: NSScriptClassDescription, containerSpecifier?: NSScriptObjectSpecifier, key?: string, startSpecifier?: NSScriptObjectSpecifier, endSpecifier?: NSScriptObjectSpecifier): NSRangeSpecifier;
  }

  // export function NSRecordAllocationEvent(eventType: number, object_: any): void;

  // export function NSRectFromString(aString: string): CGRect;

  // interface
  class NSRecursiveLock extends NSObject /* implements NSLocking */ {
    name: string;
    setName(_: string)
    lockBeforeDate(before: Date): boolean;
    tryLock(): boolean;
  }

  // interface
  class NSRegularExpression extends NSObject /* implements NSCopying, NSSecureCoding */ {
    static escapedPatternForString(for_: string): string;
    static escapedTemplateForString(for_: string): string;
    static regularExpressionWithPatternOptionsError(options: string, error: NSRegularExpression.Options): NSRegularExpression;
    numberOfCaptureGroups: number;
    options: NSRegularExpression.Options;
    pattern: string;
    enumerateMatchesWithInOptionsRangeUsing(in_: string, options: NSRegularExpression.MatchingOptions, range: NSRange, using?: (p1: NSTextCheckingResult, p2: NSRegularExpression.MatchingFlags, p3: boolean) => void): void;
    firstMatchInStringOptionsRange(in_: string, options: NSRegularExpression.MatchingOptions, range: NSRange): NSTextCheckingResult;
    static createWithPatternOptions(pattern: string, options: NSRegularExpression.Options): NSRegularExpression;
    matchesInStringOptionsRange(in_: string, options: NSRegularExpression.MatchingOptions, range: NSRange): NSTextCheckingResult[];
    numberOfMatchesInStringOptionsRange(in_: string, options: NSRegularExpression.MatchingOptions, range: NSRange): number;
    rangeOfFirstMatchInStringOptionsRange(in_: string, options: NSRegularExpression.MatchingOptions, range: NSRange): NSRange;
    replaceMatchesInStringOptionsRangeWithTemplate(in_: NSMutableString, options: NSRegularExpression.MatchingOptions, range: NSRange, withTemplate: string): number;
    replacementStringForResultInStringOffsetTemplate(for_: NSTextCheckingResult, in_: string, offset: number, template: string): string;
    stringByReplacingMatchesInStringOptionsRangeWithTemplate(in_: string, options: NSRegularExpression.MatchingOptions, range: NSRange, withTemplate: string): string;
  }

  // interface
  class RelativeDateTimeFormatter extends Formatter {
    calendar: NSCalendar;
    setCalendar(_: NSCalendar)
    dateTimeStyle: RelativeDateTimeFormatter.DateTimeStyle;
    setDateTimeStyle(_: RelativeDateTimeFormatter.DateTimeStyle)
    formattingContext: Formatter.Context;
    setFormattingContext(_: Formatter.Context)
    locale: NSLocale;
    setLocale(_: NSLocale)
    unitsStyle: RelativeDateTimeFormatter.UnitsStyle;
    setUnitsStyle(_: RelativeDateTimeFormatter.UnitsStyle)
    localizedStringForDateRelativeToDate(_: Date, relativeToDate: Date): string;
    localizedStringFromDateComponents(_: NSDateComponents): string;
    localizedStringFromTimeInterval(_: number): string;
  }

  // interface
  class NSRelativeSpecifier extends NSScriptObjectSpecifier {
    baseSpecifier: NSScriptObjectSpecifier;
    setBaseSpecifier(_: NSScriptObjectSpecifier)
    relativePosition: NSRelativeSpecifier.RelativePosition;
    setRelativePosition(_: NSRelativeSpecifier.RelativePosition)
    static createWithContainerClassDescriptionContainerSpecifierKeyRelativePositionBaseSpecifier(containerClassDescription: NSScriptClassDescription, containerSpecifier?: NSScriptObjectSpecifier, key?: string, relativePosition?: NSRelativeSpecifier.RelativePosition, baseSpecifier?: NSScriptObjectSpecifier): NSRelativeSpecifier;
  }

  // export function NSResetHashTable(table: NSHashTable<any>): void;

  // export function NSResetMapTable(table: NSMapTable<any, any>): void;

  // export function NSReturnAddress(frame: number): any;

  // export function NSRoundDownToMultipleOfPageSize(bytes: number): number;

  // export function NSRoundUpToMultipleOfPageSize(bytes: number): number;

  // interface
  class RunLoop extends NSObject {
    currentMode: string;
    static currentRunLoop: RunLoop;
    static mainRunLoop: RunLoop;
    acceptInputForModeBeforeDate(_: string, beforeDate: Date): void;
    addPortForMode(_: Port, forMode: string): void;
    addTimerForMode(_: Timer, forMode: string): void;
    cancelPerformSelectorTargetArgument(_: string, target: any, argument?: any): void;
    cancelPerformSelectorsWithTarget(_: any): void;
    getCFRunLoop(): any;
    limitDateForMode(_: string): Date;
    performBlock(_: () => void): void;
    performInModesWithBlock(_: string[], block: () => void): void;
    performSelectorTargetArgumentOrderModes(_: string, target: any, argument?: any, order?: number, modes?: string[]): void;
    removePortForMode(_: Port, forMode: string): void;
    run(): void;
    runModeBeforeDate(mode: string, before: Date): boolean;
    runUntilDate(_: Date): void;
  }

  // interface
  class Scanner extends NSObject /* implements NSCopying */ {
    static localizedScannerWithString(_: string): any;
    isAtEnd: boolean;
    caseSensitive: boolean;
    setCaseSensitive(_: boolean)
    charactersToBeSkipped: NSCharacterSet;
    setCharactersToBeSkipped(_: NSCharacterSet)
    locale: any;
    setLocale(_: any)
    string: string;
    static createWithString(string: string): Scanner;
    scanHexDouble(_?: number): boolean;
    scanHexFloat(_?: number): boolean;
    scanHexLongLong(_?: number): boolean;
    scanInt(_?: number): boolean;
    scanInteger(_?: number): boolean;
    scanLongLong(_?: number): boolean;
    scanUnsignedLongLong(_?: number): boolean;
  }

  // interface
  class NSScriptClassDescription extends NSClassDescription {
    appleEventCode: number;
    defaultSubcontainerAttributeKey: string;
    implementationClassName: string;
    suiteName: string;
    superclassDescription: NSScriptClassDescription;
    appleEventCodeForKey(forKey: string): number;
    classDescriptionForKey(_: string): NSScriptClassDescription;
    hasOrderedToManyRelationshipForKey(forKey: string): boolean;
    hasPropertyForKey(forKey: string): boolean;
    hasReadablePropertyForKey(forKey: string): boolean;
    hasWritablePropertyForKey(forKey: string): boolean;
    static createWithSuiteNameClassNameDictionary(suiteName: string, className: string, dictionary?: Map<any, any>): NSScriptClassDescription;
    isLocationRequiredToCreateForKey(forKey: string): boolean;
    keyWithAppleEventCode(withAppleEventCode: number): string;
    matchesAppleEventCode(_: number): boolean;
    selectorForCommand(forCommand: NSScriptCommandDescription): string;
    supportsCommand(_: NSScriptCommandDescription): boolean;
    typeForKey(forKey: string): string;
  }

  // interface
  class NSScriptCoercionHandler extends NSObject {
    static sharedCoercionHandler(): NSScriptCoercionHandler;
    coerceValueToClass(_: any, to: typeof NSObject): any;
    registerCoercerSelectorToConvertFromClassToClass(_: any, selector: string, toConvertFrom: typeof NSObject, to: typeof NSObject): void;
  }

  // interface
  class NSScriptCommand extends NSObject /* implements NSCoding */ {
    static currentCommand(): NSScriptCommand;
    appleEvent: NSAppleEventDescriptor;
    arguments: Map<string, any>;
    setArguments(_: Map<string, any>)
    commandDescription: NSScriptCommandDescription;
    directParameter: any;
    setDirectParameter(_: any)
    evaluatedArguments: Map<string, any>;
    evaluatedReceivers: any;
    receiversSpecifier: NSScriptObjectSpecifier;
    setReceiversSpecifier(_: NSScriptObjectSpecifier)
    scriptErrorExpectedTypeDescriptor: NSAppleEventDescriptor;
    setScriptErrorExpectedTypeDescriptor(_: NSAppleEventDescriptor)
    scriptErrorNumber: number;
    setScriptErrorNumber(_: number)
    scriptErrorOffendingObjectDescriptor: NSAppleEventDescriptor;
    setScriptErrorOffendingObjectDescriptor(_: NSAppleEventDescriptor)
    scriptErrorString: string;
    setScriptErrorString(_: string)
    isWellFormed: boolean;
    executeCommand(): any;
    static createWithCommandDescription(commandDescription: NSScriptCommandDescription): NSScriptCommand;
    performDefaultImplementation(): any;
    resumeExecutionWithResult(withResult?: any): void;
    suspendExecution(): void;
  }

  // interface
  class NSScriptCommandDescription extends NSObject /* implements NSCoding */ {
    appleEventClassCode: number;
    appleEventCode: number;
    appleEventCodeForReturnType: number;
    argumentNames: string[];
    commandClassName: string;
    commandName: string;
    returnType: string;
    suiteName: string;
    appleEventCodeForArgumentWithName(withName: string): number;
    createCommandInstance(): NSScriptCommand;
    createCommandInstanceWithZone(with_?: any): NSScriptCommand;
    static createWithSuiteNameCommandNameDictionary(suiteName: string, commandName: string, dictionary?: Map<any, any>): NSScriptCommandDescription;
    isOptionalArgumentWithName(withName: string): boolean;
    typeForArgumentWithName(withName: string): string;
  }

  // interface
  class NSScriptExecutionContext extends NSObject {
    static sharedScriptExecutionContext(): NSScriptExecutionContext;
    objectBeingTested: any;
    setObjectBeingTested(_: any)
    rangeContainerObject: any;
    setRangeContainerObject(_: any)
    topLevelObject: any;
    setTopLevelObject(_: any)
  }

  // interface
  class NSScriptObjectSpecifier extends NSObject /* implements NSCoding */ {
    static objectSpecifierWithDescriptor(descriptor: NSAppleEventDescriptor): NSScriptObjectSpecifier;
    childSpecifier: NSScriptObjectSpecifier;
    setChildSpecifier(_: NSScriptObjectSpecifier)
    containerClassDescription: NSScriptClassDescription;
    setContainerClassDescription(_: NSScriptClassDescription)
    containerIsObjectBeingTested: boolean;
    setContainerIsObjectBeingTested(_: boolean)
    containerIsRangeContainerObject: boolean;
    setContainerIsRangeContainerObject(_: boolean)
    containerSpecifier: NSScriptObjectSpecifier;
    setContainerSpecifier(_: NSScriptObjectSpecifier)
    descriptor: NSAppleEventDescriptor;
    evaluationErrorNumber: number;
    setEvaluationErrorNumber(_: number)
    evaluationErrorSpecifier: NSScriptObjectSpecifier;
    key: string;
    setKey(_: string)
    keyClassDescription: NSScriptClassDescription;
    objectsByEvaluatingSpecifier: any;
    indicesOfObjectsByEvaluatingWithContainerCount(withContainer: any, count: number): number;
    static createWithContainerClassDescriptionContainerSpecifierKey(containerClassDescription: NSScriptClassDescription, containerSpecifier?: NSScriptObjectSpecifier, key?: string): NSScriptObjectSpecifier;
    static createWithContainerSpecifierKey(containerSpecifier: NSScriptObjectSpecifier, key: string): NSScriptObjectSpecifier;
    objectsByEvaluatingWithContainers(withContainers: any): any;
  }

  // interface
  class NSScriptSuiteRegistry extends NSObject {
    static setSharedScriptSuiteRegistry(_: NSScriptSuiteRegistry): void;
    static sharedScriptSuiteRegistry(): NSScriptSuiteRegistry;
    suiteNames: string[];
    aeteResource(_: string): NSData;
    appleEventCodeForSuite(forSuite: string): number;
    bundleForSuite(forSuite: string): Bundle;
    classDescriptionWithAppleEventCode(withAppleEventCode: number): NSScriptClassDescription;
    classDescriptionsInSuite(inSuite: string): Map<string, NSScriptClassDescription>;
    commandDescriptionWithAppleEventClassAndAppleEventCode(withAppleEventClass: number, andAppleEventCode: number): NSScriptCommandDescription;
    commandDescriptionsInSuite(inSuite: string): Map<string, NSScriptCommandDescription>;
    loadSuiteWithDictionaryFromBundle(with_: Map<any, any>, from: Bundle): void;
    loadSuitesFromBundle(from: Bundle): void;
    registerClassDescription(_: NSScriptClassDescription): void;
    registerCommandDescription(_: NSScriptCommandDescription): void;
    suiteForAppleEventCode(forAppleEventCode: number): string;
  }

  // interface
  class NSScriptWhoseTest extends NSObject /* implements NSCoding */ {
    isTrue(): boolean;
  }

  // export function NSSearchPathForDirectoriesInDomains(directory: FileManager.SearchPathDirectory, domainMask: FileManager.SearchPathDomainMask, expandTilde: boolean): string[];

  type NSSecureCoding = NSCoding

  // interface
  class NSSecureUnarchiveFromDataTransformer extends ValueTransformer {
    static allowedTopLevelClasses: typeof NSObject[];
  }

  // export function NSSelectorFromString(aSelectorName: string): string;

  // interface
  class NSSet<ObjectType> extends NSObject /* implements NSCopying, NSFastEnumeration, NSMutableCopying, NSSecureCoding */ {
    static setWithObjects<ObjectType>(_: ObjectType): NSSet<ObjectType>;
    allObjects: ObjectType[];
    count: number;
    anyObject(): ObjectType;
    containsObject(_: ObjectType): boolean;
    descriptionWithLocale(withLocale?: any): string;
    enumerateIndexPathsWithOptionsUsing(options: NSEnumerationOptions, using: (p1: NSIndexPath, p2: boolean) => void): void;
    enumerateObjects(_: (p1: ObjectType, p2: boolean) => void): void;
    enumerateObjectsWithOptionsUsing(options: NSEnumerationOptions, using: (p1: ObjectType, p2: boolean) => void): void;
    filteredSetUsingPredicate(using: NSPredicate): NSSet<ObjectType>;
    intersects(_: NSSet<ObjectType>): boolean;
    isEqualWithTo(to: NSSet<ObjectType>): boolean;
    isSubsetOf(of: NSSet<ObjectType>): boolean;
    member(_: ObjectType): ObjectType;
    objectEnumerator(): NSEnumerator<ObjectType>;
    objectsWithPassingTest(passingTest: (p1: ObjectType, p2: boolean) => boolean): NSSet<ObjectType>;
    objectsWithOptionsPassingTest(options: NSEnumerationOptions, passingTest: (p1: ObjectType, p2: boolean) => boolean): NSSet<ObjectType>;
    setByAddingObject(_: ObjectType): NSSet<ObjectType>;
    setByAddingObjectsFromArray(from: ObjectType[]): NSSet<ObjectType>;
    addingObjectsWithFrom(from: NSSet<ObjectType>): NSSet<ObjectType>;
    sortedArrayUsingDescriptors(using: NSSortDescriptor[]): ObjectType[];
  }

  // interface
  class NSSetCommand extends NSScriptCommand {
    keySpecifier: NSScriptObjectSpecifier;
    setReceiversSpecifier(_?: NSScriptObjectSpecifier): void;
  }

  // export function NSSetUncaughtExceptionHandler(p1: (p1: NSException) => void): void;

  // export function NSShouldRetainWithZone(anObject: any, requestedZone: any): boolean;

  // export function NSSizeFromString(aString: string): CGSize;

  // interface
  class SocketPort extends Port {
    address: NSData;
    protocol: number;
    protocolFamily: number;
    socket: number;
    socketType: number;
    static createWithRemoteWithProtocolFamilySocketTypeProtocolAddress(remoteWithProtocolFamily: number, socketType: number, protocol: number, address: NSData): SocketPort;
    static createWithRemoteWithTCPPortHost(remoteWithTCPPort: number, host?: string): SocketPort;
    static createWithProtocolFamilySocketTypeProtocolAddress(protocolFamily: number, socketType: number, protocol: number, address: NSData): SocketPort;
    static createWithProtocolFamilySocketTypeProtocolSocket(protocolFamily: number, socketType: number, protocol: number, socket: number): SocketPort;
    static createWithTCPPort(TCPPort: number): SocketPort;
  }

  // interface
  class NSSortDescriptor extends NSObject /* implements NSCopying, NSSecureCoding */ {
    ascending: boolean;
    comparator: (p1: any, p2: any) => ComparisonResult;
    key: string;
    reversedSortDescriptor: any;
    selector: string;
    allowEvaluation(): void;
    compareObjectToObject(_: any, to: any): ComparisonResult;
    static createWithKeyAscending(key?: string, ascending?: boolean): NSSortDescriptor;
    static createWithKeyAscendingComparator(key?: string, ascending?: boolean, comparator?: (p1: any, p2: any) => ComparisonResult): NSSortDescriptor;
    static createWithKeyAscendingSelector(key?: string, ascending?: boolean, selector?: string): NSSortDescriptor;
  }

  // interface
  class NSSpecifierTest extends NSScriptWhoseTest {
    static createWithObjectSpecifierComparisonOperatorTestObject(objectSpecifier?: NSScriptObjectSpecifier, comparisonOperator?: NSSpecifierTest.TestComparisonOperation, testObject?: any): NSSpecifierTest;
  }

  // interface
  class NSSpellServer extends NSObject {
    delegate: NSSpellServerDelegate;
    setDelegate(_: NSSpellServerDelegate)
    isWordInUserDictionariesCaseSensitive(inUserDictionaries: string, caseSensitive: boolean): boolean;
    registerLanguageByVendor(_?: string, byVendor?: string): boolean;
    run(): void;
  }

  interface NSSpellServerDelegate extends NSObject {
    // instance method
    spellServerFindMisspelledWordInStringLanguageWordCountCountOnly?(_: NSSpellServer, findMisspelledWordIn: string, language: string, wordCount: number, countOnly: boolean): NSRange;
    // instance method
    spellServerSuggestCompletionsForPartialWordRangeInStringLanguage?(_: NSSpellServer, suggestCompletionsForPartialWordRange: NSRange, in_: string, language: string): string[];
    // instance method
    spellServerCheckGrammarInStringLanguageDetails?(_: NSSpellServer, checkGrammarIn: string, language?: string, details?: Map<string, any>[]): NSRange;
    // instance method
    spellServerCheckStringOffsetTypesOptionsOrthographyWordCount?(_: NSSpellServer, check: string, offset: number, types: number, options?: Map<string, any>, orthography?: NSOrthography, wordCount?: number): NSTextCheckingResult[];
    // instance method
    spellServerDidForgetWordInLanguage?(_: NSSpellServer, didForgetWord: string, inLanguage: string): void;
    // instance method
    spellServerDidLearnWordInLanguage?(_: NSSpellServer, didLearnWord: string, inLanguage: string): void;
    // instance method
    spellServerRecordResponseToCorrectionForWordLanguage?(_: NSSpellServer, recordResponse: number, toCorrection: string, forWord: string, language: string): void;
    // instance method
    spellServerSuggestGuessesForWordInLanguage?(_: NSSpellServer, suggestGuessesForWord: string, inLanguage: string): string[];
  }

  // interface
  class Stream extends NSObject {
    static getBoundStreamsWithBufferSizeInputStreamOutputStream(_: number, inputStream?: InputStream, outputStream?: OutputStream): void;
    static getStreamsToHostWithNamePortInputStreamOutputStream(_: string, port: number, inputStream?: InputStream, outputStream?: OutputStream): void;
    delegate: StreamDelegate;
    setDelegate(_: StreamDelegate)
    streamError: NSError;
    streamStatus: Stream.Status;
    close(): void;
    open(): void;
    propertyForKey(_: string): any;
    removeFromRunLoopForMode(_: RunLoop, forMode: string): void;
    scheduleInRunLoopForMode(_: RunLoop, forMode: string): void;
    setPropertyForKey(_?: any, forKey?: string): boolean;
  }

  interface StreamDelegate extends NSObject {
    // instance method
    streamHandleEvent?(_: Stream, handleEvent: Stream.Event): void;
  }

  // interface
  class NSString extends NSObject /* implements NSCopying, NSMutableCopying, NSSecureCoding, NSItemProviderReading, NSItemProviderWriting, NSPasteboardReading, NSPasteboardWriting */ {
    static localizedNameOfStringEncoding(of: number): string;
    static pathWithComponents(withComponents: string[]): string;
    static stringEncodingForDataEncodingOptionsConvertedStringUsedLossyConversion(for_: NSData, encodingOptions?: Map<string, any>, convertedString?: string, usedLossyConversion?: boolean): number;
    static stringWithContentsOfFileEncodingError(encoding: string, error: number): NSString;
    static stringWithContentsOfFileUsedEncodingError(usedEncoding: string, error?: number): NSString;
    static stringWithContentsOfURLEncodingError(encoding: NSURL, error: number): NSString;
    static stringWithContentsOfURLUsedEncodingError(usedEncoding: NSURL, error?: number): NSString;
    UTF8String: string;
    isAbsolutePath: boolean;
    boolValue: boolean;
    capitalizedString: string;
    decomposedStringWithCanonicalMapping: string;
    decomposedStringWithCompatibilityMapping: string;
    doubleValue: number;
    fastestEncoding: number;
    fileSystemRepresentation: string;
    floatValue: number;
    intValue: number;
    integerValue: number;
    lastPathComponent: string;
    length: number;
    localizedCapitalizedString: string;
    localizedLowercaseString: string;
    localizedUppercaseString: string;
    longLongValue: number;
    lowercaseString: string;
    pathComponents: string[];
    pathExtension: string;
    precomposedStringWithCanonicalMapping: string;
    precomposedStringWithCompatibilityMapping: string;
    smallestEncoding: number;
    stringByAbbreviatingWithTildeInPath: string;
    stringByDeletingLastPathComponent: string;
    stringByDeletingPathExtension: string;
    stringByExpandingTildeInPath: string;
    stringByRemovingPercentEncoding: string;
    stringByResolvingSymlinksInPath: string;
    stringByStandardizingPath: string;
    uppercaseString: string;
    static availableStringEncodings: number;
    static defaultCStringEncoding: number;
    boundingRectWithSizeOptionsAttributes(with_: CGSize, options: NSString.DrawingOptions, attributes?: Map<string, any>): CGRect;
    boundingRectWithSizeOptionsAttributesContext(with_: CGSize, options: NSString.DrawingOptions, attributes?: Map<string, any>, context?: NSStringDrawingContext): CGRect;
    cStringUsingEncoding(using: number): string;
    canBeConvertedToEncoding(to: number): boolean;
    capitalizedStringWithLocale(with_?: NSLocale): string;
    caseInsensitiveCompare(_: string): ComparisonResult;
    characterAtIndex(at: number): string;
    commonPrefixWithStringOptions(with_: string, options: NSString.CompareOptions): string;
    compare(_: string): ComparisonResult;
    compareOptions(_: string, options: NSString.CompareOptions): ComparisonResult;
    compareOptionsRange(_: string, options: NSString.CompareOptions, range: NSRange): ComparisonResult;
    compareOptionsRangeLocale(_: string, options: NSString.CompareOptions, range: NSRange, locale?: any): ComparisonResult;
    completePathIntoStringCaseSensitiveMatchesIntoArrayFilterTypes(into?: string, caseSensitive?: boolean, matchesInto?: string[], filterTypes?: string[]): number;
    componentsSeparatedByCharactersInSet(separatedBy: NSCharacterSet): string[];
    componentsSeparatedByString(separatedBy: string): string[];
    containsString(_: string): boolean;
    dataUsingEncoding(using: number): NSData;
    dataUsingEncodingAllowLossyConversion(using: number, allowLossyConversion: boolean): NSData;
    drawAtPointWithAttributes(at: CGPoint, withAttributes?: Map<string, any>): void;
    drawInRectWithAttributes(in_: CGRect, withAttributes?: Map<string, any>): void;
    drawWithRectOptionsAttributes(with_: CGRect, options: NSString.DrawingOptions, attributes?: Map<string, any>): void;
    drawWithRectOptionsAttributesContext(with_: CGRect, options: NSString.DrawingOptions, attributes?: Map<string, any>, context?: NSStringDrawingContext): void;
    enumerateLines(_: (p1: string, p2: boolean) => void): void;
    enumerateLinguisticTagsWithInSchemeOptionsOrthographyUsing(in_: NSRange, scheme: string, options: NSLinguisticTagger.Options, orthography?: NSOrthography, using?: (p1: string, p2: NSRange, p3: NSRange, p4: boolean) => void): void;
    enumerateSubstringsWithInOptionsUsing(in_: NSRange, options: NSString.EnumerationOptions, using?: (p1: string, p2: NSRange, p3: NSRange, p4: boolean) => void): void;
    getBytesMaxLengthUsedLengthEncodingOptionsRangeRemainingRange(_?: any, maxLength?: number, usedLength?: number, encoding?: number, options?: NSString.EncodingConversionOptions, range?: NSRange, remaining?: NSRange): boolean;
    getCStringMaxLengthEncoding(_: string, maxLength: number, encoding: number): boolean;
    getCharacters(_: string): void;
    getCharactersRange(_: string, range: NSRange): void;
    getFileSystemRepresentationMaxLength(_: string, maxLength: number): boolean;
    getLineStartEndContentsEndForRange(_?: number, end?: number, contentsEnd?: number, for_?: NSRange): void;
    getParagraphStartEndContentsEndForRange(_?: number, end?: number, contentsEnd?: number, for_?: NSRange): void;
    hasPrefix(_: string): boolean;
    hasSuffix(_: string): boolean;
    static createWithBytesLengthEncoding(bytes: any, length: number, encoding: number): NSString;
    static createWithBytesNoCopyLengthEncodingFreeWhenDone(bytesNoCopy: any, length: number, encoding: number, freeWhenDone: boolean): NSString;
    static createWithCStringEncoding(CString: string, encoding: number): NSString;
    static createWithCharactersLength(characters: string, length: number): NSString;
    static createWithCharactersNoCopyLengthFreeWhenDone(charactersNoCopy: string, length: number, freeWhenDone: boolean): NSString;
    static createWithContentsOfFileEncoding(contentsOfFile: string, encoding: number): NSString;
    static createWithContentsOfFileUsedEncoding(contentsOfFile: string, usedEncoding?: number): NSString;
    static createWithContentsOfURLEncoding(contentsOfURL: NSURL, encoding: number): NSString;
    static createWithContentsOfURLUsedEncoding(contentsOfURL: NSURL, usedEncoding?: number): NSString;
    static createWithDataEncoding(data: NSData, encoding: number): NSString;
    static createWithString(string: string): NSString;
    static createWithUTF8String(UTF8String: string): NSString;
    isEqualToString(to: string): boolean;
    lengthOfBytesUsingEncoding(using: number): number;
    lineRangeForRange(for_: NSRange): NSRange;
    linguisticTagsInRangeSchemeOptionsOrthographyTokenRanges(in_: NSRange, scheme: string, options: NSLinguisticTagger.Options, orthography?: NSOrthography, tokenRanges?: NSValue[]): string[];
    localizedCaseInsensitiveCompare(_: string): ComparisonResult;
    localizedCaseInsensitiveContainsString(_: string): boolean;
    localizedCompare(_: string): ComparisonResult;
    localizedStandardCompare(_: string): ComparisonResult;
    localizedStandardContainsString(_: string): boolean;
    localizedStandardRangeOfString(of: string): NSRange;
    lowercaseStringWithLocale(with_?: NSLocale): string;
    maximumLengthOfBytesUsingEncoding(using: number): number;
    paragraphRangeForRange(for_: NSRange): NSRange;
    propertyList(): any;
    propertyListFromStringsFileFormat(): Map<any, any>;
    rangeOfCharacterFromSet(from: NSCharacterSet): NSRange;
    rangeOfCharacterFromSetOptions(from: NSCharacterSet, options: NSString.CompareOptions): NSRange;
    rangeOfCharacterFromSetOptionsRange(from: NSCharacterSet, options: NSString.CompareOptions, range: NSRange): NSRange;
    rangeOfComposedCharacterSequenceAtIndex(at: number): NSRange;
    rangeOfComposedCharacterSequencesForRange(for_: NSRange): NSRange;
    rangeOfString(of: string): NSRange;
    rangeOfStringOptions(of: string, options: NSString.CompareOptions): NSRange;
    rangeOfStringOptionsRange(of: string, options: NSString.CompareOptions, range: NSRange): NSRange;
    rangeOfStringOptionsRangeLocale(of: string, options: NSString.CompareOptions, range: NSRange, locale?: NSLocale): NSRange;
    sizeWithAttributes(withAttributes?: Map<string, any>): CGSize;
    stringByAddingPercentEncodingWithAllowedCharacters(withAllowedCharacters: NSCharacterSet): string;
    stringByAppendingPathComponent(_: string): string;
    stringByAppendingPathExtension(_: string): string;
    stringByAppendingString(_: string): string;
    stringByApplyingTransformReverse(_: string, reverse: boolean): string;
    stringByFoldingWithOptionsLocale(options: NSString.CompareOptions, locale?: NSLocale): string;
    stringByPaddingToLengthWithStringStartingAtIndex(toLength: number, withPad: string, startingAt: number): string;
    stringByReplacingCharactersInRangeWithString(in_: NSRange, with_: string): string;
    stringByReplacingOccurrencesOfStringWithString(of: string, with_: string): string;
    stringByReplacingOccurrencesOfStringWithStringOptionsRange(of: string, with_: string, options: NSString.CompareOptions, range: NSRange): string;
    stringByTrimmingCharactersInSet(in_: NSCharacterSet): string;
    stringsByAppendingPaths(byAppendingPaths: string[]): string[];
    substringFromIndex(from: number): string;
    substringToIndex(to: number): string;
    substringWithRange(with_: NSRange): string;
    uppercaseStringWithLocale(with_?: NSLocale): string;
    variantFittingPresentationWidth(_: number): string;
    writeToFileAtomicallyEncodingError(atomically: string, encoding: boolean, error: number): boolean;
    writeToURLAtomicallyEncodingError(atomically: NSURL, encoding: boolean, error: number): boolean;
  }

  // export function NSStringFromClass(aClass: typeof NSObject): string;

  // export function NSStringFromHashTable(table: NSHashTable<any>): string;

  // export function NSStringFromMapTable(table: NSMapTable<any, any>): string;

  // export function NSStringFromPoint(aPoint: CGPoint): string;

  // export function NSStringFromProtocol(proto: any /* Protocol */): string;

  // export function NSStringFromRange(range: NSRange): string;

  // export function NSStringFromRect(aRect: CGRect): string;

  // export function NSStringFromSelector(aSelector: string): string;

  // export function NSStringFromSize(aSize: CGSize): string;

  // interface
  class Process extends NSObject {
    static runArgumentsTerminationHandler(_: NSURL, _2: string[], arguments_?: Error, terminationHandler?: (p1: Process) => void): Process;
    static launchedTaskWithLaunchPathArguments(launchPath: string, arguments_: string[]): Process;
    arguments: string[];
    setArguments(_: string[])
    currentDirectoryPath: string;
    setCurrentDirectoryPath(_: string)
    currentDirectoryURL: NSURL;
    setCurrentDirectoryURL(_: NSURL)
    environment: Map<string, string>;
    setEnvironment(_: Map<string, string>)
    executableURL: NSURL;
    setExecutableURL(_: NSURL)
    launchPath: string;
    setLaunchPath(_: string)
    processIdentifier: number;
    qualityOfService: QualityOfService;
    setQualityOfService(_: QualityOfService)
    isRunning: boolean;
    standardError: any;
    setStandardError(_: any)
    standardInput: any;
    setStandardInput(_: any)
    standardOutput: any;
    setStandardOutput(_: any)
    terminationHandler: (p1: Process) => void;
    setTerminationHandler(_: (p1: Process) => void)
    terminationReason: Process.TerminationReason;
    terminationStatus: number;
    interrupt(): void;
    launch(): void;
    launchAndReturnError(): boolean;
    resume(): boolean;
    suspend(): boolean;
    terminate(): void;
    waitUntilExit(): void;
  }

  // export function NSTemporaryDirectory(): string;

  // interface
  class NSTextCheckingResult extends NSObject /* implements NSCopying, NSSecureCoding */ {
    static addressCheckingResultWithRangeComponents(range: NSRange, components: Map<string, string>): NSTextCheckingResult;
    static correctionCheckingResultWithRangeReplacementString(range: NSRange, replacementString: string): NSTextCheckingResult;
    static correctionCheckingResultWithRangeReplacementStringAlternativeStrings(range: NSRange, replacementString: string, alternativeStrings: string[]): NSTextCheckingResult;
    static dashCheckingResultWithRangeReplacementString(range: NSRange, replacementString: string): NSTextCheckingResult;
    static dateCheckingResultWithRangeDate(range: NSRange, date: Date): NSTextCheckingResult;
    static dateCheckingResultWithRangeDateTimeZoneDuration(range: NSRange, date: Date, timeZone: NSTimeZone, duration: number): NSTextCheckingResult;
    static grammarCheckingResultWithRangeDetails(range: NSRange, details: Map<string, any>[]): NSTextCheckingResult;
    static linkCheckingResultWithRangeUrl(range: NSRange, url: NSURL): NSTextCheckingResult;
    static orthographyCheckingResultWithRangeOrthography(range: NSRange, orthography: NSOrthography): NSTextCheckingResult;
    static phoneNumberCheckingResultWithRangePhoneNumber(range: NSRange, phoneNumber: string): NSTextCheckingResult;
    static quoteCheckingResultWithRangeReplacementString(range: NSRange, replacementString: string): NSTextCheckingResult;
    static regularExpressionCheckingResultWithRangesCountRegularExpression(ranges: NSRange, count: number, regularExpression: NSRegularExpression): NSTextCheckingResult;
    static replacementCheckingResultWithRangeReplacementString(range: NSRange, replacementString: string): NSTextCheckingResult;
    static spellCheckingResultWithRange(range: NSRange): NSTextCheckingResult;
    static transitInformationCheckingResultWithRangeComponents(range: NSRange, components: Map<string, string>): NSTextCheckingResult;
    URL: NSURL;
    addressComponents: Map<string, string>;
    alternativeStrings: string[];
    components: Map<string, string>;
    date: Date;
    duration: number;
    grammarDetails: Map<string, any>[];
    numberOfRanges: number;
    orthography: NSOrthography;
    phoneNumber: string;
    range: NSRange;
    regularExpression: NSRegularExpression;
    replacementString: string;
    resultType: NSTextCheckingResult.CheckingType;
    timeZone: NSTimeZone;
    rangeAtIndex(at: number): NSRange;
    rangeWithName(withName: string): NSRange;
    resultByAdjustingRangesWithOffset(offset: number): NSTextCheckingResult;
  }

  // interface
  class Thread extends NSObject {
    static detachNewThreadSelectorToTargetWithObject(_: string, toTarget: any, withObject?: any): void;
    static detachNewThreadWithBlock(_: () => void): void;
    static exit(): void;
    static isMultiThreaded(): boolean;
    static setThreadPriority(_: number): boolean;
    static sleepForTimeInterval(_: number): void;
    static sleepUntilDate(_: Date): void;
    static threadPriority(): number;
    isCancelled: boolean;
    isExecuting: boolean;
    isFinished: boolean;
    name: string;
    setName(_: string)
    qualityOfService: QualityOfService;
    setQualityOfService(_: QualityOfService)
    stackSize: number;
    setStackSize(_: number)
    threadDictionary: NSMutableDictionary<any, any>;
    threadPriority: number;
    setThreadPriority(_: number)
    static callStackReturnAddresses: number[];
    static callStackSymbols: string[];
    static currentThread: Thread;
    static isMainThread: boolean;
    static mainThread: Thread;
    cancel(): void;
    static createWithBlock(block: () => void): Thread;
    static createWithTargetSelectorObject(target: any, selector: string, object_?: any): Thread;
    main(): void;
    start(): void;
  }

  // interface
  class NSTimeZone extends NSObject /* implements NSCopying, NSSecureCoding */ {
    static resetSystemTimeZone(): void;
    abbreviation: string;
    data: NSData;
    isDaylightSavingTime: boolean;
    daylightSavingTimeOffset: number;
    name: string;
    nextDaylightSavingTimeTransition: Date;
    secondsFromGMT: number;
    static abbreviationDictionary: Map<string, string>;
    setAbbreviationDictionary(_: Map<string, string>)
    static defaultTimeZone: NSTimeZone;
    setDefaultTimeZone(_: NSTimeZone)
    static knownTimeZoneNames: string[];
    static localTimeZone: NSTimeZone;
    static systemTimeZone: NSTimeZone;
    static timeZoneDataVersion: string;
    abbreviationForDate(for_: Date): string;
    daylightSavingTimeOffsetForDate(for_: Date): number;
    static createWithName(name: string): NSTimeZone;
    static createWithNameData(name: string, data?: NSData): NSTimeZone;
    isDaylightSavingTimeForDate(for_: Date): boolean;
    isEqualToTimeZone(to: NSTimeZone): boolean;
    localizedNameLocale(_: NSTimeZone.NameStyle, locale?: NSLocale): string;
    nextDaylightSavingTimeTransitionAfterDate(after: Date): Date;
    secondsFromGMTForDate(for_: Date): number;
  }

  // interface
  class Timer extends NSObject {
    static scheduledTimerWithTimeIntervalWithRepeatsBlock(_: number, repeats: boolean, block: (p1: Timer) => void): Timer;
    static scheduledTimerWithTimeIntervalTargetSelectorUserInfoRepeats(timeInterval: number, target: any, selector: string, userInfo?: any, repeats?: boolean): Timer;
    fireDate: Date;
    setFireDate(_: Date)
    timeInterval: number;
    tolerance: number;
    setTolerance(_: number)
    userInfo: any;
    isValid: boolean;
    fire(): void;
    static createWithFireDateIntervalRepeatsBlock(fireDate: Date, interval: number, repeats: boolean, block: (p1: Timer) => void): Timer;
    static createWithFireDateIntervalTargetSelectorUserInfoRepeats(fireDate: Date, interval: number, target: any, selector: string, userInfo?: any, repeats?: boolean): Timer;
    invalidate(): void;
  }

  // interface
  class NSURL extends NSObject /* implements NSCopying, NSSecureCoding, NSItemProviderReading, NSItemProviderWriting, NSPasteboardReading, NSPasteboardWriting, QLPreviewItem */ {
    static URLByResolvingAliasFileAtURLOptionsError(resolvingAliasFileAt: NSURL, options: NSURL.BookmarkResolutionOptions): NSURL;
    static URLByResolvingBookmarkDataOptionsRelativeToURLBookmarkDataIsStaleError(options: NSData, relativeToURL: NSURL.BookmarkResolutionOptions, bookmarkDataIsStale?: NSURL, error?: boolean): NSURL;
    static absoluteURLWithDataRepresentationRelativeToURL(withDataRepresentation: NSData, relativeTo?: NSURL): NSURL;
    static bookmarkDataWithContentsOfURLError(error: NSURL): NSData;
    static fileURLWithFileSystemRepresentationIsDirectoryRelativeToURL(withFileSystemRepresentation: string, isDirectory: boolean, relativeTo?: NSURL): NSURL;
    static fileURLWithPath(withPath: string): NSURL;
    static fileURLWithPathIsDirectory(withPath: string, isDirectory: boolean): NSURL;
    static fileURLWithPathIsDirectoryRelativeToURL(withPath: string, isDirectory: boolean, relativeTo?: NSURL): NSURL;
    static fileURLWithPathRelativeToURL(withPath: string, relativeTo?: NSURL): NSURL;
    static fileURLWithPathComponents(withPathComponents: string[]): NSURL;
    static resourceValuesForKeysFromBookmarkData(forKeys: string[], fromBookmarkData: NSData): Map<string, any>;
    static writeBookmarkDataToURLOptionsError(toURL: NSData, options: NSURL, error: number): boolean;
    URLByDeletingLastPathComponent: NSURL;
    URLByDeletingPathExtension: NSURL;
    URLByResolvingSymlinksInPath: NSURL;
    URLByStandardizingPath: NSURL;
    absoluteString: string;
    absoluteURL: NSURL;
    baseURL: NSURL;
    dataRepresentation: NSData;
    filePathURL: NSURL;
    fileSystemRepresentation: string;
    isFileURL: boolean;
    fragment: string;
    hasDirectoryPath: boolean;
    host: string;
    lastPathComponent: string;
    password: string;
    path: string;
    pathComponents: string[];
    pathExtension: string;
    port: number;
    query: string;
    relativePath: string;
    relativeString: string;
    resourceSpecifier: string;
    scheme: string;
    standardizedURL: NSURL;
    user: string;
    URLByAppendingPathComponent(_: string): NSURL;
    URLByAppendingPathComponentIsDirectory(_: string, isDirectory: boolean): NSURL;
    URLByAppendingPathExtension(_: string): NSURL;
    bookmarkDataWithOptionsIncludingResourceValuesForKeysRelativeToURLError(includingResourceValuesForKeys: NSURL.BookmarkCreationOptions, relativeToURL?: string[], error?: NSURL): NSData;
    checkPromisedItemIsReachableAndReturnError(): boolean;
    checkResourceIsReachableAndReturnError(): boolean;
    fileReferenceURL(): NSURL;
    getFileSystemRepresentationMaxLength(_: string, maxLength: number): boolean;
    getPromisedItemResourceValueForKeyError(forKey?: any, error?: string): boolean;
    getResourceValueForKeyError(forKey?: any, error?: string): boolean;
    static createWithAbsoluteURLWithDataRepresentationRelativeToURL(absoluteURLWithDataRepresentation: NSData, relativeToURL?: NSURL): NSURL;
    static createWithByResolvingBookmarkDataOptionsRelativeToURLBookmarkDataIsStale(byResolvingBookmarkData: NSData, options: NSURL.BookmarkResolutionOptions, relativeToURL?: NSURL, bookmarkDataIsStale?: boolean): NSURL;
    static createWithFileURLWithFileSystemRepresentationIsDirectoryRelativeToURL(fileURLWithFileSystemRepresentation: string, isDirectory: boolean, relativeToURL?: NSURL): NSURL;
    static createWithFileURLWithPath(fileURLWithPath: string): NSURL;
    static createWithFileURLWithPathIsDirectory(fileURLWithPath: string, isDirectory: boolean): NSURL;
    static createWithFileURLWithPathIsDirectoryRelativeToURL(fileURLWithPath: string, isDirectory: boolean, relativeToURL?: NSURL): NSURL;
    static createWithFileURLWithPathRelativeToURL(fileURLWithPath: string, relativeToURL?: NSURL): NSURL;
    static createWithDataRepresentationRelativeToURL(dataRepresentation: NSData, relativeToURL?: NSURL): NSURL;
    static createWithString(string: string): NSURL;
    static createWithStringRelativeToURL(string: string, relativeToURL?: NSURL): NSURL;
    isFileReferenceURL(): boolean;
    promisedItemResourceValuesForKeysError(error: string[]): Map<string, any>;
    removeAllCachedResourceValues(): void;
    removeCachedResourceValueForKey(forKey: string): void;
    resourceValuesForKeysError(error: string[]): Map<string, any>;
    setResourceValueForKeyError(forKey?: any, error?: string): boolean;
    setResourceValuesError(error: Map<string, any>): boolean;
    setTemporaryResourceValueForKey(_?: any, forKey?: string): void;
    startAccessingSecurityScopedResource(): boolean;
    stopAccessingSecurityScopedResource(): void;
    writeToPasteboard(to: NSPasteboard): void;
  }

  // interface
  class URLAuthenticationChallenge extends NSObject /* implements NSSecureCoding */ {
    error: NSError;
    failureResponse: URLResponse;
    previousFailureCount: number;
    proposedCredential: URLCredential;
    protectionSpace: URLProtectionSpace;
    sender: URLAuthenticationChallengeSender;
    static createWithAuthenticationChallengeSender(authenticationChallenge: URLAuthenticationChallenge, sender: URLAuthenticationChallengeSender): URLAuthenticationChallenge;
    static createWithProtectionSpaceProposedCredentialPreviousFailureCountFailureResponseErrorSender(protectionSpace: URLProtectionSpace, proposedCredential?: URLCredential, previousFailureCount?: number, failureResponse?: URLResponse, error?: NSError, sender?: URLAuthenticationChallengeSender): URLAuthenticationChallenge;
  }

  interface URLAuthenticationChallengeSender extends NSObject {
    // instance method
    cancelAuthenticationChallenge(_: URLAuthenticationChallenge): void;
    // instance method
    continueWithoutCredentialForAuthenticationChallenge(_: URLAuthenticationChallenge): void;
    // instance method
    performDefaultHandlingForAuthenticationChallenge?(_: URLAuthenticationChallenge): void;
    // instance method
    rejectProtectionSpaceAndContinueWithChallenge?(_: URLAuthenticationChallenge): void;
    // instance method
    useCredentialForAuthenticationChallenge(_: URLCredential, forAuthenticationChallenge: URLAuthenticationChallenge): void;
  }

  // interface
  class URLCache extends NSObject {
    currentDiskUsage: number;
    currentMemoryUsage: number;
    diskCapacity: number;
    setDiskCapacity(_: number)
    memoryCapacity: number;
    setMemoryCapacity(_: number)
    static sharedURLCache: URLCache;
    setSharedURLCache(_: URLCache)
    cachedResponseForRequest(_: NSURLRequest): CachedURLResponse;
    getCachedResponseForDataTaskWithCompletionHandler(_: URLSessionDataTask, completionHandler?: (p1: CachedURLResponse) => void): void;
    static createWithMemoryCapacityDiskCapacityDirectoryURL(memoryCapacity: number, diskCapacity: number, directoryURL?: NSURL): URLCache;
    static createWithMemoryCapacityDiskCapacityDiskPath(memoryCapacity: number, diskCapacity: number, diskPath?: string): URLCache;
    removeAllCachedResponses(): void;
    removeCachedResponseForDataTask(_: URLSessionDataTask): void;
    removeCachedResponseForRequest(_: NSURLRequest): void;
    removeCachedResponsesSinceDate(_: Date): void;
    storeCachedResponseForDataTask(_: CachedURLResponse, forDataTask: URLSessionDataTask): void;
    storeCachedResponseForRequest(_: CachedURLResponse, forRequest: NSURLRequest): void;
  }

  // interface
  class NSURLComponents extends NSObject /* implements NSCopying */ {
    static componentsWithString(string: string): NSURLComponents;
    static componentsWithURLResolvingAgainstBaseURL(url: NSURL, resolvingAgainstBaseURL: boolean): NSURLComponents;
    URL: NSURL;
    fragment: string;
    setFragment(_: string)
    host: string;
    setHost(_: string)
    password: string;
    setPassword(_: string)
    path: string;
    setPath(_: string)
    percentEncodedFragment: string;
    setPercentEncodedFragment(_: string)
    percentEncodedHost: string;
    setPercentEncodedHost(_: string)
    percentEncodedPassword: string;
    setPercentEncodedPassword(_: string)
    percentEncodedPath: string;
    setPercentEncodedPath(_: string)
    percentEncodedQuery: string;
    setPercentEncodedQuery(_: string)
    percentEncodedQueryItems: NSURLQueryItem[];
    setPercentEncodedQueryItems(_: NSURLQueryItem[])
    percentEncodedUser: string;
    setPercentEncodedUser(_: string)
    port: number;
    setPort(_: number)
    query: string;
    setQuery(_: string)
    queryItems: NSURLQueryItem[];
    setQueryItems(_: NSURLQueryItem[])
    rangeOfFragment: NSRange;
    rangeOfHost: NSRange;
    rangeOfPassword: NSRange;
    rangeOfPath: NSRange;
    rangeOfPort: NSRange;
    rangeOfQuery: NSRange;
    rangeOfScheme: NSRange;
    rangeOfUser: NSRange;
    scheme: string;
    setScheme(_: string)
    string: string;
    user: string;
    setUser(_: string)
    URLRelativeToURL(relativeTo?: NSURL): NSURL;
    static createWithString(string: string): NSURLComponents;
    static createWithUrlResolvingAgainstBaseURL(URL: NSURL, resolvingAgainstBaseURL: boolean): NSURLComponents;
  }

  // interface
  class NSURLConnection extends NSObject {
    static canHandleRequest(_: NSURLRequest): boolean;
    currentRequest: NSURLRequest;
    originalRequest: NSURLRequest;
    cancel(): void;
    scheduleInRunLoopForMode(in_: RunLoop, forMode: string): void;
    setDelegateQueue(_?: OperationQueue): void;
    start(): void;
    unscheduleFromRunLoopForMode(from: RunLoop, forMode: string): void;
  }

  interface NSURLConnectionDataDelegate extends NSURLConnectionDelegate {
    // instance method
    connectionWillSendRequestRedirectResponse?(_: NSURLConnection, willSend: NSURLRequest, redirectResponse?: URLResponse): NSURLRequest;
    // instance method
    connectionDidReceiveResponse?(_: NSURLConnection, didReceive: URLResponse): void;
    // instance method
    connectionDidReceiveData?(_: NSURLConnection, didReceive: NSData): void;
    // instance method
    connectionDidSendBodyDataTotalBytesWrittenTotalBytesExpectedToWrite?(_: NSURLConnection, didSendBodyData: number, totalBytesWritten: number, totalBytesExpectedToWrite: number): void;
    // instance method
    connectionNeedNewBodyStream?(_: NSURLConnection, needNewBodyStream: NSURLRequest): InputStream;
    // instance method
    connectionWillCacheResponse?(_: NSURLConnection, willCacheResponse: CachedURLResponse): CachedURLResponse;
    // instance method
    connectionDidFinishLoading?(_: NSURLConnection): void;
  }

  interface NSURLConnectionDelegate extends NSObject {
    // instance method
    connectionWillSendRequestForAuthenticationChallenge?(_: NSURLConnection, willSendRequestFor: URLAuthenticationChallenge): void;
    // instance method
    connectionDidFailWithError?(_: NSURLConnection, didFailWithError: NSError): void;
    // instance method
    connectionShouldUseCredentialStorage?(_: NSURLConnection): boolean;
  }

  interface NSURLConnectionDownloadDelegate extends NSURLConnectionDelegate {
    // instance method
    connectionDidWriteDataTotalBytesWrittenExpectedTotalBytes?(_: NSURLConnection, didWriteData: number, totalBytesWritten: number, expectedTotalBytes: number): void;
    // instance method
    connectionDidFinishDownloadingDestinationURL(_: NSURLConnection, destinationURL: NSURL): void;
    // instance method
    connectionDidResumeDownloadingTotalBytesWrittenExpectedTotalBytes?(_: NSURLConnection, totalBytesWritten: number, expectedTotalBytes: number): void;
  }

  // interface
  class URLCredential extends NSObject /* implements NSCopying, NSSecureCoding */ {
    certificates: any[];
    hasPassword: boolean;
    identity: any;
    password: string;
    persistence: URLCredential.Persistence;
    user: string;
    static createWithIdentityCertificatesPersistence(identity: any, certificates?: any[], persistence?: URLCredential.Persistence): URLCredential;
    static createWithTrust(trust: any): URLCredential;
    static createWithUserPasswordPersistence(user: string, password: string, persistence: URLCredential.Persistence): URLCredential;
  }

  // interface
  class URLCredentialStorage extends NSObject {
    allCredentials: Map<URLProtectionSpace, Map<string, URLCredential>>;
    static sharedCredentialStorage: URLCredentialStorage;
    credentialsForProtectionSpace(_: URLProtectionSpace): Map<string, URLCredential>;
    defaultCredentialForProtectionSpace(_: URLProtectionSpace): URLCredential;
    getCredentialsForTaskCompletionHandler(for_: URLProtectionSpace, task: URLSessionTask, completionHandler?: (p1: Map<string, URLCredential>) => void): void;
    getDefaultCredentialForProtectionSpaceWithTaskCompletionHandler(_: URLProtectionSpace, task: URLSessionTask, completionHandler?: (p1: URLCredential) => void): void;
    removeCredentialForProtectionSpace(_: URLCredential, forProtectionSpace: URLProtectionSpace): void;
    removeCredentialForProtectionSpaceOptions(_: URLCredential, forProtectionSpace: URLProtectionSpace, options?: Map<string, any>): void;
    removeCredentialForProtectionSpaceOptionsTask(_: URLCredential, forProtectionSpace: URLProtectionSpace, options?: Map<string, any>, task?: URLSessionTask): void;
    setCredentialForProtectionSpace(_: URLCredential, for_: URLProtectionSpace): void;
    setCredentialForProtectionSpaceTask(_: URLCredential, for_: URLProtectionSpace, task: URLSessionTask): void;
    setDefaultCredentialForProtectionSpace(_: URLCredential, forProtectionSpace: URLProtectionSpace): void;
    setDefaultCredentialForProtectionSpaceTask(_: URLCredential, forProtectionSpace: URLProtectionSpace, task: URLSessionTask): void;
  }

  // interface
  class NSURLDownload extends NSObject {
    static canResumeDownloadDecodedWithEncodingMIMEType(withEncodingMIMEType: string): boolean;
    deletesFileUponFailure: boolean;
    setDeletesFileUponFailure(_: boolean)
    request: NSURLRequest;
    resumeData: NSData;
    cancel(): void;
    setDestinationAllowOverwrite(_: string, allowOverwrite: boolean): void;
  }

  interface NSURLDownloadDelegate extends NSObject {
    // instance method
    downloadWillSendRequestRedirectResponse?(_: NSURLDownload, willSend: NSURLRequest, redirectResponse?: URLResponse): NSURLRequest;
    // instance method
    downloadDidReceiveAuthenticationChallenge?(_: NSURLDownload, didReceive: URLAuthenticationChallenge): void;
    // instance method
    downloadDidCancelAuthenticationChallenge?(_: NSURLDownload, didCancel: URLAuthenticationChallenge): void;
    // instance method
    downloadDidReceiveResponse?(_: NSURLDownload, didReceive: URLResponse): void;
    // instance method
    downloadWillResumeWithResponseFromByte?(_: NSURLDownload, willResumeWith: URLResponse, fromByte: number): void;
    // instance method
    downloadCanAuthenticateAgainstProtectionSpace?(_: NSURLDownload, canAuthenticateAgainstProtectionSpace: URLProtectionSpace): boolean;
    // instance method
    downloadDecideDestinationWithSuggestedFilename?(_: NSURLDownload, decideDestinationWithSuggestedFilename: string): void;
    // instance method
    downloadDidCreateDestination?(_: NSURLDownload, didCreateDestination: string): void;
    // instance method
    downloadDidFailWithError?(_: NSURLDownload, didFailWithError: NSError): void;
    // instance method
    downloadDidReceiveDataOfLength?(_: NSURLDownload, didReceiveDataOfLength: number): void;
    // instance method
    downloadShouldDecodeSourceDataOfMIMEType?(_: NSURLDownload, shouldDecodeSourceDataOfMIMEType: string): boolean;
    // instance method
    downloadDidBegin?(_: NSURLDownload): void;
    // instance method
    downloadDidFinish?(_: NSURLDownload): void;
    // instance method
    downloadShouldUseCredentialStorage?(_: NSURLDownload): boolean;
  }

  // interface
  class NSURLHandle extends NSObject {
  }

  // interface
  class URLProtectionSpace extends NSObject /* implements NSCopying, NSSecureCoding */ {
    authenticationMethod: string;
    distinguishedNames: NSData[];
    host: string;
    isProxy: boolean;
    port: number;
    protocol: string;
    proxyType: string;
    realm: string;
    receivesCredentialSecurely: boolean;
    serverTrust: any;
    static createWithHostPortProtocolRealmAuthenticationMethod(host: string, port: number, protocol?: string, realm?: string, authenticationMethod?: string): URLProtectionSpace;
    static createWithProxyHostPortTypeRealmAuthenticationMethod(proxyHost: string, port: number, type?: string, realm?: string, authenticationMethod?: string): URLProtectionSpace;
  }

  // interface
  class URLProtocol extends NSObject {
    static canInitWithRequest(_: NSURLRequest): boolean;
    static canInitWithTask(_: URLSessionTask): boolean;
    static canonicalRequestForRequest(_: NSURLRequest): NSURLRequest;
    static propertyForKeyInRequest(_: string, inRequest: NSURLRequest): any;
    static registerClass(_: typeof NSObject): boolean;
    static removePropertyForKeyInRequest(_: string, inRequest: NSMutableURLRequest): void;
    static requestIsCacheEquivalentToRequest(_: NSURLRequest, toRequest: NSURLRequest): boolean;
    static setPropertyForKeyInRequest(_: any, forKey: string, inRequest: NSMutableURLRequest): void;
    static unregisterClass(_: typeof NSObject): void;
    cachedResponse: CachedURLResponse;
    client: URLProtocolClient;
    request: NSURLRequest;
    task: URLSessionTask;
    static createWithRequestCachedResponseClient(request: NSURLRequest, cachedResponse?: CachedURLResponse, client?: URLProtocolClient): URLProtocol;
    static createWithTaskCachedResponseClient(task: URLSessionTask, cachedResponse?: CachedURLResponse, client?: URLProtocolClient): URLProtocol;
    startLoading(): void;
    stopLoading(): void;
  }

  interface URLProtocolClient extends NSObject {
    // instance method
    URLProtocolCachedResponseIsValid(_: URLProtocol, cachedResponseIsValid: CachedURLResponse): void;
    // instance method
    URLProtocolDidCancelAuthenticationChallenge(_: URLProtocol, didCancelAuthenticationChallenge: URLAuthenticationChallenge): void;
    // instance method
    URLProtocolDidFailWithError(_: URLProtocol, didFailWithError: NSError): void;
    // instance method
    URLProtocolDidLoadData(_: URLProtocol, didLoadData: NSData): void;
    // instance method
    URLProtocolDidReceiveAuthenticationChallenge(_: URLProtocol, didReceiveAuthenticationChallenge: URLAuthenticationChallenge): void;
    // instance method
    URLProtocolDidReceiveResponseCacheStoragePolicy(_: URLProtocol, didReceiveResponse: URLResponse, cacheStoragePolicy: URLCache.StoragePolicy): void;
    // instance method
    URLProtocolWasRedirectedToRequestRedirectResponse(_: URLProtocol, wasRedirectedToRequest: NSURLRequest, redirectResponse: URLResponse): void;
    // instance method
    URLProtocolDidFinishLoading(_: URLProtocol): void;
  }

  // interface
  class NSURLQueryItem extends NSObject /* implements NSCopying, NSSecureCoding */ {
    static queryItemWithNameValue(name: string, value?: string): NSURLQueryItem;
    name: string;
    value: string;
    static createWithNameValue(name: string, value?: string): NSURLQueryItem;
  }

  // interface
  class NSURLRequest extends NSObject /* implements NSCopying, NSMutableCopying, NSSecureCoding */ {
    HTTPBody: NSData;
    HTTPBodyStream: InputStream;
    HTTPMethod: string;
    HTTPShouldHandleCookies: boolean;
    HTTPShouldUsePipelining: boolean;
    URL: NSURL;
    allHTTPHeaderFields: Map<string, string>;
    allowsCellularAccess: boolean;
    allowsConstrainedNetworkAccess: boolean;
    allowsExpensiveNetworkAccess: boolean;
    cachePolicy: NSURLRequest.CachePolicy;
    mainDocumentURL: NSURL;
    networkServiceType: NSURLRequest.NetworkServiceType;
    timeoutInterval: number;
    static createWithUrl(URL: NSURL): NSURLRequest;
    static createWithUrlCachePolicyTimeoutInterval(URL: NSURL, cachePolicy: NSURLRequest.CachePolicy, timeoutInterval: number): NSURLRequest;
    valueForHTTPHeaderField(forHTTPHeaderField: string): string;
  }

  // interface
  class URLResponse extends NSObject /* implements NSCopying, NSSecureCoding */ {
    MIMEType: string;
    URL: NSURL;
    expectedContentLength: number;
    suggestedFilename: string;
    textEncodingName: string;
    static createWithUrlMIMETypeExpectedContentLengthTextEncodingName(URL: NSURL, MIMEType?: string, expectedContentLength?: number, textEncodingName?: string): URLResponse;
  }

  // interface
  class URLSession extends NSObject {
    configuration: URLSessionConfiguration;
    delegate: URLSessionDelegate;
    delegateQueue: OperationQueue;
    sessionDescription: string;
    setSessionDescription(_: string)
    static sharedSession: URLSession;
    dataTaskWithRequest(_: NSURLRequest): URLSessionDataTask;
    dataTaskWithRequestWithCompletionHandler(_: NSURLRequest, completionHandler?: (p1: NSData, p2: URLResponse, p3: NSError) => void): URLSessionDataTask;
    dataTaskWithURL(_: NSURL): URLSessionDataTask;
    dataTaskWithURLWithCompletionHandler(_: NSURL, completionHandler?: (p1: NSData, p2: URLResponse, p3: NSError) => void): URLSessionDataTask;
    downloadTaskWithRequest(_: NSURLRequest): URLSessionDownloadTask;
    downloadTaskWithRequestWithCompletionHandler(_: NSURLRequest, completionHandler?: (p1: NSURL, p2: URLResponse, p3: NSError) => void): URLSessionDownloadTask;
    downloadTaskWithResumeData(_: NSData): URLSessionDownloadTask;
    downloadTaskWithResumeDataWithCompletionHandler(_: NSData, completionHandler?: (p1: NSURL, p2: URLResponse, p3: NSError) => void): URLSessionDownloadTask;
    downloadTaskWithURL(_: NSURL): URLSessionDownloadTask;
    downloadTaskWithURLWithCompletionHandler(_: NSURL, completionHandler?: (p1: NSURL, p2: URLResponse, p3: NSError) => void): URLSessionDownloadTask;
    finishTasksAndInvalidate(): void;
    flushWithCompletionHandler(_: () => void): void;
    getAllTasksWithCompletionHandler(_: (p1: URLSessionTask[]) => void): void;
    getTasksWithCompletionHandler(_: (p1: URLSessionDataTask[], p2: URLSessionUploadTask[], p3: URLSessionDownloadTask[]) => void): void;
    invalidateAndCancel(): void;
    resetWithCompletionHandler(_: () => void): void;
    streamTaskWithHostNamePort(_: string, port: number): URLSessionStreamTask;
    streamTaskWithNetService(_: NetService): URLSessionStreamTask;
    uploadTaskWithRequestFromData(_: NSURLRequest, fromData: NSData): URLSessionUploadTask;
    uploadTaskWithRequestWithFromDataCompletionHandler(_: NSURLRequest, fromData?: NSData, completionHandler?: (p1: NSData, p2: URLResponse, p3: NSError) => void): URLSessionUploadTask;
    uploadTaskWithRequestFromFile(_: NSURLRequest, fromFile: NSURL): URLSessionUploadTask;
    uploadTaskWithRequestWithFromFileCompletionHandler(_: NSURLRequest, fromFile: NSURL, completionHandler?: (p1: NSData, p2: URLResponse, p3: NSError) => void): URLSessionUploadTask;
    uploadTaskWithStreamedRequest(_: NSURLRequest): URLSessionUploadTask;
    webSocketTaskWithRequest(_: NSURLRequest): URLSessionWebSocketTask;
    webSocketTaskWithURL(_: NSURL): URLSessionWebSocketTask;
    webSocketTaskWithURLProtocols(_: NSURL, protocols: string[]): URLSessionWebSocketTask;
  }

  // interface
  class URLSessionConfiguration extends NSObject /* implements NSCopying */ {
    static backgroundSessionConfigurationWithIdentifier(withIdentifier: string): URLSessionConfiguration;
    HTTPAdditionalHeaders: Map<any, any>;
    setHTTPAdditionalHeaders(_: Map<any, any>)
    HTTPCookieAcceptPolicy: HTTPCookie.AcceptPolicy;
    setHTTPCookieAcceptPolicy(_: HTTPCookie.AcceptPolicy)
    HTTPCookieStorage: HTTPCookieStorage;
    setHTTPCookieStorage(_: HTTPCookieStorage)
    HTTPMaximumConnectionsPerHost: number;
    setHTTPMaximumConnectionsPerHost(_: number)
    HTTPShouldSetCookies: boolean;
    setHTTPShouldSetCookies(_: boolean)
    HTTPShouldUsePipelining: boolean;
    setHTTPShouldUsePipelining(_: boolean)
    TLSMaximumSupportedProtocol: SSLProtocol;
    setTLSMaximumSupportedProtocol(_: SSLProtocol)
    TLSMaximumSupportedProtocolVersion: tls_protocol_version_t;
    setTLSMaximumSupportedProtocolVersion(_: tls_protocol_version_t)
    TLSMinimumSupportedProtocol: SSLProtocol;
    setTLSMinimumSupportedProtocol(_: SSLProtocol)
    TLSMinimumSupportedProtocolVersion: tls_protocol_version_t;
    setTLSMinimumSupportedProtocolVersion(_: tls_protocol_version_t)
    URLCache: URLCache;
    setURLCache(_: URLCache)
    URLCredentialStorage: URLCredentialStorage;
    setURLCredentialStorage(_: URLCredentialStorage)
    allowsCellularAccess: boolean;
    setAllowsCellularAccess(_: boolean)
    allowsConstrainedNetworkAccess: boolean;
    setAllowsConstrainedNetworkAccess(_: boolean)
    allowsExpensiveNetworkAccess: boolean;
    setAllowsExpensiveNetworkAccess(_: boolean)
    connectionProxyDictionary: Map<any, any>;
    setConnectionProxyDictionary(_: Map<any, any>)
    isDiscretionary: boolean;
    setDiscretionary(_: boolean)
    identifier: string;
    networkServiceType: NSURLRequest.NetworkServiceType;
    setNetworkServiceType(_: NSURLRequest.NetworkServiceType)
    protocolClasses: typeof NSObject[];
    setProtocolClasses(_: typeof NSObject[])
    requestCachePolicy: NSURLRequest.CachePolicy;
    setRequestCachePolicy(_: NSURLRequest.CachePolicy)
    sharedContainerIdentifier: string;
    setSharedContainerIdentifier(_: string)
    shouldUseExtendedBackgroundIdleMode: boolean;
    setShouldUseExtendedBackgroundIdleMode(_: boolean)
    timeoutIntervalForRequest: number;
    setTimeoutIntervalForRequest(_: number)
    timeoutIntervalForResource: number;
    setTimeoutIntervalForResource(_: number)
    waitsForConnectivity: boolean;
    setWaitsForConnectivity(_: boolean)
    static defaultSessionConfiguration: URLSessionConfiguration;
    static ephemeralSessionConfiguration: URLSessionConfiguration;
  }

  interface URLSessionDataDelegate extends URLSessionTaskDelegate {
    // instance method
    URLSessionDataTaskDidBecomeDownloadTask?(_: URLSession, dataTask: URLSessionDataTask, didBecomeDownloadTask: URLSessionDownloadTask): void;
    // instance method
    URLSessionDataTaskDidBecomeStreamTask?(_: URLSession, dataTask: URLSessionDataTask, didBecomeStreamTask: URLSessionStreamTask): void;
    // instance method
    URLSessionDataTaskDidReceiveData?(_: URLSession, dataTask: URLSessionDataTask, didReceiveData: NSData): void;
    // instance method
    URLSessionWithDataTaskDidReceiveResponseCompletionHandler?(_: URLSession, dataTask: URLSessionDataTask, didReceiveResponse: URLResponse, completionHandler: (p1: URLSession.ResponseDisposition) => void): void;
    // instance method
    URLSessionWithDataTaskWillCacheResponseCompletionHandler?(_: URLSession, dataTask: URLSessionDataTask, willCacheResponse: CachedURLResponse, completionHandler?: (p1: CachedURLResponse) => void): void;
  }

  // interface
  class URLSessionDataTask extends URLSessionTask {
  }

  interface URLSessionDelegate extends NSObject {
    // instance method
    URLSessionDidBecomeInvalidWithError?(_: URLSession, didBecomeInvalidWithError?: NSError): void;
    // instance method
    URLSessionWithDidReceiveChallengeCompletionHandler?(_: URLSession, didReceiveChallenge: URLAuthenticationChallenge, completionHandler?: (p1: URLSession.AuthChallengeDisposition, p2: URLCredential) => void): void;
  }

  interface URLSessionDownloadDelegate extends URLSessionTaskDelegate {
    // instance method
    URLSessionDownloadTaskDidFinishDownloadingToURL(_: URLSession, downloadTask: URLSessionDownloadTask, didFinishDownloadingToURL: NSURL): void;
    // instance method
    URLSessionDownloadTaskDidResumeAtOffsetExpectedTotalBytes?(_: URLSession, downloadTask: URLSessionDownloadTask, didResumeAtOffset: number, expectedTotalBytes: number): void;
    // instance method
    URLSessionDownloadTaskDidWriteDataTotalBytesWrittenTotalBytesExpectedToWrite?(_: URLSession, downloadTask: URLSessionDownloadTask, didWriteData: number, totalBytesWritten: number, totalBytesExpectedToWrite: number): void;
  }

  // interface
  class URLSessionDownloadTask extends URLSessionTask {
    cancelByProducingResumeData(_?: (p1: NSData) => void): void;
  }

  interface URLSessionStreamDelegate extends URLSessionTaskDelegate {
    // instance method
    URLSessionBetterRouteDiscoveredForStreamTask?(_: URLSession, betterRouteDiscoveredForStreamTask: URLSessionStreamTask): void;
    // instance method
    URLSessionReadClosedForStreamTask?(_: URLSession, readClosedForStreamTask: URLSessionStreamTask): void;
    // instance method
    URLSessionStreamTaskDidBecomeInputStreamOutputStream?(_: URLSession, streamTask: URLSessionStreamTask, didBecomeInputStream: InputStream, outputStream: OutputStream): void;
    // instance method
    URLSessionWriteClosedForStreamTask?(_: URLSession, writeClosedForStreamTask: URLSessionStreamTask): void;
  }

  // interface
  class URLSessionStreamTask extends URLSessionTask {
    captureStreams(): void;
    closeRead(): void;
    closeWrite(): void;
    readDataOfMinLengthWithMaxLengthTimeoutCompletionHandler(_: number, maxLength: number, timeout: number, completionHandler?: (p1: NSData, p2: boolean, p3: NSError) => void): void;
    startSecureConnection(): void;
    writeDataWithTimeoutCompletionHandler(_: NSData, timeout: number, completionHandler?: (p1: NSError) => void): void;
  }

  // interface
  class URLSessionTask extends NSObject /* implements NSCopying, ProgressReporting */ {
    countOfBytesClientExpectsToReceive: number;
    setCountOfBytesClientExpectsToReceive(_: number)
    countOfBytesClientExpectsToSend: number;
    setCountOfBytesClientExpectsToSend(_: number)
    countOfBytesExpectedToReceive: number;
    countOfBytesExpectedToSend: number;
    countOfBytesReceived: number;
    countOfBytesSent: number;
    currentRequest: NSURLRequest;
    earliestBeginDate: Date;
    setEarliestBeginDate(_: Date)
    error: NSError;
    originalRequest: NSURLRequest;
    priority: number;
    setPriority(_: number)
    response: URLResponse;
    state: URLSessionTask.State;
    taskDescription: string;
    setTaskDescription(_: string)
    taskIdentifier: number;
    cancel(): void;
    resume(): void;
    suspend(): void;
  }

  interface URLSessionTaskDelegate extends URLSessionDelegate {
    // instance method
    URLSessionTaskDidCompleteWithError?(_: URLSession, task: URLSessionTask, didCompleteWithError?: NSError): void;
    // instance method
    URLSessionTaskDidFinishCollectingMetrics?(_: URLSession, task: URLSessionTask, didFinishCollectingMetrics: URLSessionTaskMetrics): void;
    // instance method
    URLSessionWithTaskDidReceiveChallengeCompletionHandler?(_: URLSession, task: URLSessionTask, didReceiveChallenge: URLAuthenticationChallenge, completionHandler?: (p1: URLSession.AuthChallengeDisposition, p2: URLCredential) => void): void;
    // instance method
    URLSessionTaskDidSendBodyDataTotalBytesSentTotalBytesExpectedToSend?(_: URLSession, task: URLSessionTask, didSendBodyData: number, totalBytesSent: number, totalBytesExpectedToSend: number): void;
    // instance method
    URLSessionWithTaskNeedNewBodyStream?(_: URLSession, task: URLSessionTask, needNewBodyStream?: (p1: InputStream) => void): void;
    // instance method
    URLSessionWithTaskWillBeginDelayedRequestCompletionHandler?(_: URLSession, task: URLSessionTask, willBeginDelayedRequest: NSURLRequest, completionHandler?: (p1: NSURLSessionDelayedRequestDisposition, p2: NSURLRequest) => void): void;
    // instance method
    URLSessionWithTaskWillPerformHTTPRedirectionNewRequestCompletionHandler?(_: URLSession, task: URLSessionTask, willPerformHTTPRedirection: HTTPURLResponse, newRequest: NSURLRequest, completionHandler?: (p1: NSURLRequest) => void): void;
    // instance method
    URLSessionTaskIsWaitingForConnectivity?(_: URLSession, taskIsWaitingForConnectivity: URLSessionTask): void;
  }

  // interface
  class URLSessionTaskMetrics extends NSObject {
    redirectCount: number;
    taskInterval: NSDateInterval;
    transactionMetrics: URLSessionTaskTransactionMetrics[];
  }

  // interface
  class URLSessionTaskTransactionMetrics extends NSObject {
    isCellular: boolean;
    connectEndDate: Date;
    connectStartDate: Date;
    isConstrained: boolean;
    countOfRequestBodyBytesBeforeEncoding: number;
    countOfRequestBodyBytesSent: number;
    countOfRequestHeaderBytesSent: number;
    countOfResponseBodyBytesAfterDecoding: number;
    countOfResponseBodyBytesReceived: number;
    countOfResponseHeaderBytesReceived: number;
    domainLookupEndDate: Date;
    domainLookupStartDate: Date;
    isExpensive: boolean;
    fetchStartDate: Date;
    localAddress: string;
    localPort: number;
    isMultipath: boolean;
    negotiatedTLSCipherSuite: number;
    negotiatedTLSProtocolVersion: number;
    networkProtocolName: string;
    isProxyConnection: boolean;
    remoteAddress: string;
    remotePort: number;
    request: NSURLRequest;
    requestEndDate: Date;
    requestStartDate: Date;
    resourceFetchType: URLSessionTaskMetrics.ResourceFetchType;
    response: URLResponse;
    responseEndDate: Date;
    responseStartDate: Date;
    isReusedConnection: boolean;
    secureConnectionEndDate: Date;
    secureConnectionStartDate: Date;
  }

  // interface
  class URLSessionUploadTask extends URLSessionDataTask {
  }

  interface URLSessionWebSocketDelegate extends URLSessionTaskDelegate {
    // instance method
    URLSessionWebSocketTaskDidCloseWithCodeReason?(_: URLSession, webSocketTask: URLSessionWebSocketTask, didCloseWithCode: URLSessionWebSocketTask.CloseCode, reason?: NSData): void;
    // instance method
    URLSessionWebSocketTaskDidOpenWithProtocol?(_: URLSession, webSocketTask: URLSessionWebSocketTask, didOpenWithProtocol?: string): void;
  }

  // interface
  class NSURLSessionWebSocketMessage extends NSObject {
    data: NSData;
    string: string;
    type: NSURLSessionWebSocketMessageType;
    static createWithData(data: NSData): NSURLSessionWebSocketMessage;
    static createWithString(string: string): NSURLSessionWebSocketMessage;
  }

  // interface
  class URLSessionWebSocketTask extends URLSessionTask {
    closeCode: URLSessionWebSocketTask.CloseCode;
    closeReason: NSData;
    maximumMessageSize: number;
    setMaximumMessageSize(_: number)
    cancelWithCloseCodeReason(_: URLSessionWebSocketTask.CloseCode, reason?: NSData): void;
    receiveMessageWithCompletionHandler(_?: (p1: NSURLSessionWebSocketMessage, p2: NSError) => void): void;
    sendMessageWithCompletionHandler(_: NSURLSessionWebSocketMessage, completionHandler?: (p1: NSError) => void): void;
    sendPingWithPongReceiveHandler(_?: (p1: NSError) => void): void;
  }

  // interface
  class NSUUID extends NSObject /* implements NSCopying, NSSecureCoding */ {
    UUIDString: string;
    getUUIDBytes(_: number): void;
    static createWithUUIDBytes(UUIDBytes?: number): NSUUID;
    static createWithUUIDString(UUIDString: string): NSUUID;
  }

  // interface
  class NSUbiquitousKeyValueStore extends NSObject {
    dictionaryRepresentation: Map<string, any>;
    static defaultStore: NSUbiquitousKeyValueStore;
    arrayForKey(forKey: string): any[];
    boolForKey(forKey: string): boolean;
    dataForKey(forKey: string): NSData;
    dictionaryForKey(forKey: string): Map<string, any>;
    doubleForKey(forKey: string): number;
    longLongForKey(forKey: string): number;
    objectForKey(forKey: string): any;
    removeObjectForKey(forKey: string): void;
    setArrayForKey(_?: any[], forKey?: string): void;
    setBoolForKey(_: boolean, forKey: string): void;
    setDataForKey(_?: NSData, forKey?: string): void;
    setDictionaryForKey(_?: Map<string, any>, forKey?: string): void;
    setDoubleForKey(_: number, forKey: string): void;
    setLongLongForKey(_: number, forKey: string): void;
    setObjectForKey(_?: any, forKey?: string): void;
    setStringForKey(_?: string, forKey?: string): void;
    stringForKey(forKey: string): string;
    synchronize(): boolean;
  }

  // interface
  class UndoManager extends NSObject {
    canRedo: boolean;
    canUndo: boolean;
    groupingLevel: number;
    groupsByEvent: boolean;
    setGroupsByEvent(_: boolean)
    levelsOfUndo: number;
    setLevelsOfUndo(_: number)
    redoActionIsDiscardable: boolean;
    redoActionName: string;
    redoMenuItemTitle: string;
    isRedoing: boolean;
    runLoopModes: string[];
    setRunLoopModes(_: string[])
    undoActionIsDiscardable: boolean;
    undoActionName: string;
    undoMenuItemTitle: string;
    isUndoRegistrationEnabled: boolean;
    isUndoing: boolean;
    beginUndoGrouping(): void;
    disableUndoRegistration(): void;
    enableUndoRegistration(): void;
    endUndoGrouping(): void;
    prepareWithInvocationTarget(_: any): any;
    redo(): void;
    redoMenuTitleForUndoActionName(_: string): string;
    registerUndoWithTargetSelectorObject(_: any, selector: string, object_?: any): void;
    removeAllActions(): void;
    removeAllActionsWithTarget(_: any): void;
    setActionIsDiscardable(_: boolean): void;
    setActionName(_: string): void;
    undo(): void;
    undoMenuTitleForUndoActionName(_: string): string;
    undoNestedGroup(): void;
  }

  // export function NSUnionRange(range1: NSRange, range2: NSRange): NSRange;

  // export function NSUnionRect(aRect: CGRect, bRect: CGRect): CGRect;

  // interface
  class NSUniqueIDSpecifier extends NSScriptObjectSpecifier {
    uniqueID: any;
    setUniqueID(_: any)
    static createWithContainerClassDescriptionContainerSpecifierKeyUniqueID(containerClassDescription: NSScriptClassDescription, containerSpecifier?: NSScriptObjectSpecifier, key?: string, uniqueID?: any): NSUniqueIDSpecifier;
  }

  // interface
  class Unit extends NSObject /* implements NSCopying, NSSecureCoding */ {
    symbol: string;
    static createWithSymbol(symbol: string): Unit;
  }

  // interface
  class UnitAcceleration extends Dimension /* implements NSSecureCoding */ {
    static gravity: UnitAcceleration;
    static metersPerSecondSquared: UnitAcceleration;
  }

  // interface
  class UnitAngle extends Dimension /* implements NSSecureCoding */ {
    static arcMinutes: UnitAngle;
    static arcSeconds: UnitAngle;
    static degrees: UnitAngle;
    static gradians: UnitAngle;
    static radians: UnitAngle;
    static revolutions: UnitAngle;
  }

  // interface
  class UnitArea extends Dimension /* implements NSSecureCoding */ {
    static acres: UnitArea;
    static ares: UnitArea;
    static hectares: UnitArea;
    static squareCentimeters: UnitArea;
    static squareFeet: UnitArea;
    static squareInches: UnitArea;
    static squareKilometers: UnitArea;
    static squareMegameters: UnitArea;
    static squareMeters: UnitArea;
    static squareMicrometers: UnitArea;
    static squareMiles: UnitArea;
    static squareMillimeters: UnitArea;
    static squareNanometers: UnitArea;
    static squareYards: UnitArea;
  }

  // interface
  class UnitConcentrationMass extends Dimension /* implements NSSecureCoding */ {
    static millimolesPerLiterWithGramsPerMole(_: number): UnitConcentrationMass;
    static gramsPerLiter: UnitConcentrationMass;
    static milligramsPerDeciliter: UnitConcentrationMass;
  }

  // interface
  class UnitConverter extends NSObject {
    baseUnitValueFromValue(_: number): number;
    valueFromBaseUnitValue(_: number): number;
  }

  // interface
  class UnitConverterLinear extends UnitConverter /* implements NSSecureCoding */ {
    coefficient: number;
    constant: number;
    static createWithCoefficient(coefficient: number): UnitConverterLinear;
    static createWithCoefficientConstant(coefficient: number, constant: number): UnitConverterLinear;
  }

  // interface
  class UnitDispersion extends Dimension /* implements NSSecureCoding */ {
    static partsPerMillion: UnitDispersion;
  }

  // interface
  class UnitDuration extends Dimension /* implements NSSecureCoding */ {
    static hours: UnitDuration;
    static microseconds: UnitDuration;
    static milliseconds: UnitDuration;
    static minutes: UnitDuration;
    static nanoseconds: UnitDuration;
    static picoseconds: UnitDuration;
    static seconds: UnitDuration;
  }

  // interface
  class UnitElectricCharge extends Dimension /* implements NSSecureCoding */ {
    static ampereHours: UnitElectricCharge;
    static coulombs: UnitElectricCharge;
    static kiloampereHours: UnitElectricCharge;
    static megaampereHours: UnitElectricCharge;
    static microampereHours: UnitElectricCharge;
    static milliampereHours: UnitElectricCharge;
  }

  // interface
  class UnitElectricCurrent extends Dimension /* implements NSSecureCoding */ {
    static amperes: UnitElectricCurrent;
    static kiloamperes: UnitElectricCurrent;
    static megaamperes: UnitElectricCurrent;
    static microamperes: UnitElectricCurrent;
    static milliamperes: UnitElectricCurrent;
  }

  // interface
  class UnitElectricPotentialDifference extends Dimension /* implements NSSecureCoding */ {
    static kilovolts: UnitElectricPotentialDifference;
    static megavolts: UnitElectricPotentialDifference;
    static microvolts: UnitElectricPotentialDifference;
    static millivolts: UnitElectricPotentialDifference;
    static volts: UnitElectricPotentialDifference;
  }

  // interface
  class UnitElectricResistance extends Dimension /* implements NSSecureCoding */ {
    static kiloohms: UnitElectricResistance;
    static megaohms: UnitElectricResistance;
    static microohms: UnitElectricResistance;
    static milliohms: UnitElectricResistance;
    static ohms: UnitElectricResistance;
  }

  // interface
  class UnitEnergy extends Dimension /* implements NSSecureCoding */ {
    static calories: UnitEnergy;
    static joules: UnitEnergy;
    static kilocalories: UnitEnergy;
    static kilojoules: UnitEnergy;
    static kilowattHours: UnitEnergy;
  }

  // interface
  class UnitFrequency extends Dimension /* implements NSSecureCoding */ {
    static framesPerSecond: UnitFrequency;
    static gigahertz: UnitFrequency;
    static hertz: UnitFrequency;
    static kilohertz: UnitFrequency;
    static megahertz: UnitFrequency;
    static microhertz: UnitFrequency;
    static millihertz: UnitFrequency;
    static nanohertz: UnitFrequency;
    static terahertz: UnitFrequency;
  }

  // interface
  class UnitFuelEfficiency extends Dimension /* implements NSSecureCoding */ {
    static litersPer100Kilometers: UnitFuelEfficiency;
    static milesPerGallon: UnitFuelEfficiency;
    static milesPerImperialGallon: UnitFuelEfficiency;
  }

  // interface
  class UnitIlluminance extends Dimension /* implements NSSecureCoding */ {
    static lux: UnitIlluminance;
  }

  // interface
  class NSUnitInformationStorage extends Dimension /* implements NSSecureCoding */ {
    static bits: NSUnitInformationStorage;
    static bytes: NSUnitInformationStorage;
    static exabits: NSUnitInformationStorage;
    static exabytes: NSUnitInformationStorage;
    static exbibits: NSUnitInformationStorage;
    static exbibytes: NSUnitInformationStorage;
    static gibibits: NSUnitInformationStorage;
    static gibibytes: NSUnitInformationStorage;
    static gigabits: NSUnitInformationStorage;
    static gigabytes: NSUnitInformationStorage;
    static kibibits: NSUnitInformationStorage;
    static kibibytes: NSUnitInformationStorage;
    static kilobits: NSUnitInformationStorage;
    static kilobytes: NSUnitInformationStorage;
    static mebibits: NSUnitInformationStorage;
    static mebibytes: NSUnitInformationStorage;
    static megabits: NSUnitInformationStorage;
    static megabytes: NSUnitInformationStorage;
    static nibbles: NSUnitInformationStorage;
    static pebibits: NSUnitInformationStorage;
    static pebibytes: NSUnitInformationStorage;
    static petabits: NSUnitInformationStorage;
    static petabytes: NSUnitInformationStorage;
    static tebibits: NSUnitInformationStorage;
    static tebibytes: NSUnitInformationStorage;
    static terabits: NSUnitInformationStorage;
    static terabytes: NSUnitInformationStorage;
    static yobibits: NSUnitInformationStorage;
    static yobibytes: NSUnitInformationStorage;
    static yottabits: NSUnitInformationStorage;
    static yottabytes: NSUnitInformationStorage;
    static zebibits: NSUnitInformationStorage;
    static zebibytes: NSUnitInformationStorage;
    static zettabits: NSUnitInformationStorage;
    static zettabytes: NSUnitInformationStorage;
  }

  // interface
  class UnitLength extends Dimension /* implements NSSecureCoding */ {
    static astronomicalUnits: UnitLength;
    static centimeters: UnitLength;
    static decameters: UnitLength;
    static decimeters: UnitLength;
    static fathoms: UnitLength;
    static feet: UnitLength;
    static furlongs: UnitLength;
    static hectometers: UnitLength;
    static inches: UnitLength;
    static kilometers: UnitLength;
    static lightyears: UnitLength;
    static megameters: UnitLength;
    static meters: UnitLength;
    static micrometers: UnitLength;
    static miles: UnitLength;
    static millimeters: UnitLength;
    static nanometers: UnitLength;
    static nauticalMiles: UnitLength;
    static parsecs: UnitLength;
    static picometers: UnitLength;
    static scandinavianMiles: UnitLength;
    static yards: UnitLength;
  }

  // interface
  class UnitMass extends Dimension /* implements NSSecureCoding */ {
    static carats: UnitMass;
    static centigrams: UnitMass;
    static decigrams: UnitMass;
    static grams: UnitMass;
    static kilograms: UnitMass;
    static metricTons: UnitMass;
    static micrograms: UnitMass;
    static milligrams: UnitMass;
    static nanograms: UnitMass;
    static ounces: UnitMass;
    static ouncesTroy: UnitMass;
    static picograms: UnitMass;
    static poundsMass: UnitMass;
    static shortTons: UnitMass;
    static slugs: UnitMass;
    static stones: UnitMass;
  }

  // interface
  class UnitPower extends Dimension /* implements NSSecureCoding */ {
    static femtowatts: UnitPower;
    static gigawatts: UnitPower;
    static horsepower: UnitPower;
    static kilowatts: UnitPower;
    static megawatts: UnitPower;
    static microwatts: UnitPower;
    static milliwatts: UnitPower;
    static nanowatts: UnitPower;
    static picowatts: UnitPower;
    static terawatts: UnitPower;
    static watts: UnitPower;
  }

  // interface
  class UnitPressure extends Dimension /* implements NSSecureCoding */ {
    static bars: UnitPressure;
    static gigapascals: UnitPressure;
    static hectopascals: UnitPressure;
    static inchesOfMercury: UnitPressure;
    static kilopascals: UnitPressure;
    static megapascals: UnitPressure;
    static millibars: UnitPressure;
    static millimetersOfMercury: UnitPressure;
    static newtonsPerMetersSquared: UnitPressure;
    static poundsForcePerSquareInch: UnitPressure;
  }

  // interface
  class UnitSpeed extends Dimension /* implements NSSecureCoding */ {
    static kilometersPerHour: UnitSpeed;
    static knots: UnitSpeed;
    static metersPerSecond: UnitSpeed;
    static milesPerHour: UnitSpeed;
  }

  // interface
  class UnitTemperature extends Dimension /* implements NSSecureCoding */ {
    static celsius: UnitTemperature;
    static fahrenheit: UnitTemperature;
    static kelvin: UnitTemperature;
  }

  // interface
  class UnitVolume extends Dimension /* implements NSSecureCoding */ {
    static acreFeet: UnitVolume;
    static bushels: UnitVolume;
    static centiliters: UnitVolume;
    static cubicCentimeters: UnitVolume;
    static cubicDecimeters: UnitVolume;
    static cubicFeet: UnitVolume;
    static cubicInches: UnitVolume;
    static cubicKilometers: UnitVolume;
    static cubicMeters: UnitVolume;
    static cubicMiles: UnitVolume;
    static cubicMillimeters: UnitVolume;
    static cubicYards: UnitVolume;
    static cups: UnitVolume;
    static deciliters: UnitVolume;
    static fluidOunces: UnitVolume;
    static gallons: UnitVolume;
    static imperialFluidOunces: UnitVolume;
    static imperialGallons: UnitVolume;
    static imperialPints: UnitVolume;
    static imperialQuarts: UnitVolume;
    static imperialTablespoons: UnitVolume;
    static imperialTeaspoons: UnitVolume;
    static kiloliters: UnitVolume;
    static liters: UnitVolume;
    static megaliters: UnitVolume;
    static metricCups: UnitVolume;
    static milliliters: UnitVolume;
    static pints: UnitVolume;
    static quarts: UnitVolume;
    static tablespoons: UnitVolume;
    static teaspoons: UnitVolume;
  }

  // interface
  class NSUserActivity extends NSObject {
    activityType: string;
    delegate: NSUserActivityDelegate;
    setDelegate(_: NSUserActivityDelegate)
    detectedBarcodeDescriptor: CIBarcodeDescriptor;
    isEligibleForHandoff: boolean;
    setEligibleForHandoff(_: boolean)
    isEligibleForPublicIndexing: boolean;
    setEligibleForPublicIndexing(_: boolean)
    isEligibleForSearch: boolean;
    setEligibleForSearch(_: boolean)
    expirationDate: Date;
    setExpirationDate(_: Date)
    keywords: NSSet<string>;
    setKeywords(_: NSSet<string>)
    needsSave: boolean;
    setNeedsSave(_: boolean)
    referrerURL: NSURL;
    setReferrerURL(_: NSURL)
    requiredUserInfoKeys: NSSet<string>;
    setRequiredUserInfoKeys(_: NSSet<string>)
    supportsContinuationStreams: boolean;
    setSupportsContinuationStreams(_: boolean)
    targetContentIdentifier: string;
    setTargetContentIdentifier(_: string)
    title: string;
    setTitle(_: string)
    userInfo: Map<any, any>;
    setUserInfo(_: Map<any, any>)
    webpageURL: NSURL;
    setWebpageURL(_: NSURL)
    addUserInfoEntriesFromDictionary(from: Map<any, any>): void;
    becomeCurrent(): void;
    getContinuationStreamsWithCompletionHandler(completionHandler?: (p1: InputStream, p2: OutputStream, p3: NSError) => void): void;
    static createWithActivityType(activityType: string): NSUserActivity;
    invalidate(): void;
    resignCurrent(): void;
  }

  interface NSUserActivityDelegate extends NSObject {
    // instance method
    userActivityDidReceiveInputStreamOutputStream?(_: NSUserActivity, didReceive: InputStream, outputStream: OutputStream): void;
    // instance method
    userActivityWasContinued?(_: NSUserActivity): void;
    // instance method
    userActivityWillSave?(_: NSUserActivity): void;
  }

  // interface
  class NSUserAppleScriptTask extends NSUserScriptTask {
    executeWithWithAppleEventCompletionHandler(withAppleEvent?: NSAppleEventDescriptor, completionHandler?: (p1: NSAppleEventDescriptor, p2: NSError) => void): void;
  }

  // interface
  class NSUserAutomatorTask extends NSUserScriptTask {
    variables: Map<string, any>;
    setVariables(_: Map<string, any>)
    executeWithWithInputCompletionHandler(withInput?: NSSecureCoding, completionHandler?: (p1: any, p2: NSError) => void): void;
  }

  // interface
  class UserDefaults extends NSObject {
    static resetStandardUserDefaults(): void;
    volatileDomainNames: string[];
    static standardUserDefaults: UserDefaults;
    URLForKey(_: string): NSURL;
    addSuiteNamed(named: string): void;
    arrayForKey(_: string): any[];
    boolForKey(_: string): boolean;
    dataForKey(_: string): NSData;
    dictionaryForKey(_: string): Map<string, any>;
    dictionaryRepresentation(): Map<string, any>;
    doubleForKey(_: string): number;
    floatForKey(_: string): number;
    static createWithSuiteName(suiteName?: string): UserDefaults;
    integerForKey(_: string): number;
    objectForKey(_: string): any;
    objectIsForcedForKey(_: string): boolean;
    objectIsForcedForKeyInDomain(_: string, inDomain: string): boolean;
    persistentDomainForName(_: string): Map<string, any>;
    registerDefaults(defaults: Map<string, any>): void;
    removeObjectForKey(_: string): void;
    removePersistentDomainForName(_: string): void;
    removeSuiteNamed(named: string): void;
    removeVolatileDomainForName(_: string): void;
    setBoolForKey(_: boolean, forKey: string): void;
    setDoubleForKey(_: number, forKey: string): void;
    setFloatForKey(_: number, forKey: string): void;
    setIntegerForKey(_: number, forKey: string): void;
    setObjectForKey(_?: any, forKey?: string): void;
    setPersistentDomainForName(_: Map<string, any>, forName: string): void;
    setURLForKey(_?: NSURL, forKey?: string): void;
    setVolatileDomainForName(_: Map<string, any>, forName: string): void;
    stringArrayForKey(_: string): string[];
    stringForKey(_: string): string;
    synchronize(): boolean;
    volatileDomainForName(_: string): Map<string, any>;
  }

  // export function NSUserName(): string;

  // interface
  class NSUserNotification extends NSObject /* implements NSCopying */ {
    actionButtonTitle: string;
    setActionButtonTitle(_: string)
    activationType: NSUserNotification.ActivationType;
    actualDeliveryDate: Date;
    additionalActions: NSUserNotificationAction[];
    setAdditionalActions(_: NSUserNotificationAction[])
    additionalActivationAction: NSUserNotificationAction;
    contentImage: NSImage;
    setContentImage(_: NSImage)
    deliveryDate: Date;
    setDeliveryDate(_: Date)
    deliveryRepeatInterval: NSDateComponents;
    setDeliveryRepeatInterval(_: NSDateComponents)
    deliveryTimeZone: NSTimeZone;
    setDeliveryTimeZone(_: NSTimeZone)
    hasActionButton: boolean;
    setHasActionButton(_: boolean)
    hasReplyButton: boolean;
    setHasReplyButton(_: boolean)
    identifier: string;
    setIdentifier(_: string)
    informativeText: string;
    setInformativeText(_: string)
    otherButtonTitle: string;
    setOtherButtonTitle(_: string)
    isPresented: boolean;
    isRemote: boolean;
    response: NSAttributedString;
    responsePlaceholder: string;
    setResponsePlaceholder(_: string)
    soundName: string;
    setSoundName(_: string)
    subtitle: string;
    setSubtitle(_: string)
    title: string;
    setTitle(_: string)
    userInfo: Map<string, any>;
    setUserInfo(_: Map<string, any>)
  }

  // interface
  class NSUserNotificationAction extends NSObject /* implements NSCopying */ {
    static actionWithIdentifierTitle(identifier?: string, title?: string): NSUserNotificationAction;
    identifier: string;
    title: string;
  }

  // interface
  class NSUserNotificationCenter extends NSObject {
    delegate: NSUserNotificationCenterDelegate;
    setDelegate(_: NSUserNotificationCenterDelegate)
    deliveredNotifications: NSUserNotification[];
    scheduledNotifications: NSUserNotification[];
    setScheduledNotifications(_: NSUserNotification[])
    static defaultUserNotificationCenter: NSUserNotificationCenter;
    deliverNotification(_: NSUserNotification): void;
    removeAllDeliveredNotifications(): void;
    removeDeliveredNotification(_: NSUserNotification): void;
    removeScheduledNotification(_: NSUserNotification): void;
    scheduleNotification(_: NSUserNotification): void;
  }

  interface NSUserNotificationCenterDelegate extends NSObject {
    // instance method
    userNotificationCenterDidDeliverNotification?(_: NSUserNotificationCenter, didDeliver: NSUserNotification): void;
    // instance method
    userNotificationCenterDidActivateNotification?(_: NSUserNotificationCenter, didActivate: NSUserNotification): void;
    // instance method
    userNotificationCenterShouldPresentNotification?(_: NSUserNotificationCenter, shouldPresent: NSUserNotification): boolean;
  }

  // interface
  class NSUserScriptTask extends NSObject {
    scriptURL: NSURL;
    executeWithCompletionHandler(completionHandler?: (p1: NSError) => void): void;
    static createWithUrl(URL: NSURL): NSUserScriptTask;
  }

  // interface
  class NSUserUnixTask extends NSUserScriptTask {
    standardError: FileHandle;
    setStandardError(_: FileHandle)
    standardInput: FileHandle;
    setStandardInput(_: FileHandle)
    standardOutput: FileHandle;
    setStandardOutput(_: FileHandle)
    executeWithWithArgumentsCompletionHandler(withArguments?: string[], completionHandler?: (p1: NSError) => void): void;
  }

  // interface
  class NSValue extends NSObject /* implements NSCopying, NSSecureCoding */ {
    static valueWithCMTime(time: CMTime): NSValue;
    static valueWithCMTimeMapping(timeMapping: CMTimeMapping): NSValue;
    static valueWithCMTimeRange(timeRange: CMTimeRange): NSValue;
    CATransform3DValue: CATransform3D;
    CMTimeMappingValue: CMTimeMapping;
    CMTimeRangeValue: CMTimeRange;
    CMTimeValue: CMTime;
    edgeInsetsValue: NSEdgeInsets;
    nonretainedObjectValue: any;
    objCType: string;
    pointValue: CGPoint;
    pointerValue: any;
    rangeValue: NSRange;
    rectValue: CGRect;
    sizeValue: CGSize;
    getValue(_: any): void;
    getValueSize(_: any, size: number): void;
    static createWithBytesObjCType(bytes: any, objCType: string): NSValue;
    isEqualToValue(to: NSValue): boolean;
  }

  // interface
  class ValueTransformer extends NSObject {
    static allowsReverseTransformation(): boolean;
    static setValueTransformerForName(_?: ValueTransformer, forName?: string): void;
    static transformedValueClass(): typeof NSObject;
    static valueTransformerNames(): string[];
    reverseTransformedValue(_?: any): any;
    transformedValue(_?: any): any;
  }

  // interface
  class NSWhoseSpecifier extends NSScriptObjectSpecifier {
    endSubelementIdentifier: NSWhoseSpecifier.SubelementIdentifier;
    setEndSubelementIdentifier(_: NSWhoseSpecifier.SubelementIdentifier)
    endSubelementIndex: number;
    setEndSubelementIndex(_: number)
    startSubelementIdentifier: NSWhoseSpecifier.SubelementIdentifier;
    setStartSubelementIdentifier(_: NSWhoseSpecifier.SubelementIdentifier)
    startSubelementIndex: number;
    setStartSubelementIndex(_: number)
    test: NSScriptWhoseTest;
    setTest(_: NSScriptWhoseTest)
    static createWithContainerClassDescriptionContainerSpecifierKeyTest(containerClassDescription: NSScriptClassDescription, containerSpecifier?: NSScriptObjectSpecifier, key?: string, test?: NSScriptWhoseTest): NSWhoseSpecifier;
  }

  // interface
  class XMLDTD extends XMLNode {
    static predefinedEntityDeclarationForName(_: string): XMLDTDNode;
    publicID: string;
    setPublicID(_: string)
    systemID: string;
    setSystemID(_: string)
    addChild(_: XMLNode): void;
    attributeDeclarationForNameElementName(_: string, elementName: string): XMLDTDNode;
    elementDeclarationForName(_: string): XMLDTDNode;
    entityDeclarationForName(_: string): XMLDTDNode;
    static createWithContentsOfURLOptions(contentsOfURL: NSURL, options: XMLNode.Options): XMLDTD;
    static createWithDataOptions(data: NSData, options: XMLNode.Options): XMLDTD;
    insertChildAtIndex(_: XMLNode, atIndex: number): void;
    insertChildrenAtIndex(_: XMLNode[], atIndex: number): void;
    notationDeclarationForName(_: string): XMLDTDNode;
    removeChildAtIndex(_: number): void;
    replaceChildAtIndexWithNode(_: number, withNode: XMLNode): void;
    setChildren(_?: XMLNode[]): void;
  }

  // interface
  class XMLDTDNode extends XMLNode {
    DTDKind: XMLDTDNode.DTDKind;
    setDTDKind(_: XMLDTDNode.DTDKind)
    isExternal: boolean;
    notationName: string;
    setNotationName(_: string)
    publicID: string;
    setPublicID(_: string)
    systemID: string;
    setSystemID(_: string)
    static createWithXMLString(XMLString: string): XMLDTDNode;
  }

  // interface
  class XMLDocument extends XMLNode {
    static replacementClassForClass(_: typeof NSObject): typeof NSObject;
    DTD: XMLDTD;
    setDTD(_: XMLDTD)
    MIMEType: string;
    setMIMEType(_: string)
    XMLData: NSData;
    characterEncoding: string;
    setCharacterEncoding(_: string)
    documentContentKind: XMLDocument.ContentKind;
    setDocumentContentKind(_: XMLDocument.ContentKind)
    isStandalone: boolean;
    setStandalone(_: boolean)
    XMLDataWithOptions(_: XMLNode.Options): NSData;
    addChild(_: XMLNode): void;
    static createWithContentsOfURLOptions(contentsOfURL: NSURL, options: XMLNode.Options): XMLDocument;
    static createWithDataOptions(data: NSData, options: XMLNode.Options): XMLDocument;
    static createWithRootElement(rootElement?: XMLElement): XMLDocument;
    static createWithXMLStringOptions(XMLString: string, options: XMLNode.Options): XMLDocument;
    insertChildAtIndex(_: XMLNode, atIndex: number): void;
    insertChildrenAtIndex(_: XMLNode[], atIndex: number): void;
    objectByApplyingXSLTArgumentsError(arguments_: NSData, error?: Map<string, string>): any;
    objectByApplyingXSLTAtURLArgumentsError(arguments_: NSURL, error?: Map<string, string>): any;
    objectByApplyingXSLTStringArgumentsError(arguments_: string, error?: Map<string, string>): any;
    removeChildAtIndex(_: number): void;
    replaceChildAtIndexWithNode(_: number, withNode: XMLNode): void;
    rootElement(): XMLElement;
    setChildren(_?: XMLNode[]): void;
    setRootElement(_: XMLElement): void;
    validateAndReturnError(): boolean;
  }

  // interface
  class XMLElement extends XMLNode {
    attributes: XMLNode[];
    setAttributes(_: XMLNode[])
    namespaces: XMLNode[];
    setNamespaces(_: XMLNode[])
    addAttribute(_: XMLNode): void;
    addChild(_: XMLNode): void;
    addNamespace(_: XMLNode): void;
    attributeForLocalNameUri(_: string, URI?: string): XMLNode;
    attributeForName(_: string): XMLNode;
    elementsForLocalNameUri(_: string, URI?: string): XMLElement[];
    elementsForName(_: string): XMLElement[];
    static createWithName(name: string): XMLElement;
    static createWithNameUri(name: string, URI?: string): XMLElement;
    static createWithNameStringValue(name: string, stringValue?: string): XMLElement;
    static createWithXMLString(XMLString: string): XMLElement;
    insertChildAtIndex(_: XMLNode, atIndex: number): void;
    insertChildrenAtIndex(_: XMLNode[], atIndex: number): void;
    namespaceForPrefix(_: string): XMLNode;
    normalizeAdjacentTextNodesPreservingCDATA(_: boolean): void;
    removeAttributeForName(_: string): void;
    removeChildAtIndex(_: number): void;
    removeNamespaceForPrefix(_: string): void;
    replaceChildAtIndexWithNode(_: number, withNode: XMLNode): void;
    resolveNamespaceForName(_: string): XMLNode;
    resolvePrefixForNamespaceURI(_: string): string;
    setAttributesAsDictionary(_: Map<any, any>): void;
    setAttributesWithDictionary(_: Map<string, string>): void;
    setChildren(_?: XMLNode[]): void;
  }

  // interface
  class XMLNode extends NSObject /* implements NSCopying */ {
    static DTDNodeWithXMLString(_: string): any;
    static attributeWithNameUriStringValue(_: string, URI: string, stringValue: string): any;
    static attributeWithNameStringValue(_: string, stringValue: string): any;
    static commentWithStringValue(_: string): any;
    static document(): any;
    static documentWithRootElement(_: XMLElement): any;
    static elementWithName(_: string): any;
    static elementWithNameUri(_: string, URI: string): any;
    static elementWithNameChildrenAttributes(_: string, children?: XMLNode[], attributes?: XMLNode[]): any;
    static elementWithNameStringValue(_: string, stringValue: string): any;
    static localNameForName(_: string): string;
    static namespaceWithNameStringValue(_: string, stringValue: string): any;
    static predefinedNamespaceForPrefix(_: string): XMLNode;
    static prefixForName(_: string): string;
    static processingInstructionWithNameStringValue(_: string, stringValue: string): any;
    static textWithStringValue(_: string): any;
    URI: string;
    setURI(_: string)
    XMLString: string;
    XPath: string;
    childCount: number;
    children: XMLNode[];
    index: number;
    kind: XMLNode.Kind;
    level: number;
    localName: string;
    name: string;
    setName(_: string)
    nextNode: XMLNode;
    nextSibling: XMLNode;
    objectValue: any;
    setObjectValue(_: any)
    parent: XMLNode;
    prefix: string;
    previousNode: XMLNode;
    previousSibling: XMLNode;
    rootDocument: XMLDocument;
    stringValue: string;
    setStringValue(_: string)
    XMLStringWithOptions(_: XMLNode.Options): string;
    canonicalXMLStringPreservingComments(_: boolean): string;
    childAtIndex(_: number): XMLNode;
    detach(): void;
    static createWithKind(kind: XMLNode.Kind): XMLNode;
    static createWithKindOptions(kind: XMLNode.Kind, options: XMLNode.Options): XMLNode;
    nodesForXPathError(error: string): XMLNode[];
    objectsForXQueryConstantsError(constants: string, error?: Map<string, any>): any[];
    objectsForXQueryError(error: string): any[];
    setStringValueResolvingEntities(_: string, resolvingEntities: boolean): void;
  }

  // interface
  class XMLParser extends NSObject {
    allowedExternalEntityURLs: NSSet<NSURL>;
    setAllowedExternalEntityURLs(_: NSSet<NSURL>)
    columnNumber: number;
    delegate: XMLParserDelegate;
    setDelegate(_: XMLParserDelegate)
    externalEntityResolvingPolicy: XMLParser.ExternalEntityResolvingPolicy;
    setExternalEntityResolvingPolicy(_: XMLParser.ExternalEntityResolvingPolicy)
    lineNumber: number;
    parserError: NSError;
    publicID: string;
    shouldProcessNamespaces: boolean;
    setShouldProcessNamespaces(_: boolean)
    shouldReportNamespacePrefixes: boolean;
    setShouldReportNamespacePrefixes(_: boolean)
    shouldResolveExternalEntities: boolean;
    setShouldResolveExternalEntities(_: boolean)
    systemID: string;
    abortParsing(): void;
    static createWithContentsOfURL(contentsOfURL: NSURL): XMLParser;
    static createWithData(data: NSData): XMLParser;
    static createWithStream(stream: InputStream): XMLParser;
    parse(): boolean;
  }

  interface XMLParserDelegate extends NSObject {
    // instance method
    parserDidEndElementNamespaceURIQualifiedName?(_: XMLParser, didEndElement: string, namespaceURI?: string, qualifiedName?: string): void;
    // instance method
    parserDidEndMappingPrefix?(_: XMLParser, didEndMappingPrefix: string): void;
    // instance method
    parserDidStartElementNamespaceURIQualifiedNameAttributes?(_: XMLParser, didStartElement: string, namespaceURI?: string, qualifiedName?: string, attributes?: Map<string, string>): void;
    // instance method
    parserDidStartMappingPrefixToURI?(_: XMLParser, didStartMappingPrefix: string, toURI: string): void;
    // instance method
    parserFoundAttributeDeclarationWithNameForElementTypeDefaultValue?(_: XMLParser, foundAttributeDeclarationWithName: string, forElement: string, type?: string, defaultValue?: string): void;
    // instance method
    parserFoundCDATA?(_: XMLParser, foundCDATA: NSData): void;
    // instance method
    parserFoundCharacters?(_: XMLParser, foundCharacters: string): void;
    // instance method
    parserFoundComment?(_: XMLParser, foundComment: string): void;
    // instance method
    parserFoundElementDeclarationWithNameModel?(_: XMLParser, foundElementDeclarationWithName: string, model: string): void;
    // instance method
    parserFoundExternalEntityDeclarationWithNamePublicIDSystemID?(_: XMLParser, foundExternalEntityDeclarationWithName: string, publicID?: string, systemID?: string): void;
    // instance method
    parserFoundIgnorableWhitespace?(_: XMLParser, foundIgnorableWhitespace: string): void;
    // instance method
    parserFoundInternalEntityDeclarationWithNameValue?(_: XMLParser, foundInternalEntityDeclarationWithName: string, value?: string): void;
    // instance method
    parserFoundNotationDeclarationWithNamePublicIDSystemID?(_: XMLParser, foundNotationDeclarationWithName: string, publicID?: string, systemID?: string): void;
    // instance method
    parserFoundProcessingInstructionWithTargetData?(_: XMLParser, foundProcessingInstructionWithTarget: string, data?: string): void;
    // instance method
    parserFoundUnparsedEntityDeclarationWithNamePublicIDSystemIDNotationName?(_: XMLParser, foundUnparsedEntityDeclarationWithName: string, publicID?: string, systemID?: string, notationName?: string): void;
    // instance method
    parserParseErrorOccurred?(_: XMLParser, parseErrorOccurred: NSError): void;
    // instance method
    parserResolveExternalEntityNameSystemID?(_: XMLParser, resolveExternalEntityName: string, systemID?: string): NSData;
    // instance method
    parserValidationErrorOccurred?(_: XMLParser, validationErrorOccurred: NSError): void;
    // instance method
    parserDidEndDocument?(_: XMLParser): void;
    // instance method
    parserDidStartDocument?(_: XMLParser): void;
  }

  // interface
  class NSXPCCoder extends NSCoder {
    connection: NSXPCConnection;
    userInfo: NSObject;
    setUserInfo(_: NSObject)
    decodeXPCObjectOfTypeForKey(ofType: any, forKey: string): NSObject;
    encodeXPCObjectForKey(_: NSObject, forKey: string): void;
  }

  // interface
  class NSXPCConnection extends NSObject /* implements NSXPCProxyCreating */ {
    static currentConnection(): NSXPCConnection;
    auditSessionIdentifier: number;
    effectiveGroupIdentifier: number;
    effectiveUserIdentifier: number;
    endpoint: NSXPCListenerEndpoint;
    exportedInterface: NSXPCInterface;
    setExportedInterface(_: NSXPCInterface)
    exportedObject: any;
    setExportedObject(_: any)
    interruptionHandler: () => void;
    setInterruptionHandler(_: () => void)
    invalidationHandler: () => void;
    setInvalidationHandler(_: () => void)
    processIdentifier: number;
    remoteObjectInterface: NSXPCInterface;
    setRemoteObjectInterface(_: NSXPCInterface)
    remoteObjectProxy: any;
    serviceName: string;
    static createWithListenerEndpoint(listenerEndpoint: NSXPCListenerEndpoint): NSXPCConnection;
    static createWithMachServiceNameOptions(machServiceName: string, options: NSXPCConnection.Options): NSXPCConnection;
    static createWithServiceName(serviceName: string): NSXPCConnection;
    invalidate(): void;
    resume(): void;
    scheduleSendBarrierBlock(_: () => void): void;
    suspend(): void;
  }

  // interface
  class NSXPCInterface extends NSObject {
    static interfaceWithProtocol(with_: any /* Protocol */): NSXPCInterface;
    protocol: any /* Protocol */;
    setProtocol(_: any /* Protocol */)
    XPCTypeForSelectorArgumentIndexOfReply(for_: string, argumentIndex: number, ofReply: boolean): any;
    classesForSelectorArgumentIndexOfReply(for_: string, argumentIndex: number, ofReply: boolean): NSSet<typeof NSObject>;
    interfaceForSelectorArgumentIndexOfReply(_: string, argumentIndex: number, ofReply: boolean): NSXPCInterface;
    setClassesForArgumentIndexOfReply(_: NSSet<typeof NSObject>, for_: string, argumentIndex: number, ofReply: boolean): void;
    setInterfaceForSelectorArgumentIndexOfReply(_: NSXPCInterface, for_: string, argumentIndex: number, ofReply: boolean): void;
    setXPCTypeForSelectorArgumentIndexOfReply(_: any, for_: string, argumentIndex: number, ofReply: boolean): void;
  }

  // interface
  class NSXPCListener extends NSObject {
    static anonymousListener(): NSXPCListener;
    static serviceListener(): NSXPCListener;
    delegate: NSXPCListenerDelegate;
    setDelegate(_: NSXPCListenerDelegate)
    endpoint: NSXPCListenerEndpoint;
    static createWithMachServiceName(machServiceName: string): NSXPCListener;
    invalidate(): void;
    resume(): void;
    suspend(): void;
  }

  interface NSXPCListenerDelegate extends NSObject {
    // instance method
    listenerShouldAcceptNewConnection?(_: NSXPCListener, shouldAcceptNewConnection: NSXPCConnection): boolean;
  }

  // interface
  class NSXPCListenerEndpoint extends NSObject /* implements NSSecureCoding */ {
  }

  interface NSXPCProxyCreating {
    remoteObjectProxy: any;
    // instance method
    remoteObjectProxyWithErrorHandler(_: (p1: NSError) => void): any;
    // instance method
    synchronousRemoteObjectProxyWithErrorHandler?(_: (p1: NSError) => void): any;
  }

  // interface
  class IKCameraDeviceView extends NSView {
    cameraDevice: ICCameraDevice;
    setCameraDevice(_: ICCameraDevice)
    canDeleteSelectedItems: boolean;
    canDownloadSelectedItems: boolean;
    canRotateSelectedItemsLeft: boolean;
    canRotateSelectedItemsRight: boolean;
    delegate: IKCameraDeviceViewDelegate;
    setDelegate(_: IKCameraDeviceViewDelegate)
    displaysDownloadsDirectoryControl: boolean;
    setDisplaysDownloadsDirectoryControl(_: boolean)
    displaysPostProcessApplicationControl: boolean;
    setDisplaysPostProcessApplicationControl(_: boolean)
    downloadAllControlLabel: string;
    setDownloadAllControlLabel(_: string)
    downloadSelectedControlLabel: string;
    setDownloadSelectedControlLabel(_: string)
    downloadsDirectory: NSURL;
    setDownloadsDirectory(_: NSURL)
    hasDisplayModeIcon: boolean;
    setHasDisplayModeIcon(_: boolean)
    hasDisplayModeTable: boolean;
    setHasDisplayModeTable(_: boolean)
    iconSize: number;
    setIconSize(_: number)
    mode: IKCameraDeviceViewDisplayMode;
    setMode(_: IKCameraDeviceViewDisplayMode)
    postProcessApplication: NSURL;
    setPostProcessApplication(_: NSURL)
    transferMode: IKCameraDeviceViewTransferMode;
    setTransferMode(_: IKCameraDeviceViewTransferMode)
    deleteSelectedItems(_: any): void;
    downloadAllItems(_: any): void;
    downloadSelectedItems(_: any): void;
    rotateLeft(_: any): void;
    rotateRight(_: any): void;
    selectIndexesByExtendingSelection(_: NSIndexSet, byExtendingSelection: boolean): void;
    selectedIndexes(): NSIndexSet;
  }

  interface IKCameraDeviceViewDelegate {
    // instance method
    cameraDeviceViewDidDownloadFileLocationFileDataError?(_: IKCameraDeviceView, didDownloadFile: ICCameraFile, location: NSURL, fileData: NSData, error: NSError): void;
    // instance method
    cameraDeviceViewDidEncounterError?(_: IKCameraDeviceView, didEncounterError: NSError): void;
    // instance method
    cameraDeviceViewSelectionDidChange?(_: IKCameraDeviceView): void;
  }

  // interface
  class IKDeviceBrowserView extends NSView {
    delegate: IKDeviceBrowserViewDelegate;
    setDelegate(_: IKDeviceBrowserViewDelegate)
    displaysLocalCameras: boolean;
    setDisplaysLocalCameras(_: boolean)
    displaysLocalScanners: boolean;
    setDisplaysLocalScanners(_: boolean)
    displaysNetworkCameras: boolean;
    setDisplaysNetworkCameras(_: boolean)
    displaysNetworkScanners: boolean;
    setDisplaysNetworkScanners(_: boolean)
    mode: IKDeviceBrowserViewDisplayMode;
    setMode(_: IKDeviceBrowserViewDisplayMode)
    selectedDevice: ICDevice;
  }

  interface IKDeviceBrowserViewDelegate {
    // instance method
    deviceBrowserViewDidEncounterError?(_: IKDeviceBrowserView, didEncounterError: NSError): void;
    // instance method
    deviceBrowserViewSelectionDidChange(_: IKDeviceBrowserView, selectionDidChange: ICDevice): void;
  }

  // interface
  class IKFilterBrowserPanel extends NSPanel {
    static filterBrowserPanelWithStyleMask(withStyleMask: number): any;
    beginSheetWithOptionsModalForWindowModalDelegateDidEndSelectorContextInfo(options: Map<any, any>, modalFor: NSWindow, modalDelegate: any, didEnd: string, contextInfo: any): void;
    beginWithOptionsModelessDelegateDidEndSelectorContextInfo(options: Map<any, any>, modelessDelegate: any, didEnd: string, contextInfo: any): void;
    filterBrowserViewWithOptions(options: Map<any, any>): IKFilterBrowserView;
    filterName(): string;
    finish(_: any): void;
    runModalWithOptions(options: Map<any, any>): number;
  }

  // interface
  class IKFilterBrowserView extends NSView {
    filterName(): string;
    setPreviewState(_: boolean): void;
  }

  interface IKFilterCustomUIProvider {
    // instance method
    provideViewForUIConfigurationExcludedKeys(forUIConfiguration: Map<any, any>, excludedKeys: any[]): IKFilterUIView;
  }

  // interface
  class IKFilterUIView extends NSView {
    static viewWithFrameFilter(withFrame: CGRect, filter: CIFilter): any;
    filter(): CIFilter;
    static createWithFrameFilter(frame: CGRect, filter: CIFilter): IKFilterUIView;
    objectController(): NSObjectController;
  }

  // interface
  class IKImageBrowserCell extends NSObject {
    cellState(): IKImageBrowserCellState;
    frame(): CGRect;
    imageAlignment(): NSImageAlignment;
    imageContainerFrame(): CGRect;
    imageFrame(): CGRect;
    indexOfRepresentedItem(): number;
    isSelected(): boolean;
    layerForType(forType: string): CALayer;
    opacity(): number;
    representedItem(): any;
    selectionFrame(): CGRect;
    subtitleFrame(): CGRect;
    titleFrame(): CGRect;
  }

  // interface
  class IKImageEditPanel extends NSPanel {
    static sharedImageEditPanel(): IKImageEditPanel;
    dataSource: IKImageEditPanelDataSource;
    setDataSource(_: IKImageEditPanelDataSource)
    filterArray: any[];
    reloadData(): void;
  }

  interface IKImageEditPanelDataSource {
    // instance method
    hasAdjustMode?(): boolean;
    // instance method
    hasDetailsMode?(): boolean;
    // instance method
    hasEffectsMode?(): boolean;
    // instance method
    image(): any;
    // instance method
    imageProperties?(): Map<any, any>;
    // instance method
    setImageImageProperties(_: any, imageProperties: Map<any, any>): void;
    // instance method
    thumbnailWithMaximumSize?(withMaximumSize: CGSize): any;
  }

  // interface
  class IKImageView extends NSView {
    autohidesScrollers: boolean;
    setAutohidesScrollers(_: boolean)
    autoresizes: boolean;
    setAutoresizes(_: boolean)
    backgroundColor: NSColor;
    setBackgroundColor(_: NSColor)
    currentToolMode: string;
    setCurrentToolMode(_: string)
    delegate: any;
    setDelegate(_: any)
    doubleClickOpensImageEditPanel: boolean;
    setDoubleClickOpensImageEditPanel(_: boolean)
    editable: boolean;
    setEditable(_: boolean)
    hasHorizontalScroller: boolean;
    setHasHorizontalScroller(_: boolean)
    hasVerticalScroller: boolean;
    setHasVerticalScroller(_: boolean)
    imageCorrection: CIFilter;
    setImageCorrection(_: CIFilter)
    rotationAngle: number;
    setRotationAngle(_: number)
    supportsDragAndDrop: boolean;
    setSupportsDragAndDrop(_: boolean)
    zoomFactor: number;
    setZoomFactor(_: number)
    convertImagePointToViewPoint(toViewPoint: CGPoint): CGPoint;
    convertImageRectToViewRect(toViewRect: CGRect): CGRect;
    convertViewPointToImagePoint(toImagePoint: CGPoint): CGPoint;
    convertViewRectToImageRect(toImageRect: CGRect): CGRect;
    crop(_: any): void;
    flipImageHorizontal(_: any): void;
    flipImageVertical(_: any): void;
    image(): any;
    imageProperties(): Map<any, any>;
    imageSize(): CGSize;
    overlayForType(forType: string): CALayer;
    rotateImageLeft(_: any): void;
    rotateImageRight(_: any): void;
    scrollToPoint(to: CGPoint): void;
    scrollToRect(to: CGRect): void;
    setImageImageProperties(_: any, imageProperties: Map<any, any>): void;
    setImageWithURL(_: NSURL): void;
    setImageZoomFactorCenterPoint(_: number, center: CGPoint): void;
    setOverlayForType(_: CALayer, forType: string): void;
    setRotationAngleCenterPoint(_: number, center: CGPoint): void;
    zoomImageToActualSize(_: any): void;
    zoomImageToFit(_: any): void;
    zoomImageToRect(to: CGRect): void;
    zoomIn(_: any): void;
    zoomOut(_: any): void;
  }

  // interface
  class IKPictureTaker extends NSPanel {
    static pictureTaker(): IKPictureTaker;
    beginPictureTakerSheetForWindowWithDelegateDidEndSelectorContextInfo(for_: NSWindow, withDelegate: any, didEnd: string, contextInfo: any): void;
    beginPictureTakerWithDelegateDidEndSelectorContextInfo(withDelegate: any, didEnd: string, contextInfo: any): void;
    inputImage(): NSImage;
    mirroring(): boolean;
    outputImage(): NSImage;
    popUpRecentsMenuForViewWithDelegateDidEndSelectorContextInfo(for_: NSView, withDelegate: any, didEnd: string, contextInfo: any): void;
    runModal(): number;
    setInputImage(_: NSImage): void;
    setMirroring(_: boolean): void;
  }

  // interface
  class IKSaveOptions extends NSObject {
    delegate: any;
    setDelegate(_: any)
    imageProperties: Map<any, any>;
    imageUTType: string;
    userSelection: Map<any, any>;
    addSaveOptionsAccessoryViewToSavePanel(to: NSSavePanel): void;
    addSaveOptionsToView(to: NSView): void;
    static createWithImagePropertiesImageUTType(imageProperties: Map<any, any>, imageUTType: string): IKSaveOptions;
  }

  // interface
  class IKScannerDeviceView extends NSView {
    delegate: IKScannerDeviceViewDelegate;
    setDelegate(_: IKScannerDeviceViewDelegate)
    displaysDownloadsDirectoryControl: boolean;
    setDisplaysDownloadsDirectoryControl(_: boolean)
    displaysPostProcessApplicationControl: boolean;
    setDisplaysPostProcessApplicationControl(_: boolean)
    documentName: string;
    setDocumentName(_: string)
    downloadsDirectory: NSURL;
    setDownloadsDirectory(_: NSURL)
    hasDisplayModeAdvanced: boolean;
    setHasDisplayModeAdvanced(_: boolean)
    hasDisplayModeSimple: boolean;
    setHasDisplayModeSimple(_: boolean)
    mode: IKScannerDeviceViewDisplayMode;
    setMode(_: IKScannerDeviceViewDisplayMode)
    overviewControlLabel: string;
    setOverviewControlLabel(_: string)
    postProcessApplication: NSURL;
    setPostProcessApplication(_: NSURL)
    scanControlLabel: string;
    setScanControlLabel(_: string)
    scannerDevice: ICScannerDevice;
    setScannerDevice(_: ICScannerDevice)
    transferMode: IKScannerDeviceViewTransferMode;
    setTransferMode(_: IKScannerDeviceViewTransferMode)
  }

  interface IKScannerDeviceViewDelegate {
    // instance method
    scannerDeviceViewDidScanToURLFileDataError?(_: IKScannerDeviceView, didScanTo: NSURL, fileData: NSData, error: NSError): void;
    // instance method
    scannerDeviceViewDidScanToURLError?(_: IKScannerDeviceView, didScanTo: NSURL, error: NSError): void;
    // instance method
    scannerDeviceViewDidScanToBandDataScanInfoError?(_: IKScannerDeviceView, didScanTo: ICScannerBandData, scanInfo: Map<any, any>, error: NSError): void;
    // instance method
    scannerDeviceViewDidEncounterError?(_: IKScannerDeviceView, didEncounterError: NSError): void;
  }

  // interface
  class IKSlideshow extends NSObject {
    static canExportToApplication(toApplication: string): boolean;
    static exportSlideshowItemToApplication(_: any, toApplication: string): void;
    static sharedSlideshow(): IKSlideshow;
    autoPlayDelay: number;
    setAutoPlayDelay(_: number)
    indexOfCurrentSlideshowItem(): number;
    reloadData(): void;
    reloadSlideshowItemAtIndex(at: number): void;
    runSlideshowWithDataSourceInModeOptions(with_: IKSlideshowDataSource, inMode: string, options: Map<any, any>): void;
    stopSlideshow(_: any): void;
  }

  interface IKSlideshowDataSource {
    // instance method
    canExportSlideshowItemAtIndexToApplication?(at: number, toApplication: string): boolean;
    // instance method
    nameOfSlideshowItemAtIndex?(at: number): string;
    // instance method
    numberOfSlideshowItems(): number;
    // instance method
    slideshowDidChangeCurrentIndex?(_: number): void;
    // instance method
    slideshowDidStop?(): void;
    // instance method
    slideshowItemAtIndex(at: number): any;
    // instance method
    slideshowWillStart?(): void;
  }

  interface QLPreviewItem extends NSObject {
    previewItemDisplayState?: any;
    previewItemTitle?: string;
    previewItemURL: NSURL;
  }

  // interface
  class QLPreviewPanel extends NSPanel {
    static sharedPreviewPanel(): QLPreviewPanel;
    static sharedPreviewPanelExists(): boolean;
    currentController: any;
    currentPreviewItem: QLPreviewItem;
    currentPreviewItemIndex: number;
    setCurrentPreviewItemIndex(_: number)
    dataSource: QLPreviewPanelDataSource;
    setDataSource(_: QLPreviewPanelDataSource)
    displayState: any;
    setDisplayState(_: any)
    isInFullScreenMode: boolean;
    enterFullScreenModeWithOptions(_: NSScreen, withOptions: Map<any, any>): boolean;
    exitFullScreenModeWithOptions(options: Map<any, any>): void;
    refreshCurrentPreviewItem(): void;
    reloadData(): void;
    updateController(): void;
  }

  interface QLPreviewPanelDataSource {
    // instance method
    numberOfPreviewItemsInPreviewPanel(in_: QLPreviewPanel): number;
    // instance method
    previewPanelPreviewItemAtIndex(_: QLPreviewPanel, previewItemAt: number): QLPreviewItem;
  }

  interface QLPreviewPanelDelegate extends NSWindowDelegate {
    // instance method
    previewPanelHandleEvent?(_: QLPreviewPanel, handle: NSEvent): boolean;
    // instance method
    previewPanelSourceFrameOnScreenForPreviewItem?(_: QLPreviewPanel, sourceFrameOnScreenFor: QLPreviewItem): CGRect;
    // instance method
    previewPanelTransitionImageForPreviewItemContentRect?(_: QLPreviewPanel, transitionImageFor: QLPreviewItem, contentRect: NSRect): any;
  }

  // interface
  class QLPreviewView extends NSView {
    autostarts: boolean;
    setAutostarts(_: boolean)
    displayState: any;
    setDisplayState(_: any)
    previewItem: QLPreviewItem;
    setPreviewItem(_: QLPreviewItem)
    shouldCloseWithWindow: boolean;
    setShouldCloseWithWindow(_: boolean)
    close(): void;
    static createWithFrameStyle(frame: CGRect, style: QLPreviewViewStyle): QLPreviewView;
    refreshPreviewItem(): void;
  }

  interface QLPreviewingController extends NSObject {
    // instance method
    preparePreviewOfFileWithAtCompletionHandler?(at: NSURL, completionHandler?: (p1: NSError) => void): void;
    // instance method
    preparePreviewOfSearchableItemWithIdentifierQueryStringCompletionHandler?(identifier: string, queryString?: string, completionHandler?: (p1: NSError) => void): void;
  }

  // interface
  class QuartzFilter extends NSObject {
    applyToContext(to: any): boolean;
    localizedName(): string;
    properties(): Map<any, any>;
    removeFromContext(from: any): void;
    url(): NSURL;
  }

  // interface
  class QuartzFilterManager extends NSObject {
    static filtersInDomains(inDomains: any[]): any[];
    delegate(): any;
    filterPanel(): NSPanel;
    filterView(): QuartzFilterView;
    importFilter(_: Map<any, any>): QuartzFilter;
    selectFilter(_: QuartzFilter): boolean;
    selectedFilter(): QuartzFilter;
    setDelegate(_: any): void;
  }

  // interface
  class QuartzFilterView extends NSView {
    sizeToFit(): void;
  }

  interface CAAction {
    // instance method
    runActionForKeyObjectArguments(forKey: string, object_: any, arguments_?: Map<any, any>): void;
  }

  // interface
  class CAAnimation extends NSObject /* implements CAAction, CAMediaTiming, NSCopying, NSSecureCoding */ {
    static defaultValueForKey(forKey: string): any;
    delegate: CAAnimationDelegate;
    setDelegate(_: CAAnimationDelegate)
    isRemovedOnCompletion: boolean;
    setRemovedOnCompletion(_: boolean)
    timingFunction: CAMediaTimingFunction;
    setTimingFunction(_: CAMediaTimingFunction)
    shouldArchiveValueForKey(forKey: string): boolean;
  }

  interface CAAnimationDelegate extends NSObject {
    // instance method
    animationDidStart?(_: CAAnimation): void;
    // instance method
    animationDidStopFinished?(_: CAAnimation, finished: boolean): void;
  }

  // interface
  class CAAnimationGroup extends CAAnimation {
    animations: CAAnimation[];
    setAnimations(_: CAAnimation[])
  }

  // interface
  class CABasicAnimation extends CAPropertyAnimation {
    byValue: any;
    setByValue(_: any)
    fromValue: any;
    setFromValue(_: any)
    toValue: any;
    setToValue(_: any)
  }

  // interface
  class CAConstraint extends NSObject /* implements NSSecureCoding */ {
    static constraintWithAttributeRelativeToAttribute(attribute: CAConstraintAttribute, relativeTo: string, attribute2: CAConstraintAttribute): CAConstraint;
    static constraintWithAttributeRelativeToAttributeOffset(attribute: CAConstraintAttribute, relativeTo: string, attribute2: CAConstraintAttribute, offset: number): CAConstraint;
    static constraintWithAttributeRelativeToAttributeScaleOffset(attribute: CAConstraintAttribute, relativeTo: string, attribute2: CAConstraintAttribute, scale: number, offset: number): CAConstraint;
    attribute: CAConstraintAttribute;
    offset: number;
    scale: number;
    sourceAttribute: CAConstraintAttribute;
    sourceName: string;
    static createWithAttributeRelativeToAttribute2ScaleOffset(attribute: CAConstraintAttribute, relativeTo: string, attribute2: CAConstraintAttribute, scale: number, offset: number): CAConstraint;
  }

  // interface
  class CAConstraintLayoutManager extends NSObject /* implements CALayoutManager */ {
  }

  // export function CACurrentMediaTime(): number;

  // interface
  class CAEDRMetadata extends NSObject {
    static HDR10MetadataWithDisplayInfoContentInfoOpticalOutputScale(displayInfo?: NSData, contentInfo?: NSData, opticalOutputScale?: number): CAEDRMetadata;
    static HDR10MetadataWithMinLuminanceMaxLuminanceOpticalOutputScale(minLuminance: number, maxLuminance: number, opticalOutputScale: number): CAEDRMetadata;
    static HLGMetadata: CAEDRMetadata;
  }

  // interface
  class CAEmitterCell extends NSObject /* implements CAMediaTiming, NSSecureCoding */ {
    static defaultValueForKey(forKey: string): any;
    alphaRange: number;
    setAlphaRange(_: number)
    alphaSpeed: number;
    setAlphaSpeed(_: number)
    birthRate: number;
    setBirthRate(_: number)
    blueRange: number;
    setBlueRange(_: number)
    blueSpeed: number;
    setBlueSpeed(_: number)
    color: any;
    setColor(_: any)
    contents: any;
    setContents(_: any)
    contentsRect: CGRect;
    setContentsRect(_: CGRect)
    contentsScale: number;
    setContentsScale(_: number)
    emissionLatitude: number;
    setEmissionLatitude(_: number)
    emissionLongitude: number;
    setEmissionLongitude(_: number)
    emissionRange: number;
    setEmissionRange(_: number)
    emitterCells: CAEmitterCell[];
    setEmitterCells(_: CAEmitterCell[])
    isEnabled: boolean;
    setEnabled(_: boolean)
    greenRange: number;
    setGreenRange(_: number)
    greenSpeed: number;
    setGreenSpeed(_: number)
    lifetime: number;
    setLifetime(_: number)
    lifetimeRange: number;
    setLifetimeRange(_: number)
    magnificationFilter: string;
    setMagnificationFilter(_: string)
    minificationFilter: string;
    setMinificationFilter(_: string)
    minificationFilterBias: number;
    setMinificationFilterBias(_: number)
    name: string;
    setName(_: string)
    redRange: number;
    setRedRange(_: number)
    redSpeed: number;
    setRedSpeed(_: number)
    scale: number;
    setScale(_: number)
    scaleRange: number;
    setScaleRange(_: number)
    scaleSpeed: number;
    setScaleSpeed(_: number)
    spin: number;
    setSpin(_: number)
    spinRange: number;
    setSpinRange(_: number)
    style: Map<any, any>;
    setStyle(_: Map<any, any>)
    velocity: number;
    setVelocity(_: number)
    velocityRange: number;
    setVelocityRange(_: number)
    xAcceleration: number;
    setXAcceleration(_: number)
    yAcceleration: number;
    setYAcceleration(_: number)
    zAcceleration: number;
    setZAcceleration(_: number)
    shouldArchiveValueForKey(forKey: string): boolean;
  }

  // interface
  class CAEmitterLayer extends CALayer {
    birthRate: number;
    setBirthRate(_: number)
    emitterCells: CAEmitterCell[];
    setEmitterCells(_: CAEmitterCell[])
    emitterDepth: number;
    setEmitterDepth(_: number)
    emitterMode: string;
    setEmitterMode(_: string)
    emitterPosition: CGPoint;
    setEmitterPosition(_: CGPoint)
    emitterShape: string;
    setEmitterShape(_: string)
    emitterSize: CGSize;
    setEmitterSize(_: CGSize)
    emitterZPosition: number;
    setEmitterZPosition(_: number)
    lifetime: number;
    setLifetime(_: number)
    preservesDepth: boolean;
    setPreservesDepth(_: boolean)
    renderMode: string;
    setRenderMode(_: string)
    scale: number;
    setScale(_: number)
    seed: number;
    setSeed(_: number)
    spin: number;
    setSpin(_: number)
    velocity: number;
    setVelocity(_: number)
  }

  // interface
  class CAGradientLayer extends CALayer {
    colors: any[];
    setColors(_: any[])
    endPoint: CGPoint;
    setEndPoint(_: CGPoint)
    locations: number[];
    setLocations(_: number[])
    startPoint: CGPoint;
    setStartPoint(_: CGPoint)
    type: string;
    setType(_: string)
  }

  // interface
  class CAKeyframeAnimation extends CAPropertyAnimation {
    biasValues: number[];
    setBiasValues(_: number[])
    calculationMode: string;
    setCalculationMode(_: string)
    continuityValues: number[];
    setContinuityValues(_: number[])
    keyTimes: number[];
    setKeyTimes(_: number[])
    path: any;
    setPath(_: any)
    rotationMode: string;
    setRotationMode(_: string)
    tensionValues: number[];
    setTensionValues(_: number[])
    timingFunctions: CAMediaTimingFunction[];
    setTimingFunctions(_: CAMediaTimingFunction[])
    values: any[];
    setValues(_: any[])
  }

  // interface
  class CALayer extends NSObject /* implements CAMediaTiming, NSSecureCoding */ {
    static cornerCurveExpansionFactor(_: string): number;
    static defaultActionForKey(forKey: string): CAAction;
    static defaultValueForKey(forKey: string): any;
    static needsDisplayForKey(forKey: string): boolean;
    actions: Map<string, CAAction>;
    setActions(_: Map<string, CAAction>)
    allowsEdgeAntialiasing: boolean;
    setAllowsEdgeAntialiasing(_: boolean)
    allowsGroupOpacity: boolean;
    setAllowsGroupOpacity(_: boolean)
    anchorPoint: CGPoint;
    setAnchorPoint(_: CGPoint)
    anchorPointZ: number;
    setAnchorPointZ(_: number)
    autoresizingMask: CAAutoresizingMask;
    setAutoresizingMask(_: CAAutoresizingMask)
    backgroundColor: any;
    setBackgroundColor(_: any)
    backgroundFilters: any[];
    setBackgroundFilters(_: any[])
    borderColor: any;
    setBorderColor(_: any)
    borderWidth: number;
    setBorderWidth(_: number)
    bounds: CGRect;
    setBounds(_: CGRect)
    compositingFilter: any;
    setCompositingFilter(_: any)
    constraints: CAConstraint[];
    setConstraints(_: CAConstraint[])
    contents: any;
    setContents(_: any)
    contentsCenter: CGRect;
    setContentsCenter(_: CGRect)
    contentsFormat: string;
    setContentsFormat(_: string)
    contentsGravity: string;
    setContentsGravity(_: string)
    contentsRect: CGRect;
    setContentsRect(_: CGRect)
    contentsScale: number;
    setContentsScale(_: number)
    cornerCurve: string;
    setCornerCurve(_: string)
    cornerRadius: number;
    setCornerRadius(_: number)
    delegate: CALayerDelegate;
    setDelegate(_: CALayerDelegate)
    isDoubleSided: boolean;
    setDoubleSided(_: boolean)
    drawsAsynchronously: boolean;
    setDrawsAsynchronously(_: boolean)
    edgeAntialiasingMask: CAEdgeAntialiasingMask;
    setEdgeAntialiasingMask(_: CAEdgeAntialiasingMask)
    filters: any[];
    setFilters(_: any[])
    frame: CGRect;
    setFrame(_: CGRect)
    isGeometryFlipped: boolean;
    setGeometryFlipped(_: boolean)
    isHidden: boolean;
    setHidden(_: boolean)
    layoutManager: CALayoutManager;
    setLayoutManager(_: CALayoutManager)
    magnificationFilter: string;
    setMagnificationFilter(_: string)
    mask: CALayer;
    setMask(_: CALayer)
    maskedCorners: CACornerMask;
    setMaskedCorners(_: CACornerMask)
    masksToBounds: boolean;
    setMasksToBounds(_: boolean)
    minificationFilter: string;
    setMinificationFilter(_: string)
    minificationFilterBias: number;
    setMinificationFilterBias(_: number)
    name: string;
    setName(_: string)
    needsDisplayOnBoundsChange: boolean;
    setNeedsDisplayOnBoundsChange(_: boolean)
    opacity: number;
    setOpacity(_: number)
    isOpaque: boolean;
    setOpaque(_: boolean)
    position: CGPoint;
    setPosition(_: CGPoint)
    rasterizationScale: number;
    setRasterizationScale(_: number)
    shadowColor: any;
    setShadowColor(_: any)
    shadowOffset: CGSize;
    setShadowOffset(_: CGSize)
    shadowOpacity: number;
    setShadowOpacity(_: number)
    shadowPath: any;
    setShadowPath(_: any)
    shadowRadius: number;
    setShadowRadius(_: number)
    shouldRasterize: boolean;
    setShouldRasterize(_: boolean)
    style: Map<any, any>;
    setStyle(_: Map<any, any>)
    sublayerTransform: CATransform3D;
    setSublayerTransform(_: CATransform3D)
    sublayers: CALayer[];
    setSublayers(_: CALayer[])
    superlayer: CALayer;
    transform: CATransform3D;
    setTransform(_: CATransform3D)
    visibleRect: CGRect;
    zPosition: number;
    setZPosition(_: number)
    actionForKey(forKey: string): CAAction;
    addAnimationForKey(_: CAAnimation, forKey?: string): void;
    addConstraint(_: CAConstraint): void;
    addSublayer(_: CALayer): void;
    affineTransform(): CGAffineTransform;
    animationForKey(forKey: string): CAAnimation;
    animationKeys(): string[];
    containsPoint(_: CGPoint): boolean;
    contentsAreFlipped(): boolean;
    convertPointFromLayer(_: CGPoint, from?: CALayer): CGPoint;
    convertPointToLayer(_: CGPoint, to?: CALayer): CGPoint;
    convertRectFromLayer(_: CGRect, from?: CALayer): CGRect;
    convertRectToLayer(_: CGRect, to?: CALayer): CGRect;
    convertTimeFromLayer(_: number, from?: CALayer): number;
    convertTimeToLayer(_: number, to?: CALayer): number;
    display(): void;
    displayIfNeeded(): void;
    drawInContext(in_: any): void;
    hitTest(_: CGPoint): CALayer;
    static createWithLayer(layer: any): CALayer;
    insertSublayerAbove(_: CALayer, above?: CALayer): void;
    insertSublayerAtIndex(_: CALayer, at: number): void;
    insertSublayerBelow(_: CALayer, below?: CALayer): void;
    layoutIfNeeded(): void;
    layoutSublayers(): void;
    modelLayer(): CALayer;
    needsDisplay(): boolean;
    needsLayout(): boolean;
    preferredFrameSize(): CGSize;
    presentationLayer(): CALayer;
    removeAllAnimations(): void;
    removeAnimationForKey(forKey: string): void;
    removeFromSuperlayer(): void;
    renderInContext(in_: any): void;
    replaceSublayerWith(_: CALayer, with_: CALayer): void;
    resizeSublayersWithOldSize(withOldSize: CGSize): void;
    resizeWithOldSuperlayerSize(withOldSuperlayerSize: CGSize): void;
    scrollPoint(_: CGPoint): void;
    scrollRectToVisible(_: CGRect): void;
    setAffineTransform(_: CGAffineTransform): void;
    setNeedsDisplay(): void;
    setNeedsDisplayInRect(_: CGRect): void;
    setNeedsLayout(): void;
    shouldArchiveValueForKey(forKey: string): boolean;
  }

  interface CALayerDelegate extends NSObject {
    // instance method
    actionForLayerForKey?(for_: CALayer, forKey: string): CAAction;
    // instance method
    displayLayer?(_: CALayer): void;
    // instance method
    drawLayerInContext?(_: CALayer, in_: any): void;
    // instance method
    layerWillDraw?(_: CALayer): void;
    // instance method
    layoutSublayersOfLayer?(of: CALayer): void;
  }

  interface CALayoutManager extends NSObject {
    // instance method
    invalidateLayoutOfLayer?(of: CALayer): void;
    // instance method
    layoutSublayersOfLayer?(of: CALayer): void;
    // instance method
    preferredSizeOfLayer?(of: CALayer): CGSize;
  }

  interface CAMediaTiming {
    autoreverses: boolean;
    setAutoreverses(_: boolean)
    beginTime: number;
    setBeginTime(_: number)
    duration: number;
    setDuration(_: number)
    fillMode: string;
    setFillMode(_: string)
    repeatCount: number;
    setRepeatCount(_: number)
    repeatDuration: number;
    setRepeatDuration(_: number)
    speed: number;
    setSpeed(_: number)
    timeOffset: number;
    setTimeOffset(_: number)
  }

  // interface
  class CAMediaTimingFunction extends NSObject /* implements NSSecureCoding */ {
    static functionWithControlPoints(_: number, _2: number, _3: number, _4: number): CAMediaTimingFunction;
    getControlPointAtIndexValues(at: number, values: number): void;
    static createWithControlPoints(_: number, _2: number, _3: number, controlPoints: number): CAMediaTimingFunction;
  }

  interface CAMetalDrawable extends MTLDrawable {
    layer: CAMetalLayer;
    // texture: MTLTexture;
  }

  // interface
  class CAMetalLayer extends CALayer {
    EDRMetadata: CAEDRMetadata;
    setEDRMetadata(_: CAEDRMetadata)
    allowsNextDrawableTimeout: boolean;
    setAllowsNextDrawableTimeout(_: boolean)
    colorspace: any;
    setColorspace(_: any)
    // device: MTLDevice;
    // setDevice(_: MTLDevice)
    displaySyncEnabled: boolean;
    setDisplaySyncEnabled(_: boolean)
    drawableSize: CGSize;
    setDrawableSize(_: CGSize)
    framebufferOnly: boolean;
    setFramebufferOnly(_: boolean)
    maximumDrawableCount: number;
    setMaximumDrawableCount(_: number)
    // pixelFormat: MTLPixelFormat;
    // setPixelFormat(_: MTLPixelFormat)
    // preferredDevice: MTLDevice;
    presentsWithTransaction: boolean;
    setPresentsWithTransaction(_: boolean)
    wantsExtendedDynamicRangeContent: boolean;
    setWantsExtendedDynamicRangeContent(_: boolean)
    nextDrawable(): CAMetalDrawable;
  }

  // interface
  class CAPropertyAnimation extends CAAnimation {
    static animationWithKeyPath(keyPath?: string): CAPropertyAnimation;
    isAdditive: boolean;
    setAdditive(_: boolean)
    isCumulative: boolean;
    setCumulative(_: boolean)
    keyPath: string;
    setKeyPath(_: string)
    valueFunction: CAValueFunction;
    setValueFunction(_: CAValueFunction)
  }

  // interface
  class CARemoteLayerClient extends NSObject {
    clientId: number;
    layer: CALayer;
    setLayer(_: CALayer)
    static createWithServerPort(serverPort: number): CARemoteLayerClient;
    invalidate(): void;
  }

  // interface
  class CARemoteLayerServer extends NSObject {
    static sharedServer(): CARemoteLayerServer;
    serverPort: number;
  }

  // interface
  class CARenderer extends NSObject {
    bounds: CGRect;
    setBounds(_: CGRect)
    layer: CALayer;
    setLayer(_: CALayer)
    addUpdateRect(_: CGRect): void;
    beginFrameAtTimeTimeStamp(atTime: number, timeStamp?: CVTimeStamp): void;
    endFrame(): void;
    nextFrameTime(): number;
    render(): void;
    // setDestination(_: MTLTexture): void;
    updateBounds(): CGRect;
  }

  // interface
  class CAReplicatorLayer extends CALayer {
    instanceAlphaOffset: number;
    setInstanceAlphaOffset(_: number)
    instanceBlueOffset: number;
    setInstanceBlueOffset(_: number)
    instanceColor: any;
    setInstanceColor(_: any)
    instanceCount: number;
    setInstanceCount(_: number)
    instanceDelay: number;
    setInstanceDelay(_: number)
    instanceGreenOffset: number;
    setInstanceGreenOffset(_: number)
    instanceRedOffset: number;
    setInstanceRedOffset(_: number)
    instanceTransform: CATransform3D;
    setInstanceTransform(_: CATransform3D)
    preservesDepth: boolean;
    setPreservesDepth(_: boolean)
  }

  // interface
  class CAScrollLayer extends CALayer {
    scrollMode: string;
    setScrollMode(_: string)
    scrollToPoint(to: CGPoint): void;
    scrollToRect(to: CGRect): void;
  }

  // interface
  class CAShapeLayer extends CALayer {
    fillColor: any;
    setFillColor(_: any)
    fillRule: string;
    setFillRule(_: string)
    lineCap: string;
    setLineCap(_: string)
    lineDashPattern: number[];
    setLineDashPattern(_: number[])
    lineDashPhase: number;
    setLineDashPhase(_: number)
    lineJoin: string;
    setLineJoin(_: string)
    lineWidth: number;
    setLineWidth(_: number)
    miterLimit: number;
    setMiterLimit(_: number)
    path: any;
    setPath(_: any)
    strokeColor: any;
    setStrokeColor(_: any)
    strokeEnd: number;
    setStrokeEnd(_: number)
    strokeStart: number;
    setStrokeStart(_: number)
  }

  // interface
  class CASpringAnimation extends CABasicAnimation {
    damping: number;
    setDamping(_: number)
    initialVelocity: number;
    setInitialVelocity(_: number)
    mass: number;
    setMass(_: number)
    settlingDuration: number;
    stiffness: number;
    setStiffness(_: number)
  }

  // interface
  class CATextLayer extends CALayer {
    alignmentMode: string;
    setAlignmentMode(_: string)
    allowsFontSubpixelQuantization: boolean;
    setAllowsFontSubpixelQuantization(_: boolean)
    font: any;
    setFont(_: any)
    fontSize: number;
    setFontSize(_: number)
    foregroundColor: any;
    setForegroundColor(_: any)
    string: any;
    setString(_: any)
    truncationMode: string;
    setTruncationMode(_: string)
    isWrapped: boolean;
    setWrapped(_: boolean)
  }

  // interface
  class CATiledLayer extends CALayer {
    static fadeDuration(): number;
    levelsOfDetail: number;
    setLevelsOfDetail(_: number)
    levelsOfDetailBias: number;
    setLevelsOfDetailBias(_: number)
    tileSize: CGSize;
    setTileSize(_: CGSize)
  }

  // interface
  class CATransaction extends NSObject {
    static animationDuration(): number;
    static animationTimingFunction(): CAMediaTimingFunction;
    static begin(): void;
    static commit(): void;
    static completionBlock(): () => void;
    static disableActions(): boolean;
    static flush(): void;
    static lock(): void;
    static setAnimationDuration(_: number): void;
    static setAnimationTimingFunction(_?: CAMediaTimingFunction): void;
    static setCompletionBlock(_?: () => void): void;
    static setDisableActions(_: boolean): void;
    static setValueForKey(_?: any, forKey?: string): void;
    static unlock(): void;
    static valueForKey(forKey: string): any;
  }

  // export function CATransform3DConcat(a: CATransform3D, b: CATransform3D): CATransform3D;

  // export function CATransform3DEqualToTransform(a: CATransform3D, b: CATransform3D): boolean;

  // export function CATransform3DGetAffineTransform(t: CATransform3D): CGAffineTransform;

  // export function CATransform3DInvert(t: CATransform3D): CATransform3D;

  // export function CATransform3DIsAffine(t: CATransform3D): boolean;

  // export function CATransform3DIsIdentity(t: CATransform3D): boolean;

  // export function CATransform3DMakeAffineTransform(m: CGAffineTransform): CATransform3D;

  // export function CATransform3DMakeRotation(angle: number, x: number, y: number, z: number): CATransform3D;

  // export function CATransform3DMakeScale(sx: number, sy: number, sz: number): CATransform3D;

  // export function CATransform3DMakeTranslation(tx: number, ty: number, tz: number): CATransform3D;

  // export function CATransform3DRotate(t: CATransform3D, angle: number, x: number, y: number, z: number): CATransform3D;

  // export function CATransform3DScale(t: CATransform3D, sx: number, sy: number, sz: number): CATransform3D;

  // export function CATransform3DTranslate(t: CATransform3D, tx: number, ty: number, tz: number): CATransform3D;

  // interface
  class CATransformLayer extends CALayer {
  }

  // interface
  class CATransition extends CAAnimation {
    endProgress: number;
    setEndProgress(_: number)
    filter: any;
    setFilter(_: any)
    startProgress: number;
    setStartProgress(_: number)
    subtype: string;
    setSubtype(_: string)
    type: string;
    setType(_: string)
  }

  // interface
  class CAValueFunction extends NSObject /* implements NSSecureCoding */ {
    name: string;
  }

  namespace AE {
    export enum AEDataModel { }
  }
  namespace AVAssetExportSession {
    export enum Status {
      Unknown = 0,
      Waiting = 1,
      Exporting = 2,
      Completed = 3,
      Failed = 4,
      Cancelled = 5
    }

  }

  namespace AVAssetImageGenerator {
    export enum Result {
      Succeeded = 0,
      Failed = 1,
      Cancelled = 2
    }

    export let cleanAperture: string;
    export let encodedPixels: string;
    export let productionAperture: string;
  }

  namespace AVAssetReader {
    export enum Status {
      Unknown = 0,
      Reading = 1,
      Completed = 2,
      Failed = 3,
      Cancelled = 4
    }

  }

  namespace AVAssetTrack {
    export let audioFallback: string;
    export let chapterList: string;
    export let forcedSubtitlesOnly: string;
    export let metadataReferent: string;
    export let selectionFollower: string;
    export let timecode: string;
  }

  namespace AVAssetWriter {
    export enum Status {
      Unknown = 0,
      Writing = 1,
      Completed = 2,
      Failed = 3,
      Cancelled = 4
    }

  }

  namespace AVAssetWriterInput {
    export let beforeMainMediaDataNotInterleaved: string;
    export let interleavedWithMainMediaData: string;
  }

  namespace AVAudioSession {
    export enum CategoryOptions {
      MixWithOthers = 1,
      DuckOthers = 2,
      AllowBluetooth = 4,
      DefaultToSpeaker = 8,
      InterruptSpokenAudioAndMixWithOthers = 17,
      AllowBluetoothA2DP = 32,
      AllowAirPlay = 64
    }

    export enum IOType {
      NotSpecified = 0,
      Aggregated = 1
    }

    export enum InterruptionOptions {
      ShouldResume = 1
    }

    export enum InterruptionType {
      Began = 1,
      Ended = 0
    }

    export enum PortOverride {
      None = 0,
      Speaker = 1936747378
    }

    export enum PromptStyle {
      None = 1852796517,
      Short = 1936224884,
      Normal = 1852992876
    }

    export enum RecordPermission {
      Undetermined = 1970168948,
      Denied = 1684369017,
      Granted = 1735552628
    }

    export enum RouteChangeReason {
      Unknown = 0,
      NewDeviceAvailable = 1,
      OldDeviceUnavailable = 2,
      CategoryChange = 3,
      Override = 4,
      WakeFromSleep = 6,
      NoSuitableRouteForCategory = 7,
      RouteConfigurationChange = 8
    }

    export enum RouteSharingPolicy {
      Default = 0,
      LongFormAudio = 1,
      LongForm = 1,
      Independent = 2,
      LongFormVideo = 3
    }

    export enum SetActiveOptions {
      NotifyOthersOnDeactivation = 1
    }

    export enum SilenceSecondaryAudioHintType {
      Begin = 1,
      End = 0
    }

    export let ambient: string;
    export let audioProcessing: string;
    export let multiRoute: string;
    export let playAndRecord: string;
    export let playback: string;
    export let record: string;
    export let soloAmbient: string;
    export let interruptionNotification: string;
    export let lower: string;
    export let upper: string;
    export let mediaServicesWereLostNotification: string;
    export let mediaServicesWereResetNotification: string;
    export let default_: string;
    export let gameChat: string;
    export let measurement: string;
    export let moviePlayback: string;
    export let spokenAudio: string;
    export let videoChat: string;
    export let videoRecording: string;
    export let voiceChat: string;
    export let voicePrompt: string;
    export let back: string;
    export let bottom: string;
    export let front: string;
    export let left: string;
    export let right: string;
    export let top: string;
    export let cardioid: string;
    export let omnidirectional: string;
    export let subcardioid: string;
    export let airPlay: string;
    export let bluetoothA2DP: string;
    export let bluetoothHFP: string;
    export let bluetoothLE: string;
    export let builtInMic: string;
    export let builtInReceiver: string;
    export let builtInSpeaker: string;
    export let carAudio: string;
    export let HDMI: string;
    export let headphones: string;
    export let headsetMic: string;
    export let lineIn: string;
    export let lineOut: string;
    export let usbAudio: string;
    export let routeChangeNotification: string;
    export let silenceSecondaryAudioHintNotification: string;
  }

  namespace AVAudioTimePitchAlgorithm {
    export let lowQualityZeroLatency: string;
    export let spectral: string;
    export let timeDomain: string;
    export let varispeed: string;
  }

  namespace AVAudioUnitComponentManager {
    export let registrationsChangedNotification: string;
  }

  namespace AVCaptureDevice {
    export enum AutoFocusRangeRestriction {
      None = 0,
      Near = 1,
      Far = 2
    }

    export enum Position {
      Unspecified = 0,
      Back = 1,
      Front = 2
    }

    export enum TransportControlsPlaybackMode {
      NotPlayingMode = 0,
      PlayingMode = 1
    }

    export enum ExposureMode {
      Locked = 0,
      AutoExpose = 1,
      ContinuousAutoExposure = 2,
      Custom = 3
    }

    export enum FlashMode {
      Off = 0,
      On = 1,
      Auto = 2
    }

    export enum FocusMode {
      Locked = 0,
      AutoFocus = 1,
      ContinuousAutoFocus = 2
    }

    export enum LensStabilizationStatus {
      Unsupported = 0,
      Off = 1,
      Active = 2,
      OutOfRange = 3,
      Unavailable = 4
    }

    export enum TorchMode {
      Off = 0,
      On = 1,
      Auto = 2
    }

    export enum WhiteBalanceMode {
      Locked = 0,
      AutoWhiteBalance = 1,
      ContinuousAutoWhiteBalance = 2
    }

    export let builtInDualCamera: string;
    export let builtInDualWideCamera: string;
    export let builtInDuoCamera: string;
    export let builtInMicrophone: string;
    export let builtInTelephotoCamera: string;
    export let builtInTripleCamera: string;
    export let builtInTrueDepthCamera: string;
    export let builtInUltraWideCamera: string;
    export let builtInWideAngleCamera: string;
    export let externalUnknown: string;
    export let currentExposureDuration: CMTime;
    export let currentExposureTargetBias: number;
    export let currentISO: number;
    export let currentLensPosition: number;
    export let maxAvailableTorchLevel: number;
    // export let currentWhiteBalanceGains: AVCaptureDevice.WhiteBalanceGains;
  }

  namespace AVCaptureOutput {
    export enum DataDroppedReason {
      None = 0,
      LateData = 1,
      OutOfBuffers = 2,
      Discontinuity = 3
    }

  }

  namespace AVCapturePhotoOutput {
    export enum QualityPrioritization {
      Speed = 1,
      Balanced = 2,
      Quality = 3
    }

  }

  namespace AVCaptureSession {
    export enum InterruptionReason {
      VideoDeviceNotAvailableInBackground = 1,
      AudioDeviceInUseByAnotherClient = 2,
      VideoDeviceInUseByAnotherClient = 3,
      VideoDeviceNotAvailableWithMultipleForegroundApps = 4,
      VideoDeviceNotAvailableDueToSystemPressure = 5
    }

    export let hd1280x720: string;
    export let hd1920x1080: string;
    export let qvga320x240: string;
    export let cif352x288: string;
    export let hd4K3840x2160: string;
    export let vga640x480: string;
    export let qHD960x540: string;
    export let high: string;
    export let inputPriority: string;
    export let low: string;
    export let medium: string;
    export let photo: string;
    export let iFrame1280x720: string;
    export let iFrame960x540: string;
  }

  namespace AVContentKeyRequest {
    export enum Status {
      RequestingResponse = 0,
      ReceivedResponse = 1,
      Renewed = 2,
      Retried = 3,
      Cancelled = 4,
      Failed = 5
    }

    export let receivedObsoleteContentKey: string;
    export let receivedResponseWithExpiredLease: string;
    export let timedOut: string;
  }

  namespace AVContentKeySessionServerPlaybackContextOption {
    export let protocolVersions: string;
    export let serverChallenge: string;
  }

  namespace AVContentKeySystem {
    export let authorizationToken: string;
    export let clearKey: string;
    export let fairPlayStreaming: string;
  }

  namespace AVDepthData {
    export enum Accuracy {
      Relative = 0,
      Absolute = 1
    }

    export enum Quality {
      Low = 0,
      High = 1
    }

  }

  namespace AVFileType {
    export let mobile3GPP: string;
    export let mobile3GPP2: string;
    export let ac3: string;
    export let aifc: string;
    export let aiff: string;
    export let amr: string;
    export let avci: string;
    export let m4a: string;
    export let m4v: string;
    export let caf: string;
    export let dng: string;
    export let eac3: string;
    export let heic: string;
    export let heif: string;
    export let jpg: string;
    export let mp4: string;
    export let mp3: string;
    export let mov: string;
    export let au: string;
    export let tif: string;
    export let wav: string;
  }

  namespace AVLayerVideoGravity {
    export let resize: string;
    export let resizeAspect: string;
    export let resizeAspectFill: string;
  }

  namespace AVMediaCharacteristic {
    export let audible: string;
    export let containsAlphaChannel: string;
    export let containsOnlyForcedSubtitles: string;
    export let describesMusicAndSoundForAccessibility: string;
    export let describesVideoForAccessibility: string;
    export let dubbedTranslation: string;
    export let easyToRead: string;
    export let frameBased: string;
    export let isAuxiliaryContent: string;
    export let isMainProgramContent: string;
    export let isOriginalContent: string;
    export let languageTranslation: string;
    export let legible: string;
    export let transcribesSpokenDialogForAccessibility: string;
    export let usesWideGamutColorSpace: string;
    export let visual: string;
    export let voiceOverTranslation: string;
  }

  namespace AVMediaType {
    export let audio: string;
    export let closedCaption: string;
    export let depthData: string;
    export let metadata: string;
    export let metadataObject: string;
    export let muxed: string;
    export let subtitle: string;
    export let text: string;
    export let timecode: string;
    export let video: string;
  }

  namespace AVMetadataExtraAttributeKey {
    export let baseURI: string;
    export let info: string;
    export let valueURI: string;
  }

  namespace AVMetadataFormat {
    export let hlsMetadata: string;
    export let id3Metadata: string;
    export let isoUserData: string;
    export let quickTimeMetadata: string;
    export let quickTimeUserData: string;
    export let unknown: string;
    export let iTunesMetadata: string;
  }

  namespace AVMetadataIdentifier {
    export let commonIdentifierAlbumName: string;
    export let commonIdentifierArtist: string;
    export let commonIdentifierArtwork: string;
    export let commonIdentifierAssetIdentifier: string;
    export let commonIdentifierAuthor: string;
    export let commonIdentifierContributor: string;
    export let commonIdentifierCopyrights: string;
    export let commonIdentifierCreationDate: string;
    export let commonIdentifierCreator: string;
    export let commonIdentifierDescription: string;
    export let commonIdentifierFormat: string;
    export let commonIdentifierLanguage: string;
    export let commonIdentifierLastModifiedDate: string;
    export let commonIdentifierLocation: string;
    export let commonIdentifierMake: string;
    export let commonIdentifierModel: string;
    export let commonIdentifierPublisher: string;
    export let commonIdentifierRelation: string;
    export let commonIdentifierSoftware: string;
    export let commonIdentifierSource: string;
    export let commonIdentifierSubject: string;
    export let commonIdentifierTitle: string;
    export let commonIdentifierType: string;
    export let identifier3GPUserDataAlbumAndTrack: string;
    export let identifier3GPUserDataAuthor: string;
    export let identifier3GPUserDataCollection: string;
    export let identifier3GPUserDataCopyright: string;
    export let identifier3GPUserDataDescription: string;
    export let identifier3GPUserDataGenre: string;
    export let identifier3GPUserDataKeywordList: string;
    export let identifier3GPUserDataLocation: string;
    export let identifier3GPUserDataMediaClassification: string;
    export let identifier3GPUserDataMediaRating: string;
    export let identifier3GPUserDataPerformer: string;
    export let identifier3GPUserDataRecordingYear: string;
    export let identifier3GPUserDataThumbnail: string;
    export let identifier3GPUserDataTitle: string;
    export let identifier3GPUserDataUserRating: string;
    export let id3MetadataAlbumSortOrder: string;
    export let id3MetadataAlbumTitle: string;
    export let id3MetadataAttachedPicture: string;
    export let id3MetadataAudioEncryption: string;
    export let id3MetadataAudioSeekPointIndex: string;
    export let id3MetadataBand: string;
    export let id3MetadataBeatsPerMinute: string;
    export let id3MetadataComments: string;
    export let id3MetadataCommercial: string;
    export let id3MetadataCommercialInformation: string;
    export let id3MetadataComposer: string;
    export let id3MetadataConductor: string;
    export let id3MetadataContentGroupDescription: string;
    export let id3MetadataContentType: string;
    export let id3MetadataCopyright: string;
    export let id3MetadataCopyrightInformation: string;
    export let id3MetadataDate: string;
    export let id3MetadataEncodedBy: string;
    export let id3MetadataEncodedWith: string;
    export let id3MetadataEncodingTime: string;
    export let id3MetadataEncryption: string;
    export let id3MetadataEqualization: string;
    export let id3MetadataEqualization2: string;
    export let id3MetadataEventTimingCodes: string;
    export let id3MetadataFileOwner: string;
    export let id3MetadataFileType: string;
    export let id3MetadataGeneralEncapsulatedObject: string;
    export let id3MetadataGroupIdentifier: string;
    export let id3MetadataInitialKey: string;
    export let id3MetadataInternationalStandardRecordingCode: string;
    export let id3MetadataInternetRadioStationName: string;
    export let id3MetadataInternetRadioStationOwner: string;
    export let id3MetadataInvolvedPeopleList_v23: string;
    export let id3MetadataInvolvedPeopleList_v24: string;
    export let id3MetadataLanguage: string;
    export let id3MetadataLeadPerformer: string;
    export let id3MetadataLength: string;
    export let id3MetadataLink: string;
    export let id3MetadataLyricist: string;
    export let id3MetadataMPEGLocationLookupTable: string;
    export let id3MetadataMediaType: string;
    export let id3MetadataModifiedBy: string;
    export let id3MetadataMood: string;
    export let id3MetadataMusicCDIdentifier: string;
    export let id3MetadataMusicianCreditsList: string;
    export let id3MetadataOfficialArtistWebpage: string;
    export let id3MetadataOfficialAudioFileWebpage: string;
    export let id3MetadataOfficialAudioSourceWebpage: string;
    export let id3MetadataOfficialInternetRadioStationHomepage: string;
    export let id3MetadataOfficialPublisherWebpage: string;
    export let id3MetadataOriginalAlbumTitle: string;
    export let id3MetadataOriginalArtist: string;
    export let id3MetadataOriginalFilename: string;
    export let id3MetadataOriginalLyricist: string;
    export let id3MetadataOriginalReleaseTime: string;
    export let id3MetadataOriginalReleaseYear: string;
    export let id3MetadataOwnership: string;
    export let id3MetadataPartOfASet: string;
    export let id3MetadataPayment: string;
    export let id3MetadataPerformerSortOrder: string;
    export let id3MetadataPlayCounter: string;
    export let id3MetadataPlaylistDelay: string;
    export let id3MetadataPopularimeter: string;
    export let id3MetadataPositionSynchronization: string;
    export let id3MetadataPrivate: string;
    export let id3MetadataProducedNotice: string;
    export let id3MetadataPublisher: string;
    export let id3MetadataRecommendedBufferSize: string;
    export let id3MetadataRecordingDates: string;
    export let id3MetadataRecordingTime: string;
    export let id3MetadataRelativeVolumeAdjustment: string;
    export let id3MetadataRelativeVolumeAdjustment2: string;
    export let id3MetadataReleaseTime: string;
    export let id3MetadataReverb: string;
    export let id3MetadataSeek: string;
    export let id3MetadataSetSubtitle: string;
    export let id3MetadataSignature: string;
    export let id3MetadataSize: string;
    export let id3MetadataSubTitle: string;
    export let id3MetadataSynchronizedLyric: string;
    export let id3MetadataSynchronizedTempoCodes: string;
    export let id3MetadataTaggingTime: string;
    export let id3MetadataTermsOfUse: string;
    export let id3MetadataTime: string;
    export let id3MetadataTitleDescription: string;
    export let id3MetadataTitleSortOrder: string;
    export let id3MetadataTrackNumber: string;
    export let id3MetadataUniqueFileIdentifier: string;
    export let id3MetadataUnsynchronizedLyric: string;
    export let id3MetadataUserText: string;
    export let id3MetadataUserURL: string;
    export let id3MetadataYear: string;
    export let isoUserDataCopyright: string;
    export let isoUserDataDate: string;
    export let isoUserDataTaggedCharacteristic: string;
    export let icyMetadataStreamTitle: string;
    export let icyMetadataStreamURL: string;
    export let quickTimeMetadataAlbum: string;
    export let quickTimeMetadataArranger: string;
    export let quickTimeMetadataArtist: string;
    export let quickTimeMetadataArtwork: string;
    export let quickTimeMetadataAuthor: string;
    export let quickTimeMetadataAutoLivePhoto: string;
    export let quickTimeMetadataCameraFrameReadoutTime: string;
    export let quickTimeMetadataCameraIdentifier: string;
    export let quickTimeMetadataCollectionUser: string;
    export let quickTimeMetadataComment: string;
    export let quickTimeMetadataComposer: string;
    export let quickTimeMetadataContentIdentifier: string;
    export let quickTimeMetadataCopyright: string;
    export let quickTimeMetadataCreationDate: string;
    export let quickTimeMetadataCredits: string;
    export let quickTimeMetadataDescription: string;
    export let quickTimeMetadataDetectedCatBody: string;
    export let quickTimeMetadataDetectedDogBody: string;
    export let quickTimeMetadataDetectedFace: string;
    export let quickTimeMetadataDetectedHumanBody: string;
    export let quickTimeMetadataDetectedSalientObject: string;
    export let quickTimeMetadataDirectionFacing: string;
    export let quickTimeMetadataDirectionMotion: string;
    export let quickTimeMetadataDirector: string;
    export let quickTimeMetadataDisplayName: string;
    export let quickTimeMetadataEncodedBy: string;
    export let quickTimeMetadataGenre: string;
    export let quickTimeMetadataInformation: string;
    export let quickTimeMetadataKeywords: string;
    export let quickTimeMetadataLivePhotoVitalityScore: string;
    export let quickTimeMetadataLivePhotoVitalityScoringVersion: string;
    export let quickTimeMetadataLocationBody: string;
    export let quickTimeMetadataLocationDate: string;
    export let quickTimeMetadataLocationISO6709: string;
    export let quickTimeMetadataLocationName: string;
    export let quickTimeMetadataLocationNote: string;
    export let quickTimeMetadataLocationRole: string;
    export let quickTimeMetadataMake: string;
    export let quickTimeMetadataModel: string;
    export let quickTimeMetadataOriginalArtist: string;
    export let quickTimeMetadataPerformer: string;
    export let quickTimeMetadataPhonogramRights: string;
    export let quickTimeMetadataPreferredAffineTransform: string;
    export let quickTimeMetadataProducer: string;
    export let quickTimeMetadataPublisher: string;
    export let quickTimeMetadataRatingUser: string;
    export let quickTimeMetadataSoftware: string;
    export let quickTimeMetadataSpatialOverCaptureQualityScore: string;
    export let quickTimeMetadataSpatialOverCaptureQualityScoringVersion: string;
    export let quickTimeMetadataTitle: string;
    export let quickTimeMetadataVideoOrientation: string;
    export let quickTimeMetadataYear: string;
    export let quickTimeMetadataiXML: string;
    export let quickTimeUserDataAlbum: string;
    export let quickTimeUserDataArranger: string;
    export let quickTimeUserDataArtist: string;
    export let quickTimeUserDataAuthor: string;
    export let quickTimeUserDataChapter: string;
    export let quickTimeUserDataComment: string;
    export let quickTimeUserDataComposer: string;
    export let quickTimeUserDataCopyright: string;
    export let quickTimeUserDataCreationDate: string;
    export let quickTimeUserDataCredits: string;
    export let quickTimeUserDataDescription: string;
    export let quickTimeUserDataDirector: string;
    export let quickTimeUserDataDisclaimer: string;
    export let quickTimeUserDataEncodedBy: string;
    export let quickTimeUserDataFullName: string;
    export let quickTimeUserDataGenre: string;
    export let quickTimeUserDataHostComputer: string;
    export let quickTimeUserDataInformation: string;
    export let quickTimeUserDataKeywords: string;
    export let quickTimeUserDataLocationISO6709: string;
    export let quickTimeUserDataMake: string;
    export let quickTimeUserDataModel: string;
    export let quickTimeUserDataOriginalArtist: string;
    export let quickTimeUserDataOriginalFormat: string;
    export let quickTimeUserDataOriginalSource: string;
    export let quickTimeUserDataPerformers: string;
    export let quickTimeUserDataPhonogramRights: string;
    export let quickTimeUserDataProducer: string;
    export let quickTimeUserDataProduct: string;
    export let quickTimeUserDataPublisher: string;
    export let quickTimeUserDataSoftware: string;
    export let quickTimeUserDataSpecialPlaybackRequirements: string;
    export let quickTimeUserDataTaggedCharacteristic: string;
    export let quickTimeUserDataTrack: string;
    export let quickTimeUserDataTrackName: string;
    export let quickTimeUserDataURLLink: string;
    export let quickTimeUserDataWarning: string;
    export let quickTimeUserDataWriter: string;
    export let iTunesMetadataAccountKind: string;
    export let iTunesMetadataAcknowledgement: string;
    export let iTunesMetadataAlbum: string;
    export let iTunesMetadataAlbumArtist: string;
    export let iTunesMetadataAppleID: string;
    export let iTunesMetadataArranger: string;
    export let iTunesMetadataArtDirector: string;
    export let iTunesMetadataArtist: string;
    export let iTunesMetadataArtistID: string;
    export let iTunesMetadataAuthor: string;
    export let iTunesMetadataBeatsPerMin: string;
    export let iTunesMetadataComposer: string;
    export let iTunesMetadataConductor: string;
    export let iTunesMetadataContentRating: string;
    export let iTunesMetadataCopyright: string;
    export let iTunesMetadataCoverArt: string;
    export let iTunesMetadataCredits: string;
    export let iTunesMetadataDescription: string;
    export let iTunesMetadataDirector: string;
    export let iTunesMetadataDiscCompilation: string;
    export let iTunesMetadataDiscNumber: string;
    export let iTunesMetadataEQ: string;
    export let iTunesMetadataEncodedBy: string;
    export let iTunesMetadataEncodingTool: string;
    export let iTunesMetadataExecProducer: string;
    export let iTunesMetadataGenreID: string;
    export let iTunesMetadataGrouping: string;
    export let iTunesMetadataLinerNotes: string;
    export let iTunesMetadataLyrics: string;
    export let iTunesMetadataOnlineExtras: string;
    export let iTunesMetadataOriginalArtist: string;
    export let iTunesMetadataPerformer: string;
    export let iTunesMetadataPhonogramRights: string;
    export let iTunesMetadataPlaylistID: string;
    export let iTunesMetadataPredefinedGenre: string;
    export let iTunesMetadataProducer: string;
    export let iTunesMetadataPublisher: string;
    export let iTunesMetadataRecordCompany: string;
    export let iTunesMetadataReleaseDate: string;
    export let iTunesMetadataSoloist: string;
    export let iTunesMetadataSongID: string;
    export let iTunesMetadataSongName: string;
    export let iTunesMetadataSoundEngineer: string;
    export let iTunesMetadataThanks: string;
    export let iTunesMetadataTrackNumber: string;
    export let iTunesMetadataTrackSubTitle: string;
    export let iTunesMetadataUserComment: string;
    export let iTunesMetadataUserGenre: string;
  }

  namespace AVMetadataKey {
    export let metadata3GPUserDataKeyAlbumAndTrack: string;
    export let metadata3GPUserDataKeyAuthor: string;
    export let metadata3GPUserDataKeyCollection: string;
    export let metadata3GPUserDataKeyCopyright: string;
    export let metadata3GPUserDataKeyDescription: string;
    export let metadata3GPUserDataKeyGenre: string;
    export let metadata3GPUserDataKeyKeywordList: string;
    export let metadata3GPUserDataKeyLocation: string;
    export let metadata3GPUserDataKeyMediaClassification: string;
    export let metadata3GPUserDataKeyMediaRating: string;
    export let metadata3GPUserDataKeyPerformer: string;
    export let metadata3GPUserDataKeyRecordingYear: string;
    export let metadata3GPUserDataKeyThumbnail: string;
    export let metadata3GPUserDataKeyTitle: string;
    export let metadata3GPUserDataKeyUserRating: string;
    export let commonKeyAlbumName: string;
    export let commonKeyArtist: string;
    export let commonKeyArtwork: string;
    export let commonKeyAuthor: string;
    export let commonKeyContributor: string;
    export let commonKeyCopyrights: string;
    export let commonKeyCreationDate: string;
    export let commonKeyCreator: string;
    export let commonKeyDescription: string;
    export let commonKeyFormat: string;
    export let commonKeyIdentifier: string;
    export let commonKeyLanguage: string;
    export let commonKeyLastModifiedDate: string;
    export let commonKeyLocation: string;
    export let commonKeyMake: string;
    export let commonKeyModel: string;
    export let commonKeyPublisher: string;
    export let commonKeyRelation: string;
    export let commonKeySoftware: string;
    export let commonKeySource: string;
    export let commonKeySubject: string;
    export let commonKeyTitle: string;
    export let commonKeyType: string;
    export let id3MetadataKeyAlbumSortOrder: string;
    export let id3MetadataKeyAlbumTitle: string;
    export let id3MetadataKeyAttachedPicture: string;
    export let id3MetadataKeyAudioEncryption: string;
    export let id3MetadataKeyAudioSeekPointIndex: string;
    export let id3MetadataKeyBand: string;
    export let id3MetadataKeyBeatsPerMinute: string;
    export let id3MetadataKeyComments: string;
    export let id3MetadataKeyCommercial: string;
    export let id3MetadataKeyCommercialInformation: string;
    export let id3MetadataKeyComposer: string;
    export let id3MetadataKeyConductor: string;
    export let id3MetadataKeyContentGroupDescription: string;
    export let id3MetadataKeyContentType: string;
    export let id3MetadataKeyCopyright: string;
    export let id3MetadataKeyCopyrightInformation: string;
    export let id3MetadataKeyDate: string;
    export let id3MetadataKeyEncodedBy: string;
    export let id3MetadataKeyEncodedWith: string;
    export let id3MetadataKeyEncodingTime: string;
    export let id3MetadataKeyEncryption: string;
    export let id3MetadataKeyEqualization: string;
    export let id3MetadataKeyEqualization2: string;
    export let id3MetadataKeyEventTimingCodes: string;
    export let id3MetadataKeyFileOwner: string;
    export let id3MetadataKeyFileType: string;
    export let id3MetadataKeyGeneralEncapsulatedObject: string;
    export let id3MetadataKeyGroupIdentifier: string;
    export let id3MetadataKeyInitialKey: string;
    export let id3MetadataKeyInternationalStandardRecordingCode: string;
    export let id3MetadataKeyInternetRadioStationName: string;
    export let id3MetadataKeyInternetRadioStationOwner: string;
    export let id3MetadataKeyInvolvedPeopleList_v23: string;
    export let id3MetadataKeyInvolvedPeopleList_v24: string;
    export let id3MetadataKeyLanguage: string;
    export let id3MetadataKeyLeadPerformer: string;
    export let id3MetadataKeyLength: string;
    export let id3MetadataKeyLink: string;
    export let id3MetadataKeyLyricist: string;
    export let id3MetadataKeyMPEGLocationLookupTable: string;
    export let id3MetadataKeyMediaType: string;
    export let id3MetadataKeyModifiedBy: string;
    export let id3MetadataKeyMood: string;
    export let id3MetadataKeyMusicCDIdentifier: string;
    export let id3MetadataKeyMusicianCreditsList: string;
    export let id3MetadataKeyOfficialArtistWebpage: string;
    export let id3MetadataKeyOfficialAudioFileWebpage: string;
    export let id3MetadataKeyOfficialAudioSourceWebpage: string;
    export let id3MetadataKeyOfficialInternetRadioStationHomepage: string;
    export let id3MetadataKeyOfficialPublisherWebpage: string;
    export let id3MetadataKeyOriginalAlbumTitle: string;
    export let id3MetadataKeyOriginalArtist: string;
    export let id3MetadataKeyOriginalFilename: string;
    export let id3MetadataKeyOriginalLyricist: string;
    export let id3MetadataKeyOriginalReleaseTime: string;
    export let id3MetadataKeyOriginalReleaseYear: string;
    export let id3MetadataKeyOwnership: string;
    export let id3MetadataKeyPartOfASet: string;
    export let id3MetadataKeyPayment: string;
    export let id3MetadataKeyPerformerSortOrder: string;
    export let id3MetadataKeyPlayCounter: string;
    export let id3MetadataKeyPlaylistDelay: string;
    export let id3MetadataKeyPopularimeter: string;
    export let id3MetadataKeyPositionSynchronization: string;
    export let id3MetadataKeyPrivate: string;
    export let id3MetadataKeyProducedNotice: string;
    export let id3MetadataKeyPublisher: string;
    export let id3MetadataKeyRecommendedBufferSize: string;
    export let id3MetadataKeyRecordingDates: string;
    export let id3MetadataKeyRecordingTime: string;
    export let id3MetadataKeyRelativeVolumeAdjustment: string;
    export let id3MetadataKeyRelativeVolumeAdjustment2: string;
    export let id3MetadataKeyReleaseTime: string;
    export let id3MetadataKeyReverb: string;
    export let id3MetadataKeySeek: string;
    export let id3MetadataKeySetSubtitle: string;
    export let id3MetadataKeySignature: string;
    export let id3MetadataKeySize: string;
    export let id3MetadataKeySubTitle: string;
    export let id3MetadataKeySynchronizedLyric: string;
    export let id3MetadataKeySynchronizedTempoCodes: string;
    export let id3MetadataKeyTaggingTime: string;
    export let id3MetadataKeyTermsOfUse: string;
    export let id3MetadataKeyTime: string;
    export let id3MetadataKeyTitleDescription: string;
    export let id3MetadataKeyTitleSortOrder: string;
    export let id3MetadataKeyTrackNumber: string;
    export let id3MetadataKeyUniqueFileIdentifier: string;
    export let id3MetadataKeyUnsynchronizedLyric: string;
    export let id3MetadataKeyUserText: string;
    export let id3MetadataKeyUserURL: string;
    export let id3MetadataKeyYear: string;
    export let isoUserDataKeyCopyright: string;
    export let isoUserDataKeyDate: string;
    export let isoUserDataKeyTaggedCharacteristic: string;
    export let icyMetadataKeyStreamTitle: string;
    export let icyMetadataKeyStreamURL: string;
    export let quickTimeMetadataKeyAlbum: string;
    export let quickTimeMetadataKeyArranger: string;
    export let quickTimeMetadataKeyArtist: string;
    export let quickTimeMetadataKeyArtwork: string;
    export let quickTimeMetadataKeyAuthor: string;
    export let quickTimeMetadataKeyCameraFrameReadoutTime: string;
    export let quickTimeMetadataKeyCameraIdentifier: string;
    export let quickTimeMetadataKeyCollectionUser: string;
    export let quickTimeMetadataKeyComment: string;
    export let quickTimeMetadataKeyComposer: string;
    export let quickTimeMetadataKeyContentIdentifier: string;
    export let quickTimeMetadataKeyCopyright: string;
    export let quickTimeMetadataKeyCreationDate: string;
    export let quickTimeMetadataKeyCredits: string;
    export let quickTimeMetadataKeyDescription: string;
    export let quickTimeMetadataKeyDirectionFacing: string;
    export let quickTimeMetadataKeyDirectionMotion: string;
    export let quickTimeMetadataKeyDirector: string;
    export let quickTimeMetadataKeyDisplayName: string;
    export let quickTimeMetadataKeyEncodedBy: string;
    export let quickTimeMetadataKeyGenre: string;
    export let quickTimeMetadataKeyInformation: string;
    export let quickTimeMetadataKeyKeywords: string;
    export let quickTimeMetadataKeyLocationBody: string;
    export let quickTimeMetadataKeyLocationDate: string;
    export let quickTimeMetadataKeyLocationISO6709: string;
    export let quickTimeMetadataKeyLocationName: string;
    export let quickTimeMetadataKeyLocationNote: string;
    export let quickTimeMetadataKeyLocationRole: string;
    export let quickTimeMetadataKeyMake: string;
    export let quickTimeMetadataKeyModel: string;
    export let quickTimeMetadataKeyOriginalArtist: string;
    export let quickTimeMetadataKeyPerformer: string;
    export let quickTimeMetadataKeyPhonogramRights: string;
    export let quickTimeMetadataKeyProducer: string;
    export let quickTimeMetadataKeyPublisher: string;
    export let quickTimeMetadataKeyRatingUser: string;
    export let quickTimeMetadataKeySoftware: string;
    export let quickTimeMetadataKeyTitle: string;
    export let quickTimeMetadataKeyYear: string;
    export let quickTimeMetadataKeyiXML: string;
    export let quickTimeUserDataKeyAlbum: string;
    export let quickTimeUserDataKeyArranger: string;
    export let quickTimeUserDataKeyArtist: string;
    export let quickTimeUserDataKeyAuthor: string;
    export let quickTimeUserDataKeyChapter: string;
    export let quickTimeUserDataKeyComment: string;
    export let quickTimeUserDataKeyComposer: string;
    export let quickTimeUserDataKeyCopyright: string;
    export let quickTimeUserDataKeyCreationDate: string;
    export let quickTimeUserDataKeyCredits: string;
    export let quickTimeUserDataKeyDescription: string;
    export let quickTimeUserDataKeyDirector: string;
    export let quickTimeUserDataKeyDisclaimer: string;
    export let quickTimeUserDataKeyEncodedBy: string;
    export let quickTimeUserDataKeyFullName: string;
    export let quickTimeUserDataKeyGenre: string;
    export let quickTimeUserDataKeyHostComputer: string;
    export let quickTimeUserDataKeyInformation: string;
    export let quickTimeUserDataKeyKeywords: string;
    export let quickTimeUserDataKeyLocationISO6709: string;
    export let quickTimeUserDataKeyMake: string;
    export let quickTimeUserDataKeyModel: string;
    export let quickTimeUserDataKeyOriginalArtist: string;
    export let quickTimeUserDataKeyOriginalFormat: string;
    export let quickTimeUserDataKeyOriginalSource: string;
    export let quickTimeUserDataKeyPerformers: string;
    export let quickTimeUserDataKeyPhonogramRights: string;
    export let quickTimeUserDataKeyProducer: string;
    export let quickTimeUserDataKeyProduct: string;
    export let quickTimeUserDataKeyPublisher: string;
    export let quickTimeUserDataKeySoftware: string;
    export let quickTimeUserDataKeySpecialPlaybackRequirements: string;
    export let quickTimeUserDataKeyTaggedCharacteristic: string;
    export let quickTimeUserDataKeyTrack: string;
    export let quickTimeUserDataKeyTrackName: string;
    export let quickTimeUserDataKeyURLLink: string;
    export let quickTimeUserDataKeyWarning: string;
    export let quickTimeUserDataKeyWriter: string;
    export let iTunesMetadataKeyAccountKind: string;
    export let iTunesMetadataKeyAcknowledgement: string;
    export let iTunesMetadataKeyAlbum: string;
    export let iTunesMetadataKeyAlbumArtist: string;
    export let iTunesMetadataKeyAppleID: string;
    export let iTunesMetadataKeyArranger: string;
    export let iTunesMetadataKeyArtDirector: string;
    export let iTunesMetadataKeyArtist: string;
    export let iTunesMetadataKeyArtistID: string;
    export let iTunesMetadataKeyAuthor: string;
    export let iTunesMetadataKeyBeatsPerMin: string;
    export let iTunesMetadataKeyComposer: string;
    export let iTunesMetadataKeyConductor: string;
    export let iTunesMetadataKeyContentRating: string;
    export let iTunesMetadataKeyCopyright: string;
    export let iTunesMetadataKeyCoverArt: string;
    export let iTunesMetadataKeyCredits: string;
    export let iTunesMetadataKeyDescription: string;
    export let iTunesMetadataKeyDirector: string;
    export let iTunesMetadataKeyDiscCompilation: string;
    export let iTunesMetadataKeyDiscNumber: string;
    export let iTunesMetadataKeyEQ: string;
    export let iTunesMetadataKeyEncodedBy: string;
    export let iTunesMetadataKeyEncodingTool: string;
    export let iTunesMetadataKeyExecProducer: string;
    export let iTunesMetadataKeyGenreID: string;
    export let iTunesMetadataKeyGrouping: string;
    export let iTunesMetadataKeyLinerNotes: string;
    export let iTunesMetadataKeyLyrics: string;
    export let iTunesMetadataKeyOnlineExtras: string;
    export let iTunesMetadataKeyOriginalArtist: string;
    export let iTunesMetadataKeyPerformer: string;
    export let iTunesMetadataKeyPhonogramRights: string;
    export let iTunesMetadataKeyPlaylistID: string;
    export let iTunesMetadataKeyPredefinedGenre: string;
    export let iTunesMetadataKeyProducer: string;
    export let iTunesMetadataKeyPublisher: string;
    export let iTunesMetadataKeyRecordCompany: string;
    export let iTunesMetadataKeyReleaseDate: string;
    export let iTunesMetadataKeySoloist: string;
    export let iTunesMetadataKeySongID: string;
    export let iTunesMetadataKeySongName: string;
    export let iTunesMetadataKeySoundEngineer: string;
    export let iTunesMetadataKeyThanks: string;
    export let iTunesMetadataKeyTrackNumber: string;
    export let iTunesMetadataKeyTrackSubTitle: string;
    export let iTunesMetadataKeyUserComment: string;
    export let iTunesMetadataKeyUserGenre: string;
  }

  namespace AVMetadataKeySpace {
    export let audioFile: string;
    export let common: string;
    export let hlsDateRange: string;
    export let id3: string;
    export let isoUserData: string;
    export let icy: string;
    export let quickTimeMetadata: string;
    export let quickTimeUserData: string;
    export let iTunes: string;
  }

  namespace AVMetadataObject {
    export let aztec: string;
    export let catBody: string;
    export let code128: string;
    export let code39: string;
    export let code39Mod43: string;
    export let code93: string;
    export let dataMatrix: string;
    export let dogBody: string;
    export let ean13: string;
    export let ean8: string;
    export let face: string;
    export let humanBody: string;
    export let itf14: string;
    export let interleaved2of5: string;
    export let pdf417: string;
    export let qr: string;
    export let salientObject: string;
    export let upce: string;
  }

  namespace AVOutputSettingsPreset {
    export let preset1280x720: string;
    export let preset1920x1080: string;
    export let preset3840x2160: string;
    export let preset640x480: string;
    export let preset960x540: string;
    export let hevc1920x1080: string;
    export let hevc1920x1080WithAlpha: string;
    export let hevc3840x2160: string;
    export let hevc3840x2160WithAlpha: string;
  }

  namespace AVPlayer {
    export enum ActionAtItemEnd {
      Advance = 0,
      Pause = 1,
      None = 2
    }

    export enum HDRMode {
      HLG = 1,
      HDR10 = 2,
      DolbyVision = 4
    }

    export enum Status {
      Unknown = 0,
      ReadyToPlay = 1,
      Failed = 2
    }

    export enum TimeControlStatus {
      Paused = 0,
      WaitingToPlayAtSpecifiedRate = 1,
      Playing = 2
    }

    export let eligibleForHDRPlaybackDidChangeNotification: string;
    export let toMinimizeStalls: string;
    export let evaluatingBufferingRate: string;
    export let noItemToPlay: string;
  }

  namespace AVPlayerItem {
    export enum Status {
      Unknown = 0,
      ReadyToPlay = 1,
      Failed = 2
    }

    export let mediaSelectionDidChangeNotification: string;
    export let recommendedTimeOffsetFromLiveDidChangeNotification: string;
  }

  namespace AVPlayerItemLegibleOutput {
    export let default_: string;
    export let sourceAndRulesOnly: string;
  }

  namespace AVPlayerLooper {
    export enum Status {
      Unknown = 0,
      Ready = 1,
      Failed = 2,
      Cancelled = 3
    }

  }

  namespace AVSampleBufferRenderSynchronizer {
    export let rateDidChangeNotification: string;
  }

  namespace AVSampleBufferRequest {
    export enum Direction {
      Forward = 1,
      None = 0,
      Reverse = -1
    }

    export enum Mode {
      Immediate = 0,
      Scheduled = 1,
      Opportunistic = 2
    }

  }

  namespace AVSemanticSegmentationMatte {
    export let hair: string;
    export let skin: string;
    export let teeth: string;
  }

  namespace AVVideoApertureMode {
    export let cleanAperture: string;
    export let encodedPixels: string;
    export let productionAperture: string;
  }

  namespace AVVideoCodecType {
    export let proRes422: string;
    export let proRes422HQ: string;
    export let proRes422LT: string;
    export let proRes422Proxy: string;
    export let proRes4444: string;
    export let h264: string;
    export let hevc: string;
    export let hevcWithAlpha: string;
    export let jpeg: string;
  }

  namespace Bundle {
    export let didLoadNotification: string;
  }

  namespace ByteCountFormatter {
    export enum CountStyle {
      File = 0,
      Memory = 1,
      Decimal = 2,
      Binary = 3
    }

    export enum Units {
      UseDefault = 0,
      UseBytes = 1,
      UseKB = 2,
      UseMB = 4,
      UseGB = 8,
      UseTB = 16,
      UsePB = 32,
      UseEB = 64,
      UseZB = 128,
      UseYBOrHigher = 65280,
      UseAll = 65535
    }

  }

  namespace CAAnimationCalculationMode {
    export let cubic: string;
    export let cubicPaced: string;
    export let discrete: string;
    export let linear: string;
    export let paced: string;
  }

  namespace CAAnimationRotationMode {
    export let rotateAuto: string;
    export let rotateAutoReverse: string;
  }

  namespace CAEmitterLayerEmitterMode {
    export let outline: string;
    export let points: string;
    export let surface: string;
    export let volume: string;
  }

  namespace CAEmitterLayerEmitterShape {
    export let circle: string;
    export let cuboid: string;
    export let line: string;
    export let point: string;
    export let rectangle: string;
    export let sphere: string;
  }

  namespace CAEmitterLayerRenderMode {
    export let additive: string;
    export let backToFront: string;
    export let oldestFirst: string;
    export let oldestLast: string;
    export let unordered: string;
  }

  namespace CAGradientLayerType {
    export let axial: string;
    export let conic: string;
    export let radial: string;
  }

  namespace CALayerContentsFilter {
    export let linear: string;
    export let nearest: string;
    export let trilinear: string;
  }

  namespace CALayerContentsFormat {
    export let gray8Uint: string;
    export let RGBA16Float: string;
    export let RGBA8Uint: string;
  }

  namespace CALayerContentsGravity {
    export let bottom: string;
    export let bottomLeft: string;
    export let bottomRight: string;
    export let center: string;
    export let left: string;
    export let resize: string;
    export let resizeAspect: string;
    export let resizeAspectFill: string;
    export let right: string;
    export let top: string;
    export let topLeft: string;
    export let topRight: string;
  }

  namespace CALayerCornerCurve {
    export let circular: string;
    export let continuous: string;
  }

  namespace CAMediaTimingFillMode {
    export let backwards: string;
    export let both: string;
    export let forwards: string;
    export let removed: string;
  }

  namespace CAMediaTimingFunctionName {
    export let default_: string;
    export let easeIn: string;
    export let easeInEaseOut: string;
    export let easeOut: string;
    export let linear: string;
  }

  namespace CAScrollLayerScrollMode {
    export let both: string;
    export let horizontally: string;
    export let none: string;
    export let vertically: string;
  }

  namespace CAShapeLayerFillRule {
    export let evenOdd: string;
    export let nonZero: string;
  }

  namespace CAShapeLayerLineCap {
    export let butt: string;
    export let round: string;
    export let square: string;
  }

  namespace CAShapeLayerLineJoin {
    export let bevel: string;
    export let miter: string;
    export let round: string;
  }

  namespace CATextLayerAlignmentMode {
    export let center: string;
    export let justified: string;
    export let left: string;
    export let natural: string;
    export let right: string;
  }

  namespace CATextLayerTruncationMode {
    export let end: string;
    export let middle: string;
    export let none: string;
    export let start: string;
  }

  namespace CATransitionSubtype {
    export let fromBottom: string;
    export let fromLeft: string;
    export let fromRight: string;
    export let fromTop: string;
  }

  namespace CATransitionType {
    export let fade: string;
    export let moveIn: string;
    export let push: string;
    export let reveal: string;
  }

  namespace CAValueFunctionName {
    export let rotateX: string;
    export let rotateY: string;
    export let rotateZ: string;
    export let scale: string;
    export let scaleX: string;
    export let scaleY: string;
    export let scaleZ: string;
    export let translate: string;
    export let translateX: string;
    export let translateY: string;
    export let translateZ: string;
  }

  namespace CFCalendarIdentifier {
    export let buddhistCalendar: any;
    export let chineseCalendar: any;
    export let gregorianCalendar: any;
    export let hebrewCalendar: any;
    export let cfiso8601Calendar: any;
    export let indianCalendar: any;
    export let islamicCalendar: any;
    export let islamicCivilCalendar: any;
    export let islamicTabularCalendar: any;
    export let islamicUmmAlQuraCalendar: any;
    export let japaneseCalendar: any;
    export let persianCalendar: any;
    export let republicOfChinaCalendar: any;
  }

  namespace CFDateFormatterKey {
    export let amSymbol: any;
    export let calendar: any;
    export let calendarName: any;
    export let defaultDate: any;
    export let defaultFormat: any;
    export let doesRelativeDateFormattingKey: any;
    export let eraSymbols: any;
    export let gregorianStartDate: any;
    export let isLenient: any;
    export let longEraSymbols: any;
    export let monthSymbols: any;
    export let pmSymbol: any;
    export let quarterSymbols: any;
    export let shortMonthSymbols: any;
    export let shortQuarterSymbols: any;
    export let shortStandaloneMonthSymbols: any;
    export let shortStandaloneQuarterSymbols: any;
    export let shortStandaloneWeekdaySymbols: any;
    export let shortWeekdaySymbols: any;
    export let standaloneMonthSymbols: any;
    export let standaloneQuarterSymbols: any;
    export let standaloneWeekdaySymbols: any;
    export let timeZone: any;
    export let twoDigitStartDate: any;
    export let veryShortMonthSymbols: any;
    export let veryShortStandaloneMonthSymbols: any;
    export let veryShortStandaloneWeekdaySymbols: any;
    export let veryShortWeekdaySymbols: any;
    export let weekdaySymbols: any;
  }

  namespace CFLocaleKey {
    export let alternateQuotationBeginDelimiterKey: any;
    export let alternateQuotationEndDelimiterKey: any;
    export let calendar: any;
    export let calendarIdentifier: any;
    export let collationIdentifier: any;
    export let collatorIdentifier: any;
    export let countryCode: any;
    export let currencyCode: any;
    export let currencySymbol: any;
    export let decimalSeparator: any;
    export let exemplarCharacterSet: any;
    export let groupingSeparator: any;
    export let identifier: any;
    export let languageCode: any;
    export let measurementSystem: any;
    export let quotationBeginDelimiterKey: any;
    export let quotationEndDelimiterKey: any;
    export let scriptCode: any;
    export let usesMetricSystem: any;
    export let variantCode: any;
  }

  namespace CFNotificationName {
    export let cfLocaleCurrentLocaleDidChange: any;
    export let cfTimeZoneSystemTimeZoneDidChange: any;
  }

  namespace CFNumberFormatterKey {
    export let alwaysShowDecimalSeparator: any;
    export let currencyCode: any;
    export let currencyDecimalSeparator: any;
    export let currencyGroupingSeparator: any;
    export let currencySymbol: any;
    export let decimalSeparator: any;
    export let defaultFormat: any;
    export let exponentSymbol: any;
    export let formatWidth: any;
    export let groupingSeparator: any;
    export let groupingSize: any;
    export let infinitySymbol: any;
    export let internationalCurrencySymbol: any;
    export let isLenient: any;
    export let maxFractionDigits: any;
    export let maxIntegerDigits: any;
    export let maxSignificantDigits: any;
    export let minFractionDigits: any;
    export let minIntegerDigits: any;
    export let minSignificantDigits: any;
    export let minusSign: any;
    export let multiplier: any;
    export let naNSymbol: any;
    export let negativePrefix: any;
    export let negativeSuffix: any;
    export let paddingCharacter: any;
    export let paddingPosition: any;
    export let perMillSymbol: any;
    export let percentSymbol: any;
    export let plusSign: any;
    export let positivePrefix: any;
    export let positiveSuffix: any;
    export let roundingIncrement: any;
    export let roundingMode: any;
    export let secondaryGroupingSize: any;
    export let useGroupingSeparator: any;
    export let useSignificantDigits: any;
    export let zeroSymbol: any;
  }

  namespace CFRunLoopMode {
    export let commonModes: any;
    export let defaultMode: any;
  }

  namespace CFStreamPropertyKey {
    export let appendToFile: any;
    export let dataWritten: any;
    export let fileCurrentOffset: any;
    export let socketNativeHandle: any;
    export let socketRemoteHostName: any;
    export let socketRemotePortNumber: any;
  }

  namespace CGAffineTransform {
    export let identity: CGAffineTransform;
  }

  namespace CGColor {
    export let __blackColorName: string;
    export let __clearColorName: string;
    export let conversionBlackPointCompensation: string;
    export let conversionTRCSize: string;
    export let __whiteColorName: string;
  }

  namespace CGColorSpace {
    export let acescgLinear: string;
    export let adobeRGB1998: string;
    export let dcip3: string;
    export let displayP3: string;
    export let displayP3_HLG: string;
    export let displayP3_PQ_EOTF: string;
    export let extendedGray: string;
    export let extendedLinearDisplayP3: string;
    export let extendedLinearGray: string;
    export let extendedLinearITUR_2020: string;
    export let extendedLinearSRGB: string;
    export let extendedSRGB: string;
    export let genericCMYK: string;
    export let genericGray: string;
    export let genericGrayGamma2_2: string;
    export let genericLab: string;
    export let genericRGB: string;
    export let genericRGBLinear: string;
    export let genericXYZ: string;
    export let itur_2020: string;
    export let itur_2020_HLG: string;
    export let itur_2020_PQ_EOTF: string;
    export let itur_709: string;
    export let linearGray: string;
    export let linearSRGB: string;
    export let rommrgb: string;
    export let sRGB: string;
  }

  namespace CGDisplayStream {
    export let colorSpace: string;
    export let destinationRect: string;
    export let minimumFrameTime: string;
    export let preserveAspectRatio: string;
    export let queueDepth: string;
    export let showCursor: string;
    export let sourceRect: string;
    export let yCbCrMatrix: string;
    export let yCbCrMatrix_ITU_R_601_4: string;
    export let yCbCrMatrix_ITU_R_709_2: string;
    export let yCbCrMatrix_SMPTE_240M_1995: string;
  }

  namespace CGFont {
    export let variationAxisDefaultValue: string;
    export let variationAxisMaxValue: string;
    export let variationAxisMinValue: string;
    export let variationAxisName: string;
  }

  namespace CGPDFTagProperty {
    export let actualText: any;
    export let alternativeText: any;
    export let languageText: any;
    export let titleText: any;
  }

  namespace CGPoint {
    export let zero: CGPoint;
  }

  namespace CGRect {
    export let infinite: CGRect;
    export let null_: CGRect;
    export let zero: CGRect;
  }

  namespace CGSize {
    export let zero: CGSize;
  }

  namespace CIContextOption {
    export let allowLowPower: string;
    export let cacheIntermediates: string;
    export let highQualityDownsample: string;
    export let outputColorSpace: string;
    export let outputPremultiplied: string;
    export let priorityRequestLow: string;
    export let useSoftwareRenderer: string;
    export let workingColorSpace: string;
    export let workingFormat: string;
  }

  namespace CIFormat {
    export let A16: number;
    export let A8: number;
    export let ABGR8: number;
    export let ARGB8: number;
    export let Af: number;
    export let Ah: number;
    export let BGRA8: number;
    export let L16: number;
    export let L8: number;
    export let LA16: number;
    export let LA8: number;
    export let LAf: number;
    export let LAh: number;
    export let Lf: number;
    export let Lh: number;
    export let R16: number;
    export let R8: number;
    export let RG16: number;
    export let RG8: number;
    export let RGBA16: number;
    export let RGBA8: number;
    export let RGBAf: number;
    export let RGBAh: number;
    export let RGf: number;
    export let RGh: number;
    export let Rf: number;
    export let Rh: number;
  }

  namespace CIImageAutoAdjustmentOption {
    export let crop: string;
    export let enhance: string;
    export let features: string;
    export let level: string;
    export let redEye: string;
  }

  namespace CIImageOption {
    export let applyOrientationProperty: string;
    export let auxiliaryDepth: string;
    export let auxiliaryDisparity: string;
    export let auxiliaryPortraitEffectsMatte: string;
    export let auxiliarySemanticSegmentationHairMatte: string;
    export let auxiliarySemanticSegmentationSkinMatte: string;
    export let auxiliarySemanticSegmentationTeethMatte: string;
    export let colorSpace: string;
    export let nearestSampling: string;
    export let properties: string;
    export let providerTileSize: string;
    export let providerUserInfo: string;
  }

  namespace CIImageRepresentationOption {
    export let avDepthData: string;
    export let avPortraitEffectsMatte: string;
    export let avSemanticSegmentationMattes: string;
    export let depthImage: string;
    export let disparityImage: string;
    export let portraitEffectsMatteImage: string;
    export let semanticSegmentationHairMatteImage: string;
    export let semanticSegmentationSkinMatteImage: string;
    export let semanticSegmentationTeethMatteImage: string;
  }

  namespace CIRAWFilterOption {
    export let activeKeys: string;
    export let allowDraftMode: string;
    export let baselineExposure: string;
    export let boostAmount: string;
    export let boostShadowAmount: string;
    export let colorNoiseReductionAmount: string;
    export let decoderVersion: string;
    export let disableGamutMap: string;
    export let enableChromaticNoiseTracking: string;
    export let enableSharpening: string;
    export let enableVendorLensCorrection: string;
    export let ignoreImageOrientation: string;
    export let imageOrientation: string;
    export let linearSpaceFilter: string;
    export let luminanceNoiseReductionAmount: string;
    export let moireAmount: string;
    export let neutralChromaticityX: string;
    export let neutralChromaticityY: string;
    export let neutralLocation: string;
    export let neutralTemperature: string;
    export let neutralTint: string;
    export let noiseReductionAmount: string;
    export let noiseReductionContrastAmount: string;
    export let noiseReductionDetailAmount: string;
    export let noiseReductionSharpnessAmount: string;
    export let scaleFactor: string;
    export let outputNativeSize: string;
    export let supportedDecoderVersions: string;
  }

  namespace CMImageDescriptionFlavor {
    export let mobile3GPFamily: any;
    export let isoFamily: any;
    export let quickTimeMovie: any;
  }

  namespace CMSampleTimingInfo {
    export let invalid: CMSampleTimingInfo;
  }

  namespace CMSoundDescriptionFlavor {
    export let mobile3GPFamily: any;
    export let isoFamily: any;
    export let quickTimeMovie: any;
    export let quickTimeMovieV2: any;
  }

  namespace CMTime {
    export let indefinite: CMTime;
    export let invalid: CMTime;
    export let negativeInfinity: CMTime;
    export let positiveInfinity: CMTime;
    export let zero: CMTime;
  }

  namespace CMTimeMapping {
    export let invalid: CMTimeMapping;
  }

  namespace CMTimeRange {
    export let invalid: CMTimeRange;
    export let zero: CMTimeRange;
  }

  namespace DateComponentsFormatter {
    export enum UnitsStyle {
      Positional = 0,
      Abbreviated = 1,
      Short = 2,
      Full = 3,
      SpellOut = 4,
      Brief = 5
    }

    export enum ZeroFormattingBehavior {
      None = 0,
      Default = 1,
      DropLeading = 2,
      DropMiddle = 4,
      DropTrailing = 8,
      DropAll = 14,
      Pad = 65536
    }

  }

  namespace DateFormatter {
    export enum Behavior {
      BehaviorDefault = 0,
      Behavior10_0 = 1000,
      Behavior10_4 = 1040
    }

    export enum Style {
      NoStyle = 0,
      ShortStyle = 1,
      MediumStyle = 2,
      LongStyle = 3,
      FullStyle = 4
    }

  }

  namespace DateIntervalFormatter {
    export enum Style {
      NoStyle = 0,
      ShortStyle = 1,
      MediumStyle = 2,
      LongStyle = 3,
      FullStyle = 4
    }

  }

  namespace Decimal {
    export type RoundingMode = NSDecimalNumber;
    export type CalculationError = NSDecimalNumber;
    export type FloatLiteralType = number;
    export type IntegerLiteralType = number;
    export type Magnitude = number;
    export type Stride = number;
  }

  namespace DistributedNotificationCenter {
    export enum Options {
      DeliverImmediately = 1,
      PostToAllSessions = 2
    }

    export enum SuspensionBehavior {
      Drop = 1,
      Coalesce = 2,
      Hold = 3,
      DeliverImmediately = 4
    }

    export let localNotificationCenterType: string;
  }

  namespace EnergyFormatter {
    export enum Unit {
      Joule = 11,
      Kilojoule = 14,
      Calorie = 1793,
      Kilocalorie = 1794
    }

  }

  namespace FileAttributeKey {
    export let appendOnly: string;
    export let busy: string;
    export let creationDate: string;
    export let deviceIdentifier: string;
    export let extensionHidden: string;
    export let groupOwnerAccountID: string;
    export let groupOwnerAccountName: string;
    export let hfsCreatorCode: string;
    export let hfsTypeCode: string;
    export let immutable: string;
    export let modificationDate: string;
    export let ownerAccountID: string;
    export let ownerAccountName: string;
    export let posixPermissions: string;
    export let protectionKey: string;
    export let referenceCount: string;
    export let size: string;
    export let systemFileNumber: string;
    export let systemFreeNodes: string;
    export let systemFreeSize: string;
    export let systemNodes: string;
    export let systemNumber: string;
    export let systemSize: string;
    export let type: string;
  }

  namespace FileAttributeType {
    export let typeBlockSpecial: string;
    export let typeCharacterSpecial: string;
    export let typeDirectory: string;
    export let typeRegular: string;
    export let typeSocket: string;
    export let typeSymbolicLink: string;
    export let typeUnknown: string;
  }

  namespace FileHandle {
    export let readCompletionNotification: string;
  }

  namespace FileManager {
    export enum DirectoryEnumerationOptions {
      SkipsSubdirectoryDescendants = 1,
      SkipsPackageDescendants = 2,
      SkipsHiddenFiles = 4,
      IncludesDirectoriesPostOrder = 8,
      ProducesRelativePathURLs = 16
    }

    export enum ItemReplacementOptions {
      UsingNewMetadataOnly = 1,
      WithoutDeletingBackupItem = 2
    }

    export enum UnmountOptions {
      AllPartitionsAndEjectDisk = 1,
      WithoutUI = 2
    }

    export enum SearchPathDirectory {
      ApplicationDirectory = 1,
      DemoApplicationDirectory = 2,
      DeveloperApplicationDirectory = 3,
      AdminApplicationDirectory = 4,
      LibraryDirectory = 5,
      DeveloperDirectory = 6,
      UserDirectory = 7,
      DocumentationDirectory = 8,
      DocumentDirectory = 9,
      CoreServiceDirectory = 10,
      AutosavedInformationDirectory = 11,
      DesktopDirectory = 12,
      CachesDirectory = 13,
      ApplicationSupportDirectory = 14,
      DownloadsDirectory = 15,
      InputMethodsDirectory = 16,
      MoviesDirectory = 17,
      MusicDirectory = 18,
      PicturesDirectory = 19,
      PrinterDescriptionDirectory = 20,
      SharedPublicDirectory = 21,
      PreferencePanesDirectory = 22,
      ApplicationScriptsDirectory = 23,
      ItemReplacementDirectory = 99,
      AllApplicationsDirectory = 100,
      AllLibrariesDirectory = 101,
      TrashDirectory = 102
    }

    export enum SearchPathDomainMask {
      UserDomainMask = 1,
      LocalDomainMask = 2,
      NetworkDomainMask = 4,
      SystemDomainMask = 8,
      AllDomainsMask = 65535
    }

    export enum URLRelationship {
      Contains = 0,
      Same = 1,
      Other = 2
    }

    export enum VolumeEnumerationOptions {
      SkipHiddenVolumes = 2,
      ProduceFileReferenceURLs = 4
    }

  }

  namespace FileProtectionType {
    export let complete: string;
    export let completeUnlessOpen: string;
    export let completeUntilFirstUserAuthentication: string;
    export let none: string;
  }

  namespace FileWrapper {
    export enum ReadingOptions {
      Immediate = 1,
      WithoutMapping = 2
    }

    export enum WritingOptions {
      Atomic = 1,
      WithNameUpdating = 2
    }

  }

  namespace Formatter {
    export enum Context {
      Unknown = 0,
      Dynamic = 1,
      Standalone = 2,
      ListItem = 3,
      BeginningOfSentence = 4,
      MiddleOfSentence = 5
    }

    export enum UnitStyle {
      Short = 1,
      Medium = 2,
      Long = 3
    }

  }

  namespace HTTPCookie {
    export enum AcceptPolicy {
      Always = 0,
      Never = 1,
      OnlyFromMainDocumentDomain = 2
    }

  }

  namespace HTTPCookiePropertyKey {
    export let comment: string;
    export let commentURL: string;
    export let discard: string;
    export let domain: string;
    export let expires: string;
    export let maximumAge: string;
    export let name: string;
    export let originURL: string;
    export let path: string;
    export let port: string;
    export let sameSitePolicy: string;
    export let secure: string;
    export let value: string;
    export let version: string;
  }

  namespace HTTPCookieStringPolicy {
    export let sameSiteLax: string;
    export let sameSiteStrict: string;
  }

  namespace ISO8601DateFormatter {
    export enum Options {
      WithYear = 1,
      WithMonth = 2,
      WithWeekOfYear = 4,
      WithDay = 16,
      WithTime = 32,
      WithTimeZone = 64,
      WithSpaceBetweenDateAndTime = 128,
      WithDashSeparatorInDate = 256,
      WithColonSeparatorInTime = 512,
      WithColonSeparatorInTimeZone = 1024,
      WithFractionalSeconds = 2048,
      WithFullDate = 275,
      WithFullTime = 1632,
      WithInternetDateTime = 1907
    }

  }

  namespace JSONSerialization {
    export enum ReadingOptions {
      MutableContainers = 1,
      MutableLeaves = 2,
      FragmentsAllowed = 4,
      AllowFragments = 4
    }

    export enum WritingOptions {
      PrettyPrinted = 1,
      SortedKeys = 2,
      FragmentsAllowed = 4,
      WithoutEscapingSlashes = 8
    }

  }

  namespace LengthFormatter {
    export enum Unit {
      Millimeter = 8,
      Centimeter = 9,
      Meter = 11,
      Kilometer = 14,
      Inch = 1281,
      Foot = 1282,
      Yard = 1283,
      Mile = 1284
    }

  }

  namespace MassFormatter {
    export enum Unit {
      Gram = 11,
      Kilogram = 14,
      Ounce = 1537,
      Pound = 1538,
      Stone = 1539
    }

  }

  namespace MeasurementFormatter {
    export enum UnitOptions {
      ProvidedUnit = 1,
      NaturalScale = 2,
      TemperatureWithoutUnit = 4
    }

  }

  namespace NSAccessibility {
    export enum AnnotationPosition {
      FullRange = 0,
      Start = 1,
      End = 2
    }

    export enum Orientation {
      Unknown = 0,
      Vertical = 1,
      Horizontal = 2
    }

    export enum RulerMarkerType {
      Unknown = 0,
      TabStopLeft = 1,
      TabStopRight = 2,
      TabStopCenter = 3,
      TabStopDecimal = 4,
      IndentHead = 5,
      IndentTail = 6,
      IndentFirstLine = 7
    }

    export enum SortDirection {
      Unknown = 0,
      Ascending = 1,
      Descending = 2
    }

    export enum Units {
      Unknown = 0,
      Inches = 1,
      Centimeters = 2,
      Points = 3,
      Picas = 4
    }

    export let activationPoint: string;
    export let allowedValues: string;
    export let alternateUIVisible: string;
    export let element: string;
    export let label: string;
    export let location: string;
    export let announcement: string;
    export let announcementRequested: string;
    export let applicationActivated: string;
    export let applicationDeactivated: string;
    export let applicationHidden: string;
    export let application: string;
    export let applicationShown: string;
    export let ascending: string;
    export let attributedStringForRange: string;
    export let boundsForRange: string;
    export let browser: string;
    export let busyIndicator: string;
    export let button: string;
    export let cancel: string;
    export let cancelButton: string;
    export let cellForColumnAndRow: string;
    export let cell: string;
    export let centerTabStop: string;
    export let centimeters: string;
    export let checkBox: string;
    export let children: string;
    export let clearButton: string;
    export let closeButton: string;
    export let collectionListSubrole: string;
    export let colorWell: string;
    export let columnCount: string;
    export let columnHeaderUIElements: string;
    export let columnIndexRange: string;
    export let column: string;
    export let columnTitles: string;
    export let columns: string;
    export let comboBox: string;
    export let confirm: string;
    export let containsProtectedContent: string;
    export let contentList: string;
    export let contents: string;
    export let created: string;
    export let criticalValue: string;
    export let decimalTabStop: string;
    export let decrement: string;
    export let decrementArrow: string;
    export let decrementButton: string;
    export let decrementPage: string;
    export let defaultButton: string;
    export let definitionList: string;
    export let delete_: string;
    export let descending: string;
    export let description: string;
    export let descriptionList: string;
    export let dialog: string;
    export let disclosedByRow: string;
    export let disclosedRows: string;
    export let disclosing: string;
    export let disclosureLevel: string;
    export let disclosureTriangle: string;
    export let document: string;
    export let drawerCreated: string;
    export let drawer: string;
    export let edited: string;
    export let enabled: string;
    export let ErrorCodeExceptionInfo: string;
    export let expanded: string;
    export let extrasMenuBar: string;
    export let filename: string;
    export let firstLineIndent: string;
    export let floatingWindow: string;
    export let focused: string;
    export let focusedUIElement: string;
    export let focusedUIElementChanged: string;
    export let focusedWindow: string;
    export let focusedWindowChanged: string;
    export let fontFamily: string;
    export let fontName: string;
    export let fontSize: string;
    export let frontmost: string;
    export let fullScreenButton: string;
    export let grid: string;
    export let group: string;
    export let growArea: string;
    export let handle: string;
    export let handles: string;
    export let headIndent: string;
    export let header: string;
    export let help: string;
    export let helpTagCreated: string;
    export let helpTag: string;
    export let hidden: string;
    export let horizontal: string;
    export let horizontalScrollBar: string;
    export let horizontalUnitDescription: string;
    export let horizontalUnits: string;
    export let identifier: string;
    export let image: string;
    export let inches: string;
    export let increment: string;
    export let incrementArrow: string;
    export let incrementButton: string;
    export let incrementPage: string;
    export let incrementor: string;
    export let index: string;
    export let insertionPointLineNumber: string;
    export let labelUIElements: string;
    export let labelValue: string;
    export let layoutArea: string;
    export let layoutChanged: string;
    export let layoutItem: string;
    export let layoutPointForScreenPoint: string;
    export let layoutSizeForScreenSize: string;
    export let leftTabStop: string;
    export let levelIndicator: string;
    export let lineForIndex: string;
    export let link: string;
    export let linkedUIElements: string;
    export let list: string;
    export let main: string;
    export let mainWindow: string;
    export let mainWindowChanged: string;
    export let markerGroupUIElement: string;
    export let markerType: string;
    export let markerTypeDescription: string;
    export let markerUIElements: string;
    export let markerValues: string;
    export let matte: string;
    export let maxValue: string;
    export let menuBar: string;
    export let menuBarItem: string;
    export let menuButton: string;
    export let menuItem: string;
    export let menu: string;
    export let minValue: string;
    export let minimizeButton: string;
    export let minimized: string;
    export let modal: string;
    export let moved: string;
    export let nextContents: string;
    export let numberOfCharacters: string;
    export let orderedByRow: string;
    export let orientation: string;
    export let outline: string;
    export let outlineRow: string;
    export let overflowButton: string;
    export let pageRole: string;
    export let parent: string;
    export let picas: string;
    export let pick: string;
    export let placeholderValue: string;
    export let points: string;
    export let popUpButton: string;
    export let popover: string;
    export let position: string;
    export let press: string;
    export let previousContents: string;
    export let priority: string;
    export let progressIndicator: string;
    export let proxy: string;
    export let rtfForRange: string;
    export let radioButton: string;
    export let radioGroup: string;
    export let raise: string;
    export let rangeForIndex: string;
    export let rangeForLine: string;
    export let rangeForPosition: string;
    export let ratingIndicator: string;
    export let relevanceIndicator: string;
    export let required: string;
    export let resized: string;
    export let rightTabStop: string;
    export let role: string;
    export let roleDescription: string;
    export let rowCollapsed: string;
    export let rowCount: string;
    export let rowCountChanged: string;
    export let rowExpanded: string;
    export let rowHeaderUIElements: string;
    export let rowIndexRange: string;
    export let row: string;
    export let rows: string;
    export let rulerMarker: string;
    export let ruler: string;
    export let screenPointForLayoutPoint: string;
    export let screenSizeForLayoutSize: string;
    export let scrollArea: string;
    export let scrollBar: string;
    export let searchButton: string;
    export let searchField: string;
    export let searchMenu: string;
    export let sectionListSubrole: string;
    export let secureTextField: string;
    export let selected: string;
    export let selectedCells: string;
    export let selectedCellsChanged: string;
    export let selectedChildren: string;
    export let selectedChildrenChanged: string;
    export let selectedChildrenMoved: string;
    export let selectedColumns: string;
    export let selectedColumnsChanged: string;
    export let selectedRows: string;
    export let selectedRowsChanged: string;
    export let selectedText: string;
    export let selectedTextChanged: string;
    export let selectedTextRange: string;
    export let selectedTextRanges: string;
    export let servesAsTitleForUIElements: string;
    export let sharedCharacterRange: string;
    export let sharedFocusElements: string;
    export let sharedTextUIElements: string;
    export let sheetCreated: string;
    export let sheet: string;
    export let showAlternateUI: string;
    export let showDefaultUI: string;
    export let showMenu: string;
    export let shownMenu: string;
    export let size: string;
    export let slider: string;
    export let sortButton: string;
    export let sortDirection: string;
    export let splitGroup: string;
    export let splitter: string;
    export let splitters: string;
    export let standardWindow: string;
    export let staticText: string;
    export let stringForRange: string;
    export let styleRangeForIndex: string;
    export let subrole: string;
    export let switch_: string;
    export let systemDialog: string;
    export let systemFloatingWindow: string;
    export let systemWide: string;
    export let tabButtonSubrole: string;
    export let tabGroup: string;
    export let table: string;
    export let tableRow: string;
    export let tabs: string;
    export let tailIndent: string;
    export let textArea: string;
    export let textAttachment: string;
    export let textField: string;
    export let textLink: string;
    export let timeline: string;
    export let title: string;
    export let titleChanged: string;
    export let titleUIElement: string;
    export let toggle: string;
    export let toolbarButton: string;
    export let toolbar: string;
    export let topLevelUIElement: string;
    export let uiElementDestroyed: string;
    export let uiElements: string;
    export let url: string;
    export let unitDescription: string;
    export let units: string;
    export let unitsChanged: string;
    export let unknown: string;
    export let value: string;
    export let valueChanged: string;
    export let valueDescription: string;
    export let valueIndicator: string;
    export let vertical: string;
    export let verticalScrollBar: string;
    export let verticalUnitDescription: string;
    export let verticalUnits: string;
    export let visibleCells: string;
    export let visibleCharacterRange: string;
    export let visibleChildren: string;
    export let visibleColumns: string;
    export let visibleName: string;
    export let visibleRows: string;
    export let warningValue: string;
    export let window: string;
    export let windowCreated: string;
    export let windowDeminiaturized: string;
    export let windowMiniaturized: string;
    export let windowMoved: string;
    export let windowResized: string;
    export let windows: string;
    export let zoomButton: string;
  }

  namespace NSAccessibilityCustomRotor {
    export enum SearchDirection {
      Previous = 0,
      Next = 1
    }

    export enum RotorType {
      Custom = 0,
      Any = 1,
      Annotation = 2,
      BoldText = 3,
      Heading = 4,
      HeadingLevel1 = 5,
      HeadingLevel2 = 6,
      HeadingLevel3 = 7,
      HeadingLevel4 = 8,
      HeadingLevel5 = 9,
      HeadingLevel6 = 10,
      Image = 11,
      ItalicText = 12,
      Landmark = 13,
      Link = 14,
      List = 15,
      MisspelledWord = 16,
      Table = 17,
      TextField = 18,
      UnderlinedText = 19,
      VisitedLink = 20
    }

  }

  namespace NSAlert {
    export enum Style {
      Warning = 0,
      Informational = 1,
      Critical = 2
    }

  }

  namespace NSAnimation {
    export enum BlockingMode {
      Blocking = 0,
      Nonblocking = 1,
      NonblockingThreaded = 2
    }

    export enum Curve {
      EaseInOut = 0,
      EaseIn = 1,
      EaseOut = 2,
      Linear = 3
    }

    export let progressMarkUserInfoKey: string;
    export let progressMarkNotification: string;
    export type Progress = number;
  }

  namespace NSAppKitVersion {
    export let current: number;
    export let macOS10_0: number;
    export let macOS10_1: number;
    export let macOS10_10: number;
    export let macOS10_10_2: number;
    export let macOS10_10_3: number;
    export let macOS10_10_4: number;
    export let macOS10_10_5: number;
    export let macOS10_10_Max: number;
    export let macOS10_11: number;
    export let macOS10_11_1: number;
    export let macOS10_11_2: number;
    export let macOS10_11_3: number;
    export let macOS10_12: number;
    export let macOS10_12_1: number;
    export let macOS10_12_2: number;
    export let macOS10_13: number;
    export let macOS10_13_1: number;
    export let macOS10_13_2: number;
    export let macOS10_13_4: number;
    export let number10_14: number;
    export let number10_14_1: number;
    export let number10_14_2: number;
    export let number10_14_3: number;
    export let number10_14_4: number;
    export let number10_14_5: number;
    export let macOS10_2: number;
    export let macOS10_2_3: number;
    export let macOS10_3: number;
    export let macOS10_3_2: number;
    export let macOS10_3_3: number;
    export let macOS10_3_5: number;
    export let macOS10_3_7: number;
    export let macOS10_3_9: number;
    export let macOS10_4: number;
    export let macOS10_4_1: number;
    export let macOS10_4_3: number;
    export let macOS10_4_4: number;
    export let macOS10_4_7: number;
    export let macOS10_5: number;
    export let macOS10_5_2: number;
    export let macOS10_5_3: number;
    export let macOS10_6: number;
    export let macOS10_7: number;
    export let macOS10_7_2: number;
    export let macOS10_7_3: number;
    export let macOS10_7_4: number;
    export let macOS10_8: number;
    export let macOS10_9: number;
    export let numberWithColumnResizingBrowser: number;
    export let numberWithContinuousScrollingBrowser: number;
    export let numberWithCursorSizeSupport: number;
    export let numberWithCustomSheetPosition: number;
    export let numberWithDeferredWindowDisplaySupport: number;
    export let numberWithDirectionalTabs: number;
    export let numberWithDockTilePlugInSupport: number;
    export let numberWithPatternColorLeakFix: number;
  }

  namespace NSAppearance {
    export let accessibilityHighContrastAqua: string;
    export let accessibilityHighContrastDarkAqua: string;
    export let accessibilityHighContrastVibrantDark: string;
    export let accessibilityHighContrastVibrantLight: string;
    export let aqua: string;
    export let darkAqua: string;
    export let vibrantDark: string;
    export let vibrantLight: string;
  }

  namespace NSAppleEventDescriptor {
    export enum SendOptions {
      NoReply = 1,
      QueueReply = 2,
      WaitForReply = 3,
      NeverInteract = 16,
      CanInteract = 32,
      AlwaysInteract = 48,
      CanSwitchLayer = 64,
      DontRecord = 4096,
      DontExecute = 8192,
      DontAnnotate = 65536,
      DefaultOptions = 35
    }

  }

  namespace NSAppleEventManager {
    export type SuspensionID = OpaquePointer;
  }

  namespace NSAppleScript {
    export let errorAppName: string;
    export let errorBriefMessage: string;
    export let errorMessage: string;
    export let errorNumber: string;
    export let errorRange: string;
  }

  namespace NSApplication {
    export enum ActivationOptions {
      ActivateAllWindows = 1,
      ActivateIgnoringOtherApps = 2
    }

    export enum ActivationPolicy {
      Regular = 0,
      Accessory = 1,
      Prohibited = 2
    }

    export enum DelegateReply {
      Success = 0,
      Cancel = 1,
      Failure = 2
    }

    export enum OcclusionState {
      Visible = 2
    }

    export enum PresentationOptions {
      Default = 0,
      AutoHideDock = 1,
      HideDock = 2,
      AutoHideMenuBar = 4,
      HideMenuBar = 8,
      DisableAppleMenu = 16,
      DisableProcessSwitching = 32,
      DisableForceQuit = 64,
      DisableSessionTermination = 128,
      DisableHideApplication = 256,
      DisableMenuBarTransparency = 512,
      FullScreen = 1024,
      AutoHideToolbar = 2048,
      DisableCursorLocationAssistance = 4096
    }

    export enum PrintReply {
      PrintingCancelled = 0,
      PrintingSuccess = 1,
      PrintingFailure = 3,
      PrintingReplyLater = 2
    }

    export enum TerminateReply {
      TerminateCancel = 0,
      TerminateNow = 1,
      TerminateLater = 2
    }

    export enum RemoteNotificationType {
      None = 0,
      Badge = 1,
      Sound = 2,
      Alert = 4
    }

    export enum RequestUserAttentionType {
      CriticalRequest = 0,
      InformationalRequest = 10
    }

    export enum WindowListOptions {
      OrderedFrontToBack = 1
    }

    export let applicationIcon: string;
    export let applicationName: string;
    export let applicationVersion: string;
    export let credits: string;
    export let version: string;
    export let alertFirstButtonReturn: number;
    export let alertSecondButtonReturn: number;
    export let alertThirdButtonReturn: number;
    export let didBecomeActiveNotification: string;
    export let didChangeOcclusionStateNotification: string;
    export let didChangeScreenParametersNotification: string;
    export let didFinishLaunchingNotification: string;
    export let didFinishRestoringWindowsNotification: string;
    export let didHideNotification: string;
    export let didResignActiveNotification: string;
    export let didUnhideNotification: string;
    export let didUpdateNotification: string;
    export let launchIsDefaultUserInfoKey: string;
    export let launchUserNotificationUserInfoKey: string;
    export let willBecomeActiveNotification: string;
    export let willFinishLaunchingNotification: string;
    export let willHideNotification: string;
    export let willResignActiveNotification: string;
    export let willTerminateNotification: string;
    export let willUnhideNotification: string;
    export let willUpdateNotification: string;
    export let abort: number;
    export let cancel: number;
    export let continue_: number;
    export let OK: number;
    export let stop: number;
    export type ModalSession = OpaquePointer;
  }

  namespace NSArray {
    export type Iterator = NSFastEnumerationIterator;
  }

  namespace NSAttributedString {
    export enum SpellingState {
      SpellingFlag = 1,
      GrammarFlag = 2
    }

    export enum EnumerationOptions {
      Reverse = 2,
      LongestEffectiveRangeNotRequired = 1048576
    }

    export let accessibilityAnnotationTextAttribute: string;
    export let accessibilityAttachment: string;
    export let accessibilityAutocorrected: string;
    export let accessibilityBackgroundColor: string;
    export let accessibilityCustomText: string;
    export let accessibilityFont: string;
    export let accessibilityForegroundColor: string;
    export let accessibilityLanguage: string;
    export let accessibilityLink: string;
    export let accessibilityListItemIndex: string;
    export let accessibilityListItemLevel: string;
    export let accessibilityListItemPrefix: string;
    export let accessibilityMarkedMisspelled: string;
    export let accessibilityMisspelled: string;
    export let accessibilityShadow: string;
    export let accessibilityStrikethroughColor: string;
    export let accessibilityStrikethrough: string;
    export let accessibilitySuperscript: string;
    export let accessibilityAlignment: string;
    export let accessibilityUnderlineColor: string;
    export let accessibilityUnderline: string;
    export let appearance: string;
    export let attachment: string;
    export let author: string;
    export let backgroundColor: string;
    export let baseURL: string;
    export let baselineOffset: string;
    export let bottomMargin: string;
    export let category: string;
    export let characterEncoding: string;
    export let cocoaVersion: string;
    export let comment: string;
    export let company: string;
    export let converted: string;
    export let copyright: string;
    export let creationTime: string;
    export let cursor: string;
    export let defaultAttributes: string;
    export let defaultTabInterval: string;
    export let docFormat: string;
    export let documentType: string;
    export let editor: string;
    export let excludedElements: string;
    export let expansion: string;
    export let fileType: string;
    export let font: string;
    export let foregroundColor: string;
    export let glyphInfo: string;
    export let html: string;
    export let hyphenationFactor: string;
    export let kern: string;
    export let keywords: string;
    export let leftMargin: string;
    export let ligature: string;
    export let link: string;
    export let macSimpleText: string;
    export let manager: string;
    export let markedClauseSegment: string;
    export let modificationTime: string;
    export let obliqueness: string;
    export let officeOpenXML: string;
    export let openDocument: string;
    export let paperSize: string;
    export let paragraphStyle: string;
    export let plain: string;
    export let prefixSpaces: string;
    export let rtfd: string;
    export let rtf: string;
    export let readOnly: string;
    export let rightMargin: string;
    export let shadow: string;
    export let sourceTextScaling: string;
    export let spellingState: string;
    export let strikethroughColor: string;
    export let strikethroughStyle: string;
    export let strokeColor: string;
    export let strokeWidth: string;
    export let subject: string;
    export let superscript: string;
    export let targetTextScaling: string;
    export let textAlternatives: string;
    export let textEffect: string;
    export let letterpressStyle: string;
    export let textEncodingName: string;
    export let orientation: string;
    export let range: string;
    export let textLayoutSections: string;
    export let textScaling: string;
    export let textSizeMultiplier: string;
    export let timeout: string;
    export let title: string;
    export let toolTip: string;
    export let topMargin: string;
    export let underlineColor: string;
    export let underlineStyle: string;
    export let verticalGlyphForm: string;
    export let viewMode: string;
    export let viewSize: string;
    export let viewZoom: string;
    export let webArchive: string;
    export let webPreferences: string;
    export let webResourceLoadDelegate: string;
    export let wordML: string;
    export let writingDirection: string;
  }

  namespace NSBackgroundActivityScheduler {
    export enum Result {
      Finished = 1,
      Deferred = 2
    }

  }

  namespace NSBezierPath {
    export enum ElementType {
      MoveTo = 0,
      LineTo = 1,
      CurveTo = 2,
      ClosePath = 3
    }

    export enum LineCapStyle {
      Butt = 0,
      Round = 1,
      Square = 2
    }

    export enum LineJoinStyle {
      Miter = 0,
      Round = 1,
      Bevel = 2
    }

    export enum WindingRule {
      NonZero = 0,
      EvenOdd = 1
    }

    export let bevel: NSBezierPath.LineJoinStyle;
    export let butt: NSBezierPath.LineCapStyle;
    export let closePath: NSBezierPath.ElementType;
    export let curveTo: NSBezierPath.ElementType;
    export let evenOdd: NSBezierPath.WindingRule;
    export let lineTo: NSBezierPath.ElementType;
    export let miter: NSBezierPath.LineJoinStyle;
    export let moveTo: NSBezierPath.ElementType;
    export let nonZero: NSBezierPath.WindingRule;
    export let round: NSBezierPath.LineCapStyle;
    export let square: NSBezierPath.LineCapStyle;
  }

  namespace NSBindingInfoKey {
    export let observedKeyPath: string;
    export let observedObject: string;
    export let options: string;
  }

  namespace NSBindingName {
    export let alignment: string;
    export let alternateImage: string;
    export let alternateTitle: string;
    export let animate: string;
    export let animationDelay: string;
    export let argument: string;
    export let attributedString: string;
    export let contentArray: string;
    export let contentArrayForMultipleSelection: string;
    export let content: string;
    export let contentDictionary: string;
    export let contentHeight: string;
    export let contentObject: string;
    export let contentObjects: string;
    export let contentSet: string;
    export let contentValues: string;
    export let contentWidth: string;
    export let criticalValue: string;
    export let data: string;
    export let displayPatternTitle: string;
    export let displayPatternValue: string;
    export let documentEdited: string;
    export let doubleClickArgument: string;
    export let doubleClickTarget: string;
    export let editable: string;
    export let enabled: string;
    export let excludedKeys: string;
    export let filterPredicate: string;
    export let font: string;
    export let fontBold: string;
    export let fontFamilyName: string;
    export let fontItalic: string;
    export let fontName: string;
    export let fontSize: string;
    export let headerTitle: string;
    export let hidden: string;
    export let image: string;
    export let includedKeys: string;
    export let initialKey: string;
    export let initialValue: string;
    export let isIndeterminate: string;
    export let label: string;
    export let localizedKeyDictionary: string;
    export let managedObjectContext: string;
    export let maxValue: string;
    export let maxWidth: string;
    export let maximumRecents: string;
    export let minValue: string;
    export let minWidth: string;
    export let mixedStateImage: string;
    export let offStateImage: string;
    export let onStateImage: string;
    export let positioningRect: string;
    export let predicate: string;
    export let recentSearches: string;
    export let representedFilename: string;
    export let rowHeight: string;
    export let selectedIdentifier: string;
    export let selectedIndex: string;
    export let selectedLabel: string;
    export let selectedObject: string;
    export let selectedObjects: string;
    export let selectedTag: string;
    export let selectedValue: string;
    export let selectedValues: string;
    export let selectionIndexPaths: string;
    export let selectionIndexes: string;
    export let sortDescriptors: string;
    export let target: string;
    export let textColor: string;
    export let title: string;
    export let toolTip: string;
    export let transparent: string;
    export let value: string;
    export let valuePath: string;
    export let valueURL: string;
    export let visible: string;
    export let warningValue: string;
    export let width: string;
  }

  namespace NSBindingOption {
    export let allowsEditingMultipleValuesSelection: string;
    export let allowsNullArgument: string;
    export let alwaysPresentsApplicationModalAlerts: string;
    export let conditionallySetsEditable: string;
    export let conditionallySetsEnabled: string;
    export let conditionallySetsHidden: string;
    export let contentPlacementTag: string;
    export let continuouslyUpdatesValue: string;
    export let createsSortDescriptor: string;
    export let deletesObjectsOnRemove: string;
    export let displayName: string;
    export let displayPattern: string;
    export let handlesContentAsCompoundValue: string;
    export let insertsNullPlaceholder: string;
    export let invokesSeparatelyWithArrayObjects: string;
    export let multipleValuesPlaceholder: string;
    export let noSelectionPlaceholder: string;
    export let notApplicablePlaceholder: string;
    export let nullPlaceholder: string;
    export let predicateFormat: string;
    export let raisesForNotApplicableKeys: string;
    export let selectorName: string;
    export let selectsAllWhenSettingContent: string;
    export let validatesImmediately: string;
    export let valueTransformer: string;
    export let valueTransformerName: string;
  }

  namespace NSBitmapImageRep {
    export enum Format {
      AlphaFirst = 1,
      AlphaNonpremultiplied = 2,
      FloatingPointSamples = 4,
      SixteenBitLittleEndian = 256,
      ThirtyTwoBitLittleEndian = 512,
      SixteenBitBigEndian = 1024,
      ThirtyTwoBitBigEndian = 2048
    }

    export enum FileType {
      TIFF = 0,
      BMP = 1,
      GIF = 2,
      JPEG = 3,
      PNG = 4,
      JPEG2000 = 5
    }

    export enum LoadStatus {
      UnknownType = -1,
      ReadingHeader = -2,
      WillNeedAllData = -3,
      InvalidData = -4,
      UnexpectedEOF = -5,
      Completed = -6
    }

    export enum TIFFCompression {
      None = 1,
      CCITTFAX3 = 3,
      CCITTFAX4 = 4,
      LZW = 5,
      JPEG = 6,
      NEXT = 32766,
      PackBits = 32773,
      OldJPEG = 32865
    }

    export let colorSyncProfileData: string;
    export let compressionFactor: string;
    export let compressionMethod: string;
    export let currentFrame: string;
    export let currentFrameDuration: string;
    export let ditherTransparency: string;
    export let exifData: string;
    export let fallbackBackgroundColor: string;
    export let frameCount: string;
    export let gamma: string;
    export let interlaced: string;
    export let loopCount: string;
    export let progressive: string;
    export let rgbColorTable: string;
  }

  namespace NSBox {
    export enum BoxType {
      Primary = 0,
      Separator = 2,
      Custom = 4
    }

    export enum TitlePosition {
      NoTitle = 0,
      AboveTop = 1,
      AtTop = 2,
      BelowTop = 3,
      AboveBottom = 4,
      AtBottom = 5,
      BelowBottom = 6
    }

    export let primary: NSBox.BoxType;
  }

  namespace NSBrowser {
    export enum ColumnResizingType {
      NoColumnResizing = 0,
      AutoColumnResizing = 1,
      UserColumnResizing = 2
    }

    export enum DropOperation {
      On = 0,
      Above = 1
    }

    export let columnConfigurationDidChangeNotification: string;
    export type ColumnsAutosaveName = String;
  }

  namespace NSButton {
    export enum BezelStyle {
      Rounded = 1,
      RegularSquare = 2,
      Disclosure = 5,
      ShadowlessSquare = 6,
      Circular = 7,
      TexturedSquare = 8,
      HelpButton = 9,
      SmallSquare = 10,
      TexturedRounded = 11,
      RoundRect = 12,
      Recessed = 13,
      RoundedDisclosure = 14,
      Inline = 15
    }

    export enum ButtonType {
      MomentaryLight = 0,
      PushOnPushOff = 1,
      Toggle = 2,
      Switch = 3,
      Radio = 4,
      MomentaryChange = 5,
      OnOff = 6,
      MomentaryPushIn = 7,
      Accelerator = 8,
      MultiLevelAccelerator = 9
    }

  }

  namespace NSCalendar {
    export enum Options {
      WrapComponents = 1,
      MatchStrictly = 2,
      SearchBackwards = 4,
      MatchPreviousTimePreservingSmallerUnits = 256,
      MatchNextTimePreservingSmallerUnits = 512,
      MatchNextTime = 1024,
      MatchFirst = 4096,
      MatchLast = 8192
    }

    export enum Unit {
      CalendarUnitEra = 2,
      CalendarUnitYear = 4,
      CalendarUnitMonth = 8,
      CalendarUnitDay = 16,
      CalendarUnitHour = 32,
      CalendarUnitMinute = 64,
      CalendarUnitSecond = 128,
      CalendarUnitWeekday = 512,
      CalendarUnitWeekdayOrdinal = 1024,
      CalendarUnitQuarter = 2048,
      CalendarUnitWeekOfMonth = 4096,
      CalendarUnitWeekOfYear = 8192,
      CalendarUnitYearForWeekOfYear = 16384,
      CalendarUnitNanosecond = 32768,
      CalendarUnitCalendar = 1048576,
      CalendarUnitTimeZone = 2097152,
      EraCalendarUnit = 2,
      YearCalendarUnit = 4,
      MonthCalendarUnit = 8,
      DayCalendarUnit = 16,
      HourCalendarUnit = 32,
      MinuteCalendarUnit = 64,
      SecondCalendarUnit = 128,
      WeekCalendarUnit = 256,
      WeekdayCalendarUnit = 512,
      WeekdayOrdinalCalendarUnit = 1024,
      QuarterCalendarUnit = 2048,
      WeekOfMonthCalendarUnit = 4096,
      WeekOfYearCalendarUnit = 8192,
      YearForWeekOfYearCalendarUnit = 16384,
      CalendarCalendarUnit = 1048576,
      TimeZoneCalendarUnit = 2097152
    }

    export let buddhist: string;
    export let chinese: string;
    export let coptic: string;
    export let ethiopicAmeteAlem: string;
    export let ethiopicAmeteMihret: string;
    export let gregorian: string;
    export let hebrew: string;
    export let ISO8601: string;
    export let indian: string;
    export let islamic: string;
    export let islamicCivil: string;
    export let islamicTabular: string;
    export let islamicUmmAlQura: string;
    export let japanese: string;
    export let persian: string;
    export let republicOfChina: string;
  }

  namespace NSCell {
    export enum Attribute {
      CellDisabled = 0,
      CellState = 1,
      PushInCell = 2,
      CellEditable = 3,
      ChangeGrayCell = 4,
      CellHighlighted = 5,
      CellLightsByContents = 6,
      CellLightsByGray = 7,
      ChangeBackgroundCell = 8,
      CellLightsByBackground = 9,
      CellIsBordered = 10,
      CellHasOverlappingImage = 11,
      CellHasImageHorizontal = 12,
      CellHasImageOnLeftOrBottom = 13,
      CellChangesContents = 14,
      CellIsInsetButton = 15,
      CellAllowsMixedState = 16
    }

    export enum HitResult {
      None = 0,
      ContentArea = 1,
      EditableTextArea = 2,
      TrackableArea = 4
    }

    export enum StyleMask {
      NoCellMask = 0,
      ContentsCellMask = 1,
      PushInCellMask = 2,
      ChangeGrayCellMask = 4,
      ChangeBackgroundCellMask = 8
    }

    export enum CellType {
      NullCellType = 0,
      TextCellType = 1,
      ImageCellType = 2
    }

  }

  namespace NSCoder {
    export enum DecodingFailurePolicy {
      RaiseException = 0,
      SetErrorAndReturn = 1
    }

  }

  namespace NSCollectionView {
    export enum UpdateAction {
      Insert = 0,
      Delete = 1,
      Reload = 2,
      Move = 3,
      None = 4
    }

    export enum DropOperation {
      On = 0,
      Before = 1
    }

    export enum ScrollDirection {
      Vertical = 0,
      Horizontal = 1
    }

    export enum ScrollPosition {
      None = 0,
      Top = 1,
      CenteredVertically = 2,
      Bottom = 4,
      NearestHorizontalEdge = 512,
      Left = 8,
      CenteredHorizontally = 16,
      Right = 32,
      LeadingEdge = 64,
      TrailingEdge = 128,
      NearestVerticalEdge = 256
    }

    export let elementKindInterItemGapIndicator: string;
    export let elementKindSectionFooter: string;
    export let elementKindSectionHeader: string;
    export type DecorationElementKind = String;
    export type SupplementaryElementKind = String;
  }

  namespace NSCollectionViewItem {
    export enum HighlightState {
      None = 0,
      ForSelection = 1,
      ForDeselection = 2,
      AsDropTarget = 3
    }

  }

  namespace NSCollectionViewTransitionLayout {
    export type AnimatedKey = String;
  }

  namespace NSColor {
    export enum SystemEffect {
      None = 0,
      Pressed = 1,
      DeepPressed = 2,
      Disabled = 3,
      Rollover = 4
    }

    export enum ColorType {
      ComponentBased = 0,
      Pattern = 1,
      Catalog = 2
    }

    export let currentControlTintDidChangeNotification: string;
    export let systemColorsDidChangeNotification: string;
    export type Name = String;
  }

  namespace NSColorList {
    export let didChangeNotification: string;
    export type Name = String;
  }

  namespace NSColorPanel {
    export enum Mode {
      None = -1,
      Gray = 0,
      RGB = 1,
      CMYK = 2,
      HSB = 3,
      CustomPalette = 4,
      ColorList = 5,
      Wheel = 6,
      Crayon = 7
    }

    export enum Options {
      GrayModeMask = 1,
      RGBModeMask = 2,
      CMYKModeMask = 4,
      HSBModeMask = 8,
      CustomPaletteModeMask = 16,
      ColorListModeMask = 32,
      WheelModeMask = 64,
      CrayonModeMask = 128,
      AllModesMask = 65535
    }

    export let colorDidChangeNotification: string;
  }

  namespace NSColorSpace {
    export enum Model {
      Unknown = -1,
      Gray = 0,
      RGB = 1,
      CMYK = 2,
      LAB = 3,
      DeviceN = 4,
      Indexed = 5,
      Patterned = 6
    }

  }

  namespace NSColorSpaceName {
    export let calibratedRGB: string;
    export let calibratedWhite: string;
    export let custom: string;
    export let deviceCMYK: string;
    export let deviceRGB: string;
    export let deviceWhite: string;
    export let named: string;
    export let pattern: string;
  }

  namespace NSComboBox {
    export let selectionDidChangeNotification: string;
    export let selectionIsChangingNotification: string;
    export let willDismissNotification: string;
    export let willPopUpNotification: string;
  }

  namespace NSComparisonPredicate {
    export enum Modifier {
      DirectPredicateModifier = 0,
      AllPredicateModifier = 1,
      AnyPredicateModifier = 2
    }

    export enum Options {
      CaseInsensitivePredicateOption = 1,
      DiacriticInsensitivePredicateOption = 2,
      NormalizedPredicateOption = 4
    }

    export enum Operator {
      LessThanPredicateOperatorType = 0,
      LessThanOrEqualToPredicateOperatorType = 1,
      GreaterThanPredicateOperatorType = 2,
      GreaterThanOrEqualToPredicateOperatorType = 3,
      EqualToPredicateOperatorType = 4,
      NotEqualToPredicateOperatorType = 5,
      MatchesPredicateOperatorType = 6,
      LikePredicateOperatorType = 7,
      BeginsWithPredicateOperatorType = 8,
      EndsWithPredicateOperatorType = 9,
      InPredicateOperatorType = 10,
      CustomSelectorPredicateOperatorType = 11,
      ContainsPredicateOperatorType = 99,
      BetweenPredicateOperatorType = 100
    }

  }

  namespace NSCompoundPredicate {
    export enum LogicalType {
      NotPredicateType = 0,
      AndPredicateType = 1,
      OrPredicateType = 2
    }

  }

  namespace NSControl {
    export enum ImagePosition {
      NoImage = 0,
      ImageOnly = 1,
      ImageLeft = 2,
      ImageRight = 3,
      ImageBelow = 4,
      ImageAbove = 5,
      ImageOverlaps = 6,
      ImageLeading = 7,
      ImageTrailing = 8
    }

    export enum ControlSize {
      Regular = 0,
      Small = 1,
      Mini = 2
    }

    export let mixed: number;
    export let off: number;
    export let on: number;
    export let textDidBeginEditingNotification: string;
    export let textDidChangeNotification: string;
    export let textDidEndEditingNotification: string;
  }

  namespace NSData {
    export enum Base64DecodingOptions {
      IgnoreUnknownCharacters = 1
    }

    export enum Base64EncodingOptions {
      Encoding64CharacterLineLength = 1,
      Encoding76CharacterLineLength = 2,
      EncodingEndLineWithCarriageReturn = 16,
      EncodingEndLineWithLineFeed = 32
    }

    export enum CompressionAlgorithm {
      LZFSE = 0,
      LZ4 = 1,
      LZMA = 2,
      Zlib = 3
    }

    export enum ReadingOptions {
      DataReadingMappedIfSafe = 1,
      DataReadingUncached = 2,
      DataReadingMappedAlways = 8,
      DataReadingMapped = 1,
      MappedRead = 1,
      UncachedRead = 2
    }

    export enum SearchOptions {
      Backwards = 1,
      Anchored = 2
    }

    export enum WritingOptions {
      DataWritingAtomic = 1,
      DataWritingWithoutOverwriting = 2,
      DataWritingFileProtectionNone = 268435456,
      DataWritingFileProtectionComplete = 536870912,
      DataWritingFileProtectionCompleteUnlessOpen = 805306368,
      DataWritingFileProtectionCompleteUntilFirstUserAuthentication = 1073741824,
      DataWritingFileProtectionMask = 4026531840,
      AtomicWrite = 1
    }

    export type Element = number;
    export type Index = number;
    export type Iterator = IndexingIterator;
    export type SubSequence = Slice;
    export type Indices = Range;
  }

  namespace NSDatePicker {
    export enum ElementFlags {
      HourMinute = 12,
      HourMinuteSecond = 14,
      TimeZone = 16,
      YearMonth = 192,
      YearMonthDay = 224,
      Era = 256
    }

    export enum Mode {
      Single = 0,
      Range = 1
    }

    export enum Style {
      TextFieldAndStepper = 0,
      ClockAndCalendar = 1,
      TextField = 2
    }

    export let clockAndCalendar: NSDatePicker.Style;
    export let era: NSDatePicker.ElementFlags;
    export let hourMinute: NSDatePicker.ElementFlags;
    export let hourMinuteSecond: NSDatePicker.ElementFlags;
    export let range: NSDatePicker.Mode;
    export let single: NSDatePicker.Mode;
    export let textFieldAndStepper: NSDatePicker.Style;
    export let textField: NSDatePicker.Style;
    export let timeZone: NSDatePicker.ElementFlags;
    export let yearMonth: NSDatePicker.ElementFlags;
    export let yearMonthDay: NSDatePicker.ElementFlags;
  }

  namespace NSDecimalNumber {
    export enum CalculationError {
      NoError = 0,
      LossOfPrecision = 1,
      Underflow = 2,
      Overflow = 3,
      DivideByZero = 4
    }

    export enum RoundingMode {
      Plain = 0,
      Down = 1,
      Up = 2,
      Bankers = 3
    }

  }

  namespace NSDeviceDescriptionKey {
    export let bitsPerSample: string;
    export let colorSpaceName: string;
    export let isPrinter: string;
    export let isScreen: string;
    export let resolution: string;
    export let size: string;
  }

  namespace NSDocument {
    export enum ChangeType {
      ChangeDone = 0,
      ChangeUndone = 1,
      ChangeRedone = 5,
      ChangeCleared = 2,
      ChangeReadOtherContents = 3,
      ChangeAutosaved = 4,
      ChangeDiscardable = 256
    }

    export enum SaveOperationType {
      SaveOperation = 0,
      SaveAsOperation = 1,
      SaveToOperation = 2,
      AutosaveInPlaceOperation = 4,
      AutosaveElsewhereOperation = 3,
      AutosaveAsOperation = 5,
      AutosaveOperation = 3
    }

  }

  namespace NSDraggingItem {
    export let icon: string;
    export let label: string;
  }

  namespace NSDrawer {
    export enum State {
      ClosedState = 0,
      OpeningState = 1,
      OpenState = 2,
      ClosingState = 3
    }

  }

  namespace NSEnumerator {
    export type Iterator = NSFastEnumerationIterator;
  }

  namespace NSError {
    export type UserInfoKey = string;
  }

  namespace NSEvent {
    export enum ButtonMask {
      PenTip = 1,
      PenLowerSide = 2,
      PenUpperSide = 4
    }

    export enum GestureAxis {
      None = 0,
      Horizontal = 1,
      Vertical = 2
    }

    export enum EventTypeMask {
      LeftMouseDown = 2,
      LeftMouseUp = 4,
      RightMouseDown = 8,
      RightMouseUp = 16,
      MouseMoved = 32,
      LeftMouseDragged = 64,
      RightMouseDragged = 128,
      MouseEntered = 256,
      MouseExited = 512,
      KeyDown = 1024,
      KeyUp = 2048,
      FlagsChanged = 4096,
      AppKitDefined = 8192,
      SystemDefined = 16384,
      ApplicationDefined = 32768,
      Periodic = 65536,
      CursorUpdate = 131072,
      ScrollWheel = 4194304,
      TabletPoint = 8388608,
      TabletProximity = 16777216,
      OtherMouseDown = 33554432,
      OtherMouseUp = 67108864,
      OtherMouseDragged = 134217728,
      Gesture = 536870912,
      Magnify = 1073741824,
      Swipe = 2147483648,
      Rotate = 262144,
      BeginGesture = 524288,
      EndGesture = 1048576,
      SmartMagnify = 4294967296,
      Pressure = 17179869184,
      DirectTouch = 137438953472,
      ChangeMode = 274877906944,
      Any = -1
    }

    export enum ModifierFlags {
      CapsLock = 65536,
      Shift = 131072,
      Control = 262144,
      Option = 524288,
      Command = 1048576,
      NumericPad = 2097152,
      Help = 4194304,
      Function = 8388608,
      DeviceIndependentFlagsMask = 4294901760
    }

    export enum Phase {
      None = 0,
      Began = 1,
      Stationary = 2,
      Changed = 4,
      Ended = 8,
      Cancelled = 16,
      MayBegin = 32
    }

    export enum EventSubtype {
      WindowExposed = 0,
      ApplicationActivated = 1,
      ApplicationDeactivated = 2,
      WindowMoved = 4,
      ScreenChanged = 8,
      PowerOff = 1,
      MouseEvent = 0,
      TabletPoint = 1,
      TabletProximity = 2,
      Touch = 3
    }

    export enum SwipeTrackingOptions {
      LockDirection = 1,
      ClampGestureAmount = 2
    }

    export enum EventType {
      LeftMouseDown = 1,
      LeftMouseUp = 2,
      RightMouseDown = 3,
      RightMouseUp = 4,
      MouseMoved = 5,
      LeftMouseDragged = 6,
      RightMouseDragged = 7,
      MouseEntered = 8,
      MouseExited = 9,
      KeyDown = 10,
      KeyUp = 11,
      FlagsChanged = 12,
      AppKitDefined = 13,
      SystemDefined = 14,
      ApplicationDefined = 15,
      Periodic = 16,
      CursorUpdate = 17,
      ScrollWheel = 22,
      TabletPoint = 23,
      TabletProximity = 24,
      OtherMouseDown = 25,
      OtherMouseUp = 26,
      OtherMouseDragged = 27,
      Gesture = 29,
      Magnify = 30,
      Swipe = 31,
      Rotate = 18,
      BeginGesture = 19,
      EndGesture = 20,
      SmartMagnify = 32,
      QuickLook = 33,
      Pressure = 34,
      DirectTouch = 37,
      ChangeMode = 38
    }

    export enum PointingDeviceType {
      Unknown = 0,
      Pen = 1,
      Cursor = 2,
      Eraser = 3
    }

    export enum PressureBehavior {
      Unknown = -1,
      PrimaryDefault = 0,
      PrimaryClick = 1,
      PrimaryGeneric = 2,
      PrimaryAccelerator = 3,
      PrimaryDeepClick = 5,
      PrimaryDeepDrag = 6
    }

    export let foreverDuration: number;
  }

  namespace NSExceptionName {
    export let abortModalException: string;
    export let abortPrintingException: string;
    export let appKitIgnoredException: string;
    export let appKitVirtualMemoryException: string;
    export let badBitmapParametersException: string;
    export let badComparisonException: string;
    export let badRTFColorTableException: string;
    export let badRTFDirectiveException: string;
    export let badRTFFontTableException: string;
    export let badRTFStyleSheetException: string;
    export let browserIllegalDelegateException: string;
    export let colorListIOException: string;
    export let colorListNotEditableException: string;
    export let draggingException: string;
    export let fontUnavailableException: string;
    export let illegalSelectorException: string;
    export let imageCacheException: string;
    export let nibLoadingException: string;
    export let NSPPDIncludeNotFoundException: string;
    export let NSPPDIncludeStackOverflowException: string;
    export let NSPPDIncludeStackUnderflowException: string;
    export let NSPPDParseException: string;
    export let pasteboardCommunicationException: string;
    export let printOperationExistsException: string;
    export let printPackageException: string;
    export let printingCommunicationException: string;
    export let NSRTFPropertyStackOverflowException: string;
    export let NSTIFFException: string;
    export let textLineTooLongException: string;
    export let textNoSelectionException: string;
    export let textReadException: string;
    export let textWriteException: string;
    export let typedStreamVersionException: string;
    export let windowServerCommunicationException: string;
    export let wordTablesReadException: string;
    export let wordTablesWriteException: string;
    export let characterConversionException: string;
    export let decimalNumberDivideByZeroException: string;
    export let decimalNumberExactnessException: string;
    export let decimalNumberOverflowException: string;
    export let decimalNumberUnderflowException: string;
    export let destinationInvalidException: string;
    export let fileHandleOperationException: string;
    export let genericException: string;
    export let inconsistentArchiveException: string;
    export let internalInconsistencyException: string;
    export let invalidArchiveOperationException: string;
    export let invalidArgumentException: string;
    export let invalidReceivePortException: string;
    export let invalidSendPortException: string;
    export let invalidUnarchiveOperationException: string;
    export let invocationOperationCancelledException: string;
    export let invocationOperationVoidResultException: string;
    export let mallocException: string;
    export let objectInaccessibleException: string;
    export let objectNotAvailableException: string;
    export let oldStyleException: string;
    export let parseErrorException: string;
    export let portReceiveException: string;
    export let portSendException: string;
    export let portTimeoutException: string;
    export let rangeException: string;
    export let undefinedKeyException: string;
  }

  namespace NSExpression {
    export enum ExpressionType {
      ConstantValueExpressionType = 0,
      EvaluatedObjectExpressionType = 1,
      VariableExpressionType = 2,
      KeyPathExpressionType = 3,
      FunctionExpressionType = 4,
      UnionSetExpressionType = 5,
      IntersectSetExpressionType = 6,
      MinusSetExpressionType = 7,
      SubqueryExpressionType = 13,
      AggregateExpressionType = 14,
      AnyKeyExpressionType = 15,
      BlockExpressionType = 19,
      ConditionalExpressionType = 20
    }

  }

  namespace NSFileCoordinator {
    export enum ReadingOptions {
      WithoutChanges = 1,
      ResolvesSymbolicLink = 2,
      ImmediatelyAvailableMetadataOnly = 4,
      ForUploading = 8
    }

    export enum WritingOptions {
      ForDeleting = 1,
      ForMoving = 2,
      ForMerging = 4,
      ForReplacing = 8,
      ContentIndependentMetadataOnly = 16
    }

  }

  namespace NSFileVersion {
    export enum AddingOptions {
      ByMoving = 1
    }

    export enum ReplacingOptions {
      ByMoving = 1
    }

  }

  namespace NSFont {
    export let antialiasThresholdChangedNotification: string;
    export let identityMatrix: number;
    export let fontSetChangedNotification: string;
    export let black: number;
    export let bold: number;
    export let heavy: number;
    export let light: number;
    export let medium: number;
    export let regular: number;
    export let semibold: number;
    export let thin: number;
    export let ultraLight: number;
  }

  namespace NSFontAssetRequest {
    export enum Options {
      UsesStandardUI = 1
    }

  }

  namespace NSFontCollection {
    export enum Visibility {
      Process = 1,
      User = 2,
      Computer = 4
    }

    export let actionUserInfoKey: string;
    export let allFonts: string;
    export let didChangeNotification: string;
    export let favorites: string;
    export let nameUserInfoKey: string;
    export let oldNameUserInfoKey: string;
    export let recentlyUsed: string;
    export let user: string;
    export let visibilityUserInfoKey: string;
    export let hidden: string;
    export let renamed: string;
    export let shown: string;
  }

  namespace NSFontDescriptor {
    export enum SymbolicTraits {
      TraitItalic = 1,
      TraitBold = 2,
      TraitExpanded = 32,
      TraitCondensed = 64,
      TraitMonoSpace = 1024,
      TraitVertical = 2048,
      TraitUIOptimized = 4096,
      TraitTightLeading = 32768,
      TraitLooseLeading = 65536,
      ClassMask = 4026531840,
      ClassUnknown = 0,
      ClassOldStyleSerifs = 268435456,
      ClassTransitionalSerifs = 536870912,
      ClassModernSerifs = 805306368,
      ClassClarendonSerifs = 1073741824,
      ClassSlabSerifs = 1342177280,
      ClassFreeformSerifs = 1879048192,
      ClassSansSerif = 2147483648,
      ClassOrnamentals = 2415919104,
      ClassScripts = 2684354560,
      ClassSymbolic = 3221225472
    }

    export let cascadeList: string;
    export let characterSet: string;
    export let default_: string;
    export let monospaced: string;
    export let rounded: string;
    export let serif: string;
    export let face: string;
    export let family: string;
    export let selectorIdentifier: string;
    export let featureSettings: string;
    export let typeIdentifier: string;
    export let fixedAdvance: string;
    export let matrix: string;
    export let name: string;
    export let size: string;
    export let slant: string;
    export let symbolic: string;
    export let traits: string;
    export let variation: string;
    export let defaultValue: string;
    export let identifier: string;
    export let maximumValue: string;
    export let minimumValue: string;
    export let visibleName: string;
    export let weight: string;
    export let width: string;
  }

  namespace NSFontPanel {
    export enum ModeMask {
      ModeMaskFace = 1,
      ModeMaskSize = 2,
      ModeMaskCollection = 4,
      ModeMaskUnderlineEffect = 256,
      ModeMaskStrikethroughEffect = 512,
      ModeMaskTextColorEffect = 1024,
      ModeMaskDocumentColorEffect = 2048,
      ModeMaskShadowEffect = 4096,
      ModeMaskAllEffects = 1048320,
      ModesMaskStandardModes = 65535,
      ModesMaskAllModes = 4294967295
    }

  }

  namespace NSGestureRecognizer {
    export enum State {
      Possible = 0,
      Began = 1,
      Changed = 2,
      Ended = 3,
      Cancelled = 4,
      Failed = 5,
      Recognized = 3
    }

  }

  namespace NSGradient {
    export enum DrawingOptions {
      DrawsBeforeStartingLocation = 1,
      DrawsAfterEndingLocation = 2
    }

  }

  namespace NSGraphicsContext {
    export let destination: string;
    export let pdf: string;
    export let postScript: string;
    export let representationFormat: string;
  }

  namespace NSGridCell {
    export enum Placement {
      Inherited = 0,
      None = 1,
      Leading = 2,
      Top = 2,
      Trailing = 3,
      Bottom = 3,
      Center = 4,
      Fill = 5
    }

  }

  namespace NSGridRow {
    export enum Alignment {
      Inherited = 0,
      None = 1,
      FirstBaseline = 2,
      LastBaseline = 3
    }

  }

  namespace NSGridView {
    export let sizedForContent: number;
  }

  namespace NSHapticFeedbackManager {
    export enum FeedbackPattern {
      Generic = 0,
      Alignment = 1,
      LevelChange = 2
    }

    export enum PerformanceTime {
      Default = 0,
      Now = 1,
      DrawCompleted = 2
    }

  }

  namespace NSHelpManager {
    export let contextHelpModeDidActivateNotification: string;
    export let contextHelpModeDidDeactivateNotification: string;
    export type BookName = String;
    export type AnchorName = String;
    export type ContextHelpKey = String;
  }

  namespace NSImage {
    export enum CacheMode {
      Default = 0,
      Always = 1,
      BySize = 2,
      Never = 3
    }

    export enum LayoutDirection {
      Unspecified = -1,
      LeftToRight = 2,
      RightToLeft = 3
    }

    export enum LoadStatus {
      Completed = 0,
      Cancelled = 1,
      InvalidData = 2,
      UnexpectedEOF = 3,
      ReadError = 4
    }

    export enum ResizingMode {
      Stretch = 0,
      Tile = 1
    }

    export let actionTemplateName: string;
    export let addTemplateName: string;
    export let advancedName: string;
    export let applicationIconName: string;
    export let bluetoothTemplateName: string;
    export let bonjourName: string;
    export let bookmarksTemplateName: string;
    export let cautionName: string;
    export let colorPanelName: string;
    export let columnViewTemplateName: string;
    export let computerName: string;
    export let enterFullScreenTemplateName: string;
    export let everyoneName: string;
    export let exitFullScreenTemplateName: string;
    export let flowViewTemplateName: string;
    export let folderName: string;
    export let folderBurnableName: string;
    export let folderSmartName: string;
    export let followLinkFreestandingTemplateName: string;
    export let fontPanelName: string;
    export let goBackTemplateName: string;
    export let goForwardTemplateName: string;
    export let goLeftTemplateName: string;
    export let goRightTemplateName: string;
    export let homeTemplateName: string;
    export let iChatTheaterTemplateName: string;
    export let iconViewTemplateName: string;
    export let infoName: string;
    export let invalidDataFreestandingTemplateName: string;
    export let leftFacingTriangleTemplateName: string;
    export let listViewTemplateName: string;
    export let lockLockedTemplateName: string;
    export let lockUnlockedTemplateName: string;
    export let menuMixedStateTemplateName: string;
    export let menuOnStateTemplateName: string;
    export let mobileMeName: string;
    export let multipleDocumentsName: string;
    export let networkName: string;
    export let pathTemplateName: string;
    export let preferencesGeneralName: string;
    export let quickLookTemplateName: string;
    export let refreshFreestandingTemplateName: string;
    export let refreshTemplateName: string;
    export let removeTemplateName: string;
    export let revealFreestandingTemplateName: string;
    export let rightFacingTriangleTemplateName: string;
    export let shareTemplateName: string;
    export let slideshowTemplateName: string;
    export let smartBadgeTemplateName: string;
    export let statusAvailableName: string;
    export let statusNoneName: string;
    export let statusPartiallyAvailableName: string;
    export let statusUnavailableName: string;
    export let stopProgressFreestandingTemplateName: string;
    export let stopProgressTemplateName: string;
    export let touchBarAddDetailTemplateName: string;
    export let touchBarAddTemplateName: string;
    export let touchBarAlarmTemplateName: string;
    export let touchBarAudioInputMuteTemplateName: string;
    export let touchBarAudioInputTemplateName: string;
    export let touchBarAudioOutputMuteTemplateName: string;
    export let touchBarAudioOutputVolumeHighTemplateName: string;
    export let touchBarAudioOutputVolumeLowTemplateName: string;
    export let touchBarAudioOutputVolumeMediumTemplateName: string;
    export let touchBarAudioOutputVolumeOffTemplateName: string;
    export let touchBarBookmarksTemplateName: string;
    export let touchBarColorPickerFillName: string;
    export let touchBarColorPickerFontName: string;
    export let touchBarColorPickerStrokeName: string;
    export let touchBarCommunicationAudioTemplateName: string;
    export let touchBarCommunicationVideoTemplateName: string;
    export let touchBarComposeTemplateName: string;
    export let touchBarDeleteTemplateName: string;
    export let touchBarDownloadTemplateName: string;
    export let touchBarEnterFullScreenTemplateName: string;
    export let touchBarExitFullScreenTemplateName: string;
    export let touchBarFastForwardTemplateName: string;
    export let touchBarFolderCopyToTemplateName: string;
    export let touchBarFolderMoveToTemplateName: string;
    export let touchBarFolderTemplateName: string;
    export let touchBarGetInfoTemplateName: string;
    export let touchBarGoBackTemplateName: string;
    export let touchBarGoDownTemplateName: string;
    export let touchBarGoForwardTemplateName: string;
    export let touchBarGoUpTemplateName: string;
    export let touchBarHistoryTemplateName: string;
    export let touchBarIconViewTemplateName: string;
    export let touchBarListViewTemplateName: string;
    export let touchBarMailTemplateName: string;
    export let touchBarNewFolderTemplateName: string;
    export let touchBarNewMessageTemplateName: string;
    export let touchBarOpenInBrowserTemplateName: string;
    export let touchBarPauseTemplateName: string;
    export let touchBarPlayPauseTemplateName: string;
    export let touchBarPlayTemplateName: string;
    export let touchBarPlayheadTemplateName: string;
    export let touchBarQuickLookTemplateName: string;
    export let touchBarRecordStartTemplateName: string;
    export let touchBarRecordStopTemplateName: string;
    export let touchBarRefreshTemplateName: string;
    export let touchBarRemoveTemplateName: string;
    export let touchBarRewindTemplateName: string;
    export let touchBarRotateLeftTemplateName: string;
    export let touchBarRotateRightTemplateName: string;
    export let touchBarSearchTemplateName: string;
    export let touchBarShareTemplateName: string;
    export let touchBarSidebarTemplateName: string;
    export let touchBarSkipAhead15SecondsTemplateName: string;
    export let touchBarSkipAhead30SecondsTemplateName: string;
    export let touchBarSkipAheadTemplateName: string;
    export let touchBarSkipBack15SecondsTemplateName: string;
    export let touchBarSkipBack30SecondsTemplateName: string;
    export let touchBarSkipBackTemplateName: string;
    export let touchBarSkipToEndTemplateName: string;
    export let touchBarSkipToStartTemplateName: string;
    export let touchBarSlideshowTemplateName: string;
    export let touchBarTagIconTemplateName: string;
    export let touchBarTextBoldTemplateName: string;
    export let touchBarTextBoxTemplateName: string;
    export let touchBarTextCenterAlignTemplateName: string;
    export let touchBarTextItalicTemplateName: string;
    export let touchBarTextJustifiedAlignTemplateName: string;
    export let touchBarTextLeftAlignTemplateName: string;
    export let touchBarTextListTemplateName: string;
    export let touchBarTextRightAlignTemplateName: string;
    export let touchBarTextStrikethroughTemplateName: string;
    export let touchBarTextUnderlineTemplateName: string;
    export let touchBarUserAddTemplateName: string;
    export let touchBarUserGroupTemplateName: string;
    export let touchBarUserTemplateName: string;
    export let touchBarVolumeDownTemplateName: string;
    export let touchBarVolumeUpTemplateName: string;
    export let trashEmptyName: string;
    export let trashFullName: string;
    export let userName: string;
    export let userAccountsName: string;
    export let userGroupName: string;
    export let userGuestName: string;
    export type Name = String;
  }

  namespace NSImageRep {
    export let ctm: string;
    export let interpolation: string;
    export let userInterfaceLayoutDirection: string;
    export let registryDidChangeNotification: string;
  }

  namespace NSImageView {
    export enum FrameStyle {
      None = 0,
      Photo = 1,
      GrayBezel = 2,
      Groove = 3,
      Button = 4
    }

  }

  namespace NSIndexSet {
    export type Element = NSIndexSetIterator;
    export type Iterator = NSIndexSetIterator;
  }

  namespace NSItemProvider {
    export enum ErrorCode {
      UnknownError = -1,
      ItemUnavailableError = -1000,
      UnexpectedValueClassError = -1100,
      UnavailableCoercionError = -1200
    }

    export let errorDomain: string;
  }

  namespace NSKeyValueChangeKey {
    export let indexesKey: string;
    export let kindKey: string;
    export let newKey: string;
    export let notificationIsPriorKey: string;
    export let oldKey: string;
  }

  namespace NSKeyValueOperator {
    export let averageKeyValueOperator: string;
    export let countKeyValueOperator: string;
    export let distinctUnionOfArraysKeyValueOperator: string;
    export let distinctUnionOfObjectsKeyValueOperator: string;
    export let distinctUnionOfSetsKeyValueOperator: string;
    export let maximumKeyValueOperator: string;
    export let minimumKeyValueOperator: string;
    export let sumKeyValueOperator: string;
    export let unionOfArraysKeyValueOperator: string;
    export let unionOfObjectsKeyValueOperator: string;
    export let unionOfSetsKeyValueOperator: string;
  }

  namespace NSLayoutConstraint {
    export enum Attribute {
      Left = 1,
      Right = 2,
      Top = 3,
      Bottom = 4,
      Leading = 5,
      Trailing = 6,
      Width = 7,
      Height = 8,
      CenterX = 9,
      CenterY = 10,
      LastBaseline = 11,
      Baseline = 11,
      FirstBaseline = 12,
      NotAnAttribute = 0
    }

    export enum Orientation {
      Horizontal = 0,
      Vertical = 1
    }

    export enum FormatOptions {
      AlignAllLeft = 2,
      AlignAllRight = 4,
      AlignAllTop = 8,
      AlignAllBottom = 16,
      AlignAllLeading = 32,
      AlignAllTrailing = 64,
      AlignAllCenterX = 512,
      AlignAllCenterY = 1024,
      AlignAllLastBaseline = 2048,
      AlignAllFirstBaseline = 4096,
      AlignAllBaseline = 2048,
      AlignmentMask = 65535,
      DirectionLeadingToTrailing = 0,
      DirectionLeftToRight = 65536,
      DirectionRightToLeft = 131072,
      DirectionMask = 196608
    }

    export enum Relation {
      LessThanOrEqual = -1,
      Equal = 0,
      GreaterThanOrEqual = 1
    }

    export let defaultHigh: number;
    export let defaultLow: number;
    export let dragThatCanResizeWindow: number;
    export let dragThatCannotResizeWindow: number;
    export let fittingSizeCompression: number;
    export let required: number;
    export let windowSizeStayPut: number;
  }

  namespace NSLayoutManager {
    export enum ControlCharacterAction {
      ZeroAdvancement = 1,
      Whitespace = 2,
      HorizontalTab = 4,
      LineBreak = 8,
      ParagraphBreak = 16,
      ContainerBreak = 32
    }

    export enum GlyphProperty {
      Null = 1,
      ControlCharacter = 2,
      Elastic = 4,
      NonBaseCharacter = 8
    }

    export enum TextLayoutOrientation {
      Horizontal = 0,
      Vertical = 1
    }

    export enum TypesetterBehavior {
      LatestBehavior = -1,
      OriginalBehavior = 0,
      Behavior_10_2_WithCompatibility = 1,
      Behavior_10_2 = 2,
      Behavior_10_3 = 3,
      Behavior_10_4 = 4
    }

  }

  namespace NSLevelIndicator {
    export enum PlaceholderVisibility {
      Automatic = 0,
      Always = 1,
      WhileEditing = 2
    }

    export enum Style {
      Relevancy = 0,
      ContinuousCapacity = 1,
      DiscreteCapacity = 2,
      Rating = 3
    }

  }

  namespace NSLinguisticTag {
    export let adjective: string;
    export let adverb: string;
    export let classifier: string;
    export let closeParenthesis: string;
    export let closeQuote: string;
    export let conjunction: string;
    export let dash: string;
    export let determiner: string;
    export let idiom: string;
    export let interjection: string;
    export let noun: string;
    export let number: string;
    export let openParenthesis: string;
    export let openQuote: string;
    export let organizationName: string;
    export let other: string;
    export let otherPunctuation: string;
    export let otherWhitespace: string;
    export let otherWord: string;
    export let paragraphBreak: string;
    export let particle: string;
    export let personalName: string;
    export let placeName: string;
    export let preposition: string;
    export let pronoun: string;
    export let punctuation: string;
    export let sentenceTerminator: string;
    export let verb: string;
    export let whitespace: string;
    export let word: string;
    export let wordJoiner: string;
  }

  namespace NSLinguisticTagScheme {
    export let language: string;
    export let lemma: string;
    export let lexicalClass: string;
    export let nameType: string;
    export let nameTypeOrLexicalClass: string;
    export let script: string;
    export let tokenType: string;
  }

  namespace NSLinguisticTagger {
    export enum Options {
      OmitWords = 1,
      OmitPunctuation = 2,
      OmitWhitespace = 4,
      OmitOther = 8,
      JoinNames = 16
    }

  }

  namespace NSLocale {
    export enum LanguageDirection {
      Unknown = 0,
      LeftToRight = 1,
      RightToLeft = 2,
      TopToBottom = 3,
      BottomToTop = 4
    }

    export let currentLocaleDidChangeNotification: string;
    export let alternateQuotationBeginDelimiterKey: string;
    export let alternateQuotationEndDelimiterKey: string;
    export let calendar: string;
    export let collationIdentifier: string;
    export let collatorIdentifier: string;
    export let countryCode: string;
    export let currencyCode: string;
    export let currencySymbol: string;
    export let decimalSeparator: string;
    export let exemplarCharacterSet: string;
    export let groupingSeparator: string;
    export let identifier: string;
    export let languageCode: string;
    export let measurementSystem: string;
    export let quotationBeginDelimiterKey: string;
    export let quotationEndDelimiterKey: string;
    export let scriptCode: string;
    export let usesMetricSystem: string;
    export let variantCode: string;
  }

  namespace NSMachPort {
    export enum Options {
      DeallocateNone = 0,
      DeallocateSendRight = 1,
      DeallocateReceiveRight = 2
    }

  }

  namespace NSManagedObject {
    export type ObjectWillChangePublisher = ObservableObjectPublisher;
  }

  namespace NSMatrix {
    export enum Mode {
      RadioModeMatrix = 0,
      HighlightModeMatrix = 1,
      ListModeMatrix = 2,
      TrackModeMatrix = 3
    }

  }

  namespace NSMediaLibraryBrowserController {
    export enum Library {
      Audio = 1,
      Image = 2,
      Movie = 4
    }

  }

  namespace NSMenu {
    export enum Properties {
      PropertyItemTitle = 1,
      PropertyItemAttributedTitle = 2,
      PropertyItemKeyEquivalent = 4,
      PropertyItemImage = 8,
      PropertyItemEnabled = 16,
      PropertyItemAccessibilityDescription = 32
    }

    export let didAddItemNotification: string;
    export let didBeginTrackingNotification: string;
    export let didChangeItemNotification: string;
    export let didEndTrackingNotification: string;
    export let didRemoveItemNotification: string;
    export let didSendActionNotification: string;
    export let willSendActionNotification: string;
  }

  namespace NSMenuItem {
    export let importFromDeviceIdentifier: string;
  }

  namespace NSNib {
    export type Name = String;
  }

  namespace NSNotification {
    export let AVAssetChapterMetadataGroupsDidChange: string;
    export let AVAssetContainsFragmentsDidChange: string;
    export let AVAssetDurationDidChange: string;
    export let AVAssetMediaSelectionGroupsDidChange: string;
    export let AVAssetTrackSegmentsDidChange: string;
    export let AVAssetTrackTimeRangeDidChange: string;
    export let AVAssetTrackTrackAssociationsDidChange: string;
    export let AVAssetWasDefragmented: string;
    export let AVAudioEngineConfigurationChange: string;
    export let AVAudioUnitComponentTagsDidChange: string;
    export let AVCaptureDeviceSubjectAreaDidChange: string;
    export let AVCaptureDeviceWasConnected: string;
    export let AVCaptureDeviceWasDisconnected: string;
    export let AVCaptureInputPortFormatDescriptionDidChange: string;
    export let AVCaptureSessionDidStartRunning: string;
    export let AVCaptureSessionDidStopRunning: string;
    export let AVCaptureSessionInterruptionEnded: string;
    export let AVCaptureSessionRuntimeError: string;
    export let AVCaptureSessionWasInterrupted: string;
    export let AVFragmentedMovieContainsMovieFragmentsDidChange: string;
    export let AVFragmentedMovieDurationDidChange: string;
    export let AVFragmentedMovieTrackSegmentsDidChange: string;
    export let AVFragmentedMovieTrackTimeRangeDidChange: string;
    export let AVFragmentedMovieWasDefragmented: string;
    export let AVPlayerAvailableHDRModesDidChange: string;
    export let AVPlayerItemDidPlayToEndTime: string;
    export let AVPlayerItemFailedToPlayToEndTime: string;
    export let AVPlayerItemNewAccessLogEntry: string;
    export let AVPlayerItemNewErrorLogEntry: string;
    export let AVPlayerItemPlaybackStalled: string;
    export let AVPlayerItemTimeJumped: string;
    export let AVRouteDetectorMultipleRoutesDetectedDidChange: string;
    export let AVSampleBufferAudioRendererWasFlushedAutomatically: string;
    export let AVSampleBufferDisplayLayerFailedToDecode: string;
    export let NSAppleEventManagerWillProcessFirstEvent: string;
    export let NSBundleResourceRequestLowDiskSpace: string;
    export let NSCalendarDayChanged: string;
    export let NSClassDescriptionNeededForClass: string;
    export let NSDidBecomeSingleThreaded: string;
    export let NSExtensionHostDidBecomeActive: string;
    export let NSExtensionHostDidEnterBackground: string;
    export let NSExtensionHostWillEnterForeground: string;
    export let NSExtensionHostWillResignActive: string;
    export let NSFileHandleConnectionAccepted: string;
    export let NSFileHandleDataAvailable: string;
    export let NSFileHandleReadToEndOfFileCompletion: string;
    export let NSHTTPCookieManagerAcceptPolicyChanged: string;
    export let NSHTTPCookieManagerCookiesChanged: string;
    export let NSMetadataQueryDidFinishGathering: string;
    export let NSMetadataQueryDidStartGathering: string;
    export let NSMetadataQueryDidUpdate: string;
    export let NSMetadataQueryGatheringProgress: string;
    export let NSProcessInfoPowerStateDidChange: string;
    export let NSSystemClockDidChange: string;
    export let NSSystemTimeZoneDidChange: string;
    export let NSThreadWillExit: string;
    export let NSURLCredentialStorageChanged: string;
    export let NSUbiquityIdentityDidChange: string;
    export let NSUndoManagerCheckpoint: string;
    export let NSUndoManagerDidCloseUndoGroup: string;
    export let NSUndoManagerDidOpenUndoGroup: string;
    export let NSUndoManagerDidRedoChange: string;
    export let NSUndoManagerDidUndoChange: string;
    export let NSUndoManagerWillCloseUndoGroup: string;
    export let NSUndoManagerWillRedoChange: string;
    export let NSUndoManagerWillUndoChange: string;
    export let NSWillBecomeMultiThreaded: string;
    export let IKFilterBrowserFilterDoubleClick: string;
    export let IKFilterBrowserFilterSelected: string;
    export let IKFilterBrowserWillPreviewFilter: string;
    export let quartzFilterManagerDidAddFilter: string;
    export let quartzFilterManagerDidModifyFilter: string;
    export let quartzFilterManagerDidRemoveFilter: string;
    export let quartzFilterManagerDidSelectFilter: string;
  }

  namespace NSNumber {
    export type BooleanLiteralType = boolean;
    export type IntegerLiteralType = number;
    export type FloatLiteralType = number;
  }

  namespace NSOrderedSet {
    export type Iterator = NSFastEnumerationIterator;
  }

  namespace NSOutlineView {
    export let columnDidMoveNotification: string;
    export let columnDidResizeNotification: string;
    export let disclosureButtonIdentifier: string;
    export let itemDidCollapseNotification: string;
    export let itemDidExpandNotification: string;
    export let itemWillCollapseNotification: string;
    export let itemWillExpandNotification: string;
    export let selectionDidChangeNotification: string;
    export let selectionIsChangingNotification: string;
    export let showHideButtonIdentifier: string;
  }

  namespace NSPDFPanel {
    export enum Options {
      ShowsPaperSize = 4,
      ShowsOrientation = 8,
      RequestsParentDirectory = 16777216
    }

  }

  namespace NSPageController {
    export enum TransitionStyle {
      StackHistory = 0,
      StackBook = 1,
      HorizontalStrip = 2
    }

    export type ObjectIdentifier = String;
  }

  namespace NSParagraphStyle {
    export enum TextTabType {
      LeftTabStopType = 0,
      RightTabStopType = 1,
      CenterTabStopType = 2,
      DecimalTabStopType = 3
    }

    // struct
    export enum LineBreakStrategy {
      pushOut,
      hangulWordPriority,
      standard
    }

  }

  namespace NSPasteboard {
    export enum ContentsOptions {
      CurrentHostOnly = 1
    }

    export enum ReadingOptions {
      AsData = 0,
      AsString = 1,
      AsPropertyList = 2,
      AsKeyedArchive = 4
    }

    export enum WritingOptions {
      Promised = 512
    }

    export let fileContents: string;
    export let findPanelSearchOptions: string;
    export let drag: string;
    export let find: string;
    export let font: string;
    export let general: string;
    export let ruler: string;
    export let color: string;
    export let fileURL: string;
    export let html: string;
    export let multipleTextSelection: string;
    export let pdf: string;
    export let png: string;
    export let rtf: string;
    export let rtfd: string;
    export let sound: string;
    export let string: string;
    export let tiff: string;
    export let tabularText: string;
    export let textFinderOptions: string;
    export let URL: string;
    export let urlReadingContentsConformToTypes: string;
    export let urlReadingFileURLsOnly: string;
    export let soundPboardType: string;
  }

  namespace NSPathControl {
    export enum Style {
      Standard = 0,
      PopUp = 2,
      NavigationBar = 1
    }

  }

  namespace NSPickerTouchBarItem {
    export enum ControlRepresentation {
      Automatic = 0,
      Expanded = 1,
      Collapsed = 2
    }

    export enum SelectionMode {
      SelectOne = 0,
      SelectAny = 1,
      Momentary = 2
    }

  }

  namespace NSPointerFunctions {
    export enum Options {
      StrongMemory = 0,
      ZeroingWeakMemory = 1,
      OpaqueMemory = 2,
      MallocMemory = 3,
      MachVirtualMemory = 4,
      WeakMemory = 5,
      ObjectPersonality = 0,
      OpaquePersonality = 256,
      ObjectPointerPersonality = 512,
      CStringPersonality = 768,
      StructPersonality = 1024,
      IntegerPersonality = 1280,
      CopyIn = 65536
    }

  }

  namespace NSPopUpButton {
    export enum ArrowPosition {
      NoArrow = 0,
      ArrowAtCenter = 1,
      ArrowAtBottom = 2
    }

    export let willPopUpNotification: string;
  }

  namespace NSPopUpButtonCell {
    export let willPopUpNotification: string;
  }

  namespace NSPopover {
    export enum Behavior {
      ApplicationDefined = 0,
      Transient = 1,
      Semitransient = 2
    }

    export let detachToWindow: string;
    export let closeReasonUserInfoKey: string;
    export let standard: string;
    export let didCloseNotification: string;
    export let didShowNotification: string;
    export let willCloseNotification: string;
    export let willShowNotification: string;
  }

  namespace NSPositionalSpecifier {
    export enum InsertionPosition {
      PositionAfter = 0,
      PositionBefore = 1,
      PositionBeginning = 2,
      PositionEnd = 3,
      PositionReplace = 4
    }

  }

  namespace NSPrintInfo {
    export enum PaperOrientation {
      Portrait = 0,
      Landscape = 1
    }

    export enum PaginationMode {
      Automatic = 0,
      Fit = 1,
      Clip = 2
    }

    export let automatic: NSPrintInfo.PaginationMode;
    export let clip: NSPrintInfo.PaginationMode;
    export let fit: NSPrintInfo.PaginationMode;
    export let allPages: string;
    export let bottomMargin: string;
    export let cancel: string;
    export let copies: string;
    export let detailedErrorReporting: string;
    export let faxNumber: string;
    export let firstPage: string;
    export let headerAndFooter: string;
    export let horizontalPagination: string;
    export let horizontallyCentered: string;
    export let jobDisposition: string;
    export let jobSavingFileNameExtensionHidden: string;
    export let jobSavingURL: string;
    export let lastPage: string;
    export let leftMargin: string;
    export let mustCollate: string;
    export let orientation: string;
    export let pagesAcross: string;
    export let pagesDown: string;
    export let paperName: string;
    export let paperSize: string;
    export let preview: string;
    export let printer: string;
    export let printerName: string;
    export let reversePageOrder: string;
    export let rightMargin: string;
    export let save: string;
    export let scalingFactor: string;
    export let selectionOnly: string;
    export let spool: string;
    export let time: string;
    export let topMargin: string;
    export let verticalPagination: string;
    export let verticallyCentered: string;
    export type SettingKey = String;
  }

  namespace NSPrintOperation {
    export enum RenderingQuality {
      Best = 0,
      Responsive = 1
    }

    export enum PageOrder {
      DescendingPageOrder = -1,
      SpecialPageOrder = 0,
      AscendingPageOrder = 1,
      UnknownPageOrder = 2
    }

  }

  namespace NSPrintPanel {
    export enum Options {
      ShowsCopies = 1,
      ShowsPageRange = 2,
      ShowsPaperSize = 4,
      ShowsOrientation = 8,
      ShowsScaling = 16,
      ShowsPrintSelection = 32,
      ShowsPageSetupAccessory = 256,
      ShowsPreview = 131072
    }

    export let allPresets: string;
    export let noPresets: string;
    export let itemDescription: string;
    export let itemName: string;
    export let photo: string;
  }

  namespace NSPrinter {
    export enum TableStatus {
      OK = 0,
      NotFound = 1,
      Error = 2
    }

  }

  namespace NSProgressIndicator {
    export enum Style {
      Bar = 0,
      Spinning = 1
    }

  }

  namespace NSRegularExpression {
    export enum MatchingFlags {
      Progress = 1,
      Completed = 2,
      HitEnd = 4,
      RequiredEnd = 8,
      InternalError = 16
    }

    export enum MatchingOptions {
      ReportProgress = 1,
      ReportCompletion = 2,
      Anchored = 4,
      WithTransparentBounds = 8,
      WithoutAnchoringBounds = 16
    }

    export enum Options {
      CaseInsensitive = 1,
      AllowCommentsAndWhitespace = 2,
      IgnoreMetacharacters = 4,
      DotMatchesLineSeparators = 8,
      AnchorsMatchLines = 16,
      UseUnixLineSeparators = 32,
      UseUnicodeWordBoundaries = 64
    }

  }

  namespace NSRelativeSpecifier {
    export enum RelativePosition {
      After = 0,
      Before = 1
    }

  }

  namespace NSRuleEditor {
    export enum NestingMode {
      Single = 0,
      List = 1,
      Compound = 2,
      Simple = 3
    }

    export enum RowType {
      Simple = 0,
      Compound = 1
    }

    export let comparisonModifier: string;
    export let compoundType: string;
    export let customSelector: string;
    export let leftExpression: string;
    export let operatorType: string;
    export let options: string;
    export let rightExpression: string;
    export let rowsDidChangeNotification: string;
  }

  namespace NSRulerView {
    export enum Orientation {
      HorizontalRuler = 0,
      VerticalRuler = 1
    }

    export let centimeters: string;
    export let inches: string;
    export let picas: string;
    export let points: string;
  }

  namespace NSScreen {
    export let colorSpaceDidChangeNotification: string;
  }

  namespace NSScrollView {
    export enum Elasticity {
      Automatic = 0,
      None = 1,
      Allowed = 2
    }

    export enum FindBarPosition {
      AboveHorizontalRuler = 0,
      AboveContent = 1,
      BelowContent = 2
    }

    export let didEndLiveMagnifyNotification: string;
    export let didEndLiveScrollNotification: string;
    export let didLiveScrollNotification: string;
    export let willStartLiveMagnifyNotification: string;
    export let willStartLiveScrollNotification: string;
  }

  namespace NSScroller {
    export enum KnobStyle {
      Default = 0,
      Dark = 1,
      Light = 2
    }

    export enum Part {
      NoPart = 0,
      DecrementPage = 1,
      Knob = 2,
      IncrementPage = 3,
      DecrementLine = 4,
      IncrementLine = 5,
      KnobSlot = 6
    }

    export enum Style {
      Legacy = 0,
      Overlay = 1
    }

    export enum UsableParts {
      NoScrollerParts = 0,
      OnlyScrollerArrows = 1,
      AllScrollerParts = 2
    }

    export let preferredScrollerStyleDidChangeNotification: string;
  }

  namespace NSScrubber {
    export enum Alignment {
      None = 0,
      Leading = 1,
      Trailing = 2,
      Center = 3
    }

    export enum Mode {
      Fixed = 0,
      Free = 1
    }

  }

  namespace NSSearchField {
    export let clearRecentsMenuItemTag: number;
    export let noRecentsMenuItemTag: number;
    export let recentsMenuItemTag: number;
    export let recentsTitleMenuItemTag: number;
    export type RecentsAutosaveName = String;
  }

  namespace NSSegmentedControl {
    export enum Distribution {
      Fit = 0,
      Fill = 1,
      FillEqually = 2,
      FillProportionally = 3
    }

    export enum Style {
      Automatic = 0,
      Rounded = 1,
      RoundRect = 3,
      TexturedSquare = 4,
      SmallSquare = 6,
      Separated = 8,
      TexturedRounded = 2,
      Capsule = 5
    }

    export enum SwitchTracking {
      SelectOne = 0,
      SelectAny = 1,
      Momentary = 2,
      MomentaryAccelerator = 3
    }

  }

  namespace NSSet {
    export type Iterator = NSFastEnumerationIterator;
  }

  namespace NSSharingService {
    export enum CloudKitOptions {
      Standard = 0,
      AllowPublic = 1,
      AllowPrivate = 2,
      AllowReadOnly = 16,
      AllowReadWrite = 32
    }

    export enum SharingContentScope {
      Item = 0,
      Partial = 1,
      Full = 2
    }

    export let addToAperture: string;
    export let addToIPhoto: string;
    export let addToSafariReadingList: string;
    export let cloudSharing: string;
    export let composeEmail: string;
    export let composeMessage: string;
    export let sendViaAirDrop: string;
    export let useAsDesktopPicture: string;
  }

  namespace NSSlider {
    export enum SliderType {
      Linear = 0,
      Circular = 1
    }

    export enum TickMarkPosition {
      Below = 0,
      Above = 1,
      Leading = 1,
      Trailing = 0
    }

  }

  namespace NSSliderAccessory {
    export let default_: number;
    export let wide: number;
  }

  namespace NSSound {
    export type Name = String;
    export type PlaybackDeviceIdentifier = String;
  }

  namespace NSSpecifierTest {
    export enum TestComparisonOperation {
      EqualToComparison = 0,
      LessThanOrEqualToComparison = 1,
      LessThanComparison = 2,
      GreaterThanOrEqualToComparison = 3,
      GreaterThanComparison = 4,
      BeginsWithComparison = 5,
      EndsWithComparison = 6,
      ContainsComparison = 7
    }

  }

  namespace NSSpeechSynthesizer {
    export enum Boundary {
      ImmediateBoundary = 0,
      WordBoundary = 1,
      SentenceBoundary = 2
    }

    export let characterMode: string;
    export let commandDelimiter: string;
    export let currentVoice: string;
    export let abbreviations: string;
    export let entryPhonemes: string;
    export let entrySpelling: string;
    export let localeIdentifier: string;
    export let modificationDate: string;
    export let pronunciations: string;
    export let errors: string;
    export let inputMode: string;
    export let numberMode: string;
    export let outputToFileURL: string;
    export let phonemeSymbols: string;
    export let pitchBase: string;
    export let pitchMod: string;
    export let rate: string;
    export let recentSync: string;
    export let reset: string;
    export let status: string;
    export let synthesizerInfo: string;
    export let volume: string;
    export let age: string;
    export let demoText: string;
    export let gender: string;
    export let female: string;
    export let male: string;
    export let neuter: string;
    export let identifier: string;
    export let individuallySpokenCharacters: string;
    export let name: string;
    export let supportedCharacters: string;
  }

  namespace NSSpellChecker {
    export enum CorrectionIndicatorType {
      Default = 0,
      Reversion = 1,
      Guesses = 2
    }

    export enum CorrectionResponse {
      None = 0,
      Accepted = 1,
      Rejected = 2,
      Ignored = 3,
      Edited = 4,
      Reverted = 5
    }

    export let didChangeAutomaticCapitalizationNotification: string;
    export let didChangeAutomaticDashSubstitutionNotification: string;
    export let didChangeAutomaticPeriodSubstitutionNotification: string;
    export let didChangeAutomaticQuoteSubstitutionNotification: string;
    export let didChangeAutomaticSpellingCorrectionNotification: string;
    export let didChangeAutomaticTextCompletionNotification: string;
    export let didChangeAutomaticTextReplacementNotification: string;
    export let documentAuthor: string;
    export let documentTitle: string;
    export let documentURL: string;
    export let orthography: string;
    export let quotes: string;
    export let referenceDate: string;
    export let referenceTimeZone: string;
    export let regularExpressions: string;
    export let replacements: string;
    export let selectedRange: string;
  }

  namespace NSSplitView {
    export enum DividerStyle {
      Thick = 1,
      Thin = 2,
      PaneSplitter = 3
    }

    export let didResizeSubviewsNotification: string;
    export let willResizeSubviewsNotification: string;
    export type AutosaveName = String;
  }

  namespace NSSplitViewController {
    export let automaticDimension: number;
  }

  namespace NSSplitViewItem {
    export enum Behavior {
      Default = 0,
      Sidebar = 1,
      ContentList = 2
    }

    export enum CollapseBehavior {
      Default = 0,
      PreferResizingSplitViewWithFixedSiblings = 1,
      PreferResizingSiblingsWithFixedSplitView = 2,
      UseConstraints = 3
    }

    export let unspecifiedDimension: number;
  }

  namespace NSStackView {
    export enum Distribution {
      GravityAreas = -1,
      Fill = 0,
      FillEqually = 1,
      FillProportionally = 2,
      EqualSpacing = 3,
      EqualCentering = 4
    }

    export enum Gravity {
      Top = 1,
      Leading = 1,
      Center = 2,
      Bottom = 3,
      Trailing = 3
    }

    export let useDefaultSpacing: number;
    export let detachOnlyIfNecessary: number;
    export let mustHold: number;
    export let notVisible: number;
  }

  namespace NSStatusItem {
    export enum Behavior {
      RemovalAllowed = 2,
      TerminationOnRemoval = 4
    }

    export let squareLength: number;
    export let variableLength: number;
    export type AutosaveName = String;
  }

  namespace NSStoryboard {
    export type Name = String;
    export type SceneIdentifier = String;
  }

  namespace NSStoryboardSegue {
    export type Identifier = String;
  }

  namespace NSString {
    export enum DrawingOptions {
      UsesLineFragmentOrigin = 1,
      UsesFontLeading = 2,
      UsesDeviceMetrics = 8,
      TruncatesLastVisibleLine = 32,
      DisableScreenFontSubstitution = 4,
      OneShot = 16
    }

    export enum CompareOptions {
      CaseInsensitiveSearch = 1,
      LiteralSearch = 2,
      BackwardsSearch = 4,
      AnchoredSearch = 8,
      NumericSearch = 64,
      DiacriticInsensitiveSearch = 128,
      WidthInsensitiveSearch = 256,
      ForcedOrderingSearch = 512,
      RegularExpressionSearch = 1024
    }

    export enum EncodingConversionOptions {
      AllowLossy = 1,
      ExternalRepresentation = 2
    }

    export enum EnumerationOptions {
      ByLines = 0,
      ByParagraphs = 1,
      ByComposedCharacterSequences = 2,
      ByWords = 3,
      BySentences = 4,
      Reverse = 256,
      SubstringNotRequired = 512,
      Localized = 1024
    }

    export type StringLiteralType = string;
    export type ExtendedGraphemeClusterLiteralType = string;
    export type UnicodeScalarLiteralType = string;
  }

  namespace NSTabView {
    export enum TabPosition {
      None = 0,
      Top = 1,
      Left = 2,
      Bottom = 3,
      Right = 4
    }

    export enum TabViewBorderType {
      None = 0,
      Line = 1,
      Bezel = 2
    }

    export enum TabType {
      TopTabsBezelBorder = 0,
      LeftTabsBezelBorder = 1,
      BottomTabsBezelBorder = 2,
      RightTabsBezelBorder = 3,
      NoTabsBezelBorder = 4,
      NoTabsLineBorder = 5,
      NoTabsNoBorder = 6
    }

  }

  namespace NSTabViewController {
    export enum TabStyle {
      SegmentedControlOnTop = 0,
      SegmentedControlOnBottom = 1,
      Toolbar = 2,
      Unspecified = -1
    }

  }

  namespace NSTabViewItem {
    export enum State {
      SelectedTab = 0,
      BackgroundTab = 1,
      PressedTab = 2
    }

  }

  namespace NSTableColumn {
    export enum ResizingOptions {
      NoResizing = 0,
      AutoresizingMask = 1,
      UserResizingMask = 2
    }

  }

  namespace NSTableView {
    export enum RowActionEdge {
      Leading = 0,
      Trailing = 1
    }

    export enum AnimationOptions {
      EffectNone = 0,
      EffectFade = 1,
      EffectGap = 2,
      SlideUp = 16,
      SlideDown = 32,
      SlideLeft = 48,
      SlideRight = 64
    }

    export enum ColumnAutoresizingStyle {
      NoColumnAutoresizing = 0,
      UniformColumnAutoresizingStyle = 1,
      SequentialColumnAutoresizingStyle = 2,
      ReverseSequentialColumnAutoresizingStyle = 3,
      LastColumnOnlyAutoresizingStyle = 4,
      FirstColumnOnlyAutoresizingStyle = 5
    }

    export enum DraggingDestinationFeedbackStyle {
      None = -1,
      Regular = 0,
      SourceList = 1,
      Gap = 2
    }

    export enum DropOperation {
      On = 0,
      Above = 1
    }

    export enum GridLineStyle {
      GridNone = 0,
      SolidVerticalGridLineMask = 1,
      SolidHorizontalGridLineMask = 2,
      DashedHorizontalGridLineMask = 8
    }

    export enum RowSizeStyle {
      Default = -1,
      Custom = 0,
      Small = 1,
      Medium = 2,
      Large = 3
    }

    export enum SelectionHighlightStyle {
      None = -1,
      Regular = 0,
      SourceList = 1
    }

    export let columnDidMoveNotification: string;
    export let columnDidResizeNotification: string;
    export let rowViewIdentifier: string;
    export let selectionDidChangeNotification: string;
    export let selectionIsChangingNotification: string;
    export type AutosaveName = String;
  }

  namespace NSTableViewRowAction {
    export enum Style {
      Regular = 0,
      Destructive = 1
    }

  }

  namespace NSText {
    export let didBeginEditingNotification: string;
    export let didChangeNotification: string;
    export let didEndEditingNotification: string;
    export let movementUserInfoKey: string;
  }

  namespace NSTextAlternatives {
    export let selectedAlternativeStringNotification: string;
  }

  namespace NSTextBlock {
    export enum Dimension {
      Width = 0,
      MinimumWidth = 1,
      MaximumWidth = 2,
      Height = 4,
      MinimumHeight = 5,
      MaximumHeight = 6
    }

    export enum Layer {
      Padding = -1,
      Border = 0,
      Margin = 1
    }

    export enum ValueType {
      AbsoluteValueType = 0,
      PercentageValueType = 1
    }

    export enum VerticalAlignment {
      TopAlignment = 0,
      MiddleAlignment = 1,
      BottomAlignment = 2,
      BaselineAlignment = 3
    }

  }

  namespace NSTextCheckingKey {
    export let airline: string;
    export let city: string;
    export let country: string;
    export let flight: string;
    export let jobTitle: string;
    export let name: string;
    export let organization: string;
    export let phone: string;
    export let state: string;
    export let street: string;
    export let zip: string;
  }

  namespace NSTextCheckingResult {
    export enum CheckingType {
      Orthography = 1,
      Spelling = 2,
      Grammar = 4,
      Date = 8,
      Address = 16,
      Link = 32,
      Quote = 64,
      Dash = 128,
      Replacement = 256,
      Correction = 512,
      RegularExpression = 1024,
      PhoneNumber = 2048,
      TransitInformation = 4096
    }

  }

  namespace NSTextField {
    export enum BezelStyle {
      SquareBezel = 0,
      RoundedBezel = 1
    }

  }

  namespace NSTextFinder {
    export enum Action {
      ShowFindInterface = 1,
      NextMatch = 2,
      PreviousMatch = 3,
      ReplaceAll = 4,
      Replace = 5,
      ReplaceAndFind = 6,
      SetSearchString = 7,
      ReplaceAllInSelection = 8,
      SelectAll = 9,
      SelectAllInSelection = 10,
      HideFindInterface = 11,
      ShowReplaceInterface = 12,
      HideReplaceInterface = 13
    }

    export enum MatchingType {
      Contains = 0,
      StartsWith = 1,
      FullWord = 2,
      EndsWith = 3
    }

  }

  namespace NSTextInputContext {
    export let keyboardSelectionDidChangeNotification: string;
  }

  namespace NSTextList {
    export enum Options {
      PrependEnclosingMarker = 1
    }

    export let box: string;
    export let check: string;
    export let circle: string;
    export let decimal: string;
    export let diamond: string;
    export let disc: string;
    export let hyphen: string;
    export let lowercaseAlpha: string;
    export let lowercaseHexadecimal: string;
    export let lowercaseLatin: string;
    export let lowercaseRoman: string;
    export let octal: string;
    export let square: string;
    export let uppercaseAlpha: string;
    export let uppercaseHexadecimal: string;
    export let uppercaseLatin: string;
    export let uppercaseRoman: string;
  }

  namespace NSTextStorage {
    export let didProcessEditingNotification: string;
    export let willProcessEditingNotification: string;
  }

  namespace NSTextTab {
    export let columnTerminators: string;
  }

  namespace NSTextTable {
    export enum LayoutAlgorithm {
      AutomaticLayoutAlgorithm = 0,
      FixedLayoutAlgorithm = 1
    }

  }

  namespace NSTextView {
    export let didChangeSelectionNotification: string;
    export let didChangeTypingAttributesNotification: string;
    export let willChangeNotifyingTextViewNotification: string;
  }

  namespace NSTimeZone {
    export enum NameStyle {
      Standard = 0,
      ShortStandard = 1,
      DaylightSaving = 2,
      ShortDaylightSaving = 3,
      Generic = 4,
      ShortGeneric = 5
    }

  }

  namespace NSTokenField {
    export enum TokenStyle {
      Default = 0,
      None = 1,
      Rounded = 2,
      Squared = 3,
      PlainSquared = 4
    }

  }

  namespace NSToolbar {
    export enum DisplayMode {
      Default = 0,
      IconAndLabel = 1,
      IconOnly = 2,
      LabelOnly = 3
    }

    export enum SizeMode {
      Default = 0,
      Regular = 1,
      Small = 2
    }

    export let didRemoveItemNotification: string;
    export let willAddItemNotification: string;
    export type Identifier = String;
  }

  namespace NSToolbarItem {
    export let cloudSharing: string;
    export let customizeToolbar: string;
    export let flexibleSpace: string;
    export let high: number;
    export let low: number;
    export let standard: number;
    export let user: number;
    export let print: string;
    export let separator: string;
    export let showColors: string;
    export let showFonts: string;
    export let space: string;
    export let toggleSidebar: string;
  }

  namespace NSToolbarItemGroup {
    export enum ControlRepresentation {
      Automatic = 0,
      Expanded = 1,
      Collapsed = 2
    }

    export enum SelectionMode {
      SelectOne = 0,
      SelectAny = 1,
      Momentary = 2
    }

  }

  namespace NSTouch {
    export enum Phase {
      Began = 1,
      Moved = 2,
      Stationary = 4,
      Ended = 8,
      Cancelled = 16,
      Touching = 7,
      Any = -1
    }

    export enum TouchType {
      Direct = 0,
      Indirect = 1
    }

    export enum TouchTypeMask {
      Direct = 1,
      Indirect = 2
    }

  }

  namespace NSTouchBar {
    export type CustomizationIdentifier = String;
  }

  namespace NSTouchBarItem {
    export let candidateList: string;
    export let characterPicker: string;
    export let fixedSpaceLarge: string;
    export let fixedSpaceSmall: string;
    export let flexibleSpace: string;
    export let otherItemsProxy: string;
    export let textAlignment: string;
    export let textColorPicker: string;
    export let textFormat: string;
    export let textList: string;
    export let textStyle: string;
    export let high: number;
    export let low: number;
    export let normal: number;
  }

  namespace NSTrackingArea {
    export enum Options {
      MouseEnteredAndExited = 1,
      MouseMoved = 2,
      CursorUpdate = 4,
      ActiveWhenFirstResponder = 16,
      ActiveInKeyWindow = 32,
      ActiveInActiveApp = 64,
      ActiveAlways = 128,
      AssumeInside = 256,
      InVisibleRect = 512,
      EnabledDuringMouseDrag = 1024
    }

  }

  namespace NSURL {
    export enum BookmarkCreationOptions {
      PreferFileIDResolution = 256,
      MinimalBookmark = 512,
      SuitableForBookmarkFile = 1024,
      WithSecurityScope = 2048,
      SecurityScopeAllowOnlyReadAccess = 4096
    }

    export enum BookmarkResolutionOptions {
      WithoutUI = 256,
      WithoutMounting = 512,
      WithSecurityScope = 1024
    }

    export type BookmarkFileCreationOptions = number;
  }

  namespace NSURLHandle {
    export enum Status {
      NotLoaded = 0,
      LoadSucceeded = 1,
      LoadInProgress = 2,
      LoadFailed = 3
    }

  }

  namespace NSURLRequest {
    export enum CachePolicy {
      UseProtocolCachePolicy = 0,
      ReloadIgnoringLocalCacheData = 1,
      ReloadIgnoringLocalAndRemoteCacheData = 4,
      ReloadIgnoringCacheData = 1,
      ReturnCacheDataElseLoad = 2,
      ReturnCacheDataDontLoad = 3,
      ReloadRevalidatingCacheData = 5
    }

    export enum NetworkServiceType {
      NetworkServiceTypeDefault = 0,
      NetworkServiceTypeVoIP = 1,
      NetworkServiceTypeVideo = 2,
      NetworkServiceTypeBackground = 3,
      NetworkServiceTypeVoice = 4,
      NetworkServiceTypeResponsiveData = 6,
      NetworkServiceTypeAVStreaming = 8,
      NetworkServiceTypeResponsiveAV = 9,
      NetworkServiceTypeCallSignaling = 11
    }

  }

  namespace NSUbiquitousKeyValueStore {
    export let didChangeExternallyNotification: string;
  }

  namespace NSUserNotification {
    export enum ActivationType {
      None = 0,
      ContentsClicked = 1,
      ActionButtonClicked = 2,
      Replied = 3,
      AdditionalActionClicked = 4
    }

  }

  namespace NSValueTransformerName {
    export let isNilTransformerName: string;
    export let isNotNilTransformerName: string;
    export let negateBooleanTransformerName: string;
    export let secureUnarchiveFromDataTransformerName: string;
  }

  namespace NSView {
    export enum AutoresizingMask {
      ViewNotSizable = 0,
      ViewMinXMargin = 1,
      ViewWidthSizable = 2,
      ViewMaxXMargin = 4,
      ViewMinYMargin = 8,
      ViewHeightSizable = 16,
      ViewMaxYMargin = 32
    }

    export enum BackgroundStyle {
      Normal = 0,
      Emphasized = 1,
      Raised = 2,
      Lowered = 3
    }

    export enum LayerContentsPlacement {
      ScaleAxesIndependently = 0,
      ScaleProportionallyToFit = 1,
      ScaleProportionallyToFill = 2,
      Center = 3,
      Top = 4,
      TopRight = 5,
      Right = 6,
      BottomRight = 7,
      Bottom = 8,
      BottomLeft = 9,
      Left = 10,
      TopLeft = 11
    }

    export enum LayerContentsRedrawPolicy {
      Never = 0,
      OnSetNeedsDisplay = 1,
      DuringViewResize = 2,
      BeforeViewResize = 3,
      Crossfade = 4
    }

    export let emphasized: NSView.BackgroundStyle;
    export let normal: NSView.BackgroundStyle;
    export let dictionaryApplication: string;
    export let presentationType: string;
    export let overlay: string;
    export let fullScreenModeAllScreens: string;
    export let fullScreenModeApplicationPresentationOptions: string;
    export let fullScreenModeSetting: string;
    export let fullScreenModeWindowLevel: string;
    export let boundsDidChangeNotification: string;
    export let didUpdateTrackingAreasNotification: string;
    export let frameDidChangeNotification: string;
    export let noIntrinsicMetric: number;
    export type TrackingRectTag = number;
    export type ToolTipTag = number;
  }

  namespace NSViewAnimation {
    export let effect: string;
    export let endFrame: string;
    export let fadeIn: string;
    export let fadeOut: string;
    export let startFrame: string;
    export let target: string;
  }

  namespace NSViewController {
    export enum TransitionOptions {
      None = 0,
      Crossfade = 1,
      SlideUp = 16,
      SlideDown = 32,
      SlideLeft = 64,
      SlideRight = 128,
      SlideForward = 320,
      SlideBackward = 384,
      AllowUserInteraction = 4096
    }

  }

  namespace NSVisualEffectView {
    export enum BlendingMode {
      BehindWindow = 0,
      WithinWindow = 1
    }

    export enum Material {
      Titlebar = 3,
      Selection = 4,
      Menu = 5,
      Popover = 6,
      Sidebar = 7,
      HeaderView = 10,
      Sheet = 11,
      WindowBackground = 12,
      HUDWindow = 13,
      FullScreenUI = 15,
      ToolTip = 17,
      ContentBackground = 18,
      UnderWindowBackground = 21,
      UnderPageBackground = 22,
      AppearanceBased = 0,
      Light = 1,
      Dark = 2,
      MediumLight = 8,
      UltraDark = 9
    }

    export enum State {
      FollowsWindowActiveState = 0,
      Active = 1,
      Inactive = 2
    }

  }

  namespace NSWhoseSpecifier {
    export enum SubelementIdentifier {
      IndexSubelement = 0,
      EverySubelement = 1,
      MiddleSubelement = 2,
      RandomSubelement = 3,
      NoSubelement = 4
    }

  }

  namespace NSWindow {
    export enum BackingStoreType {
      Retained = 0,
      Nonretained = 1,
      Buffered = 2
    }

    export enum SelectionDirection {
      DirectSelection = 0,
      SelectingNext = 1,
      SelectingPrevious = 2
    }

    export enum AnimationBehavior {
      Default = 0,
      None = 2,
      DocumentWindow = 3,
      UtilityWindow = 4,
      AlertPanel = 5
    }

    export enum ButtonType {
      CloseButton = 0,
      MiniaturizeButton = 1,
      ZoomButton = 2,
      ToolbarButton = 3,
      DocumentIconButton = 4,
      DocumentVersionsButton = 6
    }

    export enum CollectionBehavior {
      Default = 0,
      CanJoinAllSpaces = 1,
      MoveToActiveSpace = 2,
      Managed = 4,
      Transient = 8,
      Stationary = 16,
      ParticipatesInCycle = 32,
      IgnoresCycle = 64,
      FullScreenPrimary = 128,
      FullScreenAuxiliary = 256,
      FullScreenNone = 512,
      FullScreenAllowsTiling = 2048,
      FullScreenDisallowsTiling = 4096
    }

    export enum Depth {
      TwentyfourBitRGB = 520,
      SixtyfourBitRGB = 528,
      OnehundredtwentyeightBitRGB = 544
    }

    export enum NumberListOptions {
      AllApplications = 1,
      AllSpaces = 16
    }

    export enum OcclusionState {
      Visible = 2
    }

    export enum OrderingMode {
      Above = 1,
      Below = -1,
      Out = 0
    }

    export enum SharingType {
      None = 0,
      ReadOnly = 1,
      ReadWrite = 2
    }

    export enum StyleMask {
      Borderless = 0,
      Titled = 1,
      Closable = 2,
      Miniaturizable = 4,
      Resizable = 8,
      TexturedBackground = 256,
      UnifiedTitleAndToolbar = 4096,
      FullScreen = 16384,
      FullSizeContentView = 32768,
      UtilityWindow = 16,
      DocModalWindow = 64,
      NonactivatingPanel = 128,
      HUDWindow = 8192
    }

    export enum TabbingMode {
      Automatic = 0,
      Preferred = 1,
      Disallowed = 2
    }

    export enum TitleVisibility {
      Visible = 0,
      Hidden = 1
    }

    export enum UserTabbingPreference {
      Manual = 0,
      Always = 1,
      InFullScreen = 2
    }

    export let oldColorSpaceUserInfoKey: string;
    export let oldScaleFactorUserInfoKey: string;
    export let floating: number;
    export let mainMenu: number;
    export let modalPanel: number;
    export let normal: number;
    export let popUpMenu: number;
    export let screenSaver: number;
    export let statusBar: number;
    export let submenu: number;
    export let tornOffMenu: number;
    export let didBecomeKeyNotification: string;
    export let didBecomeMainNotification: string;
    export let didChangeBackingPropertiesNotification: string;
    export let didChangeOcclusionStateNotification: string;
    export let didChangeScreenNotification: string;
    export let didChangeScreenProfileNotification: string;
    export let didDeminiaturizeNotification: string;
    export let didEndLiveResizeNotification: string;
    export let didEndSheetNotification: string;
    export let didEnterFullScreenNotification: string;
    export let didEnterVersionBrowserNotification: string;
    export let didExitFullScreenNotification: string;
    export let didExitVersionBrowserNotification: string;
    export let didExposeNotification: string;
    export let didMiniaturizeNotification: string;
    export let didMoveNotification: string;
    export let didResignKeyNotification: string;
    export let didResignMainNotification: string;
    export let didResizeNotification: string;
    export let didUpdateNotification: string;
    export let willBeginSheetNotification: string;
    export let willCloseNotification: string;
    export let willEnterFullScreenNotification: string;
    export let willEnterVersionBrowserNotification: string;
    export let willExitFullScreenNotification: string;
    export let willExitVersionBrowserNotification: string;
    export let willMiniaturizeNotification: string;
    export let willMoveNotification: string;
    export let willStartLiveResizeNotification: string;
    export type FrameAutosaveName = String;
    export type PersistableFrameDescriptor = String;
    export type TabbingIdentifier = String;
  }

  namespace NSWorkspace {
    export enum AuthorizationType {
      CreateSymbolicLink = 0,
      SetAttributes = 1,
      ReplaceFile = 2
    }

    export enum IconCreationOptions {
      ExcludeQuickDrawElementsIconCreationOption = 2,
      Exclude10_4ElementsIconCreationOption = 4
    }

    export enum LaunchOptions {
      AndPrint = 2,
      WithErrorPresentation = 64,
      InhibitingBackgroundOnly = 128,
      WithoutAddingToRecents = 256,
      WithoutActivation = 512,
      Async = 65536,
      NewInstance = 524288,
      AndHide = 1048576,
      AndHideOthers = 2097152,
      Default = 65536,
      AllowingClassicStartup = 131072,
      PreferringClassic = 262144
    }

    export let accessibilityDisplayOptionsDidChangeNotification: string;
    export let activeSpaceDidChangeNotification: string;
    export let applicationUserInfoKey: string;
    export let allowClipping: string;
    export let fillColor: string;
    export let imageScaling: string;
    export let didActivateApplicationNotification: string;
    export let didChangeFileLabelsNotification: string;
    export let didDeactivateApplicationNotification: string;
    export let didHideApplicationNotification: string;
    export let didLaunchApplicationNotification: string;
    export let didMountNotification: string;
    export let didRenameVolumeNotification: string;
    export let didTerminateApplicationNotification: string;
    export let didUnhideApplicationNotification: string;
    export let didUnmountNotification: string;
    export let didWakeNotification: string;
    export let appleEvent: string;
    export let architecture: string;
    export let arguments_: string;
    export let environment: string;
    export let screensDidSleepNotification: string;
    export let screensDidWakeNotification: string;
    export let sessionDidBecomeActiveNotification: string;
    export let sessionDidResignActiveNotification: string;
    export let localizedVolumeNameUserInfoKey: string;
    export let oldLocalizedVolumeNameUserInfoKey: string;
    export let oldVolumeURLUserInfoKey: string;
    export let volumeURLUserInfoKey: string;
    export let willLaunchApplicationNotification: string;
    export let willPowerOffNotification: string;
    export let willSleepNotification: string;
    export let willUnmountNotification: string;
  }

  namespace NSXPCConnection {
    export enum Options {
      Privileged = 4096
    }

  }

  namespace NetService {
    // struct
    export enum Options {
      noAutoRename,
      listenForConnections,
      center,
      name,
      object
    }

  }

  namespace NotificationQueue {
    export enum NotificationCoalescing {
      NoCoalescing = 0,
      CoalescingOnName = 1,
      CoalescingOnSender = 2
    }

    export enum PostingStyle {
      WhenIdle = 1,
      ASAP = 2,
      Now = 3
    }

  }

  namespace NumberFormatter {
    export enum Behavior {
      BehaviorDefault = 0,
      Behavior10_0 = 1000,
      Behavior10_4 = 1040
    }

    export enum PadPosition {
      BeforePrefix = 0,
      AfterPrefix = 1,
      BeforeSuffix = 2,
      AfterSuffix = 3
    }

    export enum RoundingMode {
      Ceiling = 0,
      Floor = 1,
      Down = 2,
      Up = 3,
      HalfEven = 4,
      HalfDown = 5,
      HalfUp = 6
    }

    export enum Style {
      NoStyle = 0,
      DecimalStyle = 1,
      CurrencyStyle = 2,
      PercentStyle = 3,
      ScientificStyle = 4,
      SpellOutStyle = 5,
      OrdinalStyle = 6,
      CurrencyISOCodeStyle = 8,
      CurrencyPluralStyle = 9,
      CurrencyAccountingStyle = 10
    }

  }

  namespace Operation {
    export enum QueuePriority {
      VeryLow = -8,
      Low = -4,
      Normal = 0,
      High = 4,
      VeryHigh = 8
    }

  }

  namespace OperationQueue {
    export let defaultMaxConcurrentOperationCount: number;
  }

  namespace PersonNameComponentsFormatter {
    export enum Options {
      Phonetic = 2
    }

    export enum Style {
      Default = 0,
      Short = 1,
      Medium = 2,
      Long = 3,
      Abbreviated = 4
    }

  }

  namespace Port {
    export let didBecomeInvalidNotification: string;
  }

  namespace Process {
    export enum TerminationReason {
      Exit = 1,
      UncaughtSignal = 2
    }

    export let didTerminateNotification: string;
  }

  namespace ProcessInfo {
    export enum ActivityOptions {
      IdleDisplaySleepDisabled = 1099511627776,
      IdleSystemSleepDisabled = 1048576,
      SuddenTerminationDisabled = 16384,
      AutomaticTerminationDisabled = 32768,
      UserInitiated = 16777215,
      UserInitiatedAllowingIdleSystemSleep = 15728639,
      Background = 255,
      LatencyCritical = 1095216660480
    }

    export enum ThermalState {
      Nominal = 0,
      Fair = 1,
      Serious = 2,
      Critical = 3
    }

    export let thermalStateDidChangeNotification: string;
  }

  namespace Progress {
    export let copying: string;
    export let decompressingAfterDownloading: string;
    export let downloading: string;
    export let receiving: string;
  }

  namespace ProgressKind {
    export let file: string;
  }

  namespace ProgressUserInfoKey {
    export let estimatedTimeRemainingKey: string;
    export let fileAnimationImageKey: string;
    export let fileAnimationImageOriginalRectKey: string;
    export let fileCompletedCountKey: string;
    export let fileIconKey: string;
    export let fileOperationKindKey: string;
    export let fileTotalCountKey: string;
    export let fileURLKey: string;
    export let throughputKey: string;
  }

  namespace PropertyListSerialization {
    export enum PropertyListFormat {
      OpenStepFormat = 1,
      XMLFormat_v1_0 = 100,
      BinaryFormat_v1_0 = 200
    }

    export enum MutabilityOptions {
      Immutable = 0,
      MutableContainers = 1,
      MutableContainersAndLeaves = 2
    }

    export type ReadOptions = PropertyListSerialization;
    export type WriteOptions = number;
  }

  namespace RelativeDateTimeFormatter {
    export enum DateTimeStyle {
      Numeric = 0,
      Named = 1
    }

    export enum UnitsStyle {
      Full = 0,
      SpellOut = 1,
      Short = 2,
      Abbreviated = 3
    }

  }

  namespace RunLoop {
    export let eventTracking: string;
    export let modalPanel: string;
    export let default_: string;
    export let common: string;
  }

  namespace Stream {
    export enum Event {
      None = 0,
      OpenCompleted = 1,
      HasBytesAvailable = 2,
      HasSpaceAvailable = 4,
      ErrorOccurred = 8,
      EndEncountered = 16
    }

    export enum Status {
      NotOpen = 0,
      Opening = 1,
      Open = 2,
      Reading = 3,
      Writing = 4,
      AtEnd = 5,
      Closed = 6,
      Error = 7
    }

    export let dataWrittenToMemoryStreamKey: string;
    export let fileCurrentOffsetKey: string;
    export let networkServiceType: string;
    export let socksProxyConfigurationKey: string;
    export let socketSecurityLevelKey: string;
  }

  namespace StreamNetworkServiceTypeValue {
    export let background: string;
    export let callSignaling: string;
    export let video: string;
    export let voIP: string;
    export let voice: string;
  }

  namespace StreamSOCKSProxyConfiguration {
    export let hostKey: string;
    export let passwordKey: string;
    export let portKey: string;
    export let userKey: string;
    export let versionKey: string;
  }

  namespace StreamSOCKSProxyVersion {
    export let version4: string;
    export let version5: string;
  }

  namespace StreamSocketSecurityLevel {
    export let negotiatedSSL: string;
    export let none: string;
    export let ssLv2: string;
    export let ssLv3: string;
    export let tlSv1: string;
  }

  namespace StringEncodingDetectionOptionsKey {
    export let allowLossyKey: string;
    export let disallowedEncodingsKey: string;
    export let fromWindowsKey: string;
    export let likelyLanguageKey: string;
    export let lossySubstitutionKey: string;
    export let suggestedEncodingsKey: string;
    export let useOnlySuggestedEncodingsKey: string;
  }

  namespace StringTransform {
    export let fullwidthToHalfwidth: string;
    export let hiraganaToKatakana: string;
    export let latinToArabic: string;
    export let latinToCyrillic: string;
    export let latinToGreek: string;
    export let latinToHangul: string;
    export let latinToHebrew: string;
    export let latinToHiragana: string;
    export let latinToKatakana: string;
    export let latinToThai: string;
    export let mandarinToLatin: string;
    export let stripCombiningMarks: string;
    export let stripDiacritics: string;
    export let toLatin: string;
    export let toUnicodeName: string;
    export let toXMLHex: string;
  }

  namespace SystemPressureState {
    // struct
    export enum Factors {
      systemTemperature,
      peakPower,
      depthModuleTemperature
    }

  }

  namespace URLCache {
    export enum StoragePolicy {
      Allowed = 0,
      AllowedInMemoryOnly = 1,
      NotAllowed = 2
    }

  }

  namespace URLCredential {
    export enum Persistence {
      None = 0,
      ForSession = 1,
      Permanent = 2,
      Synchronizable = 3
    }

  }

  namespace URLFileProtection {
    export let complete: string;
    export let completeUnlessOpen: string;
    export let completeUntilFirstUserAuthentication: string;
    export let none: string;
  }

  namespace URLFileResourceType {
    export let blockSpecial: string;
    export let characterSpecial: string;
    export let directory: string;
    export let namedPipe: string;
    export let regular: string;
    export let socket: string;
    export let symbolicLink: string;
    export let unknown: string;
  }

  namespace URLResourceKey {
    export let addedToDirectoryDateKey: string;
    export let applicationIsScriptableKey: string;
    export let attributeModificationDateKey: string;
    export let canonicalPathKey: string;
    export let contentAccessDateKey: string;
    export let contentModificationDateKey: string;
    export let creationDateKey: string;
    export let customIconKey: string;
    export let documentIdentifierKey: string;
    export let effectiveIconKey: string;
    export let fileAllocatedSizeKey: string;
    export let fileProtectionKey: string;
    export let fileResourceIdentifierKey: string;
    export let fileResourceTypeKey: string;
    export let fileSecurityKey: string;
    export let fileSizeKey: string;
    export let generationIdentifierKey: string;
    export let hasHiddenExtensionKey: string;
    export let isAliasFileKey: string;
    export let isApplicationKey: string;
    export let isDirectoryKey: string;
    export let isExcludedFromBackupKey: string;
    export let isExecutableKey: string;
    export let isHiddenKey: string;
    export let isMountTriggerKey: string;
    export let isPackageKey: string;
    export let isReadableKey: string;
    export let isRegularFileKey: string;
    export let isSymbolicLinkKey: string;
    export let isSystemImmutableKey: string;
    export let isUbiquitousItemKey: string;
    export let isUserImmutableKey: string;
    export let isVolumeKey: string;
    export let isWritableKey: string;
    export let keysOfUnsetValuesKey: string;
    export let labelColorKey: string;
    export let labelNumberKey: string;
    export let linkCountKey: string;
    export let localizedLabelKey: string;
    export let localizedNameKey: string;
    export let localizedTypeDescriptionKey: string;
    export let nameKey: string;
    export let parentDirectoryURLKey: string;
    export let pathKey: string;
    export let preferredIOBlockSizeKey: string;
    export let quarantinePropertiesKey: string;
    export let tagNamesKey: string;
    export let thumbnailDictionaryKey: string;
    export let thumbnailKey: string;
    export let totalFileAllocatedSizeKey: string;
    export let totalFileSizeKey: string;
    export let typeIdentifierKey: string;
    export let ubiquitousItemContainerDisplayNameKey: string;
    export let ubiquitousItemDownloadRequestedKey: string;
    export let ubiquitousItemDownloadingErrorKey: string;
    export let ubiquitousItemDownloadingStatusKey: string;
    export let ubiquitousItemHasUnresolvedConflictsKey: string;
    export let ubiquitousItemIsDownloadingKey: string;
    export let ubiquitousItemIsSharedKey: string;
    export let ubiquitousItemIsUploadedKey: string;
    export let ubiquitousItemIsUploadingKey: string;
    export let ubiquitousItemUploadingErrorKey: string;
    export let ubiquitousSharedItemCurrentUserPermissionsKey: string;
    export let ubiquitousSharedItemCurrentUserRoleKey: string;
    export let ubiquitousSharedItemMostRecentEditorNameComponentsKey: string;
    export let ubiquitousSharedItemOwnerNameComponentsKey: string;
    export let volumeAvailableCapacityForImportantUsageKey: string;
    export let volumeAvailableCapacityForOpportunisticUsageKey: string;
    export let volumeAvailableCapacityKey: string;
    export let volumeCreationDateKey: string;
    export let volumeIdentifierKey: string;
    export let volumeIsAutomountedKey: string;
    export let volumeIsBrowsableKey: string;
    export let volumeIsEjectableKey: string;
    export let volumeIsEncryptedKey: string;
    export let volumeIsInternalKey: string;
    export let volumeIsJournalingKey: string;
    export let volumeIsLocalKey: string;
    export let volumeIsReadOnlyKey: string;
    export let volumeIsRemovableKey: string;
    export let volumeIsRootFileSystemKey: string;
    export let volumeLocalizedFormatDescriptionKey: string;
    export let volumeLocalizedNameKey: string;
    export let volumeMaximumFileSizeKey: string;
    export let volumeNameKey: string;
    export let volumeResourceCountKey: string;
    export let volumeSupportsAccessPermissionsKey: string;
    export let volumeSupportsAdvisoryFileLockingKey: string;
    export let volumeSupportsCasePreservedNamesKey: string;
    export let volumeSupportsCaseSensitiveNamesKey: string;
    export let volumeSupportsCompressionKey: string;
    export let volumeSupportsExclusiveRenamingKey: string;
    export let volumeSupportsExtendedSecurityKey: string;
    export let volumeSupportsFileCloningKey: string;
    export let volumeSupportsHardLinksKey: string;
    export let volumeSupportsImmutableFilesKey: string;
    export let volumeSupportsJournalingKey: string;
    export let volumeSupportsPersistentIDsKey: string;
    export let volumeSupportsRenamingKey: string;
    export let volumeSupportsRootDirectoryDatesKey: string;
    export let volumeSupportsSparseFilesKey: string;
    export let volumeSupportsSwapRenamingKey: string;
    export let volumeSupportsSymbolicLinksKey: string;
    export let volumeSupportsVolumeSizesKey: string;
    export let volumeSupportsZeroRunsKey: string;
    export let volumeTotalCapacityKey: string;
    export let volumeURLForRemountingKey: string;
    export let volumeURLKey: string;
    export let volumeUUIDStringKey: string;
  }

  namespace URLSession {
    export enum AuthChallengeDisposition {
      UseCredential = 0,
      PerformDefaultHandling = 1,
      CancelAuthenticationChallenge = 2,
      RejectProtectionSpace = 3
    }

    export enum ResponseDisposition {
      Cancel = 0,
      Allow = 1,
      BecomeDownload = 2,
      BecomeStream = 3
    }

  }

  namespace URLSessionTask {
    export enum State {
      Running = 0,
      Suspended = 1,
      Canceling = 2,
      Completed = 3
    }

    export let defaultPriority: number;
    export let highPriority: number;
    export let lowPriority: number;
  }

  namespace URLSessionTaskMetrics {
    export enum ResourceFetchType {
      Unknown = 0,
      NetworkLoad = 1,
      ServerPush = 2,
      LocalCache = 3
    }

  }

  namespace URLSessionWebSocketTask {
    export enum CloseCode {
      Invalid = 0,
      NormalClosure = 1000,
      GoingAway = 1001,
      ProtocolError = 1002,
      UnsupportedData = 1003,
      NoStatusReceived = 1005,
      AbnormalClosure = 1006,
      InvalidFramePayloadData = 1007,
      PolicyViolation = 1008,
      MessageTooBig = 1009,
      MandatoryExtensionMissing = 1010,
      InternalServerError = 1011,
      TLSHandshakeFailure = 1015
    }

  }

  namespace URLThumbnailDictionaryItem {
    export let NSThumbnail1024x1024SizeKey: string;
  }

  namespace URLUbiquitousItemDownloadingStatus {
    export let current: string;
    export let downloaded: string;
    export let notDownloaded: string;
  }

  namespace URLUbiquitousSharedItemPermissions {
    export let readOnly: string;
    export let readWrite: string;
  }

  namespace URLUbiquitousSharedItemRole {
    export let owner: string;
    export let participant: string;
  }

  namespace UserDefaults {
    export let argumentDomain: string;
    export let globalDomain: string;
    export let registrationDomain: string;
    export let completedInitialCloudSyncNotification: string;
    export let didChangeCloudAccountsNotification: string;
    export let noCloudAccountNotification: string;
    export let didChangeNotification: string;
    export let sizeLimitExceededNotification: string;
  }

  namespace XMLDTDNode {
    export enum DTDKind {
      EntityGeneralKind = 1,
      EntityParsedKind = 2,
      EntityUnparsedKind = 3,
      EntityParameterKind = 4,
      EntityPredefined = 5,
      AttributeCDATAKind = 6,
      AttributeIDKind = 7,
      AttributeIDRefKind = 8,
      AttributeIDRefsKind = 9,
      AttributeEntityKind = 10,
      AttributeEntitiesKind = 11,
      AttributeNMTokenKind = 12,
      AttributeNMTokensKind = 13,
      AttributeEnumerationKind = 14,
      AttributeNotationKind = 15,
      ElementDeclarationUndefinedKind = 16,
      ElementDeclarationEmptyKind = 17,
      ElementDeclarationAnyKind = 18,
      ElementDeclarationMixedKind = 19,
      ElementDeclarationElementKind = 20
    }

  }

  namespace XMLDocument {
    export enum ContentKind {
      XMLKind = 0,
      XHTMLKind = 1,
      HTMLKind = 2,
      TextKind = 3
    }

  }

  namespace XMLNode {
    export enum Kind {
      InvalidKind = 0,
      DocumentKind = 1,
      ElementKind = 2,
      AttributeKind = 3,
      NamespaceKind = 4,
      ProcessingInstructionKind = 5,
      CommentKind = 6,
      TextKind = 7,
      DTDKind = 8,
      EntityDeclarationKind = 9,
      AttributeDeclarationKind = 10,
      ElementDeclarationKind = 11,
      NotationDeclarationKind = 12
    }

    export enum Options {
      NodeOptionsNone = 0,
      NodeIsCDATA = 1,
      NodeExpandEmptyElement = 2,
      NodeCompactEmptyElement = 4,
      NodeUseSingleQuotes = 8,
      NodeUseDoubleQuotes = 16,
      NodeNeverEscapeContents = 32,
      DocumentTidyHTML = 512,
      DocumentTidyXML = 1024,
      DocumentValidate = 8192,
      NodeLoadExternalEntitiesAlways = 16384,
      NodeLoadExternalEntitiesSameOriginOnly = 32768,
      NodeLoadExternalEntitiesNever = 524288,
      DocumentXInclude = 65536,
      NodePrettyPrint = 131072,
      DocumentIncludeContentTypeDeclaration = 262144,
      NodePreserveNamespaceOrder = 1048576,
      NodePreserveAttributeOrder = 2097152,
      NodePreserveEntities = 4194304,
      NodePreservePrefixes = 8388608,
      NodePreserveCDATA = 16777216,
      NodePreserveWhitespace = 33554432,
      NodePreserveDTD = 67108864,
      NodePreserveCharacterReferences = 134217728,
      NodePromoteSignificantWhitespace = 268435456,
      NodePreserveEmptyElements = 6,
      NodePreserveQuotes = 24,
      NodePreserveAll = 4293918750
    }

  }

  namespace XMLParser {
    export enum ErrorCode {
      InternalError = 1,
      OutOfMemoryError = 2,
      DocumentStartError = 3,
      EmptyDocumentError = 4,
      PrematureDocumentEndError = 5,
      InvalidHexCharacterRefError = 6,
      InvalidDecimalCharacterRefError = 7,
      InvalidCharacterRefError = 8,
      InvalidCharacterError = 9,
      CharacterRefAtEOFError = 10,
      CharacterRefInPrologError = 11,
      CharacterRefInEpilogError = 12,
      CharacterRefInDTDError = 13,
      EntityRefAtEOFError = 14,
      EntityRefInPrologError = 15,
      EntityRefInEpilogError = 16,
      EntityRefInDTDError = 17,
      ParsedEntityRefAtEOFError = 18,
      ParsedEntityRefInPrologError = 19,
      ParsedEntityRefInEpilogError = 20,
      ParsedEntityRefInInternalSubsetError = 21,
      EntityReferenceWithoutNameError = 22,
      EntityReferenceMissingSemiError = 23,
      ParsedEntityRefNoNameError = 24,
      ParsedEntityRefMissingSemiError = 25,
      UndeclaredEntityError = 26,
      UnparsedEntityError = 28,
      EntityIsExternalError = 29,
      EntityIsParameterError = 30,
      UnknownEncodingError = 31,
      EncodingNotSupportedError = 32,
      StringNotStartedError = 33,
      StringNotClosedError = 34,
      NamespaceDeclarationError = 35,
      EntityNotStartedError = 36,
      EntityNotFinishedError = 37,
      LessThanSymbolInAttributeError = 38,
      AttributeNotStartedError = 39,
      AttributeNotFinishedError = 40,
      AttributeHasNoValueError = 41,
      AttributeRedefinedError = 42,
      LiteralNotStartedError = 43,
      LiteralNotFinishedError = 44,
      CommentNotFinishedError = 45,
      ProcessingInstructionNotStartedError = 46,
      ProcessingInstructionNotFinishedError = 47,
      NotationNotStartedError = 48,
      NotationNotFinishedError = 49,
      AttributeListNotStartedError = 50,
      AttributeListNotFinishedError = 51,
      MixedContentDeclNotStartedError = 52,
      MixedContentDeclNotFinishedError = 53,
      ElementContentDeclNotStartedError = 54,
      ElementContentDeclNotFinishedError = 55,
      XMLDeclNotStartedError = 56,
      XMLDeclNotFinishedError = 57,
      ConditionalSectionNotStartedError = 58,
      ConditionalSectionNotFinishedError = 59,
      ExternalSubsetNotFinishedError = 60,
      DOCTYPEDeclNotFinishedError = 61,
      MisplacedCDATAEndStringError = 62,
      CDATANotFinishedError = 63,
      MisplacedXMLDeclarationError = 64,
      SpaceRequiredError = 65,
      SeparatorRequiredError = 66,
      NMTOKENRequiredError = 67,
      NAMERequiredError = 68,
      PCDATARequiredError = 69,
      URIRequiredError = 70,
      PublicIdentifierRequiredError = 71,
      LTRequiredError = 72,
      GTRequiredError = 73,
      LTSlashRequiredError = 74,
      EqualExpectedError = 75,
      TagNameMismatchError = 76,
      UnfinishedTagError = 77,
      StandaloneValueError = 78,
      InvalidEncodingNameError = 79,
      CommentContainsDoubleHyphenError = 80,
      InvalidEncodingError = 81,
      ExternalStandaloneEntityError = 82,
      InvalidConditionalSectionError = 83,
      EntityValueRequiredError = 84,
      NotWellBalancedError = 85,
      ExtraContentError = 86,
      InvalidCharacterInEntityError = 87,
      ParsedEntityRefInInternalError = 88,
      EntityRefLoopError = 89,
      EntityBoundaryError = 90,
      InvalidURIError = 91,
      URIFragmentError = 92,
      NoDTDError = 94,
      DelegateAbortedParseError = 512
    }

    export enum ExternalEntityResolvingPolicy {
      ResolveExternalEntitiesNever = 0,
      ResolveExternalEntitiesNoNetwork = 1,
      ResolveExternalEntitiesSameOriginOnly = 2,
      ResolveExternalEntitiesAlways = 3
    }

    export let errorDomain: string;
  }

  export enum AVAssetReferenceRestrictions {
    forbidRemoteReferenceToLocal,
    forbidLocalReferenceToRemote,
    forbidCrossSiteReference,
    forbidLocalReferenceToLocal,
    forbidAll,
    defaultPolicy,
  }

  export enum AVAudioPlayerNodeBufferOptions {
    byteSwapped,
    scalarCount,
    loops,
    interrupts,
    interruptsAtLoop,
  }

  export enum AVAudioSpatializationFormats {
    monoAndStereo,
    multichannel,
    monoStereoAndMultichannel,
  }

  export enum AVMovieWritingOptions {
    errorDomain,
    unknown,
    outOfMemory,
    sessionNotRunning,
    deviceAlreadyUsedByAnotherSession,
    noDataCaptured,
    sessionConfigurationChanged,
    diskFull,
    deviceWasDisconnected,
    mediaChanged,
    maximumDurationReached,
    maximumFileSizeReached,
    mediaDiscontinuity,
    maximumNumberOfSamplesForFileFormatReached,
    deviceNotConnected,
    deviceInUseByAnotherApplication,
    deviceLockedForConfigurationByAnotherProcess,
    exportFailed,
    decodeFailed,
    invalidSourceMedia,
    fileAlreadyExists,
    compositionTrackSegmentsNotContiguous,
    invalidCompositionTrackSegmentDuration,
    invalidCompositionTrackSegmentSourceStartTime,
    invalidCompositionTrackSegmentSourceDuration,
    fileFormatNotRecognized,
    fileFailedToParse,
    maximumStillImageCaptureRequestsExceeded,
    contentIsProtected,
    noImageAtTime,
    decoderNotFound,
    encoderNotFound,
    contentIsNotAuthorized,
    applicationIsNotAuthorized,
    operationNotSupportedForAsset,
    decoderTemporarilyUnavailable,
    encoderTemporarilyUnavailable,
    invalidVideoComposition,
    referenceForbiddenByReferencePolicy,
    invalidOutputURLPathExtension,
    screenCaptureFailed,
    displayWasDisabled,
    torchLevelUnavailable,
    incompatibleAsset,
    failedToLoadMediaData,
    serverIncorrectlyConfigured,
    applicationIsNotAuthorizedToUseDevice,
    failedToParse,
    fileTypeDoesNotSupportSampleReferences,
    undecodableMediaData,
    airPlayControllerRequiresInternet,
    airPlayReceiverRequiresInternet,
    videoCompositorFailed,
    createContentKeyRequestFailed,
    unsupportedOutputSettings,
    operationNotAllowed,
    contentIsUnavailable,
    formatUnsupported,
    malformedDepth,
    contentNotUpdated,
    noLongerPlayable,
    noCompatibleAlternatesForExternalDisplay,
    noSourceTrack,
    externalPlaybackNotSupportedForAsset,
    operationNotSupportedForPreset,
    incorrectlyConfigured,
    segmentStartedWithNonSyncSample,
    rosettaNotInstalled,
    addMovieHeaderToDestination,
    truncateDestinationToMovieHeaderOnly,
  }

  export enum AVMusicSequenceLoadOptions {
    smfChannelsToTracks,
    scalarCount,
  }

  export enum AlignmentOptions {
    alignMinXInward,
    alignMinYInward,
    alignMaxXInward,
    alignMaxYInward,
    alignWidthInward,
    alignHeightInward,
    alignMinXOutward,
    alignMinYOutward,
    alignMaxXOutward,
    alignMaxYOutward,
    alignWidthOutward,
    alignHeightOutward,
    alignMinXNearest,
    alignMinYNearest,
    alignMaxXNearest,
    alignMaxYNearest,
    alignWidthNearest,
    alignHeightNearest,
    alignRectFlipped,
    alignAllEdgesInward,
    alignAllEdgesOutward,
    alignAllEdgesNearest,
  }

  export enum AnyObject {
    byteSwapped,
    scalarCount,
    assureMemoryNow,
    alwaysCopyData,
    dontOptimizeDepth,
    permitEmptyReference,
  }

  export enum CAAutoresizingMask {
    layerMinXMargin,
    layerWidthSizable,
    layerMaxXMargin,
    layerMinYMargin,
    layerHeightSizable,
    layerMaxYMargin,
  }

  export enum CACornerMask {
    layerMinXMinYCorner,
    layerMaxXMinYCorner,
    layerMinXMaxYCorner,
    layerMaxXMaxYCorner,
  }

  export enum CAEdgeAntialiasingMask {
    layerLeftEdge,
    layerRightEdge,
    layerBottomEdge,
    layerTopEdge,
  }

  export enum CFCalendarUnit {
    magnitude,
    byteSwapped,
    scalarCount,
    era,
    year,
    month,
    day,
    hour,
    minute,
    second,
    week,
    weekday,
    weekdayOrdinal,
    quarter,
    weekOfMonth,
    weekOfYear,
    yearForWeekOfYear,
  }

  export enum CFDataSearchFlags {
    backwards,
    anchored,
  }

  export enum CFFileSecurityClearOptions {
    magnitude,
    byteSwapped,
    scalarCount,
    owner,
    group,
    mode,
    ownerUUID,
    groupUUID,
    accessControlList,
  }

  export enum CFGregorianUnitFlags {
    unitsYears,
    unitsMonths,
    unitsDays,
    unitsHours,
    unitsMinutes,
    unitsSeconds,
    allUnits,
  }

  export enum CFISO8601DateFormatOptions {
    byteSwapped,
    scalarCount,
    withYear,
    withMonth,
    withWeekOfYear,
    withDay,
    withTime,
    withTimeZone,
    withSpaceBetweenDateAndTime,
    withDashSeparatorInDate,
    withColonSeparatorInTime,
    withColonSeparatorInTimeZone,
    withFractionalSeconds,
    withFullDate,
    withFullTime,
    withInternetDateTime,
  }

  export enum CFNumberFormatterOptionFlags {
    magnitude,
    byteSwapped,
    scalarCount,
    parseIntegersOnly,
  }

  export enum CFPropertyListMutabilityOptions {
    byteSwapped,
    scalarCount,
    mutableContainers,
    mutableContainersAndLeaves,
  }

  export enum CFRunLoopActivity {
    entry,
    beforeTimers,
    beforeSources,
    beforeWaiting,
    afterWaiting,
    exit,
    allActivities,
  }

  export enum CFSocketCallBackType {
    readCallBack,
    acceptCallBack,
    dataCallBack,
    connectCallBack,
    writeCallBack,
  }

  export enum CFStreamEventType {
    magnitude,
    byteSwapped,
    scalarCount,
    openCompleted,
    hasBytesAvailable,
    canAcceptBytes,
    errorOccurred,
    endEncountered,
  }

  export enum CFStringCompareFlags {
    compareCaseInsensitive,
    compareBackwards,
    compareAnchored,
    compareNonliteral,
    compareLocalized,
    compareNumerically,
    compareDiacriticInsensitive,
    compareWidthInsensitive,
    compareForcedOrdering,
  }

  export enum CFStringTokenizerTokenType {
    byteSwapped,
    scalarCount,
    normal,
    hasSubTokensMask,
    hasDerivedSubTokensMask,
    hasHasNumbersMask,
    hasNonLettersMask,
    isCJWordMask,
  }

  export enum CFURLBookmarkCreationOptions {
    byteSwapped,
    scalarCount,
    minimalBookmarkMask,
    suitableForBookmarkFile,
    withSecurityScope,
    securityScopeAllowOnlyReadAccess,
  }

  export enum CFURLBookmarkResolutionOptions {
    byteSwapped,
    scalarCount,
    cfurlBookmarkResolutionWithoutUIMask,
    cfurlBookmarkResolutionWithoutMountingMask,
    cfurlBookmarkResolutionWithSecurityScope,
    cfBookmarkResolutionWithoutUIMask,
    cfBookmarkResolutionWithoutMountingMask,
  }

  export enum CFURLEnumeratorOptions {
    descendRecursively,
    skipInvisibles,
    generateFileReferenceURLs,
    skipPackageContents,
    includeDirectoriesPreOrder,
    includeDirectoriesPostOrder,
    generateRelativePathURLs,
  }

  export enum CFXMLParserOptions {
    validateDocument,
    skipMetaData,
    replacePhysicalEntities,
    skipWhitespace,
    resolveExternalEntities,
    addImpliedAttributes,
    allOptions,
  }

  export enum CFXMLParserStatusCode {
    statusParseNotBegun,
    statusParseInProgress,
    errorUnexpectedEOF,
    errorUnknownEncoding,
    errorEncodingConversionFailure,
    errorMalformedProcessingInstruction,
    errorMalformedDTD,
    errorMalformedName,
    errorMalformedCDSect,
    errorMalformedCloseTag,
    errorMalformedStartTag,
    errorMalformedDocument,
    errorElementlessDocument,
    errorMalformedComment,
    errorMalformedCharacterReference,
    errorMalformedParsedCharacterData,
    errorNoData,
  }

  export enum CGBitmapInfo {
    alphaInfoMask,
    floatInfoMask,
    floatComponents,
    byteOrderMask,
    byteOrder16Little,
    byteOrder32Little,
    byteOrder16Big,
    byteOrder32Big,
  }

  export enum CGCaptureOptions {
    byteSwapped,
    scalarCount,
    noFill,
  }

  export enum CGConfigureOption {
    byteSwapped,
    scalarCount,
    forAppOnly,
    forSession,
    permanently,
  }

  export enum CGDisplayChangeSummaryFlags {
    byteSwapped,
    scalarCount,
    beginConfigurationFlag,
    movedFlag,
    setMainFlag,
    setModeFlag,
    addFlag,
    removeFlag,
    enabledFlag,
    disabledFlag,
    mirrorFlag,
    unMirrorFlag,
    desktopShapeChangedFlag,
  }

  export enum CGEventFilterMask {
    byteSwapped,
    scalarCount,
    permitLocalMouseEvents,
    permitLocalKeyboardEvents,
    permitSystemDefinedEvents,
  }

  export enum CGEventFlags {
    maskAlphaShift,
    maskShift,
    maskControl,
    maskAlternate,
    maskCommand,
    maskHelp,
    maskSecondaryFn,
    maskNumericPad,
    maskNonCoalesced,
  }

  export enum CGGradientDrawingOptions {
    byteSwapped,
    scalarCount,
    drawsBeforeStartLocation,
    drawsAfterEndLocation,
  }

  export enum CGPDFAccessPermissions {
    byteSwapped,
    scalarCount,
    allowsLowQualityPrinting,
    allowsHighQualityPrinting,
    allowsDocumentChanges,
    allowsDocumentAssembly,
    allowsContentCopying,
    allowsContentAccessibility,
    allowsCommenting,
    allowsFormFieldEntry,
  }

  export enum CGScreenUpdateOperation {
    byteSwapped,
    scalarCount,
    refresh,
    move,
    reducedDirtyRectangleCount,
  }

  export enum CGWindowImageOption {
    byteSwapped,
    scalarCount,
    boundsIgnoreFraming,
    shouldBeOpaque,
    onlyShadows,
    bestResolution,
    nominalResolution,
  }

  export enum CGWindowListOption {
    magnitude,
    byteSwapped,
    scalarCount,
    optionAll,
    optionOnScreenOnly,
    optionOnScreenAboveWindow,
    optionOnScreenBelowWindow,
    optionIncludingWindow,
    excludeDesktopElements,
  }

  export enum CKContainer_Application_Permissions {
    userDiscoverability,
  }

  export enum CMSampleBuffer {
    audioBufferListAssure16ByteAlignment,
  }

  export enum CMTimeFlags {
    magnitude,
    byteSwapped,
    scalarCount,
    valid,
    hasBeenRounded,
    positiveInfinity,
    negativeInfinity,
    indefinite,
    impliedValueFlagsMask,
  }

  export enum Character {
    request,
    session,
    ascii,
    nextstep,
    japaneseEUC,
    utf8,
    isoLatin1,
    symbol,
    nonLossyASCII,
    shiftJIS,
    isoLatin2,
    unicode,
    windowsCP1251,
    windowsCP1252,
    windowsCP1253,
    windowsCP1254,
    windowsCP1250,
    iso2022JP,
    macOSRoman,
    utf16,
    utf16BigEndian,
    utf16LittleEndian,
    utf32,
    utf32BigEndian,
    utf32LittleEndian,
  }

  export enum Data {
    video,
    audio,
    muxed,
    text,
    closedCaption,
    subtitle,
    timeCode,
    metadata,
    linearPCM,
    ac3,
    iec60958AC3,
    appleIMA4,
    mpeg4AAC,
    mpeg4CELP,
    mpeg4HVXC,
    mpeg4TwinVQ,
    mace3,
    mace6,
    uLaw,
    aLaw,
    qDesign,
    qDesign2,
    qualcomm,
    mpegLayer1,
    mpegLayer2,
    mpegLayer3,
    midiStream,
    parameterValueStream,
    appleLossless,
    mpeg4AAC_HE,
    mpeg4AAC_LD,
    mpeg4AAC_ELD,
    mpeg4AAC_ELD_SBR,
    mpeg4AAC_ELD_V2,
    mpeg4AAC_HE_V2,
    mpeg4AAC_Spatial,
    mpegD_USAC,
    amr,
    amr_WB,
    audible,
    iLBC,
    dviIntelIMA,
    microsoftGSM,
    aes3,
    enhancedAC3,
    flac,
    opus,
    aacLCProtected,
    aacAudibleProtected,
    pixelFormat_32ARGB,
    pixelFormat_32BGRA,
    pixelFormat_24RGB,
    pixelFormat_16BE555,
    pixelFormat_16BE565,
    pixelFormat_16LE555,
    pixelFormat_16LE565,
    pixelFormat_16LE5551,
    pixelFormat_422YpCbCr8,
    pixelFormat_422YpCbCr8_yuvs,
    pixelFormat_444YpCbCr8,
    pixelFormat_4444YpCbCrA8,
    pixelFormat_422YpCbCr16,
    pixelFormat_422YpCbCr10,
    pixelFormat_444YpCbCr10,
    pixelFormat_8IndexedGray_WhiteIsZero,
    animation,
    cinepak,
    jpeg,
    jpeg_OpenDML,
    sorensonVideo,
    sorensonVideo3,
    h263,
    h264,
    hevc,
    hevcWithAlpha,
    mpeg4Video,
    mpeg2Video,
    mpeg1Video,
    dvcNTSC,
    dvcPAL,
    dvcProPAL,
    dvcPro50NTSC,
    dvcPro50PAL,
    dvcPROHD720p60,
    dvcPROHD720p50,
    dvcPROHD1080i60,
    dvcPROHD1080i50,
    dvcPROHD1080p30,
    dvcPROHD1080p25,
    proRes4444XQ,
    proRes4444,
    proRes422HQ,
    proRes422,
    proRes422LT,
    proRes422Proxy,
    proResRAW,
    proResRAWHQ,
    mpeg1System,
    mpeg2Transport,
    mpeg2Program,
    dv,
    cea608,
    cea708,
    atsc,
    qt,
    mobile3GPP,
    webVTT,
    timeCode32,
    timeCode64,
    counter32,
    counter64,
    icy,
    id3,
    boxed,
    emsg,
    streamBasicDescription,
    magicCookie,
    channelLayout,
    extensions,
    all,
    startIndex,
    endIndex,
  }

  export enum Int {
    byteSwapped,
    scalarCount,
  }

  export enum NSBinarySearchingOptions {
    firstEqual,
    lastEqual,
    insertionIndex,
  }

  export enum NSDirectionalRectEdge {
    top,
    leading,
    bottom,
    trailing,
    all,
  }

  export enum NSDragOperation {
    copy,
    link,
    generic,
    private,
    move,
    delete,
    every,
    all_Obsolete,
    all,
  }

  export enum NSDraggingItemEnumerationOptions {
    concurrent,
    clearNonenumeratedImages,
  }

  export enum NSEnumerationOptions {
    concurrent,
    reverse,
  }

  export enum NSFetchRequestResultType {
    managedObjectResultType,
    managedObjectIDResultType,
    dictionaryResultType,
    countResultType,
  }

  export enum NSFontCollectionOptions {
    applicationOnlyMask,
  }

  export enum NSFontTraitMask {
    byteSwapped,
    scalarCount,
    italicFontMask,
    boldFontMask,
    unboldFontMask,
    nonStandardCharacterSetFontMask,
    narrowFontMask,
    expandedFontMask,
    condensedFontMask,
    smallCapsFontMask,
    posterFontMask,
    compressedFontMask,
    fixedPitchFontMask,
    unitalicFontMask,
  }

  export enum NSItemProviderFileOptions {
    openInPlace,
  }

  export enum NSKeyValueObservingOptions {
    new,
    old,
    initial,
    prior,
  }

  export enum NSOrderedCollectionDifferenceCalculationOptions {
    magnitude,
    timeInterval,
    hashValue,
    omitInsertedObjects,
    omitRemovedObjects,
    inferMoves,
  }

  export enum NSPersistentCloudKitContainerSchemaInitializationOptions {
    dryRun,
    printSchema,
  }

  export enum NSSnapshotEventType {
    undoInsertion,
    undoDeletion,
    undoUpdate,
    rollback,
    refresh,
    mergePolicy,
  }

  export enum NSSortOptions {
    magnitude,
    byteSwapped,
    scalarCount,
    concurrent,
    stable,
  }

  export enum NSSpringLoadingOptions {
    disabled,
    enabled,
    continuousActivation,
    noHover,
  }

  export enum NSTextStorageEditActions {
    editedAttributes,
    editedCharacters,
  }

  export enum NSTypesetterControlCharacterAction {
    magnitude,
    byteSwapped,
    scalarCount,
    zeroAdvancementAction,
    whitespaceAction,
    horizontalTabAction,
    lineBreakAction,
    paragraphBreakAction,
    containerBreakAction,
  }

  export enum NSUnderlineStyle {
    single,
    thick,
    double,
    patternDot,
    patternDash,
    patternDashDot,
    patternDashDotDot,
    byWord,
  }

  export enum UInt {
    magnitude,
    byteSwapped,
    scalarCount,
    hashValue,
    boolValue,
    ptr,
    bitWidth,
    leadingZeroBitCount,
    trailingZeroBitCount,
    nonzeroBitCount,
    count,
    startIndex,
    endIndex,
    indices,
    words,
  }

  export enum UInt8 {
    regions,
    startIndex,
    endIndex,
    indices,
    hashValue,
    autoupdatingCurrent,
    current,
  }

  export enum AVAssetReferenceRestrictions {
    ForbidNone = 0,
    ForbidRemoteReferenceToLocal = 1,
    ForbidLocalReferenceToRemote = 2,
    ForbidCrossSiteReference = 4,
    ForbidLocalReferenceToLocal = 8,
    ForbidAll = 65535,
    DefaultPolicy = 2
  }

  export enum AVAudio3DMixingPointSourceInHeadMode {
    Mono = 0,
    Bypass = 1
  }

  export enum AVAudio3DMixingRenderingAlgorithm {
    EqualPowerPanning = 0,
    SphericalHead = 1,
    HRTF = 2,
    SoundField = 3,
    StereoPassThrough = 5,
    HRTFHQ = 6,
    Auto = 7
  }

  export enum AVAudio3DMixingSourceMode {
    SpatializeIfMono = 0,
    Bypass = 1,
    PointSource = 2,
    AmbienceBed = 3
  }

  export enum AVAudioCommonFormat {
    OtherFormat = 0,
    PCMFormatFloat32 = 1,
    PCMFormatFloat64 = 2,
    PCMFormatInt16 = 3,
    PCMFormatInt32 = 4
  }

  export enum AVAudioConverterInputStatus {
    HaveData = 0,
    NoDataNow = 1,
    EndOfStream = 2
  }

  export enum AVAudioConverterOutputStatus {
    HaveData = 0,
    InputRanDry = 1,
    EndOfStream = 2,
    Error = 3
  }

  export enum AVAudioConverterPrimeMethod {
    Pre = 0,
    Normal = 1,
    None = 2
  }

  export enum AVAudioEngineManualRenderingError {
    InvalidMode = -80800,
    Initialized = -80801,
    NotRunning = -80802
  }

  export enum AVAudioEngineManualRenderingMode {
    Offline = 0,
    Realtime = 1
  }

  export enum AVAudioEngineManualRenderingStatus {
    Error = -1,
    Success = 0,
    InsufficientDataFromInputNode = 1,
    CannotDoInCurrentContext = 2
  }

  export enum AVAudioEnvironmentDistanceAttenuationModel {
    Exponential = 1,
    Inverse = 2,
    Linear = 3
  }

  export enum AVAudioEnvironmentOutputType {
    Auto = 0,
    Headphones = 1,
    BuiltInSpeakers = 2,
    ExternalSpeakers = 3
  }

  export enum AVAudioPlayerNodeBufferOptions {
    Loops = 1,
    Interrupts = 2,
    InterruptsAtLoop = 4
  }

  export enum AVAudioPlayerNodeCompletionCallbackType {
    DataConsumed = 0,
    DataRendered = 1,
    DataPlayedBack = 2
  }

  export enum AVAudioQuality {
    Min = 0,
    Low = 32,
    Medium = 64,
    High = 96,
    Max = 127
  }

  export enum AVAudioSessionActivationOptions {
    None = 0
  }

  export enum AVAudioUnitDistortionPreset {
    DrumsBitBrush = 0,
    DrumsBufferBeats = 1,
    DrumsLoFi = 2,
    MultiBrokenSpeaker = 3,
    MultiCellphoneConcert = 4,
    MultiDecimated1 = 5,
    MultiDecimated2 = 6,
    MultiDecimated3 = 7,
    MultiDecimated4 = 8,
    MultiDistortedFunk = 9,
    MultiDistortedCubed = 10,
    MultiDistortedSquared = 11,
    MultiEcho1 = 12,
    MultiEcho2 = 13,
    MultiEchoTight1 = 14,
    MultiEchoTight2 = 15,
    MultiEverythingIsBroken = 16,
    SpeechAlienChatter = 17,
    SpeechCosmicInterference = 18,
    SpeechGoldenPi = 19,
    SpeechRadioTower = 20,
    SpeechWaves = 21
  }

  export enum AVAudioUnitEQFilterType {
    Parametric = 0,
    LowPass = 1,
    HighPass = 2,
    ResonantLowPass = 3,
    ResonantHighPass = 4,
    BandPass = 5,
    BandStop = 6,
    LowShelf = 7,
    HighShelf = 8,
    ResonantLowShelf = 9,
    ResonantHighShelf = 10
  }

  export enum AVAudioUnitReverbPreset {
    SmallRoom = 0,
    MediumRoom = 1,
    LargeRoom = 2,
    MediumHall = 3,
    LargeHall = 4,
    Plate = 5,
    MediumChamber = 6,
    LargeChamber = 7,
    Cathedral = 8,
    LargeRoom2 = 9,
    MediumHall2 = 10,
    MediumHall3 = 11,
    LargeHall2 = 12
  }

  export enum AVAuthorizationStatus {
    NotDetermined = 0,
    Restricted = 1,
    Denied = 2,
    Authorized = 3
  }

  export enum AVCaptureColorSpace {
    sRGB = 0,
    P3_D65 = 1
  }

  export enum AVCaptureVideoOrientation {
    Portrait = 1,
    PortraitUpsideDown = 2,
    LandscapeRight = 3,
    LandscapeLeft = 4
  }

  export enum AVContentAuthorizationStatus {
    Unknown = 0,
    Completed = 1,
    Cancelled = 2,
    TimedOut = 3,
    Busy = 4,
    NotAvailable = 5,
    NotPossible = 6
  }

  export enum AVError {
    Unknown = -11800,
    OutOfMemory = -11801,
    SessionNotRunning = -11803,
    DeviceAlreadyUsedByAnotherSession = -11804,
    NoDataCaptured = -11805,
    SessionConfigurationChanged = -11806,
    DiskFull = -11807,
    DeviceWasDisconnected = -11808,
    MediaChanged = -11809,
    MaximumDurationReached = -11810,
    MaximumFileSizeReached = -11811,
    MediaDiscontinuity = -11812,
    MaximumNumberOfSamplesForFileFormatReached = -11813,
    DeviceNotConnected = -11814,
    DeviceInUseByAnotherApplication = -11815,
    DeviceLockedForConfigurationByAnotherProcess = -11817,
    ExportFailed = -11820,
    DecodeFailed = -11821,
    InvalidSourceMedia = -11822,
    FileAlreadyExists = -11823,
    CompositionTrackSegmentsNotContiguous = -11824,
    InvalidCompositionTrackSegmentDuration = -11825,
    InvalidCompositionTrackSegmentSourceStartTime = -11826,
    InvalidCompositionTrackSegmentSourceDuration = -11827,
    FileFormatNotRecognized = -11828,
    FileFailedToParse = -11829,
    MaximumStillImageCaptureRequestsExceeded = -11830,
    ContentIsProtected = -11831,
    NoImageAtTime = -11832,
    DecoderNotFound = -11833,
    EncoderNotFound = -11834,
    ContentIsNotAuthorized = -11835,
    ApplicationIsNotAuthorized = -11836,
    OperationNotSupportedForAsset = -11838,
    DecoderTemporarilyUnavailable = -11839,
    EncoderTemporarilyUnavailable = -11840,
    InvalidVideoComposition = -11841,
    ReferenceForbiddenByReferencePolicy = -11842,
    InvalidOutputURLPathExtension = -11843,
    ScreenCaptureFailed = -11844,
    DisplayWasDisabled = -11845,
    TorchLevelUnavailable = -11846,
    IncompatibleAsset = -11848,
    FailedToLoadMediaData = -11849,
    ServerIncorrectlyConfigured = -11850,
    ApplicationIsNotAuthorizedToUseDevice = -11852,
    FailedToParse = -11853,
    FileTypeDoesNotSupportSampleReferences = -11854,
    UndecodableMediaData = -11855,
    AirPlayControllerRequiresInternet = -11856,
    AirPlayReceiverRequiresInternet = -11857,
    VideoCompositorFailed = -11858,
    CreateContentKeyRequestFailed = -11860,
    UnsupportedOutputSettings = -11861,
    OperationNotAllowed = -11862,
    ContentIsUnavailable = -11863,
    FormatUnsupported = -11864,
    MalformedDepth = -11865,
    ContentNotUpdated = -11866,
    NoLongerPlayable = -11867,
    NoCompatibleAlternatesForExternalDisplay = -11868,
    NoSourceTrack = -11869,
    ExternalPlaybackNotSupportedForAsset = -11870,
    OperationNotSupportedForPreset = -11871,
    SessionHardwareCostOverage = -11872,
    UnsupportedDeviceActiveFormat = -11873
  }

  export enum AVKeyValueStatus {
    Unknown = 0,
    Loading = 1,
    Loaded = 2,
    Failed = 3,
    Cancelled = 4
  }

  export enum AVMovieWritingOptions {
    AddMovieHeaderToDestination = 0,
    TruncateDestinationToMovieHeaderOnly = 1
  }

  export enum AVMusicSequenceLoadOptions {
    SMF_PreserveTracks = 0,
    SMF_ChannelsToTracks = 1
  }

  export enum AVMusicTrackLoopCount {
    Forever = -1
  }

  export enum AVQueuedSampleBufferRenderingStatus {
    Unknown = 0,
    Rendering = 1,
    Failed = 2
  }

  export enum AVSpeechBoundary {
    Immediate = 0,
    Word = 1
  }

  export enum AVSpeechSynthesisVoiceGender {
    Unspecified = 0,
    Male = 1,
    Female = 2
  }

  export enum AVSpeechSynthesisVoiceQuality {
    Default = 1,
    Enhanced = 2
  }

  export enum AVVideoFieldMode {
    Both = 0,
    TopOnly = 1,
    BottomOnly = 2,
    Deinterlace = 3
  }

  export enum AVCaptureViewControlsStyle {
    Inline = 0,
    Floating = 1,
    InlineDeviceSelection = 2,
    Default = 0
  }

  export enum AVPlayerViewControlsStyle {
    None = 0,
    Inline = 1,
    Floating = 2,
    Minimal = 3,
    Default = 1
  }

  export enum AVPlayerViewTrimResult {
    OKButton = 0,
    CancelButton = 1
  }

  export enum AVRoutePickerViewButtonState {
    Normal = 0,
    NormalHighlighted = 1,
    Active = 2,
    ActiveHighlighted = 3
  }

  export enum NSAccessibilityPriorityLevel {
    Low = 10,
    Medium = 50,
    High = 90
  }

  export enum NSAnimationEffect {
    DisappearingItemDefault = 0,
    Poof = 10
  }

  export enum NSBorderType {
    NoBorder = 0,
    LineBorder = 1,
    BezelBorder = 2,
    GrooveBorder = 3
  }

  export enum NSCharacterCollection {
    IdentityMappingCharacterCollection = 0,
    AdobeCNS1CharacterCollection = 1,
    AdobeGB1CharacterCollection = 2,
    AdobeJapan1CharacterCollection = 3,
    AdobeJapan2CharacterCollection = 4,
    AdobeKorea1CharacterCollection = 5
  }

  export enum NSCollectionElementCategory {
    Item = 0,
    SupplementaryView = 1,
    DecorationView = 2,
    InterItemGap = 3
  }

  export enum NSCollectionLayoutSectionOrthogonalScrollingBehavior {
    None = 0,
    Continuous = 1,
    ContinuousGroupLeadingBoundary = 2,
    Paging = 3,
    GroupPaging = 4,
    GroupPagingCentered = 5
  }

  export enum NSColorRenderingIntent {
    Default = 0,
    AbsoluteColorimetric = 1,
    RelativeColorimetric = 2,
    Perceptual = 3,
    Saturation = 4
  }

  export enum NSCompositingOperation {
    Clear = 0,
    Copy = 1,
    SourceOver = 2,
    SourceIn = 3,
    SourceOut = 4,
    SourceAtop = 5,
    DestinationOver = 6,
    DestinationIn = 7,
    DestinationOut = 8,
    DestinationAtop = 9,
    XOR = 10,
    PlusDarker = 11,
    Highlight = 12,
    PlusLighter = 13,
    Multiply = 14,
    Screen = 15,
    Overlay = 16,
    Darken = 17,
    Lighten = 18,
    ColorDodge = 19,
    ColorBurn = 20,
    SoftLight = 21,
    HardLight = 22,
    Difference = 23,
    Exclusion = 24,
    Hue = 25,
    Saturation = 26,
    Color = 27,
    Luminosity = 28
  }

  export enum NSControlTint {
    DefaultControlTint = 0,
    BlueControlTint = 1,
    GraphiteControlTint = 6,
    ClearControlTint = 7
  }

  export enum NSDirectionalRectEdge {
    None = 0,
    Top = 1,
    Leading = 2,
    Bottom = 4,
    Trailing = 8,
    All = 15
  }

  export enum NSDisplayGamut {
    SRGB = 1,
    P3 = 2
  }

  export enum NSDragOperation {
    None = 0,
    Copy = 1,
    Link = 2,
    Generic = 4,
    Private = 8,
    Move = 16,
    Delete = 32,
    Every = -1,
    All_Obsolete = 15,
    All = 15
  }

  export enum NSDraggingContext {
    OutsideApplication = 0,
    WithinApplication = 1
  }

  export enum NSDraggingFormation {
    Default = 0,
    None = 1,
    Pile = 2,
    List = 3,
    Stack = 4
  }

  export enum NSDraggingItemEnumerationOptions {
    Concurrent = 1,
    ClearNonenumeratedImages = 65536
  }

  export enum NSFindPanelAction {
    ShowFindPanel = 1,
    Next = 2,
    Previous = 3,
    ReplaceAll = 4,
    Replace = 5,
    ReplaceAndFind = 6,
    SetFindString = 7,
    ReplaceAllInSelection = 8,
    SelectAll = 9,
    SelectAllInSelection = 10
  }

  export enum NSFindPanelSubstringMatchType {
    Contains = 0,
    StartsWith = 1,
    FullWord = 2,
    EndsWith = 3
  }

  export enum NSFocusRingPlacement {
    Only = 0,
    Below = 1,
    Above = 2
  }

  export enum NSFocusRingType {
    Default = 0,
    None = 1,
    Exterior = 2
  }

  export enum NSFontAction {
    NoFontChangeAction = 0,
    ViaPanelFontAction = 1,
    AddTraitFontAction = 2,
    SizeUpFontAction = 3,
    SizeDownFontAction = 4,
    HeavierFontAction = 5,
    LighterFontAction = 6,
    RemoveTraitFontAction = 7
  }

  export enum NSFontCollectionOptions {
    ApplicationOnlyMask = 1
  }

  export enum NSFontRenderingMode {
    DefaultRenderingMode = 0,
    AntialiasedRenderingMode = 1,
    IntegerAdvancementsRenderingMode = 2,
    AntialiasedIntegerAdvancementsRenderingMode = 3
  }

  export enum NSFontTraitMask {
    ItalicFontMask = 1,
    BoldFontMask = 2,
    UnboldFontMask = 4,
    NonStandardCharacterSetFontMask = 8,
    NarrowFontMask = 16,
    ExpandedFontMask = 32,
    CondensedFontMask = 64,
    SmallCapsFontMask = 128,
    PosterFontMask = 256,
    CompressedFontMask = 512,
    FixedPitchFontMask = 1024,
    UnitalicFontMask = 16777216
  }

  export enum NSImageAlignment {
    Center = 0,
    Top = 1,
    TopLeft = 2,
    TopRight = 3,
    Left = 4,
    Bottom = 5,
    BottomLeft = 6,
    BottomRight = 7,
    Right = 8
  }

  export enum NSImageInterpolation {
    Default = 0,
    None = 1,
    Low = 2,
    Medium = 4,
    High = 3
  }

  export enum NSImageScaling {
    ImageScaleProportionallyDown = 0,
    ImageScaleAxesIndependently = 1,
    ImageScaleNone = 2,
    ImageScaleProportionallyUpOrDown = 3,
    ScaleProportionally = 0,
    ScaleToFit = 1,
    ScaleNone = 2
  }

  export enum NSLineBreakMode {
    ByWordWrapping = 0,
    ByCharWrapping = 1,
    ByClipping = 2,
    ByTruncatingHead = 3,
    ByTruncatingTail = 4,
    ByTruncatingMiddle = 5
  }

  export enum NSLineMovementDirection {
    DoesntMove = 0,
    MovesLeft = 1,
    MovesRight = 2,
    MovesDown = 3,
    MovesUp = 4
  }

  export enum NSLineSweepDirection {
    Left = 0,
    Right = 1,
    Down = 2,
    Up = 3
  }

  export enum NSRectAlignment {
    None = 0,
    Top = 1,
    TopLeading = 2,
    Leading = 3,
    BottomLeading = 4,
    Bottom = 5,
    BottomTrailing = 6,
    Trailing = 7,
    TopTrailing = 8
  }

  export enum NSSelectionAffinity {
    Upstream = 0,
    Downstream = 1
  }

  export enum NSSelectionGranularity {
    ByCharacter = 0,
    ByWord = 1,
    ByParagraph = 2
  }

  export enum NSSpringLoadingHighlight {
    None = 0,
    Standard = 1,
    Emphasized = 2
  }

  export enum NSSpringLoadingOptions {
    Disabled = 0,
    Enabled = 1,
    ContinuousActivation = 2,
    NoHover = 8
  }

  export enum NSTextAlignment {
    Left = 0,
    Right = 1,
    Center = 2,
    Justified = 3,
    Natural = 4
  }

  export enum NSTextInputTraitType {
    Default = 0,
    No = 1,
    Yes = 2
  }

  export enum NSTextMovement {
    Return = 16,
    Tab = 17,
    Backtab = 18,
    Left = 19,
    Right = 20,
    Up = 21,
    Down = 22,
    Cancel = 23,
    Other = 0
  }

  export enum NSTextScalingType {
    Standard = 0,
    iOS = 1
  }

  export enum NSTextStorageEditActions {
    EditedAttributes = 1,
    EditedCharacters = 2
  }

  export enum NSTypesetterControlCharacterAction {
    ZeroAdvancementAction = 1,
    WhitespaceAction = 2,
    HorizontalTabAction = 4,
    LineBreakAction = 8,
    ParagraphBreakAction = 16,
    ContainerBreakAction = 32
  }

  export enum NSUnderlineStyle {
    None = 0,
    Single = 1,
    Thick = 2,
    Double = 9,
    PatternSolid = 0,
    PatternDot = 256,
    PatternDash = 512,
    PatternDashDot = 768,
    PatternDashDotDot = 1024,
    ByWord = 32768
  }

  export enum NSUserInterfaceLayoutDirection {
    LeftToRight = 0,
    RightToLeft = 1
  }

  export enum NSUserInterfaceLayoutOrientation {
    Horizontal = 0,
    Vertical = 1
  }

  export enum NSWritingDirection {
    Natural = -1,
    LeftToRight = 0,
    RightToLeft = 1
  }

  export enum NSWritingDirectionFormatType {
    Embedding = 0,
    Override = 2
  }

  export enum NSAttributeType {
    UndefinedAttributeType = 0,
    Integer16AttributeType = 100,
    Integer32AttributeType = 200,
    Integer64AttributeType = 300,
    DecimalAttributeType = 400,
    DoubleAttributeType = 500,
    FloatAttributeType = 600,
    StringAttributeType = 700,
    BooleanAttributeType = 800,
    DateAttributeType = 900,
    BinaryDataAttributeType = 1000,
    UUIDAttributeType = 1100,
    URIAttributeType = 1200,
    TransformableAttributeType = 1800,
    ObjectIDAttributeType = 2000
  }

  export enum NSBatchDeleteRequestResultType {
    ResultTypeStatusOnly = 0,
    ResultTypeObjectIDs = 1,
    ResultTypeCount = 2
  }

  export enum NSBatchInsertRequestResultType {
    StatusOnly = 0,
    ObjectIDs = 1,
    Count = 2
  }

  export enum NSBatchUpdateRequestResultType {
    StatusOnlyResultType = 0,
    UpdatedObjectIDsResultType = 1,
    UpdatedObjectsCountResultType = 2
  }

  export enum NSDeleteRule {
    NoActionDeleteRule = 0,
    NullifyDeleteRule = 1,
    CascadeDeleteRule = 2,
    DenyDeleteRule = 3
  }

  export enum NSEntityMappingType {
    UndefinedEntityMappingType = 0,
    CustomEntityMappingType = 1,
    AddEntityMappingType = 2,
    RemoveEntityMappingType = 3,
    CopyEntityMappingType = 4,
    TransformEntityMappingType = 5
  }

  export enum NSFetchIndexElementType {
    Binary = 0,
    RTree = 1
  }

  export enum NSFetchRequestResultType {
    ManagedObjectResultType = 0,
    ManagedObjectIDResultType = 1,
    DictionaryResultType = 2,
    CountResultType = 4
  }

  export enum NSFetchedResultsChangeType {
    Insert = 1,
    Delete = 2,
    Move = 3,
    Update = 4
  }

  export enum NSManagedObjectContextConcurrencyType {
    ConfinementConcurrencyType = 0,
    PrivateQueueConcurrencyType = 1,
    MainQueueConcurrencyType = 2
  }

  export enum NSMergePolicyType {
    ErrorMergePolicyType = 0,
    MergeByPropertyStoreTrumpMergePolicyType = 1,
    MergeByPropertyObjectTrumpMergePolicyType = 2,
    OverwriteMergePolicyType = 3,
    RollbackMergePolicyType = 4
  }

  export enum NSPersistentCloudKitContainerSchemaInitializationOptions {
    None = 0,
    DryRun = 2,
    PrintSchema = 4
  }

  export enum NSPersistentHistoryChangeType {
    Insert = 0,
    Update = 1,
    Delete = 2
  }

  export enum NSPersistentHistoryResultType {
    StatusOnly = 0,
    ObjectIDs = 1,
    Count = 2,
    TransactionsOnly = 3,
    ChangesOnly = 4,
    TransactionsAndChanges = 5
  }

  export enum NSPersistentStoreRequestType {
    FetchRequestType = 1,
    SaveRequestType = 2,
    BatchInsertRequestType = 5,
    BatchUpdateRequestType = 6,
    BatchDeleteRequestType = 7
  }

  export enum NSSnapshotEventType {
    UndoInsertion = 2,
    UndoDeletion = 4,
    UndoUpdate = 8,
    Rollback = 16,
    Refresh = 32,
    MergePolicy = 64
  }

  export enum CFCalendarUnit {
    kCFCalendarUnitEra = 2,
    kCFCalendarUnitYear = 4,
    kCFCalendarUnitMonth = 8,
    kCFCalendarUnitDay = 16,
    kCFCalendarUnitHour = 32,
    kCFCalendarUnitMinute = 64,
    kCFCalendarUnitSecond = 128,
    kCFCalendarUnitWeek = 256,
    kCFCalendarUnitWeekday = 512,
    kCFCalendarUnitWeekdayOrdinal = 1024,
    kCFCalendarUnitQuarter = 2048,
    kCFCalendarUnitWeekOfMonth = 4096,
    kCFCalendarUnitWeekOfYear = 8192,
    kCFCalendarUnitYearForWeekOfYear = 16384
  }

  export enum CFCharacterSetPredefinedSet {
    kCFCharacterSetControl = 1,
    kCFCharacterSetWhitespace = 2,
    kCFCharacterSetWhitespaceAndNewline = 3,
    kCFCharacterSetDecimalDigit = 4,
    kCFCharacterSetLetter = 5,
    kCFCharacterSetLowercaseLetter = 6,
    kCFCharacterSetUppercaseLetter = 7,
    kCFCharacterSetNonBase = 8,
    kCFCharacterSetDecomposable = 9,
    kCFCharacterSetAlphaNumeric = 10,
    kCFCharacterSetPunctuation = 11,
    kCFCharacterSetCapitalizedLetter = 13,
    kCFCharacterSetSymbol = 14,
    kCFCharacterSetNewline = 15,
    kCFCharacterSetIllegal = 12
  }

  export enum CFComparisonResult {
    kCFCompareLessThan = -1,
    kCFCompareEqualTo = 0,
    kCFCompareGreaterThan = 1
  }

  export enum CFDataSearchFlags {
    kCFDataSearchBackwards = 1,
    kCFDataSearchAnchored = 2
  }

  export enum CFDateFormatterStyle {
    kCFDateFormatterNoStyle = 0,
    kCFDateFormatterShortStyle = 1,
    kCFDateFormatterMediumStyle = 2,
    kCFDateFormatterLongStyle = 3,
    kCFDateFormatterFullStyle = 4
  }

  export enum CFFileSecurityClearOptions {
    kCFFileSecurityClearOwner = 1,
    kCFFileSecurityClearGroup = 2,
    kCFFileSecurityClearMode = 4,
    kCFFileSecurityClearOwnerUUID = 8,
    kCFFileSecurityClearGroupUUID = 16,
    kCFFileSecurityClearAccessControlList = 32
  }

  export enum CFGregorianUnitFlags {
    kCFGregorianUnitsYears = 1,
    kCFGregorianUnitsMonths = 2,
    kCFGregorianUnitsDays = 4,
    kCFGregorianUnitsHours = 8,
    kCFGregorianUnitsMinutes = 16,
    kCFGregorianUnitsSeconds = 32,
    kCFGregorianAllUnits = 16777215
  }

  export enum CFISO8601DateFormatOptions {
    kCFISO8601DateFormatWithYear = 1,
    kCFISO8601DateFormatWithMonth = 2,
    kCFISO8601DateFormatWithWeekOfYear = 4,
    kCFISO8601DateFormatWithDay = 16,
    kCFISO8601DateFormatWithTime = 32,
    kCFISO8601DateFormatWithTimeZone = 64,
    kCFISO8601DateFormatWithSpaceBetweenDateAndTime = 128,
    kCFISO8601DateFormatWithDashSeparatorInDate = 256,
    kCFISO8601DateFormatWithColonSeparatorInTime = 512,
    kCFISO8601DateFormatWithColonSeparatorInTimeZone = 1024,
    kCFISO8601DateFormatWithFractionalSeconds = 2048,
    kCFISO8601DateFormatWithFullDate = 275,
    kCFISO8601DateFormatWithFullTime = 1632,
    kCFISO8601DateFormatWithInternetDateTime = 1907
  }

  export enum CFLocaleLanguageDirection {
    kCFLocaleLanguageDirectionUnknown = 0,
    kCFLocaleLanguageDirectionLeftToRight = 1,
    kCFLocaleLanguageDirectionRightToLeft = 2,
    kCFLocaleLanguageDirectionTopToBottom = 3,
    kCFLocaleLanguageDirectionBottomToTop = 4
  }

  export enum CFNotificationSuspensionBehavior {
    Drop = 1,
    Coalesce = 2,
    Hold = 3,
    DeliverImmediately = 4
  }

  export enum CFNumberFormatterOptionFlags {
    kCFNumberFormatterParseIntegersOnly = 1
  }

  export enum CFNumberFormatterPadPosition {
    kCFNumberFormatterPadBeforePrefix = 0,
    kCFNumberFormatterPadAfterPrefix = 1,
    kCFNumberFormatterPadBeforeSuffix = 2,
    kCFNumberFormatterPadAfterSuffix = 3
  }

  export enum CFNumberFormatterRoundingMode {
    kCFNumberFormatterRoundCeiling = 0,
    kCFNumberFormatterRoundFloor = 1,
    kCFNumberFormatterRoundDown = 2,
    kCFNumberFormatterRoundUp = 3,
    kCFNumberFormatterRoundHalfEven = 4,
    kCFNumberFormatterRoundHalfDown = 5,
    kCFNumberFormatterRoundHalfUp = 6
  }

  export enum CFNumberFormatterStyle {
    kCFNumberFormatterNoStyle = 0,
    kCFNumberFormatterDecimalStyle = 1,
    kCFNumberFormatterCurrencyStyle = 2,
    kCFNumberFormatterPercentStyle = 3,
    kCFNumberFormatterScientificStyle = 4,
    kCFNumberFormatterSpellOutStyle = 5,
    kCFNumberFormatterOrdinalStyle = 6,
    kCFNumberFormatterCurrencyISOCodeStyle = 8,
    kCFNumberFormatterCurrencyPluralStyle = 9,
    kCFNumberFormatterCurrencyAccountingStyle = 10
  }

  export enum CFNumberType {
    kCFNumberSInt8Type = 1,
    kCFNumberSInt16Type = 2,
    kCFNumberSInt32Type = 3,
    kCFNumberSInt64Type = 4,
    kCFNumberFloat32Type = 5,
    kCFNumberFloat64Type = 6,
    kCFNumberCharType = 7,
    kCFNumberShortType = 8,
    kCFNumberIntType = 9,
    kCFNumberLongType = 10,
    kCFNumberLongLongType = 11,
    kCFNumberFloatType = 12,
    kCFNumberDoubleType = 13,
    kCFNumberCFIndexType = 14,
    kCFNumberNSIntegerType = 15,
    kCFNumberCGFloatType = 16,
    kCFNumberMaxType = 16
  }

  export enum CFPropertyListFormat {
    kCFPropertyListOpenStepFormat = 1,
    kCFPropertyListXMLFormat_v1_0 = 100,
    kCFPropertyListBinaryFormat_v1_0 = 200
  }

  export enum CFPropertyListMutabilityOptions {
    kCFPropertyListImmutable = 0,
    kCFPropertyListMutableContainers = 1,
    kCFPropertyListMutableContainersAndLeaves = 2
  }

  export enum CFRunLoopActivity {
    kCFRunLoopEntry = 1,
    kCFRunLoopBeforeTimers = 2,
    kCFRunLoopBeforeSources = 4,
    kCFRunLoopBeforeWaiting = 32,
    kCFRunLoopAfterWaiting = 64,
    kCFRunLoopExit = 128,
    kCFRunLoopAllActivities = 268435455
  }

  export enum CFRunLoopRunResult {
    kCFRunLoopRunFinished = 1,
    kCFRunLoopRunStopped = 2,
    kCFRunLoopRunTimedOut = 3,
    kCFRunLoopRunHandledSource = 4
  }

  export enum CFSocketCallBackType {
    kCFSocketNoCallBack = 0,
    kCFSocketReadCallBack = 1,
    kCFSocketAcceptCallBack = 2,
    kCFSocketDataCallBack = 3,
    kCFSocketConnectCallBack = 4,
    kCFSocketWriteCallBack = 8
  }

  export enum CFSocketError {
    kCFSocketSuccess = 0,
    kCFSocketError = -1,
    kCFSocketTimeout = -2
  }

  export enum CFStreamErrorDomain {
    kCFStreamErrorDomainCustom = -1,
    kCFStreamErrorDomainPOSIX = 1,
    kCFStreamErrorDomainMacOSStatus = 2
  }

  export enum CFStreamEventType {
    kCFStreamEventNone = 0,
    kCFStreamEventOpenCompleted = 1,
    kCFStreamEventHasBytesAvailable = 2,
    kCFStreamEventCanAcceptBytes = 4,
    kCFStreamEventErrorOccurred = 8,
    kCFStreamEventEndEncountered = 16
  }

  export enum CFStreamStatus {
    kCFStreamStatusNotOpen = 0,
    kCFStreamStatusOpening = 1,
    kCFStreamStatusOpen = 2,
    kCFStreamStatusReading = 3,
    kCFStreamStatusWriting = 4,
    kCFStreamStatusAtEnd = 5,
    kCFStreamStatusClosed = 6,
    kCFStreamStatusError = 7
  }

  export enum CFStringBuiltInEncodings {
    kCFStringEncodingMacRoman = 0,
    kCFStringEncodingWindowsLatin1 = 1280,
    kCFStringEncodingISOLatin1 = 513,
    kCFStringEncodingNextStepLatin = 2817,
    kCFStringEncodingASCII = 1536,
    kCFStringEncodingUnicode = 256,
    kCFStringEncodingUTF8 = 134217984,
    kCFStringEncodingNonLossyASCII = 3071,
    kCFStringEncodingUTF16 = 256,
    kCFStringEncodingUTF16BE = 268435712,
    kCFStringEncodingUTF16LE = 335544576,
    kCFStringEncodingUTF32 = 201326848,
    kCFStringEncodingUTF32BE = 402653440,
    kCFStringEncodingUTF32LE = 469762304
  }

  export enum CFStringCompareFlags {
    kCFCompareCaseInsensitive = 1,
    kCFCompareBackwards = 4,
    kCFCompareAnchored = 8,
    kCFCompareNonliteral = 16,
    kCFCompareLocalized = 32,
    kCFCompareNumerically = 64,
    kCFCompareDiacriticInsensitive = 128,
    kCFCompareWidthInsensitive = 256,
    kCFCompareForcedOrdering = 512
  }

  export enum CFStringEncodings {
    kCFStringEncodingMacJapanese = 1,
    kCFStringEncodingMacChineseTrad = 2,
    kCFStringEncodingMacKorean = 3,
    kCFStringEncodingMacArabic = 4,
    kCFStringEncodingMacHebrew = 5,
    kCFStringEncodingMacGreek = 6,
    kCFStringEncodingMacCyrillic = 7,
    kCFStringEncodingMacDevanagari = 9,
    kCFStringEncodingMacGurmukhi = 10,
    kCFStringEncodingMacGujarati = 11,
    kCFStringEncodingMacOriya = 12,
    kCFStringEncodingMacBengali = 13,
    kCFStringEncodingMacTamil = 14,
    kCFStringEncodingMacTelugu = 15,
    kCFStringEncodingMacKannada = 16,
    kCFStringEncodingMacMalayalam = 17,
    kCFStringEncodingMacSinhalese = 18,
    kCFStringEncodingMacBurmese = 19,
    kCFStringEncodingMacKhmer = 20,
    kCFStringEncodingMacThai = 21,
    kCFStringEncodingMacLaotian = 22,
    kCFStringEncodingMacGeorgian = 23,
    kCFStringEncodingMacArmenian = 24,
    kCFStringEncodingMacChineseSimp = 25,
    kCFStringEncodingMacTibetan = 26,
    kCFStringEncodingMacMongolian = 27,
    kCFStringEncodingMacEthiopic = 28,
    kCFStringEncodingMacCentralEurRoman = 29,
    kCFStringEncodingMacVietnamese = 30,
    kCFStringEncodingMacExtArabic = 31,
    kCFStringEncodingMacSymbol = 33,
    kCFStringEncodingMacDingbats = 34,
    kCFStringEncodingMacTurkish = 35,
    kCFStringEncodingMacCroatian = 36,
    kCFStringEncodingMacIcelandic = 37,
    kCFStringEncodingMacRomanian = 38,
    kCFStringEncodingMacCeltic = 39,
    kCFStringEncodingMacGaelic = 40,
    kCFStringEncodingMacFarsi = 140,
    kCFStringEncodingMacUkrainian = 152,
    kCFStringEncodingMacInuit = 236,
    kCFStringEncodingMacVT100 = 252,
    kCFStringEncodingMacHFS = 255,
    kCFStringEncodingISOLatin2 = 514,
    kCFStringEncodingISOLatin3 = 515,
    kCFStringEncodingISOLatin4 = 516,
    kCFStringEncodingISOLatinCyrillic = 517,
    kCFStringEncodingISOLatinArabic = 518,
    kCFStringEncodingISOLatinGreek = 519,
    kCFStringEncodingISOLatinHebrew = 520,
    kCFStringEncodingISOLatin5 = 521,
    kCFStringEncodingISOLatin6 = 522,
    kCFStringEncodingISOLatinThai = 523,
    kCFStringEncodingISOLatin7 = 525,
    kCFStringEncodingISOLatin8 = 526,
    kCFStringEncodingISOLatin9 = 527,
    kCFStringEncodingISOLatin10 = 528,
    kCFStringEncodingDOSLatinUS = 1024,
    kCFStringEncodingDOSGreek = 1029,
    kCFStringEncodingDOSBalticRim = 1030,
    kCFStringEncodingDOSLatin1 = 1040,
    kCFStringEncodingDOSGreek1 = 1041,
    kCFStringEncodingDOSLatin2 = 1042,
    kCFStringEncodingDOSCyrillic = 1043,
    kCFStringEncodingDOSTurkish = 1044,
    kCFStringEncodingDOSPortuguese = 1045,
    kCFStringEncodingDOSIcelandic = 1046,
    kCFStringEncodingDOSHebrew = 1047,
    kCFStringEncodingDOSCanadianFrench = 1048,
    kCFStringEncodingDOSArabic = 1049,
    kCFStringEncodingDOSNordic = 1050,
    kCFStringEncodingDOSRussian = 1051,
    kCFStringEncodingDOSGreek2 = 1052,
    kCFStringEncodingDOSThai = 1053,
    kCFStringEncodingDOSJapanese = 1056,
    kCFStringEncodingDOSChineseSimplif = 1057,
    kCFStringEncodingDOSKorean = 1058,
    kCFStringEncodingDOSChineseTrad = 1059,
    kCFStringEncodingWindowsLatin2 = 1281,
    kCFStringEncodingWindowsCyrillic = 1282,
    kCFStringEncodingWindowsGreek = 1283,
    kCFStringEncodingWindowsLatin5 = 1284,
    kCFStringEncodingWindowsHebrew = 1285,
    kCFStringEncodingWindowsArabic = 1286,
    kCFStringEncodingWindowsBalticRim = 1287,
    kCFStringEncodingWindowsVietnamese = 1288,
    kCFStringEncodingWindowsKoreanJohab = 1296,
    kCFStringEncodingANSEL = 1537,
    kCFStringEncodingJIS_X0201_76 = 1568,
    kCFStringEncodingJIS_X0208_83 = 1569,
    kCFStringEncodingJIS_X0208_90 = 1570,
    kCFStringEncodingJIS_X0212_90 = 1571,
    kCFStringEncodingJIS_C6226_78 = 1572,
    kCFStringEncodingShiftJIS_X0213 = 1576,
    kCFStringEncodingShiftJIS_X0213_MenKuTen = 1577,
    kCFStringEncodingGB_2312_80 = 1584,
    kCFStringEncodingGBK_95 = 1585,
    kCFStringEncodingGB_18030_2000 = 1586,
    kCFStringEncodingKSC_5601_87 = 1600,
    kCFStringEncodingKSC_5601_92_Johab = 1601,
    kCFStringEncodingCNS_11643_92_P1 = 1617,
    kCFStringEncodingCNS_11643_92_P2 = 1618,
    kCFStringEncodingCNS_11643_92_P3 = 1619,
    kCFStringEncodingISO_2022_JP = 2080,
    kCFStringEncodingISO_2022_JP_2 = 2081,
    kCFStringEncodingISO_2022_JP_1 = 2082,
    kCFStringEncodingISO_2022_JP_3 = 2083,
    kCFStringEncodingISO_2022_CN = 2096,
    kCFStringEncodingISO_2022_CN_EXT = 2097,
    kCFStringEncodingISO_2022_KR = 2112,
    kCFStringEncodingEUC_JP = 2336,
    kCFStringEncodingEUC_CN = 2352,
    kCFStringEncodingEUC_TW = 2353,
    kCFStringEncodingEUC_KR = 2368,
    kCFStringEncodingShiftJIS = 2561,
    kCFStringEncodingKOI8_R = 2562,
    kCFStringEncodingBig5 = 2563,
    kCFStringEncodingMacRomanLatin1 = 2564,
    kCFStringEncodingHZ_GB_2312 = 2565,
    kCFStringEncodingBig5_HKSCS_1999 = 2566,
    kCFStringEncodingVISCII = 2567,
    kCFStringEncodingKOI8_U = 2568,
    kCFStringEncodingBig5_E = 2569,
    kCFStringEncodingNextStepJapanese = 2818,
    kCFStringEncodingEBCDIC_US = 3073,
    kCFStringEncodingEBCDIC_CP037 = 3074,
    kCFStringEncodingUTF7 = 67109120,
    kCFStringEncodingUTF7_IMAP = 2576,
    kCFStringEncodingShiftJIS_X0213_00 = 1576
  }

  export enum CFStringNormalizationForm {
    kCFStringNormalizationFormD = 0,
    kCFStringNormalizationFormKD = 1,
    kCFStringNormalizationFormC = 2,
    kCFStringNormalizationFormKC = 3
  }

  export enum CFStringTokenizerTokenType {
    kCFStringTokenizerTokenNone = 0,
    kCFStringTokenizerTokenNormal = 1,
    kCFStringTokenizerTokenHasSubTokensMask = 2,
    kCFStringTokenizerTokenHasDerivedSubTokensMask = 4,
    kCFStringTokenizerTokenHasHasNumbersMask = 8,
    kCFStringTokenizerTokenHasNonLettersMask = 16,
    kCFStringTokenizerTokenIsCJWordMask = 32
  }

  export enum CFTimeZoneNameStyle {
    kCFTimeZoneNameStyleStandard = 0,
    kCFTimeZoneNameStyleShortStandard = 1,
    kCFTimeZoneNameStyleDaylightSaving = 2,
    kCFTimeZoneNameStyleShortDaylightSaving = 3,
    kCFTimeZoneNameStyleGeneric = 4,
    kCFTimeZoneNameStyleShortGeneric = 5
  }

  export enum CFURLBookmarkCreationOptions {
    kCFURLBookmarkCreationMinimalBookmarkMask = 512,
    kCFURLBookmarkCreationSuitableForBookmarkFile = 1024,
    kCFURLBookmarkCreationWithSecurityScope = 2048,
    kCFURLBookmarkCreationSecurityScopeAllowOnlyReadAccess = 4096,
    kCFURLBookmarkCreationPreferFileIDResolutionMask = 256
  }

  export enum CFURLBookmarkResolutionOptions {
    kCFURLBookmarkResolutionWithoutUIMask = 256,
    kCFURLBookmarkResolutionWithoutMountingMask = 512,
    kCFURLBookmarkResolutionWithSecurityScope = 1024,
    kCFBookmarkResolutionWithoutUIMask = 256,
    kCFBookmarkResolutionWithoutMountingMask = 512
  }

  export enum CFURLComponentType {
    kCFURLComponentScheme = 1,
    kCFURLComponentNetLocation = 2,
    kCFURLComponentPath = 3,
    kCFURLComponentResourceSpecifier = 4,
    kCFURLComponentUser = 5,
    kCFURLComponentPassword = 6,
    kCFURLComponentUserInfo = 7,
    kCFURLComponentHost = 8,
    kCFURLComponentPort = 9,
    kCFURLComponentParameterString = 10,
    kCFURLComponentQuery = 11,
    kCFURLComponentFragment = 12
  }

  export enum CFURLEnumeratorOptions {
    kCFURLEnumeratorDefaultBehavior = 0,
    kCFURLEnumeratorDescendRecursively = 1,
    kCFURLEnumeratorSkipInvisibles = 2,
    kCFURLEnumeratorGenerateFileReferenceURLs = 4,
    kCFURLEnumeratorSkipPackageContents = 8,
    kCFURLEnumeratorIncludeDirectoriesPreOrder = 16,
    kCFURLEnumeratorIncludeDirectoriesPostOrder = 32,
    kCFURLEnumeratorGenerateRelativePathURLs = 64
  }

  export enum CFURLEnumeratorResult {
    kCFURLEnumeratorSuccess = 1,
    kCFURLEnumeratorEnd = 2,
    kCFURLEnumeratorError = 3,
    kCFURLEnumeratorDirectoryPostOrderSuccess = 4
  }

  export enum CFURLPathStyle {
    kCFURLPOSIXPathStyle = 0,
    kCFURLHFSPathStyle = 1,
    kCFURLWindowsPathStyle = 2
  }

  export enum CFXMLEntityTypeCode {
    kCFXMLEntityTypeParameter = 0,
    kCFXMLEntityTypeParsedInternal = 1,
    kCFXMLEntityTypeParsedExternal = 2,
    kCFXMLEntityTypeUnparsed = 3,
    kCFXMLEntityTypeCharacter = 4
  }

  export enum CFXMLNodeTypeCode {
    kCFXMLNodeTypeDocument = 1,
    kCFXMLNodeTypeElement = 2,
    kCFXMLNodeTypeAttribute = 3,
    kCFXMLNodeTypeProcessingInstruction = 4,
    kCFXMLNodeTypeComment = 5,
    kCFXMLNodeTypeText = 6,
    kCFXMLNodeTypeCDATASection = 7,
    kCFXMLNodeTypeDocumentFragment = 8,
    kCFXMLNodeTypeEntity = 9,
    kCFXMLNodeTypeEntityReference = 10,
    kCFXMLNodeTypeDocumentType = 11,
    kCFXMLNodeTypeWhitespace = 12,
    kCFXMLNodeTypeNotation = 13,
    kCFXMLNodeTypeElementTypeDeclaration = 14,
    kCFXMLNodeTypeAttributeListDeclaration = 15
  }

  export enum CFXMLParserOptions {
    kCFXMLParserValidateDocument = 1,
    kCFXMLParserSkipMetaData = 2,
    kCFXMLParserReplacePhysicalEntities = 4,
    kCFXMLParserSkipWhitespace = 8,
    kCFXMLParserResolveExternalEntities = 16,
    kCFXMLParserAddImpliedAttributes = 32,
    kCFXMLParserAllOptions = 16777215,
    kCFXMLParserNoOptions = 0
  }

  export enum CFXMLParserStatusCode {
    kCFXMLStatusParseNotBegun = -2,
    kCFXMLStatusParseInProgress = -1,
    kCFXMLStatusParseSuccessful = 0,
    kCFXMLErrorUnexpectedEOF = 1,
    kCFXMLErrorUnknownEncoding = 2,
    kCFXMLErrorEncodingConversionFailure = 3,
    kCFXMLErrorMalformedProcessingInstruction = 4,
    kCFXMLErrorMalformedDTD = 5,
    kCFXMLErrorMalformedName = 6,
    kCFXMLErrorMalformedCDSect = 7,
    kCFXMLErrorMalformedCloseTag = 8,
    kCFXMLErrorMalformedStartTag = 9,
    kCFXMLErrorMalformedDocument = 10,
    kCFXMLErrorElementlessDocument = 11,
    kCFXMLErrorMalformedComment = 12,
    kCFXMLErrorMalformedCharacterReference = 13,
    kCFXMLErrorMalformedParsedCharacterData = 14,
    kCFXMLErrorNoData = 15
  }

  export enum __CFByteOrder {
    CFByteOrderUnknown = 0,
    CFByteOrderLittleEndian = 1,
    CFByteOrderBigEndian = 2
  }

  export enum CGBitmapInfo {
    kCGBitmapAlphaInfoMask = 31,
    kCGBitmapFloatInfoMask = 3840,
    kCGBitmapFloatComponents = 256,
    kCGBitmapByteOrderMask = 28672,
    kCGBitmapByteOrderDefault = 0,
    kCGBitmapByteOrder16Little = 4096,
    kCGBitmapByteOrder32Little = 8192,
    kCGBitmapByteOrder16Big = 12288,
    kCGBitmapByteOrder32Big = 16384
  }

  export enum CGBlendMode {
    kCGBlendModeNormal = 0,
    kCGBlendModeMultiply = 1,
    kCGBlendModeScreen = 2,
    kCGBlendModeOverlay = 3,
    kCGBlendModeDarken = 4,
    kCGBlendModeLighten = 5,
    kCGBlendModeColorDodge = 6,
    kCGBlendModeColorBurn = 7,
    kCGBlendModeSoftLight = 8,
    kCGBlendModeHardLight = 9,
    kCGBlendModeDifference = 10,
    kCGBlendModeExclusion = 11,
    kCGBlendModeHue = 12,
    kCGBlendModeSaturation = 13,
    kCGBlendModeColor = 14,
    kCGBlendModeLuminosity = 15,
    kCGBlendModeClear = 16,
    kCGBlendModeCopy = 17,
    kCGBlendModeSourceIn = 18,
    kCGBlendModeSourceOut = 19,
    kCGBlendModeSourceAtop = 20,
    kCGBlendModeDestinationOver = 21,
    kCGBlendModeDestinationIn = 22,
    kCGBlendModeDestinationOut = 23,
    kCGBlendModeDestinationAtop = 24,
    kCGBlendModeXOR = 25,
    kCGBlendModePlusDarker = 26,
    kCGBlendModePlusLighter = 27
  }

  export enum CGCaptureOptions {
    kCGCaptureNoOptions = 0,
    kCGCaptureNoFill = 1
  }

  export enum CGColorConversionInfoTransformType {
    kCGColorConversionTransformFromSpace = 0,
    kCGColorConversionTransformToSpace = 1,
    kCGColorConversionTransformApplySpace = 2
  }

  export enum CGColorRenderingIntent {
    kCGRenderingIntentDefault = 0,
    kCGRenderingIntentAbsoluteColorimetric = 1,
    kCGRenderingIntentRelativeColorimetric = 2,
    kCGRenderingIntentPerceptual = 3,
    kCGRenderingIntentSaturation = 4
  }

  export enum CGColorSpaceModel {
    kCGColorSpaceModelUnknown = -1,
    kCGColorSpaceModelMonochrome = 0,
    kCGColorSpaceModelRGB = 1,
    kCGColorSpaceModelCMYK = 2,
    kCGColorSpaceModelLab = 3,
    kCGColorSpaceModelDeviceN = 4,
    kCGColorSpaceModelIndexed = 5,
    kCGColorSpaceModelPattern = 6,
    kCGColorSpaceModelXYZ = 7
  }

  export enum CGConfigureOption {
    kCGConfigureForAppOnly = 0,
    kCGConfigureForSession = 1,
    kCGConfigurePermanently = 2
  }

  export enum CGDisplayChangeSummaryFlags {
    kCGDisplayBeginConfigurationFlag = 1,
    kCGDisplayMovedFlag = 2,
    kCGDisplaySetMainFlag = 4,
    kCGDisplaySetModeFlag = 8,
    kCGDisplayAddFlag = 16,
    kCGDisplayRemoveFlag = 32,
    kCGDisplayEnabledFlag = 256,
    kCGDisplayDisabledFlag = 512,
    kCGDisplayMirrorFlag = 1024,
    kCGDisplayUnMirrorFlag = 2048,
    kCGDisplayDesktopShapeChangedFlag = 4096
  }

  export enum CGDisplayStreamFrameStatus {
    kCGDisplayStreamFrameStatusFrameComplete = 0,
    kCGDisplayStreamFrameStatusFrameIdle = 1,
    kCGDisplayStreamFrameStatusFrameBlank = 2,
    kCGDisplayStreamFrameStatusStopped = 3
  }

  export enum CGDisplayStreamUpdateRectType {
    kCGDisplayStreamUpdateRefreshedRects = 0,
    kCGDisplayStreamUpdateMovedRects = 1,
    kCGDisplayStreamUpdateDirtyRects = 2,
    kCGDisplayStreamUpdateReducedDirtyRects = 3
  }

  export enum CGError {
    kCGErrorSuccess = 0,
    kCGErrorFailure = 1000,
    kCGErrorIllegalArgument = 1001,
    kCGErrorInvalidConnection = 1002,
    kCGErrorInvalidContext = 1003,
    kCGErrorCannotComplete = 1004,
    kCGErrorNotImplemented = 1006,
    kCGErrorRangeCheck = 1007,
    kCGErrorTypeCheck = 1008,
    kCGErrorInvalidOperation = 1010,
    kCGErrorNoneAvailable = 1011
  }

  export enum CGEventField {
    kCGMouseEventNumber = 0,
    kCGMouseEventClickState = 1,
    kCGMouseEventPressure = 2,
    kCGMouseEventButtonNumber = 3,
    kCGMouseEventDeltaX = 4,
    kCGMouseEventDeltaY = 5,
    kCGMouseEventInstantMouser = 6,
    kCGMouseEventSubtype = 7,
    kCGKeyboardEventAutorepeat = 8,
    kCGKeyboardEventKeycode = 9,
    kCGKeyboardEventKeyboardType = 10,
    kCGScrollWheelEventDeltaAxis1 = 11,
    kCGScrollWheelEventDeltaAxis2 = 12,
    kCGScrollWheelEventDeltaAxis3 = 13,
    kCGScrollWheelEventFixedPtDeltaAxis1 = 93,
    kCGScrollWheelEventFixedPtDeltaAxis2 = 94,
    kCGScrollWheelEventFixedPtDeltaAxis3 = 95,
    kCGScrollWheelEventPointDeltaAxis1 = 96,
    kCGScrollWheelEventPointDeltaAxis2 = 97,
    kCGScrollWheelEventPointDeltaAxis3 = 98,
    kCGScrollWheelEventScrollPhase = 99,
    kCGScrollWheelEventScrollCount = 100,
    kCGScrollWheelEventMomentumPhase = 123,
    kCGScrollWheelEventInstantMouser = 14,
    kCGTabletEventPointX = 15,
    kCGTabletEventPointY = 16,
    kCGTabletEventPointZ = 17,
    kCGTabletEventPointButtons = 18,
    kCGTabletEventPointPressure = 19,
    kCGTabletEventTiltX = 20,
    kCGTabletEventTiltY = 21,
    kCGTabletEventRotation = 22,
    kCGTabletEventTangentialPressure = 23,
    kCGTabletEventDeviceID = 24,
    kCGTabletEventVendor1 = 25,
    kCGTabletEventVendor2 = 26,
    kCGTabletEventVendor3 = 27,
    kCGTabletProximityEventVendorID = 28,
    kCGTabletProximityEventTabletID = 29,
    kCGTabletProximityEventPointerID = 30,
    kCGTabletProximityEventDeviceID = 31,
    kCGTabletProximityEventSystemTabletID = 32,
    kCGTabletProximityEventVendorPointerType = 33,
    kCGTabletProximityEventVendorPointerSerialNumber = 34,
    kCGTabletProximityEventVendorUniqueID = 35,
    kCGTabletProximityEventCapabilityMask = 36,
    kCGTabletProximityEventPointerType = 37,
    kCGTabletProximityEventEnterProximity = 38,
    kCGEventTargetProcessSerialNumber = 39,
    kCGEventTargetUnixProcessID = 40,
    kCGEventSourceUnixProcessID = 41,
    kCGEventSourceUserData = 42,
    kCGEventSourceUserID = 43,
    kCGEventSourceGroupID = 44,
    kCGEventSourceStateID = 45,
    kCGScrollWheelEventIsContinuous = 88,
    kCGMouseEventWindowUnderMousePointer = 91,
    kCGMouseEventWindowUnderMousePointerThatCanHandleThisEvent = 92,
    kCGEventUnacceleratedPointerMovementX = 170,
    kCGEventUnacceleratedPointerMovementY = 171
  }

  export enum CGEventFilterMask {
    kCGEventFilterMaskPermitLocalMouseEvents = 1,
    kCGEventFilterMaskPermitLocalKeyboardEvents = 2,
    kCGEventFilterMaskPermitSystemDefinedEvents = 4
  }

  export enum CGEventFlags {
    kCGEventFlagMaskAlphaShift = 65536,
    kCGEventFlagMaskShift = 131072,
    kCGEventFlagMaskControl = 262144,
    kCGEventFlagMaskAlternate = 524288,
    kCGEventFlagMaskCommand = 1048576,
    kCGEventFlagMaskHelp = 4194304,
    kCGEventFlagMaskSecondaryFn = 8388608,
    kCGEventFlagMaskNumericPad = 2097152,
    kCGEventFlagMaskNonCoalesced = 256
  }

  export enum CGEventMouseSubtype {
    kCGEventMouseSubtypeDefault = 0,
    kCGEventMouseSubtypeTabletPoint = 1,
    kCGEventMouseSubtypeTabletProximity = 2
  }

  export enum CGEventSourceStateID {
    kCGEventSourceStatePrivate = -1,
    kCGEventSourceStateCombinedSessionState = 0,
    kCGEventSourceStateHIDSystemState = 1
  }

  export enum CGEventSuppressionState {
    kCGEventSuppressionStateSuppressionInterval = 0,
    kCGEventSuppressionStateRemoteMouseDrag = 1,
    kCGNumberOfEventSuppressionStates = 2
  }

  export enum CGEventTapLocation {
    kCGHIDEventTap = 0,
    kCGSessionEventTap = 1,
    kCGAnnotatedSessionEventTap = 2
  }

  export enum CGEventTapOptions {
    kCGEventTapOptionDefault = 0,
    kCGEventTapOptionListenOnly = 1
  }

  export enum CGEventTapPlacement {
    kCGHeadInsertEventTap = 0,
    kCGTailAppendEventTap = 1
  }

  export enum CGEventType {
    kCGEventNull = 0,
    kCGEventLeftMouseDown = 1,
    kCGEventLeftMouseUp = 2,
    kCGEventRightMouseDown = 3,
    kCGEventRightMouseUp = 4,
    kCGEventMouseMoved = 5,
    kCGEventLeftMouseDragged = 6,
    kCGEventRightMouseDragged = 7,
    kCGEventKeyDown = 10,
    kCGEventKeyUp = 11,
    kCGEventFlagsChanged = 12,
    kCGEventScrollWheel = 22,
    kCGEventTabletPointer = 23,
    kCGEventTabletProximity = 24,
    kCGEventOtherMouseDown = 25,
    kCGEventOtherMouseUp = 26,
    kCGEventOtherMouseDragged = 27,
    kCGEventTapDisabledByTimeout = 4294967294,
    kCGEventTapDisabledByUserInput = 4294967295
  }

  export enum CGFontPostScriptFormat {
    kCGFontPostScriptFormatType1 = 1,
    kCGFontPostScriptFormatType3 = 3,
    kCGFontPostScriptFormatType42 = 42
  }

  export enum CGGesturePhase {
    kCGGesturePhaseNone = 0,
    kCGGesturePhaseBegan = 1,
    kCGGesturePhaseChanged = 2,
    kCGGesturePhaseEnded = 4,
    kCGGesturePhaseCancelled = 8,
    kCGGesturePhaseMayBegin = 128
  }

  export enum CGGlyphDeprecatedEnum {
    Min = 0,
    Max = 1
  }

  export enum CGGradientDrawingOptions {
    kCGGradientDrawsBeforeStartLocation = 1,
    kCGGradientDrawsAfterEndLocation = 2
  }

  export enum CGImageAlphaInfo {
    kCGImageAlphaNone = 0,
    kCGImageAlphaPremultipliedLast = 1,
    kCGImageAlphaPremultipliedFirst = 2,
    kCGImageAlphaLast = 3,
    kCGImageAlphaFirst = 4,
    kCGImageAlphaNoneSkipLast = 5,
    kCGImageAlphaNoneSkipFirst = 6,
    kCGImageAlphaOnly = 7
  }

  export enum CGImageByteOrderInfo {
    kCGImageByteOrderMask = 28672,
    kCGImageByteOrderDefault = 0,
    kCGImageByteOrder16Little = 4096,
    kCGImageByteOrder32Little = 8192,
    kCGImageByteOrder16Big = 12288,
    kCGImageByteOrder32Big = 16384
  }

  export enum CGImagePixelFormatInfo {
    kCGImagePixelFormatMask = 983040,
    kCGImagePixelFormatPacked = 0,
    kCGImagePixelFormatRGB555 = 65536,
    kCGImagePixelFormatRGB565 = 131072,
    kCGImagePixelFormatRGB101010 = 196608,
    kCGImagePixelFormatRGBCIF10 = 262144
  }

  export enum CGInterpolationQuality {
    kCGInterpolationDefault = 0,
    kCGInterpolationNone = 1,
    kCGInterpolationLow = 2,
    kCGInterpolationMedium = 4,
    kCGInterpolationHigh = 3
  }

  export enum CGLineCap {
    kCGLineCapButt = 0,
    kCGLineCapRound = 1,
    kCGLineCapSquare = 2
  }

  export enum CGLineJoin {
    kCGLineJoinMiter = 0,
    kCGLineJoinRound = 1,
    kCGLineJoinBevel = 2
  }

  export enum CGMomentumScrollPhase {
    kCGMomentumScrollPhaseNone = 0,
    kCGMomentumScrollPhaseBegin = 1,
    kCGMomentumScrollPhaseContinue = 2,
    kCGMomentumScrollPhaseEnd = 3
  }

  export enum CGMouseButton {
    kCGMouseButtonLeft = 0,
    kCGMouseButtonRight = 1,
    kCGMouseButtonCenter = 2
  }

  export enum CGPDFAccessPermissions {
    kCGPDFAllowsLowQualityPrinting = 1,
    kCGPDFAllowsHighQualityPrinting = 2,
    kCGPDFAllowsDocumentChanges = 4,
    kCGPDFAllowsDocumentAssembly = 8,
    kCGPDFAllowsContentCopying = 16,
    kCGPDFAllowsContentAccessibility = 32,
    kCGPDFAllowsCommenting = 64,
    kCGPDFAllowsFormFieldEntry = 128
  }

  export enum CGPDFBox {
    kCGPDFMediaBox = 0,
    kCGPDFCropBox = 1,
    kCGPDFBleedBox = 2,
    kCGPDFTrimBox = 3,
    kCGPDFArtBox = 4
  }

  export enum CGPDFDataFormat {
    Raw = 0,
    JPEGEncoded = 1,
    JPEG2000 = 2
  }

  export enum CGPDFObjectType {
    kCGPDFObjectTypeNull = 1,
    kCGPDFObjectTypeBoolean = 2,
    kCGPDFObjectTypeInteger = 3,
    kCGPDFObjectTypeReal = 4,
    kCGPDFObjectTypeName = 5,
    kCGPDFObjectTypeString = 6,
    kCGPDFObjectTypeArray = 7,
    kCGPDFObjectTypeDictionary = 8,
    kCGPDFObjectTypeStream = 9
  }

  export enum CGPDFTagType {
    Document = 100,
    Part = 101,
    Art = 102,
    Section = 103,
    Div = 104,
    BlockQuote = 105,
    Caption = 106,
    TOC = 107,
    TOCI = 108,
    Index = 109,
    NonStructure = 110,
    Private = 111,
    Paragraph = 200,
    Header = 201,
    Header1 = 202,
    Header2 = 203,
    Header3 = 204,
    Header4 = 205,
    Header5 = 206,
    Header6 = 207,
    List = 300,
    ListItem = 301,
    Label = 302,
    ListBody = 303,
    Table = 400,
    TableRow = 401,
    TableHeaderCell = 402,
    TableDataCell = 403,
    TableHeader = 404,
    TableBody = 405,
    TableFooter = 406,
    Span = 500,
    Quote = 501,
    Note = 502,
    Reference = 503,
    Bibliography = 504,
    Code = 505,
    Link = 506,
    Annotation = 507,
    Ruby = 600,
    RubyBaseText = 601,
    RubyAnnotationText = 602,
    RubyPunctuation = 603,
    Warichu = 604,
    WarichuText = 605,
    WarichuPunctiation = 606,
    Figure = 700,
    Formula = 701,
    Form = 702
  }

  export enum CGPathDrawingMode {
    kCGPathFill = 0,
    kCGPathEOFill = 1,
    kCGPathStroke = 2,
    kCGPathFillStroke = 3,
    kCGPathEOFillStroke = 4
  }

  export enum CGPathElementType {
    kCGPathElementMoveToPoint = 0,
    kCGPathElementAddLineToPoint = 1,
    kCGPathElementAddQuadCurveToPoint = 2,
    kCGPathElementAddCurveToPoint = 3,
    kCGPathElementCloseSubpath = 4
  }

  export enum CGPatternTiling {
    kCGPatternTilingNoDistortion = 0,
    kCGPatternTilingConstantSpacingMinimalDistortion = 1,
    kCGPatternTilingConstantSpacing = 2
  }

  export enum CGRectEdge {
    MinXEdge = 0,
    MinYEdge = 1,
    MaxXEdge = 2,
    MaxYEdge = 3
  }

  export enum CGScreenUpdateOperation {
    kCGScreenUpdateOperationRefresh = 0,
    kCGScreenUpdateOperationMove = 1,
    kCGScreenUpdateOperationReducedDirtyRectangleCount = 2147483648
  }

  export enum CGScrollEventUnit {
    kCGScrollEventUnitPixel = 0,
    kCGScrollEventUnitLine = 1
  }

  export enum CGScrollPhase {
    kCGScrollPhaseBegan = 1,
    kCGScrollPhaseChanged = 2,
    kCGScrollPhaseEnded = 4,
    kCGScrollPhaseCancelled = 8,
    kCGScrollPhaseMayBegin = 128
  }

  export enum CGTextDrawingMode {
    kCGTextFill = 0,
    kCGTextStroke = 1,
    kCGTextFillStroke = 2,
    kCGTextInvisible = 3,
    kCGTextFillClip = 4,
    kCGTextStrokeClip = 5,
    kCGTextFillStrokeClip = 6,
    kCGTextClip = 7
  }

  export enum CGWindowBackingType {
    kCGBackingStoreRetained = 0,
    kCGBackingStoreNonretained = 1,
    kCGBackingStoreBuffered = 2
  }

  export enum CGWindowImageOption {
    kCGWindowImageDefault = 0,
    kCGWindowImageBoundsIgnoreFraming = 1,
    kCGWindowImageShouldBeOpaque = 2,
    kCGWindowImageOnlyShadows = 4,
    kCGWindowImageBestResolution = 8,
    kCGWindowImageNominalResolution = 16
  }

  export enum CGWindowLevelKey {
    kCGBaseWindowLevelKey = 0,
    kCGMinimumWindowLevelKey = 1,
    kCGDesktopWindowLevelKey = 2,
    kCGBackstopMenuLevelKey = 3,
    kCGNormalWindowLevelKey = 4,
    kCGFloatingWindowLevelKey = 5,
    kCGTornOffMenuWindowLevelKey = 6,
    kCGDockWindowLevelKey = 7,
    kCGMainMenuWindowLevelKey = 8,
    kCGStatusWindowLevelKey = 9,
    kCGModalPanelWindowLevelKey = 10,
    kCGPopUpMenuWindowLevelKey = 11,
    kCGDraggingWindowLevelKey = 12,
    kCGScreenSaverWindowLevelKey = 13,
    kCGMaximumWindowLevelKey = 14,
    kCGOverlayWindowLevelKey = 15,
    kCGHelpWindowLevelKey = 16,
    kCGUtilityWindowLevelKey = 17,
    kCGDesktopIconWindowLevelKey = 18,
    kCGCursorWindowLevelKey = 19,
    kCGAssistiveTechHighWindowLevelKey = 20,
    kCGNumberOfWindowLevelKeys = 21
  }

  export enum CGWindowListOption {
    kCGWindowListOptionAll = 0,
    kCGWindowListOptionOnScreenOnly = 1,
    kCGWindowListOptionOnScreenAboveWindow = 2,
    kCGWindowListOptionOnScreenBelowWindow = 4,
    kCGWindowListOptionIncludingWindow = 8,
    kCGWindowListExcludeDesktopElements = 16
  }

  export enum CGWindowSharingType {
    kCGWindowSharingNone = 0,
    kCGWindowSharingReadOnly = 1,
    kCGWindowSharingReadWrite = 2
  }

  export enum CIDataMatrixCodeECCVersion {
    Version000 = 0,
    Version050 = 50,
    Version080 = 80,
    Version100 = 100,
    Version140 = 140,
    Version200 = 200
  }

  export enum CIQRCodeErrorCorrectionLevel {
    L = 76,
    M = 77,
    Q = 81,
    H = 72
  }

  export enum CIRenderDestinationAlphaMode {
    None = 0,
    Premultiplied = 1,
    Unpremultiplied = 2
  }

  export enum CMTimeFlags {
    kCMTimeFlags_Valid = 1,
    kCMTimeFlags_HasBeenRounded = 2,
    kCMTimeFlags_PositiveInfinity = 4,
    kCMTimeFlags_NegativeInfinity = 8,
    kCMTimeFlags_Indefinite = 16,
    kCMTimeFlags_ImpliedValueFlagsMask = 28
  }

  export enum CMTimeRoundingMethod {
    kCMTimeRoundingMethod_RoundHalfAwayFromZero = 1,
    kCMTimeRoundingMethod_RoundTowardZero = 2,
    kCMTimeRoundingMethod_RoundAwayFromZero = 3,
    kCMTimeRoundingMethod_QuickTime = 4,
    kCMTimeRoundingMethod_RoundTowardPositiveInfinity = 5,
    kCMTimeRoundingMethod_RoundTowardNegativeInfinity = 6,
    kCMTimeRoundingMethod_Default = 1
  }

  export enum AlignmentOptions {
    MinXInward = 1,
    MinYInward = 2,
    MaxXInward = 4,
    MaxYInward = 8,
    WidthInward = 16,
    HeightInward = 32,
    MinXOutward = 256,
    MinYOutward = 512,
    MaxXOutward = 1024,
    MaxYOutward = 2048,
    WidthOutward = 4096,
    HeightOutward = 8192,
    MinXNearest = 65536,
    MinYNearest = 131072,
    MaxXNearest = 262144,
    MaxYNearest = 524288,
    WidthNearest = 1048576,
    HeightNearest = 2097152,
    RectFlipped = -9223372036854775808,
    AllEdgesInward = 15,
    AllEdgesOutward = 3840,
    AllEdgesNearest = 983040
  }

  export enum NSBinarySearchingOptions {
    FirstEqual = 256,
    LastEqual = 512,
    InsertionIndex = 1024
  }

  export enum NSCollectionChangeType {
    Insert = 0,
    Remove = 1
  }

  export enum ComparisonResult {
    OrderedAscending = -1,
    OrderedSame = 0,
    OrderedDescending = 1
  }

  export enum NSEnumerationOptions {
    Concurrent = 1,
    Reverse = 2
  }

  export enum NSItemProviderFileOptions {
    OpenInPlace = 1
  }

  export enum NSItemProviderRepresentationVisibility {
    All = 0,
    Team = 1,
    Group = 2,
    OwnProcess = 3
  }

  export enum NSKeyValueChange {
    Setting = 1,
    Insertion = 2,
    Removal = 3,
    Replacement = 4
  }

  export enum NSKeyValueObservingOptions {
    New = 1,
    Old = 2,
    Initial = 4,
    Prior = 8
  }

  export enum NSKeyValueSetMutationKind {
    UnionSetMutation = 1,
    MinusSetMutation = 2,
    IntersectSetMutation = 3,
    SetSetMutation = 4
  }

  export enum NSLinguisticTaggerUnit {
    Word = 0,
    Sentence = 1,
    Paragraph = 2,
    Document = 3
  }

  export enum NSOrderedCollectionDifferenceCalculationOptions {
    OmitInsertedObjects = 1,
    OmitRemovedObjects = 2,
    InferMoves = 4
  }

  export enum QualityOfService {
    UserInteractive = 33,
    UserInitiated = 25,
    Utility = 17,
    Background = 9,
    Default = -1
  }

  export enum NSRectEdge {
    RectEdgeMinX = 0,
    RectEdgeMinY = 1,
    RectEdgeMaxX = 2,
    RectEdgeMaxY = 3,
    MinXEdge = 0,
    MinYEdge = 1,
    MaxXEdge = 2,
    MaxYEdge = 3
  }

  export enum NSSaveOptions {
    Yes = 0,
    No = 1,
    Ask = 2
  }

  export enum NSSortOptions {
    Concurrent = 1,
    Stable = 16
  }

  export enum NSURLErrorNetworkUnavailableReason {
    Cellular = 0,
    Expensive = 1,
    Constrained = 2
  }

  export enum NSURLSessionDelayedRequestDisposition {
    ContinueLoading = 0,
    UseNewRequest = 1,
    Cancel = 2
  }

  export enum NSURLSessionWebSocketMessageType {
    Data = 0,
    String = 1
  }

  export enum IKCameraDeviceViewDisplayMode {
    None = -1,
    Table = 0,
    Icon = 1
  }

  export enum IKCameraDeviceViewTransferMode {
    FileBased = 0,
    MemoryBased = 1
  }

  export enum IKDeviceBrowserViewDisplayMode {
    Table = 0,
    Outline = 1,
    Icon = 2
  }

  export enum IKImageBrowserCellState {
    StateNoImage = 0,
    StateInvalid = 1,
    StateReady = 2
  }

  export enum IKImageBrowserDropOperation {
    On = 0,
    Before = 1
  }

  export enum IKScannerDeviceViewDisplayMode {
    None = -1,
    Simple = 0,
    Advanced = 1
  }

  export enum IKScannerDeviceViewTransferMode {
    FileBased = 0,
    MemoryBased = 1
  }

  export enum QCPlugInExecutionMode {
    kQCPlugInExecutionModeProvider = 1,
    kQCPlugInExecutionModeProcessor = 2,
    kQCPlugInExecutionModeConsumer = 3
  }

  export enum QCPlugInTimeMode {
    kQCPlugInTimeModeNone = 0,
    kQCPlugInTimeModeIdle = 1,
    kQCPlugInTimeModeTimeBase = 2
  }

  export enum QLPreviewViewStyle {
    Normal = 0,
    Compact = 1
  }

  export enum CAAutoresizingMask {
    kCALayerNotSizable = 0,
    kCALayerMinXMargin = 1,
    kCALayerWidthSizable = 2,
    kCALayerMaxXMargin = 4,
    kCALayerMinYMargin = 8,
    kCALayerHeightSizable = 16,
    kCALayerMaxYMargin = 32
  }

  export enum CAConstraintAttribute {
    kCAConstraintMinX = 0,
    kCAConstraintMidX = 1,
    kCAConstraintMaxX = 2,
    kCAConstraintWidth = 3,
    kCAConstraintMinY = 4,
    kCAConstraintMidY = 5,
    kCAConstraintMaxY = 6,
    kCAConstraintHeight = 7
  }

  export enum CACornerMask {
    kCALayerMinXMinYCorner = 1,
    kCALayerMaxXMinYCorner = 2,
    kCALayerMinXMaxYCorner = 4,
    kCALayerMaxXMaxYCorner = 8
  }

  export enum CAEdgeAntialiasingMask {
    kCALayerLeftEdge = 1,
    kCALayerRightEdge = 2,
    kCALayerBottomEdge = 4,
    kCALayerTopEdge = 8
  }

  // export let AVAssetExportPreset1280x720: string;
  // export let AVAssetExportPreset1920x1080: string;
  // export let AVAssetExportPreset3840x2160: string;
  // export let AVAssetExportPreset640x480: string;
  // export let AVAssetExportPreset960x540: string;
  // export let AVAssetExportPresetAppleM4A: string;
  // export let AVAssetExportPresetAppleM4V1080pHD: string;
  // export let AVAssetExportPresetAppleM4V480pSD: string;
  // export let AVAssetExportPresetAppleM4V720pHD: string;
  // export let AVAssetExportPresetAppleM4VAppleTV: string;
  // export let AVAssetExportPresetAppleM4VCellular: string;
  // export let AVAssetExportPresetAppleM4VWiFi: string;
  // export let AVAssetExportPresetAppleM4ViPod: string;
  // export let AVAssetExportPresetAppleProRes422LPCM: string;
  // export let AVAssetExportPresetAppleProRes4444LPCM: string;
  // export let AVAssetExportPresetHEVC1920x1080: string;
  // export let AVAssetExportPresetHEVC1920x1080WithAlpha: string;
  // export let AVAssetExportPresetHEVC3840x2160: string;
  // export let AVAssetExportPresetHEVC3840x2160WithAlpha: string;
  // export let AVAssetExportPresetHEVCHighestQuality: string;
  // export let AVAssetExportPresetHEVCHighestQualityWithAlpha: string;
  // export let AVAssetExportPresetHighestQuality: string;
  // export let AVAssetExportPresetLowQuality: string;
  // export let AVAssetExportPresetMediumQuality: string;
  // export let AVAssetExportPresetPassthrough: string;
  // export let AVAssetResourceLoadingRequestStreamingContentKeyRequestRequiresPersistentKey: string;
  // export let AVAudioBitRateStrategy_Constant: string;
  // export let AVAudioBitRateStrategy_LongTermAverage: string;
  // export let AVAudioBitRateStrategy_Variable: string;
  // export let AVAudioBitRateStrategy_VariableConstrained: string;
  // export let AVAudioFileTypeKey: string;
  // export let AVAudioUnitManufacturerNameApple: string;
  // export let AVAudioUnitTypeEffect: string;
  // export let AVAudioUnitTypeFormatConverter: string;
  // export let AVAudioUnitTypeGenerator: string;
  // export let AVAudioUnitTypeMIDIProcessor: string;
  // export let AVAudioUnitTypeMixer: string;
  // export let AVAudioUnitTypeMusicDevice: string;
  // export let AVAudioUnitTypeMusicEffect: string;
  // export let AVAudioUnitTypeOfflineEffect: string;
  // export let AVAudioUnitTypeOutput: string;
  // export let AVAudioUnitTypePanner: string;
  // export let AVCaptureSessionErrorKey: string;
  // export let AVChannelLayoutKey: string;
  // export let AVContentKeyRequestProtocolVersionsKey: string;
  // export let AVContentKeyRequestRequiresValidationDataInSecureTokenKey: string;
  // export let AVCoreAnimationBeginTimeAtZero: number;
  // export let AVEncoderAudioQualityForVBRKey: string;
  // export let AVEncoderAudioQualityKey: string;
  // export let AVEncoderBitDepthHintKey: string;
  // export let AVEncoderBitRateKey: string;
  // export let AVEncoderBitRatePerChannelKey: string;
  // export let AVEncoderBitRateStrategyKey: string;
  // export let AVErrorDeviceKey: string;
  // export let AVErrorDiscontinuityFlagsKey: string;
  // export let AVErrorFileSizeKey: string;
  // export let AVErrorFileTypeKey: string;
  // export let AVErrorMediaSubTypeKey: string;
  // export let AVErrorMediaTypeKey: string;
  // export let AVErrorPIDKey: string;
  // export let AVErrorPersistentTrackIDKey: string;
  // export let AVErrorPresentationTimeStampKey: string;
  // export let AVErrorRecordingSuccessfullyFinishedKey: string;
  // export let AVErrorTimeKey: string;
  // export let AVFormatIDKey: string;
  // export let AVFoundationErrorDomain: string;
  // export let AVLinearPCMBitDepthKey: string;
  // export let AVLinearPCMIsBigEndianKey: string;
  // export let AVLinearPCMIsFloatKey: string;
  // export let AVLinearPCMIsNonInterleaved: string;
  // export let AVMovieReferenceRestrictionsKey: string;
  // export let AVNumberOfChannelsKey: string;
  // export let AVPlayerItemFailedToPlayToEndTimeErrorKey: string;
  // export let AVPlayerItemTrackVideoFieldModeDeinterlaceFields: string;
  // export let AVSampleBufferAudioRendererFlushTimeKey: string;
  // export let AVSampleBufferDisplayLayerFailedToDecodeNotificationErrorKey: string;
  // export let AVSampleRateConverterAlgorithmKey: string;
  // export let AVSampleRateConverterAlgorithm_Mastering: string;
  // export let AVSampleRateConverterAlgorithm_MinimumPhase: string;
  // export let AVSampleRateConverterAlgorithm_Normal: string;
  // export let AVSampleRateConverterAudioQualityKey: string;
  // export let AVSampleRateKey: string;
  // export let AVSpeechSynthesisIPANotationAttribute: string;
  // export let AVSpeechSynthesisVoiceIdentifierAlex: string;
  // export let AVSpeechUtteranceDefaultSpeechRate: number;
  // export let AVSpeechUtteranceMaximumSpeechRate: number;
  // export let AVSpeechUtteranceMinimumSpeechRate: number;
  // export let AVStreamingKeyDeliveryContentKeyType: string;
  // export let AVStreamingKeyDeliveryPersistentContentKeyType: string;
  // export let AVURLAssetAllowsCellularAccessKey: string;
  // export let AVURLAssetAllowsConstrainedNetworkAccessKey: string;
  // export let AVURLAssetAllowsExpensiveNetworkAccessKey: string;
  // export let AVURLAssetHTTPCookiesKey: string;
  // export let AVURLAssetPreferPreciseDurationAndTimingKey: string;
  // export let AVURLAssetReferenceRestrictionsKey: string;
  // export let AVVideoAllowFrameReorderingKey: string;
  // export let AVVideoAllowWideColorKey: string;
  // export let AVVideoAverageBitRateKey: string;
  // export let AVVideoAverageNonDroppableFrameRateKey: string;
  // export let AVVideoCleanApertureHeightKey: string;
  // export let AVVideoCleanApertureHorizontalOffsetKey: string;
  // export let AVVideoCleanApertureKey: string;
  // export let AVVideoCleanApertureVerticalOffsetKey: string;
  // export let AVVideoCleanApertureWidthKey: string;
  // export let AVVideoCodecKey: string;
  // export let AVVideoColorPrimariesKey: string;
  // export let AVVideoColorPrimaries_EBU_3213: string;
  // export let AVVideoColorPrimaries_ITU_R_2020: string;
  // export let AVVideoColorPrimaries_ITU_R_709_2: string;
  // export let AVVideoColorPrimaries_P3_D65: string;
  // export let AVVideoColorPrimaries_SMPTE_C: string;
  // export let AVVideoColorPropertiesKey: string;
  // export let AVVideoCompressionPropertiesKey: string;
  // export let AVVideoDecompressionPropertiesKey: string;
  // export let AVVideoEncoderSpecificationKey: string;
  // export let AVVideoExpectedSourceFrameRateKey: string;
  // export let AVVideoH264EntropyModeCABAC: string;
  // export let AVVideoH264EntropyModeCAVLC: string;
  // export let AVVideoH264EntropyModeKey: string;
  // export let AVVideoHeightKey: string;
  // export let AVVideoMaxKeyFrameIntervalDurationKey: string;
  // export let AVVideoMaxKeyFrameIntervalKey: string;
  // export let AVVideoPixelAspectRatioHorizontalSpacingKey: string;
  // export let AVVideoPixelAspectRatioKey: string;
  // export let AVVideoPixelAspectRatioVerticalSpacingKey: string;
  // export let AVVideoProfileLevelH264Baseline30: string;
  // export let AVVideoProfileLevelH264Baseline31: string;
  // export let AVVideoProfileLevelH264Baseline41: string;
  // export let AVVideoProfileLevelH264BaselineAutoLevel: string;
  // export let AVVideoProfileLevelH264High40: string;
  // export let AVVideoProfileLevelH264High41: string;
  // export let AVVideoProfileLevelH264HighAutoLevel: string;
  // export let AVVideoProfileLevelH264Main30: string;
  // export let AVVideoProfileLevelH264Main31: string;
  // export let AVVideoProfileLevelH264Main32: string;
  // export let AVVideoProfileLevelH264Main41: string;
  // export let AVVideoProfileLevelH264MainAutoLevel: string;
  // export let AVVideoProfileLevelKey: string;
  // export let AVVideoQualityKey: string;
  // export let AVVideoScalingModeFit: string;
  // export let AVVideoScalingModeKey: string;
  // export let AVVideoScalingModeResize: string;
  // export let AVVideoScalingModeResizeAspect: string;
  // export let AVVideoScalingModeResizeAspectFill: string;
  // export let AVVideoTransferFunctionKey: string;
  // export let AVVideoTransferFunction_ITU_R_2100_HLG: string;
  // export let AVVideoTransferFunction_ITU_R_709_2: string;
  // export let AVVideoTransferFunction_SMPTE_240M_1995: string;
  // export let AVVideoTransferFunction_SMPTE_ST_2084_PQ: string;
  // export let AVVideoWidthKey: string;
  // export let AVVideoYCbCrMatrixKey: string;
  // export let AVVideoYCbCrMatrix_ITU_R_2020: string;
  // export let AVVideoYCbCrMatrix_ITU_R_601_4: string;
  // export let AVVideoYCbCrMatrix_ITU_R_709_2: string;
  // export let AVVideoYCbCrMatrix_SMPTE_240M_1995: string;
  // export let NSAllRomanInputSourcesLocaleIdentifier: string;
  // export let NSAnimationTriggerOrderIn: string;
  // export let NSAnimationTriggerOrderOut: string;
  // export let NSApp: NSApplication;
  // export let NSBlack: number;
  // export let NSDarkGray: number;
  // export let NSDirectionalEdgeInsetsZero: NSDirectionalEdgeInsets;
  // export let NSLightGray: number;
  // export let NSMultipleValuesMarker: any;
  // export let NSNoSelectionMarker: any;
  // export let NSNotApplicableMarker: any;
  // export let NSTypeIdentifierAddressText: string;
  // export let NSTypeIdentifierDateText: string;
  // export let NSTypeIdentifierPhoneNumberText: string;
  // export let NSTypeIdentifierTransitInformationText: string;
  // export let NSUnderlineByWord: NSUnderlineStyle;
  // export let NSUnderlinePatternDash: NSUnderlineStyle;
  // export let NSUnderlinePatternDashDot: NSUnderlineStyle;
  // export let NSUnderlinePatternDashDotDot: NSUnderlineStyle;
  // export let NSUnderlinePatternDot: NSUnderlineStyle;
  // export let NSUnderlinePatternSolid: NSUnderlineStyle;
  // export let NSUserActivityDocumentURLKey: string;
  // export let NSWhite: number;
  // export let NSAddedPersistentStoresKey: string;
  // export let NSAffectedObjectsErrorKey: string;
  // export let NSAffectedStoresErrorKey: string;
  // export let NSBinaryStoreInsecureDecodingCompatibilityOption: string;
  // export let NSBinaryStoreSecureDecodingClasses: string;
  // export let NSBinaryStoreType: string;
  // export let NSCoreDataCoreSpotlightExporter: string;
  // export let NSCoreDataVersionNumber: number;
  // export let NSDeletedObjectsKey: string;
  // export let NSDetailedErrorsKey: string;
  // export let NSErrorMergePolicy: any;
  // export let NSErrorMergePolicy: any;
  // export let NSFetchRequestExpressionType: NSExpression.ExpressionType;
  // export let NSIgnorePersistentStoreVersioningOption: string;
  // export let NSInMemoryStoreType: string;
  // export let NSInferMappingModelAutomaticallyOption: string;
  // export let NSInsertedObjectsKey: string;
  // export let NSInvalidatedAllObjectsKey: string;
  // export let NSInvalidatedObjectsKey: string;
  // export let NSManagedObjectContextDidSaveNotification: string;
  // export let NSManagedObjectContextObjectsDidChangeNotification: string;
  // export let NSManagedObjectContextQueryGenerationKey: string;
  // export let NSManagedObjectContextWillSaveNotification: string;
  // export let NSMergeByPropertyObjectTrumpMergePolicy: any;
  // export let NSMergeByPropertyObjectTrumpMergePolicy: any;
  // export let NSMergeByPropertyStoreTrumpMergePolicy: any;
  // export let NSMergeByPropertyStoreTrumpMergePolicy: any;
  // export let NSMigratePersistentStoresAutomaticallyOption: string;
  // export let NSMigrationDestinationObjectKey: string;
  // export let NSMigrationEntityMappingKey: string;
  // export let NSMigrationEntityPolicyKey: string;
  // export let NSMigrationManagerKey: string;
  // export let NSMigrationPropertyMappingKey: string;
  // export let NSMigrationSourceObjectKey: string;
  // export let NSOverwriteMergePolicy: any;
  // export let NSOverwriteMergePolicy: any;
  // export let NSPersistentHistoryTokenKey: string;
  // export let NSPersistentHistoryTrackingKey: string;
  // export let NSPersistentStoreConnectionPoolMaxSizeKey: string;
  // export let NSPersistentStoreCoordinatorStoresDidChangeNotification: string;
  // export let NSPersistentStoreCoordinatorStoresWillChangeNotification: string;
  // export let NSPersistentStoreCoordinatorWillRemoveStoreNotification: string;
  // export let NSPersistentStoreForceDestroyOption: string;
  // export let NSPersistentStoreOSCompatibility: string;
  // export let NSPersistentStoreRemoteChangeNotification: string;
  // export let NSPersistentStoreRemoteChangeNotificationPostOptionKey: string;
  // export let NSPersistentStoreSaveConflictsErrorKey: string;
  // export let NSPersistentStoreTimeoutOption: string;
  // export let NSPersistentStoreURLKey: string;
  // export let NSReadOnlyPersistentStoreOption: string;
  // export let NSRefreshedObjectsKey: string;
  // export let NSRemovedPersistentStoresKey: string;
  // export let NSRollbackMergePolicy: any;
  // export let NSRollbackMergePolicy: any;
  // export let NSSQLiteAnalyzeOption: string;
  // export let NSSQLiteErrorDomain: string;
  // export let NSSQLiteManualVacuumOption: string;
  // export let NSSQLitePragmasOption: string;
  // export let NSSQLiteStoreType: string;
  // export let NSStoreModelVersionHashesKey: string;
  // export let NSStoreModelVersionIdentifiersKey: string;
  // export let NSStoreTypeKey: string;
  // export let NSStoreUUIDKey: string;
  // export let NSUUIDChangedPersistentStoresKey: string;
  // export let NSUpdatedObjectsKey: string;
  // export let NSValidateXMLStoreOption: string;
  // export let NSValidationKeyErrorKey: string;
  // export let NSValidationObjectErrorKey: string;
  // export let NSValidationPredicateErrorKey: string;
  // export let NSValidationValueErrorKey: string;
  // export let NSXMLStoreType: string;
  // export let kCFAbsoluteTimeIntervalSince1904: number;
  // export let kCFAbsoluteTimeIntervalSince1970: number;
  // export let kCFAllocatorDefault: any;
  // export let kCFAllocatorMalloc: any;
  // export let kCFAllocatorMallocZone: any;
  // export let kCFAllocatorNull: any;
  // export let kCFAllocatorSystemDefault: any;
  // export let kCFAllocatorUseContext: any;
  // export let kCFBooleanFalse: number;
  // export let kCFBooleanTrue: number;
  // export let kCFBundleDevelopmentRegionKey: string;
  // export let kCFBundleExecutableKey: string;
  // export let kCFBundleIdentifierKey: string;
  // export let kCFBundleInfoDictionaryVersionKey: string;
  // export let kCFBundleLocalizationsKey: string;
  // export let kCFBundleNameKey: string;
  // export let kCFBundleVersionKey: string;
  // export let kCFCopyStringBagCallBacks: CFBagCallBacks;
  // export let kCFCopyStringDictionaryKeyCallBacks: CFDictionaryKeyCallBacks;
  // export let kCFCopyStringSetCallBacks: CFSetCallBacks;
  // export let kCFCoreFoundationVersionNumber: number;
  // export let kCFErrorDescriptionKey: string;
  // export let kCFErrorDomainCocoa: any;
  // export let kCFErrorDomainMach: any;
  // export let kCFErrorDomainOSStatus: any;
  // export let kCFErrorDomainPOSIX: any;
  // export let kCFErrorFilePathKey: string;
  // export let kCFErrorLocalizedDescriptionKey: string;
  // export let kCFErrorLocalizedFailureKey: string;
  // export let kCFErrorLocalizedFailureReasonKey: string;
  // export let kCFErrorLocalizedRecoverySuggestionKey: string;
  // export let kCFErrorURLKey: string;
  // export let kCFErrorUnderlyingErrorKey: string;
  // export let kCFNotFound: number;
  // export let kCFNull: NSNull;
  // export let kCFNumberNaN: number;
  // export let kCFNumberNegativeInfinity: number;
  // export let kCFNumberPositiveInfinity: number;
  // export let kCFPlugInDynamicRegisterFunctionKey: string;
  // export let kCFPlugInDynamicRegistrationKey: string;
  // export let kCFPlugInFactoriesKey: string;
  // export let kCFPlugInTypesKey: string;
  // export let kCFPlugInUnloadFunctionKey: string;
  // export let kCFPreferencesAnyApplication: string;
  // export let kCFPreferencesAnyHost: string;
  // export let kCFPreferencesAnyUser: string;
  // export let kCFPreferencesCurrentApplication: string;
  // export let kCFPreferencesCurrentHost: string;
  // export let kCFPreferencesCurrentUser: string;
  // export let kCFSocketCommandKey: string;
  // export let kCFSocketErrorKey: string;
  // export let kCFSocketNameKey: string;
  // export let kCFSocketRegisterCommand: string;
  // export let kCFSocketResultKey: string;
  // export let kCFSocketRetrieveCommand: string;
  // export let kCFSocketValueKey: string;
  // export let kCFStreamErrorDomainSOCKS: number;
  // export let kCFStreamErrorDomainSSL: number;
  // export let kCFStreamPropertySOCKSPassword: string;
  // export let kCFStreamPropertySOCKSProxy: string;
  // export let kCFStreamPropertySOCKSProxyHost: string;
  // export let kCFStreamPropertySOCKSProxyPort: string;
  // export let kCFStreamPropertySOCKSUser: string;
  // export let kCFStreamPropertySOCKSVersion: string;
  // export let kCFStreamPropertyShouldCloseNativeSocket: string;
  // export let kCFStreamPropertySocketSecurityLevel: string;
  // export let kCFStreamSocketSOCKSVersion4: string;
  // export let kCFStreamSocketSOCKSVersion5: string;
  // export let kCFStreamSocketSecurityLevelNegotiatedSSL: string;
  // export let kCFStreamSocketSecurityLevelNone: string;
  // export let kCFStreamSocketSecurityLevelTLSv1: string;
  // export let kCFStringBinaryHeapCallBacks: CFBinaryHeapCallBacks;
  // export let kCFStringTransformFullwidthHalfwidth: string;
  // export let kCFStringTransformHiraganaKatakana: string;
  // export let kCFStringTransformLatinArabic: string;
  // export let kCFStringTransformLatinCyrillic: string;
  // export let kCFStringTransformLatinGreek: string;
  // export let kCFStringTransformLatinHangul: string;
  // export let kCFStringTransformLatinHebrew: string;
  // export let kCFStringTransformLatinHiragana: string;
  // export let kCFStringTransformLatinKatakana: string;
  // export let kCFStringTransformLatinThai: string;
  // export let kCFStringTransformMandarinLatin: string;
  // export let kCFStringTransformStripCombiningMarks: string;
  // export let kCFStringTransformStripDiacritics: string;
  // export let kCFStringTransformToLatin: string;
  // export let kCFStringTransformToUnicodeName: string;
  // export let kCFStringTransformToXMLHex: string;
  // export let kCFTypeArrayCallBacks: CFArrayCallBacks;
  // export let kCFTypeBagCallBacks: CFBagCallBacks;
  // export let kCFTypeDictionaryKeyCallBacks: CFDictionaryKeyCallBacks;
  // export let kCFTypeDictionaryValueCallBacks: CFDictionaryValueCallBacks;
  // export let kCFTypeSetCallBacks: CFSetCallBacks;
  // export let kCFURLAddedToDirectoryDateKey: string;
  // export let kCFURLApplicationIsScriptableKey: string;
  // export let kCFURLAttributeModificationDateKey: string;
  // export let kCFURLCanonicalPathKey: string;
  // export let kCFURLContentAccessDateKey: string;
  // export let kCFURLContentModificationDateKey: string;
  // export let kCFURLCreationDateKey: string;
  // export let kCFURLDocumentIdentifierKey: string;
  // export let kCFURLFileAllocatedSizeKey: string;
  // export let kCFURLFileResourceIdentifierKey: string;
  // export let kCFURLFileResourceTypeBlockSpecial: string;
  // export let kCFURLFileResourceTypeCharacterSpecial: string;
  // export let kCFURLFileResourceTypeDirectory: string;
  // export let kCFURLFileResourceTypeKey: string;
  // export let kCFURLFileResourceTypeNamedPipe: string;
  // export let kCFURLFileResourceTypeRegular: string;
  // export let kCFURLFileResourceTypeSocket: string;
  // export let kCFURLFileResourceTypeSymbolicLink: string;
  // export let kCFURLFileResourceTypeUnknown: string;
  // export let kCFURLFileSecurityKey: string;
  // export let kCFURLFileSizeKey: string;
  // export let kCFURLGenerationIdentifierKey: string;
  // export let kCFURLHasHiddenExtensionKey: string;
  // export let kCFURLIsAliasFileKey: string;
  // export let kCFURLIsApplicationKey: string;
  // export let kCFURLIsDirectoryKey: string;
  // export let kCFURLIsExcludedFromBackupKey: string;
  // export let kCFURLIsExecutableKey: string;
  // export let kCFURLIsHiddenKey: string;
  // export let kCFURLIsMountTriggerKey: string;
  // export let kCFURLIsPackageKey: string;
  // export let kCFURLIsReadableKey: string;
  // export let kCFURLIsRegularFileKey: string;
  // export let kCFURLIsSymbolicLinkKey: string;
  // export let kCFURLIsSystemImmutableKey: string;
  // export let kCFURLIsUbiquitousItemKey: string;
  // export let kCFURLIsUserImmutableKey: string;
  // export let kCFURLIsVolumeKey: string;
  // export let kCFURLIsWritableKey: string;
  // export let kCFURLKeysOfUnsetValuesKey: string;
  // export let kCFURLLabelNumberKey: string;
  // export let kCFURLLinkCountKey: string;
  // export let kCFURLLocalizedLabelKey: string;
  // export let kCFURLLocalizedNameKey: string;
  // export let kCFURLLocalizedTypeDescriptionKey: string;
  // export let kCFURLNameKey: string;
  // export let kCFURLParentDirectoryURLKey: string;
  // export let kCFURLPathKey: string;
  // export let kCFURLPreferredIOBlockSizeKey: string;
  // export let kCFURLQuarantinePropertiesKey: string;
  // export let kCFURLTagNamesKey: string;
  // export let kCFURLTotalFileAllocatedSizeKey: string;
  // export let kCFURLTotalFileSizeKey: string;
  // export let kCFURLTypeIdentifierKey: string;
  // export let kCFURLUbiquitousItemDownloadingErrorKey: string;
  // export let kCFURLUbiquitousItemDownloadingStatusCurrent: string;
  // export let kCFURLUbiquitousItemDownloadingStatusDownloaded: string;
  // export let kCFURLUbiquitousItemDownloadingStatusKey: string;
  // export let kCFURLUbiquitousItemDownloadingStatusNotDownloaded: string;
  // export let kCFURLUbiquitousItemHasUnresolvedConflictsKey: string;
  // export let kCFURLUbiquitousItemIsDownloadingKey: string;
  // export let kCFURLUbiquitousItemIsUploadedKey: string;
  // export let kCFURLUbiquitousItemIsUploadingKey: string;
  // export let kCFURLUbiquitousItemUploadingErrorKey: string;
  // export let kCFURLVolumeAvailableCapacityForImportantUsageKey: string;
  // export let kCFURLVolumeAvailableCapacityForOpportunisticUsageKey: string;
  // export let kCFURLVolumeAvailableCapacityKey: string;
  // export let kCFURLVolumeCreationDateKey: string;
  // export let kCFURLVolumeIdentifierKey: string;
  // export let kCFURLVolumeIsAutomountedKey: string;
  // export let kCFURLVolumeIsBrowsableKey: string;
  // export let kCFURLVolumeIsEjectableKey: string;
  // export let kCFURLVolumeIsEncryptedKey: string;
  // export let kCFURLVolumeIsInternalKey: string;
  // export let kCFURLVolumeIsJournalingKey: string;
  // export let kCFURLVolumeIsLocalKey: string;
  // export let kCFURLVolumeIsReadOnlyKey: string;
  // export let kCFURLVolumeIsRemovableKey: string;
  // export let kCFURLVolumeIsRootFileSystemKey: string;
  // export let kCFURLVolumeLocalizedFormatDescriptionKey: string;
  // export let kCFURLVolumeLocalizedNameKey: string;
  // export let kCFURLVolumeMaximumFileSizeKey: string;
  // export let kCFURLVolumeNameKey: string;
  // export let kCFURLVolumeResourceCountKey: string;
  // export let kCFURLVolumeSupportsAccessPermissionsKey: string;
  // export let kCFURLVolumeSupportsAdvisoryFileLockingKey: string;
  // export let kCFURLVolumeSupportsCasePreservedNamesKey: string;
  // export let kCFURLVolumeSupportsCaseSensitiveNamesKey: string;
  // export let kCFURLVolumeSupportsCompressionKey: string;
  // export let kCFURLVolumeSupportsExclusiveRenamingKey: string;
  // export let kCFURLVolumeSupportsExtendedSecurityKey: string;
  // export let kCFURLVolumeSupportsFileCloningKey: string;
  // export let kCFURLVolumeSupportsHardLinksKey: string;
  // export let kCFURLVolumeSupportsImmutableFilesKey: string;
  // export let kCFURLVolumeSupportsJournalingKey: string;
  // export let kCFURLVolumeSupportsPersistentIDsKey: string;
  // export let kCFURLVolumeSupportsRenamingKey: string;
  // export let kCFURLVolumeSupportsRootDirectoryDatesKey: string;
  // export let kCFURLVolumeSupportsSparseFilesKey: string;
  // export let kCFURLVolumeSupportsSwapRenamingKey: string;
  // export let kCFURLVolumeSupportsSymbolicLinksKey: string;
  // export let kCFURLVolumeSupportsVolumeSizesKey: string;
  // export let kCFURLVolumeSupportsZeroRunsKey: string;
  // export let kCFURLVolumeTotalCapacityKey: string;
  // export let kCFURLVolumeURLForRemountingKey: string;
  // export let kCFURLVolumeURLKey: string;
  // export let kCFURLVolumeUUIDStringKey: string;
  // export let kCFUserNotificationAlertHeaderKey: string;
  // export let kCFUserNotificationAlertMessageKey: string;
  // export let kCFUserNotificationAlertTopMostKey: string;
  // export let kCFUserNotificationAlternateButtonTitleKey: string;
  // export let kCFUserNotificationCheckBoxTitlesKey: string;
  // export let kCFUserNotificationDefaultButtonTitleKey: string;
  // export let kCFUserNotificationIconURLKey: string;
  // export let kCFUserNotificationKeyboardTypesKey: string;
  // export let kCFUserNotificationLocalizationURLKey: string;
  // export let kCFUserNotificationOtherButtonTitleKey: string;
  // export let kCFUserNotificationPopUpSelectionKey: string;
  // export let kCFUserNotificationPopUpTitlesKey: string;
  // export let kCFUserNotificationProgressIndicatorValueKey: string;
  // export let kCFUserNotificationSoundURLKey: string;
  // export let kCFUserNotificationTextFieldTitlesKey: string;
  // export let kCFUserNotificationTextFieldValuesKey: string;
  // export let kCFXMLTreeErrorDescription: string;
  // export let kCFXMLTreeErrorLineNumber: string;
  // export let kCFXMLTreeErrorLocation: string;
  // export let kCFXMLTreeErrorStatusCode: string;
  // export let kCGDisplayShowDuplicateLowResolutionModes: string;
  // export let kCGFontIndexInvalid: number;
  // export let kCGFontIndexMax: number;
  // export let kCGGlyphMax: number;
  // export let kCGPDFContextAccessPermissions: string;
  // export let kCGPDFContextAllowsCopying: string;
  // export let kCGPDFContextAllowsPrinting: string;
  // export let kCGPDFContextArtBox: string;
  // export let kCGPDFContextAuthor: string;
  // export let kCGPDFContextBleedBox: string;
  // export let kCGPDFContextCreator: string;
  // export let kCGPDFContextCropBox: string;
  // export let kCGPDFContextEncryptionKeyLength: string;
  // export let kCGPDFContextKeywords: string;
  // export let kCGPDFContextMediaBox: string;
  // export let kCGPDFContextOutputIntent: string;
  // export let kCGPDFContextOutputIntents: string;
  // export let kCGPDFContextOwnerPassword: string;
  // export let kCGPDFContextSubject: string;
  // export let kCGPDFContextTitle: string;
  // export let kCGPDFContextTrimBox: string;
  // export let kCGPDFContextUserPassword: string;
  // export let kCGPDFOutlineChildren: string;
  // export let kCGPDFOutlineDestination: string;
  // export let kCGPDFOutlineDestinationRect: string;
  // export let kCGPDFOutlineTitle: string;
  // export let kCGPDFXDestinationOutputProfile: string;
  // export let kCGPDFXInfo: string;
  // export let kCGPDFXOutputCondition: string;
  // export let kCGPDFXOutputConditionIdentifier: string;
  // export let kCGPDFXOutputIntentSubtype: string;
  // export let kCGPDFXRegistryName: string;
  // export let kCGWindowAlpha: string;
  // export let kCGWindowBackingLocationVideoMemory: string;
  // export let kCGWindowBounds: string;
  // export let kCGWindowIsOnscreen: string;
  // export let kCGWindowLayer: string;
  // export let kCGWindowMemoryUsage: string;
  // export let kCGWindowName: string;
  // export let kCGWindowNumber: string;
  // export let kCGWindowOwnerName: string;
  // export let kCGWindowOwnerPID: string;
  // export let kCGWindowSharingState: string;
  // export let kCGWindowStoreType: string;
  // export let CIDetectorAccuracy: string;
  // export let CIDetectorAccuracyHigh: string;
  // export let CIDetectorAccuracyLow: string;
  // export let CIDetectorAspectRatio: string;
  // export let CIDetectorEyeBlink: string;
  // export let CIDetectorFocalLength: string;
  // export let CIDetectorImageOrientation: string;
  // export let CIDetectorMaxFeatureCount: string;
  // export let CIDetectorMinFeatureSize: string;
  // export let CIDetectorNumberOfAngles: string;
  // export let CIDetectorReturnSubFeatures: string;
  // export let CIDetectorSmile: string;
  // export let CIDetectorTracking: string;
  // export let CIDetectorTypeFace: string;
  // export let CIDetectorTypeQRCode: string;
  // export let CIDetectorTypeRectangle: string;
  // export let CIDetectorTypeText: string;
  // export let CIFeatureTypeFace: string;
  // export let CIFeatureTypeQRCode: string;
  // export let CIFeatureTypeRectangle: string;
  // export let CIFeatureTypeText: string;
  // export let kCIApplyOptionColorSpace: string;
  // export let kCIApplyOptionDefinition: string;
  // export let kCIApplyOptionExtent: string;
  // export let kCIApplyOptionUserInfo: string;
  // export let kCIAttributeClass: string;
  // export let kCIAttributeDefault: string;
  // export let kCIAttributeDescription: string;
  // export let kCIAttributeDisplayName: string;
  // export let kCIAttributeFilterAvailable_Mac: string;
  // export let kCIAttributeFilterAvailable_iOS: string;
  // export let kCIAttributeFilterCategories: string;
  // export let kCIAttributeFilterDisplayName: string;
  // export let kCIAttributeFilterName: string;
  // export let kCIAttributeIdentity: string;
  // export let kCIAttributeMax: string;
  // export let kCIAttributeMin: string;
  // export let kCIAttributeName: string;
  // export let kCIAttributeReferenceDocumentation: string;
  // export let kCIAttributeSliderMax: string;
  // export let kCIAttributeSliderMin: string;
  // export let kCIAttributeType: string;
  // export let kCIAttributeTypeAngle: string;
  // export let kCIAttributeTypeBoolean: string;
  // export let kCIAttributeTypeColor: string;
  // export let kCIAttributeTypeCount: string;
  // export let kCIAttributeTypeDistance: string;
  // export let kCIAttributeTypeGradient: string;
  // export let kCIAttributeTypeImage: string;
  // export let kCIAttributeTypeInteger: string;
  // export let kCIAttributeTypeOffset: string;
  // export let kCIAttributeTypeOpaqueColor: string;
  // export let kCIAttributeTypePosition: string;
  // export let kCIAttributeTypePosition3: string;
  // export let kCIAttributeTypeRectangle: string;
  // export let kCIAttributeTypeScalar: string;
  // export let kCIAttributeTypeTime: string;
  // export let kCIAttributeTypeTransform: string;
  // export let kCICategoryBlur: string;
  // export let kCICategoryBuiltIn: string;
  // export let kCICategoryColorAdjustment: string;
  // export let kCICategoryColorEffect: string;
  // export let kCICategoryCompositeOperation: string;
  // export let kCICategoryDistortionEffect: string;
  // export let kCICategoryFilterGenerator: string;
  // export let kCICategoryGenerator: string;
  // export let kCICategoryGeometryAdjustment: string;
  // export let kCICategoryGradient: string;
  // export let kCICategoryHalftoneEffect: string;
  // export let kCICategoryHighDynamicRange: string;
  // export let kCICategoryInterlaced: string;
  // export let kCICategoryNonSquarePixels: string;
  // export let kCICategoryReduction: string;
  // export let kCICategorySharpen: string;
  // export let kCICategoryStillImage: string;
  // export let kCICategoryStylize: string;
  // export let kCICategoryTileEffect: string;
  // export let kCICategoryTransition: string;
  // export let kCICategoryVideo: string;
  // export let kCIFilterGeneratorExportedKey: string;
  // export let kCIFilterGeneratorExportedKeyName: string;
  // export let kCIFilterGeneratorExportedKeyTargetObject: string;
  // export let kCIInputAmountKey: string;
  // export let kCIInputAngleKey: string;
  // export let kCIInputAspectRatioKey: string;
  // export let kCIInputBackgroundImageKey: string;
  // export let kCIInputBiasKey: string;
  // export let kCIInputBrightnessKey: string;
  // export let kCIInputCenterKey: string;
  // export let kCIInputColorKey: string;
  // export let kCIInputContrastKey: string;
  // export let kCIInputDepthImageKey: string;
  // export let kCIInputDisparityImageKey: string;
  // export let kCIInputEVKey: string;
  // export let kCIInputEnableEDRModeKey: string;
  // export let kCIInputExtentKey: string;
  // export let kCIInputGradientImageKey: string;
  // export let kCIInputImageKey: string;
  // export let kCIInputIntensityKey: string;
  // export let kCIInputMaskImageKey: string;
  // export let kCIInputMatteImageKey: string;
  // export let kCIInputRadiusKey: string;
  // export let kCIInputRefractionKey: string;
  // export let kCIInputSaturationKey: string;
  // export let kCIInputScaleKey: string;
  // export let kCIInputShadingImageKey: string;
  // export let kCIInputSharpnessKey: string;
  // export let kCIInputTargetImageKey: string;
  // export let kCIInputTimeKey: string;
  // export let kCIInputTransformKey: string;
  // export let kCIInputVersionKey: string;
  // export let kCIInputWeightsKey: string;
  // export let kCIInputWidthKey: string;
  // export let kCIOutputImageKey: string;
  // export let kCISamplerAffineMatrix: string;
  // export let kCISamplerColorSpace: string;
  // export let kCISamplerFilterLinear: string;
  // export let kCISamplerFilterMode: string;
  // export let kCISamplerFilterNearest: string;
  // export let kCISamplerWrapBlack: string;
  // export let kCISamplerWrapClamp: string;
  // export let kCISamplerWrapMode: string;
  // export let kCIUIParameterSet: string;
  // export let kCIUISetAdvanced: string;
  // export let kCIUISetBasic: string;
  // export let kCIUISetDevelopment: string;
  // export let kCIUISetIntermediate: string;
  // export let kCMFormatDescriptionAlphaChannelMode_PremultipliedAlpha: string;
  // export let kCMFormatDescriptionAlphaChannelMode_StraightAlpha: string;
  // export let kCMFormatDescriptionChromaLocation_Bottom: string;
  // export let kCMFormatDescriptionChromaLocation_BottomLeft: string;
  // export let kCMFormatDescriptionChromaLocation_Center: string;
  // export let kCMFormatDescriptionChromaLocation_DV420: string;
  // export let kCMFormatDescriptionChromaLocation_Left: string;
  // export let kCMFormatDescriptionChromaLocation_Top: string;
  // export let kCMFormatDescriptionChromaLocation_TopLeft: string;
  // export let kCMFormatDescriptionColorPrimaries_DCI_P3: string;
  // export let kCMFormatDescriptionColorPrimaries_EBU_3213: string;
  // export let kCMFormatDescriptionColorPrimaries_ITU_R_2020: string;
  // export let kCMFormatDescriptionColorPrimaries_ITU_R_709_2: string;
  // export let kCMFormatDescriptionColorPrimaries_P22: string;
  // export let kCMFormatDescriptionColorPrimaries_P3_D65: string;
  // export let kCMFormatDescriptionColorPrimaries_SMPTE_C: string;
  // export let kCMFormatDescriptionConformsToMPEG2VideoProfile: string;
  // export let kCMFormatDescriptionExtensionKey_MetadataKeyTable: string;
  // export let kCMFormatDescriptionExtension_AlphaChannelMode: string;
  // export let kCMFormatDescriptionExtension_AlternativeTransferCharacteristics: string;
  // export let kCMFormatDescriptionExtension_AuxiliaryTypeInfo: string;
  // export let kCMFormatDescriptionExtension_BytesPerRow: string;
  // export let kCMFormatDescriptionExtension_ChromaLocationBottomField: string;
  // export let kCMFormatDescriptionExtension_ChromaLocationTopField: string;
  // export let kCMFormatDescriptionExtension_CleanAperture: string;
  // export let kCMFormatDescriptionExtension_ColorPrimaries: string;
  // export let kCMFormatDescriptionExtension_ContainsAlphaChannel: string;
  // export let kCMFormatDescriptionExtension_ContentLightLevelInfo: string;
  // export let kCMFormatDescriptionExtension_Depth: string;
  // export let kCMFormatDescriptionExtension_FieldCount: string;
  // export let kCMFormatDescriptionExtension_FieldDetail: string;
  // export let kCMFormatDescriptionExtension_FormatName: string;
  // export let kCMFormatDescriptionExtension_FullRangeVideo: string;
  // export let kCMFormatDescriptionExtension_GammaLevel: string;
  // export let kCMFormatDescriptionExtension_ICCProfile: string;
  // export let kCMFormatDescriptionExtension_MasteringDisplayColorVolume: string;
  // export let kCMFormatDescriptionExtension_OriginalCompressionSettings: string;
  // export let kCMFormatDescriptionExtension_PixelAspectRatio: string;
  // export let kCMFormatDescriptionExtension_RevisionLevel: string;
  // export let kCMFormatDescriptionExtension_SampleDescriptionExtensionAtoms: string;
  // export let kCMFormatDescriptionExtension_SpatialQuality: string;
  // export let kCMFormatDescriptionExtension_TemporalQuality: string;
  // export let kCMFormatDescriptionExtension_TransferFunction: string;
  // export let kCMFormatDescriptionExtension_Vendor: string;
  // export let kCMFormatDescriptionExtension_VerbatimISOSampleEntry: string;
  // export let kCMFormatDescriptionExtension_VerbatimImageDescription: string;
  // export let kCMFormatDescriptionExtension_VerbatimSampleDescription: string;
  // export let kCMFormatDescriptionExtension_Version: string;
  // export let kCMFormatDescriptionExtension_YCbCrMatrix: string;
  // export let kCMFormatDescriptionFieldDetail_SpatialFirstLineEarly: string;
  // export let kCMFormatDescriptionFieldDetail_SpatialFirstLineLate: string;
  // export let kCMFormatDescriptionFieldDetail_TemporalBottomFirst: string;
  // export let kCMFormatDescriptionFieldDetail_TemporalTopFirst: string;
  // export let kCMFormatDescriptionKey_CleanApertureHeight: string;
  // export let kCMFormatDescriptionKey_CleanApertureHeightRational: string;
  // export let kCMFormatDescriptionKey_CleanApertureHorizontalOffset: string;
  // export let kCMFormatDescriptionKey_CleanApertureHorizontalOffsetRational: string;
  // export let kCMFormatDescriptionKey_CleanApertureVerticalOffset: string;
  // export let kCMFormatDescriptionKey_CleanApertureVerticalOffsetRational: string;
  // export let kCMFormatDescriptionKey_CleanApertureWidth: string;
  // export let kCMFormatDescriptionKey_CleanApertureWidthRational: string;
  // export let kCMFormatDescriptionKey_PixelAspectRatioHorizontalSpacing: string;
  // export let kCMFormatDescriptionKey_PixelAspectRatioVerticalSpacing: string;
  // export let kCMFormatDescriptionTransferFunction_ITU_R_2020: string;
  // export let kCMFormatDescriptionTransferFunction_ITU_R_2100_HLG: string;
  // export let kCMFormatDescriptionTransferFunction_ITU_R_709_2: string;
  // export let kCMFormatDescriptionTransferFunction_Linear: string;
  // export let kCMFormatDescriptionTransferFunction_SMPTE_240M_1995: string;
  // export let kCMFormatDescriptionTransferFunction_SMPTE_ST_2084_PQ: string;
  // export let kCMFormatDescriptionTransferFunction_SMPTE_ST_428_1: string;
  // export let kCMFormatDescriptionTransferFunction_UseGamma: string;
  // export let kCMFormatDescriptionTransferFunction_sRGB: string;
  // export let kCMFormatDescriptionVendor_Apple: string;
  // export let kCMFormatDescriptionYCbCrMatrix_ITU_R_2020: string;
  // export let kCMFormatDescriptionYCbCrMatrix_ITU_R_601_4: string;
  // export let kCMFormatDescriptionYCbCrMatrix_ITU_R_709_2: string;
  // export let kCMFormatDescriptionYCbCrMatrix_SMPTE_240M_1995: string;
  // export let kCMHEVCTemporalLevelInfoKey_ConstraintIndicatorFlags: string;
  // export let kCMHEVCTemporalLevelInfoKey_LevelIndex: string;
  // export let kCMHEVCTemporalLevelInfoKey_ProfileCompatibilityFlags: string;
  // export let kCMHEVCTemporalLevelInfoKey_ProfileIndex: string;
  // export let kCMHEVCTemporalLevelInfoKey_ProfileSpace: string;
  // export let kCMHEVCTemporalLevelInfoKey_TemporalLevel: string;
  // export let kCMHEVCTemporalLevelInfoKey_TierFlag: string;
  // export let kCMMemoryPoolOption_AgeOutPeriod: string;
  // export let kCMMetadataBaseDataType_AffineTransformF64: string;
  // export let kCMMetadataBaseDataType_BMP: string;
  // export let kCMMetadataBaseDataType_DimensionsF32: string;
  // export let kCMMetadataBaseDataType_Float32: string;
  // export let kCMMetadataBaseDataType_Float64: string;
  // export let kCMMetadataBaseDataType_GIF: string;
  // export let kCMMetadataBaseDataType_JPEG: string;
  // export let kCMMetadataBaseDataType_JSON: string;
  // export let kCMMetadataBaseDataType_PNG: string;
  // export let kCMMetadataBaseDataType_PerspectiveTransformF64: string;
  // export let kCMMetadataBaseDataType_PointF32: string;
  // export let kCMMetadataBaseDataType_PolygonF32: string;
  // export let kCMMetadataBaseDataType_PolylineF32: string;
  // export let kCMMetadataBaseDataType_RawData: string;
  // export let kCMMetadataBaseDataType_RectF32: string;
  // export let kCMMetadataBaseDataType_SInt16: string;
  // export let kCMMetadataBaseDataType_SInt32: string;
  // export let kCMMetadataBaseDataType_SInt64: string;
  // export let kCMMetadataBaseDataType_SInt8: string;
  // export let kCMMetadataBaseDataType_UInt16: string;
  // export let kCMMetadataBaseDataType_UInt32: string;
  // export let kCMMetadataBaseDataType_UInt64: string;
  // export let kCMMetadataBaseDataType_UInt8: string;
  // export let kCMMetadataBaseDataType_UTF16: string;
  // export let kCMMetadataBaseDataType_UTF8: string;
  // export let kCMMetadataDataType_QuickTimeMetadataDirection: string;
  // export let kCMMetadataDataType_QuickTimeMetadataLocation_ISO6709: string;
  // export let kCMMetadataFormatDescriptionKey_ConformingDataTypes: string;
  // export let kCMMetadataFormatDescriptionKey_DataType: string;
  // export let kCMMetadataFormatDescriptionKey_DataTypeNamespace: string;
  // export let kCMMetadataFormatDescriptionKey_LanguageTag: string;
  // export let kCMMetadataFormatDescriptionKey_LocalID: string;
  // export let kCMMetadataFormatDescriptionKey_Namespace: string;
  // export let kCMMetadataFormatDescriptionKey_SetupData: string;
  // export let kCMMetadataFormatDescriptionKey_StructuralDependency: string;
  // export let kCMMetadataFormatDescriptionKey_Value: string;
  // export let kCMMetadataFormatDescriptionMetadataSpecificationKey_DataType: string;
  // export let kCMMetadataFormatDescriptionMetadataSpecificationKey_ExtendedLanguageTag: string;
  // export let kCMMetadataFormatDescriptionMetadataSpecificationKey_Identifier: string;
  // export let kCMMetadataFormatDescriptionMetadataSpecificationKey_SetupData: string;
  // export let kCMMetadataFormatDescriptionMetadataSpecificationKey_StructuralDependency: string;
  // export let kCMMetadataFormatDescription_StructuralDependencyKey_DependencyIsInvalidFlag: string;
  // export let kCMMetadataIdentifier_QuickTimeMetadataDirection_Facing: string;
  // export let kCMMetadataIdentifier_QuickTimeMetadataLivePhotoStillImageTransform: string;
  // export let kCMMetadataIdentifier_QuickTimeMetadataLivePhotoStillImageTransformReferenceDimensions: string;
  // export let kCMMetadataIdentifier_QuickTimeMetadataLocation_ISO6709: string;
  // export let kCMMetadataIdentifier_QuickTimeMetadataPreferredAffineTransform: string;
  // export let kCMMetadataIdentifier_QuickTimeMetadataVideoOrientation: string;
  // export let kCMMetadataKeySpace_HLSDateRange: string;
  // export let kCMMetadataKeySpace_ID3: string;
  // export let kCMMetadataKeySpace_ISOUserData: string;
  // export let kCMMetadataKeySpace_Icy: string;
  // export let kCMMetadataKeySpace_QuickTimeMetadata: string;
  // export let kCMMetadataKeySpace_QuickTimeUserData: string;
  // export let kCMMetadataKeySpace_iTunes: string;
  // export let kCMSampleAttachmentKey_AudioIndependentSampleDecoderRefreshCount: string;
  // export let kCMSampleAttachmentKey_DependsOnOthers: string;
  // export let kCMSampleAttachmentKey_DisplayImmediately: string;
  // export let kCMSampleAttachmentKey_DoNotDisplay: string;
  // export let kCMSampleAttachmentKey_EarlierDisplayTimesAllowed: string;
  // export let kCMSampleAttachmentKey_HEVCStepwiseTemporalSubLayerAccess: string;
  // export let kCMSampleAttachmentKey_HEVCSyncSampleNALUnitType: string;
  // export let kCMSampleAttachmentKey_HEVCTemporalLevelInfo: string;
  // export let kCMSampleAttachmentKey_HEVCTemporalSubLayerAccess: string;
  // export let kCMSampleAttachmentKey_HasRedundantCoding: string;
  // export let kCMSampleAttachmentKey_IsDependedOnByOthers: string;
  // export let kCMSampleAttachmentKey_NotSync: string;
  // export let kCMSampleAttachmentKey_PartialSync: string;
  // export let kCMSampleBufferAttachmentKey_CameraIntrinsicMatrix: string;
  // export let kCMSampleBufferAttachmentKey_DisplayEmptyMediaImmediately: string;
  // export let kCMSampleBufferAttachmentKey_DrainAfterDecoding: string;
  // export let kCMSampleBufferAttachmentKey_DroppedFrameReason: string;
  // export let kCMSampleBufferAttachmentKey_DroppedFrameReasonInfo: string;
  // export let kCMSampleBufferAttachmentKey_EmptyMedia: string;
  // export let kCMSampleBufferAttachmentKey_EndsPreviousSampleDuration: string;
  // export let kCMSampleBufferAttachmentKey_FillDiscontinuitiesWithSilence: string;
  // export let kCMSampleBufferAttachmentKey_ForceKeyFrame: string;
  // export let kCMSampleBufferAttachmentKey_GradualDecoderRefresh: string;
  // export let kCMSampleBufferAttachmentKey_PermanentEmptyMedia: string;
  // export let kCMSampleBufferAttachmentKey_PostNotificationWhenConsumed: string;
  // export let kCMSampleBufferAttachmentKey_ResetDecoderBeforeDecoding: string;
  // export let kCMSampleBufferAttachmentKey_ResumeOutput: string;
  // export let kCMSampleBufferAttachmentKey_Reverse: string;
  // export let kCMSampleBufferAttachmentKey_SampleReferenceByteOffset: string;
  // export let kCMSampleBufferAttachmentKey_SampleReferenceURL: string;
  // export let kCMSampleBufferAttachmentKey_SpeedMultiplier: string;
  // export let kCMSampleBufferAttachmentKey_StillImageLensStabilizationInfo: string;
  // export let kCMSampleBufferAttachmentKey_TransitionID: string;
  // export let kCMSampleBufferAttachmentKey_TrimDurationAtEnd: string;
  // export let kCMSampleBufferAttachmentKey_TrimDurationAtStart: string;
  // export let kCMSampleBufferConduitNotificationParameter_MaxUpcomingOutputPTS: string;
  // export let kCMSampleBufferConduitNotificationParameter_MinUpcomingOutputPTS: string;
  // export let kCMSampleBufferConduitNotificationParameter_ResumeTag: string;
  // export let kCMSampleBufferConduitNotificationParameter_UpcomingOutputPTSRangeMayOverlapQueuedOutputPTSRange: string;
  // export let kCMSampleBufferConduitNotification_InhibitOutputUntil: string;
  // export let kCMSampleBufferConduitNotification_ResetOutput: string;
  // export let kCMSampleBufferConduitNotification_UpcomingOutputPTSRangeChanged: string;
  // export let kCMSampleBufferConsumerNotification_BufferConsumed: string;
  // export let kCMSampleBufferDroppedFrameReasonInfo_CameraModeSwitch: string;
  // export let kCMSampleBufferDroppedFrameReason_Discontinuity: string;
  // export let kCMSampleBufferDroppedFrameReason_FrameWasLate: string;
  // export let kCMSampleBufferDroppedFrameReason_OutOfBuffers: string;
  // export let kCMSampleBufferLensStabilizationInfo_Active: string;
  // export let kCMSampleBufferLensStabilizationInfo_Off: string;
  // export let kCMSampleBufferLensStabilizationInfo_OutOfRange: string;
  // export let kCMSampleBufferLensStabilizationInfo_Unavailable: string;
  // export let kCMSampleBufferNotificationParameter_OSStatus: string;
  // export let kCMSampleBufferNotification_DataBecameReady: string;
  // export let kCMSampleBufferNotification_DataFailed: string;
  // export let kCMTextFormatDescriptionColor_Alpha: string;
  // export let kCMTextFormatDescriptionColor_Blue: string;
  // export let kCMTextFormatDescriptionColor_Green: string;
  // export let kCMTextFormatDescriptionColor_Red: string;
  // export let kCMTextFormatDescriptionExtension_BackgroundColor: string;
  // export let kCMTextFormatDescriptionExtension_DefaultFontName: string;
  // export let kCMTextFormatDescriptionExtension_DefaultStyle: string;
  // export let kCMTextFormatDescriptionExtension_DefaultTextBox: string;
  // export let kCMTextFormatDescriptionExtension_DisplayFlags: string;
  // export let kCMTextFormatDescriptionExtension_FontTable: string;
  // export let kCMTextFormatDescriptionExtension_HorizontalJustification: string;
  // export let kCMTextFormatDescriptionExtension_TextJustification: string;
  // export let kCMTextFormatDescriptionExtension_VerticalJustification: string;
  // export let kCMTextFormatDescriptionRect_Bottom: string;
  // export let kCMTextFormatDescriptionRect_Left: string;
  // export let kCMTextFormatDescriptionRect_Right: string;
  // export let kCMTextFormatDescriptionRect_Top: string;
  // export let kCMTextFormatDescriptionStyle_Ascent: string;
  // export let kCMTextFormatDescriptionStyle_EndChar: string;
  // export let kCMTextFormatDescriptionStyle_Font: string;
  // export let kCMTextFormatDescriptionStyle_FontFace: string;
  // export let kCMTextFormatDescriptionStyle_FontSize: string;
  // export let kCMTextFormatDescriptionStyle_ForegroundColor: string;
  // export let kCMTextFormatDescriptionStyle_Height: string;
  // export let kCMTextFormatDescriptionStyle_StartChar: string;
  // export let kCMTextMarkupAlignmentType_End: string;
  // export let kCMTextMarkupAlignmentType_Left: string;
  // export let kCMTextMarkupAlignmentType_Middle: string;
  // export let kCMTextMarkupAlignmentType_Right: string;
  // export let kCMTextMarkupAlignmentType_Start: string;
  // export let kCMTextMarkupAttribute_Alignment: string;
  // export let kCMTextMarkupAttribute_BackgroundColorARGB: string;
  // export let kCMTextMarkupAttribute_BaseFontSizePercentageRelativeToVideoHeight: string;
  // export let kCMTextMarkupAttribute_BoldStyle: string;
  // export let kCMTextMarkupAttribute_CharacterBackgroundColorARGB: string;
  // export let kCMTextMarkupAttribute_CharacterEdgeStyle: string;
  // export let kCMTextMarkupAttribute_FontFamilyName: string;
  // export let kCMTextMarkupAttribute_ForegroundColorARGB: string;
  // export let kCMTextMarkupAttribute_GenericFontFamilyName: string;
  // export let kCMTextMarkupAttribute_ItalicStyle: string;
  // export let kCMTextMarkupAttribute_OrthogonalLinePositionPercentageRelativeToWritingDirection: string;
  // export let kCMTextMarkupAttribute_RelativeFontSize: string;
  // export let kCMTextMarkupAttribute_TextPositionPercentageRelativeToWritingDirection: string;
  // export let kCMTextMarkupAttribute_UnderlineStyle: string;
  // export let kCMTextMarkupAttribute_VerticalLayout: string;
  // export let kCMTextMarkupAttribute_WritingDirectionSizePercentage: string;
  // export let kCMTextMarkupCharacterEdgeStyle_Depressed: string;
  // export let kCMTextMarkupCharacterEdgeStyle_DropShadow: string;
  // export let kCMTextMarkupCharacterEdgeStyle_None: string;
  // export let kCMTextMarkupCharacterEdgeStyle_Raised: string;
  // export let kCMTextMarkupCharacterEdgeStyle_Uniform: string;
  // export let kCMTextMarkupGenericFontName_Casual: string;
  // export let kCMTextMarkupGenericFontName_Cursive: string;
  // export let kCMTextMarkupGenericFontName_Default: string;
  // export let kCMTextMarkupGenericFontName_Fantasy: string;
  // export let kCMTextMarkupGenericFontName_Monospace: string;
  // export let kCMTextMarkupGenericFontName_MonospaceSansSerif: string;
  // export let kCMTextMarkupGenericFontName_MonospaceSerif: string;
  // export let kCMTextMarkupGenericFontName_ProportionalSansSerif: string;
  // export let kCMTextMarkupGenericFontName_ProportionalSerif: string;
  // export let kCMTextMarkupGenericFontName_SansSerif: string;
  // export let kCMTextMarkupGenericFontName_Serif: string;
  // export let kCMTextMarkupGenericFontName_SmallCapital: string;
  // export let kCMTextVerticalLayout_LeftToRight: string;
  // export let kCMTextVerticalLayout_RightToLeft: string;
  // export let kCMTimeCodeFormatDescriptionExtension_SourceReferenceName: string;
  // export let kCMTimeCodeFormatDescriptionKey_LangCode: string;
  // export let kCMTimeCodeFormatDescriptionKey_Value: string;
  // export let kCMTimeEpochKey: string;
  // export let kCMTimeFlagsKey: string;
  // export let kCMTimeMappingSourceKey: string;
  // export let kCMTimeMappingTargetKey: string;
  // export let kCMTimeRangeDurationKey: string;
  // export let kCMTimeRangeStartKey: string;
  // export let kCMTimeScaleKey: string;
  // export let kCMTimeValueKey: string;
  // export let kCMTimebaseNotificationKey_EventTime: string;
  // export let kCMTimebaseNotification_EffectiveRateChanged: string;
  // export let kCMTimebaseNotification_TimeJumped: string;
  // export let kCMIOBlockBufferAttachmentKey_CVPixelBufferReference: string;
  // export let kCMIOSampleBufferAttachmentKey_CAAudioTimeStamp: string;
  // export let kCMIOSampleBufferAttachmentKey_ClientSequenceID: string;
  // export let kCMIOSampleBufferAttachmentKey_ClosedCaptionSampleBuffer: string;
  // export let kCMIOSampleBufferAttachmentKey_DiscontinuityFlags: string;
  // export let kCMIOSampleBufferAttachmentKey_HDV1_PackData: string;
  // export let kCMIOSampleBufferAttachmentKey_HDV2_VAUX: string;
  // export let kCMIOSampleBufferAttachmentKey_HostTime: string;
  // export let kCMIOSampleBufferAttachmentKey_MouseAndKeyboardModifiers: string;
  // export let kCMIOSampleBufferAttachmentKey_MuxedSourcePresentationTimeStamp: string;
  // export let kCMIOSampleBufferAttachmentKey_NativeSMPTEFrameCount: string;
  // export let kCMIOSampleBufferAttachmentKey_NoDataMarker: string;
  // export let kCMIOSampleBufferAttachmentKey_NumberOfVideoFramesInBuffer: string;
  // export let kCMIOSampleBufferAttachmentKey_NumberOfVideoFramesInGOP: string;
  // export let kCMIOSampleBufferAttachmentKey_PulldownCadenceInfo: string;
  // export let kCMIOSampleBufferAttachmentKey_RepeatedBufferContents: string;
  // export let kCMIOSampleBufferAttachmentKey_SMPTETime: string;
  // export let kCMIOSampleBufferAttachmentKey_SequenceNumber: string;
  // export let kCMIOSampleBufferAttachmentKey_SourceAudioFormatDescription: string;
  // export let kCMIOSampleBufferAttachment_MouseAndKeyboardModifiersKey_CursorFrameRect: string;
  // export let kCMIOSampleBufferAttachment_MouseAndKeyboardModifiersKey_CursorIsDrawnInFramebuffer: string;
  // export let kCMIOSampleBufferAttachment_MouseAndKeyboardModifiersKey_CursorIsVisible: string;
  // export let kCMIOSampleBufferAttachment_MouseAndKeyboardModifiersKey_CursorPositionX: string;
  // export let kCMIOSampleBufferAttachment_MouseAndKeyboardModifiersKey_CursorPositionY: string;
  // export let kCMIOSampleBufferAttachment_MouseAndKeyboardModifiersKey_CursorReference: string;
  // export let kCMIOSampleBufferAttachment_MouseAndKeyboardModifiersKey_CursorScale: string;
  // export let kCMIOSampleBufferAttachment_MouseAndKeyboardModifiersKey_CursorSeed: string;
  // export let kCMIOSampleBufferAttachment_MouseAndKeyboardModifiersKey_KeyboardModifiers: string;
  // export let kCMIOSampleBufferAttachment_MouseAndKeyboardModifiersKey_KeyboardModifiersEvent: string;
  // export let kCMIOSampleBufferAttachment_MouseAndKeyboardModifiersKey_MouseButtonState: string;
  // export let NSAppleEventTimeOutDefault: number;
  // export let NSAppleEventTimeOutNone: number;
  // export let NSAssertionHandlerKey: string;
  // export let NSCocoaErrorDomain: string;
  // export let NSDeallocateZombies: boolean;
  // export let NSDebugDescriptionErrorKey: string;
  // export let NSDebugEnabled: boolean;
  // export let NSEdgeInsetsZero: NSEdgeInsets;
  // export let NSExtensionItemAttachmentsKey: string;
  // export let NSExtensionItemAttributedContentTextKey: string;
  // export let NSExtensionItemAttributedTitleKey: string;
  // export let NSExtensionItemsAndErrorsKey: string;
  // export let NSExtensionJavaScriptPreprocessingResultsKey: string;
  // export let NSFileHandleNotificationDataItem: string;
  // export let NSFileHandleNotificationFileHandleItem: string;
  // export let NSFileManagerUnmountDissentingProcessIdentifierErrorKey: string;
  // export let NSFilePathErrorKey: string;
  // export let NSFoundationVersionNumber: number;
  // export let NSGrammarCorrections: string;
  // export let NSGrammarRange: string;
  // export let NSGrammarUserDescription: string;
  // export let NSHashTableCopyIn: NSPointerFunctions.Options;
  // export let NSHashTableObjectPointerPersonality: NSPointerFunctions.Options;
  // export let NSHashTableStrongMemory: NSPointerFunctions.Options;
  // export let NSHashTableWeakMemory: NSPointerFunctions.Options;
  // export let NSHelpAnchorErrorKey: string;
  // export let NSIntegerHashCallBacks: NSHashTableCallBacks;
  // export let NSIntegerMapKeyCallBacks: NSMapTableKeyCallBacks;
  // export let NSIntegerMapValueCallBacks: NSMapTableValueCallBacks;
  // export let NSItemProviderPreferredImageSizeKey: string;
  // export let NSKeepAllocationStatistics: boolean;
  // export let NSKeyedArchiveRootObjectKey: string;
  // export let NSLoadedClasses: string;
  // export let NSLocalizedDescriptionKey: string;
  // export let NSLocalizedFailureErrorKey: string;
  // export let NSLocalizedFailureReasonErrorKey: string;
  // export let NSLocalizedRecoveryOptionsErrorKey: string;
  // export let NSLocalizedRecoverySuggestionErrorKey: string;
  // export let NSMachErrorDomain: string;
  // export let NSMapTableCopyIn: NSPointerFunctions.Options;
  // export let NSMapTableObjectPointerPersonality: NSPointerFunctions.Options;
  // export let NSMapTableStrongMemory: NSPointerFunctions.Options;
  // export let NSMapTableWeakMemory: NSPointerFunctions.Options;
  // export let NSMetadataItemAcquisitionMakeKey: string;
  // export let NSMetadataItemAcquisitionModelKey: string;
  // export let NSMetadataItemAlbumKey: string;
  // export let NSMetadataItemAltitudeKey: string;
  // export let NSMetadataItemApertureKey: string;
  // export let NSMetadataItemAppleLoopDescriptorsKey: string;
  // export let NSMetadataItemAppleLoopsKeyFilterTypeKey: string;
  // export let NSMetadataItemAppleLoopsLoopModeKey: string;
  // export let NSMetadataItemAppleLoopsRootKeyKey: string;
  // export let NSMetadataItemApplicationCategoriesKey: string;
  // export let NSMetadataItemAttributeChangeDateKey: string;
  // export let NSMetadataItemAudiencesKey: string;
  // export let NSMetadataItemAudioBitRateKey: string;
  // export let NSMetadataItemAudioChannelCountKey: string;
  // export let NSMetadataItemAudioEncodingApplicationKey: string;
  // export let NSMetadataItemAudioSampleRateKey: string;
  // export let NSMetadataItemAudioTrackNumberKey: string;
  // export let NSMetadataItemAuthorAddressesKey: string;
  // export let NSMetadataItemAuthorEmailAddressesKey: string;
  // export let NSMetadataItemAuthorsKey: string;
  // export let NSMetadataItemBitsPerSampleKey: string;
  // export let NSMetadataItemCFBundleIdentifierKey: string;
  // export let NSMetadataItemCameraOwnerKey: string;
  // export let NSMetadataItemCityKey: string;
  // export let NSMetadataItemCodecsKey: string;
  // export let NSMetadataItemColorSpaceKey: string;
  // export let NSMetadataItemCommentKey: string;
  // export let NSMetadataItemComposerKey: string;
  // export let NSMetadataItemContactKeywordsKey: string;
  // export let NSMetadataItemContentCreationDateKey: string;
  // export let NSMetadataItemContentModificationDateKey: string;
  // export let NSMetadataItemContentTypeKey: string;
  // export let NSMetadataItemContentTypeTreeKey: string;
  // export let NSMetadataItemContributorsKey: string;
  // export let NSMetadataItemCopyrightKey: string;
  // export let NSMetadataItemCountryKey: string;
  // export let NSMetadataItemCoverageKey: string;
  // export let NSMetadataItemCreatorKey: string;
  // export let NSMetadataItemDateAddedKey: string;
  // export let NSMetadataItemDeliveryTypeKey: string;
  // export let NSMetadataItemDescriptionKey: string;
  // export let NSMetadataItemDirectorKey: string;
  // export let NSMetadataItemDisplayNameKey: string;
  // export let NSMetadataItemDownloadedDateKey: string;
  // export let NSMetadataItemDueDateKey: string;
  // export let NSMetadataItemDurationSecondsKey: string;
  // export let NSMetadataItemEXIFGPSVersionKey: string;
  // export let NSMetadataItemEXIFVersionKey: string;
  // export let NSMetadataItemEditorsKey: string;
  // export let NSMetadataItemEmailAddressesKey: string;
  // export let NSMetadataItemEncodingApplicationsKey: string;
  // export let NSMetadataItemExecutableArchitecturesKey: string;
  // export let NSMetadataItemExecutablePlatformKey: string;
  // export let NSMetadataItemExposureModeKey: string;
  // export let NSMetadataItemExposureProgramKey: string;
  // export let NSMetadataItemExposureTimeSecondsKey: string;
  // export let NSMetadataItemExposureTimeStringKey: string;
  // export let NSMetadataItemFNumberKey: string;
  // export let NSMetadataItemFSContentChangeDateKey: string;
  // export let NSMetadataItemFSCreationDateKey: string;
  // export let NSMetadataItemFSNameKey: string;
  // export let NSMetadataItemFSSizeKey: string;
  // export let NSMetadataItemFinderCommentKey: string;
  // export let NSMetadataItemFlashOnOffKey: string;
  // export let NSMetadataItemFocalLength35mmKey: string;
  // export let NSMetadataItemFocalLengthKey: string;
  // export let NSMetadataItemFontsKey: string;
  // export let NSMetadataItemGPSAreaInformationKey: string;
  // export let NSMetadataItemGPSDOPKey: string;
  // export let NSMetadataItemGPSDateStampKey: string;
  // export let NSMetadataItemGPSDestBearingKey: string;
  // export let NSMetadataItemGPSDestDistanceKey: string;
  // export let NSMetadataItemGPSDestLatitudeKey: string;
  // export let NSMetadataItemGPSDestLongitudeKey: string;
  // export let NSMetadataItemGPSDifferentalKey: string;
  // export let NSMetadataItemGPSMapDatumKey: string;
  // export let NSMetadataItemGPSMeasureModeKey: string;
  // export let NSMetadataItemGPSProcessingMethodKey: string;
  // export let NSMetadataItemGPSStatusKey: string;
  // export let NSMetadataItemGPSTrackKey: string;
  // export let NSMetadataItemGenreKey: string;
  // export let NSMetadataItemHasAlphaChannelKey: string;
  // export let NSMetadataItemHeadlineKey: string;
  // export let NSMetadataItemISOSpeedKey: string;
  // export let NSMetadataItemIdentifierKey: string;
  // export let NSMetadataItemImageDirectionKey: string;
  // export let NSMetadataItemInformationKey: string;
  // export let NSMetadataItemInstantMessageAddressesKey: string;
  // export let NSMetadataItemInstructionsKey: string;
  // export let NSMetadataItemIsApplicationManagedKey: string;
  // export let NSMetadataItemIsGeneralMIDISequenceKey: string;
  // export let NSMetadataItemIsLikelyJunkKey: string;
  // export let NSMetadataItemIsUbiquitousKey: string;
  // export let NSMetadataItemKeySignatureKey: string;
  // export let NSMetadataItemKeywordsKey: string;
  // export let NSMetadataItemKindKey: string;
  // export let NSMetadataItemLanguagesKey: string;
  // export let NSMetadataItemLastUsedDateKey: string;
  // export let NSMetadataItemLatitudeKey: string;
  // export let NSMetadataItemLayerNamesKey: string;
  // export let NSMetadataItemLensModelKey: string;
  // export let NSMetadataItemLongitudeKey: string;
  // export let NSMetadataItemLyricistKey: string;
  // export let NSMetadataItemMaxApertureKey: string;
  // export let NSMetadataItemMediaTypesKey: string;
  // export let NSMetadataItemMeteringModeKey: string;
  // export let NSMetadataItemMusicalGenreKey: string;
  // export let NSMetadataItemMusicalInstrumentCategoryKey: string;
  // export let NSMetadataItemMusicalInstrumentNameKey: string;
  // export let NSMetadataItemNamedLocationKey: string;
  // export let NSMetadataItemNumberOfPagesKey: string;
  // export let NSMetadataItemOrganizationsKey: string;
  // export let NSMetadataItemOrientationKey: string;
  // export let NSMetadataItemOriginalFormatKey: string;
  // export let NSMetadataItemOriginalSourceKey: string;
  // export let NSMetadataItemPageHeightKey: string;
  // export let NSMetadataItemPageWidthKey: string;
  // export let NSMetadataItemParticipantsKey: string;
  // export let NSMetadataItemPathKey: string;
  // export let NSMetadataItemPerformersKey: string;
  // export let NSMetadataItemPhoneNumbersKey: string;
  // export let NSMetadataItemPixelCountKey: string;
  // export let NSMetadataItemPixelHeightKey: string;
  // export let NSMetadataItemPixelWidthKey: string;
  // export let NSMetadataItemProducerKey: string;
  // export let NSMetadataItemProfileNameKey: string;
  // export let NSMetadataItemProjectsKey: string;
  // export let NSMetadataItemPublishersKey: string;
  // export let NSMetadataItemRecipientAddressesKey: string;
  // export let NSMetadataItemRecipientEmailAddressesKey: string;
  // export let NSMetadataItemRecipientsKey: string;
  // export let NSMetadataItemRecordingDateKey: string;
  // export let NSMetadataItemRecordingYearKey: string;
  // export let NSMetadataItemRedEyeOnOffKey: string;
  // export let NSMetadataItemResolutionHeightDPIKey: string;
  // export let NSMetadataItemResolutionWidthDPIKey: string;
  // export let NSMetadataItemRightsKey: string;
  // export let NSMetadataItemSecurityMethodKey: string;
  // export let NSMetadataItemSpeedKey: string;
  // export let NSMetadataItemStarRatingKey: string;
  // export let NSMetadataItemStateOrProvinceKey: string;
  // export let NSMetadataItemStreamableKey: string;
  // export let NSMetadataItemSubjectKey: string;
  // export let NSMetadataItemTempoKey: string;
  // export let NSMetadataItemTextContentKey: string;
  // export let NSMetadataItemThemeKey: string;
  // export let NSMetadataItemTimeSignatureKey: string;
  // export let NSMetadataItemTimestampKey: string;
  // export let NSMetadataItemTitleKey: string;
  // export let NSMetadataItemTotalBitRateKey: string;
  // export let NSMetadataItemURLKey: string;
  // export let NSMetadataItemVersionKey: string;
  // export let NSMetadataItemVideoBitRateKey: string;
  // export let NSMetadataItemWhereFromsKey: string;
  // export let NSMetadataItemWhiteBalanceKey: string;
  // export let NSMetadataQueryAccessibleUbiquitousExternalDocumentsScope: string;
  // export let NSMetadataQueryIndexedLocalComputerScope: string;
  // export let NSMetadataQueryIndexedNetworkScope: string;
  // export let NSMetadataQueryLocalComputerScope: string;
  // export let NSMetadataQueryNetworkScope: string;
  // export let NSMetadataQueryResultContentRelevanceAttribute: string;
  // export let NSMetadataQueryUbiquitousDataScope: string;
  // export let NSMetadataQueryUbiquitousDocumentsScope: string;
  // export let NSMetadataQueryUpdateAddedItemsKey: string;
  // export let NSMetadataQueryUpdateChangedItemsKey: string;
  // export let NSMetadataQueryUpdateRemovedItemsKey: string;
  // export let NSMetadataQueryUserHomeScope: string;
  // export let NSMetadataUbiquitousItemContainerDisplayNameKey: string;
  // export let NSMetadataUbiquitousItemDownloadRequestedKey: string;
  // export let NSMetadataUbiquitousItemDownloadingErrorKey: string;
  // export let NSMetadataUbiquitousItemDownloadingStatusCurrent: string;
  // export let NSMetadataUbiquitousItemDownloadingStatusDownloaded: string;
  // export let NSMetadataUbiquitousItemDownloadingStatusKey: string;
  // export let NSMetadataUbiquitousItemDownloadingStatusNotDownloaded: string;
  // export let NSMetadataUbiquitousItemHasUnresolvedConflictsKey: string;
  // export let NSMetadataUbiquitousItemIsDownloadingKey: string;
  // export let NSMetadataUbiquitousItemIsExternalDocumentKey: string;
  // export let NSMetadataUbiquitousItemIsSharedKey: string;
  // export let NSMetadataUbiquitousItemIsUploadedKey: string;
  // export let NSMetadataUbiquitousItemIsUploadingKey: string;
  // export let NSMetadataUbiquitousItemPercentDownloadedKey: string;
  // export let NSMetadataUbiquitousItemPercentUploadedKey: string;
  // export let NSMetadataUbiquitousItemURLInLocalContainerKey: string;
  // export let NSMetadataUbiquitousItemUploadingErrorKey: string;
  // export let NSMetadataUbiquitousSharedItemCurrentUserPermissionsKey: string;
  // export let NSMetadataUbiquitousSharedItemCurrentUserRoleKey: string;
  // export let NSMetadataUbiquitousSharedItemMostRecentEditorNameComponentsKey: string;
  // export let NSMetadataUbiquitousSharedItemOwnerNameComponentsKey: string;
  // export let NSMetadataUbiquitousSharedItemPermissionsReadOnly: string;
  // export let NSMetadataUbiquitousSharedItemPermissionsReadWrite: string;
  // export let NSMetadataUbiquitousSharedItemRoleOwner: string;
  // export let NSMetadataUbiquitousSharedItemRoleParticipant: string;
  // export let NSNonOwnedPointerHashCallBacks: NSHashTableCallBacks;
  // export let NSNonOwnedPointerMapKeyCallBacks: NSMapTableKeyCallBacks;
  // export let NSNonOwnedPointerMapValueCallBacks: NSMapTableValueCallBacks;
  // export let NSNonOwnedPointerOrNullMapKeyCallBacks: NSMapTableKeyCallBacks;
  // export let NSNonRetainedObjectHashCallBacks: NSHashTableCallBacks;
  // export let NSNonRetainedObjectMapKeyCallBacks: NSMapTableKeyCallBacks;
  // export let NSNonRetainedObjectMapValueCallBacks: NSMapTableValueCallBacks;
  // export let NSNotFound: number;
  // export let NSNotificationDeliverImmediately: DistributedNotificationCenter.Options;
  // export let NSNotificationPostToAllSessions: DistributedNotificationCenter.Options;
  // export let NSOSStatusErrorDomain: string;
  // export let NSObjectHashCallBacks: NSHashTableCallBacks;
  // export let NSObjectMapKeyCallBacks: NSMapTableKeyCallBacks;
  // export let NSObjectMapValueCallBacks: NSMapTableValueCallBacks;
  // export let NSOperationNotSupportedForKeyException: string;
  // export let NSOwnedObjectIdentityHashCallBacks: NSHashTableCallBacks;
  // export let NSOwnedPointerHashCallBacks: NSHashTableCallBacks;
  // export let NSOwnedPointerMapKeyCallBacks: NSMapTableKeyCallBacks;
  // export let NSOwnedPointerMapValueCallBacks: NSMapTableValueCallBacks;
  // export let NSPOSIXErrorDomain: string;
  // export let NSPersonNameComponentDelimiter: string;
  // export let NSPersonNameComponentFamilyName: string;
  // export let NSPersonNameComponentGivenName: string;
  // export let NSPersonNameComponentKey: string;
  // export let NSPersonNameComponentMiddleName: string;
  // export let NSPersonNameComponentNickname: string;
  // export let NSPersonNameComponentPrefix: string;
  // export let NSPersonNameComponentSuffix: string;
  // export let NSPointerToStructHashCallBacks: NSHashTableCallBacks;
  // export let NSRecoveryAttempterErrorKey: string;
  // export let NSStreamSOCKSErrorDomain: string;
  // export let NSStreamSocketSSLErrorDomain: string;
  // export let NSStringEncodingErrorKey: string;
  // export let NSURLAuthenticationMethodClientCertificate: string;
  // export let NSURLAuthenticationMethodDefault: string;
  // export let NSURLAuthenticationMethodHTMLForm: string;
  // export let NSURLAuthenticationMethodHTTPBasic: string;
  // export let NSURLAuthenticationMethodHTTPDigest: string;
  // export let NSURLAuthenticationMethodNTLM: string;
  // export let NSURLAuthenticationMethodNegotiate: string;
  // export let NSURLAuthenticationMethodServerTrust: string;
  // export let NSURLCredentialStorageRemoveSynchronizableCredentials: string;
  // export let NSURLErrorBackgroundTaskCancelledReasonKey: string;
  // export let NSURLErrorDomain: string;
  // export let NSURLErrorFailingURLErrorKey: string;
  // export let NSURLErrorFailingURLPeerTrustErrorKey: string;
  // export let NSURLErrorFailingURLStringErrorKey: string;
  // export let NSURLErrorKey: string;
  // export let NSURLErrorNetworkUnavailableReasonKey: string;
  // export let NSURLFileScheme: string;
  // export let NSURLProtectionSpaceFTP: string;
  // export let NSURLProtectionSpaceFTPProxy: string;
  // export let NSURLProtectionSpaceHTTP: string;
  // export let NSURLProtectionSpaceHTTPProxy: string;
  // export let NSURLProtectionSpaceHTTPS: string;
  // export let NSURLProtectionSpaceHTTPSProxy: string;
  // export let NSURLProtectionSpaceSOCKSProxy: string;
  // export let NSURLSessionDownloadTaskResumeData: string;
  // export let NSURLSessionTransferSizeUnknown: number;
  // export let NSUbiquitousKeyValueStoreChangeReasonKey: string;
  // export let NSUbiquitousKeyValueStoreChangedKeysKey: string;
  // export let NSUnderlyingErrorKey: string;
  // export let NSUndoCloseGroupingRunLoopOrdering: number;
  // export let NSUndoManagerGroupIsDiscardableKey: string;
  // export let NSUserActivityTypeBrowsingWeb: string;
  // export let NSUserNotificationDefaultSoundName: string;
  // export let NSZeroPoint: CGPoint;
  // export let NSZeroRect: CGRect;
  // export let NSZeroSize: CGSize;
  // export let NSZombieEnabled: boolean;
  // export let IKFilterBrowserDefaultInputImage: string;
  // export let IKFilterBrowserExcludeCategories: string;
  // export let IKFilterBrowserExcludeFilters: string;
  // export let IKFilterBrowserShowCategories: string;
  // export let IKFilterBrowserShowPreview: string;
  // export let IKImageBrowserBackgroundColorKey: string;
  // export let IKImageBrowserCGImageRepresentationType: string;
  // export let IKImageBrowserCGImageSourceRepresentationType: string;
  // export let IKImageBrowserCellBackgroundLayer: string;
  // export let IKImageBrowserCellForegroundLayer: string;
  // export let IKImageBrowserCellPlaceHolderLayer: string;
  // export let IKImageBrowserCellSelectionLayer: string;
  // export let IKImageBrowserCellsHighlightedTitleAttributesKey: string;
  // export let IKImageBrowserCellsOutlineColorKey: string;
  // export let IKImageBrowserCellsSubtitleAttributesKey: string;
  // export let IKImageBrowserCellsTitleAttributesKey: string;
  // export let IKImageBrowserGroupBackgroundColorKey: string;
  // export let IKImageBrowserGroupFooterLayer: string;
  // export let IKImageBrowserGroupHeaderLayer: string;
  // export let IKImageBrowserGroupRangeKey: string;
  // export let IKImageBrowserGroupStyleKey: string;
  // export let IKImageBrowserGroupTitleKey: string;
  // export let IKImageBrowserIconRefPathRepresentationType: string;
  // export let IKImageBrowserIconRefRepresentationType: string;
  // export let IKImageBrowserNSBitmapImageRepresentationType: string;
  // export let IKImageBrowserNSDataRepresentationType: string;
  // export let IKImageBrowserNSImageRepresentationType: string;
  // export let IKImageBrowserNSURLRepresentationType: string;
  // export let IKImageBrowserPDFPageRepresentationType: string;
  // export let IKImageBrowserPathRepresentationType: string;
  // export let IKImageBrowserQCCompositionPathRepresentationType: string;
  // export let IKImageBrowserQCCompositionRepresentationType: string;
  // export let IKImageBrowserQTMoviePathRepresentationType: string;
  // export let IKImageBrowserQTMovieRepresentationType: string;
  // export let IKImageBrowserQuickLookPathRepresentationType: string;
  // export let IKImageBrowserSelectionColorKey: string;
  // export let IKOverlayTypeBackground: string;
  // export let IKOverlayTypeImage: string;
  // export let IKPictureTakerAllowsEditingKey: string;
  // export let IKPictureTakerAllowsFileChoosingKey: string;
  // export let IKPictureTakerAllowsVideoCaptureKey: string;
  // export let IKPictureTakerCropAreaSizeKey: string;
  // export let IKPictureTakerImageTransformsKey: string;
  // export let IKPictureTakerInformationalTextKey: string;
  // export let IKPictureTakerOutputImageMaxSizeKey: string;
  // export let IKPictureTakerRemainOpenAfterValidateKey: string;
  // export let IKPictureTakerShowAddressBookPicture: string;
  // export let IKPictureTakerShowAddressBookPictureKey: string;
  // export let IKPictureTakerShowEffectsKey: string;
  // export let IKPictureTakerShowEmptyPicture: string;
  // export let IKPictureTakerShowEmptyPictureKey: string;
  // export let IKPictureTakerShowRecentPictureKey: string;
  // export let IKPictureTakerUpdateRecentPictureKey: string;
  // export let IKSlideshowAudioFile: string;
  // export let IKSlideshowModeImages: string;
  // export let IKSlideshowModeOther: string;
  // export let IKSlideshowModePDF: string;
  // export let IKSlideshowPDFDisplayBox: string;
  // export let IKSlideshowPDFDisplayMode: string;
  // export let IKSlideshowPDFDisplaysAsBook: string;
  // export let IKSlideshowScreen: string;
  // export let IKSlideshowStartIndex: string;
  // export let IKSlideshowStartPaused: string;
  // export let IKSlideshowWrapAround: string;
  // export let IKToolModeAnnotate: string;
  // export let IKToolModeCrop: string;
  // export let IKToolModeMove: string;
  // export let IKToolModeNone: string;
  // export let IKToolModeRotate: string;
  // export let IKToolModeSelect: string;
  // export let IKToolModeSelectEllipse: string;
  // export let IKToolModeSelectLasso: string;
  // export let IKToolModeSelectRect: string;
  // export let IKUIFlavorAllowFallback: string;
  // export let IKUISizeFlavor: string;
  // export let IKUISizeMini: string;
  // export let IKUISizeRegular: string;
  // export let IKUISizeSmall: string;
  // export let IKUImaxSize: string;
  // export let IK_ApertureBundleIdentifier: string;
  // export let IK_MailBundleIdentifier: string;
  // export let IK_PhotosBundleIdentifier: string;
  // export let IK_iPhotoBundleIdentifier: string;
  // export let QCCompositionInputPaceKey: string;
  // export let globalUpdateOK: boolean;
  // export let kQuartzFilterApplicationDomain: string;
  // export let kQuartzFilterPDFWorkflowDomain: string;
  // export let kQuartzFilterPrintingDomain: string;
  // export let CATransform3DIdentity: CATransform3D;
  // export let kCAOnOrderIn: string;
  // export let kCAOnOrderOut: string;
  // export let kCARendererColorSpace: string;
  // export let kCARendererMetalCommandQueue: string;
  // export let kCATransactionAnimationDuration: string;
  // export let kCATransactionAnimationTimingFunction: string;
  // export let kCATransactionCompletionBlock: string;
  // export let kCATransactionDisableActions: string;
  // export let kCATransition: string;
}

// Add enums to the already-existing bridged classes
//
// If we didn't do this, these would be duplicated
// (i.e. both NSButton and NSButton$1 would exist
// in global scope)

let global = globalThis as any;

namespace AVAssetExportSession {
  export enum Status {
    Unknown = 0,
    Waiting = 1,
    Exporting = 2,
    Completed = 3,
    Failed = 4,
    Cancelled = 5
  }

  global['AVAssetExportSession']['Status'] = Status;

}

namespace AVAssetImageGenerator {
  export enum Result {
    Succeeded = 0,
    Failed = 1,
    Cancelled = 2
  }

  global['AVAssetImageGenerator']['Result'] = Result;

  export let cleanAperture: string;
  export let encodedPixels: string;
  export let productionAperture: string;
}

namespace AVAssetReader {
  export enum Status {
    Unknown = 0,
    Reading = 1,
    Completed = 2,
    Failed = 3,
    Cancelled = 4
  }

  global['AVAssetReader']['Status'] = Status;

}

namespace AVAssetTrack {
  export let audioFallback: string;
  export let chapterList: string;
  export let forcedSubtitlesOnly: string;
  export let metadataReferent: string;
  export let selectionFollower: string;
  export let timecode: string;
}

namespace AVAssetWriter {
  export enum Status {
    Unknown = 0,
    Writing = 1,
    Completed = 2,
    Failed = 3,
    Cancelled = 4
  }

  global['AVAssetWriter']['Status'] = Status;

}

namespace AVAssetWriterInput {
  export let beforeMainMediaDataNotInterleaved: string;
  export let interleavedWithMainMediaData: string;
}

namespace AVAudioSession {
  export enum CategoryOptions {
    MixWithOthers = 1,
    DuckOthers = 2,
    AllowBluetooth = 4,
    DefaultToSpeaker = 8,
    InterruptSpokenAudioAndMixWithOthers = 17,
    AllowBluetoothA2DP = 32,
    AllowAirPlay = 64
  }

  global['AVAudioSession']['CategoryOptions'] = CategoryOptions;

  export enum IOType {
    NotSpecified = 0,
    Aggregated = 1
  }

  global['AVAudioSession']['IOType'] = IOType;

  export enum InterruptionOptions {
    ShouldResume = 1
  }

  global['AVAudioSession']['InterruptionOptions'] = InterruptionOptions;

  export enum InterruptionType {
    Began = 1,
    Ended = 0
  }

  global['AVAudioSession']['InterruptionType'] = InterruptionType;

  export enum PortOverride {
    None = 0,
    Speaker = 1936747378
  }

  global['AVAudioSession']['PortOverride'] = PortOverride;

  export enum PromptStyle {
    None = 1852796517,
    Short = 1936224884,
    Normal = 1852992876
  }

  global['AVAudioSession']['PromptStyle'] = PromptStyle;

  export enum RecordPermission {
    Undetermined = 1970168948,
    Denied = 1684369017,
    Granted = 1735552628
  }

  global['AVAudioSession']['RecordPermission'] = RecordPermission;

  export enum RouteChangeReason {
    Unknown = 0,
    NewDeviceAvailable = 1,
    OldDeviceUnavailable = 2,
    CategoryChange = 3,
    Override = 4,
    WakeFromSleep = 6,
    NoSuitableRouteForCategory = 7,
    RouteConfigurationChange = 8
  }

  global['AVAudioSession']['RouteChangeReason'] = RouteChangeReason;

  export enum RouteSharingPolicy {
    Default = 0,
    LongFormAudio = 1,
    LongForm = 1,
    Independent = 2,
    LongFormVideo = 3
  }

  global['AVAudioSession']['RouteSharingPolicy'] = RouteSharingPolicy;

  export enum SetActiveOptions {
    NotifyOthersOnDeactivation = 1
  }

  global['AVAudioSession']['SetActiveOptions'] = SetActiveOptions;

  export enum SilenceSecondaryAudioHintType {
    Begin = 1,
    End = 0
  }

  global['AVAudioSession']['SilenceSecondaryAudioHintType'] = SilenceSecondaryAudioHintType;

  export let ambient: string;
  export let audioProcessing: string;
  export let multiRoute: string;
  export let playAndRecord: string;
  export let playback: string;
  export let record: string;
  export let soloAmbient: string;
  export let interruptionNotification: string;
  export let lower: string;
  export let upper: string;
  export let mediaServicesWereLostNotification: string;
  export let mediaServicesWereResetNotification: string;
  export let default_: string;
  export let gameChat: string;
  export let measurement: string;
  export let moviePlayback: string;
  export let spokenAudio: string;
  export let videoChat: string;
  export let videoRecording: string;
  export let voiceChat: string;
  export let voicePrompt: string;
  export let back: string;
  export let bottom: string;
  export let front: string;
  export let left: string;
  export let right: string;
  export let top: string;
  export let cardioid: string;
  export let omnidirectional: string;
  export let subcardioid: string;
  export let airPlay: string;
  export let bluetoothA2DP: string;
  export let bluetoothHFP: string;
  export let bluetoothLE: string;
  export let builtInMic: string;
  export let builtInReceiver: string;
  export let builtInSpeaker: string;
  export let carAudio: string;
  export let HDMI: string;
  export let headphones: string;
  export let headsetMic: string;
  export let lineIn: string;
  export let lineOut: string;
  export let usbAudio: string;
  export let routeChangeNotification: string;
  export let silenceSecondaryAudioHintNotification: string;
}

namespace AVAudioTimePitchAlgorithm {
  export let lowQualityZeroLatency: string;
  export let spectral: string;
  export let timeDomain: string;
  export let varispeed: string;
}

namespace AVAudioUnitComponentManager {
  export let registrationsChangedNotification: string;
}

namespace AVCaptureDevice {
  export enum AutoFocusRangeRestriction {
    None = 0,
    Near = 1,
    Far = 2
  }

  global['AVCaptureDevice']['AutoFocusRangeRestriction'] = AutoFocusRangeRestriction;

  export enum Position {
    Unspecified = 0,
    Back = 1,
    Front = 2
  }

  global['AVCaptureDevice']['Position'] = Position;

  export enum TransportControlsPlaybackMode {
    NotPlayingMode = 0,
    PlayingMode = 1
  }

  global['AVCaptureDevice']['TransportControlsPlaybackMode'] = TransportControlsPlaybackMode;

  export enum ExposureMode {
    Locked = 0,
    AutoExpose = 1,
    ContinuousAutoExposure = 2,
    Custom = 3
  }

  global['AVCaptureDevice']['ExposureMode'] = ExposureMode;

  export enum FlashMode {
    Off = 0,
    On = 1,
    Auto = 2
  }

  global['AVCaptureDevice']['FlashMode'] = FlashMode;

  export enum FocusMode {
    Locked = 0,
    AutoFocus = 1,
    ContinuousAutoFocus = 2
  }

  global['AVCaptureDevice']['FocusMode'] = FocusMode;

  export enum LensStabilizationStatus {
    Unsupported = 0,
    Off = 1,
    Active = 2,
    OutOfRange = 3,
    Unavailable = 4
  }

  global['AVCaptureDevice']['LensStabilizationStatus'] = LensStabilizationStatus;

  export enum TorchMode {
    Off = 0,
    On = 1,
    Auto = 2
  }

  global['AVCaptureDevice']['TorchMode'] = TorchMode;

  export enum WhiteBalanceMode {
    Locked = 0,
    AutoWhiteBalance = 1,
    ContinuousAutoWhiteBalance = 2
  }

  global['AVCaptureDevice']['WhiteBalanceMode'] = WhiteBalanceMode;

  export let builtInDualCamera: string;
  export let builtInDualWideCamera: string;
  export let builtInDuoCamera: string;
  export let builtInMicrophone: string;
  export let builtInTelephotoCamera: string;
  export let builtInTripleCamera: string;
  export let builtInTrueDepthCamera: string;
  export let builtInUltraWideCamera: string;
  export let builtInWideAngleCamera: string;
  export let externalUnknown: string;
  export let currentExposureDuration: CMTime;
  export let currentExposureTargetBias: number;
  export let currentISO: number;
  export let currentLensPosition: number;
  export let maxAvailableTorchLevel: number;
  // export let currentWhiteBalanceGains: AVCaptureDevice.WhiteBalanceGains;
}

namespace AVCaptureOutput {
  export enum DataDroppedReason {
    None = 0,
    LateData = 1,
    OutOfBuffers = 2,
    Discontinuity = 3
  }

  global['AVCaptureOutput']['DataDroppedReason'] = DataDroppedReason;

}

namespace AVCapturePhotoOutput {
  export enum QualityPrioritization {
    Speed = 1,
    Balanced = 2,
    Quality = 3
  }

  global['AVCapturePhotoOutput']['QualityPrioritization'] = QualityPrioritization;

}

namespace AVCaptureSession {
  export enum InterruptionReason {
    VideoDeviceNotAvailableInBackground = 1,
    AudioDeviceInUseByAnotherClient = 2,
    VideoDeviceInUseByAnotherClient = 3,
    VideoDeviceNotAvailableWithMultipleForegroundApps = 4,
    VideoDeviceNotAvailableDueToSystemPressure = 5
  }

  global['AVCaptureSession']['InterruptionReason'] = InterruptionReason;

  export let hd1280x720: string;
  export let hd1920x1080: string;
  export let qvga320x240: string;
  export let cif352x288: string;
  export let hd4K3840x2160: string;
  export let vga640x480: string;
  export let qHD960x540: string;
  export let high: string;
  export let inputPriority: string;
  export let low: string;
  export let medium: string;
  export let photo: string;
  export let iFrame1280x720: string;
  export let iFrame960x540: string;
}

namespace AVContentKeyRequest {
  export enum Status {
    RequestingResponse = 0,
    ReceivedResponse = 1,
    Renewed = 2,
    Retried = 3,
    Cancelled = 4,
    Failed = 5
  }

  global['AVContentKeyRequest']['Status'] = Status;

  export let receivedObsoleteContentKey: string;
  export let receivedResponseWithExpiredLease: string;
  export let timedOut: string;
}

namespace AVContentKeySessionServerPlaybackContextOption {
  export let protocolVersions: string;
  export let serverChallenge: string;
}

namespace AVContentKeySystem {
  export let authorizationToken: string;
  export let clearKey: string;
  export let fairPlayStreaming: string;
}

namespace AVDepthData {
  export enum Accuracy {
    Relative = 0,
    Absolute = 1
  }

  global['AVDepthData']['Accuracy'] = Accuracy;

  export enum Quality {
    Low = 0,
    High = 1
  }

  global['AVDepthData']['Quality'] = Quality;

}

namespace AVFileType {
  export let mobile3GPP: string;
  export let mobile3GPP2: string;
  export let ac3: string;
  export let aifc: string;
  export let aiff: string;
  export let amr: string;
  export let avci: string;
  export let m4a: string;
  export let m4v: string;
  export let caf: string;
  export let dng: string;
  export let eac3: string;
  export let heic: string;
  export let heif: string;
  export let jpg: string;
  export let mp4: string;
  export let mp3: string;
  export let mov: string;
  export let au: string;
  export let tif: string;
  export let wav: string;
}

namespace AVLayerVideoGravity {
  export let resize: string;
  export let resizeAspect: string;
  export let resizeAspectFill: string;
}

namespace AVMediaCharacteristic {
  export let audible: string;
  export let containsAlphaChannel: string;
  export let containsOnlyForcedSubtitles: string;
  export let describesMusicAndSoundForAccessibility: string;
  export let describesVideoForAccessibility: string;
  export let dubbedTranslation: string;
  export let easyToRead: string;
  export let frameBased: string;
  export let isAuxiliaryContent: string;
  export let isMainProgramContent: string;
  export let isOriginalContent: string;
  export let languageTranslation: string;
  export let legible: string;
  export let transcribesSpokenDialogForAccessibility: string;
  export let usesWideGamutColorSpace: string;
  export let visual: string;
  export let voiceOverTranslation: string;
}

namespace AVMediaType {
  export let audio: string;
  export let closedCaption: string;
  export let depthData: string;
  export let metadata: string;
  export let metadataObject: string;
  export let muxed: string;
  export let subtitle: string;
  export let text: string;
  export let timecode: string;
  export let video: string;
}

namespace AVMetadataExtraAttributeKey {
  export let baseURI: string;
  export let info: string;
  export let valueURI: string;
}

namespace AVMetadataFormat {
  export let hlsMetadata: string;
  export let id3Metadata: string;
  export let isoUserData: string;
  export let quickTimeMetadata: string;
  export let quickTimeUserData: string;
  export let unknown: string;
  export let iTunesMetadata: string;
}

namespace AVMetadataIdentifier {
  export let commonIdentifierAlbumName: string;
  export let commonIdentifierArtist: string;
  export let commonIdentifierArtwork: string;
  export let commonIdentifierAssetIdentifier: string;
  export let commonIdentifierAuthor: string;
  export let commonIdentifierContributor: string;
  export let commonIdentifierCopyrights: string;
  export let commonIdentifierCreationDate: string;
  export let commonIdentifierCreator: string;
  export let commonIdentifierDescription: string;
  export let commonIdentifierFormat: string;
  export let commonIdentifierLanguage: string;
  export let commonIdentifierLastModifiedDate: string;
  export let commonIdentifierLocation: string;
  export let commonIdentifierMake: string;
  export let commonIdentifierModel: string;
  export let commonIdentifierPublisher: string;
  export let commonIdentifierRelation: string;
  export let commonIdentifierSoftware: string;
  export let commonIdentifierSource: string;
  export let commonIdentifierSubject: string;
  export let commonIdentifierTitle: string;
  export let commonIdentifierType: string;
  export let identifier3GPUserDataAlbumAndTrack: string;
  export let identifier3GPUserDataAuthor: string;
  export let identifier3GPUserDataCollection: string;
  export let identifier3GPUserDataCopyright: string;
  export let identifier3GPUserDataDescription: string;
  export let identifier3GPUserDataGenre: string;
  export let identifier3GPUserDataKeywordList: string;
  export let identifier3GPUserDataLocation: string;
  export let identifier3GPUserDataMediaClassification: string;
  export let identifier3GPUserDataMediaRating: string;
  export let identifier3GPUserDataPerformer: string;
  export let identifier3GPUserDataRecordingYear: string;
  export let identifier3GPUserDataThumbnail: string;
  export let identifier3GPUserDataTitle: string;
  export let identifier3GPUserDataUserRating: string;
  export let id3MetadataAlbumSortOrder: string;
  export let id3MetadataAlbumTitle: string;
  export let id3MetadataAttachedPicture: string;
  export let id3MetadataAudioEncryption: string;
  export let id3MetadataAudioSeekPointIndex: string;
  export let id3MetadataBand: string;
  export let id3MetadataBeatsPerMinute: string;
  export let id3MetadataComments: string;
  export let id3MetadataCommercial: string;
  export let id3MetadataCommercialInformation: string;
  export let id3MetadataComposer: string;
  export let id3MetadataConductor: string;
  export let id3MetadataContentGroupDescription: string;
  export let id3MetadataContentType: string;
  export let id3MetadataCopyright: string;
  export let id3MetadataCopyrightInformation: string;
  export let id3MetadataDate: string;
  export let id3MetadataEncodedBy: string;
  export let id3MetadataEncodedWith: string;
  export let id3MetadataEncodingTime: string;
  export let id3MetadataEncryption: string;
  export let id3MetadataEqualization: string;
  export let id3MetadataEqualization2: string;
  export let id3MetadataEventTimingCodes: string;
  export let id3MetadataFileOwner: string;
  export let id3MetadataFileType: string;
  export let id3MetadataGeneralEncapsulatedObject: string;
  export let id3MetadataGroupIdentifier: string;
  export let id3MetadataInitialKey: string;
  export let id3MetadataInternationalStandardRecordingCode: string;
  export let id3MetadataInternetRadioStationName: string;
  export let id3MetadataInternetRadioStationOwner: string;
  export let id3MetadataInvolvedPeopleList_v23: string;
  export let id3MetadataInvolvedPeopleList_v24: string;
  export let id3MetadataLanguage: string;
  export let id3MetadataLeadPerformer: string;
  export let id3MetadataLength: string;
  export let id3MetadataLink: string;
  export let id3MetadataLyricist: string;
  export let id3MetadataMPEGLocationLookupTable: string;
  export let id3MetadataMediaType: string;
  export let id3MetadataModifiedBy: string;
  export let id3MetadataMood: string;
  export let id3MetadataMusicCDIdentifier: string;
  export let id3MetadataMusicianCreditsList: string;
  export let id3MetadataOfficialArtistWebpage: string;
  export let id3MetadataOfficialAudioFileWebpage: string;
  export let id3MetadataOfficialAudioSourceWebpage: string;
  export let id3MetadataOfficialInternetRadioStationHomepage: string;
  export let id3MetadataOfficialPublisherWebpage: string;
  export let id3MetadataOriginalAlbumTitle: string;
  export let id3MetadataOriginalArtist: string;
  export let id3MetadataOriginalFilename: string;
  export let id3MetadataOriginalLyricist: string;
  export let id3MetadataOriginalReleaseTime: string;
  export let id3MetadataOriginalReleaseYear: string;
  export let id3MetadataOwnership: string;
  export let id3MetadataPartOfASet: string;
  export let id3MetadataPayment: string;
  export let id3MetadataPerformerSortOrder: string;
  export let id3MetadataPlayCounter: string;
  export let id3MetadataPlaylistDelay: string;
  export let id3MetadataPopularimeter: string;
  export let id3MetadataPositionSynchronization: string;
  export let id3MetadataPrivate: string;
  export let id3MetadataProducedNotice: string;
  export let id3MetadataPublisher: string;
  export let id3MetadataRecommendedBufferSize: string;
  export let id3MetadataRecordingDates: string;
  export let id3MetadataRecordingTime: string;
  export let id3MetadataRelativeVolumeAdjustment: string;
  export let id3MetadataRelativeVolumeAdjustment2: string;
  export let id3MetadataReleaseTime: string;
  export let id3MetadataReverb: string;
  export let id3MetadataSeek: string;
  export let id3MetadataSetSubtitle: string;
  export let id3MetadataSignature: string;
  export let id3MetadataSize: string;
  export let id3MetadataSubTitle: string;
  export let id3MetadataSynchronizedLyric: string;
  export let id3MetadataSynchronizedTempoCodes: string;
  export let id3MetadataTaggingTime: string;
  export let id3MetadataTermsOfUse: string;
  export let id3MetadataTime: string;
  export let id3MetadataTitleDescription: string;
  export let id3MetadataTitleSortOrder: string;
  export let id3MetadataTrackNumber: string;
  export let id3MetadataUniqueFileIdentifier: string;
  export let id3MetadataUnsynchronizedLyric: string;
  export let id3MetadataUserText: string;
  export let id3MetadataUserURL: string;
  export let id3MetadataYear: string;
  export let isoUserDataCopyright: string;
  export let isoUserDataDate: string;
  export let isoUserDataTaggedCharacteristic: string;
  export let icyMetadataStreamTitle: string;
  export let icyMetadataStreamURL: string;
  export let quickTimeMetadataAlbum: string;
  export let quickTimeMetadataArranger: string;
  export let quickTimeMetadataArtist: string;
  export let quickTimeMetadataArtwork: string;
  export let quickTimeMetadataAuthor: string;
  export let quickTimeMetadataAutoLivePhoto: string;
  export let quickTimeMetadataCameraFrameReadoutTime: string;
  export let quickTimeMetadataCameraIdentifier: string;
  export let quickTimeMetadataCollectionUser: string;
  export let quickTimeMetadataComment: string;
  export let quickTimeMetadataComposer: string;
  export let quickTimeMetadataContentIdentifier: string;
  export let quickTimeMetadataCopyright: string;
  export let quickTimeMetadataCreationDate: string;
  export let quickTimeMetadataCredits: string;
  export let quickTimeMetadataDescription: string;
  export let quickTimeMetadataDetectedCatBody: string;
  export let quickTimeMetadataDetectedDogBody: string;
  export let quickTimeMetadataDetectedFace: string;
  export let quickTimeMetadataDetectedHumanBody: string;
  export let quickTimeMetadataDetectedSalientObject: string;
  export let quickTimeMetadataDirectionFacing: string;
  export let quickTimeMetadataDirectionMotion: string;
  export let quickTimeMetadataDirector: string;
  export let quickTimeMetadataDisplayName: string;
  export let quickTimeMetadataEncodedBy: string;
  export let quickTimeMetadataGenre: string;
  export let quickTimeMetadataInformation: string;
  export let quickTimeMetadataKeywords: string;
  export let quickTimeMetadataLivePhotoVitalityScore: string;
  export let quickTimeMetadataLivePhotoVitalityScoringVersion: string;
  export let quickTimeMetadataLocationBody: string;
  export let quickTimeMetadataLocationDate: string;
  export let quickTimeMetadataLocationISO6709: string;
  export let quickTimeMetadataLocationName: string;
  export let quickTimeMetadataLocationNote: string;
  export let quickTimeMetadataLocationRole: string;
  export let quickTimeMetadataMake: string;
  export let quickTimeMetadataModel: string;
  export let quickTimeMetadataOriginalArtist: string;
  export let quickTimeMetadataPerformer: string;
  export let quickTimeMetadataPhonogramRights: string;
  export let quickTimeMetadataPreferredAffineTransform: string;
  export let quickTimeMetadataProducer: string;
  export let quickTimeMetadataPublisher: string;
  export let quickTimeMetadataRatingUser: string;
  export let quickTimeMetadataSoftware: string;
  export let quickTimeMetadataSpatialOverCaptureQualityScore: string;
  export let quickTimeMetadataSpatialOverCaptureQualityScoringVersion: string;
  export let quickTimeMetadataTitle: string;
  export let quickTimeMetadataVideoOrientation: string;
  export let quickTimeMetadataYear: string;
  export let quickTimeMetadataiXML: string;
  export let quickTimeUserDataAlbum: string;
  export let quickTimeUserDataArranger: string;
  export let quickTimeUserDataArtist: string;
  export let quickTimeUserDataAuthor: string;
  export let quickTimeUserDataChapter: string;
  export let quickTimeUserDataComment: string;
  export let quickTimeUserDataComposer: string;
  export let quickTimeUserDataCopyright: string;
  export let quickTimeUserDataCreationDate: string;
  export let quickTimeUserDataCredits: string;
  export let quickTimeUserDataDescription: string;
  export let quickTimeUserDataDirector: string;
  export let quickTimeUserDataDisclaimer: string;
  export let quickTimeUserDataEncodedBy: string;
  export let quickTimeUserDataFullName: string;
  export let quickTimeUserDataGenre: string;
  export let quickTimeUserDataHostComputer: string;
  export let quickTimeUserDataInformation: string;
  export let quickTimeUserDataKeywords: string;
  export let quickTimeUserDataLocationISO6709: string;
  export let quickTimeUserDataMake: string;
  export let quickTimeUserDataModel: string;
  export let quickTimeUserDataOriginalArtist: string;
  export let quickTimeUserDataOriginalFormat: string;
  export let quickTimeUserDataOriginalSource: string;
  export let quickTimeUserDataPerformers: string;
  export let quickTimeUserDataPhonogramRights: string;
  export let quickTimeUserDataProducer: string;
  export let quickTimeUserDataProduct: string;
  export let quickTimeUserDataPublisher: string;
  export let quickTimeUserDataSoftware: string;
  export let quickTimeUserDataSpecialPlaybackRequirements: string;
  export let quickTimeUserDataTaggedCharacteristic: string;
  export let quickTimeUserDataTrack: string;
  export let quickTimeUserDataTrackName: string;
  export let quickTimeUserDataURLLink: string;
  export let quickTimeUserDataWarning: string;
  export let quickTimeUserDataWriter: string;
  export let iTunesMetadataAccountKind: string;
  export let iTunesMetadataAcknowledgement: string;
  export let iTunesMetadataAlbum: string;
  export let iTunesMetadataAlbumArtist: string;
  export let iTunesMetadataAppleID: string;
  export let iTunesMetadataArranger: string;
  export let iTunesMetadataArtDirector: string;
  export let iTunesMetadataArtist: string;
  export let iTunesMetadataArtistID: string;
  export let iTunesMetadataAuthor: string;
  export let iTunesMetadataBeatsPerMin: string;
  export let iTunesMetadataComposer: string;
  export let iTunesMetadataConductor: string;
  export let iTunesMetadataContentRating: string;
  export let iTunesMetadataCopyright: string;
  export let iTunesMetadataCoverArt: string;
  export let iTunesMetadataCredits: string;
  export let iTunesMetadataDescription: string;
  export let iTunesMetadataDirector: string;
  export let iTunesMetadataDiscCompilation: string;
  export let iTunesMetadataDiscNumber: string;
  export let iTunesMetadataEQ: string;
  export let iTunesMetadataEncodedBy: string;
  export let iTunesMetadataEncodingTool: string;
  export let iTunesMetadataExecProducer: string;
  export let iTunesMetadataGenreID: string;
  export let iTunesMetadataGrouping: string;
  export let iTunesMetadataLinerNotes: string;
  export let iTunesMetadataLyrics: string;
  export let iTunesMetadataOnlineExtras: string;
  export let iTunesMetadataOriginalArtist: string;
  export let iTunesMetadataPerformer: string;
  export let iTunesMetadataPhonogramRights: string;
  export let iTunesMetadataPlaylistID: string;
  export let iTunesMetadataPredefinedGenre: string;
  export let iTunesMetadataProducer: string;
  export let iTunesMetadataPublisher: string;
  export let iTunesMetadataRecordCompany: string;
  export let iTunesMetadataReleaseDate: string;
  export let iTunesMetadataSoloist: string;
  export let iTunesMetadataSongID: string;
  export let iTunesMetadataSongName: string;
  export let iTunesMetadataSoundEngineer: string;
  export let iTunesMetadataThanks: string;
  export let iTunesMetadataTrackNumber: string;
  export let iTunesMetadataTrackSubTitle: string;
  export let iTunesMetadataUserComment: string;
  export let iTunesMetadataUserGenre: string;
}

namespace AVMetadataKey {
  export let metadata3GPUserDataKeyAlbumAndTrack: string;
  export let metadata3GPUserDataKeyAuthor: string;
  export let metadata3GPUserDataKeyCollection: string;
  export let metadata3GPUserDataKeyCopyright: string;
  export let metadata3GPUserDataKeyDescription: string;
  export let metadata3GPUserDataKeyGenre: string;
  export let metadata3GPUserDataKeyKeywordList: string;
  export let metadata3GPUserDataKeyLocation: string;
  export let metadata3GPUserDataKeyMediaClassification: string;
  export let metadata3GPUserDataKeyMediaRating: string;
  export let metadata3GPUserDataKeyPerformer: string;
  export let metadata3GPUserDataKeyRecordingYear: string;
  export let metadata3GPUserDataKeyThumbnail: string;
  export let metadata3GPUserDataKeyTitle: string;
  export let metadata3GPUserDataKeyUserRating: string;
  export let commonKeyAlbumName: string;
  export let commonKeyArtist: string;
  export let commonKeyArtwork: string;
  export let commonKeyAuthor: string;
  export let commonKeyContributor: string;
  export let commonKeyCopyrights: string;
  export let commonKeyCreationDate: string;
  export let commonKeyCreator: string;
  export let commonKeyDescription: string;
  export let commonKeyFormat: string;
  export let commonKeyIdentifier: string;
  export let commonKeyLanguage: string;
  export let commonKeyLastModifiedDate: string;
  export let commonKeyLocation: string;
  export let commonKeyMake: string;
  export let commonKeyModel: string;
  export let commonKeyPublisher: string;
  export let commonKeyRelation: string;
  export let commonKeySoftware: string;
  export let commonKeySource: string;
  export let commonKeySubject: string;
  export let commonKeyTitle: string;
  export let commonKeyType: string;
  export let id3MetadataKeyAlbumSortOrder: string;
  export let id3MetadataKeyAlbumTitle: string;
  export let id3MetadataKeyAttachedPicture: string;
  export let id3MetadataKeyAudioEncryption: string;
  export let id3MetadataKeyAudioSeekPointIndex: string;
  export let id3MetadataKeyBand: string;
  export let id3MetadataKeyBeatsPerMinute: string;
  export let id3MetadataKeyComments: string;
  export let id3MetadataKeyCommercial: string;
  export let id3MetadataKeyCommercialInformation: string;
  export let id3MetadataKeyComposer: string;
  export let id3MetadataKeyConductor: string;
  export let id3MetadataKeyContentGroupDescription: string;
  export let id3MetadataKeyContentType: string;
  export let id3MetadataKeyCopyright: string;
  export let id3MetadataKeyCopyrightInformation: string;
  export let id3MetadataKeyDate: string;
  export let id3MetadataKeyEncodedBy: string;
  export let id3MetadataKeyEncodedWith: string;
  export let id3MetadataKeyEncodingTime: string;
  export let id3MetadataKeyEncryption: string;
  export let id3MetadataKeyEqualization: string;
  export let id3MetadataKeyEqualization2: string;
  export let id3MetadataKeyEventTimingCodes: string;
  export let id3MetadataKeyFileOwner: string;
  export let id3MetadataKeyFileType: string;
  export let id3MetadataKeyGeneralEncapsulatedObject: string;
  export let id3MetadataKeyGroupIdentifier: string;
  export let id3MetadataKeyInitialKey: string;
  export let id3MetadataKeyInternationalStandardRecordingCode: string;
  export let id3MetadataKeyInternetRadioStationName: string;
  export let id3MetadataKeyInternetRadioStationOwner: string;
  export let id3MetadataKeyInvolvedPeopleList_v23: string;
  export let id3MetadataKeyInvolvedPeopleList_v24: string;
  export let id3MetadataKeyLanguage: string;
  export let id3MetadataKeyLeadPerformer: string;
  export let id3MetadataKeyLength: string;
  export let id3MetadataKeyLink: string;
  export let id3MetadataKeyLyricist: string;
  export let id3MetadataKeyMPEGLocationLookupTable: string;
  export let id3MetadataKeyMediaType: string;
  export let id3MetadataKeyModifiedBy: string;
  export let id3MetadataKeyMood: string;
  export let id3MetadataKeyMusicCDIdentifier: string;
  export let id3MetadataKeyMusicianCreditsList: string;
  export let id3MetadataKeyOfficialArtistWebpage: string;
  export let id3MetadataKeyOfficialAudioFileWebpage: string;
  export let id3MetadataKeyOfficialAudioSourceWebpage: string;
  export let id3MetadataKeyOfficialInternetRadioStationHomepage: string;
  export let id3MetadataKeyOfficialPublisherWebpage: string;
  export let id3MetadataKeyOriginalAlbumTitle: string;
  export let id3MetadataKeyOriginalArtist: string;
  export let id3MetadataKeyOriginalFilename: string;
  export let id3MetadataKeyOriginalLyricist: string;
  export let id3MetadataKeyOriginalReleaseTime: string;
  export let id3MetadataKeyOriginalReleaseYear: string;
  export let id3MetadataKeyOwnership: string;
  export let id3MetadataKeyPartOfASet: string;
  export let id3MetadataKeyPayment: string;
  export let id3MetadataKeyPerformerSortOrder: string;
  export let id3MetadataKeyPlayCounter: string;
  export let id3MetadataKeyPlaylistDelay: string;
  export let id3MetadataKeyPopularimeter: string;
  export let id3MetadataKeyPositionSynchronization: string;
  export let id3MetadataKeyPrivate: string;
  export let id3MetadataKeyProducedNotice: string;
  export let id3MetadataKeyPublisher: string;
  export let id3MetadataKeyRecommendedBufferSize: string;
  export let id3MetadataKeyRecordingDates: string;
  export let id3MetadataKeyRecordingTime: string;
  export let id3MetadataKeyRelativeVolumeAdjustment: string;
  export let id3MetadataKeyRelativeVolumeAdjustment2: string;
  export let id3MetadataKeyReleaseTime: string;
  export let id3MetadataKeyReverb: string;
  export let id3MetadataKeySeek: string;
  export let id3MetadataKeySetSubtitle: string;
  export let id3MetadataKeySignature: string;
  export let id3MetadataKeySize: string;
  export let id3MetadataKeySubTitle: string;
  export let id3MetadataKeySynchronizedLyric: string;
  export let id3MetadataKeySynchronizedTempoCodes: string;
  export let id3MetadataKeyTaggingTime: string;
  export let id3MetadataKeyTermsOfUse: string;
  export let id3MetadataKeyTime: string;
  export let id3MetadataKeyTitleDescription: string;
  export let id3MetadataKeyTitleSortOrder: string;
  export let id3MetadataKeyTrackNumber: string;
  export let id3MetadataKeyUniqueFileIdentifier: string;
  export let id3MetadataKeyUnsynchronizedLyric: string;
  export let id3MetadataKeyUserText: string;
  export let id3MetadataKeyUserURL: string;
  export let id3MetadataKeyYear: string;
  export let isoUserDataKeyCopyright: string;
  export let isoUserDataKeyDate: string;
  export let isoUserDataKeyTaggedCharacteristic: string;
  export let icyMetadataKeyStreamTitle: string;
  export let icyMetadataKeyStreamURL: string;
  export let quickTimeMetadataKeyAlbum: string;
  export let quickTimeMetadataKeyArranger: string;
  export let quickTimeMetadataKeyArtist: string;
  export let quickTimeMetadataKeyArtwork: string;
  export let quickTimeMetadataKeyAuthor: string;
  export let quickTimeMetadataKeyCameraFrameReadoutTime: string;
  export let quickTimeMetadataKeyCameraIdentifier: string;
  export let quickTimeMetadataKeyCollectionUser: string;
  export let quickTimeMetadataKeyComment: string;
  export let quickTimeMetadataKeyComposer: string;
  export let quickTimeMetadataKeyContentIdentifier: string;
  export let quickTimeMetadataKeyCopyright: string;
  export let quickTimeMetadataKeyCreationDate: string;
  export let quickTimeMetadataKeyCredits: string;
  export let quickTimeMetadataKeyDescription: string;
  export let quickTimeMetadataKeyDirectionFacing: string;
  export let quickTimeMetadataKeyDirectionMotion: string;
  export let quickTimeMetadataKeyDirector: string;
  export let quickTimeMetadataKeyDisplayName: string;
  export let quickTimeMetadataKeyEncodedBy: string;
  export let quickTimeMetadataKeyGenre: string;
  export let quickTimeMetadataKeyInformation: string;
  export let quickTimeMetadataKeyKeywords: string;
  export let quickTimeMetadataKeyLocationBody: string;
  export let quickTimeMetadataKeyLocationDate: string;
  export let quickTimeMetadataKeyLocationISO6709: string;
  export let quickTimeMetadataKeyLocationName: string;
  export let quickTimeMetadataKeyLocationNote: string;
  export let quickTimeMetadataKeyLocationRole: string;
  export let quickTimeMetadataKeyMake: string;
  export let quickTimeMetadataKeyModel: string;
  export let quickTimeMetadataKeyOriginalArtist: string;
  export let quickTimeMetadataKeyPerformer: string;
  export let quickTimeMetadataKeyPhonogramRights: string;
  export let quickTimeMetadataKeyProducer: string;
  export let quickTimeMetadataKeyPublisher: string;
  export let quickTimeMetadataKeyRatingUser: string;
  export let quickTimeMetadataKeySoftware: string;
  export let quickTimeMetadataKeyTitle: string;
  export let quickTimeMetadataKeyYear: string;
  export let quickTimeMetadataKeyiXML: string;
  export let quickTimeUserDataKeyAlbum: string;
  export let quickTimeUserDataKeyArranger: string;
  export let quickTimeUserDataKeyArtist: string;
  export let quickTimeUserDataKeyAuthor: string;
  export let quickTimeUserDataKeyChapter: string;
  export let quickTimeUserDataKeyComment: string;
  export let quickTimeUserDataKeyComposer: string;
  export let quickTimeUserDataKeyCopyright: string;
  export let quickTimeUserDataKeyCreationDate: string;
  export let quickTimeUserDataKeyCredits: string;
  export let quickTimeUserDataKeyDescription: string;
  export let quickTimeUserDataKeyDirector: string;
  export let quickTimeUserDataKeyDisclaimer: string;
  export let quickTimeUserDataKeyEncodedBy: string;
  export let quickTimeUserDataKeyFullName: string;
  export let quickTimeUserDataKeyGenre: string;
  export let quickTimeUserDataKeyHostComputer: string;
  export let quickTimeUserDataKeyInformation: string;
  export let quickTimeUserDataKeyKeywords: string;
  export let quickTimeUserDataKeyLocationISO6709: string;
  export let quickTimeUserDataKeyMake: string;
  export let quickTimeUserDataKeyModel: string;
  export let quickTimeUserDataKeyOriginalArtist: string;
  export let quickTimeUserDataKeyOriginalFormat: string;
  export let quickTimeUserDataKeyOriginalSource: string;
  export let quickTimeUserDataKeyPerformers: string;
  export let quickTimeUserDataKeyPhonogramRights: string;
  export let quickTimeUserDataKeyProducer: string;
  export let quickTimeUserDataKeyProduct: string;
  export let quickTimeUserDataKeyPublisher: string;
  export let quickTimeUserDataKeySoftware: string;
  export let quickTimeUserDataKeySpecialPlaybackRequirements: string;
  export let quickTimeUserDataKeyTaggedCharacteristic: string;
  export let quickTimeUserDataKeyTrack: string;
  export let quickTimeUserDataKeyTrackName: string;
  export let quickTimeUserDataKeyURLLink: string;
  export let quickTimeUserDataKeyWarning: string;
  export let quickTimeUserDataKeyWriter: string;
  export let iTunesMetadataKeyAccountKind: string;
  export let iTunesMetadataKeyAcknowledgement: string;
  export let iTunesMetadataKeyAlbum: string;
  export let iTunesMetadataKeyAlbumArtist: string;
  export let iTunesMetadataKeyAppleID: string;
  export let iTunesMetadataKeyArranger: string;
  export let iTunesMetadataKeyArtDirector: string;
  export let iTunesMetadataKeyArtist: string;
  export let iTunesMetadataKeyArtistID: string;
  export let iTunesMetadataKeyAuthor: string;
  export let iTunesMetadataKeyBeatsPerMin: string;
  export let iTunesMetadataKeyComposer: string;
  export let iTunesMetadataKeyConductor: string;
  export let iTunesMetadataKeyContentRating: string;
  export let iTunesMetadataKeyCopyright: string;
  export let iTunesMetadataKeyCoverArt: string;
  export let iTunesMetadataKeyCredits: string;
  export let iTunesMetadataKeyDescription: string;
  export let iTunesMetadataKeyDirector: string;
  export let iTunesMetadataKeyDiscCompilation: string;
  export let iTunesMetadataKeyDiscNumber: string;
  export let iTunesMetadataKeyEQ: string;
  export let iTunesMetadataKeyEncodedBy: string;
  export let iTunesMetadataKeyEncodingTool: string;
  export let iTunesMetadataKeyExecProducer: string;
  export let iTunesMetadataKeyGenreID: string;
  export let iTunesMetadataKeyGrouping: string;
  export let iTunesMetadataKeyLinerNotes: string;
  export let iTunesMetadataKeyLyrics: string;
  export let iTunesMetadataKeyOnlineExtras: string;
  export let iTunesMetadataKeyOriginalArtist: string;
  export let iTunesMetadataKeyPerformer: string;
  export let iTunesMetadataKeyPhonogramRights: string;
  export let iTunesMetadataKeyPlaylistID: string;
  export let iTunesMetadataKeyPredefinedGenre: string;
  export let iTunesMetadataKeyProducer: string;
  export let iTunesMetadataKeyPublisher: string;
  export let iTunesMetadataKeyRecordCompany: string;
  export let iTunesMetadataKeyReleaseDate: string;
  export let iTunesMetadataKeySoloist: string;
  export let iTunesMetadataKeySongID: string;
  export let iTunesMetadataKeySongName: string;
  export let iTunesMetadataKeySoundEngineer: string;
  export let iTunesMetadataKeyThanks: string;
  export let iTunesMetadataKeyTrackNumber: string;
  export let iTunesMetadataKeyTrackSubTitle: string;
  export let iTunesMetadataKeyUserComment: string;
  export let iTunesMetadataKeyUserGenre: string;
}

namespace AVMetadataKeySpace {
  export let audioFile: string;
  export let common: string;
  export let hlsDateRange: string;
  export let id3: string;
  export let isoUserData: string;
  export let icy: string;
  export let quickTimeMetadata: string;
  export let quickTimeUserData: string;
  export let iTunes: string;
}

namespace AVMetadataObject {
  export let aztec: string;
  export let catBody: string;
  export let code128: string;
  export let code39: string;
  export let code39Mod43: string;
  export let code93: string;
  export let dataMatrix: string;
  export let dogBody: string;
  export let ean13: string;
  export let ean8: string;
  export let face: string;
  export let humanBody: string;
  export let itf14: string;
  export let interleaved2of5: string;
  export let pdf417: string;
  export let qr: string;
  export let salientObject: string;
  export let upce: string;
}

namespace AVOutputSettingsPreset {
  export let preset1280x720: string;
  export let preset1920x1080: string;
  export let preset3840x2160: string;
  export let preset640x480: string;
  export let preset960x540: string;
  export let hevc1920x1080: string;
  export let hevc1920x1080WithAlpha: string;
  export let hevc3840x2160: string;
  export let hevc3840x2160WithAlpha: string;
}

namespace AVPlayer {
  export enum ActionAtItemEnd {
    Advance = 0,
    Pause = 1,
    None = 2
  }

  global['AVPlayer']['ActionAtItemEnd'] = ActionAtItemEnd;

  export enum HDRMode {
    HLG = 1,
    HDR10 = 2,
    DolbyVision = 4
  }

  global['AVPlayer']['HDRMode'] = HDRMode;

  export enum Status {
    Unknown = 0,
    ReadyToPlay = 1,
    Failed = 2
  }

  global['AVPlayer']['Status'] = Status;

  export enum TimeControlStatus {
    Paused = 0,
    WaitingToPlayAtSpecifiedRate = 1,
    Playing = 2
  }

  global['AVPlayer']['TimeControlStatus'] = TimeControlStatus;

  export let eligibleForHDRPlaybackDidChangeNotification: string;
  export let toMinimizeStalls: string;
  export let evaluatingBufferingRate: string;
  export let noItemToPlay: string;
}

namespace AVPlayerItem {
  export enum Status {
    Unknown = 0,
    ReadyToPlay = 1,
    Failed = 2
  }

  global['AVPlayerItem']['Status'] = Status;

  export let mediaSelectionDidChangeNotification: string;
  export let recommendedTimeOffsetFromLiveDidChangeNotification: string;
}

namespace AVPlayerItemLegibleOutput {
  export let default_: string;
  export let sourceAndRulesOnly: string;
}

namespace AVPlayerLooper {
  export enum Status {
    Unknown = 0,
    Ready = 1,
    Failed = 2,
    Cancelled = 3
  }

  global['AVPlayerLooper']['Status'] = Status;

}

namespace AVSampleBufferRenderSynchronizer {
  export let rateDidChangeNotification: string;
}

namespace AVSampleBufferRequest {
  export enum Direction {
    Forward = 1,
    None = 0,
    Reverse = -1
  }

  global['AVSampleBufferRequest']['Direction'] = Direction;

  export enum Mode {
    Immediate = 0,
    Scheduled = 1,
    Opportunistic = 2
  }

  global['AVSampleBufferRequest']['Mode'] = Mode;

}

namespace AVSemanticSegmentationMatte {
  export let hair: string;
  export let skin: string;
  export let teeth: string;
}

namespace AVVideoApertureMode {
  export let cleanAperture: string;
  export let encodedPixels: string;
  export let productionAperture: string;
}

namespace AVVideoCodecType {
  export let proRes422: string;
  export let proRes422HQ: string;
  export let proRes422LT: string;
  export let proRes422Proxy: string;
  export let proRes4444: string;
  export let h264: string;
  export let hevc: string;
  export let hevcWithAlpha: string;
  export let jpeg: string;
}

namespace Bundle {
  export let didLoadNotification: string;
}

namespace ByteCountFormatter {
  export enum CountStyle {
    File = 0,
    Memory = 1,
    Decimal = 2,
    Binary = 3
  }

  global['ByteCountFormatter']['CountStyle'] = CountStyle;

  export enum Units {
    UseDefault = 0,
    UseBytes = 1,
    UseKB = 2,
    UseMB = 4,
    UseGB = 8,
    UseTB = 16,
    UsePB = 32,
    UseEB = 64,
    UseZB = 128,
    UseYBOrHigher = 65280,
    UseAll = 65535
  }

  global['ByteCountFormatter']['Units'] = Units;

}

namespace CAAnimationCalculationMode {
  export let cubic: string;
  export let cubicPaced: string;
  export let discrete: string;
  export let linear: string;
  export let paced: string;
}

namespace CAAnimationRotationMode {
  export let rotateAuto: string;
  export let rotateAutoReverse: string;
}

namespace CAEmitterLayerEmitterMode {
  export let outline: string;
  export let points: string;
  export let surface: string;
  export let volume: string;
}

namespace CAEmitterLayerEmitterShape {
  export let circle: string;
  export let cuboid: string;
  export let line: string;
  export let point: string;
  export let rectangle: string;
  export let sphere: string;
}

namespace CAEmitterLayerRenderMode {
  export let additive: string;
  export let backToFront: string;
  export let oldestFirst: string;
  export let oldestLast: string;
  export let unordered: string;
}

namespace CAGradientLayerType {
  export let axial: string;
  export let conic: string;
  export let radial: string;
}

namespace CALayerContentsFilter {
  export let linear: string;
  export let nearest: string;
  export let trilinear: string;
}

namespace CALayerContentsFormat {
  export let gray8Uint: string;
  export let RGBA16Float: string;
  export let RGBA8Uint: string;
}

namespace CALayerContentsGravity {
  export let bottom: string;
  export let bottomLeft: string;
  export let bottomRight: string;
  export let center: string;
  export let left: string;
  export let resize: string;
  export let resizeAspect: string;
  export let resizeAspectFill: string;
  export let right: string;
  export let top: string;
  export let topLeft: string;
  export let topRight: string;
}

namespace CALayerCornerCurve {
  export let circular: string;
  export let continuous: string;
}

namespace CAMediaTimingFillMode {
  export let backwards: string;
  export let both: string;
  export let forwards: string;
  export let removed: string;
}

namespace CAMediaTimingFunctionName {
  export let default_: string;
  export let easeIn: string;
  export let easeInEaseOut: string;
  export let easeOut: string;
  export let linear: string;
}

namespace CAScrollLayerScrollMode {
  export let both: string;
  export let horizontally: string;
  export let none: string;
  export let vertically: string;
}

namespace CAShapeLayerFillRule {
  export let evenOdd: string;
  export let nonZero: string;
}

namespace CAShapeLayerLineCap {
  export let butt: string;
  export let round: string;
  export let square: string;
}

namespace CAShapeLayerLineJoin {
  export let bevel: string;
  export let miter: string;
  export let round: string;
}

namespace CATextLayerAlignmentMode {
  export let center: string;
  export let justified: string;
  export let left: string;
  export let natural: string;
  export let right: string;
}

namespace CATextLayerTruncationMode {
  export let end: string;
  export let middle: string;
  export let none: string;
  export let start: string;
}

namespace CATransitionSubtype {
  export let fromBottom: string;
  export let fromLeft: string;
  export let fromRight: string;
  export let fromTop: string;
}

namespace CATransitionType {
  export let fade: string;
  export let moveIn: string;
  export let push: string;
  export let reveal: string;
}

namespace CAValueFunctionName {
  export let rotateX: string;
  export let rotateY: string;
  export let rotateZ: string;
  export let scale: string;
  export let scaleX: string;
  export let scaleY: string;
  export let scaleZ: string;
  export let translate: string;
  export let translateX: string;
  export let translateY: string;
  export let translateZ: string;
}

namespace CFCalendarIdentifier {
  export let buddhistCalendar: any;
  export let chineseCalendar: any;
  export let gregorianCalendar: any;
  export let hebrewCalendar: any;
  export let cfiso8601Calendar: any;
  export let indianCalendar: any;
  export let islamicCalendar: any;
  export let islamicCivilCalendar: any;
  export let islamicTabularCalendar: any;
  export let islamicUmmAlQuraCalendar: any;
  export let japaneseCalendar: any;
  export let persianCalendar: any;
  export let republicOfChinaCalendar: any;
}

namespace CFDateFormatterKey {
  export let amSymbol: any;
  export let calendar: any;
  export let calendarName: any;
  export let defaultDate: any;
  export let defaultFormat: any;
  export let doesRelativeDateFormattingKey: any;
  export let eraSymbols: any;
  export let gregorianStartDate: any;
  export let isLenient: any;
  export let longEraSymbols: any;
  export let monthSymbols: any;
  export let pmSymbol: any;
  export let quarterSymbols: any;
  export let shortMonthSymbols: any;
  export let shortQuarterSymbols: any;
  export let shortStandaloneMonthSymbols: any;
  export let shortStandaloneQuarterSymbols: any;
  export let shortStandaloneWeekdaySymbols: any;
  export let shortWeekdaySymbols: any;
  export let standaloneMonthSymbols: any;
  export let standaloneQuarterSymbols: any;
  export let standaloneWeekdaySymbols: any;
  export let timeZone: any;
  export let twoDigitStartDate: any;
  export let veryShortMonthSymbols: any;
  export let veryShortStandaloneMonthSymbols: any;
  export let veryShortStandaloneWeekdaySymbols: any;
  export let veryShortWeekdaySymbols: any;
  export let weekdaySymbols: any;
}

namespace CFLocaleKey {
  export let alternateQuotationBeginDelimiterKey: any;
  export let alternateQuotationEndDelimiterKey: any;
  export let calendar: any;
  export let calendarIdentifier: any;
  export let collationIdentifier: any;
  export let collatorIdentifier: any;
  export let countryCode: any;
  export let currencyCode: any;
  export let currencySymbol: any;
  export let decimalSeparator: any;
  export let exemplarCharacterSet: any;
  export let groupingSeparator: any;
  export let identifier: any;
  export let languageCode: any;
  export let measurementSystem: any;
  export let quotationBeginDelimiterKey: any;
  export let quotationEndDelimiterKey: any;
  export let scriptCode: any;
  export let usesMetricSystem: any;
  export let variantCode: any;
}

namespace CFNotificationName {
  export let cfLocaleCurrentLocaleDidChange: any;
  export let cfTimeZoneSystemTimeZoneDidChange: any;
}

namespace CFNumberFormatterKey {
  export let alwaysShowDecimalSeparator: any;
  export let currencyCode: any;
  export let currencyDecimalSeparator: any;
  export let currencyGroupingSeparator: any;
  export let currencySymbol: any;
  export let decimalSeparator: any;
  export let defaultFormat: any;
  export let exponentSymbol: any;
  export let formatWidth: any;
  export let groupingSeparator: any;
  export let groupingSize: any;
  export let infinitySymbol: any;
  export let internationalCurrencySymbol: any;
  export let isLenient: any;
  export let maxFractionDigits: any;
  export let maxIntegerDigits: any;
  export let maxSignificantDigits: any;
  export let minFractionDigits: any;
  export let minIntegerDigits: any;
  export let minSignificantDigits: any;
  export let minusSign: any;
  export let multiplier: any;
  export let naNSymbol: any;
  export let negativePrefix: any;
  export let negativeSuffix: any;
  export let paddingCharacter: any;
  export let paddingPosition: any;
  export let perMillSymbol: any;
  export let percentSymbol: any;
  export let plusSign: any;
  export let positivePrefix: any;
  export let positiveSuffix: any;
  export let roundingIncrement: any;
  export let roundingMode: any;
  export let secondaryGroupingSize: any;
  export let useGroupingSeparator: any;
  export let useSignificantDigits: any;
  export let zeroSymbol: any;
}

namespace CFRunLoopMode {
  export let commonModes: any;
  export let defaultMode: any;
}

namespace CFStreamPropertyKey {
  export let appendToFile: any;
  export let dataWritten: any;
  export let fileCurrentOffset: any;
  export let socketNativeHandle: any;
  export let socketRemoteHostName: any;
  export let socketRemotePortNumber: any;
}

namespace CGAffineTransform {
  export let identity: CGAffineTransform;
}

namespace CGColor {
  export let __blackColorName: string;
  export let __clearColorName: string;
  export let conversionBlackPointCompensation: string;
  export let conversionTRCSize: string;
  export let __whiteColorName: string;
}

namespace CGColorSpace {
  export let acescgLinear: string;
  export let adobeRGB1998: string;
  export let dcip3: string;
  export let displayP3: string;
  export let displayP3_HLG: string;
  export let displayP3_PQ_EOTF: string;
  export let extendedGray: string;
  export let extendedLinearDisplayP3: string;
  export let extendedLinearGray: string;
  export let extendedLinearITUR_2020: string;
  export let extendedLinearSRGB: string;
  export let extendedSRGB: string;
  export let genericCMYK: string;
  export let genericGray: string;
  export let genericGrayGamma2_2: string;
  export let genericLab: string;
  export let genericRGB: string;
  export let genericRGBLinear: string;
  export let genericXYZ: string;
  export let itur_2020: string;
  export let itur_2020_HLG: string;
  export let itur_2020_PQ_EOTF: string;
  export let itur_709: string;
  export let linearGray: string;
  export let linearSRGB: string;
  export let rommrgb: string;
  export let sRGB: string;
}

namespace CGDisplayStream {
  export let colorSpace: string;
  export let destinationRect: string;
  export let minimumFrameTime: string;
  export let preserveAspectRatio: string;
  export let queueDepth: string;
  export let showCursor: string;
  export let sourceRect: string;
  export let yCbCrMatrix: string;
  export let yCbCrMatrix_ITU_R_601_4: string;
  export let yCbCrMatrix_ITU_R_709_2: string;
  export let yCbCrMatrix_SMPTE_240M_1995: string;
}

namespace CGFont {
  export let variationAxisDefaultValue: string;
  export let variationAxisMaxValue: string;
  export let variationAxisMinValue: string;
  export let variationAxisName: string;
}

namespace CGPDFTagProperty {
  export let actualText: any;
  export let alternativeText: any;
  export let languageText: any;
  export let titleText: any;
}

namespace CGPoint {
  export let zero: CGPoint;
}

namespace CGRect {
  export let infinite: CGRect;
  export let null_: CGRect;
  export let zero: CGRect;
}

namespace CGSize {
  export let zero: CGSize;
}

namespace CIContextOption {
  export let allowLowPower: string;
  export let cacheIntermediates: string;
  export let highQualityDownsample: string;
  export let outputColorSpace: string;
  export let outputPremultiplied: string;
  export let priorityRequestLow: string;
  export let useSoftwareRenderer: string;
  export let workingColorSpace: string;
  export let workingFormat: string;
}

namespace CIFormat {
  export let A16: number;
  export let A8: number;
  export let ABGR8: number;
  export let ARGB8: number;
  export let Af: number;
  export let Ah: number;
  export let BGRA8: number;
  export let L16: number;
  export let L8: number;
  export let LA16: number;
  export let LA8: number;
  export let LAf: number;
  export let LAh: number;
  export let Lf: number;
  export let Lh: number;
  export let R16: number;
  export let R8: number;
  export let RG16: number;
  export let RG8: number;
  export let RGBA16: number;
  export let RGBA8: number;
  export let RGBAf: number;
  export let RGBAh: number;
  export let RGf: number;
  export let RGh: number;
  export let Rf: number;
  export let Rh: number;
}

namespace CIImageAutoAdjustmentOption {
  export let crop: string;
  export let enhance: string;
  export let features: string;
  export let level: string;
  export let redEye: string;
}

namespace CIImageOption {
  export let applyOrientationProperty: string;
  export let auxiliaryDepth: string;
  export let auxiliaryDisparity: string;
  export let auxiliaryPortraitEffectsMatte: string;
  export let auxiliarySemanticSegmentationHairMatte: string;
  export let auxiliarySemanticSegmentationSkinMatte: string;
  export let auxiliarySemanticSegmentationTeethMatte: string;
  export let colorSpace: string;
  export let nearestSampling: string;
  export let properties: string;
  export let providerTileSize: string;
  export let providerUserInfo: string;
}

namespace CIImageRepresentationOption {
  export let avDepthData: string;
  export let avPortraitEffectsMatte: string;
  export let avSemanticSegmentationMattes: string;
  export let depthImage: string;
  export let disparityImage: string;
  export let portraitEffectsMatteImage: string;
  export let semanticSegmentationHairMatteImage: string;
  export let semanticSegmentationSkinMatteImage: string;
  export let semanticSegmentationTeethMatteImage: string;
}

namespace CIRAWFilterOption {
  export let activeKeys: string;
  export let allowDraftMode: string;
  export let baselineExposure: string;
  export let boostAmount: string;
  export let boostShadowAmount: string;
  export let colorNoiseReductionAmount: string;
  export let decoderVersion: string;
  export let disableGamutMap: string;
  export let enableChromaticNoiseTracking: string;
  export let enableSharpening: string;
  export let enableVendorLensCorrection: string;
  export let ignoreImageOrientation: string;
  export let imageOrientation: string;
  export let linearSpaceFilter: string;
  export let luminanceNoiseReductionAmount: string;
  export let moireAmount: string;
  export let neutralChromaticityX: string;
  export let neutralChromaticityY: string;
  export let neutralLocation: string;
  export let neutralTemperature: string;
  export let neutralTint: string;
  export let noiseReductionAmount: string;
  export let noiseReductionContrastAmount: string;
  export let noiseReductionDetailAmount: string;
  export let noiseReductionSharpnessAmount: string;
  export let scaleFactor: string;
  export let outputNativeSize: string;
  export let supportedDecoderVersions: string;
}

namespace CMImageDescriptionFlavor {
  export let mobile3GPFamily: any;
  export let isoFamily: any;
  export let quickTimeMovie: any;
}

namespace CMSampleTimingInfo {
  export let invalid: CMSampleTimingInfo;
}

namespace CMSoundDescriptionFlavor {
  export let mobile3GPFamily: any;
  export let isoFamily: any;
  export let quickTimeMovie: any;
  export let quickTimeMovieV2: any;
}

namespace CMTime {
  export let indefinite: CMTime;
  export let invalid: CMTime;
  export let negativeInfinity: CMTime;
  export let positiveInfinity: CMTime;
  export let zero: CMTime;
}

namespace CMTimeMapping {
  export let invalid: CMTimeMapping;
}

namespace CMTimeRange {
  export let invalid: CMTimeRange;
  export let zero: CMTimeRange;
}

namespace DateComponentsFormatter {
  export enum UnitsStyle {
    Positional = 0,
    Abbreviated = 1,
    Short = 2,
    Full = 3,
    SpellOut = 4,
    Brief = 5
  }

  global['DateComponentsFormatter']['UnitsStyle'] = UnitsStyle;

  export enum ZeroFormattingBehavior {
    None = 0,
    Default = 1,
    DropLeading = 2,
    DropMiddle = 4,
    DropTrailing = 8,
    DropAll = 14,
    Pad = 65536
  }

  global['DateComponentsFormatter']['ZeroFormattingBehavior'] = ZeroFormattingBehavior;

}

namespace DateFormatter {
  export enum Behavior {
    BehaviorDefault = 0,
    Behavior10_0 = 1000,
    Behavior10_4 = 1040
  }

  global['DateFormatter']['Behavior'] = Behavior;

  export enum Style {
    NoStyle = 0,
    ShortStyle = 1,
    MediumStyle = 2,
    LongStyle = 3,
    FullStyle = 4
  }

  global['DateFormatter']['Style'] = Style;

}

namespace DateIntervalFormatter {
  export enum Style {
    NoStyle = 0,
    ShortStyle = 1,
    MediumStyle = 2,
    LongStyle = 3,
    FullStyle = 4
  }

  global['DateIntervalFormatter']['Style'] = Style;

}

namespace Decimal {
  export type RoundingMode = NSDecimalNumber;
  export type CalculationError = NSDecimalNumber;
  export type FloatLiteralType = number;
  export type IntegerLiteralType = number;
  export type Magnitude = number;
  export type Stride = number;
}

namespace DistributedNotificationCenter {
  export enum Options {
    DeliverImmediately = 1,
    PostToAllSessions = 2
  }

  global['DistributedNotificationCenter']['Options'] = Options;

  export enum SuspensionBehavior {
    Drop = 1,
    Coalesce = 2,
    Hold = 3,
    DeliverImmediately = 4
  }

  global['DistributedNotificationCenter']['SuspensionBehavior'] = SuspensionBehavior;

  export let localNotificationCenterType: string;
}

namespace EnergyFormatter {
  export enum Unit {
    Joule = 11,
    Kilojoule = 14,
    Calorie = 1793,
    Kilocalorie = 1794
  }

  global['EnergyFormatter']['Unit'] = Unit;

}

namespace FileAttributeKey {
  export let appendOnly: string;
  export let busy: string;
  export let creationDate: string;
  export let deviceIdentifier: string;
  export let extensionHidden: string;
  export let groupOwnerAccountID: string;
  export let groupOwnerAccountName: string;
  export let hfsCreatorCode: string;
  export let hfsTypeCode: string;
  export let immutable: string;
  export let modificationDate: string;
  export let ownerAccountID: string;
  export let ownerAccountName: string;
  export let posixPermissions: string;
  export let protectionKey: string;
  export let referenceCount: string;
  export let size: string;
  export let systemFileNumber: string;
  export let systemFreeNodes: string;
  export let systemFreeSize: string;
  export let systemNodes: string;
  export let systemNumber: string;
  export let systemSize: string;
  export let type: string;
}

namespace FileAttributeType {
  export let typeBlockSpecial: string;
  export let typeCharacterSpecial: string;
  export let typeDirectory: string;
  export let typeRegular: string;
  export let typeSocket: string;
  export let typeSymbolicLink: string;
  export let typeUnknown: string;
}

namespace FileHandle {
  export let readCompletionNotification: string;
}

namespace FileManager {
  export enum DirectoryEnumerationOptions {
    SkipsSubdirectoryDescendants = 1,
    SkipsPackageDescendants = 2,
    SkipsHiddenFiles = 4,
    IncludesDirectoriesPostOrder = 8,
    ProducesRelativePathURLs = 16
  }

  global['FileManager']['DirectoryEnumerationOptions'] = DirectoryEnumerationOptions;

  export enum ItemReplacementOptions {
    UsingNewMetadataOnly = 1,
    WithoutDeletingBackupItem = 2
  }

  global['FileManager']['ItemReplacementOptions'] = ItemReplacementOptions;

  export enum UnmountOptions {
    AllPartitionsAndEjectDisk = 1,
    WithoutUI = 2
  }

  global['FileManager']['UnmountOptions'] = UnmountOptions;

  export enum SearchPathDirectory {
    ApplicationDirectory = 1,
    DemoApplicationDirectory = 2,
    DeveloperApplicationDirectory = 3,
    AdminApplicationDirectory = 4,
    LibraryDirectory = 5,
    DeveloperDirectory = 6,
    UserDirectory = 7,
    DocumentationDirectory = 8,
    DocumentDirectory = 9,
    CoreServiceDirectory = 10,
    AutosavedInformationDirectory = 11,
    DesktopDirectory = 12,
    CachesDirectory = 13,
    ApplicationSupportDirectory = 14,
    DownloadsDirectory = 15,
    InputMethodsDirectory = 16,
    MoviesDirectory = 17,
    MusicDirectory = 18,
    PicturesDirectory = 19,
    PrinterDescriptionDirectory = 20,
    SharedPublicDirectory = 21,
    PreferencePanesDirectory = 22,
    ApplicationScriptsDirectory = 23,
    ItemReplacementDirectory = 99,
    AllApplicationsDirectory = 100,
    AllLibrariesDirectory = 101,
    TrashDirectory = 102
  }

  global['FileManager']['SearchPathDirectory'] = SearchPathDirectory;

  export enum SearchPathDomainMask {
    UserDomainMask = 1,
    LocalDomainMask = 2,
    NetworkDomainMask = 4,
    SystemDomainMask = 8,
    AllDomainsMask = 65535
  }

  global['FileManager']['SearchPathDomainMask'] = SearchPathDomainMask;

  export enum URLRelationship {
    Contains = 0,
    Same = 1,
    Other = 2
  }

  global['FileManager']['URLRelationship'] = URLRelationship;

  export enum VolumeEnumerationOptions {
    SkipHiddenVolumes = 2,
    ProduceFileReferenceURLs = 4
  }

  global['FileManager']['VolumeEnumerationOptions'] = VolumeEnumerationOptions;

}

namespace FileProtectionType {
  export let complete: string;
  export let completeUnlessOpen: string;
  export let completeUntilFirstUserAuthentication: string;
  export let none: string;
}

namespace FileWrapper {
  export enum ReadingOptions {
    Immediate = 1,
    WithoutMapping = 2
  }

  global['FileWrapper']['ReadingOptions'] = ReadingOptions;

  export enum WritingOptions {
    Atomic = 1,
    WithNameUpdating = 2
  }

  global['FileWrapper']['WritingOptions'] = WritingOptions;

}

namespace Formatter {
  export enum Context {
    Unknown = 0,
    Dynamic = 1,
    Standalone = 2,
    ListItem = 3,
    BeginningOfSentence = 4,
    MiddleOfSentence = 5
  }

  global['Formatter']['Context'] = Context;

  export enum UnitStyle {
    Short = 1,
    Medium = 2,
    Long = 3
  }

  global['Formatter']['UnitStyle'] = UnitStyle;

}

namespace HTTPCookie {
  export enum AcceptPolicy {
    Always = 0,
    Never = 1,
    OnlyFromMainDocumentDomain = 2
  }

  global['HTTPCookie']['AcceptPolicy'] = AcceptPolicy;

}

namespace HTTPCookiePropertyKey {
  export let comment: string;
  export let commentURL: string;
  export let discard: string;
  export let domain: string;
  export let expires: string;
  export let maximumAge: string;
  export let name: string;
  export let originURL: string;
  export let path: string;
  export let port: string;
  export let sameSitePolicy: string;
  export let secure: string;
  export let value: string;
  export let version: string;
}

namespace HTTPCookieStringPolicy {
  export let sameSiteLax: string;
  export let sameSiteStrict: string;
}

namespace ISO8601DateFormatter {
  export enum Options {
    WithYear = 1,
    WithMonth = 2,
    WithWeekOfYear = 4,
    WithDay = 16,
    WithTime = 32,
    WithTimeZone = 64,
    WithSpaceBetweenDateAndTime = 128,
    WithDashSeparatorInDate = 256,
    WithColonSeparatorInTime = 512,
    WithColonSeparatorInTimeZone = 1024,
    WithFractionalSeconds = 2048,
    WithFullDate = 275,
    WithFullTime = 1632,
    WithInternetDateTime = 1907
  }

  global['ISO8601DateFormatter']['Options'] = Options;

}

namespace JSONSerialization {
  export enum ReadingOptions {
    MutableContainers = 1,
    MutableLeaves = 2,
    FragmentsAllowed = 4,
    AllowFragments = 4
  }

  global['JSONSerialization']['ReadingOptions'] = ReadingOptions;

  export enum WritingOptions {
    PrettyPrinted = 1,
    SortedKeys = 2,
    FragmentsAllowed = 4,
    WithoutEscapingSlashes = 8
  }

  global['JSONSerialization']['WritingOptions'] = WritingOptions;

}

namespace LengthFormatter {
  export enum Unit {
    Millimeter = 8,
    Centimeter = 9,
    Meter = 11,
    Kilometer = 14,
    Inch = 1281,
    Foot = 1282,
    Yard = 1283,
    Mile = 1284
  }

  global['LengthFormatter']['Unit'] = Unit;

}

namespace MassFormatter {
  export enum Unit {
    Gram = 11,
    Kilogram = 14,
    Ounce = 1537,
    Pound = 1538,
    Stone = 1539
  }

  global['MassFormatter']['Unit'] = Unit;

}

namespace MeasurementFormatter {
  export enum UnitOptions {
    ProvidedUnit = 1,
    NaturalScale = 2,
    TemperatureWithoutUnit = 4
  }

  global['MeasurementFormatter']['UnitOptions'] = UnitOptions;

}

namespace NSAccessibility {
  export enum AnnotationPosition {
    FullRange = 0,
    Start = 1,
    End = 2
  }

  global['NSAccessibility']['AnnotationPosition'] = AnnotationPosition;

  export enum Orientation {
    Unknown = 0,
    Vertical = 1,
    Horizontal = 2
  }

  global['NSAccessibility']['Orientation'] = Orientation;

  export enum RulerMarkerType {
    Unknown = 0,
    TabStopLeft = 1,
    TabStopRight = 2,
    TabStopCenter = 3,
    TabStopDecimal = 4,
    IndentHead = 5,
    IndentTail = 6,
    IndentFirstLine = 7
  }

  global['NSAccessibility']['RulerMarkerType'] = RulerMarkerType;

  export enum SortDirection {
    Unknown = 0,
    Ascending = 1,
    Descending = 2
  }

  global['NSAccessibility']['SortDirection'] = SortDirection;

  export enum Units {
    Unknown = 0,
    Inches = 1,
    Centimeters = 2,
    Points = 3,
    Picas = 4
  }

  global['NSAccessibility']['Units'] = Units;

  export let activationPoint: string;
  export let allowedValues: string;
  export let alternateUIVisible: string;
  export let element: string;
  export let label: string;
  export let location: string;
  export let announcement: string;
  export let announcementRequested: string;
  export let applicationActivated: string;
  export let applicationDeactivated: string;
  export let applicationHidden: string;
  export let application: string;
  export let applicationShown: string;
  export let ascending: string;
  export let attributedStringForRange: string;
  export let boundsForRange: string;
  export let browser: string;
  export let busyIndicator: string;
  export let button: string;
  export let cancel: string;
  export let cancelButton: string;
  export let cellForColumnAndRow: string;
  export let cell: string;
  export let centerTabStop: string;
  export let centimeters: string;
  export let checkBox: string;
  export let children: string;
  export let clearButton: string;
  export let closeButton: string;
  export let collectionListSubrole: string;
  export let colorWell: string;
  export let columnCount: string;
  export let columnHeaderUIElements: string;
  export let columnIndexRange: string;
  export let column: string;
  export let columnTitles: string;
  export let columns: string;
  export let comboBox: string;
  export let confirm: string;
  export let containsProtectedContent: string;
  export let contentList: string;
  export let contents: string;
  export let created: string;
  export let criticalValue: string;
  export let decimalTabStop: string;
  export let decrement: string;
  export let decrementArrow: string;
  export let decrementButton: string;
  export let decrementPage: string;
  export let defaultButton: string;
  export let definitionList: string;
  export let delete_: string;
  export let descending: string;
  export let description: string;
  export let descriptionList: string;
  export let dialog: string;
  export let disclosedByRow: string;
  export let disclosedRows: string;
  export let disclosing: string;
  export let disclosureLevel: string;
  export let disclosureTriangle: string;
  export let document: string;
  export let drawerCreated: string;
  export let drawer: string;
  export let edited: string;
  export let enabled: string;
  export let ErrorCodeExceptionInfo: string;
  export let expanded: string;
  export let extrasMenuBar: string;
  export let filename: string;
  export let firstLineIndent: string;
  export let floatingWindow: string;
  export let focused: string;
  export let focusedUIElement: string;
  export let focusedUIElementChanged: string;
  export let focusedWindow: string;
  export let focusedWindowChanged: string;
  export let fontFamily: string;
  export let fontName: string;
  export let fontSize: string;
  export let frontmost: string;
  export let fullScreenButton: string;
  export let grid: string;
  export let group: string;
  export let growArea: string;
  export let handle: string;
  export let handles: string;
  export let headIndent: string;
  export let header: string;
  export let help: string;
  export let helpTagCreated: string;
  export let helpTag: string;
  export let hidden: string;
  export let horizontal: string;
  export let horizontalScrollBar: string;
  export let horizontalUnitDescription: string;
  export let horizontalUnits: string;
  export let identifier: string;
  export let image: string;
  export let inches: string;
  export let increment: string;
  export let incrementArrow: string;
  export let incrementButton: string;
  export let incrementPage: string;
  export let incrementor: string;
  export let index: string;
  export let insertionPointLineNumber: string;
  export let labelUIElements: string;
  export let labelValue: string;
  export let layoutArea: string;
  export let layoutChanged: string;
  export let layoutItem: string;
  export let layoutPointForScreenPoint: string;
  export let layoutSizeForScreenSize: string;
  export let leftTabStop: string;
  export let levelIndicator: string;
  export let lineForIndex: string;
  export let link: string;
  export let linkedUIElements: string;
  export let list: string;
  export let main: string;
  export let mainWindow: string;
  export let mainWindowChanged: string;
  export let markerGroupUIElement: string;
  export let markerType: string;
  export let markerTypeDescription: string;
  export let markerUIElements: string;
  export let markerValues: string;
  export let matte: string;
  export let maxValue: string;
  export let menuBar: string;
  export let menuBarItem: string;
  export let menuButton: string;
  export let menuItem: string;
  export let menu: string;
  export let minValue: string;
  export let minimizeButton: string;
  export let minimized: string;
  export let modal: string;
  export let moved: string;
  export let nextContents: string;
  export let numberOfCharacters: string;
  export let orderedByRow: string;
  export let orientation: string;
  export let outline: string;
  export let outlineRow: string;
  export let overflowButton: string;
  export let pageRole: string;
  export let parent: string;
  export let picas: string;
  export let pick: string;
  export let placeholderValue: string;
  export let points: string;
  export let popUpButton: string;
  export let popover: string;
  export let position: string;
  export let press: string;
  export let previousContents: string;
  export let priority: string;
  export let progressIndicator: string;
  export let proxy: string;
  export let rtfForRange: string;
  export let radioButton: string;
  export let radioGroup: string;
  export let raise: string;
  export let rangeForIndex: string;
  export let rangeForLine: string;
  export let rangeForPosition: string;
  export let ratingIndicator: string;
  export let relevanceIndicator: string;
  export let required: string;
  export let resized: string;
  export let rightTabStop: string;
  export let role: string;
  export let roleDescription: string;
  export let rowCollapsed: string;
  export let rowCount: string;
  export let rowCountChanged: string;
  export let rowExpanded: string;
  export let rowHeaderUIElements: string;
  export let rowIndexRange: string;
  export let row: string;
  export let rows: string;
  export let rulerMarker: string;
  export let ruler: string;
  export let screenPointForLayoutPoint: string;
  export let screenSizeForLayoutSize: string;
  export let scrollArea: string;
  export let scrollBar: string;
  export let searchButton: string;
  export let searchField: string;
  export let searchMenu: string;
  export let sectionListSubrole: string;
  export let secureTextField: string;
  export let selected: string;
  export let selectedCells: string;
  export let selectedCellsChanged: string;
  export let selectedChildren: string;
  export let selectedChildrenChanged: string;
  export let selectedChildrenMoved: string;
  export let selectedColumns: string;
  export let selectedColumnsChanged: string;
  export let selectedRows: string;
  export let selectedRowsChanged: string;
  export let selectedText: string;
  export let selectedTextChanged: string;
  export let selectedTextRange: string;
  export let selectedTextRanges: string;
  export let servesAsTitleForUIElements: string;
  export let sharedCharacterRange: string;
  export let sharedFocusElements: string;
  export let sharedTextUIElements: string;
  export let sheetCreated: string;
  export let sheet: string;
  export let showAlternateUI: string;
  export let showDefaultUI: string;
  export let showMenu: string;
  export let shownMenu: string;
  export let size: string;
  export let slider: string;
  export let sortButton: string;
  export let sortDirection: string;
  export let splitGroup: string;
  export let splitter: string;
  export let splitters: string;
  export let standardWindow: string;
  export let staticText: string;
  export let stringForRange: string;
  export let styleRangeForIndex: string;
  export let subrole: string;
  export let switch_: string;
  export let systemDialog: string;
  export let systemFloatingWindow: string;
  export let systemWide: string;
  export let tabButtonSubrole: string;
  export let tabGroup: string;
  export let table: string;
  export let tableRow: string;
  export let tabs: string;
  export let tailIndent: string;
  export let textArea: string;
  export let textAttachment: string;
  export let textField: string;
  export let textLink: string;
  export let timeline: string;
  export let title: string;
  export let titleChanged: string;
  export let titleUIElement: string;
  export let toggle: string;
  export let toolbarButton: string;
  export let toolbar: string;
  export let topLevelUIElement: string;
  export let uiElementDestroyed: string;
  export let uiElements: string;
  export let url: string;
  export let unitDescription: string;
  export let units: string;
  export let unitsChanged: string;
  export let unknown: string;
  export let value: string;
  export let valueChanged: string;
  export let valueDescription: string;
  export let valueIndicator: string;
  export let vertical: string;
  export let verticalScrollBar: string;
  export let verticalUnitDescription: string;
  export let verticalUnits: string;
  export let visibleCells: string;
  export let visibleCharacterRange: string;
  export let visibleChildren: string;
  export let visibleColumns: string;
  export let visibleName: string;
  export let visibleRows: string;
  export let warningValue: string;
  export let window: string;
  export let windowCreated: string;
  export let windowDeminiaturized: string;
  export let windowMiniaturized: string;
  export let windowMoved: string;
  export let windowResized: string;
  export let windows: string;
  export let zoomButton: string;
}

namespace NSAccessibilityCustomRotor {
  export enum SearchDirection {
    Previous = 0,
    Next = 1
  }

  global['NSAccessibilityCustomRotor']['SearchDirection'] = SearchDirection;

  export enum RotorType {
    Custom = 0,
    Any = 1,
    Annotation = 2,
    BoldText = 3,
    Heading = 4,
    HeadingLevel1 = 5,
    HeadingLevel2 = 6,
    HeadingLevel3 = 7,
    HeadingLevel4 = 8,
    HeadingLevel5 = 9,
    HeadingLevel6 = 10,
    Image = 11,
    ItalicText = 12,
    Landmark = 13,
    Link = 14,
    List = 15,
    MisspelledWord = 16,
    Table = 17,
    TextField = 18,
    UnderlinedText = 19,
    VisitedLink = 20
  }

  global['NSAccessibilityCustomRotor']['RotorType'] = RotorType;

}

namespace NSAlert {
  export enum Style {
    Warning = 0,
    Informational = 1,
    Critical = 2
  }

  global['NSAlert']['Style'] = Style;

}

namespace NSAnimation {
  export enum BlockingMode {
    Blocking = 0,
    Nonblocking = 1,
    NonblockingThreaded = 2
  }

  global['NSAnimation']['BlockingMode'] = BlockingMode;

  export enum Curve {
    EaseInOut = 0,
    EaseIn = 1,
    EaseOut = 2,
    Linear = 3
  }

  global['NSAnimation']['Curve'] = Curve;

  export let progressMarkUserInfoKey: string;
  export let progressMarkNotification: string;
  export type Progress = number;
}

namespace NSAppKitVersion {
  export let current: number;
  export let macOS10_0: number;
  export let macOS10_1: number;
  export let macOS10_10: number;
  export let macOS10_10_2: number;
  export let macOS10_10_3: number;
  export let macOS10_10_4: number;
  export let macOS10_10_5: number;
  export let macOS10_10_Max: number;
  export let macOS10_11: number;
  export let macOS10_11_1: number;
  export let macOS10_11_2: number;
  export let macOS10_11_3: number;
  export let macOS10_12: number;
  export let macOS10_12_1: number;
  export let macOS10_12_2: number;
  export let macOS10_13: number;
  export let macOS10_13_1: number;
  export let macOS10_13_2: number;
  export let macOS10_13_4: number;
  export let number10_14: number;
  export let number10_14_1: number;
  export let number10_14_2: number;
  export let number10_14_3: number;
  export let number10_14_4: number;
  export let number10_14_5: number;
  export let macOS10_2: number;
  export let macOS10_2_3: number;
  export let macOS10_3: number;
  export let macOS10_3_2: number;
  export let macOS10_3_3: number;
  export let macOS10_3_5: number;
  export let macOS10_3_7: number;
  export let macOS10_3_9: number;
  export let macOS10_4: number;
  export let macOS10_4_1: number;
  export let macOS10_4_3: number;
  export let macOS10_4_4: number;
  export let macOS10_4_7: number;
  export let macOS10_5: number;
  export let macOS10_5_2: number;
  export let macOS10_5_3: number;
  export let macOS10_6: number;
  export let macOS10_7: number;
  export let macOS10_7_2: number;
  export let macOS10_7_3: number;
  export let macOS10_7_4: number;
  export let macOS10_8: number;
  export let macOS10_9: number;
  export let numberWithColumnResizingBrowser: number;
  export let numberWithContinuousScrollingBrowser: number;
  export let numberWithCursorSizeSupport: number;
  export let numberWithCustomSheetPosition: number;
  export let numberWithDeferredWindowDisplaySupport: number;
  export let numberWithDirectionalTabs: number;
  export let numberWithDockTilePlugInSupport: number;
  export let numberWithPatternColorLeakFix: number;
}

namespace NSAppearance {
  export let accessibilityHighContrastAqua: string;
  export let accessibilityHighContrastDarkAqua: string;
  export let accessibilityHighContrastVibrantDark: string;
  export let accessibilityHighContrastVibrantLight: string;
  export let aqua: string;
  export let darkAqua: string;
  export let vibrantDark: string;
  export let vibrantLight: string;
}

namespace NSAppleEventDescriptor {
  export enum SendOptions {
    NoReply = 1,
    QueueReply = 2,
    WaitForReply = 3,
    NeverInteract = 16,
    CanInteract = 32,
    AlwaysInteract = 48,
    CanSwitchLayer = 64,
    DontRecord = 4096,
    DontExecute = 8192,
    DontAnnotate = 65536,
    DefaultOptions = 35
  }

  global['NSAppleEventDescriptor']['SendOptions'] = SendOptions;

}

namespace NSAppleEventManager {
  export type SuspensionID = OpaquePointer;
}

namespace NSAppleScript {
  export let errorAppName: string;
  export let errorBriefMessage: string;
  export let errorMessage: string;
  export let errorNumber: string;
  export let errorRange: string;
}

namespace NSApplication {
  export enum ActivationOptions {
    ActivateAllWindows = 1,
    ActivateIgnoringOtherApps = 2
  }

  global['NSApplication']['ActivationOptions'] = ActivationOptions;

  export enum ActivationPolicy {
    Regular = 0,
    Accessory = 1,
    Prohibited = 2
  }

  global['NSApplication']['ActivationPolicy'] = ActivationPolicy;

  export enum DelegateReply {
    Success = 0,
    Cancel = 1,
    Failure = 2
  }

  global['NSApplication']['DelegateReply'] = DelegateReply;

  export enum OcclusionState {
    Visible = 2
  }

  global['NSApplication']['OcclusionState'] = OcclusionState;

  export enum PresentationOptions {
    Default = 0,
    AutoHideDock = 1,
    HideDock = 2,
    AutoHideMenuBar = 4,
    HideMenuBar = 8,
    DisableAppleMenu = 16,
    DisableProcessSwitching = 32,
    DisableForceQuit = 64,
    DisableSessionTermination = 128,
    DisableHideApplication = 256,
    DisableMenuBarTransparency = 512,
    FullScreen = 1024,
    AutoHideToolbar = 2048,
    DisableCursorLocationAssistance = 4096
  }

  global['NSApplication']['PresentationOptions'] = PresentationOptions;

  export enum PrintReply {
    PrintingCancelled = 0,
    PrintingSuccess = 1,
    PrintingFailure = 3,
    PrintingReplyLater = 2
  }

  global['NSApplication']['PrintReply'] = PrintReply;

  export enum TerminateReply {
    TerminateCancel = 0,
    TerminateNow = 1,
    TerminateLater = 2
  }

  global['NSApplication']['TerminateReply'] = TerminateReply;

  export enum RemoteNotificationType {
    None = 0,
    Badge = 1,
    Sound = 2,
    Alert = 4
  }

  global['NSApplication']['RemoteNotificationType'] = RemoteNotificationType;

  export enum RequestUserAttentionType {
    CriticalRequest = 0,
    InformationalRequest = 10
  }

  global['NSApplication']['RequestUserAttentionType'] = RequestUserAttentionType;

  export enum WindowListOptions {
    OrderedFrontToBack = 1
  }

  global['NSApplication']['WindowListOptions'] = WindowListOptions;

  export let applicationIcon: string;
  export let applicationName: string;
  export let applicationVersion: string;
  export let credits: string;
  export let version: string;
  export let alertFirstButtonReturn: number;
  export let alertSecondButtonReturn: number;
  export let alertThirdButtonReturn: number;
  export let didBecomeActiveNotification: string;
  export let didChangeOcclusionStateNotification: string;
  export let didChangeScreenParametersNotification: string;
  export let didFinishLaunchingNotification: string;
  export let didFinishRestoringWindowsNotification: string;
  export let didHideNotification: string;
  export let didResignActiveNotification: string;
  export let didUnhideNotification: string;
  export let didUpdateNotification: string;
  export let launchIsDefaultUserInfoKey: string;
  export let launchUserNotificationUserInfoKey: string;
  export let willBecomeActiveNotification: string;
  export let willFinishLaunchingNotification: string;
  export let willHideNotification: string;
  export let willResignActiveNotification: string;
  export let willTerminateNotification: string;
  export let willUnhideNotification: string;
  export let willUpdateNotification: string;
  export let abort: number;
  export let cancel: number;
  export let continue_: number;
  export let OK: number;
  export let stop: number;
  export type ModalSession = OpaquePointer;
}

namespace NSArray {
  export type Iterator = NSFastEnumerationIterator;
}

namespace NSAttributedString {
  export enum SpellingState {
    SpellingFlag = 1,
    GrammarFlag = 2
  }

  global['NSAttributedString']['SpellingState'] = SpellingState;

  export enum EnumerationOptions {
    Reverse = 2,
    LongestEffectiveRangeNotRequired = 1048576
  }

  global['NSAttributedString']['EnumerationOptions'] = EnumerationOptions;

  export let accessibilityAnnotationTextAttribute: string;
  export let accessibilityAttachment: string;
  export let accessibilityAutocorrected: string;
  export let accessibilityBackgroundColor: string;
  export let accessibilityCustomText: string;
  export let accessibilityFont: string;
  export let accessibilityForegroundColor: string;
  export let accessibilityLanguage: string;
  export let accessibilityLink: string;
  export let accessibilityListItemIndex: string;
  export let accessibilityListItemLevel: string;
  export let accessibilityListItemPrefix: string;
  export let accessibilityMarkedMisspelled: string;
  export let accessibilityMisspelled: string;
  export let accessibilityShadow: string;
  export let accessibilityStrikethroughColor: string;
  export let accessibilityStrikethrough: string;
  export let accessibilitySuperscript: string;
  export let accessibilityAlignment: string;
  export let accessibilityUnderlineColor: string;
  export let accessibilityUnderline: string;
  export let appearance: string;
  export let attachment: string;
  export let author: string;
  export let backgroundColor: string;
  export let baseURL: string;
  export let baselineOffset: string;
  export let bottomMargin: string;
  export let category: string;
  export let characterEncoding: string;
  export let cocoaVersion: string;
  export let comment: string;
  export let company: string;
  export let converted: string;
  export let copyright: string;
  export let creationTime: string;
  export let cursor: string;
  export let defaultAttributes: string;
  export let defaultTabInterval: string;
  export let docFormat: string;
  export let documentType: string;
  export let editor: string;
  export let excludedElements: string;
  export let expansion: string;
  export let fileType: string;
  export let font: string;
  export let foregroundColor: string;
  export let glyphInfo: string;
  export let html: string;
  export let hyphenationFactor: string;
  export let kern: string;
  export let keywords: string;
  export let leftMargin: string;
  export let ligature: string;
  export let link: string;
  export let macSimpleText: string;
  export let manager: string;
  export let markedClauseSegment: string;
  export let modificationTime: string;
  export let obliqueness: string;
  export let officeOpenXML: string;
  export let openDocument: string;
  export let paperSize: string;
  export let paragraphStyle: string;
  export let plain: string;
  export let prefixSpaces: string;
  export let rtfd: string;
  export let rtf: string;
  export let readOnly: string;
  export let rightMargin: string;
  export let shadow: string;
  export let sourceTextScaling: string;
  export let spellingState: string;
  export let strikethroughColor: string;
  export let strikethroughStyle: string;
  export let strokeColor: string;
  export let strokeWidth: string;
  export let subject: string;
  export let superscript: string;
  export let targetTextScaling: string;
  export let textAlternatives: string;
  export let textEffect: string;
  export let letterpressStyle: string;
  export let textEncodingName: string;
  export let orientation: string;
  export let range: string;
  export let textLayoutSections: string;
  export let textScaling: string;
  export let textSizeMultiplier: string;
  export let timeout: string;
  export let title: string;
  export let toolTip: string;
  export let topMargin: string;
  export let underlineColor: string;
  export let underlineStyle: string;
  export let verticalGlyphForm: string;
  export let viewMode: string;
  export let viewSize: string;
  export let viewZoom: string;
  export let webArchive: string;
  export let webPreferences: string;
  export let webResourceLoadDelegate: string;
  export let wordML: string;
  export let writingDirection: string;
}

namespace NSBackgroundActivityScheduler {
  export enum Result {
    Finished = 1,
    Deferred = 2
  }

  global['NSBackgroundActivityScheduler']['Result'] = Result;

}

namespace NSBezierPath {
  export enum ElementType {
    MoveTo = 0,
    LineTo = 1,
    CurveTo = 2,
    ClosePath = 3
  }

  global['NSBezierPath']['ElementType'] = ElementType;

  export enum LineCapStyle {
    Butt = 0,
    Round = 1,
    Square = 2
  }

  global['NSBezierPath']['LineCapStyle'] = LineCapStyle;

  export enum LineJoinStyle {
    Miter = 0,
    Round = 1,
    Bevel = 2
  }

  global['NSBezierPath']['LineJoinStyle'] = LineJoinStyle;

  export enum WindingRule {
    NonZero = 0,
    EvenOdd = 1
  }

  global['NSBezierPath']['WindingRule'] = WindingRule;

  export let bevel: NSBezierPath.LineJoinStyle;
  export let butt: NSBezierPath.LineCapStyle;
  export let closePath: NSBezierPath.ElementType;
  export let curveTo: NSBezierPath.ElementType;
  export let evenOdd: NSBezierPath.WindingRule;
  export let lineTo: NSBezierPath.ElementType;
  export let miter: NSBezierPath.LineJoinStyle;
  export let moveTo: NSBezierPath.ElementType;
  export let nonZero: NSBezierPath.WindingRule;
  export let round: NSBezierPath.LineCapStyle;
  export let square: NSBezierPath.LineCapStyle;
}

namespace NSBindingInfoKey {
  export let observedKeyPath: string;
  export let observedObject: string;
  export let options: string;
}

namespace NSBindingName {
  export let alignment: string;
  export let alternateImage: string;
  export let alternateTitle: string;
  export let animate: string;
  export let animationDelay: string;
  export let argument: string;
  export let attributedString: string;
  export let contentArray: string;
  export let contentArrayForMultipleSelection: string;
  export let content: string;
  export let contentDictionary: string;
  export let contentHeight: string;
  export let contentObject: string;
  export let contentObjects: string;
  export let contentSet: string;
  export let contentValues: string;
  export let contentWidth: string;
  export let criticalValue: string;
  export let data: string;
  export let displayPatternTitle: string;
  export let displayPatternValue: string;
  export let documentEdited: string;
  export let doubleClickArgument: string;
  export let doubleClickTarget: string;
  export let editable: string;
  export let enabled: string;
  export let excludedKeys: string;
  export let filterPredicate: string;
  export let font: string;
  export let fontBold: string;
  export let fontFamilyName: string;
  export let fontItalic: string;
  export let fontName: string;
  export let fontSize: string;
  export let headerTitle: string;
  export let hidden: string;
  export let image: string;
  export let includedKeys: string;
  export let initialKey: string;
  export let initialValue: string;
  export let isIndeterminate: string;
  export let label: string;
  export let localizedKeyDictionary: string;
  export let managedObjectContext: string;
  export let maxValue: string;
  export let maxWidth: string;
  export let maximumRecents: string;
  export let minValue: string;
  export let minWidth: string;
  export let mixedStateImage: string;
  export let offStateImage: string;
  export let onStateImage: string;
  export let positioningRect: string;
  export let predicate: string;
  export let recentSearches: string;
  export let representedFilename: string;
  export let rowHeight: string;
  export let selectedIdentifier: string;
  export let selectedIndex: string;
  export let selectedLabel: string;
  export let selectedObject: string;
  export let selectedObjects: string;
  export let selectedTag: string;
  export let selectedValue: string;
  export let selectedValues: string;
  export let selectionIndexPaths: string;
  export let selectionIndexes: string;
  export let sortDescriptors: string;
  export let target: string;
  export let textColor: string;
  export let title: string;
  export let toolTip: string;
  export let transparent: string;
  export let value: string;
  export let valuePath: string;
  export let valueURL: string;
  export let visible: string;
  export let warningValue: string;
  export let width: string;
}

namespace NSBindingOption {
  export let allowsEditingMultipleValuesSelection: string;
  export let allowsNullArgument: string;
  export let alwaysPresentsApplicationModalAlerts: string;
  export let conditionallySetsEditable: string;
  export let conditionallySetsEnabled: string;
  export let conditionallySetsHidden: string;
  export let contentPlacementTag: string;
  export let continuouslyUpdatesValue: string;
  export let createsSortDescriptor: string;
  export let deletesObjectsOnRemove: string;
  export let displayName: string;
  export let displayPattern: string;
  export let handlesContentAsCompoundValue: string;
  export let insertsNullPlaceholder: string;
  export let invokesSeparatelyWithArrayObjects: string;
  export let multipleValuesPlaceholder: string;
  export let noSelectionPlaceholder: string;
  export let notApplicablePlaceholder: string;
  export let nullPlaceholder: string;
  export let predicateFormat: string;
  export let raisesForNotApplicableKeys: string;
  export let selectorName: string;
  export let selectsAllWhenSettingContent: string;
  export let validatesImmediately: string;
  export let valueTransformer: string;
  export let valueTransformerName: string;
}

namespace NSBitmapImageRep {
  export enum Format {
    AlphaFirst = 1,
    AlphaNonpremultiplied = 2,
    FloatingPointSamples = 4,
    SixteenBitLittleEndian = 256,
    ThirtyTwoBitLittleEndian = 512,
    SixteenBitBigEndian = 1024,
    ThirtyTwoBitBigEndian = 2048
  }

  global['NSBitmapImageRep']['Format'] = Format;

  export enum FileType {
    TIFF = 0,
    BMP = 1,
    GIF = 2,
    JPEG = 3,
    PNG = 4,
    JPEG2000 = 5
  }

  global['NSBitmapImageRep']['FileType'] = FileType;

  export enum LoadStatus {
    UnknownType = -1,
    ReadingHeader = -2,
    WillNeedAllData = -3,
    InvalidData = -4,
    UnexpectedEOF = -5,
    Completed = -6
  }

  global['NSBitmapImageRep']['LoadStatus'] = LoadStatus;

  export enum TIFFCompression {
    None = 1,
    CCITTFAX3 = 3,
    CCITTFAX4 = 4,
    LZW = 5,
    JPEG = 6,
    NEXT = 32766,
    PackBits = 32773,
    OldJPEG = 32865
  }

  global['NSBitmapImageRep']['TIFFCompression'] = TIFFCompression;

  export let colorSyncProfileData: string;
  export let compressionFactor: string;
  export let compressionMethod: string;
  export let currentFrame: string;
  export let currentFrameDuration: string;
  export let ditherTransparency: string;
  export let exifData: string;
  export let fallbackBackgroundColor: string;
  export let frameCount: string;
  export let gamma: string;
  export let interlaced: string;
  export let loopCount: string;
  export let progressive: string;
  export let rgbColorTable: string;
}

namespace NSBox {
  export enum BoxType {
    Primary = 0,
    Separator = 2,
    Custom = 4
  }

  global['NSBox']['BoxType'] = BoxType;

  export enum TitlePosition {
    NoTitle = 0,
    AboveTop = 1,
    AtTop = 2,
    BelowTop = 3,
    AboveBottom = 4,
    AtBottom = 5,
    BelowBottom = 6
  }

  global['NSBox']['TitlePosition'] = TitlePosition;

  export let primary: NSBox.BoxType;
}

namespace NSBrowser {
  export enum ColumnResizingType {
    NoColumnResizing = 0,
    AutoColumnResizing = 1,
    UserColumnResizing = 2
  }

  global['NSBrowser']['ColumnResizingType'] = ColumnResizingType;

  export enum DropOperation {
    On = 0,
    Above = 1
  }

  global['NSBrowser']['DropOperation'] = DropOperation;

  export let columnConfigurationDidChangeNotification: string;
  export type ColumnsAutosaveName = String;
}

namespace NSButton {
  export enum BezelStyle {
    Rounded = 1,
    RegularSquare = 2,
    Disclosure = 5,
    ShadowlessSquare = 6,
    Circular = 7,
    TexturedSquare = 8,
    HelpButton = 9,
    SmallSquare = 10,
    TexturedRounded = 11,
    RoundRect = 12,
    Recessed = 13,
    RoundedDisclosure = 14,
    Inline = 15
  }

  global['NSButton']['BezelStyle'] = BezelStyle;

  export enum ButtonType {
    MomentaryLight = 0,
    PushOnPushOff = 1,
    Toggle = 2,
    Switch = 3,
    Radio = 4,
    MomentaryChange = 5,
    OnOff = 6,
    MomentaryPushIn = 7,
    Accelerator = 8,
    MultiLevelAccelerator = 9
  }

  global['NSButton']['ButtonType'] = ButtonType;

}

namespace NSCalendar {
  export enum Options {
    WrapComponents = 1,
    MatchStrictly = 2,
    SearchBackwards = 4,
    MatchPreviousTimePreservingSmallerUnits = 256,
    MatchNextTimePreservingSmallerUnits = 512,
    MatchNextTime = 1024,
    MatchFirst = 4096,
    MatchLast = 8192
  }

  global['NSCalendar']['Options'] = Options;

  export enum Unit {
    CalendarUnitEra = 2,
    CalendarUnitYear = 4,
    CalendarUnitMonth = 8,
    CalendarUnitDay = 16,
    CalendarUnitHour = 32,
    CalendarUnitMinute = 64,
    CalendarUnitSecond = 128,
    CalendarUnitWeekday = 512,
    CalendarUnitWeekdayOrdinal = 1024,
    CalendarUnitQuarter = 2048,
    CalendarUnitWeekOfMonth = 4096,
    CalendarUnitWeekOfYear = 8192,
    CalendarUnitYearForWeekOfYear = 16384,
    CalendarUnitNanosecond = 32768,
    CalendarUnitCalendar = 1048576,
    CalendarUnitTimeZone = 2097152,
    EraCalendarUnit = 2,
    YearCalendarUnit = 4,
    MonthCalendarUnit = 8,
    DayCalendarUnit = 16,
    HourCalendarUnit = 32,
    MinuteCalendarUnit = 64,
    SecondCalendarUnit = 128,
    WeekCalendarUnit = 256,
    WeekdayCalendarUnit = 512,
    WeekdayOrdinalCalendarUnit = 1024,
    QuarterCalendarUnit = 2048,
    WeekOfMonthCalendarUnit = 4096,
    WeekOfYearCalendarUnit = 8192,
    YearForWeekOfYearCalendarUnit = 16384,
    CalendarCalendarUnit = 1048576,
    TimeZoneCalendarUnit = 2097152
  }

  global['NSCalendar']['Unit'] = Unit;

  export let buddhist: string;
  export let chinese: string;
  export let coptic: string;
  export let ethiopicAmeteAlem: string;
  export let ethiopicAmeteMihret: string;
  export let gregorian: string;
  export let hebrew: string;
  export let ISO8601: string;
  export let indian: string;
  export let islamic: string;
  export let islamicCivil: string;
  export let islamicTabular: string;
  export let islamicUmmAlQura: string;
  export let japanese: string;
  export let persian: string;
  export let republicOfChina: string;
}

namespace NSCell {
  export enum Attribute {
    CellDisabled = 0,
    CellState = 1,
    PushInCell = 2,
    CellEditable = 3,
    ChangeGrayCell = 4,
    CellHighlighted = 5,
    CellLightsByContents = 6,
    CellLightsByGray = 7,
    ChangeBackgroundCell = 8,
    CellLightsByBackground = 9,
    CellIsBordered = 10,
    CellHasOverlappingImage = 11,
    CellHasImageHorizontal = 12,
    CellHasImageOnLeftOrBottom = 13,
    CellChangesContents = 14,
    CellIsInsetButton = 15,
    CellAllowsMixedState = 16
  }

  global['NSCell']['Attribute'] = Attribute;

  export enum HitResult {
    None = 0,
    ContentArea = 1,
    EditableTextArea = 2,
    TrackableArea = 4
  }

  global['NSCell']['HitResult'] = HitResult;

  export enum StyleMask {
    NoCellMask = 0,
    ContentsCellMask = 1,
    PushInCellMask = 2,
    ChangeGrayCellMask = 4,
    ChangeBackgroundCellMask = 8
  }

  global['NSCell']['StyleMask'] = StyleMask;

  export enum CellType {
    NullCellType = 0,
    TextCellType = 1,
    ImageCellType = 2
  }

  global['NSCell']['CellType'] = CellType;

}

namespace NSCoder {
  export enum DecodingFailurePolicy {
    RaiseException = 0,
    SetErrorAndReturn = 1
  }

  global['NSCoder']['DecodingFailurePolicy'] = DecodingFailurePolicy;

}

namespace NSCollectionView {
  export enum UpdateAction {
    Insert = 0,
    Delete = 1,
    Reload = 2,
    Move = 3,
    None = 4
  }

  global['NSCollectionView']['UpdateAction'] = UpdateAction;

  export enum DropOperation {
    On = 0,
    Before = 1
  }

  global['NSCollectionView']['DropOperation'] = DropOperation;

  export enum ScrollDirection {
    Vertical = 0,
    Horizontal = 1
  }

  global['NSCollectionView']['ScrollDirection'] = ScrollDirection;

  export enum ScrollPosition {
    None = 0,
    Top = 1,
    CenteredVertically = 2,
    Bottom = 4,
    NearestHorizontalEdge = 512,
    Left = 8,
    CenteredHorizontally = 16,
    Right = 32,
    LeadingEdge = 64,
    TrailingEdge = 128,
    NearestVerticalEdge = 256
  }

  global['NSCollectionView']['ScrollPosition'] = ScrollPosition;

  export let elementKindInterItemGapIndicator: string;
  export let elementKindSectionFooter: string;
  export let elementKindSectionHeader: string;
  export type DecorationElementKind = String;
  export type SupplementaryElementKind = String;
}

namespace NSCollectionViewItem {
  export enum HighlightState {
    None = 0,
    ForSelection = 1,
    ForDeselection = 2,
    AsDropTarget = 3
  }

  global['NSCollectionViewItem']['HighlightState'] = HighlightState;

}

namespace NSCollectionViewTransitionLayout {
  export type AnimatedKey = String;
}

namespace NSColor {
  export enum SystemEffect {
    None = 0,
    Pressed = 1,
    DeepPressed = 2,
    Disabled = 3,
    Rollover = 4
  }

  global['NSColor']['SystemEffect'] = SystemEffect;

  export enum ColorType {
    ComponentBased = 0,
    Pattern = 1,
    Catalog = 2
  }

  global['NSColor']['ColorType'] = ColorType;

  export let currentControlTintDidChangeNotification: string;
  export let systemColorsDidChangeNotification: string;
  export type Name = String;
}

namespace NSColorList {
  export let didChangeNotification: string;
  export type Name = String;
}

namespace NSColorPanel {
  export enum Mode {
    None = -1,
    Gray = 0,
    RGB = 1,
    CMYK = 2,
    HSB = 3,
    CustomPalette = 4,
    ColorList = 5,
    Wheel = 6,
    Crayon = 7
  }

  global['NSColorPanel']['Mode'] = Mode;

  export enum Options {
    GrayModeMask = 1,
    RGBModeMask = 2,
    CMYKModeMask = 4,
    HSBModeMask = 8,
    CustomPaletteModeMask = 16,
    ColorListModeMask = 32,
    WheelModeMask = 64,
    CrayonModeMask = 128,
    AllModesMask = 65535
  }

  global['NSColorPanel']['Options'] = Options;

  export let colorDidChangeNotification: string;
}

namespace NSColorSpace {
  export enum Model {
    Unknown = -1,
    Gray = 0,
    RGB = 1,
    CMYK = 2,
    LAB = 3,
    DeviceN = 4,
    Indexed = 5,
    Patterned = 6
  }

  global['NSColorSpace']['Model'] = Model;

}

namespace NSColorSpaceName {
  export let calibratedRGB: string;
  export let calibratedWhite: string;
  export let custom: string;
  export let deviceCMYK: string;
  export let deviceRGB: string;
  export let deviceWhite: string;
  export let named: string;
  export let pattern: string;
}

namespace NSComboBox {
  export let selectionDidChangeNotification: string;
  export let selectionIsChangingNotification: string;
  export let willDismissNotification: string;
  export let willPopUpNotification: string;
}

namespace NSComparisonPredicate {
  export enum Modifier {
    DirectPredicateModifier = 0,
    AllPredicateModifier = 1,
    AnyPredicateModifier = 2
  }

  global['NSComparisonPredicate']['Modifier'] = Modifier;

  export enum Options {
    CaseInsensitivePredicateOption = 1,
    DiacriticInsensitivePredicateOption = 2,
    NormalizedPredicateOption = 4
  }

  global['NSComparisonPredicate']['Options'] = Options;

  export enum Operator {
    LessThanPredicateOperatorType = 0,
    LessThanOrEqualToPredicateOperatorType = 1,
    GreaterThanPredicateOperatorType = 2,
    GreaterThanOrEqualToPredicateOperatorType = 3,
    EqualToPredicateOperatorType = 4,
    NotEqualToPredicateOperatorType = 5,
    MatchesPredicateOperatorType = 6,
    LikePredicateOperatorType = 7,
    BeginsWithPredicateOperatorType = 8,
    EndsWithPredicateOperatorType = 9,
    InPredicateOperatorType = 10,
    CustomSelectorPredicateOperatorType = 11,
    ContainsPredicateOperatorType = 99,
    BetweenPredicateOperatorType = 100
  }

  global['NSComparisonPredicate']['Operator'] = Operator;

}

namespace NSCompoundPredicate {
  export enum LogicalType {
    NotPredicateType = 0,
    AndPredicateType = 1,
    OrPredicateType = 2
  }

  global['NSCompoundPredicate']['LogicalType'] = LogicalType;

}

namespace NSControl {
  export enum ImagePosition {
    NoImage = 0,
    ImageOnly = 1,
    ImageLeft = 2,
    ImageRight = 3,
    ImageBelow = 4,
    ImageAbove = 5,
    ImageOverlaps = 6,
    ImageLeading = 7,
    ImageTrailing = 8
  }

  global['NSControl']['ImagePosition'] = ImagePosition;

  export enum ControlSize {
    Regular = 0,
    Small = 1,
    Mini = 2
  }

  global['NSControl']['ControlSize'] = ControlSize;

  export let mixed: number;
  export let off: number;
  export let on: number;
  export let textDidBeginEditingNotification: string;
  export let textDidChangeNotification: string;
  export let textDidEndEditingNotification: string;
}

namespace NSData {
  export enum Base64DecodingOptions {
    IgnoreUnknownCharacters = 1
  }

  global['NSData']['Base64DecodingOptions'] = Base64DecodingOptions;

  export enum Base64EncodingOptions {
    Encoding64CharacterLineLength = 1,
    Encoding76CharacterLineLength = 2,
    EncodingEndLineWithCarriageReturn = 16,
    EncodingEndLineWithLineFeed = 32
  }

  global['NSData']['Base64EncodingOptions'] = Base64EncodingOptions;

  export enum CompressionAlgorithm {
    LZFSE = 0,
    LZ4 = 1,
    LZMA = 2,
    Zlib = 3
  }

  global['NSData']['CompressionAlgorithm'] = CompressionAlgorithm;

  export enum ReadingOptions {
    DataReadingMappedIfSafe = 1,
    DataReadingUncached = 2,
    DataReadingMappedAlways = 8,
    DataReadingMapped = 1,
    MappedRead = 1,
    UncachedRead = 2
  }

  global['NSData']['ReadingOptions'] = ReadingOptions;

  export enum SearchOptions {
    Backwards = 1,
    Anchored = 2
  }

  global['NSData']['SearchOptions'] = SearchOptions;

  export enum WritingOptions {
    DataWritingAtomic = 1,
    DataWritingWithoutOverwriting = 2,
    DataWritingFileProtectionNone = 268435456,
    DataWritingFileProtectionComplete = 536870912,
    DataWritingFileProtectionCompleteUnlessOpen = 805306368,
    DataWritingFileProtectionCompleteUntilFirstUserAuthentication = 1073741824,
    DataWritingFileProtectionMask = 4026531840,
    AtomicWrite = 1
  }

  global['NSData']['WritingOptions'] = WritingOptions;

  export type Element = number;
  export type Index = number;
  export type Iterator = IndexingIterator;
  export type SubSequence = Slice;
  export type Indices = Range;
}

namespace NSDatePicker {
  export enum ElementFlags {
    HourMinute = 12,
    HourMinuteSecond = 14,
    TimeZone = 16,
    YearMonth = 192,
    YearMonthDay = 224,
    Era = 256
  }

  global['NSDatePicker']['ElementFlags'] = ElementFlags;

  export enum Mode {
    Single = 0,
    Range = 1
  }

  global['NSDatePicker']['Mode'] = Mode;

  export enum Style {
    TextFieldAndStepper = 0,
    ClockAndCalendar = 1,
    TextField = 2
  }

  global['NSDatePicker']['Style'] = Style;

  export let clockAndCalendar: NSDatePicker.Style;
  export let era: NSDatePicker.ElementFlags;
  export let hourMinute: NSDatePicker.ElementFlags;
  export let hourMinuteSecond: NSDatePicker.ElementFlags;
  export let range: NSDatePicker.Mode;
  export let single: NSDatePicker.Mode;
  export let textFieldAndStepper: NSDatePicker.Style;
  export let textField: NSDatePicker.Style;
  export let timeZone: NSDatePicker.ElementFlags;
  export let yearMonth: NSDatePicker.ElementFlags;
  export let yearMonthDay: NSDatePicker.ElementFlags;
}

namespace NSDecimalNumber {
  export enum CalculationError {
    NoError = 0,
    LossOfPrecision = 1,
    Underflow = 2,
    Overflow = 3,
    DivideByZero = 4
  }

  global['NSDecimalNumber']['CalculationError'] = CalculationError;

  export enum RoundingMode {
    Plain = 0,
    Down = 1,
    Up = 2,
    Bankers = 3
  }

  global['NSDecimalNumber']['RoundingMode'] = RoundingMode;

}

namespace NSDeviceDescriptionKey {
  export let bitsPerSample: string;
  export let colorSpaceName: string;
  export let isPrinter: string;
  export let isScreen: string;
  export let resolution: string;
  export let size: string;
}

namespace NSDocument {
  export enum ChangeType {
    ChangeDone = 0,
    ChangeUndone = 1,
    ChangeRedone = 5,
    ChangeCleared = 2,
    ChangeReadOtherContents = 3,
    ChangeAutosaved = 4,
    ChangeDiscardable = 256
  }

  global['NSDocument']['ChangeType'] = ChangeType;

  export enum SaveOperationType {
    SaveOperation = 0,
    SaveAsOperation = 1,
    SaveToOperation = 2,
    AutosaveInPlaceOperation = 4,
    AutosaveElsewhereOperation = 3,
    AutosaveAsOperation = 5,
    AutosaveOperation = 3
  }

  global['NSDocument']['SaveOperationType'] = SaveOperationType;

}

namespace NSDraggingItem {
  export let icon: string;
  export let label: string;
}

namespace NSDrawer {
  export enum State {
    ClosedState = 0,
    OpeningState = 1,
    OpenState = 2,
    ClosingState = 3
  }

  global['NSDrawer']['State'] = State;

}

namespace NSEnumerator {
  export type Iterator = NSFastEnumerationIterator;
}

namespace NSError {
  export type UserInfoKey = string;
}

namespace NSEvent {
  export enum ButtonMask {
    PenTip = 1,
    PenLowerSide = 2,
    PenUpperSide = 4
  }

  global['NSEvent']['ButtonMask'] = ButtonMask;

  export enum GestureAxis {
    None = 0,
    Horizontal = 1,
    Vertical = 2
  }

  global['NSEvent']['GestureAxis'] = GestureAxis;

  export enum EventTypeMask {
    LeftMouseDown = 2,
    LeftMouseUp = 4,
    RightMouseDown = 8,
    RightMouseUp = 16,
    MouseMoved = 32,
    LeftMouseDragged = 64,
    RightMouseDragged = 128,
    MouseEntered = 256,
    MouseExited = 512,
    KeyDown = 1024,
    KeyUp = 2048,
    FlagsChanged = 4096,
    AppKitDefined = 8192,
    SystemDefined = 16384,
    ApplicationDefined = 32768,
    Periodic = 65536,
    CursorUpdate = 131072,
    ScrollWheel = 4194304,
    TabletPoint = 8388608,
    TabletProximity = 16777216,
    OtherMouseDown = 33554432,
    OtherMouseUp = 67108864,
    OtherMouseDragged = 134217728,
    Gesture = 536870912,
    Magnify = 1073741824,
    Swipe = 2147483648,
    Rotate = 262144,
    BeginGesture = 524288,
    EndGesture = 1048576,
    SmartMagnify = 4294967296,
    Pressure = 17179869184,
    DirectTouch = 137438953472,
    ChangeMode = 274877906944,
    Any = -1
  }

  global['NSEvent']['EventTypeMask'] = EventTypeMask;

  export enum ModifierFlags {
    CapsLock = 65536,
    Shift = 131072,
    Control = 262144,
    Option = 524288,
    Command = 1048576,
    NumericPad = 2097152,
    Help = 4194304,
    Function = 8388608,
    DeviceIndependentFlagsMask = 4294901760
  }

  global['NSEvent']['ModifierFlags'] = ModifierFlags;

  export enum Phase {
    None = 0,
    Began = 1,
    Stationary = 2,
    Changed = 4,
    Ended = 8,
    Cancelled = 16,
    MayBegin = 32
  }

  global['NSEvent']['Phase'] = Phase;

  export enum EventSubtype {
    WindowExposed = 0,
    ApplicationActivated = 1,
    ApplicationDeactivated = 2,
    WindowMoved = 4,
    ScreenChanged = 8,
    PowerOff = 1,
    MouseEvent = 0,
    TabletPoint = 1,
    TabletProximity = 2,
    Touch = 3
  }

  global['NSEvent']['EventSubtype'] = EventSubtype;

  export enum SwipeTrackingOptions {
    LockDirection = 1,
    ClampGestureAmount = 2
  }

  global['NSEvent']['SwipeTrackingOptions'] = SwipeTrackingOptions;

  export enum EventType {
    LeftMouseDown = 1,
    LeftMouseUp = 2,
    RightMouseDown = 3,
    RightMouseUp = 4,
    MouseMoved = 5,
    LeftMouseDragged = 6,
    RightMouseDragged = 7,
    MouseEntered = 8,
    MouseExited = 9,
    KeyDown = 10,
    KeyUp = 11,
    FlagsChanged = 12,
    AppKitDefined = 13,
    SystemDefined = 14,
    ApplicationDefined = 15,
    Periodic = 16,
    CursorUpdate = 17,
    ScrollWheel = 22,
    TabletPoint = 23,
    TabletProximity = 24,
    OtherMouseDown = 25,
    OtherMouseUp = 26,
    OtherMouseDragged = 27,
    Gesture = 29,
    Magnify = 30,
    Swipe = 31,
    Rotate = 18,
    BeginGesture = 19,
    EndGesture = 20,
    SmartMagnify = 32,
    QuickLook = 33,
    Pressure = 34,
    DirectTouch = 37,
    ChangeMode = 38
  }

  global['NSEvent']['EventType'] = EventType;

  export enum PointingDeviceType {
    Unknown = 0,
    Pen = 1,
    Cursor = 2,
    Eraser = 3
  }

  global['NSEvent']['PointingDeviceType'] = PointingDeviceType;

  export enum PressureBehavior {
    Unknown = -1,
    PrimaryDefault = 0,
    PrimaryClick = 1,
    PrimaryGeneric = 2,
    PrimaryAccelerator = 3,
    PrimaryDeepClick = 5,
    PrimaryDeepDrag = 6
  }

  global['NSEvent']['PressureBehavior'] = PressureBehavior;

  export let foreverDuration: number;
}

namespace NSExceptionName {
  export let abortModalException: string;
  export let abortPrintingException: string;
  export let appKitIgnoredException: string;
  export let appKitVirtualMemoryException: string;
  export let badBitmapParametersException: string;
  export let badComparisonException: string;
  export let badRTFColorTableException: string;
  export let badRTFDirectiveException: string;
  export let badRTFFontTableException: string;
  export let badRTFStyleSheetException: string;
  export let browserIllegalDelegateException: string;
  export let colorListIOException: string;
  export let colorListNotEditableException: string;
  export let draggingException: string;
  export let fontUnavailableException: string;
  export let illegalSelectorException: string;
  export let imageCacheException: string;
  export let nibLoadingException: string;
  export let NSPPDIncludeNotFoundException: string;
  export let NSPPDIncludeStackOverflowException: string;
  export let NSPPDIncludeStackUnderflowException: string;
  export let NSPPDParseException: string;
  export let pasteboardCommunicationException: string;
  export let printOperationExistsException: string;
  export let printPackageException: string;
  export let printingCommunicationException: string;
  export let NSRTFPropertyStackOverflowException: string;
  export let NSTIFFException: string;
  export let textLineTooLongException: string;
  export let textNoSelectionException: string;
  export let textReadException: string;
  export let textWriteException: string;
  export let typedStreamVersionException: string;
  export let windowServerCommunicationException: string;
  export let wordTablesReadException: string;
  export let wordTablesWriteException: string;
  export let characterConversionException: string;
  export let decimalNumberDivideByZeroException: string;
  export let decimalNumberExactnessException: string;
  export let decimalNumberOverflowException: string;
  export let decimalNumberUnderflowException: string;
  export let destinationInvalidException: string;
  export let fileHandleOperationException: string;
  export let genericException: string;
  export let inconsistentArchiveException: string;
  export let internalInconsistencyException: string;
  export let invalidArchiveOperationException: string;
  export let invalidArgumentException: string;
  export let invalidReceivePortException: string;
  export let invalidSendPortException: string;
  export let invalidUnarchiveOperationException: string;
  export let invocationOperationCancelledException: string;
  export let invocationOperationVoidResultException: string;
  export let mallocException: string;
  export let objectInaccessibleException: string;
  export let objectNotAvailableException: string;
  export let oldStyleException: string;
  export let parseErrorException: string;
  export let portReceiveException: string;
  export let portSendException: string;
  export let portTimeoutException: string;
  export let rangeException: string;
  export let undefinedKeyException: string;
}

namespace NSExpression {
  export enum ExpressionType {
    ConstantValueExpressionType = 0,
    EvaluatedObjectExpressionType = 1,
    VariableExpressionType = 2,
    KeyPathExpressionType = 3,
    FunctionExpressionType = 4,
    UnionSetExpressionType = 5,
    IntersectSetExpressionType = 6,
    MinusSetExpressionType = 7,
    SubqueryExpressionType = 13,
    AggregateExpressionType = 14,
    AnyKeyExpressionType = 15,
    BlockExpressionType = 19,
    ConditionalExpressionType = 20
  }

  global['NSExpression']['ExpressionType'] = ExpressionType;

}

namespace NSFileCoordinator {
  export enum ReadingOptions {
    WithoutChanges = 1,
    ResolvesSymbolicLink = 2,
    ImmediatelyAvailableMetadataOnly = 4,
    ForUploading = 8
  }

  global['NSFileCoordinator']['ReadingOptions'] = ReadingOptions;

  export enum WritingOptions {
    ForDeleting = 1,
    ForMoving = 2,
    ForMerging = 4,
    ForReplacing = 8,
    ContentIndependentMetadataOnly = 16
  }

  global['NSFileCoordinator']['WritingOptions'] = WritingOptions;

}

namespace NSFileVersion {
  export enum AddingOptions {
    ByMoving = 1
  }

  global['NSFileVersion']['AddingOptions'] = AddingOptions;

  export enum ReplacingOptions {
    ByMoving = 1
  }

  global['NSFileVersion']['ReplacingOptions'] = ReplacingOptions;

}

namespace NSFont {
  export let antialiasThresholdChangedNotification: string;
  export let identityMatrix: number;
  export let fontSetChangedNotification: string;
  export let black: number;
  export let bold: number;
  export let heavy: number;
  export let light: number;
  export let medium: number;
  export let regular: number;
  export let semibold: number;
  export let thin: number;
  export let ultraLight: number;
}

namespace NSFontAssetRequest {
  export enum Options {
    UsesStandardUI = 1
  }

  global['NSFontAssetRequest']['Options'] = Options;

}

namespace NSFontCollection {
  export enum Visibility {
    Process = 1,
    User = 2,
    Computer = 4
  }

  global['NSFontCollection']['Visibility'] = Visibility;

  export let actionUserInfoKey: string;
  export let allFonts: string;
  export let didChangeNotification: string;
  export let favorites: string;
  export let nameUserInfoKey: string;
  export let oldNameUserInfoKey: string;
  export let recentlyUsed: string;
  export let user: string;
  export let visibilityUserInfoKey: string;
  export let hidden: string;
  export let renamed: string;
  export let shown: string;
}

namespace NSFontDescriptor {
  export enum SymbolicTraits {
    TraitItalic = 1,
    TraitBold = 2,
    TraitExpanded = 32,
    TraitCondensed = 64,
    TraitMonoSpace = 1024,
    TraitVertical = 2048,
    TraitUIOptimized = 4096,
    TraitTightLeading = 32768,
    TraitLooseLeading = 65536,
    ClassMask = 4026531840,
    ClassUnknown = 0,
    ClassOldStyleSerifs = 268435456,
    ClassTransitionalSerifs = 536870912,
    ClassModernSerifs = 805306368,
    ClassClarendonSerifs = 1073741824,
    ClassSlabSerifs = 1342177280,
    ClassFreeformSerifs = 1879048192,
    ClassSansSerif = 2147483648,
    ClassOrnamentals = 2415919104,
    ClassScripts = 2684354560,
    ClassSymbolic = 3221225472
  }

  global['NSFontDescriptor']['SymbolicTraits'] = SymbolicTraits;

  export let cascadeList: string;
  export let characterSet: string;
  export let default_: string;
  export let monospaced: string;
  export let rounded: string;
  export let serif: string;
  export let face: string;
  export let family: string;
  export let selectorIdentifier: string;
  export let featureSettings: string;
  export let typeIdentifier: string;
  export let fixedAdvance: string;
  export let matrix: string;
  export let name: string;
  export let size: string;
  export let slant: string;
  export let symbolic: string;
  export let traits: string;
  export let variation: string;
  export let defaultValue: string;
  export let identifier: string;
  export let maximumValue: string;
  export let minimumValue: string;
  export let visibleName: string;
  export let weight: string;
  export let width: string;
}

namespace NSFontPanel {
  export enum ModeMask {
    ModeMaskFace = 1,
    ModeMaskSize = 2,
    ModeMaskCollection = 4,
    ModeMaskUnderlineEffect = 256,
    ModeMaskStrikethroughEffect = 512,
    ModeMaskTextColorEffect = 1024,
    ModeMaskDocumentColorEffect = 2048,
    ModeMaskShadowEffect = 4096,
    ModeMaskAllEffects = 1048320,
    ModesMaskStandardModes = 65535,
    ModesMaskAllModes = 4294967295
  }

  global['NSFontPanel']['ModeMask'] = ModeMask;

}

namespace NSGestureRecognizer {
  export enum State {
    Possible = 0,
    Began = 1,
    Changed = 2,
    Ended = 3,
    Cancelled = 4,
    Failed = 5,
    Recognized = 3
  }

  global['NSGestureRecognizer']['State'] = State;

}

namespace NSGradient {
  export enum DrawingOptions {
    DrawsBeforeStartingLocation = 1,
    DrawsAfterEndingLocation = 2
  }

  global['NSGradient']['DrawingOptions'] = DrawingOptions;

}

namespace NSGraphicsContext {
  export let destination: string;
  export let pdf: string;
  export let postScript: string;
  export let representationFormat: string;
}

namespace NSGridCell {
  export enum Placement {
    Inherited = 0,
    None = 1,
    Leading = 2,
    Top = 2,
    Trailing = 3,
    Bottom = 3,
    Center = 4,
    Fill = 5
  }

  global['NSGridCell']['Placement'] = Placement;

}

namespace NSGridRow {
  export enum Alignment {
    Inherited = 0,
    None = 1,
    FirstBaseline = 2,
    LastBaseline = 3
  }

  global['NSGridRow']['Alignment'] = Alignment;

}

namespace NSGridView {
  export let sizedForContent: number;
}

namespace NSHapticFeedbackManager {
  export enum FeedbackPattern {
    Generic = 0,
    Alignment = 1,
    LevelChange = 2
  }

  global['NSHapticFeedbackManager']['FeedbackPattern'] = FeedbackPattern;

  export enum PerformanceTime {
    Default = 0,
    Now = 1,
    DrawCompleted = 2
  }

  global['NSHapticFeedbackManager']['PerformanceTime'] = PerformanceTime;

}

namespace NSHelpManager {
  export let contextHelpModeDidActivateNotification: string;
  export let contextHelpModeDidDeactivateNotification: string;
  export type BookName = String;
  export type AnchorName = String;
  export type ContextHelpKey = String;
}

namespace NSImage {
  export enum CacheMode {
    Default = 0,
    Always = 1,
    BySize = 2,
    Never = 3
  }

  global['NSImage']['CacheMode'] = CacheMode;

  export enum LayoutDirection {
    Unspecified = -1,
    LeftToRight = 2,
    RightToLeft = 3
  }

  global['NSImage']['LayoutDirection'] = LayoutDirection;

  export enum LoadStatus {
    Completed = 0,
    Cancelled = 1,
    InvalidData = 2,
    UnexpectedEOF = 3,
    ReadError = 4
  }

  global['NSImage']['LoadStatus'] = LoadStatus;

  export enum ResizingMode {
    Stretch = 0,
    Tile = 1
  }

  global['NSImage']['ResizingMode'] = ResizingMode;

  export let actionTemplateName: string;
  export let addTemplateName: string;
  export let advancedName: string;
  export let applicationIconName: string;
  export let bluetoothTemplateName: string;
  export let bonjourName: string;
  export let bookmarksTemplateName: string;
  export let cautionName: string;
  export let colorPanelName: string;
  export let columnViewTemplateName: string;
  export let computerName: string;
  export let enterFullScreenTemplateName: string;
  export let everyoneName: string;
  export let exitFullScreenTemplateName: string;
  export let flowViewTemplateName: string;
  export let folderName: string;
  export let folderBurnableName: string;
  export let folderSmartName: string;
  export let followLinkFreestandingTemplateName: string;
  export let fontPanelName: string;
  export let goBackTemplateName: string;
  export let goForwardTemplateName: string;
  export let goLeftTemplateName: string;
  export let goRightTemplateName: string;
  export let homeTemplateName: string;
  export let iChatTheaterTemplateName: string;
  export let iconViewTemplateName: string;
  export let infoName: string;
  export let invalidDataFreestandingTemplateName: string;
  export let leftFacingTriangleTemplateName: string;
  export let listViewTemplateName: string;
  export let lockLockedTemplateName: string;
  export let lockUnlockedTemplateName: string;
  export let menuMixedStateTemplateName: string;
  export let menuOnStateTemplateName: string;
  export let mobileMeName: string;
  export let multipleDocumentsName: string;
  export let networkName: string;
  export let pathTemplateName: string;
  export let preferencesGeneralName: string;
  export let quickLookTemplateName: string;
  export let refreshFreestandingTemplateName: string;
  export let refreshTemplateName: string;
  export let removeTemplateName: string;
  export let revealFreestandingTemplateName: string;
  export let rightFacingTriangleTemplateName: string;
  export let shareTemplateName: string;
  export let slideshowTemplateName: string;
  export let smartBadgeTemplateName: string;
  export let statusAvailableName: string;
  export let statusNoneName: string;
  export let statusPartiallyAvailableName: string;
  export let statusUnavailableName: string;
  export let stopProgressFreestandingTemplateName: string;
  export let stopProgressTemplateName: string;
  export let touchBarAddDetailTemplateName: string;
  export let touchBarAddTemplateName: string;
  export let touchBarAlarmTemplateName: string;
  export let touchBarAudioInputMuteTemplateName: string;
  export let touchBarAudioInputTemplateName: string;
  export let touchBarAudioOutputMuteTemplateName: string;
  export let touchBarAudioOutputVolumeHighTemplateName: string;
  export let touchBarAudioOutputVolumeLowTemplateName: string;
  export let touchBarAudioOutputVolumeMediumTemplateName: string;
  export let touchBarAudioOutputVolumeOffTemplateName: string;
  export let touchBarBookmarksTemplateName: string;
  export let touchBarColorPickerFillName: string;
  export let touchBarColorPickerFontName: string;
  export let touchBarColorPickerStrokeName: string;
  export let touchBarCommunicationAudioTemplateName: string;
  export let touchBarCommunicationVideoTemplateName: string;
  export let touchBarComposeTemplateName: string;
  export let touchBarDeleteTemplateName: string;
  export let touchBarDownloadTemplateName: string;
  export let touchBarEnterFullScreenTemplateName: string;
  export let touchBarExitFullScreenTemplateName: string;
  export let touchBarFastForwardTemplateName: string;
  export let touchBarFolderCopyToTemplateName: string;
  export let touchBarFolderMoveToTemplateName: string;
  export let touchBarFolderTemplateName: string;
  export let touchBarGetInfoTemplateName: string;
  export let touchBarGoBackTemplateName: string;
  export let touchBarGoDownTemplateName: string;
  export let touchBarGoForwardTemplateName: string;
  export let touchBarGoUpTemplateName: string;
  export let touchBarHistoryTemplateName: string;
  export let touchBarIconViewTemplateName: string;
  export let touchBarListViewTemplateName: string;
  export let touchBarMailTemplateName: string;
  export let touchBarNewFolderTemplateName: string;
  export let touchBarNewMessageTemplateName: string;
  export let touchBarOpenInBrowserTemplateName: string;
  export let touchBarPauseTemplateName: string;
  export let touchBarPlayPauseTemplateName: string;
  export let touchBarPlayTemplateName: string;
  export let touchBarPlayheadTemplateName: string;
  export let touchBarQuickLookTemplateName: string;
  export let touchBarRecordStartTemplateName: string;
  export let touchBarRecordStopTemplateName: string;
  export let touchBarRefreshTemplateName: string;
  export let touchBarRemoveTemplateName: string;
  export let touchBarRewindTemplateName: string;
  export let touchBarRotateLeftTemplateName: string;
  export let touchBarRotateRightTemplateName: string;
  export let touchBarSearchTemplateName: string;
  export let touchBarShareTemplateName: string;
  export let touchBarSidebarTemplateName: string;
  export let touchBarSkipAhead15SecondsTemplateName: string;
  export let touchBarSkipAhead30SecondsTemplateName: string;
  export let touchBarSkipAheadTemplateName: string;
  export let touchBarSkipBack15SecondsTemplateName: string;
  export let touchBarSkipBack30SecondsTemplateName: string;
  export let touchBarSkipBackTemplateName: string;
  export let touchBarSkipToEndTemplateName: string;
  export let touchBarSkipToStartTemplateName: string;
  export let touchBarSlideshowTemplateName: string;
  export let touchBarTagIconTemplateName: string;
  export let touchBarTextBoldTemplateName: string;
  export let touchBarTextBoxTemplateName: string;
  export let touchBarTextCenterAlignTemplateName: string;
  export let touchBarTextItalicTemplateName: string;
  export let touchBarTextJustifiedAlignTemplateName: string;
  export let touchBarTextLeftAlignTemplateName: string;
  export let touchBarTextListTemplateName: string;
  export let touchBarTextRightAlignTemplateName: string;
  export let touchBarTextStrikethroughTemplateName: string;
  export let touchBarTextUnderlineTemplateName: string;
  export let touchBarUserAddTemplateName: string;
  export let touchBarUserGroupTemplateName: string;
  export let touchBarUserTemplateName: string;
  export let touchBarVolumeDownTemplateName: string;
  export let touchBarVolumeUpTemplateName: string;
  export let trashEmptyName: string;
  export let trashFullName: string;
  export let userName: string;
  export let userAccountsName: string;
  export let userGroupName: string;
  export let userGuestName: string;
  export type Name = String;
}

namespace NSImageRep {
  export let ctm: string;
  export let interpolation: string;
  export let userInterfaceLayoutDirection: string;
  export let registryDidChangeNotification: string;
}

namespace NSImageView {
  export enum FrameStyle {
    None = 0,
    Photo = 1,
    GrayBezel = 2,
    Groove = 3,
    Button = 4
  }

  global['NSImageView']['FrameStyle'] = FrameStyle;

}

namespace NSIndexSet {
  export type Element = NSIndexSetIterator;
  export type Iterator = NSIndexSetIterator;
}

namespace NSItemProvider {
  export enum ErrorCode {
    UnknownError = -1,
    ItemUnavailableError = -1000,
    UnexpectedValueClassError = -1100,
    UnavailableCoercionError = -1200
  }

  global['NSItemProvider']['ErrorCode'] = ErrorCode;

  export let errorDomain: string;
}

namespace NSKeyValueChangeKey {
  export let indexesKey: string;
  export let kindKey: string;
  export let newKey: string;
  export let notificationIsPriorKey: string;
  export let oldKey: string;
}

namespace NSKeyValueOperator {
  export let averageKeyValueOperator: string;
  export let countKeyValueOperator: string;
  export let distinctUnionOfArraysKeyValueOperator: string;
  export let distinctUnionOfObjectsKeyValueOperator: string;
  export let distinctUnionOfSetsKeyValueOperator: string;
  export let maximumKeyValueOperator: string;
  export let minimumKeyValueOperator: string;
  export let sumKeyValueOperator: string;
  export let unionOfArraysKeyValueOperator: string;
  export let unionOfObjectsKeyValueOperator: string;
  export let unionOfSetsKeyValueOperator: string;
}

namespace NSLayoutConstraint {
  export enum Attribute {
    Left = 1,
    Right = 2,
    Top = 3,
    Bottom = 4,
    Leading = 5,
    Trailing = 6,
    Width = 7,
    Height = 8,
    CenterX = 9,
    CenterY = 10,
    LastBaseline = 11,
    Baseline = 11,
    FirstBaseline = 12,
    NotAnAttribute = 0
  }

  global['NSLayoutConstraint']['Attribute'] = Attribute;

  export enum Orientation {
    Horizontal = 0,
    Vertical = 1
  }

  global['NSLayoutConstraint']['Orientation'] = Orientation;

  export enum FormatOptions {
    AlignAllLeft = 2,
    AlignAllRight = 4,
    AlignAllTop = 8,
    AlignAllBottom = 16,
    AlignAllLeading = 32,
    AlignAllTrailing = 64,
    AlignAllCenterX = 512,
    AlignAllCenterY = 1024,
    AlignAllLastBaseline = 2048,
    AlignAllFirstBaseline = 4096,
    AlignAllBaseline = 2048,
    AlignmentMask = 65535,
    DirectionLeadingToTrailing = 0,
    DirectionLeftToRight = 65536,
    DirectionRightToLeft = 131072,
    DirectionMask = 196608
  }

  global['NSLayoutConstraint']['FormatOptions'] = FormatOptions;

  export enum Relation {
    LessThanOrEqual = -1,
    Equal = 0,
    GreaterThanOrEqual = 1
  }

  global['NSLayoutConstraint']['Relation'] = Relation;

  export let defaultHigh: number;
  export let defaultLow: number;
  export let dragThatCanResizeWindow: number;
  export let dragThatCannotResizeWindow: number;
  export let fittingSizeCompression: number;
  export let required: number;
  export let windowSizeStayPut: number;
}

namespace NSLayoutManager {
  export enum ControlCharacterAction {
    ZeroAdvancement = 1,
    Whitespace = 2,
    HorizontalTab = 4,
    LineBreak = 8,
    ParagraphBreak = 16,
    ContainerBreak = 32
  }

  global['NSLayoutManager']['ControlCharacterAction'] = ControlCharacterAction;

  export enum GlyphProperty {
    Null = 1,
    ControlCharacter = 2,
    Elastic = 4,
    NonBaseCharacter = 8
  }

  global['NSLayoutManager']['GlyphProperty'] = GlyphProperty;

  export enum TextLayoutOrientation {
    Horizontal = 0,
    Vertical = 1
  }

  global['NSLayoutManager']['TextLayoutOrientation'] = TextLayoutOrientation;

  export enum TypesetterBehavior {
    LatestBehavior = -1,
    OriginalBehavior = 0,
    Behavior_10_2_WithCompatibility = 1,
    Behavior_10_2 = 2,
    Behavior_10_3 = 3,
    Behavior_10_4 = 4
  }

  global['NSLayoutManager']['TypesetterBehavior'] = TypesetterBehavior;

}

namespace NSLevelIndicator {
  export enum PlaceholderVisibility {
    Automatic = 0,
    Always = 1,
    WhileEditing = 2
  }

  global['NSLevelIndicator']['PlaceholderVisibility'] = PlaceholderVisibility;

  export enum Style {
    Relevancy = 0,
    ContinuousCapacity = 1,
    DiscreteCapacity = 2,
    Rating = 3
  }

  global['NSLevelIndicator']['Style'] = Style;

}

namespace NSLinguisticTag {
  export let adjective: string;
  export let adverb: string;
  export let classifier: string;
  export let closeParenthesis: string;
  export let closeQuote: string;
  export let conjunction: string;
  export let dash: string;
  export let determiner: string;
  export let idiom: string;
  export let interjection: string;
  export let noun: string;
  export let number: string;
  export let openParenthesis: string;
  export let openQuote: string;
  export let organizationName: string;
  export let other: string;
  export let otherPunctuation: string;
  export let otherWhitespace: string;
  export let otherWord: string;
  export let paragraphBreak: string;
  export let particle: string;
  export let personalName: string;
  export let placeName: string;
  export let preposition: string;
  export let pronoun: string;
  export let punctuation: string;
  export let sentenceTerminator: string;
  export let verb: string;
  export let whitespace: string;
  export let word: string;
  export let wordJoiner: string;
}

namespace NSLinguisticTagScheme {
  export let language: string;
  export let lemma: string;
  export let lexicalClass: string;
  export let nameType: string;
  export let nameTypeOrLexicalClass: string;
  export let script: string;
  export let tokenType: string;
}

namespace NSLinguisticTagger {
  export enum Options {
    OmitWords = 1,
    OmitPunctuation = 2,
    OmitWhitespace = 4,
    OmitOther = 8,
    JoinNames = 16
  }

  global['NSLinguisticTagger']['Options'] = Options;

}

namespace NSLocale {
  export enum LanguageDirection {
    Unknown = 0,
    LeftToRight = 1,
    RightToLeft = 2,
    TopToBottom = 3,
    BottomToTop = 4
  }

  global['NSLocale']['LanguageDirection'] = LanguageDirection;

  export let currentLocaleDidChangeNotification: string;
  export let alternateQuotationBeginDelimiterKey: string;
  export let alternateQuotationEndDelimiterKey: string;
  export let calendar: string;
  export let collationIdentifier: string;
  export let collatorIdentifier: string;
  export let countryCode: string;
  export let currencyCode: string;
  export let currencySymbol: string;
  export let decimalSeparator: string;
  export let exemplarCharacterSet: string;
  export let groupingSeparator: string;
  export let identifier: string;
  export let languageCode: string;
  export let measurementSystem: string;
  export let quotationBeginDelimiterKey: string;
  export let quotationEndDelimiterKey: string;
  export let scriptCode: string;
  export let usesMetricSystem: string;
  export let variantCode: string;
}

namespace NSMachPort {
  export enum Options {
    DeallocateNone = 0,
    DeallocateSendRight = 1,
    DeallocateReceiveRight = 2
  }

  global['NSMachPort']['Options'] = Options;

}

namespace NSManagedObject {
  export type ObjectWillChangePublisher = ObservableObjectPublisher;
}

namespace NSMatrix {
  export enum Mode {
    RadioModeMatrix = 0,
    HighlightModeMatrix = 1,
    ListModeMatrix = 2,
    TrackModeMatrix = 3
  }

  global['NSMatrix']['Mode'] = Mode;

}

namespace NSMediaLibraryBrowserController {
  export enum Library {
    Audio = 1,
    Image = 2,
    Movie = 4
  }

  global['NSMediaLibraryBrowserController']['Library'] = Library;

}

namespace NSMenu {
  export enum Properties {
    PropertyItemTitle = 1,
    PropertyItemAttributedTitle = 2,
    PropertyItemKeyEquivalent = 4,
    PropertyItemImage = 8,
    PropertyItemEnabled = 16,
    PropertyItemAccessibilityDescription = 32
  }

  global['NSMenu']['Properties'] = Properties;

  export let didAddItemNotification: string;
  export let didBeginTrackingNotification: string;
  export let didChangeItemNotification: string;
  export let didEndTrackingNotification: string;
  export let didRemoveItemNotification: string;
  export let didSendActionNotification: string;
  export let willSendActionNotification: string;
}

namespace NSMenuItem {
  export let importFromDeviceIdentifier: string;
}

namespace NSNib {
  export type Name = String;
}

namespace NSNotification {
  export let AVAssetChapterMetadataGroupsDidChange: string;
  export let AVAssetContainsFragmentsDidChange: string;
  export let AVAssetDurationDidChange: string;
  export let AVAssetMediaSelectionGroupsDidChange: string;
  export let AVAssetTrackSegmentsDidChange: string;
  export let AVAssetTrackTimeRangeDidChange: string;
  export let AVAssetTrackTrackAssociationsDidChange: string;
  export let AVAssetWasDefragmented: string;
  export let AVAudioEngineConfigurationChange: string;
  export let AVAudioUnitComponentTagsDidChange: string;
  export let AVCaptureDeviceSubjectAreaDidChange: string;
  export let AVCaptureDeviceWasConnected: string;
  export let AVCaptureDeviceWasDisconnected: string;
  export let AVCaptureInputPortFormatDescriptionDidChange: string;
  export let AVCaptureSessionDidStartRunning: string;
  export let AVCaptureSessionDidStopRunning: string;
  export let AVCaptureSessionInterruptionEnded: string;
  export let AVCaptureSessionRuntimeError: string;
  export let AVCaptureSessionWasInterrupted: string;
  export let AVFragmentedMovieContainsMovieFragmentsDidChange: string;
  export let AVFragmentedMovieDurationDidChange: string;
  export let AVFragmentedMovieTrackSegmentsDidChange: string;
  export let AVFragmentedMovieTrackTimeRangeDidChange: string;
  export let AVFragmentedMovieWasDefragmented: string;
  export let AVPlayerAvailableHDRModesDidChange: string;
  export let AVPlayerItemDidPlayToEndTime: string;
  export let AVPlayerItemFailedToPlayToEndTime: string;
  export let AVPlayerItemNewAccessLogEntry: string;
  export let AVPlayerItemNewErrorLogEntry: string;
  export let AVPlayerItemPlaybackStalled: string;
  export let AVPlayerItemTimeJumped: string;
  export let AVRouteDetectorMultipleRoutesDetectedDidChange: string;
  export let AVSampleBufferAudioRendererWasFlushedAutomatically: string;
  export let AVSampleBufferDisplayLayerFailedToDecode: string;
  export let NSAppleEventManagerWillProcessFirstEvent: string;
  export let NSBundleResourceRequestLowDiskSpace: string;
  export let NSCalendarDayChanged: string;
  export let NSClassDescriptionNeededForClass: string;
  export let NSDidBecomeSingleThreaded: string;
  export let NSExtensionHostDidBecomeActive: string;
  export let NSExtensionHostDidEnterBackground: string;
  export let NSExtensionHostWillEnterForeground: string;
  export let NSExtensionHostWillResignActive: string;
  export let NSFileHandleConnectionAccepted: string;
  export let NSFileHandleDataAvailable: string;
  export let NSFileHandleReadToEndOfFileCompletion: string;
  export let NSHTTPCookieManagerAcceptPolicyChanged: string;
  export let NSHTTPCookieManagerCookiesChanged: string;
  export let NSMetadataQueryDidFinishGathering: string;
  export let NSMetadataQueryDidStartGathering: string;
  export let NSMetadataQueryDidUpdate: string;
  export let NSMetadataQueryGatheringProgress: string;
  export let NSProcessInfoPowerStateDidChange: string;
  export let NSSystemClockDidChange: string;
  export let NSSystemTimeZoneDidChange: string;
  export let NSThreadWillExit: string;
  export let NSURLCredentialStorageChanged: string;
  export let NSUbiquityIdentityDidChange: string;
  export let NSUndoManagerCheckpoint: string;
  export let NSUndoManagerDidCloseUndoGroup: string;
  export let NSUndoManagerDidOpenUndoGroup: string;
  export let NSUndoManagerDidRedoChange: string;
  export let NSUndoManagerDidUndoChange: string;
  export let NSUndoManagerWillCloseUndoGroup: string;
  export let NSUndoManagerWillRedoChange: string;
  export let NSUndoManagerWillUndoChange: string;
  export let NSWillBecomeMultiThreaded: string;
  export let IKFilterBrowserFilterDoubleClick: string;
  export let IKFilterBrowserFilterSelected: string;
  export let IKFilterBrowserWillPreviewFilter: string;
  export let quartzFilterManagerDidAddFilter: string;
  export let quartzFilterManagerDidModifyFilter: string;
  export let quartzFilterManagerDidRemoveFilter: string;
  export let quartzFilterManagerDidSelectFilter: string;
}

namespace NSNumber {
  export type BooleanLiteralType = boolean;
  export type IntegerLiteralType = number;
  export type FloatLiteralType = number;
}

namespace NSOrderedSet {
  export type Iterator = NSFastEnumerationIterator;
}

namespace NSOutlineView {
  export let columnDidMoveNotification: string;
  export let columnDidResizeNotification: string;
  export let disclosureButtonIdentifier: string;
  export let itemDidCollapseNotification: string;
  export let itemDidExpandNotification: string;
  export let itemWillCollapseNotification: string;
  export let itemWillExpandNotification: string;
  export let selectionDidChangeNotification: string;
  export let selectionIsChangingNotification: string;
  export let showHideButtonIdentifier: string;
}

namespace NSPDFPanel {
  export enum Options {
    ShowsPaperSize = 4,
    ShowsOrientation = 8,
    RequestsParentDirectory = 16777216
  }

  global['NSPDFPanel']['Options'] = Options;

}

namespace NSPageController {
  export enum TransitionStyle {
    StackHistory = 0,
    StackBook = 1,
    HorizontalStrip = 2
  }

  global['NSPageController']['TransitionStyle'] = TransitionStyle;

  export type ObjectIdentifier = String;
}

namespace NSParagraphStyle {
  export enum TextTabType {
    LeftTabStopType = 0,
    RightTabStopType = 1,
    CenterTabStopType = 2,
    DecimalTabStopType = 3
  }

  global['NSParagraphStyle']['TextTabType'] = TextTabType;

  // struct
  export enum LineBreakStrategy {
    pushOut,
    hangulWordPriority,
    standard
  }

}

namespace NSPasteboard {
  export enum ContentsOptions {
    CurrentHostOnly = 1
  }

  global['NSPasteboard']['ContentsOptions'] = ContentsOptions;

  export enum ReadingOptions {
    AsData = 0,
    AsString = 1,
    AsPropertyList = 2,
    AsKeyedArchive = 4
  }

  global['NSPasteboard']['ReadingOptions'] = ReadingOptions;

  export enum WritingOptions {
    Promised = 512
  }

  global['NSPasteboard']['WritingOptions'] = WritingOptions;

  export let fileContents: string;
  export let findPanelSearchOptions: string;
  export let drag: string;
  export let find: string;
  export let font: string;
  export let general: string;
  export let ruler: string;
  export let color: string;
  export let fileURL: string;
  export let html: string;
  export let multipleTextSelection: string;
  export let pdf: string;
  export let png: string;
  export let rtf: string;
  export let rtfd: string;
  export let sound: string;
  export let string: string;
  export let tiff: string;
  export let tabularText: string;
  export let textFinderOptions: string;
  export let URL: string;
  export let urlReadingContentsConformToTypes: string;
  export let urlReadingFileURLsOnly: string;
  export let soundPboardType: string;
}

namespace NSPathControl {
  export enum Style {
    Standard = 0,
    PopUp = 2,
    NavigationBar = 1
  }

  global['NSPathControl']['Style'] = Style;

}

namespace NSPickerTouchBarItem {
  export enum ControlRepresentation {
    Automatic = 0,
    Expanded = 1,
    Collapsed = 2
  }

  global['NSPickerTouchBarItem']['ControlRepresentation'] = ControlRepresentation;

  export enum SelectionMode {
    SelectOne = 0,
    SelectAny = 1,
    Momentary = 2
  }

  global['NSPickerTouchBarItem']['SelectionMode'] = SelectionMode;

}

namespace NSPointerFunctions {
  export enum Options {
    StrongMemory = 0,
    ZeroingWeakMemory = 1,
    OpaqueMemory = 2,
    MallocMemory = 3,
    MachVirtualMemory = 4,
    WeakMemory = 5,
    ObjectPersonality = 0,
    OpaquePersonality = 256,
    ObjectPointerPersonality = 512,
    CStringPersonality = 768,
    StructPersonality = 1024,
    IntegerPersonality = 1280,
    CopyIn = 65536
  }

  global['NSPointerFunctions']['Options'] = Options;

}

namespace NSPopUpButton {
  export enum ArrowPosition {
    NoArrow = 0,
    ArrowAtCenter = 1,
    ArrowAtBottom = 2
  }

  global['NSPopUpButton']['ArrowPosition'] = ArrowPosition;

  export let willPopUpNotification: string;
}

namespace NSPopUpButtonCell {
  export let willPopUpNotification: string;
}

namespace NSPopover {
  export enum Behavior {
    ApplicationDefined = 0,
    Transient = 1,
    Semitransient = 2
  }

  global['NSPopover']['Behavior'] = Behavior;

  export let detachToWindow: string;
  export let closeReasonUserInfoKey: string;
  export let standard: string;
  export let didCloseNotification: string;
  export let didShowNotification: string;
  export let willCloseNotification: string;
  export let willShowNotification: string;
}

namespace NSPositionalSpecifier {
  export enum InsertionPosition {
    PositionAfter = 0,
    PositionBefore = 1,
    PositionBeginning = 2,
    PositionEnd = 3,
    PositionReplace = 4
  }

  global['NSPositionalSpecifier']['InsertionPosition'] = InsertionPosition;

}

namespace NSPrintInfo {
  export enum PaperOrientation {
    Portrait = 0,
    Landscape = 1
  }

  global['NSPrintInfo']['PaperOrientation'] = PaperOrientation;

  export enum PaginationMode {
    Automatic = 0,
    Fit = 1,
    Clip = 2
  }

  global['NSPrintInfo']['PaginationMode'] = PaginationMode;

  export let automatic: NSPrintInfo.PaginationMode;
  export let clip: NSPrintInfo.PaginationMode;
  export let fit: NSPrintInfo.PaginationMode;
  export let allPages: string;
  export let bottomMargin: string;
  export let cancel: string;
  export let copies: string;
  export let detailedErrorReporting: string;
  export let faxNumber: string;
  export let firstPage: string;
  export let headerAndFooter: string;
  export let horizontalPagination: string;
  export let horizontallyCentered: string;
  export let jobDisposition: string;
  export let jobSavingFileNameExtensionHidden: string;
  export let jobSavingURL: string;
  export let lastPage: string;
  export let leftMargin: string;
  export let mustCollate: string;
  export let orientation: string;
  export let pagesAcross: string;
  export let pagesDown: string;
  export let paperName: string;
  export let paperSize: string;
  export let preview: string;
  export let printer: string;
  export let printerName: string;
  export let reversePageOrder: string;
  export let rightMargin: string;
  export let save: string;
  export let scalingFactor: string;
  export let selectionOnly: string;
  export let spool: string;
  export let time: string;
  export let topMargin: string;
  export let verticalPagination: string;
  export let verticallyCentered: string;
  export type SettingKey = String;
}

namespace NSPrintOperation {
  export enum RenderingQuality {
    Best = 0,
    Responsive = 1
  }

  global['NSPrintOperation']['RenderingQuality'] = RenderingQuality;

  export enum PageOrder {
    DescendingPageOrder = -1,
    SpecialPageOrder = 0,
    AscendingPageOrder = 1,
    UnknownPageOrder = 2
  }

  global['NSPrintOperation']['PageOrder'] = PageOrder;

}

namespace NSPrintPanel {
  export enum Options {
    ShowsCopies = 1,
    ShowsPageRange = 2,
    ShowsPaperSize = 4,
    ShowsOrientation = 8,
    ShowsScaling = 16,
    ShowsPrintSelection = 32,
    ShowsPageSetupAccessory = 256,
    ShowsPreview = 131072
  }

  global['NSPrintPanel']['Options'] = Options;

  export let allPresets: string;
  export let noPresets: string;
  export let itemDescription: string;
  export let itemName: string;
  export let photo: string;
}

namespace NSPrinter {
  export enum TableStatus {
    OK = 0,
    NotFound = 1,
    Error = 2
  }

  global['NSPrinter']['TableStatus'] = TableStatus;

}

namespace NSProgressIndicator {
  export enum Style {
    Bar = 0,
    Spinning = 1
  }

  global['NSProgressIndicator']['Style'] = Style;

}

namespace NSRegularExpression {
  export enum MatchingFlags {
    Progress = 1,
    Completed = 2,
    HitEnd = 4,
    RequiredEnd = 8,
    InternalError = 16
  }

  global['NSRegularExpression']['MatchingFlags'] = MatchingFlags;

  export enum MatchingOptions {
    ReportProgress = 1,
    ReportCompletion = 2,
    Anchored = 4,
    WithTransparentBounds = 8,
    WithoutAnchoringBounds = 16
  }

  global['NSRegularExpression']['MatchingOptions'] = MatchingOptions;

  export enum Options {
    CaseInsensitive = 1,
    AllowCommentsAndWhitespace = 2,
    IgnoreMetacharacters = 4,
    DotMatchesLineSeparators = 8,
    AnchorsMatchLines = 16,
    UseUnixLineSeparators = 32,
    UseUnicodeWordBoundaries = 64
  }

  global['NSRegularExpression']['Options'] = Options;

}

namespace NSRelativeSpecifier {
  export enum RelativePosition {
    After = 0,
    Before = 1
  }

  global['NSRelativeSpecifier']['RelativePosition'] = RelativePosition;

}

namespace NSRuleEditor {
  export enum NestingMode {
    Single = 0,
    List = 1,
    Compound = 2,
    Simple = 3
  }

  global['NSRuleEditor']['NestingMode'] = NestingMode;

  export enum RowType {
    Simple = 0,
    Compound = 1
  }

  global['NSRuleEditor']['RowType'] = RowType;

  export let comparisonModifier: string;
  export let compoundType: string;
  export let customSelector: string;
  export let leftExpression: string;
  export let operatorType: string;
  export let options: string;
  export let rightExpression: string;
  export let rowsDidChangeNotification: string;
}

namespace NSRulerView {
  export enum Orientation {
    HorizontalRuler = 0,
    VerticalRuler = 1
  }

  global['NSRulerView']['Orientation'] = Orientation;

  export let centimeters: string;
  export let inches: string;
  export let picas: string;
  export let points: string;
}

namespace NSScreen {
  export let colorSpaceDidChangeNotification: string;
}

namespace NSScrollView {
  export enum Elasticity {
    Automatic = 0,
    None = 1,
    Allowed = 2
  }

  global['NSScrollView']['Elasticity'] = Elasticity;

  export enum FindBarPosition {
    AboveHorizontalRuler = 0,
    AboveContent = 1,
    BelowContent = 2
  }

  global['NSScrollView']['FindBarPosition'] = FindBarPosition;

  export let didEndLiveMagnifyNotification: string;
  export let didEndLiveScrollNotification: string;
  export let didLiveScrollNotification: string;
  export let willStartLiveMagnifyNotification: string;
  export let willStartLiveScrollNotification: string;
}

namespace NSScroller {
  export enum KnobStyle {
    Default = 0,
    Dark = 1,
    Light = 2
  }

  global['NSScroller']['KnobStyle'] = KnobStyle;

  export enum Part {
    NoPart = 0,
    DecrementPage = 1,
    Knob = 2,
    IncrementPage = 3,
    DecrementLine = 4,
    IncrementLine = 5,
    KnobSlot = 6
  }

  global['NSScroller']['Part'] = Part;

  export enum Style {
    Legacy = 0,
    Overlay = 1
  }

  global['NSScroller']['Style'] = Style;

  export enum UsableParts {
    NoScrollerParts = 0,
    OnlyScrollerArrows = 1,
    AllScrollerParts = 2
  }

  global['NSScroller']['UsableParts'] = UsableParts;

  export let preferredScrollerStyleDidChangeNotification: string;
}

namespace NSScrubber {
  export enum Alignment {
    None = 0,
    Leading = 1,
    Trailing = 2,
    Center = 3
  }

  global['NSScrubber']['Alignment'] = Alignment;

  export enum Mode {
    Fixed = 0,
    Free = 1
  }

  global['NSScrubber']['Mode'] = Mode;

}

namespace NSSearchField {
  export let clearRecentsMenuItemTag: number;
  export let noRecentsMenuItemTag: number;
  export let recentsMenuItemTag: number;
  export let recentsTitleMenuItemTag: number;
  export type RecentsAutosaveName = String;
}

namespace NSSegmentedControl {
  export enum Distribution {
    Fit = 0,
    Fill = 1,
    FillEqually = 2,
    FillProportionally = 3
  }

  global['NSSegmentedControl']['Distribution'] = Distribution;

  export enum Style {
    Automatic = 0,
    Rounded = 1,
    RoundRect = 3,
    TexturedSquare = 4,
    SmallSquare = 6,
    Separated = 8,
    TexturedRounded = 2,
    Capsule = 5
  }

  global['NSSegmentedControl']['Style'] = Style;

  export enum SwitchTracking {
    SelectOne = 0,
    SelectAny = 1,
    Momentary = 2,
    MomentaryAccelerator = 3
  }

  global['NSSegmentedControl']['SwitchTracking'] = SwitchTracking;

}

namespace NSSet {
  export type Iterator = NSFastEnumerationIterator;
}

namespace NSSharingService {
  export enum CloudKitOptions {
    Standard = 0,
    AllowPublic = 1,
    AllowPrivate = 2,
    AllowReadOnly = 16,
    AllowReadWrite = 32
  }

  global['NSSharingService']['CloudKitOptions'] = CloudKitOptions;

  export enum SharingContentScope {
    Item = 0,
    Partial = 1,
    Full = 2
  }

  global['NSSharingService']['SharingContentScope'] = SharingContentScope;

  export let addToAperture: string;
  export let addToIPhoto: string;
  export let addToSafariReadingList: string;
  export let cloudSharing: string;
  export let composeEmail: string;
  export let composeMessage: string;
  export let sendViaAirDrop: string;
  export let useAsDesktopPicture: string;
}

namespace NSSlider {
  export enum SliderType {
    Linear = 0,
    Circular = 1
  }

  global['NSSlider']['SliderType'] = SliderType;

  export enum TickMarkPosition {
    Below = 0,
    Above = 1,
    Leading = 1,
    Trailing = 0
  }

  global['NSSlider']['TickMarkPosition'] = TickMarkPosition;

}

namespace NSSliderAccessory {
  export let default_: number;
  export let wide: number;
}

namespace NSSound {
  export type Name = String;
  export type PlaybackDeviceIdentifier = String;
}

namespace NSSpecifierTest {
  export enum TestComparisonOperation {
    EqualToComparison = 0,
    LessThanOrEqualToComparison = 1,
    LessThanComparison = 2,
    GreaterThanOrEqualToComparison = 3,
    GreaterThanComparison = 4,
    BeginsWithComparison = 5,
    EndsWithComparison = 6,
    ContainsComparison = 7
  }

  global['NSSpecifierTest']['TestComparisonOperation'] = TestComparisonOperation;

}

namespace NSSpeechSynthesizer {
  export enum Boundary {
    ImmediateBoundary = 0,
    WordBoundary = 1,
    SentenceBoundary = 2
  }

  global['NSSpeechSynthesizer']['Boundary'] = Boundary;

  export let characterMode: string;
  export let commandDelimiter: string;
  export let currentVoice: string;
  export let abbreviations: string;
  export let entryPhonemes: string;
  export let entrySpelling: string;
  export let localeIdentifier: string;
  export let modificationDate: string;
  export let pronunciations: string;
  export let errors: string;
  export let inputMode: string;
  export let numberMode: string;
  export let outputToFileURL: string;
  export let phonemeSymbols: string;
  export let pitchBase: string;
  export let pitchMod: string;
  export let rate: string;
  export let recentSync: string;
  export let reset: string;
  export let status: string;
  export let synthesizerInfo: string;
  export let volume: string;
  export let age: string;
  export let demoText: string;
  export let gender: string;
  export let female: string;
  export let male: string;
  export let neuter: string;
  export let identifier: string;
  export let individuallySpokenCharacters: string;
  export let name: string;
  export let supportedCharacters: string;
}

namespace NSSpellChecker {
  export enum CorrectionIndicatorType {
    Default = 0,
    Reversion = 1,
    Guesses = 2
  }

  global['NSSpellChecker']['CorrectionIndicatorType'] = CorrectionIndicatorType;

  export enum CorrectionResponse {
    None = 0,
    Accepted = 1,
    Rejected = 2,
    Ignored = 3,
    Edited = 4,
    Reverted = 5
  }

  global['NSSpellChecker']['CorrectionResponse'] = CorrectionResponse;

  export let didChangeAutomaticCapitalizationNotification: string;
  export let didChangeAutomaticDashSubstitutionNotification: string;
  export let didChangeAutomaticPeriodSubstitutionNotification: string;
  export let didChangeAutomaticQuoteSubstitutionNotification: string;
  export let didChangeAutomaticSpellingCorrectionNotification: string;
  export let didChangeAutomaticTextCompletionNotification: string;
  export let didChangeAutomaticTextReplacementNotification: string;
  export let documentAuthor: string;
  export let documentTitle: string;
  export let documentURL: string;
  export let orthography: string;
  export let quotes: string;
  export let referenceDate: string;
  export let referenceTimeZone: string;
  export let regularExpressions: string;
  export let replacements: string;
  export let selectedRange: string;
}

namespace NSSplitView {
  export enum DividerStyle {
    Thick = 1,
    Thin = 2,
    PaneSplitter = 3
  }

  global['NSSplitView']['DividerStyle'] = DividerStyle;

  export let didResizeSubviewsNotification: string;
  export let willResizeSubviewsNotification: string;
  export type AutosaveName = String;
}

namespace NSSplitViewController {
  export let automaticDimension: number;
}

namespace NSSplitViewItem {
  export enum Behavior {
    Default = 0,
    Sidebar = 1,
    ContentList = 2
  }

  global['NSSplitViewItem']['Behavior'] = Behavior;

  export enum CollapseBehavior {
    Default = 0,
    PreferResizingSplitViewWithFixedSiblings = 1,
    PreferResizingSiblingsWithFixedSplitView = 2,
    UseConstraints = 3
  }

  global['NSSplitViewItem']['CollapseBehavior'] = CollapseBehavior;

  export let unspecifiedDimension: number;
}

namespace NSStackView {
  export enum Distribution {
    GravityAreas = -1,
    Fill = 0,
    FillEqually = 1,
    FillProportionally = 2,
    EqualSpacing = 3,
    EqualCentering = 4
  }

  global['NSStackView']['Distribution'] = Distribution;

  export enum Gravity {
    Top = 1,
    Leading = 1,
    Center = 2,
    Bottom = 3,
    Trailing = 3
  }

  global['NSStackView']['Gravity'] = Gravity;

  export let useDefaultSpacing: number;
  export let detachOnlyIfNecessary: number;
  export let mustHold: number;
  export let notVisible: number;
}

namespace NSStatusItem {
  export enum Behavior {
    RemovalAllowed = 2,
    TerminationOnRemoval = 4
  }

  global['NSStatusItem']['Behavior'] = Behavior;

  export let squareLength: number;
  export let variableLength: number;
  export type AutosaveName = String;
}

namespace NSStoryboard {
  export type Name = String;
  export type SceneIdentifier = String;
}

namespace NSStoryboardSegue {
  export type Identifier = String;
}

namespace NSString {
  export enum DrawingOptions {
    UsesLineFragmentOrigin = 1,
    UsesFontLeading = 2,
    UsesDeviceMetrics = 8,
    TruncatesLastVisibleLine = 32,
    DisableScreenFontSubstitution = 4,
    OneShot = 16
  }

  global['NSString']['DrawingOptions'] = DrawingOptions;

  export enum CompareOptions {
    CaseInsensitiveSearch = 1,
    LiteralSearch = 2,
    BackwardsSearch = 4,
    AnchoredSearch = 8,
    NumericSearch = 64,
    DiacriticInsensitiveSearch = 128,
    WidthInsensitiveSearch = 256,
    ForcedOrderingSearch = 512,
    RegularExpressionSearch = 1024
  }

  global['NSString']['CompareOptions'] = CompareOptions;

  export enum EncodingConversionOptions {
    AllowLossy = 1,
    ExternalRepresentation = 2
  }

  global['NSString']['EncodingConversionOptions'] = EncodingConversionOptions;

  export enum EnumerationOptions {
    ByLines = 0,
    ByParagraphs = 1,
    ByComposedCharacterSequences = 2,
    ByWords = 3,
    BySentences = 4,
    Reverse = 256,
    SubstringNotRequired = 512,
    Localized = 1024
  }

  global['NSString']['EnumerationOptions'] = EnumerationOptions;

  export type StringLiteralType = string;
  export type ExtendedGraphemeClusterLiteralType = string;
  export type UnicodeScalarLiteralType = string;
}

namespace NSTabView {
  export enum TabPosition {
    None = 0,
    Top = 1,
    Left = 2,
    Bottom = 3,
    Right = 4
  }

  global['NSTabView']['TabPosition'] = TabPosition;

  export enum TabViewBorderType {
    None = 0,
    Line = 1,
    Bezel = 2
  }

  global['NSTabView']['TabViewBorderType'] = TabViewBorderType;

  export enum TabType {
    TopTabsBezelBorder = 0,
    LeftTabsBezelBorder = 1,
    BottomTabsBezelBorder = 2,
    RightTabsBezelBorder = 3,
    NoTabsBezelBorder = 4,
    NoTabsLineBorder = 5,
    NoTabsNoBorder = 6
  }

  global['NSTabView']['TabType'] = TabType;

}

namespace NSTabViewController {
  export enum TabStyle {
    SegmentedControlOnTop = 0,
    SegmentedControlOnBottom = 1,
    Toolbar = 2,
    Unspecified = -1
  }

  global['NSTabViewController']['TabStyle'] = TabStyle;

}

namespace NSTabViewItem {
  export enum State {
    SelectedTab = 0,
    BackgroundTab = 1,
    PressedTab = 2
  }

  global['NSTabViewItem']['State'] = State;

}

namespace NSTableColumn {
  export enum ResizingOptions {
    NoResizing = 0,
    AutoresizingMask = 1,
    UserResizingMask = 2
  }

  global['NSTableColumn']['ResizingOptions'] = ResizingOptions;

}

namespace NSTableView {
  export enum RowActionEdge {
    Leading = 0,
    Trailing = 1
  }

  global['NSTableView']['RowActionEdge'] = RowActionEdge;

  export enum AnimationOptions {
    EffectNone = 0,
    EffectFade = 1,
    EffectGap = 2,
    SlideUp = 16,
    SlideDown = 32,
    SlideLeft = 48,
    SlideRight = 64
  }

  global['NSTableView']['AnimationOptions'] = AnimationOptions;

  export enum ColumnAutoresizingStyle {
    NoColumnAutoresizing = 0,
    UniformColumnAutoresizingStyle = 1,
    SequentialColumnAutoresizingStyle = 2,
    ReverseSequentialColumnAutoresizingStyle = 3,
    LastColumnOnlyAutoresizingStyle = 4,
    FirstColumnOnlyAutoresizingStyle = 5
  }

  global['NSTableView']['ColumnAutoresizingStyle'] = ColumnAutoresizingStyle;

  export enum DraggingDestinationFeedbackStyle {
    None = -1,
    Regular = 0,
    SourceList = 1,
    Gap = 2
  }

  global['NSTableView']['DraggingDestinationFeedbackStyle'] = DraggingDestinationFeedbackStyle;

  export enum DropOperation {
    On = 0,
    Above = 1
  }

  global['NSTableView']['DropOperation'] = DropOperation;

  export enum GridLineStyle {
    GridNone = 0,
    SolidVerticalGridLineMask = 1,
    SolidHorizontalGridLineMask = 2,
    DashedHorizontalGridLineMask = 8
  }

  global['NSTableView']['GridLineStyle'] = GridLineStyle;

  export enum RowSizeStyle {
    Default = -1,
    Custom = 0,
    Small = 1,
    Medium = 2,
    Large = 3
  }

  global['NSTableView']['RowSizeStyle'] = RowSizeStyle;

  export enum SelectionHighlightStyle {
    None = -1,
    Regular = 0,
    SourceList = 1
  }

  global['NSTableView']['SelectionHighlightStyle'] = SelectionHighlightStyle;

  export let columnDidMoveNotification: string;
  export let columnDidResizeNotification: string;
  export let rowViewIdentifier: string;
  export let selectionDidChangeNotification: string;
  export let selectionIsChangingNotification: string;
  export type AutosaveName = String;
}

namespace NSTableViewRowAction {
  export enum Style {
    Regular = 0,
    Destructive = 1
  }

  global['NSTableViewRowAction']['Style'] = Style;

}

namespace NSText {
  export let didBeginEditingNotification: string;
  export let didChangeNotification: string;
  export let didEndEditingNotification: string;
  export let movementUserInfoKey: string;
}

namespace NSTextAlternatives {
  export let selectedAlternativeStringNotification: string;
}

namespace NSTextBlock {
  export enum Dimension {
    Width = 0,
    MinimumWidth = 1,
    MaximumWidth = 2,
    Height = 4,
    MinimumHeight = 5,
    MaximumHeight = 6
  }

  global['NSTextBlock']['Dimension'] = Dimension;

  export enum Layer {
    Padding = -1,
    Border = 0,
    Margin = 1
  }

  global['NSTextBlock']['Layer'] = Layer;

  export enum ValueType {
    AbsoluteValueType = 0,
    PercentageValueType = 1
  }

  global['NSTextBlock']['ValueType'] = ValueType;

  export enum VerticalAlignment {
    TopAlignment = 0,
    MiddleAlignment = 1,
    BottomAlignment = 2,
    BaselineAlignment = 3
  }

  global['NSTextBlock']['VerticalAlignment'] = VerticalAlignment;

}

namespace NSTextCheckingKey {
  export let airline: string;
  export let city: string;
  export let country: string;
  export let flight: string;
  export let jobTitle: string;
  export let name: string;
  export let organization: string;
  export let phone: string;
  export let state: string;
  export let street: string;
  export let zip: string;
}

namespace NSTextCheckingResult {
  export enum CheckingType {
    Orthography = 1,
    Spelling = 2,
    Grammar = 4,
    Date = 8,
    Address = 16,
    Link = 32,
    Quote = 64,
    Dash = 128,
    Replacement = 256,
    Correction = 512,
    RegularExpression = 1024,
    PhoneNumber = 2048,
    TransitInformation = 4096
  }

  global['NSTextCheckingResult']['CheckingType'] = CheckingType;

}

namespace NSTextField {
  export enum BezelStyle {
    SquareBezel = 0,
    RoundedBezel = 1
  }

  global['NSTextField']['BezelStyle'] = BezelStyle;

}

namespace NSTextFinder {
  export enum Action {
    ShowFindInterface = 1,
    NextMatch = 2,
    PreviousMatch = 3,
    ReplaceAll = 4,
    Replace = 5,
    ReplaceAndFind = 6,
    SetSearchString = 7,
    ReplaceAllInSelection = 8,
    SelectAll = 9,
    SelectAllInSelection = 10,
    HideFindInterface = 11,
    ShowReplaceInterface = 12,
    HideReplaceInterface = 13
  }

  global['NSTextFinder']['Action'] = Action;

  export enum MatchingType {
    Contains = 0,
    StartsWith = 1,
    FullWord = 2,
    EndsWith = 3
  }

  global['NSTextFinder']['MatchingType'] = MatchingType;

}

namespace NSTextInputContext {
  export let keyboardSelectionDidChangeNotification: string;
}

namespace NSTextList {
  export enum Options {
    PrependEnclosingMarker = 1
  }

  global['NSTextList']['Options'] = Options;

  export let box: string;
  export let check: string;
  export let circle: string;
  export let decimal: string;
  export let diamond: string;
  export let disc: string;
  export let hyphen: string;
  export let lowercaseAlpha: string;
  export let lowercaseHexadecimal: string;
  export let lowercaseLatin: string;
  export let lowercaseRoman: string;
  export let octal: string;
  export let square: string;
  export let uppercaseAlpha: string;
  export let uppercaseHexadecimal: string;
  export let uppercaseLatin: string;
  export let uppercaseRoman: string;
}

namespace NSTextStorage {
  export let didProcessEditingNotification: string;
  export let willProcessEditingNotification: string;
}

namespace NSTextTab {
  export let columnTerminators: string;
}

namespace NSTextTable {
  export enum LayoutAlgorithm {
    AutomaticLayoutAlgorithm = 0,
    FixedLayoutAlgorithm = 1
  }

  global['NSTextTable']['LayoutAlgorithm'] = LayoutAlgorithm;

}

namespace NSTextView {
  export let didChangeSelectionNotification: string;
  export let didChangeTypingAttributesNotification: string;
  export let willChangeNotifyingTextViewNotification: string;
}

namespace NSTimeZone {
  export enum NameStyle {
    Standard = 0,
    ShortStandard = 1,
    DaylightSaving = 2,
    ShortDaylightSaving = 3,
    Generic = 4,
    ShortGeneric = 5
  }

  global['NSTimeZone']['NameStyle'] = NameStyle;

}

namespace NSTokenField {
  export enum TokenStyle {
    Default = 0,
    None = 1,
    Rounded = 2,
    Squared = 3,
    PlainSquared = 4
  }

  global['NSTokenField']['TokenStyle'] = TokenStyle;

}

namespace NSToolbar {
  export enum DisplayMode {
    Default = 0,
    IconAndLabel = 1,
    IconOnly = 2,
    LabelOnly = 3
  }

  global['NSToolbar']['DisplayMode'] = DisplayMode;

  export enum SizeMode {
    Default = 0,
    Regular = 1,
    Small = 2
  }

  global['NSToolbar']['SizeMode'] = SizeMode;

  export let didRemoveItemNotification: string;
  export let willAddItemNotification: string;
  export type Identifier = String;
}

namespace NSToolbarItem {
  export let cloudSharing: string;
  export let customizeToolbar: string;
  export let flexibleSpace: string;
  export let high: number;
  export let low: number;
  export let standard: number;
  export let user: number;
  export let print: string;
  export let separator: string;
  export let showColors: string;
  export let showFonts: string;
  export let space: string;
  export let toggleSidebar: string;
}

namespace NSToolbarItemGroup {
  export enum ControlRepresentation {
    Automatic = 0,
    Expanded = 1,
    Collapsed = 2
  }

  global['NSToolbarItemGroup']['ControlRepresentation'] = ControlRepresentation;

  export enum SelectionMode {
    SelectOne = 0,
    SelectAny = 1,
    Momentary = 2
  }

  global['NSToolbarItemGroup']['SelectionMode'] = SelectionMode;

}

namespace NSTouch {
  export enum Phase {
    Began = 1,
    Moved = 2,
    Stationary = 4,
    Ended = 8,
    Cancelled = 16,
    Touching = 7,
    Any = -1
  }

  global['NSTouch']['Phase'] = Phase;

  export enum TouchType {
    Direct = 0,
    Indirect = 1
  }

  global['NSTouch']['TouchType'] = TouchType;

  export enum TouchTypeMask {
    Direct = 1,
    Indirect = 2
  }

  global['NSTouch']['TouchTypeMask'] = TouchTypeMask;

}

namespace NSTouchBar {
  export type CustomizationIdentifier = String;
}

namespace NSTouchBarItem {
  export let candidateList: string;
  export let characterPicker: string;
  export let fixedSpaceLarge: string;
  export let fixedSpaceSmall: string;
  export let flexibleSpace: string;
  export let otherItemsProxy: string;
  export let textAlignment: string;
  export let textColorPicker: string;
  export let textFormat: string;
  export let textList: string;
  export let textStyle: string;
  export let high: number;
  export let low: number;
  export let normal: number;
}

namespace NSTrackingArea {
  export enum Options {
    MouseEnteredAndExited = 1,
    MouseMoved = 2,
    CursorUpdate = 4,
    ActiveWhenFirstResponder = 16,
    ActiveInKeyWindow = 32,
    ActiveInActiveApp = 64,
    ActiveAlways = 128,
    AssumeInside = 256,
    InVisibleRect = 512,
    EnabledDuringMouseDrag = 1024
  }

  global['NSTrackingArea']['Options'] = Options;

}

namespace NSURL {
  export enum BookmarkCreationOptions {
    PreferFileIDResolution = 256,
    MinimalBookmark = 512,
    SuitableForBookmarkFile = 1024,
    WithSecurityScope = 2048,
    SecurityScopeAllowOnlyReadAccess = 4096
  }

  global['NSURL']['BookmarkCreationOptions'] = BookmarkCreationOptions;

  export enum BookmarkResolutionOptions {
    WithoutUI = 256,
    WithoutMounting = 512,
    WithSecurityScope = 1024
  }

  global['NSURL']['BookmarkResolutionOptions'] = BookmarkResolutionOptions;

  export type BookmarkFileCreationOptions = number;
}

namespace NSURLHandle {
  export enum Status {
    NotLoaded = 0,
    LoadSucceeded = 1,
    LoadInProgress = 2,
    LoadFailed = 3
  }

  global['NSURLHandle']['Status'] = Status;

}

namespace NSURLRequest {
  export enum CachePolicy {
    UseProtocolCachePolicy = 0,
    ReloadIgnoringLocalCacheData = 1,
    ReloadIgnoringLocalAndRemoteCacheData = 4,
    ReloadIgnoringCacheData = 1,
    ReturnCacheDataElseLoad = 2,
    ReturnCacheDataDontLoad = 3,
    ReloadRevalidatingCacheData = 5
  }

  global['NSURLRequest']['CachePolicy'] = CachePolicy;

  export enum NetworkServiceType {
    NetworkServiceTypeDefault = 0,
    NetworkServiceTypeVoIP = 1,
    NetworkServiceTypeVideo = 2,
    NetworkServiceTypeBackground = 3,
    NetworkServiceTypeVoice = 4,
    NetworkServiceTypeResponsiveData = 6,
    NetworkServiceTypeAVStreaming = 8,
    NetworkServiceTypeResponsiveAV = 9,
    NetworkServiceTypeCallSignaling = 11
  }

  global['NSURLRequest']['NetworkServiceType'] = NetworkServiceType;

}

namespace NSUbiquitousKeyValueStore {
  export let didChangeExternallyNotification: string;
}

namespace NSUserNotification {
  export enum ActivationType {
    None = 0,
    ContentsClicked = 1,
    ActionButtonClicked = 2,
    Replied = 3,
    AdditionalActionClicked = 4
  }

  global['NSUserNotification']['ActivationType'] = ActivationType;

}

namespace NSValueTransformerName {
  export let isNilTransformerName: string;
  export let isNotNilTransformerName: string;
  export let negateBooleanTransformerName: string;
  export let secureUnarchiveFromDataTransformerName: string;
}

namespace NSView {
  export enum AutoresizingMask {
    ViewNotSizable = 0,
    ViewMinXMargin = 1,
    ViewWidthSizable = 2,
    ViewMaxXMargin = 4,
    ViewMinYMargin = 8,
    ViewHeightSizable = 16,
    ViewMaxYMargin = 32
  }

  global['NSView']['AutoresizingMask'] = AutoresizingMask;

  export enum BackgroundStyle {
    Normal = 0,
    Emphasized = 1,
    Raised = 2,
    Lowered = 3
  }

  global['NSView']['BackgroundStyle'] = BackgroundStyle;

  export enum LayerContentsPlacement {
    ScaleAxesIndependently = 0,
    ScaleProportionallyToFit = 1,
    ScaleProportionallyToFill = 2,
    Center = 3,
    Top = 4,
    TopRight = 5,
    Right = 6,
    BottomRight = 7,
    Bottom = 8,
    BottomLeft = 9,
    Left = 10,
    TopLeft = 11
  }

  global['NSView']['LayerContentsPlacement'] = LayerContentsPlacement;

  export enum LayerContentsRedrawPolicy {
    Never = 0,
    OnSetNeedsDisplay = 1,
    DuringViewResize = 2,
    BeforeViewResize = 3,
    Crossfade = 4
  }

  global['NSView']['LayerContentsRedrawPolicy'] = LayerContentsRedrawPolicy;

  export let emphasized: NSView.BackgroundStyle;
  export let normal: NSView.BackgroundStyle;
  export let dictionaryApplication: string;
  export let presentationType: string;
  export let overlay: string;
  export let fullScreenModeAllScreens: string;
  export let fullScreenModeApplicationPresentationOptions: string;
  export let fullScreenModeSetting: string;
  export let fullScreenModeWindowLevel: string;
  export let boundsDidChangeNotification: string;
  export let didUpdateTrackingAreasNotification: string;
  export let frameDidChangeNotification: string;
  export let noIntrinsicMetric: number;
  export type TrackingRectTag = number;
  export type ToolTipTag = number;
}

namespace NSViewAnimation {
  export let effect: string;
  export let endFrame: string;
  export let fadeIn: string;
  export let fadeOut: string;
  export let startFrame: string;
  export let target: string;
}

namespace NSViewController {
  export enum TransitionOptions {
    None = 0,
    Crossfade = 1,
    SlideUp = 16,
    SlideDown = 32,
    SlideLeft = 64,
    SlideRight = 128,
    SlideForward = 320,
    SlideBackward = 384,
    AllowUserInteraction = 4096
  }

  global['NSViewController']['TransitionOptions'] = TransitionOptions;

}

namespace NSVisualEffectView {
  export enum BlendingMode {
    BehindWindow = 0,
    WithinWindow = 1
  }

  global['NSVisualEffectView']['BlendingMode'] = BlendingMode;

  export enum Material {
    Titlebar = 3,
    Selection = 4,
    Menu = 5,
    Popover = 6,
    Sidebar = 7,
    HeaderView = 10,
    Sheet = 11,
    WindowBackground = 12,
    HUDWindow = 13,
    FullScreenUI = 15,
    ToolTip = 17,
    ContentBackground = 18,
    UnderWindowBackground = 21,
    UnderPageBackground = 22,
    AppearanceBased = 0,
    Light = 1,
    Dark = 2,
    MediumLight = 8,
    UltraDark = 9
  }

  global['NSVisualEffectView']['Material'] = Material;

  export enum State {
    FollowsWindowActiveState = 0,
    Active = 1,
    Inactive = 2
  }

  global['NSVisualEffectView']['State'] = State;

}

namespace NSWhoseSpecifier {
  export enum SubelementIdentifier {
    IndexSubelement = 0,
    EverySubelement = 1,
    MiddleSubelement = 2,
    RandomSubelement = 3,
    NoSubelement = 4
  }

  global['NSWhoseSpecifier']['SubelementIdentifier'] = SubelementIdentifier;

}

namespace NSWindow {
  export enum BackingStoreType {
    Retained = 0,
    Nonretained = 1,
    Buffered = 2
  }

  global['NSWindow']['BackingStoreType'] = BackingStoreType;

  export enum SelectionDirection {
    DirectSelection = 0,
    SelectingNext = 1,
    SelectingPrevious = 2
  }

  global['NSWindow']['SelectionDirection'] = SelectionDirection;

  export enum AnimationBehavior {
    Default = 0,
    None = 2,
    DocumentWindow = 3,
    UtilityWindow = 4,
    AlertPanel = 5
  }

  global['NSWindow']['AnimationBehavior'] = AnimationBehavior;

  export enum ButtonType {
    CloseButton = 0,
    MiniaturizeButton = 1,
    ZoomButton = 2,
    ToolbarButton = 3,
    DocumentIconButton = 4,
    DocumentVersionsButton = 6
  }

  global['NSWindow']['ButtonType'] = ButtonType;

  export enum CollectionBehavior {
    Default = 0,
    CanJoinAllSpaces = 1,
    MoveToActiveSpace = 2,
    Managed = 4,
    Transient = 8,
    Stationary = 16,
    ParticipatesInCycle = 32,
    IgnoresCycle = 64,
    FullScreenPrimary = 128,
    FullScreenAuxiliary = 256,
    FullScreenNone = 512,
    FullScreenAllowsTiling = 2048,
    FullScreenDisallowsTiling = 4096
  }

  global['NSWindow']['CollectionBehavior'] = CollectionBehavior;

  export enum Depth {
    TwentyfourBitRGB = 520,
    SixtyfourBitRGB = 528,
    OnehundredtwentyeightBitRGB = 544
  }

  global['NSWindow']['Depth'] = Depth;

  export enum NumberListOptions {
    AllApplications = 1,
    AllSpaces = 16
  }

  global['NSWindow']['NumberListOptions'] = NumberListOptions;

  export enum OcclusionState {
    Visible = 2
  }

  global['NSWindow']['OcclusionState'] = OcclusionState;

  export enum OrderingMode {
    Above = 1,
    Below = -1,
    Out = 0
  }

  global['NSWindow']['OrderingMode'] = OrderingMode;

  export enum SharingType {
    None = 0,
    ReadOnly = 1,
    ReadWrite = 2
  }

  global['NSWindow']['SharingType'] = SharingType;

  export enum StyleMask {
    Borderless = 0,
    Titled = 1,
    Closable = 2,
    Miniaturizable = 4,
    Resizable = 8,
    TexturedBackground = 256,
    UnifiedTitleAndToolbar = 4096,
    FullScreen = 16384,
    FullSizeContentView = 32768,
    UtilityWindow = 16,
    DocModalWindow = 64,
    NonactivatingPanel = 128,
    HUDWindow = 8192
  }

  global['NSWindow']['StyleMask'] = StyleMask;

  export enum TabbingMode {
    Automatic = 0,
    Preferred = 1,
    Disallowed = 2
  }

  global['NSWindow']['TabbingMode'] = TabbingMode;

  export enum TitleVisibility {
    Visible = 0,
    Hidden = 1
  }

  global['NSWindow']['TitleVisibility'] = TitleVisibility;

  export enum UserTabbingPreference {
    Manual = 0,
    Always = 1,
    InFullScreen = 2
  }

  global['NSWindow']['UserTabbingPreference'] = UserTabbingPreference;

  export let oldColorSpaceUserInfoKey: string;
  export let oldScaleFactorUserInfoKey: string;
  export let floating: number;
  export let mainMenu: number;
  export let modalPanel: number;
  export let normal: number;
  export let popUpMenu: number;
  export let screenSaver: number;
  export let statusBar: number;
  export let submenu: number;
  export let tornOffMenu: number;
  export let didBecomeKeyNotification: string;
  export let didBecomeMainNotification: string;
  export let didChangeBackingPropertiesNotification: string;
  export let didChangeOcclusionStateNotification: string;
  export let didChangeScreenNotification: string;
  export let didChangeScreenProfileNotification: string;
  export let didDeminiaturizeNotification: string;
  export let didEndLiveResizeNotification: string;
  export let didEndSheetNotification: string;
  export let didEnterFullScreenNotification: string;
  export let didEnterVersionBrowserNotification: string;
  export let didExitFullScreenNotification: string;
  export let didExitVersionBrowserNotification: string;
  export let didExposeNotification: string;
  export let didMiniaturizeNotification: string;
  export let didMoveNotification: string;
  export let didResignKeyNotification: string;
  export let didResignMainNotification: string;
  export let didResizeNotification: string;
  export let didUpdateNotification: string;
  export let willBeginSheetNotification: string;
  export let willCloseNotification: string;
  export let willEnterFullScreenNotification: string;
  export let willEnterVersionBrowserNotification: string;
  export let willExitFullScreenNotification: string;
  export let willExitVersionBrowserNotification: string;
  export let willMiniaturizeNotification: string;
  export let willMoveNotification: string;
  export let willStartLiveResizeNotification: string;
  export type FrameAutosaveName = String;
  export type PersistableFrameDescriptor = String;
  export type TabbingIdentifier = String;
}

namespace NSWorkspace {
  export enum AuthorizationType {
    CreateSymbolicLink = 0,
    SetAttributes = 1,
    ReplaceFile = 2
  }

  global['NSWorkspace']['AuthorizationType'] = AuthorizationType;

  export enum IconCreationOptions {
    ExcludeQuickDrawElementsIconCreationOption = 2,
    Exclude10_4ElementsIconCreationOption = 4
  }

  global['NSWorkspace']['IconCreationOptions'] = IconCreationOptions;

  export enum LaunchOptions {
    AndPrint = 2,
    WithErrorPresentation = 64,
    InhibitingBackgroundOnly = 128,
    WithoutAddingToRecents = 256,
    WithoutActivation = 512,
    Async = 65536,
    NewInstance = 524288,
    AndHide = 1048576,
    AndHideOthers = 2097152,
    Default = 65536,
    AllowingClassicStartup = 131072,
    PreferringClassic = 262144
  }

  global['NSWorkspace']['LaunchOptions'] = LaunchOptions;

  export let accessibilityDisplayOptionsDidChangeNotification: string;
  export let activeSpaceDidChangeNotification: string;
  export let applicationUserInfoKey: string;
  export let allowClipping: string;
  export let fillColor: string;
  export let imageScaling: string;
  export let didActivateApplicationNotification: string;
  export let didChangeFileLabelsNotification: string;
  export let didDeactivateApplicationNotification: string;
  export let didHideApplicationNotification: string;
  export let didLaunchApplicationNotification: string;
  export let didMountNotification: string;
  export let didRenameVolumeNotification: string;
  export let didTerminateApplicationNotification: string;
  export let didUnhideApplicationNotification: string;
  export let didUnmountNotification: string;
  export let didWakeNotification: string;
  export let appleEvent: string;
  export let architecture: string;
  export let arguments_: string;
  export let environment: string;
  export let screensDidSleepNotification: string;
  export let screensDidWakeNotification: string;
  export let sessionDidBecomeActiveNotification: string;
  export let sessionDidResignActiveNotification: string;
  export let localizedVolumeNameUserInfoKey: string;
  export let oldLocalizedVolumeNameUserInfoKey: string;
  export let oldVolumeURLUserInfoKey: string;
  export let volumeURLUserInfoKey: string;
  export let willLaunchApplicationNotification: string;
  export let willPowerOffNotification: string;
  export let willSleepNotification: string;
  export let willUnmountNotification: string;
}

namespace NSXPCConnection {
  export enum Options {
    Privileged = 4096
  }

  global['NSXPCConnection']['Options'] = Options;

}

namespace NetService {
  // struct
  export enum Options {
    noAutoRename,
    listenForConnections,
    center,
    name,
    object
  }

}

namespace NotificationQueue {
  export enum NotificationCoalescing {
    NoCoalescing = 0,
    CoalescingOnName = 1,
    CoalescingOnSender = 2
  }

  global['NotificationQueue']['NotificationCoalescing'] = NotificationCoalescing;

  export enum PostingStyle {
    WhenIdle = 1,
    ASAP = 2,
    Now = 3
  }

  global['NotificationQueue']['PostingStyle'] = PostingStyle;

}

namespace NumberFormatter {
  export enum Behavior {
    BehaviorDefault = 0,
    Behavior10_0 = 1000,
    Behavior10_4 = 1040
  }

  global['NumberFormatter']['Behavior'] = Behavior;

  export enum PadPosition {
    BeforePrefix = 0,
    AfterPrefix = 1,
    BeforeSuffix = 2,
    AfterSuffix = 3
  }

  global['NumberFormatter']['PadPosition'] = PadPosition;

  export enum RoundingMode {
    Ceiling = 0,
    Floor = 1,
    Down = 2,
    Up = 3,
    HalfEven = 4,
    HalfDown = 5,
    HalfUp = 6
  }

  global['NumberFormatter']['RoundingMode'] = RoundingMode;

  export enum Style {
    NoStyle = 0,
    DecimalStyle = 1,
    CurrencyStyle = 2,
    PercentStyle = 3,
    ScientificStyle = 4,
    SpellOutStyle = 5,
    OrdinalStyle = 6,
    CurrencyISOCodeStyle = 8,
    CurrencyPluralStyle = 9,
    CurrencyAccountingStyle = 10
  }

  global['NumberFormatter']['Style'] = Style;

}

namespace Operation {
  export enum QueuePriority {
    VeryLow = -8,
    Low = -4,
    Normal = 0,
    High = 4,
    VeryHigh = 8
  }

  global['Operation']['QueuePriority'] = QueuePriority;

}

namespace OperationQueue {
  export let defaultMaxConcurrentOperationCount: number;
}

namespace PersonNameComponentsFormatter {
  export enum Options {
    Phonetic = 2
  }

  global['PersonNameComponentsFormatter']['Options'] = Options;

  export enum Style {
    Default = 0,
    Short = 1,
    Medium = 2,
    Long = 3,
    Abbreviated = 4
  }

  global['PersonNameComponentsFormatter']['Style'] = Style;

}

namespace Port {
  export let didBecomeInvalidNotification: string;
}

namespace Process {
  export enum TerminationReason {
    Exit = 1,
    UncaughtSignal = 2
  }

  global['Process']['TerminationReason'] = TerminationReason;

  export let didTerminateNotification: string;
}

namespace ProcessInfo {
  export enum ActivityOptions {
    IdleDisplaySleepDisabled = 1099511627776,
    IdleSystemSleepDisabled = 1048576,
    SuddenTerminationDisabled = 16384,
    AutomaticTerminationDisabled = 32768,
    UserInitiated = 16777215,
    UserInitiatedAllowingIdleSystemSleep = 15728639,
    Background = 255,
    LatencyCritical = 1095216660480
  }

  global['ProcessInfo']['ActivityOptions'] = ActivityOptions;

  export enum ThermalState {
    Nominal = 0,
    Fair = 1,
    Serious = 2,
    Critical = 3
  }

  global['ProcessInfo']['ThermalState'] = ThermalState;

  export let thermalStateDidChangeNotification: string;
}

namespace Progress {
  export let copying: string;
  export let decompressingAfterDownloading: string;
  export let downloading: string;
  export let receiving: string;
}

namespace ProgressKind {
  export let file: string;
}

namespace ProgressUserInfoKey {
  export let estimatedTimeRemainingKey: string;
  export let fileAnimationImageKey: string;
  export let fileAnimationImageOriginalRectKey: string;
  export let fileCompletedCountKey: string;
  export let fileIconKey: string;
  export let fileOperationKindKey: string;
  export let fileTotalCountKey: string;
  export let fileURLKey: string;
  export let throughputKey: string;
}

namespace PropertyListSerialization {
  export enum PropertyListFormat {
    OpenStepFormat = 1,
    XMLFormat_v1_0 = 100,
    BinaryFormat_v1_0 = 200
  }

  global['PropertyListSerialization']['PropertyListFormat'] = PropertyListFormat;

  export enum MutabilityOptions {
    Immutable = 0,
    MutableContainers = 1,
    MutableContainersAndLeaves = 2
  }

  global['PropertyListSerialization']['MutabilityOptions'] = MutabilityOptions;

  export type ReadOptions = PropertyListSerialization;
  export type WriteOptions = number;
}

namespace RelativeDateTimeFormatter {
  export enum DateTimeStyle {
    Numeric = 0,
    Named = 1
  }

  global['RelativeDateTimeFormatter']['DateTimeStyle'] = DateTimeStyle;

  export enum UnitsStyle {
    Full = 0,
    SpellOut = 1,
    Short = 2,
    Abbreviated = 3
  }

  global['RelativeDateTimeFormatter']['UnitsStyle'] = UnitsStyle;

}

namespace RunLoop {
  export let eventTracking: string;
  export let modalPanel: string;
  export let default_: string;
  export let common: string;
}

namespace Stream {
  export enum Event {
    None = 0,
    OpenCompleted = 1,
    HasBytesAvailable = 2,
    HasSpaceAvailable = 4,
    ErrorOccurred = 8,
    EndEncountered = 16
  }

  global['Stream']['Event'] = Event;

  export enum Status {
    NotOpen = 0,
    Opening = 1,
    Open = 2,
    Reading = 3,
    Writing = 4,
    AtEnd = 5,
    Closed = 6,
    Error = 7
  }

  global['Stream']['Status'] = Status;

  export let dataWrittenToMemoryStreamKey: string;
  export let fileCurrentOffsetKey: string;
  export let networkServiceType: string;
  export let socksProxyConfigurationKey: string;
  export let socketSecurityLevelKey: string;
}

namespace StreamNetworkServiceTypeValue {
  export let background: string;
  export let callSignaling: string;
  export let video: string;
  export let voIP: string;
  export let voice: string;
}

namespace StreamSOCKSProxyConfiguration {
  export let hostKey: string;
  export let passwordKey: string;
  export let portKey: string;
  export let userKey: string;
  export let versionKey: string;
}

namespace StreamSOCKSProxyVersion {
  export let version4: string;
  export let version5: string;
}

namespace StreamSocketSecurityLevel {
  export let negotiatedSSL: string;
  export let none: string;
  export let ssLv2: string;
  export let ssLv3: string;
  export let tlSv1: string;
}

namespace StringEncodingDetectionOptionsKey {
  export let allowLossyKey: string;
  export let disallowedEncodingsKey: string;
  export let fromWindowsKey: string;
  export let likelyLanguageKey: string;
  export let lossySubstitutionKey: string;
  export let suggestedEncodingsKey: string;
  export let useOnlySuggestedEncodingsKey: string;
}

namespace StringTransform {
  export let fullwidthToHalfwidth: string;
  export let hiraganaToKatakana: string;
  export let latinToArabic: string;
  export let latinToCyrillic: string;
  export let latinToGreek: string;
  export let latinToHangul: string;
  export let latinToHebrew: string;
  export let latinToHiragana: string;
  export let latinToKatakana: string;
  export let latinToThai: string;
  export let mandarinToLatin: string;
  export let stripCombiningMarks: string;
  export let stripDiacritics: string;
  export let toLatin: string;
  export let toUnicodeName: string;
  export let toXMLHex: string;
}

namespace SystemPressureState {
  // struct
  export enum Factors {
    systemTemperature,
    peakPower,
    depthModuleTemperature
  }

}

namespace URLCache {
  export enum StoragePolicy {
    Allowed = 0,
    AllowedInMemoryOnly = 1,
    NotAllowed = 2
  }

  global['URLCache']['StoragePolicy'] = StoragePolicy;

}

namespace URLCredential {
  export enum Persistence {
    None = 0,
    ForSession = 1,
    Permanent = 2,
    Synchronizable = 3
  }

  global['URLCredential']['Persistence'] = Persistence;

}

namespace URLFileProtection {
  export let complete: string;
  export let completeUnlessOpen: string;
  export let completeUntilFirstUserAuthentication: string;
  export let none: string;
}

namespace URLFileResourceType {
  export let blockSpecial: string;
  export let characterSpecial: string;
  export let directory: string;
  export let namedPipe: string;
  export let regular: string;
  export let socket: string;
  export let symbolicLink: string;
  export let unknown: string;
}

namespace URLResourceKey {
  export let addedToDirectoryDateKey: string;
  export let applicationIsScriptableKey: string;
  export let attributeModificationDateKey: string;
  export let canonicalPathKey: string;
  export let contentAccessDateKey: string;
  export let contentModificationDateKey: string;
  export let creationDateKey: string;
  export let customIconKey: string;
  export let documentIdentifierKey: string;
  export let effectiveIconKey: string;
  export let fileAllocatedSizeKey: string;
  export let fileProtectionKey: string;
  export let fileResourceIdentifierKey: string;
  export let fileResourceTypeKey: string;
  export let fileSecurityKey: string;
  export let fileSizeKey: string;
  export let generationIdentifierKey: string;
  export let hasHiddenExtensionKey: string;
  export let isAliasFileKey: string;
  export let isApplicationKey: string;
  export let isDirectoryKey: string;
  export let isExcludedFromBackupKey: string;
  export let isExecutableKey: string;
  export let isHiddenKey: string;
  export let isMountTriggerKey: string;
  export let isPackageKey: string;
  export let isReadableKey: string;
  export let isRegularFileKey: string;
  export let isSymbolicLinkKey: string;
  export let isSystemImmutableKey: string;
  export let isUbiquitousItemKey: string;
  export let isUserImmutableKey: string;
  export let isVolumeKey: string;
  export let isWritableKey: string;
  export let keysOfUnsetValuesKey: string;
  export let labelColorKey: string;
  export let labelNumberKey: string;
  export let linkCountKey: string;
  export let localizedLabelKey: string;
  export let localizedNameKey: string;
  export let localizedTypeDescriptionKey: string;
  export let nameKey: string;
  export let parentDirectoryURLKey: string;
  export let pathKey: string;
  export let preferredIOBlockSizeKey: string;
  export let quarantinePropertiesKey: string;
  export let tagNamesKey: string;
  export let thumbnailDictionaryKey: string;
  export let thumbnailKey: string;
  export let totalFileAllocatedSizeKey: string;
  export let totalFileSizeKey: string;
  export let typeIdentifierKey: string;
  export let ubiquitousItemContainerDisplayNameKey: string;
  export let ubiquitousItemDownloadRequestedKey: string;
  export let ubiquitousItemDownloadingErrorKey: string;
  export let ubiquitousItemDownloadingStatusKey: string;
  export let ubiquitousItemHasUnresolvedConflictsKey: string;
  export let ubiquitousItemIsDownloadingKey: string;
  export let ubiquitousItemIsSharedKey: string;
  export let ubiquitousItemIsUploadedKey: string;
  export let ubiquitousItemIsUploadingKey: string;
  export let ubiquitousItemUploadingErrorKey: string;
  export let ubiquitousSharedItemCurrentUserPermissionsKey: string;
  export let ubiquitousSharedItemCurrentUserRoleKey: string;
  export let ubiquitousSharedItemMostRecentEditorNameComponentsKey: string;
  export let ubiquitousSharedItemOwnerNameComponentsKey: string;
  export let volumeAvailableCapacityForImportantUsageKey: string;
  export let volumeAvailableCapacityForOpportunisticUsageKey: string;
  export let volumeAvailableCapacityKey: string;
  export let volumeCreationDateKey: string;
  export let volumeIdentifierKey: string;
  export let volumeIsAutomountedKey: string;
  export let volumeIsBrowsableKey: string;
  export let volumeIsEjectableKey: string;
  export let volumeIsEncryptedKey: string;
  export let volumeIsInternalKey: string;
  export let volumeIsJournalingKey: string;
  export let volumeIsLocalKey: string;
  export let volumeIsReadOnlyKey: string;
  export let volumeIsRemovableKey: string;
  export let volumeIsRootFileSystemKey: string;
  export let volumeLocalizedFormatDescriptionKey: string;
  export let volumeLocalizedNameKey: string;
  export let volumeMaximumFileSizeKey: string;
  export let volumeNameKey: string;
  export let volumeResourceCountKey: string;
  export let volumeSupportsAccessPermissionsKey: string;
  export let volumeSupportsAdvisoryFileLockingKey: string;
  export let volumeSupportsCasePreservedNamesKey: string;
  export let volumeSupportsCaseSensitiveNamesKey: string;
  export let volumeSupportsCompressionKey: string;
  export let volumeSupportsExclusiveRenamingKey: string;
  export let volumeSupportsExtendedSecurityKey: string;
  export let volumeSupportsFileCloningKey: string;
  export let volumeSupportsHardLinksKey: string;
  export let volumeSupportsImmutableFilesKey: string;
  export let volumeSupportsJournalingKey: string;
  export let volumeSupportsPersistentIDsKey: string;
  export let volumeSupportsRenamingKey: string;
  export let volumeSupportsRootDirectoryDatesKey: string;
  export let volumeSupportsSparseFilesKey: string;
  export let volumeSupportsSwapRenamingKey: string;
  export let volumeSupportsSymbolicLinksKey: string;
  export let volumeSupportsVolumeSizesKey: string;
  export let volumeSupportsZeroRunsKey: string;
  export let volumeTotalCapacityKey: string;
  export let volumeURLForRemountingKey: string;
  export let volumeURLKey: string;
  export let volumeUUIDStringKey: string;
}

namespace URLSession {
  export enum AuthChallengeDisposition {
    UseCredential = 0,
    PerformDefaultHandling = 1,
    CancelAuthenticationChallenge = 2,
    RejectProtectionSpace = 3
  }

  global['URLSession']['AuthChallengeDisposition'] = AuthChallengeDisposition;

  export enum ResponseDisposition {
    Cancel = 0,
    Allow = 1,
    BecomeDownload = 2,
    BecomeStream = 3
  }

  global['URLSession']['ResponseDisposition'] = ResponseDisposition;

}

namespace URLSessionTask {
  export enum State {
    Running = 0,
    Suspended = 1,
    Canceling = 2,
    Completed = 3
  }

  global['URLSessionTask']['State'] = State;

  export let defaultPriority: number;
  export let highPriority: number;
  export let lowPriority: number;
}

namespace URLSessionTaskMetrics {
  export enum ResourceFetchType {
    Unknown = 0,
    NetworkLoad = 1,
    ServerPush = 2,
    LocalCache = 3
  }

  global['URLSessionTaskMetrics']['ResourceFetchType'] = ResourceFetchType;

}

namespace URLSessionWebSocketTask {
  export enum CloseCode {
    Invalid = 0,
    NormalClosure = 1000,
    GoingAway = 1001,
    ProtocolError = 1002,
    UnsupportedData = 1003,
    NoStatusReceived = 1005,
    AbnormalClosure = 1006,
    InvalidFramePayloadData = 1007,
    PolicyViolation = 1008,
    MessageTooBig = 1009,
    MandatoryExtensionMissing = 1010,
    InternalServerError = 1011,
    TLSHandshakeFailure = 1015
  }

  global['URLSessionWebSocketTask']['CloseCode'] = CloseCode;

}

namespace URLThumbnailDictionaryItem {
  export let NSThumbnail1024x1024SizeKey: string;
}

namespace URLUbiquitousItemDownloadingStatus {
  export let current: string;
  export let downloaded: string;
  export let notDownloaded: string;
}

namespace URLUbiquitousSharedItemPermissions {
  export let readOnly: string;
  export let readWrite: string;
}

namespace URLUbiquitousSharedItemRole {
  export let owner: string;
  export let participant: string;
}

namespace UserDefaults {
  export let argumentDomain: string;
  export let globalDomain: string;
  export let registrationDomain: string;
  export let completedInitialCloudSyncNotification: string;
  export let didChangeCloudAccountsNotification: string;
  export let noCloudAccountNotification: string;
  export let didChangeNotification: string;
  export let sizeLimitExceededNotification: string;
}

namespace XMLDTDNode {
  export enum DTDKind {
    EntityGeneralKind = 1,
    EntityParsedKind = 2,
    EntityUnparsedKind = 3,
    EntityParameterKind = 4,
    EntityPredefined = 5,
    AttributeCDATAKind = 6,
    AttributeIDKind = 7,
    AttributeIDRefKind = 8,
    AttributeIDRefsKind = 9,
    AttributeEntityKind = 10,
    AttributeEntitiesKind = 11,
    AttributeNMTokenKind = 12,
    AttributeNMTokensKind = 13,
    AttributeEnumerationKind = 14,
    AttributeNotationKind = 15,
    ElementDeclarationUndefinedKind = 16,
    ElementDeclarationEmptyKind = 17,
    ElementDeclarationAnyKind = 18,
    ElementDeclarationMixedKind = 19,
    ElementDeclarationElementKind = 20
  }

  global['XMLDTDNode']['DTDKind'] = DTDKind;

}

namespace XMLDocument {
  export enum ContentKind {
    XMLKind = 0,
    XHTMLKind = 1,
    HTMLKind = 2,
    TextKind = 3
  }

  global['XMLDocument']['ContentKind'] = ContentKind;

}

namespace XMLNode {
  export enum Kind {
    InvalidKind = 0,
    DocumentKind = 1,
    ElementKind = 2,
    AttributeKind = 3,
    NamespaceKind = 4,
    ProcessingInstructionKind = 5,
    CommentKind = 6,
    TextKind = 7,
    DTDKind = 8,
    EntityDeclarationKind = 9,
    AttributeDeclarationKind = 10,
    ElementDeclarationKind = 11,
    NotationDeclarationKind = 12
  }

  global['XMLNode']['Kind'] = Kind;

  export enum Options {
    NodeOptionsNone = 0,
    NodeIsCDATA = 1,
    NodeExpandEmptyElement = 2,
    NodeCompactEmptyElement = 4,
    NodeUseSingleQuotes = 8,
    NodeUseDoubleQuotes = 16,
    NodeNeverEscapeContents = 32,
    DocumentTidyHTML = 512,
    DocumentTidyXML = 1024,
    DocumentValidate = 8192,
    NodeLoadExternalEntitiesAlways = 16384,
    NodeLoadExternalEntitiesSameOriginOnly = 32768,
    NodeLoadExternalEntitiesNever = 524288,
    DocumentXInclude = 65536,
    NodePrettyPrint = 131072,
    DocumentIncludeContentTypeDeclaration = 262144,
    NodePreserveNamespaceOrder = 1048576,
    NodePreserveAttributeOrder = 2097152,
    NodePreserveEntities = 4194304,
    NodePreservePrefixes = 8388608,
    NodePreserveCDATA = 16777216,
    NodePreserveWhitespace = 33554432,
    NodePreserveDTD = 67108864,
    NodePreserveCharacterReferences = 134217728,
    NodePromoteSignificantWhitespace = 268435456,
    NodePreserveEmptyElements = 6,
    NodePreserveQuotes = 24,
    NodePreserveAll = 4293918750
  }

  global['XMLNode']['Options'] = Options;

}

namespace XMLParser {
  export enum ErrorCode {
    InternalError = 1,
    OutOfMemoryError = 2,
    DocumentStartError = 3,
    EmptyDocumentError = 4,
    PrematureDocumentEndError = 5,
    InvalidHexCharacterRefError = 6,
    InvalidDecimalCharacterRefError = 7,
    InvalidCharacterRefError = 8,
    InvalidCharacterError = 9,
    CharacterRefAtEOFError = 10,
    CharacterRefInPrologError = 11,
    CharacterRefInEpilogError = 12,
    CharacterRefInDTDError = 13,
    EntityRefAtEOFError = 14,
    EntityRefInPrologError = 15,
    EntityRefInEpilogError = 16,
    EntityRefInDTDError = 17,
    ParsedEntityRefAtEOFError = 18,
    ParsedEntityRefInPrologError = 19,
    ParsedEntityRefInEpilogError = 20,
    ParsedEntityRefInInternalSubsetError = 21,
    EntityReferenceWithoutNameError = 22,
    EntityReferenceMissingSemiError = 23,
    ParsedEntityRefNoNameError = 24,
    ParsedEntityRefMissingSemiError = 25,
    UndeclaredEntityError = 26,
    UnparsedEntityError = 28,
    EntityIsExternalError = 29,
    EntityIsParameterError = 30,
    UnknownEncodingError = 31,
    EncodingNotSupportedError = 32,
    StringNotStartedError = 33,
    StringNotClosedError = 34,
    NamespaceDeclarationError = 35,
    EntityNotStartedError = 36,
    EntityNotFinishedError = 37,
    LessThanSymbolInAttributeError = 38,
    AttributeNotStartedError = 39,
    AttributeNotFinishedError = 40,
    AttributeHasNoValueError = 41,
    AttributeRedefinedError = 42,
    LiteralNotStartedError = 43,
    LiteralNotFinishedError = 44,
    CommentNotFinishedError = 45,
    ProcessingInstructionNotStartedError = 46,
    ProcessingInstructionNotFinishedError = 47,
    NotationNotStartedError = 48,
    NotationNotFinishedError = 49,
    AttributeListNotStartedError = 50,
    AttributeListNotFinishedError = 51,
    MixedContentDeclNotStartedError = 52,
    MixedContentDeclNotFinishedError = 53,
    ElementContentDeclNotStartedError = 54,
    ElementContentDeclNotFinishedError = 55,
    XMLDeclNotStartedError = 56,
    XMLDeclNotFinishedError = 57,
    ConditionalSectionNotStartedError = 58,
    ConditionalSectionNotFinishedError = 59,
    ExternalSubsetNotFinishedError = 60,
    DOCTYPEDeclNotFinishedError = 61,
    MisplacedCDATAEndStringError = 62,
    CDATANotFinishedError = 63,
    MisplacedXMLDeclarationError = 64,
    SpaceRequiredError = 65,
    SeparatorRequiredError = 66,
    NMTOKENRequiredError = 67,
    NAMERequiredError = 68,
    PCDATARequiredError = 69,
    URIRequiredError = 70,
    PublicIdentifierRequiredError = 71,
    LTRequiredError = 72,
    GTRequiredError = 73,
    LTSlashRequiredError = 74,
    EqualExpectedError = 75,
    TagNameMismatchError = 76,
    UnfinishedTagError = 77,
    StandaloneValueError = 78,
    InvalidEncodingNameError = 79,
    CommentContainsDoubleHyphenError = 80,
    InvalidEncodingError = 81,
    ExternalStandaloneEntityError = 82,
    InvalidConditionalSectionError = 83,
    EntityValueRequiredError = 84,
    NotWellBalancedError = 85,
    ExtraContentError = 86,
    InvalidCharacterInEntityError = 87,
    ParsedEntityRefInInternalError = 88,
    EntityRefLoopError = 89,
    EntityBoundaryError = 90,
    InvalidURIError = 91,
    URIFragmentError = 92,
    NoDTDError = 94,
    DelegateAbortedParseError = 512
  }

  global['XMLParser']['ErrorCode'] = ErrorCode;

  export enum ExternalEntityResolvingPolicy {
    ResolveExternalEntitiesNever = 0,
    ResolveExternalEntitiesNoNetwork = 1,
    ResolveExternalEntitiesSameOriginOnly = 2,
    ResolveExternalEntitiesAlways = 3
  }

  global['XMLParser']['ExternalEntityResolvingPolicy'] = ExternalEntityResolvingPolicy;

  export let errorDomain: string;
}

export enum AVAssetReferenceRestrictions {
  forbidRemoteReferenceToLocal,
  forbidLocalReferenceToRemote,
  forbidCrossSiteReference,
  forbidLocalReferenceToLocal,
  forbidAll,
  defaultPolicy,
}

global['AVAssetReferenceRestrictions'] = AVAssetReferenceRestrictions;

export enum AVAudioPlayerNodeBufferOptions {
  byteSwapped,
  scalarCount,
  loops,
  interrupts,
  interruptsAtLoop,
}

global['AVAudioPlayerNodeBufferOptions'] = AVAudioPlayerNodeBufferOptions;

export enum AVAudioSpatializationFormats {
  monoAndStereo,
  multichannel,
  monoStereoAndMultichannel,
}

global['AVAudioSpatializationFormats'] = AVAudioSpatializationFormats;

export enum AVMovieWritingOptions {
  errorDomain,
  unknown,
  outOfMemory,
  sessionNotRunning,
  deviceAlreadyUsedByAnotherSession,
  noDataCaptured,
  sessionConfigurationChanged,
  diskFull,
  deviceWasDisconnected,
  mediaChanged,
  maximumDurationReached,
  maximumFileSizeReached,
  mediaDiscontinuity,
  maximumNumberOfSamplesForFileFormatReached,
  deviceNotConnected,
  deviceInUseByAnotherApplication,
  deviceLockedForConfigurationByAnotherProcess,
  exportFailed,
  decodeFailed,
  invalidSourceMedia,
  fileAlreadyExists,
  compositionTrackSegmentsNotContiguous,
  invalidCompositionTrackSegmentDuration,
  invalidCompositionTrackSegmentSourceStartTime,
  invalidCompositionTrackSegmentSourceDuration,
  fileFormatNotRecognized,
  fileFailedToParse,
  maximumStillImageCaptureRequestsExceeded,
  contentIsProtected,
  noImageAtTime,
  decoderNotFound,
  encoderNotFound,
  contentIsNotAuthorized,
  applicationIsNotAuthorized,
  operationNotSupportedForAsset,
  decoderTemporarilyUnavailable,
  encoderTemporarilyUnavailable,
  invalidVideoComposition,
  referenceForbiddenByReferencePolicy,
  invalidOutputURLPathExtension,
  screenCaptureFailed,
  displayWasDisabled,
  torchLevelUnavailable,
  incompatibleAsset,
  failedToLoadMediaData,
  serverIncorrectlyConfigured,
  applicationIsNotAuthorizedToUseDevice,
  failedToParse,
  fileTypeDoesNotSupportSampleReferences,
  undecodableMediaData,
  airPlayControllerRequiresInternet,
  airPlayReceiverRequiresInternet,
  videoCompositorFailed,
  createContentKeyRequestFailed,
  unsupportedOutputSettings,
  operationNotAllowed,
  contentIsUnavailable,
  formatUnsupported,
  malformedDepth,
  contentNotUpdated,
  noLongerPlayable,
  noCompatibleAlternatesForExternalDisplay,
  noSourceTrack,
  externalPlaybackNotSupportedForAsset,
  operationNotSupportedForPreset,
  incorrectlyConfigured,
  segmentStartedWithNonSyncSample,
  rosettaNotInstalled,
  addMovieHeaderToDestination,
  truncateDestinationToMovieHeaderOnly,
}

global['AVMovieWritingOptions'] = AVMovieWritingOptions;

export enum AVMusicSequenceLoadOptions {
  smfChannelsToTracks,
  scalarCount,
}

global['AVMusicSequenceLoadOptions'] = AVMusicSequenceLoadOptions;

export enum AlignmentOptions {
  alignMinXInward,
  alignMinYInward,
  alignMaxXInward,
  alignMaxYInward,
  alignWidthInward,
  alignHeightInward,
  alignMinXOutward,
  alignMinYOutward,
  alignMaxXOutward,
  alignMaxYOutward,
  alignWidthOutward,
  alignHeightOutward,
  alignMinXNearest,
  alignMinYNearest,
  alignMaxXNearest,
  alignMaxYNearest,
  alignWidthNearest,
  alignHeightNearest,
  alignRectFlipped,
  alignAllEdgesInward,
  alignAllEdgesOutward,
  alignAllEdgesNearest,
}

global['AlignmentOptions'] = AlignmentOptions;

export enum AnyObject {
  byteSwapped,
  scalarCount,
  assureMemoryNow,
  alwaysCopyData,
  dontOptimizeDepth,
  permitEmptyReference,
}

global['AnyObject'] = AnyObject;

export enum CAAutoresizingMask {
  layerMinXMargin,
  layerWidthSizable,
  layerMaxXMargin,
  layerMinYMargin,
  layerHeightSizable,
  layerMaxYMargin,
}

global['CAAutoresizingMask'] = CAAutoresizingMask;

export enum CACornerMask {
  layerMinXMinYCorner,
  layerMaxXMinYCorner,
  layerMinXMaxYCorner,
  layerMaxXMaxYCorner,
}

global['CACornerMask'] = CACornerMask;

export enum CAEdgeAntialiasingMask {
  layerLeftEdge,
  layerRightEdge,
  layerBottomEdge,
  layerTopEdge,
}

global['CAEdgeAntialiasingMask'] = CAEdgeAntialiasingMask;

export enum CFCalendarUnit {
  magnitude,
  byteSwapped,
  scalarCount,
  era,
  year,
  month,
  day,
  hour,
  minute,
  second,
  week,
  weekday,
  weekdayOrdinal,
  quarter,
  weekOfMonth,
  weekOfYear,
  yearForWeekOfYear,
}

global['CFCalendarUnit'] = CFCalendarUnit;

export enum CFDataSearchFlags {
  backwards,
  anchored,
}

global['CFDataSearchFlags'] = CFDataSearchFlags;

export enum CFFileSecurityClearOptions {
  magnitude,
  byteSwapped,
  scalarCount,
  owner,
  group,
  mode,
  ownerUUID,
  groupUUID,
  accessControlList,
}

global['CFFileSecurityClearOptions'] = CFFileSecurityClearOptions;

export enum CFGregorianUnitFlags {
  unitsYears,
  unitsMonths,
  unitsDays,
  unitsHours,
  unitsMinutes,
  unitsSeconds,
  allUnits,
}

global['CFGregorianUnitFlags'] = CFGregorianUnitFlags;

export enum CFISO8601DateFormatOptions {
  byteSwapped,
  scalarCount,
  withYear,
  withMonth,
  withWeekOfYear,
  withDay,
  withTime,
  withTimeZone,
  withSpaceBetweenDateAndTime,
  withDashSeparatorInDate,
  withColonSeparatorInTime,
  withColonSeparatorInTimeZone,
  withFractionalSeconds,
  withFullDate,
  withFullTime,
  withInternetDateTime,
}

global['CFISO8601DateFormatOptions'] = CFISO8601DateFormatOptions;

export enum CFNumberFormatterOptionFlags {
  magnitude,
  byteSwapped,
  scalarCount,
  parseIntegersOnly,
}

global['CFNumberFormatterOptionFlags'] = CFNumberFormatterOptionFlags;

export enum CFPropertyListMutabilityOptions {
  byteSwapped,
  scalarCount,
  mutableContainers,
  mutableContainersAndLeaves,
}

global['CFPropertyListMutabilityOptions'] = CFPropertyListMutabilityOptions;

export enum CFRunLoopActivity {
  entry,
  beforeTimers,
  beforeSources,
  beforeWaiting,
  afterWaiting,
  exit,
  allActivities,
}

global['CFRunLoopActivity'] = CFRunLoopActivity;

export enum CFSocketCallBackType {
  readCallBack,
  acceptCallBack,
  dataCallBack,
  connectCallBack,
  writeCallBack,
}

global['CFSocketCallBackType'] = CFSocketCallBackType;

export enum CFStreamEventType {
  magnitude,
  byteSwapped,
  scalarCount,
  openCompleted,
  hasBytesAvailable,
  canAcceptBytes,
  errorOccurred,
  endEncountered,
}

global['CFStreamEventType'] = CFStreamEventType;

export enum CFStringCompareFlags {
  compareCaseInsensitive,
  compareBackwards,
  compareAnchored,
  compareNonliteral,
  compareLocalized,
  compareNumerically,
  compareDiacriticInsensitive,
  compareWidthInsensitive,
  compareForcedOrdering,
}

global['CFStringCompareFlags'] = CFStringCompareFlags;

export enum CFStringTokenizerTokenType {
  byteSwapped,
  scalarCount,
  normal,
  hasSubTokensMask,
  hasDerivedSubTokensMask,
  hasHasNumbersMask,
  hasNonLettersMask,
  isCJWordMask,
}

global['CFStringTokenizerTokenType'] = CFStringTokenizerTokenType;

export enum CFURLBookmarkCreationOptions {
  byteSwapped,
  scalarCount,
  minimalBookmarkMask,
  suitableForBookmarkFile,
  withSecurityScope,
  securityScopeAllowOnlyReadAccess,
}

global['CFURLBookmarkCreationOptions'] = CFURLBookmarkCreationOptions;

export enum CFURLBookmarkResolutionOptions {
  byteSwapped,
  scalarCount,
  cfurlBookmarkResolutionWithoutUIMask,
  cfurlBookmarkResolutionWithoutMountingMask,
  cfurlBookmarkResolutionWithSecurityScope,
  cfBookmarkResolutionWithoutUIMask,
  cfBookmarkResolutionWithoutMountingMask,
}

global['CFURLBookmarkResolutionOptions'] = CFURLBookmarkResolutionOptions;

export enum CFURLEnumeratorOptions {
  descendRecursively,
  skipInvisibles,
  generateFileReferenceURLs,
  skipPackageContents,
  includeDirectoriesPreOrder,
  includeDirectoriesPostOrder,
  generateRelativePathURLs,
}

global['CFURLEnumeratorOptions'] = CFURLEnumeratorOptions;

export enum CFXMLParserOptions {
  validateDocument,
  skipMetaData,
  replacePhysicalEntities,
  skipWhitespace,
  resolveExternalEntities,
  addImpliedAttributes,
  allOptions,
}

global['CFXMLParserOptions'] = CFXMLParserOptions;

export enum CFXMLParserStatusCode {
  statusParseNotBegun,
  statusParseInProgress,
  errorUnexpectedEOF,
  errorUnknownEncoding,
  errorEncodingConversionFailure,
  errorMalformedProcessingInstruction,
  errorMalformedDTD,
  errorMalformedName,
  errorMalformedCDSect,
  errorMalformedCloseTag,
  errorMalformedStartTag,
  errorMalformedDocument,
  errorElementlessDocument,
  errorMalformedComment,
  errorMalformedCharacterReference,
  errorMalformedParsedCharacterData,
  errorNoData,
}

global['CFXMLParserStatusCode'] = CFXMLParserStatusCode;

export enum CGBitmapInfo {
  alphaInfoMask,
  floatInfoMask,
  floatComponents,
  byteOrderMask,
  byteOrder16Little,
  byteOrder32Little,
  byteOrder16Big,
  byteOrder32Big,
}

global['CGBitmapInfo'] = CGBitmapInfo;

export enum CGCaptureOptions {
  byteSwapped,
  scalarCount,
  noFill,
}

global['CGCaptureOptions'] = CGCaptureOptions;

export enum CGConfigureOption {
  byteSwapped,
  scalarCount,
  forAppOnly,
  forSession,
  permanently,
}

global['CGConfigureOption'] = CGConfigureOption;

export enum CGDisplayChangeSummaryFlags {
  byteSwapped,
  scalarCount,
  beginConfigurationFlag,
  movedFlag,
  setMainFlag,
  setModeFlag,
  addFlag,
  removeFlag,
  enabledFlag,
  disabledFlag,
  mirrorFlag,
  unMirrorFlag,
  desktopShapeChangedFlag,
}

global['CGDisplayChangeSummaryFlags'] = CGDisplayChangeSummaryFlags;

export enum CGEventFilterMask {
  byteSwapped,
  scalarCount,
  permitLocalMouseEvents,
  permitLocalKeyboardEvents,
  permitSystemDefinedEvents,
}

global['CGEventFilterMask'] = CGEventFilterMask;

export enum CGEventFlags {
  maskAlphaShift,
  maskShift,
  maskControl,
  maskAlternate,
  maskCommand,
  maskHelp,
  maskSecondaryFn,
  maskNumericPad,
  maskNonCoalesced,
}

global['CGEventFlags'] = CGEventFlags;

export enum CGGradientDrawingOptions {
  byteSwapped,
  scalarCount,
  drawsBeforeStartLocation,
  drawsAfterEndLocation,
}

global['CGGradientDrawingOptions'] = CGGradientDrawingOptions;

export enum CGPDFAccessPermissions {
  byteSwapped,
  scalarCount,
  allowsLowQualityPrinting,
  allowsHighQualityPrinting,
  allowsDocumentChanges,
  allowsDocumentAssembly,
  allowsContentCopying,
  allowsContentAccessibility,
  allowsCommenting,
  allowsFormFieldEntry,
}

global['CGPDFAccessPermissions'] = CGPDFAccessPermissions;

export enum CGScreenUpdateOperation {
  byteSwapped,
  scalarCount,
  refresh,
  move,
  reducedDirtyRectangleCount,
}

global['CGScreenUpdateOperation'] = CGScreenUpdateOperation;

export enum CGWindowImageOption {
  byteSwapped,
  scalarCount,
  boundsIgnoreFraming,
  shouldBeOpaque,
  onlyShadows,
  bestResolution,
  nominalResolution,
}

global['CGWindowImageOption'] = CGWindowImageOption;

export enum CGWindowListOption {
  magnitude,
  byteSwapped,
  scalarCount,
  optionAll,
  optionOnScreenOnly,
  optionOnScreenAboveWindow,
  optionOnScreenBelowWindow,
  optionIncludingWindow,
  excludeDesktopElements,
}

global['CGWindowListOption'] = CGWindowListOption;

export enum CKContainer_Application_Permissions {
  userDiscoverability,
}

global['CKContainer_Application_Permissions'] = CKContainer_Application_Permissions;

export enum CMSampleBuffer {
  audioBufferListAssure16ByteAlignment,
}

global['CMSampleBuffer'] = CMSampleBuffer;

export enum CMTimeFlags {
  magnitude,
  byteSwapped,
  scalarCount,
  valid,
  hasBeenRounded,
  positiveInfinity,
  negativeInfinity,
  indefinite,
  impliedValueFlagsMask,
}

global['CMTimeFlags'] = CMTimeFlags;

export enum Character {
  request,
  session,
  ascii,
  nextstep,
  japaneseEUC,
  utf8,
  isoLatin1,
  symbol,
  nonLossyASCII,
  shiftJIS,
  isoLatin2,
  unicode,
  windowsCP1251,
  windowsCP1252,
  windowsCP1253,
  windowsCP1254,
  windowsCP1250,
  iso2022JP,
  macOSRoman,
  utf16,
  utf16BigEndian,
  utf16LittleEndian,
  utf32,
  utf32BigEndian,
  utf32LittleEndian,
}

global['Character'] = Character;

export enum Data {
  video,
  audio,
  muxed,
  text,
  closedCaption,
  subtitle,
  timeCode,
  metadata,
  linearPCM,
  ac3,
  iec60958AC3,
  appleIMA4,
  mpeg4AAC,
  mpeg4CELP,
  mpeg4HVXC,
  mpeg4TwinVQ,
  mace3,
  mace6,
  uLaw,
  aLaw,
  qDesign,
  qDesign2,
  qualcomm,
  mpegLayer1,
  mpegLayer2,
  mpegLayer3,
  midiStream,
  parameterValueStream,
  appleLossless,
  mpeg4AAC_HE,
  mpeg4AAC_LD,
  mpeg4AAC_ELD,
  mpeg4AAC_ELD_SBR,
  mpeg4AAC_ELD_V2,
  mpeg4AAC_HE_V2,
  mpeg4AAC_Spatial,
  mpegD_USAC,
  amr,
  amr_WB,
  audible,
  iLBC,
  dviIntelIMA,
  microsoftGSM,
  aes3,
  enhancedAC3,
  flac,
  opus,
  aacLCProtected,
  aacAudibleProtected,
  pixelFormat_32ARGB,
  pixelFormat_32BGRA,
  pixelFormat_24RGB,
  pixelFormat_16BE555,
  pixelFormat_16BE565,
  pixelFormat_16LE555,
  pixelFormat_16LE565,
  pixelFormat_16LE5551,
  pixelFormat_422YpCbCr8,
  pixelFormat_422YpCbCr8_yuvs,
  pixelFormat_444YpCbCr8,
  pixelFormat_4444YpCbCrA8,
  pixelFormat_422YpCbCr16,
  pixelFormat_422YpCbCr10,
  pixelFormat_444YpCbCr10,
  pixelFormat_8IndexedGray_WhiteIsZero,
  animation,
  cinepak,
  jpeg,
  jpeg_OpenDML,
  sorensonVideo,
  sorensonVideo3,
  h263,
  h264,
  hevc,
  hevcWithAlpha,
  mpeg4Video,
  mpeg2Video,
  mpeg1Video,
  dvcNTSC,
  dvcPAL,
  dvcProPAL,
  dvcPro50NTSC,
  dvcPro50PAL,
  dvcPROHD720p60,
  dvcPROHD720p50,
  dvcPROHD1080i60,
  dvcPROHD1080i50,
  dvcPROHD1080p30,
  dvcPROHD1080p25,
  proRes4444XQ,
  proRes4444,
  proRes422HQ,
  proRes422,
  proRes422LT,
  proRes422Proxy,
  proResRAW,
  proResRAWHQ,
  mpeg1System,
  mpeg2Transport,
  mpeg2Program,
  dv,
  cea608,
  cea708,
  atsc,
  qt,
  mobile3GPP,
  webVTT,
  timeCode32,
  timeCode64,
  counter32,
  counter64,
  icy,
  id3,
  boxed,
  emsg,
  streamBasicDescription,
  magicCookie,
  channelLayout,
  extensions,
  all,
  startIndex,
  endIndex,
}

global['Data'] = Data;

export enum Int {
  byteSwapped,
  scalarCount,
}

global['Int'] = Int;

export enum NSBinarySearchingOptions {
  firstEqual,
  lastEqual,
  insertionIndex,
}

global['NSBinarySearchingOptions'] = NSBinarySearchingOptions;

export enum NSDirectionalRectEdge {
  top,
  leading,
  bottom,
  trailing,
  all,
}

global['NSDirectionalRectEdge'] = NSDirectionalRectEdge;

export enum NSDragOperation {
  copy,
  link,
  generic,
  private,
  move,
  delete,
  every,
  all_Obsolete,
  all,
}

global['NSDragOperation'] = NSDragOperation;

export enum NSDraggingItemEnumerationOptions {
  concurrent,
  clearNonenumeratedImages,
}

global['NSDraggingItemEnumerationOptions'] = NSDraggingItemEnumerationOptions;

export enum NSEnumerationOptions {
  concurrent,
  reverse,
}

global['NSEnumerationOptions'] = NSEnumerationOptions;

export enum NSFetchRequestResultType {
  managedObjectResultType,
  managedObjectIDResultType,
  dictionaryResultType,
  countResultType,
}

global['NSFetchRequestResultType'] = NSFetchRequestResultType;

export enum NSFontCollectionOptions {
  applicationOnlyMask,
}

global['NSFontCollectionOptions'] = NSFontCollectionOptions;

export enum NSFontTraitMask {
  byteSwapped,
  scalarCount,
  italicFontMask,
  boldFontMask,
  unboldFontMask,
  nonStandardCharacterSetFontMask,
  narrowFontMask,
  expandedFontMask,
  condensedFontMask,
  smallCapsFontMask,
  posterFontMask,
  compressedFontMask,
  fixedPitchFontMask,
  unitalicFontMask,
}

global['NSFontTraitMask'] = NSFontTraitMask;

export enum NSItemProviderFileOptions {
  openInPlace,
}

global['NSItemProviderFileOptions'] = NSItemProviderFileOptions;

export enum NSKeyValueObservingOptions {
  new,
  old,
  initial,
  prior,
}

global['NSKeyValueObservingOptions'] = NSKeyValueObservingOptions;

export enum NSOrderedCollectionDifferenceCalculationOptions {
  magnitude,
  timeInterval,
  hashValue,
  omitInsertedObjects,
  omitRemovedObjects,
  inferMoves,
}

global['NSOrderedCollectionDifferenceCalculationOptions'] = NSOrderedCollectionDifferenceCalculationOptions;

export enum NSPersistentCloudKitContainerSchemaInitializationOptions {
  dryRun,
  printSchema,
}

global['NSPersistentCloudKitContainerSchemaInitializationOptions'] = NSPersistentCloudKitContainerSchemaInitializationOptions;

export enum NSSnapshotEventType {
  undoInsertion,
  undoDeletion,
  undoUpdate,
  rollback,
  refresh,
  mergePolicy,
}

global['NSSnapshotEventType'] = NSSnapshotEventType;

export enum NSSortOptions {
  magnitude,
  byteSwapped,
  scalarCount,
  concurrent,
  stable,
}

global['NSSortOptions'] = NSSortOptions;

export enum NSSpringLoadingOptions {
  disabled,
  enabled,
  continuousActivation,
  noHover,
}

global['NSSpringLoadingOptions'] = NSSpringLoadingOptions;

export enum NSTextStorageEditActions {
  editedAttributes,
  editedCharacters,
}

global['NSTextStorageEditActions'] = NSTextStorageEditActions;

export enum NSTypesetterControlCharacterAction {
  magnitude,
  byteSwapped,
  scalarCount,
  zeroAdvancementAction,
  whitespaceAction,
  horizontalTabAction,
  lineBreakAction,
  paragraphBreakAction,
  containerBreakAction,
}

global['NSTypesetterControlCharacterAction'] = NSTypesetterControlCharacterAction;

export enum NSUnderlineStyle {
  single,
  thick,
  double,
  patternDot,
  patternDash,
  patternDashDot,
  patternDashDotDot,
  byWord,
}

global['NSUnderlineStyle'] = NSUnderlineStyle;

export enum UInt {
  magnitude,
  byteSwapped,
  scalarCount,
  hashValue,
  boolValue,
  ptr,
  bitWidth,
  leadingZeroBitCount,
  trailingZeroBitCount,
  nonzeroBitCount,
  count,
  startIndex,
  endIndex,
  indices,
  words,
}

global['UInt'] = UInt;

export enum UInt8 {
  regions,
  startIndex,
  endIndex,
  indices,
  hashValue,
  autoupdatingCurrent,
  current,
}

global['UInt8'] = UInt8;

export enum AVAssetReferenceRestrictions {
  ForbidNone = 0,
  ForbidRemoteReferenceToLocal = 1,
  ForbidLocalReferenceToRemote = 2,
  ForbidCrossSiteReference = 4,
  ForbidLocalReferenceToLocal = 8,
  ForbidAll = 65535,
  DefaultPolicy = 2
}

global['AVAssetReferenceRestrictions'] = AVAssetReferenceRestrictions;

export enum AVAudio3DMixingPointSourceInHeadMode {
  Mono = 0,
  Bypass = 1
}

global['AVAudio3DMixingPointSourceInHeadMode'] = AVAudio3DMixingPointSourceInHeadMode;

export enum AVAudio3DMixingRenderingAlgorithm {
  EqualPowerPanning = 0,
  SphericalHead = 1,
  HRTF = 2,
  SoundField = 3,
  StereoPassThrough = 5,
  HRTFHQ = 6,
  Auto = 7
}

global['AVAudio3DMixingRenderingAlgorithm'] = AVAudio3DMixingRenderingAlgorithm;

export enum AVAudio3DMixingSourceMode {
  SpatializeIfMono = 0,
  Bypass = 1,
  PointSource = 2,
  AmbienceBed = 3
}

global['AVAudio3DMixingSourceMode'] = AVAudio3DMixingSourceMode;

export enum AVAudioCommonFormat {
  OtherFormat = 0,
  PCMFormatFloat32 = 1,
  PCMFormatFloat64 = 2,
  PCMFormatInt16 = 3,
  PCMFormatInt32 = 4
}

global['AVAudioCommonFormat'] = AVAudioCommonFormat;

export enum AVAudioConverterInputStatus {
  HaveData = 0,
  NoDataNow = 1,
  EndOfStream = 2
}

global['AVAudioConverterInputStatus'] = AVAudioConverterInputStatus;

export enum AVAudioConverterOutputStatus {
  HaveData = 0,
  InputRanDry = 1,
  EndOfStream = 2,
  Error = 3
}

global['AVAudioConverterOutputStatus'] = AVAudioConverterOutputStatus;

export enum AVAudioConverterPrimeMethod {
  Pre = 0,
  Normal = 1,
  None = 2
}

global['AVAudioConverterPrimeMethod'] = AVAudioConverterPrimeMethod;

export enum AVAudioEngineManualRenderingError {
  InvalidMode = -80800,
  Initialized = -80801,
  NotRunning = -80802
}

global['AVAudioEngineManualRenderingError'] = AVAudioEngineManualRenderingError;

export enum AVAudioEngineManualRenderingMode {
  Offline = 0,
  Realtime = 1
}

global['AVAudioEngineManualRenderingMode'] = AVAudioEngineManualRenderingMode;

export enum AVAudioEngineManualRenderingStatus {
  Error = -1,
  Success = 0,
  InsufficientDataFromInputNode = 1,
  CannotDoInCurrentContext = 2
}

global['AVAudioEngineManualRenderingStatus'] = AVAudioEngineManualRenderingStatus;

export enum AVAudioEnvironmentDistanceAttenuationModel {
  Exponential = 1,
  Inverse = 2,
  Linear = 3
}

global['AVAudioEnvironmentDistanceAttenuationModel'] = AVAudioEnvironmentDistanceAttenuationModel;

export enum AVAudioEnvironmentOutputType {
  Auto = 0,
  Headphones = 1,
  BuiltInSpeakers = 2,
  ExternalSpeakers = 3
}

global['AVAudioEnvironmentOutputType'] = AVAudioEnvironmentOutputType;

export enum AVAudioPlayerNodeBufferOptions {
  Loops = 1,
  Interrupts = 2,
  InterruptsAtLoop = 4
}

global['AVAudioPlayerNodeBufferOptions'] = AVAudioPlayerNodeBufferOptions;

export enum AVAudioPlayerNodeCompletionCallbackType {
  DataConsumed = 0,
  DataRendered = 1,
  DataPlayedBack = 2
}

global['AVAudioPlayerNodeCompletionCallbackType'] = AVAudioPlayerNodeCompletionCallbackType;

export enum AVAudioQuality {
  Min = 0,
  Low = 32,
  Medium = 64,
  High = 96,
  Max = 127
}

global['AVAudioQuality'] = AVAudioQuality;

export enum AVAudioSessionActivationOptions {
  None = 0
}

global['AVAudioSessionActivationOptions'] = AVAudioSessionActivationOptions;

export enum AVAudioUnitDistortionPreset {
  DrumsBitBrush = 0,
  DrumsBufferBeats = 1,
  DrumsLoFi = 2,
  MultiBrokenSpeaker = 3,
  MultiCellphoneConcert = 4,
  MultiDecimated1 = 5,
  MultiDecimated2 = 6,
  MultiDecimated3 = 7,
  MultiDecimated4 = 8,
  MultiDistortedFunk = 9,
  MultiDistortedCubed = 10,
  MultiDistortedSquared = 11,
  MultiEcho1 = 12,
  MultiEcho2 = 13,
  MultiEchoTight1 = 14,
  MultiEchoTight2 = 15,
  MultiEverythingIsBroken = 16,
  SpeechAlienChatter = 17,
  SpeechCosmicInterference = 18,
  SpeechGoldenPi = 19,
  SpeechRadioTower = 20,
  SpeechWaves = 21
}

global['AVAudioUnitDistortionPreset'] = AVAudioUnitDistortionPreset;

export enum AVAudioUnitEQFilterType {
  Parametric = 0,
  LowPass = 1,
  HighPass = 2,
  ResonantLowPass = 3,
  ResonantHighPass = 4,
  BandPass = 5,
  BandStop = 6,
  LowShelf = 7,
  HighShelf = 8,
  ResonantLowShelf = 9,
  ResonantHighShelf = 10
}

global['AVAudioUnitEQFilterType'] = AVAudioUnitEQFilterType;

export enum AVAudioUnitReverbPreset {
  SmallRoom = 0,
  MediumRoom = 1,
  LargeRoom = 2,
  MediumHall = 3,
  LargeHall = 4,
  Plate = 5,
  MediumChamber = 6,
  LargeChamber = 7,
  Cathedral = 8,
  LargeRoom2 = 9,
  MediumHall2 = 10,
  MediumHall3 = 11,
  LargeHall2 = 12
}

global['AVAudioUnitReverbPreset'] = AVAudioUnitReverbPreset;

export enum AVAuthorizationStatus {
  NotDetermined = 0,
  Restricted = 1,
  Denied = 2,
  Authorized = 3
}

global['AVAuthorizationStatus'] = AVAuthorizationStatus;

export enum AVCaptureColorSpace {
  sRGB = 0,
  P3_D65 = 1
}

global['AVCaptureColorSpace'] = AVCaptureColorSpace;

export enum AVCaptureVideoOrientation {
  Portrait = 1,
  PortraitUpsideDown = 2,
  LandscapeRight = 3,
  LandscapeLeft = 4
}

global['AVCaptureVideoOrientation'] = AVCaptureVideoOrientation;

export enum AVContentAuthorizationStatus {
  Unknown = 0,
  Completed = 1,
  Cancelled = 2,
  TimedOut = 3,
  Busy = 4,
  NotAvailable = 5,
  NotPossible = 6
}

global['AVContentAuthorizationStatus'] = AVContentAuthorizationStatus;

export enum AVError {
  Unknown = -11800,
  OutOfMemory = -11801,
  SessionNotRunning = -11803,
  DeviceAlreadyUsedByAnotherSession = -11804,
  NoDataCaptured = -11805,
  SessionConfigurationChanged = -11806,
  DiskFull = -11807,
  DeviceWasDisconnected = -11808,
  MediaChanged = -11809,
  MaximumDurationReached = -11810,
  MaximumFileSizeReached = -11811,
  MediaDiscontinuity = -11812,
  MaximumNumberOfSamplesForFileFormatReached = -11813,
  DeviceNotConnected = -11814,
  DeviceInUseByAnotherApplication = -11815,
  DeviceLockedForConfigurationByAnotherProcess = -11817,
  ExportFailed = -11820,
  DecodeFailed = -11821,
  InvalidSourceMedia = -11822,
  FileAlreadyExists = -11823,
  CompositionTrackSegmentsNotContiguous = -11824,
  InvalidCompositionTrackSegmentDuration = -11825,
  InvalidCompositionTrackSegmentSourceStartTime = -11826,
  InvalidCompositionTrackSegmentSourceDuration = -11827,
  FileFormatNotRecognized = -11828,
  FileFailedToParse = -11829,
  MaximumStillImageCaptureRequestsExceeded = -11830,
  ContentIsProtected = -11831,
  NoImageAtTime = -11832,
  DecoderNotFound = -11833,
  EncoderNotFound = -11834,
  ContentIsNotAuthorized = -11835,
  ApplicationIsNotAuthorized = -11836,
  OperationNotSupportedForAsset = -11838,
  DecoderTemporarilyUnavailable = -11839,
  EncoderTemporarilyUnavailable = -11840,
  InvalidVideoComposition = -11841,
  ReferenceForbiddenByReferencePolicy = -11842,
  InvalidOutputURLPathExtension = -11843,
  ScreenCaptureFailed = -11844,
  DisplayWasDisabled = -11845,
  TorchLevelUnavailable = -11846,
  IncompatibleAsset = -11848,
  FailedToLoadMediaData = -11849,
  ServerIncorrectlyConfigured = -11850,
  ApplicationIsNotAuthorizedToUseDevice = -11852,
  FailedToParse = -11853,
  FileTypeDoesNotSupportSampleReferences = -11854,
  UndecodableMediaData = -11855,
  AirPlayControllerRequiresInternet = -11856,
  AirPlayReceiverRequiresInternet = -11857,
  VideoCompositorFailed = -11858,
  CreateContentKeyRequestFailed = -11860,
  UnsupportedOutputSettings = -11861,
  OperationNotAllowed = -11862,
  ContentIsUnavailable = -11863,
  FormatUnsupported = -11864,
  MalformedDepth = -11865,
  ContentNotUpdated = -11866,
  NoLongerPlayable = -11867,
  NoCompatibleAlternatesForExternalDisplay = -11868,
  NoSourceTrack = -11869,
  ExternalPlaybackNotSupportedForAsset = -11870,
  OperationNotSupportedForPreset = -11871,
  SessionHardwareCostOverage = -11872,
  UnsupportedDeviceActiveFormat = -11873
}

global['AVError'] = AVError;

export enum AVKeyValueStatus {
  Unknown = 0,
  Loading = 1,
  Loaded = 2,
  Failed = 3,
  Cancelled = 4
}

global['AVKeyValueStatus'] = AVKeyValueStatus;

export enum AVMovieWritingOptions {
  AddMovieHeaderToDestination = 0,
  TruncateDestinationToMovieHeaderOnly = 1
}

global['AVMovieWritingOptions'] = AVMovieWritingOptions;

export enum AVMusicSequenceLoadOptions {
  SMF_PreserveTracks = 0,
  SMF_ChannelsToTracks = 1
}

global['AVMusicSequenceLoadOptions'] = AVMusicSequenceLoadOptions;

export enum AVMusicTrackLoopCount {
  Forever = -1
}

global['AVMusicTrackLoopCount'] = AVMusicTrackLoopCount;

export enum AVQueuedSampleBufferRenderingStatus {
  Unknown = 0,
  Rendering = 1,
  Failed = 2
}

global['AVQueuedSampleBufferRenderingStatus'] = AVQueuedSampleBufferRenderingStatus;

export enum AVSpeechBoundary {
  Immediate = 0,
  Word = 1
}

global['AVSpeechBoundary'] = AVSpeechBoundary;

export enum AVSpeechSynthesisVoiceGender {
  Unspecified = 0,
  Male = 1,
  Female = 2
}

global['AVSpeechSynthesisVoiceGender'] = AVSpeechSynthesisVoiceGender;

export enum AVSpeechSynthesisVoiceQuality {
  Default = 1,
  Enhanced = 2
}

global['AVSpeechSynthesisVoiceQuality'] = AVSpeechSynthesisVoiceQuality;

export enum AVVideoFieldMode {
  Both = 0,
  TopOnly = 1,
  BottomOnly = 2,
  Deinterlace = 3
}

global['AVVideoFieldMode'] = AVVideoFieldMode;

export enum AVCaptureViewControlsStyle {
  Inline = 0,
  Floating = 1,
  InlineDeviceSelection = 2,
  Default = 0
}

global['AVCaptureViewControlsStyle'] = AVCaptureViewControlsStyle;

export enum AVPlayerViewControlsStyle {
  None = 0,
  Inline = 1,
  Floating = 2,
  Minimal = 3,
  Default = 1
}

global['AVPlayerViewControlsStyle'] = AVPlayerViewControlsStyle;

export enum AVPlayerViewTrimResult {
  OKButton = 0,
  CancelButton = 1
}

global['AVPlayerViewTrimResult'] = AVPlayerViewTrimResult;

export enum AVRoutePickerViewButtonState {
  Normal = 0,
  NormalHighlighted = 1,
  Active = 2,
  ActiveHighlighted = 3
}

global['AVRoutePickerViewButtonState'] = AVRoutePickerViewButtonState;

export enum NSAccessibilityPriorityLevel {
  Low = 10,
  Medium = 50,
  High = 90
}

global['NSAccessibilityPriorityLevel'] = NSAccessibilityPriorityLevel;

export enum NSAnimationEffect {
  DisappearingItemDefault = 0,
  Poof = 10
}

global['NSAnimationEffect'] = NSAnimationEffect;

export enum NSBorderType {
  NoBorder = 0,
  LineBorder = 1,
  BezelBorder = 2,
  GrooveBorder = 3
}

global['NSBorderType'] = NSBorderType;

export enum NSCharacterCollection {
  IdentityMappingCharacterCollection = 0,
  AdobeCNS1CharacterCollection = 1,
  AdobeGB1CharacterCollection = 2,
  AdobeJapan1CharacterCollection = 3,
  AdobeJapan2CharacterCollection = 4,
  AdobeKorea1CharacterCollection = 5
}

global['NSCharacterCollection'] = NSCharacterCollection;

export enum NSCollectionElementCategory {
  Item = 0,
  SupplementaryView = 1,
  DecorationView = 2,
  InterItemGap = 3
}

global['NSCollectionElementCategory'] = NSCollectionElementCategory;

export enum NSCollectionLayoutSectionOrthogonalScrollingBehavior {
  None = 0,
  Continuous = 1,
  ContinuousGroupLeadingBoundary = 2,
  Paging = 3,
  GroupPaging = 4,
  GroupPagingCentered = 5
}

global['NSCollectionLayoutSectionOrthogonalScrollingBehavior'] = NSCollectionLayoutSectionOrthogonalScrollingBehavior;

export enum NSColorRenderingIntent {
  Default = 0,
  AbsoluteColorimetric = 1,
  RelativeColorimetric = 2,
  Perceptual = 3,
  Saturation = 4
}

global['NSColorRenderingIntent'] = NSColorRenderingIntent;

export enum NSCompositingOperation {
  Clear = 0,
  Copy = 1,
  SourceOver = 2,
  SourceIn = 3,
  SourceOut = 4,
  SourceAtop = 5,
  DestinationOver = 6,
  DestinationIn = 7,
  DestinationOut = 8,
  DestinationAtop = 9,
  XOR = 10,
  PlusDarker = 11,
  Highlight = 12,
  PlusLighter = 13,
  Multiply = 14,
  Screen = 15,
  Overlay = 16,
  Darken = 17,
  Lighten = 18,
  ColorDodge = 19,
  ColorBurn = 20,
  SoftLight = 21,
  HardLight = 22,
  Difference = 23,
  Exclusion = 24,
  Hue = 25,
  Saturation = 26,
  Color = 27,
  Luminosity = 28
}

global['NSCompositingOperation'] = NSCompositingOperation;

export enum NSControlTint {
  DefaultControlTint = 0,
  BlueControlTint = 1,
  GraphiteControlTint = 6,
  ClearControlTint = 7
}

global['NSControlTint'] = NSControlTint;

export enum NSDirectionalRectEdge {
  None = 0,
  Top = 1,
  Leading = 2,
  Bottom = 4,
  Trailing = 8,
  All = 15
}

global['NSDirectionalRectEdge'] = NSDirectionalRectEdge;

export enum NSDisplayGamut {
  SRGB = 1,
  P3 = 2
}

global['NSDisplayGamut'] = NSDisplayGamut;

export enum NSDragOperation {
  None = 0,
  Copy = 1,
  Link = 2,
  Generic = 4,
  Private = 8,
  Move = 16,
  Delete = 32,
  Every = -1,
  All_Obsolete = 15,
  All = 15
}

global['NSDragOperation'] = NSDragOperation;

export enum NSDraggingContext {
  OutsideApplication = 0,
  WithinApplication = 1
}

global['NSDraggingContext'] = NSDraggingContext;

export enum NSDraggingFormation {
  Default = 0,
  None = 1,
  Pile = 2,
  List = 3,
  Stack = 4
}

global['NSDraggingFormation'] = NSDraggingFormation;

export enum NSDraggingItemEnumerationOptions {
  Concurrent = 1,
  ClearNonenumeratedImages = 65536
}

global['NSDraggingItemEnumerationOptions'] = NSDraggingItemEnumerationOptions;

export enum NSFindPanelAction {
  ShowFindPanel = 1,
  Next = 2,
  Previous = 3,
  ReplaceAll = 4,
  Replace = 5,
  ReplaceAndFind = 6,
  SetFindString = 7,
  ReplaceAllInSelection = 8,
  SelectAll = 9,
  SelectAllInSelection = 10
}

global['NSFindPanelAction'] = NSFindPanelAction;

export enum NSFindPanelSubstringMatchType {
  Contains = 0,
  StartsWith = 1,
  FullWord = 2,
  EndsWith = 3
}

global['NSFindPanelSubstringMatchType'] = NSFindPanelSubstringMatchType;

export enum NSFocusRingPlacement {
  Only = 0,
  Below = 1,
  Above = 2
}

global['NSFocusRingPlacement'] = NSFocusRingPlacement;

export enum NSFocusRingType {
  Default = 0,
  None = 1,
  Exterior = 2
}

global['NSFocusRingType'] = NSFocusRingType;

export enum NSFontAction {
  NoFontChangeAction = 0,
  ViaPanelFontAction = 1,
  AddTraitFontAction = 2,
  SizeUpFontAction = 3,
  SizeDownFontAction = 4,
  HeavierFontAction = 5,
  LighterFontAction = 6,
  RemoveTraitFontAction = 7
}

global['NSFontAction'] = NSFontAction;

export enum NSFontCollectionOptions {
  ApplicationOnlyMask = 1
}

global['NSFontCollectionOptions'] = NSFontCollectionOptions;

export enum NSFontRenderingMode {
  DefaultRenderingMode = 0,
  AntialiasedRenderingMode = 1,
  IntegerAdvancementsRenderingMode = 2,
  AntialiasedIntegerAdvancementsRenderingMode = 3
}

global['NSFontRenderingMode'] = NSFontRenderingMode;

export enum NSFontTraitMask {
  ItalicFontMask = 1,
  BoldFontMask = 2,
  UnboldFontMask = 4,
  NonStandardCharacterSetFontMask = 8,
  NarrowFontMask = 16,
  ExpandedFontMask = 32,
  CondensedFontMask = 64,
  SmallCapsFontMask = 128,
  PosterFontMask = 256,
  CompressedFontMask = 512,
  FixedPitchFontMask = 1024,
  UnitalicFontMask = 16777216
}

global['NSFontTraitMask'] = NSFontTraitMask;

export enum NSImageAlignment {
  Center = 0,
  Top = 1,
  TopLeft = 2,
  TopRight = 3,
  Left = 4,
  Bottom = 5,
  BottomLeft = 6,
  BottomRight = 7,
  Right = 8
}

global['NSImageAlignment'] = NSImageAlignment;

export enum NSImageInterpolation {
  Default = 0,
  None = 1,
  Low = 2,
  Medium = 4,
  High = 3
}

global['NSImageInterpolation'] = NSImageInterpolation;

export enum NSImageScaling {
  ImageScaleProportionallyDown = 0,
  ImageScaleAxesIndependently = 1,
  ImageScaleNone = 2,
  ImageScaleProportionallyUpOrDown = 3,
  ScaleProportionally = 0,
  ScaleToFit = 1,
  ScaleNone = 2
}

global['NSImageScaling'] = NSImageScaling;

export enum NSLineBreakMode {
  ByWordWrapping = 0,
  ByCharWrapping = 1,
  ByClipping = 2,
  ByTruncatingHead = 3,
  ByTruncatingTail = 4,
  ByTruncatingMiddle = 5
}

global['NSLineBreakMode'] = NSLineBreakMode;

export enum NSLineMovementDirection {
  DoesntMove = 0,
  MovesLeft = 1,
  MovesRight = 2,
  MovesDown = 3,
  MovesUp = 4
}

global['NSLineMovementDirection'] = NSLineMovementDirection;

export enum NSLineSweepDirection {
  Left = 0,
  Right = 1,
  Down = 2,
  Up = 3
}

global['NSLineSweepDirection'] = NSLineSweepDirection;

export enum NSRectAlignment {
  None = 0,
  Top = 1,
  TopLeading = 2,
  Leading = 3,
  BottomLeading = 4,
  Bottom = 5,
  BottomTrailing = 6,
  Trailing = 7,
  TopTrailing = 8
}

global['NSRectAlignment'] = NSRectAlignment;

export enum NSSelectionAffinity {
  Upstream = 0,
  Downstream = 1
}

global['NSSelectionAffinity'] = NSSelectionAffinity;

export enum NSSelectionGranularity {
  ByCharacter = 0,
  ByWord = 1,
  ByParagraph = 2
}

global['NSSelectionGranularity'] = NSSelectionGranularity;

export enum NSSpringLoadingHighlight {
  None = 0,
  Standard = 1,
  Emphasized = 2
}

global['NSSpringLoadingHighlight'] = NSSpringLoadingHighlight;

export enum NSSpringLoadingOptions {
  Disabled = 0,
  Enabled = 1,
  ContinuousActivation = 2,
  NoHover = 8
}

global['NSSpringLoadingOptions'] = NSSpringLoadingOptions;

export enum NSTextAlignment {
  Left = 0,
  Right = 1,
  Center = 2,
  Justified = 3,
  Natural = 4
}

global['NSTextAlignment'] = NSTextAlignment;

export enum NSTextInputTraitType {
  Default = 0,
  No = 1,
  Yes = 2
}

global['NSTextInputTraitType'] = NSTextInputTraitType;

export enum NSTextMovement {
  Return = 16,
  Tab = 17,
  Backtab = 18,
  Left = 19,
  Right = 20,
  Up = 21,
  Down = 22,
  Cancel = 23,
  Other = 0
}

global['NSTextMovement'] = NSTextMovement;

export enum NSTextScalingType {
  Standard = 0,
  iOS = 1
}

global['NSTextScalingType'] = NSTextScalingType;

export enum NSTextStorageEditActions {
  EditedAttributes = 1,
  EditedCharacters = 2
}

global['NSTextStorageEditActions'] = NSTextStorageEditActions;

export enum NSTypesetterControlCharacterAction {
  ZeroAdvancementAction = 1,
  WhitespaceAction = 2,
  HorizontalTabAction = 4,
  LineBreakAction = 8,
  ParagraphBreakAction = 16,
  ContainerBreakAction = 32
}

global['NSTypesetterControlCharacterAction'] = NSTypesetterControlCharacterAction;

export enum NSUnderlineStyle {
  None = 0,
  Single = 1,
  Thick = 2,
  Double = 9,
  PatternSolid = 0,
  PatternDot = 256,
  PatternDash = 512,
  PatternDashDot = 768,
  PatternDashDotDot = 1024,
  ByWord = 32768
}

global['NSUnderlineStyle'] = NSUnderlineStyle;

export enum NSUserInterfaceLayoutDirection {
  LeftToRight = 0,
  RightToLeft = 1
}

global['NSUserInterfaceLayoutDirection'] = NSUserInterfaceLayoutDirection;

export enum NSUserInterfaceLayoutOrientation {
  Horizontal = 0,
  Vertical = 1
}

global['NSUserInterfaceLayoutOrientation'] = NSUserInterfaceLayoutOrientation;

export enum NSWritingDirection {
  Natural = -1,
  LeftToRight = 0,
  RightToLeft = 1
}

global['NSWritingDirection'] = NSWritingDirection;

export enum NSWritingDirectionFormatType {
  Embedding = 0,
  Override = 2
}

global['NSWritingDirectionFormatType'] = NSWritingDirectionFormatType;

export enum NSAttributeType {
  UndefinedAttributeType = 0,
  Integer16AttributeType = 100,
  Integer32AttributeType = 200,
  Integer64AttributeType = 300,
  DecimalAttributeType = 400,
  DoubleAttributeType = 500,
  FloatAttributeType = 600,
  StringAttributeType = 700,
  BooleanAttributeType = 800,
  DateAttributeType = 900,
  BinaryDataAttributeType = 1000,
  UUIDAttributeType = 1100,
  URIAttributeType = 1200,
  TransformableAttributeType = 1800,
  ObjectIDAttributeType = 2000
}

global['NSAttributeType'] = NSAttributeType;

export enum NSBatchDeleteRequestResultType {
  ResultTypeStatusOnly = 0,
  ResultTypeObjectIDs = 1,
  ResultTypeCount = 2
}

global['NSBatchDeleteRequestResultType'] = NSBatchDeleteRequestResultType;

export enum NSBatchInsertRequestResultType {
  StatusOnly = 0,
  ObjectIDs = 1,
  Count = 2
}

global['NSBatchInsertRequestResultType'] = NSBatchInsertRequestResultType;

export enum NSBatchUpdateRequestResultType {
  StatusOnlyResultType = 0,
  UpdatedObjectIDsResultType = 1,
  UpdatedObjectsCountResultType = 2
}

global['NSBatchUpdateRequestResultType'] = NSBatchUpdateRequestResultType;

export enum NSDeleteRule {
  NoActionDeleteRule = 0,
  NullifyDeleteRule = 1,
  CascadeDeleteRule = 2,
  DenyDeleteRule = 3
}

global['NSDeleteRule'] = NSDeleteRule;

export enum NSEntityMappingType {
  UndefinedEntityMappingType = 0,
  CustomEntityMappingType = 1,
  AddEntityMappingType = 2,
  RemoveEntityMappingType = 3,
  CopyEntityMappingType = 4,
  TransformEntityMappingType = 5
}

global['NSEntityMappingType'] = NSEntityMappingType;

export enum NSFetchIndexElementType {
  Binary = 0,
  RTree = 1
}

global['NSFetchIndexElementType'] = NSFetchIndexElementType;

export enum NSFetchRequestResultType {
  ManagedObjectResultType = 0,
  ManagedObjectIDResultType = 1,
  DictionaryResultType = 2,
  CountResultType = 4
}

global['NSFetchRequestResultType'] = NSFetchRequestResultType;

export enum NSFetchedResultsChangeType {
  Insert = 1,
  Delete = 2,
  Move = 3,
  Update = 4
}

global['NSFetchedResultsChangeType'] = NSFetchedResultsChangeType;

export enum NSManagedObjectContextConcurrencyType {
  ConfinementConcurrencyType = 0,
  PrivateQueueConcurrencyType = 1,
  MainQueueConcurrencyType = 2
}

global['NSManagedObjectContextConcurrencyType'] = NSManagedObjectContextConcurrencyType;

export enum NSMergePolicyType {
  ErrorMergePolicyType = 0,
  MergeByPropertyStoreTrumpMergePolicyType = 1,
  MergeByPropertyObjectTrumpMergePolicyType = 2,
  OverwriteMergePolicyType = 3,
  RollbackMergePolicyType = 4
}

global['NSMergePolicyType'] = NSMergePolicyType;

export enum NSPersistentCloudKitContainerSchemaInitializationOptions {
  None = 0,
  DryRun = 2,
  PrintSchema = 4
}

global['NSPersistentCloudKitContainerSchemaInitializationOptions'] = NSPersistentCloudKitContainerSchemaInitializationOptions;

export enum NSPersistentHistoryChangeType {
  Insert = 0,
  Update = 1,
  Delete = 2
}

global['NSPersistentHistoryChangeType'] = NSPersistentHistoryChangeType;

export enum NSPersistentHistoryResultType {
  StatusOnly = 0,
  ObjectIDs = 1,
  Count = 2,
  TransactionsOnly = 3,
  ChangesOnly = 4,
  TransactionsAndChanges = 5
}

global['NSPersistentHistoryResultType'] = NSPersistentHistoryResultType;

export enum NSPersistentStoreRequestType {
  FetchRequestType = 1,
  SaveRequestType = 2,
  BatchInsertRequestType = 5,
  BatchUpdateRequestType = 6,
  BatchDeleteRequestType = 7
}

global['NSPersistentStoreRequestType'] = NSPersistentStoreRequestType;

export enum NSSnapshotEventType {
  UndoInsertion = 2,
  UndoDeletion = 4,
  UndoUpdate = 8,
  Rollback = 16,
  Refresh = 32,
  MergePolicy = 64
}

global['NSSnapshotEventType'] = NSSnapshotEventType;

export enum CFCalendarUnit {
  kCFCalendarUnitEra = 2,
  kCFCalendarUnitYear = 4,
  kCFCalendarUnitMonth = 8,
  kCFCalendarUnitDay = 16,
  kCFCalendarUnitHour = 32,
  kCFCalendarUnitMinute = 64,
  kCFCalendarUnitSecond = 128,
  kCFCalendarUnitWeek = 256,
  kCFCalendarUnitWeekday = 512,
  kCFCalendarUnitWeekdayOrdinal = 1024,
  kCFCalendarUnitQuarter = 2048,
  kCFCalendarUnitWeekOfMonth = 4096,
  kCFCalendarUnitWeekOfYear = 8192,
  kCFCalendarUnitYearForWeekOfYear = 16384
}

global['CFCalendarUnit'] = CFCalendarUnit;

export enum CFCharacterSetPredefinedSet {
  kCFCharacterSetControl = 1,
  kCFCharacterSetWhitespace = 2,
  kCFCharacterSetWhitespaceAndNewline = 3,
  kCFCharacterSetDecimalDigit = 4,
  kCFCharacterSetLetter = 5,
  kCFCharacterSetLowercaseLetter = 6,
  kCFCharacterSetUppercaseLetter = 7,
  kCFCharacterSetNonBase = 8,
  kCFCharacterSetDecomposable = 9,
  kCFCharacterSetAlphaNumeric = 10,
  kCFCharacterSetPunctuation = 11,
  kCFCharacterSetCapitalizedLetter = 13,
  kCFCharacterSetSymbol = 14,
  kCFCharacterSetNewline = 15,
  kCFCharacterSetIllegal = 12
}

global['CFCharacterSetPredefinedSet'] = CFCharacterSetPredefinedSet;

export enum CFComparisonResult {
  kCFCompareLessThan = -1,
  kCFCompareEqualTo = 0,
  kCFCompareGreaterThan = 1
}

global['CFComparisonResult'] = CFComparisonResult;

export enum CFDataSearchFlags {
  kCFDataSearchBackwards = 1,
  kCFDataSearchAnchored = 2
}

global['CFDataSearchFlags'] = CFDataSearchFlags;

export enum CFDateFormatterStyle {
  kCFDateFormatterNoStyle = 0,
  kCFDateFormatterShortStyle = 1,
  kCFDateFormatterMediumStyle = 2,
  kCFDateFormatterLongStyle = 3,
  kCFDateFormatterFullStyle = 4
}

global['CFDateFormatterStyle'] = CFDateFormatterStyle;

export enum CFFileSecurityClearOptions {
  kCFFileSecurityClearOwner = 1,
  kCFFileSecurityClearGroup = 2,
  kCFFileSecurityClearMode = 4,
  kCFFileSecurityClearOwnerUUID = 8,
  kCFFileSecurityClearGroupUUID = 16,
  kCFFileSecurityClearAccessControlList = 32
}

global['CFFileSecurityClearOptions'] = CFFileSecurityClearOptions;

export enum CFGregorianUnitFlags {
  kCFGregorianUnitsYears = 1,
  kCFGregorianUnitsMonths = 2,
  kCFGregorianUnitsDays = 4,
  kCFGregorianUnitsHours = 8,
  kCFGregorianUnitsMinutes = 16,
  kCFGregorianUnitsSeconds = 32,
  kCFGregorianAllUnits = 16777215
}

global['CFGregorianUnitFlags'] = CFGregorianUnitFlags;

export enum CFISO8601DateFormatOptions {
  kCFISO8601DateFormatWithYear = 1,
  kCFISO8601DateFormatWithMonth = 2,
  kCFISO8601DateFormatWithWeekOfYear = 4,
  kCFISO8601DateFormatWithDay = 16,
  kCFISO8601DateFormatWithTime = 32,
  kCFISO8601DateFormatWithTimeZone = 64,
  kCFISO8601DateFormatWithSpaceBetweenDateAndTime = 128,
  kCFISO8601DateFormatWithDashSeparatorInDate = 256,
  kCFISO8601DateFormatWithColonSeparatorInTime = 512,
  kCFISO8601DateFormatWithColonSeparatorInTimeZone = 1024,
  kCFISO8601DateFormatWithFractionalSeconds = 2048,
  kCFISO8601DateFormatWithFullDate = 275,
  kCFISO8601DateFormatWithFullTime = 1632,
  kCFISO8601DateFormatWithInternetDateTime = 1907
}

global['CFISO8601DateFormatOptions'] = CFISO8601DateFormatOptions;

export enum CFLocaleLanguageDirection {
  kCFLocaleLanguageDirectionUnknown = 0,
  kCFLocaleLanguageDirectionLeftToRight = 1,
  kCFLocaleLanguageDirectionRightToLeft = 2,
  kCFLocaleLanguageDirectionTopToBottom = 3,
  kCFLocaleLanguageDirectionBottomToTop = 4
}

global['CFLocaleLanguageDirection'] = CFLocaleLanguageDirection;

export enum CFNotificationSuspensionBehavior {
  Drop = 1,
  Coalesce = 2,
  Hold = 3,
  DeliverImmediately = 4
}

global['CFNotificationSuspensionBehavior'] = CFNotificationSuspensionBehavior;

export enum CFNumberFormatterOptionFlags {
  kCFNumberFormatterParseIntegersOnly = 1
}

global['CFNumberFormatterOptionFlags'] = CFNumberFormatterOptionFlags;

export enum CFNumberFormatterPadPosition {
  kCFNumberFormatterPadBeforePrefix = 0,
  kCFNumberFormatterPadAfterPrefix = 1,
  kCFNumberFormatterPadBeforeSuffix = 2,
  kCFNumberFormatterPadAfterSuffix = 3
}

global['CFNumberFormatterPadPosition'] = CFNumberFormatterPadPosition;

export enum CFNumberFormatterRoundingMode {
  kCFNumberFormatterRoundCeiling = 0,
  kCFNumberFormatterRoundFloor = 1,
  kCFNumberFormatterRoundDown = 2,
  kCFNumberFormatterRoundUp = 3,
  kCFNumberFormatterRoundHalfEven = 4,
  kCFNumberFormatterRoundHalfDown = 5,
  kCFNumberFormatterRoundHalfUp = 6
}

global['CFNumberFormatterRoundingMode'] = CFNumberFormatterRoundingMode;

export enum CFNumberFormatterStyle {
  kCFNumberFormatterNoStyle = 0,
  kCFNumberFormatterDecimalStyle = 1,
  kCFNumberFormatterCurrencyStyle = 2,
  kCFNumberFormatterPercentStyle = 3,
  kCFNumberFormatterScientificStyle = 4,
  kCFNumberFormatterSpellOutStyle = 5,
  kCFNumberFormatterOrdinalStyle = 6,
  kCFNumberFormatterCurrencyISOCodeStyle = 8,
  kCFNumberFormatterCurrencyPluralStyle = 9,
  kCFNumberFormatterCurrencyAccountingStyle = 10
}

global['CFNumberFormatterStyle'] = CFNumberFormatterStyle;

export enum CFNumberType {
  kCFNumberSInt8Type = 1,
  kCFNumberSInt16Type = 2,
  kCFNumberSInt32Type = 3,
  kCFNumberSInt64Type = 4,
  kCFNumberFloat32Type = 5,
  kCFNumberFloat64Type = 6,
  kCFNumberCharType = 7,
  kCFNumberShortType = 8,
  kCFNumberIntType = 9,
  kCFNumberLongType = 10,
  kCFNumberLongLongType = 11,
  kCFNumberFloatType = 12,
  kCFNumberDoubleType = 13,
  kCFNumberCFIndexType = 14,
  kCFNumberNSIntegerType = 15,
  kCFNumberCGFloatType = 16,
  kCFNumberMaxType = 16
}

global['CFNumberType'] = CFNumberType;

export enum CFPropertyListFormat {
  kCFPropertyListOpenStepFormat = 1,
  kCFPropertyListXMLFormat_v1_0 = 100,
  kCFPropertyListBinaryFormat_v1_0 = 200
}

global['CFPropertyListFormat'] = CFPropertyListFormat;

export enum CFPropertyListMutabilityOptions {
  kCFPropertyListImmutable = 0,
  kCFPropertyListMutableContainers = 1,
  kCFPropertyListMutableContainersAndLeaves = 2
}

global['CFPropertyListMutabilityOptions'] = CFPropertyListMutabilityOptions;

export enum CFRunLoopActivity {
  kCFRunLoopEntry = 1,
  kCFRunLoopBeforeTimers = 2,
  kCFRunLoopBeforeSources = 4,
  kCFRunLoopBeforeWaiting = 32,
  kCFRunLoopAfterWaiting = 64,
  kCFRunLoopExit = 128,
  kCFRunLoopAllActivities = 268435455
}

global['CFRunLoopActivity'] = CFRunLoopActivity;

export enum CFRunLoopRunResult {
  kCFRunLoopRunFinished = 1,
  kCFRunLoopRunStopped = 2,
  kCFRunLoopRunTimedOut = 3,
  kCFRunLoopRunHandledSource = 4
}

global['CFRunLoopRunResult'] = CFRunLoopRunResult;

export enum CFSocketCallBackType {
  kCFSocketNoCallBack = 0,
  kCFSocketReadCallBack = 1,
  kCFSocketAcceptCallBack = 2,
  kCFSocketDataCallBack = 3,
  kCFSocketConnectCallBack = 4,
  kCFSocketWriteCallBack = 8
}

global['CFSocketCallBackType'] = CFSocketCallBackType;

export enum CFSocketError {
  kCFSocketSuccess = 0,
  kCFSocketError = -1,
  kCFSocketTimeout = -2
}

global['CFSocketError'] = CFSocketError;

export enum CFStreamErrorDomain {
  kCFStreamErrorDomainCustom = -1,
  kCFStreamErrorDomainPOSIX = 1,
  kCFStreamErrorDomainMacOSStatus = 2
}

global['CFStreamErrorDomain'] = CFStreamErrorDomain;

export enum CFStreamEventType {
  kCFStreamEventNone = 0,
  kCFStreamEventOpenCompleted = 1,
  kCFStreamEventHasBytesAvailable = 2,
  kCFStreamEventCanAcceptBytes = 4,
  kCFStreamEventErrorOccurred = 8,
  kCFStreamEventEndEncountered = 16
}

global['CFStreamEventType'] = CFStreamEventType;

export enum CFStreamStatus {
  kCFStreamStatusNotOpen = 0,
  kCFStreamStatusOpening = 1,
  kCFStreamStatusOpen = 2,
  kCFStreamStatusReading = 3,
  kCFStreamStatusWriting = 4,
  kCFStreamStatusAtEnd = 5,
  kCFStreamStatusClosed = 6,
  kCFStreamStatusError = 7
}

global['CFStreamStatus'] = CFStreamStatus;

export enum CFStringBuiltInEncodings {
  kCFStringEncodingMacRoman = 0,
  kCFStringEncodingWindowsLatin1 = 1280,
  kCFStringEncodingISOLatin1 = 513,
  kCFStringEncodingNextStepLatin = 2817,
  kCFStringEncodingASCII = 1536,
  kCFStringEncodingUnicode = 256,
  kCFStringEncodingUTF8 = 134217984,
  kCFStringEncodingNonLossyASCII = 3071,
  kCFStringEncodingUTF16 = 256,
  kCFStringEncodingUTF16BE = 268435712,
  kCFStringEncodingUTF16LE = 335544576,
  kCFStringEncodingUTF32 = 201326848,
  kCFStringEncodingUTF32BE = 402653440,
  kCFStringEncodingUTF32LE = 469762304
}

global['CFStringBuiltInEncodings'] = CFStringBuiltInEncodings;

export enum CFStringCompareFlags {
  kCFCompareCaseInsensitive = 1,
  kCFCompareBackwards = 4,
  kCFCompareAnchored = 8,
  kCFCompareNonliteral = 16,
  kCFCompareLocalized = 32,
  kCFCompareNumerically = 64,
  kCFCompareDiacriticInsensitive = 128,
  kCFCompareWidthInsensitive = 256,
  kCFCompareForcedOrdering = 512
}

global['CFStringCompareFlags'] = CFStringCompareFlags;

export enum CFStringEncodings {
  kCFStringEncodingMacJapanese = 1,
  kCFStringEncodingMacChineseTrad = 2,
  kCFStringEncodingMacKorean = 3,
  kCFStringEncodingMacArabic = 4,
  kCFStringEncodingMacHebrew = 5,
  kCFStringEncodingMacGreek = 6,
  kCFStringEncodingMacCyrillic = 7,
  kCFStringEncodingMacDevanagari = 9,
  kCFStringEncodingMacGurmukhi = 10,
  kCFStringEncodingMacGujarati = 11,
  kCFStringEncodingMacOriya = 12,
  kCFStringEncodingMacBengali = 13,
  kCFStringEncodingMacTamil = 14,
  kCFStringEncodingMacTelugu = 15,
  kCFStringEncodingMacKannada = 16,
  kCFStringEncodingMacMalayalam = 17,
  kCFStringEncodingMacSinhalese = 18,
  kCFStringEncodingMacBurmese = 19,
  kCFStringEncodingMacKhmer = 20,
  kCFStringEncodingMacThai = 21,
  kCFStringEncodingMacLaotian = 22,
  kCFStringEncodingMacGeorgian = 23,
  kCFStringEncodingMacArmenian = 24,
  kCFStringEncodingMacChineseSimp = 25,
  kCFStringEncodingMacTibetan = 26,
  kCFStringEncodingMacMongolian = 27,
  kCFStringEncodingMacEthiopic = 28,
  kCFStringEncodingMacCentralEurRoman = 29,
  kCFStringEncodingMacVietnamese = 30,
  kCFStringEncodingMacExtArabic = 31,
  kCFStringEncodingMacSymbol = 33,
  kCFStringEncodingMacDingbats = 34,
  kCFStringEncodingMacTurkish = 35,
  kCFStringEncodingMacCroatian = 36,
  kCFStringEncodingMacIcelandic = 37,
  kCFStringEncodingMacRomanian = 38,
  kCFStringEncodingMacCeltic = 39,
  kCFStringEncodingMacGaelic = 40,
  kCFStringEncodingMacFarsi = 140,
  kCFStringEncodingMacUkrainian = 152,
  kCFStringEncodingMacInuit = 236,
  kCFStringEncodingMacVT100 = 252,
  kCFStringEncodingMacHFS = 255,
  kCFStringEncodingISOLatin2 = 514,
  kCFStringEncodingISOLatin3 = 515,
  kCFStringEncodingISOLatin4 = 516,
  kCFStringEncodingISOLatinCyrillic = 517,
  kCFStringEncodingISOLatinArabic = 518,
  kCFStringEncodingISOLatinGreek = 519,
  kCFStringEncodingISOLatinHebrew = 520,
  kCFStringEncodingISOLatin5 = 521,
  kCFStringEncodingISOLatin6 = 522,
  kCFStringEncodingISOLatinThai = 523,
  kCFStringEncodingISOLatin7 = 525,
  kCFStringEncodingISOLatin8 = 526,
  kCFStringEncodingISOLatin9 = 527,
  kCFStringEncodingISOLatin10 = 528,
  kCFStringEncodingDOSLatinUS = 1024,
  kCFStringEncodingDOSGreek = 1029,
  kCFStringEncodingDOSBalticRim = 1030,
  kCFStringEncodingDOSLatin1 = 1040,
  kCFStringEncodingDOSGreek1 = 1041,
  kCFStringEncodingDOSLatin2 = 1042,
  kCFStringEncodingDOSCyrillic = 1043,
  kCFStringEncodingDOSTurkish = 1044,
  kCFStringEncodingDOSPortuguese = 1045,
  kCFStringEncodingDOSIcelandic = 1046,
  kCFStringEncodingDOSHebrew = 1047,
  kCFStringEncodingDOSCanadianFrench = 1048,
  kCFStringEncodingDOSArabic = 1049,
  kCFStringEncodingDOSNordic = 1050,
  kCFStringEncodingDOSRussian = 1051,
  kCFStringEncodingDOSGreek2 = 1052,
  kCFStringEncodingDOSThai = 1053,
  kCFStringEncodingDOSJapanese = 1056,
  kCFStringEncodingDOSChineseSimplif = 1057,
  kCFStringEncodingDOSKorean = 1058,
  kCFStringEncodingDOSChineseTrad = 1059,
  kCFStringEncodingWindowsLatin2 = 1281,
  kCFStringEncodingWindowsCyrillic = 1282,
  kCFStringEncodingWindowsGreek = 1283,
  kCFStringEncodingWindowsLatin5 = 1284,
  kCFStringEncodingWindowsHebrew = 1285,
  kCFStringEncodingWindowsArabic = 1286,
  kCFStringEncodingWindowsBalticRim = 1287,
  kCFStringEncodingWindowsVietnamese = 1288,
  kCFStringEncodingWindowsKoreanJohab = 1296,
  kCFStringEncodingANSEL = 1537,
  kCFStringEncodingJIS_X0201_76 = 1568,
  kCFStringEncodingJIS_X0208_83 = 1569,
  kCFStringEncodingJIS_X0208_90 = 1570,
  kCFStringEncodingJIS_X0212_90 = 1571,
  kCFStringEncodingJIS_C6226_78 = 1572,
  kCFStringEncodingShiftJIS_X0213 = 1576,
  kCFStringEncodingShiftJIS_X0213_MenKuTen = 1577,
  kCFStringEncodingGB_2312_80 = 1584,
  kCFStringEncodingGBK_95 = 1585,
  kCFStringEncodingGB_18030_2000 = 1586,
  kCFStringEncodingKSC_5601_87 = 1600,
  kCFStringEncodingKSC_5601_92_Johab = 1601,
  kCFStringEncodingCNS_11643_92_P1 = 1617,
  kCFStringEncodingCNS_11643_92_P2 = 1618,
  kCFStringEncodingCNS_11643_92_P3 = 1619,
  kCFStringEncodingISO_2022_JP = 2080,
  kCFStringEncodingISO_2022_JP_2 = 2081,
  kCFStringEncodingISO_2022_JP_1 = 2082,
  kCFStringEncodingISO_2022_JP_3 = 2083,
  kCFStringEncodingISO_2022_CN = 2096,
  kCFStringEncodingISO_2022_CN_EXT = 2097,
  kCFStringEncodingISO_2022_KR = 2112,
  kCFStringEncodingEUC_JP = 2336,
  kCFStringEncodingEUC_CN = 2352,
  kCFStringEncodingEUC_TW = 2353,
  kCFStringEncodingEUC_KR = 2368,
  kCFStringEncodingShiftJIS = 2561,
  kCFStringEncodingKOI8_R = 2562,
  kCFStringEncodingBig5 = 2563,
  kCFStringEncodingMacRomanLatin1 = 2564,
  kCFStringEncodingHZ_GB_2312 = 2565,
  kCFStringEncodingBig5_HKSCS_1999 = 2566,
  kCFStringEncodingVISCII = 2567,
  kCFStringEncodingKOI8_U = 2568,
  kCFStringEncodingBig5_E = 2569,
  kCFStringEncodingNextStepJapanese = 2818,
  kCFStringEncodingEBCDIC_US = 3073,
  kCFStringEncodingEBCDIC_CP037 = 3074,
  kCFStringEncodingUTF7 = 67109120,
  kCFStringEncodingUTF7_IMAP = 2576,
  kCFStringEncodingShiftJIS_X0213_00 = 1576
}

global['CFStringEncodings'] = CFStringEncodings;

export enum CFStringNormalizationForm {
  kCFStringNormalizationFormD = 0,
  kCFStringNormalizationFormKD = 1,
  kCFStringNormalizationFormC = 2,
  kCFStringNormalizationFormKC = 3
}

global['CFStringNormalizationForm'] = CFStringNormalizationForm;

export enum CFStringTokenizerTokenType {
  kCFStringTokenizerTokenNone = 0,
  kCFStringTokenizerTokenNormal = 1,
  kCFStringTokenizerTokenHasSubTokensMask = 2,
  kCFStringTokenizerTokenHasDerivedSubTokensMask = 4,
  kCFStringTokenizerTokenHasHasNumbersMask = 8,
  kCFStringTokenizerTokenHasNonLettersMask = 16,
  kCFStringTokenizerTokenIsCJWordMask = 32
}

global['CFStringTokenizerTokenType'] = CFStringTokenizerTokenType;

export enum CFTimeZoneNameStyle {
  kCFTimeZoneNameStyleStandard = 0,
  kCFTimeZoneNameStyleShortStandard = 1,
  kCFTimeZoneNameStyleDaylightSaving = 2,
  kCFTimeZoneNameStyleShortDaylightSaving = 3,
  kCFTimeZoneNameStyleGeneric = 4,
  kCFTimeZoneNameStyleShortGeneric = 5
}

global['CFTimeZoneNameStyle'] = CFTimeZoneNameStyle;

export enum CFURLBookmarkCreationOptions {
  kCFURLBookmarkCreationMinimalBookmarkMask = 512,
  kCFURLBookmarkCreationSuitableForBookmarkFile = 1024,
  kCFURLBookmarkCreationWithSecurityScope = 2048,
  kCFURLBookmarkCreationSecurityScopeAllowOnlyReadAccess = 4096,
  kCFURLBookmarkCreationPreferFileIDResolutionMask = 256
}

global['CFURLBookmarkCreationOptions'] = CFURLBookmarkCreationOptions;

export enum CFURLBookmarkResolutionOptions {
  kCFURLBookmarkResolutionWithoutUIMask = 256,
  kCFURLBookmarkResolutionWithoutMountingMask = 512,
  kCFURLBookmarkResolutionWithSecurityScope = 1024,
  kCFBookmarkResolutionWithoutUIMask = 256,
  kCFBookmarkResolutionWithoutMountingMask = 512
}

global['CFURLBookmarkResolutionOptions'] = CFURLBookmarkResolutionOptions;

export enum CFURLComponentType {
  kCFURLComponentScheme = 1,
  kCFURLComponentNetLocation = 2,
  kCFURLComponentPath = 3,
  kCFURLComponentResourceSpecifier = 4,
  kCFURLComponentUser = 5,
  kCFURLComponentPassword = 6,
  kCFURLComponentUserInfo = 7,
  kCFURLComponentHost = 8,
  kCFURLComponentPort = 9,
  kCFURLComponentParameterString = 10,
  kCFURLComponentQuery = 11,
  kCFURLComponentFragment = 12
}

global['CFURLComponentType'] = CFURLComponentType;

export enum CFURLEnumeratorOptions {
  kCFURLEnumeratorDefaultBehavior = 0,
  kCFURLEnumeratorDescendRecursively = 1,
  kCFURLEnumeratorSkipInvisibles = 2,
  kCFURLEnumeratorGenerateFileReferenceURLs = 4,
  kCFURLEnumeratorSkipPackageContents = 8,
  kCFURLEnumeratorIncludeDirectoriesPreOrder = 16,
  kCFURLEnumeratorIncludeDirectoriesPostOrder = 32,
  kCFURLEnumeratorGenerateRelativePathURLs = 64
}

global['CFURLEnumeratorOptions'] = CFURLEnumeratorOptions;

export enum CFURLEnumeratorResult {
  kCFURLEnumeratorSuccess = 1,
  kCFURLEnumeratorEnd = 2,
  kCFURLEnumeratorError = 3,
  kCFURLEnumeratorDirectoryPostOrderSuccess = 4
}

global['CFURLEnumeratorResult'] = CFURLEnumeratorResult;

export enum CFURLPathStyle {
  kCFURLPOSIXPathStyle = 0,
  kCFURLHFSPathStyle = 1,
  kCFURLWindowsPathStyle = 2
}

global['CFURLPathStyle'] = CFURLPathStyle;

export enum CFXMLEntityTypeCode {
  kCFXMLEntityTypeParameter = 0,
  kCFXMLEntityTypeParsedInternal = 1,
  kCFXMLEntityTypeParsedExternal = 2,
  kCFXMLEntityTypeUnparsed = 3,
  kCFXMLEntityTypeCharacter = 4
}

global['CFXMLEntityTypeCode'] = CFXMLEntityTypeCode;

export enum CFXMLNodeTypeCode {
  kCFXMLNodeTypeDocument = 1,
  kCFXMLNodeTypeElement = 2,
  kCFXMLNodeTypeAttribute = 3,
  kCFXMLNodeTypeProcessingInstruction = 4,
  kCFXMLNodeTypeComment = 5,
  kCFXMLNodeTypeText = 6,
  kCFXMLNodeTypeCDATASection = 7,
  kCFXMLNodeTypeDocumentFragment = 8,
  kCFXMLNodeTypeEntity = 9,
  kCFXMLNodeTypeEntityReference = 10,
  kCFXMLNodeTypeDocumentType = 11,
  kCFXMLNodeTypeWhitespace = 12,
  kCFXMLNodeTypeNotation = 13,
  kCFXMLNodeTypeElementTypeDeclaration = 14,
  kCFXMLNodeTypeAttributeListDeclaration = 15
}

global['CFXMLNodeTypeCode'] = CFXMLNodeTypeCode;

export enum CFXMLParserOptions {
  kCFXMLParserValidateDocument = 1,
  kCFXMLParserSkipMetaData = 2,
  kCFXMLParserReplacePhysicalEntities = 4,
  kCFXMLParserSkipWhitespace = 8,
  kCFXMLParserResolveExternalEntities = 16,
  kCFXMLParserAddImpliedAttributes = 32,
  kCFXMLParserAllOptions = 16777215,
  kCFXMLParserNoOptions = 0
}

global['CFXMLParserOptions'] = CFXMLParserOptions;

export enum CFXMLParserStatusCode {
  kCFXMLStatusParseNotBegun = -2,
  kCFXMLStatusParseInProgress = -1,
  kCFXMLStatusParseSuccessful = 0,
  kCFXMLErrorUnexpectedEOF = 1,
  kCFXMLErrorUnknownEncoding = 2,
  kCFXMLErrorEncodingConversionFailure = 3,
  kCFXMLErrorMalformedProcessingInstruction = 4,
  kCFXMLErrorMalformedDTD = 5,
  kCFXMLErrorMalformedName = 6,
  kCFXMLErrorMalformedCDSect = 7,
  kCFXMLErrorMalformedCloseTag = 8,
  kCFXMLErrorMalformedStartTag = 9,
  kCFXMLErrorMalformedDocument = 10,
  kCFXMLErrorElementlessDocument = 11,
  kCFXMLErrorMalformedComment = 12,
  kCFXMLErrorMalformedCharacterReference = 13,
  kCFXMLErrorMalformedParsedCharacterData = 14,
  kCFXMLErrorNoData = 15
}

global['CFXMLParserStatusCode'] = CFXMLParserStatusCode;

export enum __CFByteOrder {
  CFByteOrderUnknown = 0,
  CFByteOrderLittleEndian = 1,
  CFByteOrderBigEndian = 2
}

global['__CFByteOrder'] = __CFByteOrder;

export enum CGBitmapInfo {
  kCGBitmapAlphaInfoMask = 31,
  kCGBitmapFloatInfoMask = 3840,
  kCGBitmapFloatComponents = 256,
  kCGBitmapByteOrderMask = 28672,
  kCGBitmapByteOrderDefault = 0,
  kCGBitmapByteOrder16Little = 4096,
  kCGBitmapByteOrder32Little = 8192,
  kCGBitmapByteOrder16Big = 12288,
  kCGBitmapByteOrder32Big = 16384
}

global['CGBitmapInfo'] = CGBitmapInfo;

export enum CGBlendMode {
  kCGBlendModeNormal = 0,
  kCGBlendModeMultiply = 1,
  kCGBlendModeScreen = 2,
  kCGBlendModeOverlay = 3,
  kCGBlendModeDarken = 4,
  kCGBlendModeLighten = 5,
  kCGBlendModeColorDodge = 6,
  kCGBlendModeColorBurn = 7,
  kCGBlendModeSoftLight = 8,
  kCGBlendModeHardLight = 9,
  kCGBlendModeDifference = 10,
  kCGBlendModeExclusion = 11,
  kCGBlendModeHue = 12,
  kCGBlendModeSaturation = 13,
  kCGBlendModeColor = 14,
  kCGBlendModeLuminosity = 15,
  kCGBlendModeClear = 16,
  kCGBlendModeCopy = 17,
  kCGBlendModeSourceIn = 18,
  kCGBlendModeSourceOut = 19,
  kCGBlendModeSourceAtop = 20,
  kCGBlendModeDestinationOver = 21,
  kCGBlendModeDestinationIn = 22,
  kCGBlendModeDestinationOut = 23,
  kCGBlendModeDestinationAtop = 24,
  kCGBlendModeXOR = 25,
  kCGBlendModePlusDarker = 26,
  kCGBlendModePlusLighter = 27
}

global['CGBlendMode'] = CGBlendMode;

export enum CGCaptureOptions {
  kCGCaptureNoOptions = 0,
  kCGCaptureNoFill = 1
}

global['CGCaptureOptions'] = CGCaptureOptions;

export enum CGColorConversionInfoTransformType {
  kCGColorConversionTransformFromSpace = 0,
  kCGColorConversionTransformToSpace = 1,
  kCGColorConversionTransformApplySpace = 2
}

global['CGColorConversionInfoTransformType'] = CGColorConversionInfoTransformType;

export enum CGColorRenderingIntent {
  kCGRenderingIntentDefault = 0,
  kCGRenderingIntentAbsoluteColorimetric = 1,
  kCGRenderingIntentRelativeColorimetric = 2,
  kCGRenderingIntentPerceptual = 3,
  kCGRenderingIntentSaturation = 4
}

global['CGColorRenderingIntent'] = CGColorRenderingIntent;

export enum CGColorSpaceModel {
  kCGColorSpaceModelUnknown = -1,
  kCGColorSpaceModelMonochrome = 0,
  kCGColorSpaceModelRGB = 1,
  kCGColorSpaceModelCMYK = 2,
  kCGColorSpaceModelLab = 3,
  kCGColorSpaceModelDeviceN = 4,
  kCGColorSpaceModelIndexed = 5,
  kCGColorSpaceModelPattern = 6,
  kCGColorSpaceModelXYZ = 7
}

global['CGColorSpaceModel'] = CGColorSpaceModel;

export enum CGConfigureOption {
  kCGConfigureForAppOnly = 0,
  kCGConfigureForSession = 1,
  kCGConfigurePermanently = 2
}

global['CGConfigureOption'] = CGConfigureOption;

export enum CGDisplayChangeSummaryFlags {
  kCGDisplayBeginConfigurationFlag = 1,
  kCGDisplayMovedFlag = 2,
  kCGDisplaySetMainFlag = 4,
  kCGDisplaySetModeFlag = 8,
  kCGDisplayAddFlag = 16,
  kCGDisplayRemoveFlag = 32,
  kCGDisplayEnabledFlag = 256,
  kCGDisplayDisabledFlag = 512,
  kCGDisplayMirrorFlag = 1024,
  kCGDisplayUnMirrorFlag = 2048,
  kCGDisplayDesktopShapeChangedFlag = 4096
}

global['CGDisplayChangeSummaryFlags'] = CGDisplayChangeSummaryFlags;

export enum CGDisplayStreamFrameStatus {
  kCGDisplayStreamFrameStatusFrameComplete = 0,
  kCGDisplayStreamFrameStatusFrameIdle = 1,
  kCGDisplayStreamFrameStatusFrameBlank = 2,
  kCGDisplayStreamFrameStatusStopped = 3
}

global['CGDisplayStreamFrameStatus'] = CGDisplayStreamFrameStatus;

export enum CGDisplayStreamUpdateRectType {
  kCGDisplayStreamUpdateRefreshedRects = 0,
  kCGDisplayStreamUpdateMovedRects = 1,
  kCGDisplayStreamUpdateDirtyRects = 2,
  kCGDisplayStreamUpdateReducedDirtyRects = 3
}

global['CGDisplayStreamUpdateRectType'] = CGDisplayStreamUpdateRectType;

export enum CGError {
  kCGErrorSuccess = 0,
  kCGErrorFailure = 1000,
  kCGErrorIllegalArgument = 1001,
  kCGErrorInvalidConnection = 1002,
  kCGErrorInvalidContext = 1003,
  kCGErrorCannotComplete = 1004,
  kCGErrorNotImplemented = 1006,
  kCGErrorRangeCheck = 1007,
  kCGErrorTypeCheck = 1008,
  kCGErrorInvalidOperation = 1010,
  kCGErrorNoneAvailable = 1011
}

global['CGError'] = CGError;

export enum CGEventField {
  kCGMouseEventNumber = 0,
  kCGMouseEventClickState = 1,
  kCGMouseEventPressure = 2,
  kCGMouseEventButtonNumber = 3,
  kCGMouseEventDeltaX = 4,
  kCGMouseEventDeltaY = 5,
  kCGMouseEventInstantMouser = 6,
  kCGMouseEventSubtype = 7,
  kCGKeyboardEventAutorepeat = 8,
  kCGKeyboardEventKeycode = 9,
  kCGKeyboardEventKeyboardType = 10,
  kCGScrollWheelEventDeltaAxis1 = 11,
  kCGScrollWheelEventDeltaAxis2 = 12,
  kCGScrollWheelEventDeltaAxis3 = 13,
  kCGScrollWheelEventFixedPtDeltaAxis1 = 93,
  kCGScrollWheelEventFixedPtDeltaAxis2 = 94,
  kCGScrollWheelEventFixedPtDeltaAxis3 = 95,
  kCGScrollWheelEventPointDeltaAxis1 = 96,
  kCGScrollWheelEventPointDeltaAxis2 = 97,
  kCGScrollWheelEventPointDeltaAxis3 = 98,
  kCGScrollWheelEventScrollPhase = 99,
  kCGScrollWheelEventScrollCount = 100,
  kCGScrollWheelEventMomentumPhase = 123,
  kCGScrollWheelEventInstantMouser = 14,
  kCGTabletEventPointX = 15,
  kCGTabletEventPointY = 16,
  kCGTabletEventPointZ = 17,
  kCGTabletEventPointButtons = 18,
  kCGTabletEventPointPressure = 19,
  kCGTabletEventTiltX = 20,
  kCGTabletEventTiltY = 21,
  kCGTabletEventRotation = 22,
  kCGTabletEventTangentialPressure = 23,
  kCGTabletEventDeviceID = 24,
  kCGTabletEventVendor1 = 25,
  kCGTabletEventVendor2 = 26,
  kCGTabletEventVendor3 = 27,
  kCGTabletProximityEventVendorID = 28,
  kCGTabletProximityEventTabletID = 29,
  kCGTabletProximityEventPointerID = 30,
  kCGTabletProximityEventDeviceID = 31,
  kCGTabletProximityEventSystemTabletID = 32,
  kCGTabletProximityEventVendorPointerType = 33,
  kCGTabletProximityEventVendorPointerSerialNumber = 34,
  kCGTabletProximityEventVendorUniqueID = 35,
  kCGTabletProximityEventCapabilityMask = 36,
  kCGTabletProximityEventPointerType = 37,
  kCGTabletProximityEventEnterProximity = 38,
  kCGEventTargetProcessSerialNumber = 39,
  kCGEventTargetUnixProcessID = 40,
  kCGEventSourceUnixProcessID = 41,
  kCGEventSourceUserData = 42,
  kCGEventSourceUserID = 43,
  kCGEventSourceGroupID = 44,
  kCGEventSourceStateID = 45,
  kCGScrollWheelEventIsContinuous = 88,
  kCGMouseEventWindowUnderMousePointer = 91,
  kCGMouseEventWindowUnderMousePointerThatCanHandleThisEvent = 92,
  kCGEventUnacceleratedPointerMovementX = 170,
  kCGEventUnacceleratedPointerMovementY = 171
}

global['CGEventField'] = CGEventField;

export enum CGEventFilterMask {
  kCGEventFilterMaskPermitLocalMouseEvents = 1,
  kCGEventFilterMaskPermitLocalKeyboardEvents = 2,
  kCGEventFilterMaskPermitSystemDefinedEvents = 4
}

global['CGEventFilterMask'] = CGEventFilterMask;

export enum CGEventFlags {
  kCGEventFlagMaskAlphaShift = 65536,
  kCGEventFlagMaskShift = 131072,
  kCGEventFlagMaskControl = 262144,
  kCGEventFlagMaskAlternate = 524288,
  kCGEventFlagMaskCommand = 1048576,
  kCGEventFlagMaskHelp = 4194304,
  kCGEventFlagMaskSecondaryFn = 8388608,
  kCGEventFlagMaskNumericPad = 2097152,
  kCGEventFlagMaskNonCoalesced = 256
}

global['CGEventFlags'] = CGEventFlags;

export enum CGEventMouseSubtype {
  kCGEventMouseSubtypeDefault = 0,
  kCGEventMouseSubtypeTabletPoint = 1,
  kCGEventMouseSubtypeTabletProximity = 2
}

global['CGEventMouseSubtype'] = CGEventMouseSubtype;

export enum CGEventSourceStateID {
  kCGEventSourceStatePrivate = -1,
  kCGEventSourceStateCombinedSessionState = 0,
  kCGEventSourceStateHIDSystemState = 1
}

global['CGEventSourceStateID'] = CGEventSourceStateID;

export enum CGEventSuppressionState {
  kCGEventSuppressionStateSuppressionInterval = 0,
  kCGEventSuppressionStateRemoteMouseDrag = 1,
  kCGNumberOfEventSuppressionStates = 2
}

global['CGEventSuppressionState'] = CGEventSuppressionState;

export enum CGEventTapLocation {
  kCGHIDEventTap = 0,
  kCGSessionEventTap = 1,
  kCGAnnotatedSessionEventTap = 2
}

global['CGEventTapLocation'] = CGEventTapLocation;

export enum CGEventTapOptions {
  kCGEventTapOptionDefault = 0,
  kCGEventTapOptionListenOnly = 1
}

global['CGEventTapOptions'] = CGEventTapOptions;

export enum CGEventTapPlacement {
  kCGHeadInsertEventTap = 0,
  kCGTailAppendEventTap = 1
}

global['CGEventTapPlacement'] = CGEventTapPlacement;

export enum CGEventType {
  kCGEventNull = 0,
  kCGEventLeftMouseDown = 1,
  kCGEventLeftMouseUp = 2,
  kCGEventRightMouseDown = 3,
  kCGEventRightMouseUp = 4,
  kCGEventMouseMoved = 5,
  kCGEventLeftMouseDragged = 6,
  kCGEventRightMouseDragged = 7,
  kCGEventKeyDown = 10,
  kCGEventKeyUp = 11,
  kCGEventFlagsChanged = 12,
  kCGEventScrollWheel = 22,
  kCGEventTabletPointer = 23,
  kCGEventTabletProximity = 24,
  kCGEventOtherMouseDown = 25,
  kCGEventOtherMouseUp = 26,
  kCGEventOtherMouseDragged = 27,
  kCGEventTapDisabledByTimeout = 4294967294,
  kCGEventTapDisabledByUserInput = 4294967295
}

global['CGEventType'] = CGEventType;

export enum CGFontPostScriptFormat {
  kCGFontPostScriptFormatType1 = 1,
  kCGFontPostScriptFormatType3 = 3,
  kCGFontPostScriptFormatType42 = 42
}

global['CGFontPostScriptFormat'] = CGFontPostScriptFormat;

export enum CGGesturePhase {
  kCGGesturePhaseNone = 0,
  kCGGesturePhaseBegan = 1,
  kCGGesturePhaseChanged = 2,
  kCGGesturePhaseEnded = 4,
  kCGGesturePhaseCancelled = 8,
  kCGGesturePhaseMayBegin = 128
}

global['CGGesturePhase'] = CGGesturePhase;

export enum CGGlyphDeprecatedEnum {
  Min = 0,
  Max = 1
}

global['CGGlyphDeprecatedEnum'] = CGGlyphDeprecatedEnum;

export enum CGGradientDrawingOptions {
  kCGGradientDrawsBeforeStartLocation = 1,
  kCGGradientDrawsAfterEndLocation = 2
}

global['CGGradientDrawingOptions'] = CGGradientDrawingOptions;

export enum CGImageAlphaInfo {
  kCGImageAlphaNone = 0,
  kCGImageAlphaPremultipliedLast = 1,
  kCGImageAlphaPremultipliedFirst = 2,
  kCGImageAlphaLast = 3,
  kCGImageAlphaFirst = 4,
  kCGImageAlphaNoneSkipLast = 5,
  kCGImageAlphaNoneSkipFirst = 6,
  kCGImageAlphaOnly = 7
}

global['CGImageAlphaInfo'] = CGImageAlphaInfo;

export enum CGImageByteOrderInfo {
  kCGImageByteOrderMask = 28672,
  kCGImageByteOrderDefault = 0,
  kCGImageByteOrder16Little = 4096,
  kCGImageByteOrder32Little = 8192,
  kCGImageByteOrder16Big = 12288,
  kCGImageByteOrder32Big = 16384
}

global['CGImageByteOrderInfo'] = CGImageByteOrderInfo;

export enum CGImagePixelFormatInfo {
  kCGImagePixelFormatMask = 983040,
  kCGImagePixelFormatPacked = 0,
  kCGImagePixelFormatRGB555 = 65536,
  kCGImagePixelFormatRGB565 = 131072,
  kCGImagePixelFormatRGB101010 = 196608,
  kCGImagePixelFormatRGBCIF10 = 262144
}

global['CGImagePixelFormatInfo'] = CGImagePixelFormatInfo;

export enum CGInterpolationQuality {
  kCGInterpolationDefault = 0,
  kCGInterpolationNone = 1,
  kCGInterpolationLow = 2,
  kCGInterpolationMedium = 4,
  kCGInterpolationHigh = 3
}

global['CGInterpolationQuality'] = CGInterpolationQuality;

export enum CGLineCap {
  kCGLineCapButt = 0,
  kCGLineCapRound = 1,
  kCGLineCapSquare = 2
}

global['CGLineCap'] = CGLineCap;

export enum CGLineJoin {
  kCGLineJoinMiter = 0,
  kCGLineJoinRound = 1,
  kCGLineJoinBevel = 2
}

global['CGLineJoin'] = CGLineJoin;

export enum CGMomentumScrollPhase {
  kCGMomentumScrollPhaseNone = 0,
  kCGMomentumScrollPhaseBegin = 1,
  kCGMomentumScrollPhaseContinue = 2,
  kCGMomentumScrollPhaseEnd = 3
}

global['CGMomentumScrollPhase'] = CGMomentumScrollPhase;

export enum CGMouseButton {
  kCGMouseButtonLeft = 0,
  kCGMouseButtonRight = 1,
  kCGMouseButtonCenter = 2
}

global['CGMouseButton'] = CGMouseButton;

export enum CGPDFAccessPermissions {
  kCGPDFAllowsLowQualityPrinting = 1,
  kCGPDFAllowsHighQualityPrinting = 2,
  kCGPDFAllowsDocumentChanges = 4,
  kCGPDFAllowsDocumentAssembly = 8,
  kCGPDFAllowsContentCopying = 16,
  kCGPDFAllowsContentAccessibility = 32,
  kCGPDFAllowsCommenting = 64,
  kCGPDFAllowsFormFieldEntry = 128
}

global['CGPDFAccessPermissions'] = CGPDFAccessPermissions;

export enum CGPDFBox {
  kCGPDFMediaBox = 0,
  kCGPDFCropBox = 1,
  kCGPDFBleedBox = 2,
  kCGPDFTrimBox = 3,
  kCGPDFArtBox = 4
}

global['CGPDFBox'] = CGPDFBox;

export enum CGPDFDataFormat {
  Raw = 0,
  JPEGEncoded = 1,
  JPEG2000 = 2
}

global['CGPDFDataFormat'] = CGPDFDataFormat;

export enum CGPDFObjectType {
  kCGPDFObjectTypeNull = 1,
  kCGPDFObjectTypeBoolean = 2,
  kCGPDFObjectTypeInteger = 3,
  kCGPDFObjectTypeReal = 4,
  kCGPDFObjectTypeName = 5,
  kCGPDFObjectTypeString = 6,
  kCGPDFObjectTypeArray = 7,
  kCGPDFObjectTypeDictionary = 8,
  kCGPDFObjectTypeStream = 9
}

global['CGPDFObjectType'] = CGPDFObjectType;

export enum CGPDFTagType {
  Document = 100,
  Part = 101,
  Art = 102,
  Section = 103,
  Div = 104,
  BlockQuote = 105,
  Caption = 106,
  TOC = 107,
  TOCI = 108,
  Index = 109,
  NonStructure = 110,
  Private = 111,
  Paragraph = 200,
  Header = 201,
  Header1 = 202,
  Header2 = 203,
  Header3 = 204,
  Header4 = 205,
  Header5 = 206,
  Header6 = 207,
  List = 300,
  ListItem = 301,
  Label = 302,
  ListBody = 303,
  Table = 400,
  TableRow = 401,
  TableHeaderCell = 402,
  TableDataCell = 403,
  TableHeader = 404,
  TableBody = 405,
  TableFooter = 406,
  Span = 500,
  Quote = 501,
  Note = 502,
  Reference = 503,
  Bibliography = 504,
  Code = 505,
  Link = 506,
  Annotation = 507,
  Ruby = 600,
  RubyBaseText = 601,
  RubyAnnotationText = 602,
  RubyPunctuation = 603,
  Warichu = 604,
  WarichuText = 605,
  WarichuPunctiation = 606,
  Figure = 700,
  Formula = 701,
  Form = 702
}

global['CGPDFTagType'] = CGPDFTagType;

export enum CGPathDrawingMode {
  kCGPathFill = 0,
  kCGPathEOFill = 1,
  kCGPathStroke = 2,
  kCGPathFillStroke = 3,
  kCGPathEOFillStroke = 4
}

global['CGPathDrawingMode'] = CGPathDrawingMode;

export enum CGPathElementType {
  kCGPathElementMoveToPoint = 0,
  kCGPathElementAddLineToPoint = 1,
  kCGPathElementAddQuadCurveToPoint = 2,
  kCGPathElementAddCurveToPoint = 3,
  kCGPathElementCloseSubpath = 4
}

global['CGPathElementType'] = CGPathElementType;

export enum CGPatternTiling {
  kCGPatternTilingNoDistortion = 0,
  kCGPatternTilingConstantSpacingMinimalDistortion = 1,
  kCGPatternTilingConstantSpacing = 2
}

global['CGPatternTiling'] = CGPatternTiling;

export enum CGRectEdge {
  MinXEdge = 0,
  MinYEdge = 1,
  MaxXEdge = 2,
  MaxYEdge = 3
}

global['CGRectEdge'] = CGRectEdge;

export enum CGScreenUpdateOperation {
  kCGScreenUpdateOperationRefresh = 0,
  kCGScreenUpdateOperationMove = 1,
  kCGScreenUpdateOperationReducedDirtyRectangleCount = 2147483648
}

global['CGScreenUpdateOperation'] = CGScreenUpdateOperation;

export enum CGScrollEventUnit {
  kCGScrollEventUnitPixel = 0,
  kCGScrollEventUnitLine = 1
}

global['CGScrollEventUnit'] = CGScrollEventUnit;

export enum CGScrollPhase {
  kCGScrollPhaseBegan = 1,
  kCGScrollPhaseChanged = 2,
  kCGScrollPhaseEnded = 4,
  kCGScrollPhaseCancelled = 8,
  kCGScrollPhaseMayBegin = 128
}

global['CGScrollPhase'] = CGScrollPhase;

export enum CGTextDrawingMode {
  kCGTextFill = 0,
  kCGTextStroke = 1,
  kCGTextFillStroke = 2,
  kCGTextInvisible = 3,
  kCGTextFillClip = 4,
  kCGTextStrokeClip = 5,
  kCGTextFillStrokeClip = 6,
  kCGTextClip = 7
}

global['CGTextDrawingMode'] = CGTextDrawingMode;

export enum CGWindowBackingType {
  kCGBackingStoreRetained = 0,
  kCGBackingStoreNonretained = 1,
  kCGBackingStoreBuffered = 2
}

global['CGWindowBackingType'] = CGWindowBackingType;

export enum CGWindowImageOption {
  kCGWindowImageDefault = 0,
  kCGWindowImageBoundsIgnoreFraming = 1,
  kCGWindowImageShouldBeOpaque = 2,
  kCGWindowImageOnlyShadows = 4,
  kCGWindowImageBestResolution = 8,
  kCGWindowImageNominalResolution = 16
}

global['CGWindowImageOption'] = CGWindowImageOption;

export enum CGWindowLevelKey {
  kCGBaseWindowLevelKey = 0,
  kCGMinimumWindowLevelKey = 1,
  kCGDesktopWindowLevelKey = 2,
  kCGBackstopMenuLevelKey = 3,
  kCGNormalWindowLevelKey = 4,
  kCGFloatingWindowLevelKey = 5,
  kCGTornOffMenuWindowLevelKey = 6,
  kCGDockWindowLevelKey = 7,
  kCGMainMenuWindowLevelKey = 8,
  kCGStatusWindowLevelKey = 9,
  kCGModalPanelWindowLevelKey = 10,
  kCGPopUpMenuWindowLevelKey = 11,
  kCGDraggingWindowLevelKey = 12,
  kCGScreenSaverWindowLevelKey = 13,
  kCGMaximumWindowLevelKey = 14,
  kCGOverlayWindowLevelKey = 15,
  kCGHelpWindowLevelKey = 16,
  kCGUtilityWindowLevelKey = 17,
  kCGDesktopIconWindowLevelKey = 18,
  kCGCursorWindowLevelKey = 19,
  kCGAssistiveTechHighWindowLevelKey = 20,
  kCGNumberOfWindowLevelKeys = 21
}

global['CGWindowLevelKey'] = CGWindowLevelKey;

export enum CGWindowListOption {
  kCGWindowListOptionAll = 0,
  kCGWindowListOptionOnScreenOnly = 1,
  kCGWindowListOptionOnScreenAboveWindow = 2,
  kCGWindowListOptionOnScreenBelowWindow = 4,
  kCGWindowListOptionIncludingWindow = 8,
  kCGWindowListExcludeDesktopElements = 16
}

global['CGWindowListOption'] = CGWindowListOption;

export enum CGWindowSharingType {
  kCGWindowSharingNone = 0,
  kCGWindowSharingReadOnly = 1,
  kCGWindowSharingReadWrite = 2
}

global['CGWindowSharingType'] = CGWindowSharingType;

export enum CIDataMatrixCodeECCVersion {
  Version000 = 0,
  Version050 = 50,
  Version080 = 80,
  Version100 = 100,
  Version140 = 140,
  Version200 = 200
}

global['CIDataMatrixCodeECCVersion'] = CIDataMatrixCodeECCVersion;

export enum CIQRCodeErrorCorrectionLevel {
  L = 76,
  M = 77,
  Q = 81,
  H = 72
}

global['CIQRCodeErrorCorrectionLevel'] = CIQRCodeErrorCorrectionLevel;

export enum CIRenderDestinationAlphaMode {
  None = 0,
  Premultiplied = 1,
  Unpremultiplied = 2
}

global['CIRenderDestinationAlphaMode'] = CIRenderDestinationAlphaMode;

export enum CMTimeFlags {
  kCMTimeFlags_Valid = 1,
  kCMTimeFlags_HasBeenRounded = 2,
  kCMTimeFlags_PositiveInfinity = 4,
  kCMTimeFlags_NegativeInfinity = 8,
  kCMTimeFlags_Indefinite = 16,
  kCMTimeFlags_ImpliedValueFlagsMask = 28
}

global['CMTimeFlags'] = CMTimeFlags;

export enum CMTimeRoundingMethod {
  kCMTimeRoundingMethod_RoundHalfAwayFromZero = 1,
  kCMTimeRoundingMethod_RoundTowardZero = 2,
  kCMTimeRoundingMethod_RoundAwayFromZero = 3,
  kCMTimeRoundingMethod_QuickTime = 4,
  kCMTimeRoundingMethod_RoundTowardPositiveInfinity = 5,
  kCMTimeRoundingMethod_RoundTowardNegativeInfinity = 6,
  kCMTimeRoundingMethod_Default = 1
}

global['CMTimeRoundingMethod'] = CMTimeRoundingMethod;

export enum AlignmentOptions {
  MinXInward = 1,
  MinYInward = 2,
  MaxXInward = 4,
  MaxYInward = 8,
  WidthInward = 16,
  HeightInward = 32,
  MinXOutward = 256,
  MinYOutward = 512,
  MaxXOutward = 1024,
  MaxYOutward = 2048,
  WidthOutward = 4096,
  HeightOutward = 8192,
  MinXNearest = 65536,
  MinYNearest = 131072,
  MaxXNearest = 262144,
  MaxYNearest = 524288,
  WidthNearest = 1048576,
  HeightNearest = 2097152,
  RectFlipped = -9223372036854775808,
  AllEdgesInward = 15,
  AllEdgesOutward = 3840,
  AllEdgesNearest = 983040
}

global['AlignmentOptions'] = AlignmentOptions;

export enum NSBinarySearchingOptions {
  FirstEqual = 256,
  LastEqual = 512,
  InsertionIndex = 1024
}

global['NSBinarySearchingOptions'] = NSBinarySearchingOptions;

export enum NSCollectionChangeType {
  Insert = 0,
  Remove = 1
}

global['NSCollectionChangeType'] = NSCollectionChangeType;

export enum ComparisonResult {
  OrderedAscending = -1,
  OrderedSame = 0,
  OrderedDescending = 1
}

global['ComparisonResult'] = ComparisonResult;

export enum NSEnumerationOptions {
  Concurrent = 1,
  Reverse = 2
}

global['NSEnumerationOptions'] = NSEnumerationOptions;

export enum NSItemProviderFileOptions {
  OpenInPlace = 1
}

global['NSItemProviderFileOptions'] = NSItemProviderFileOptions;

export enum NSItemProviderRepresentationVisibility {
  All = 0,
  Team = 1,
  Group = 2,
  OwnProcess = 3
}

global['NSItemProviderRepresentationVisibility'] = NSItemProviderRepresentationVisibility;

export enum NSKeyValueChange {
  Setting = 1,
  Insertion = 2,
  Removal = 3,
  Replacement = 4
}

global['NSKeyValueChange'] = NSKeyValueChange;

export enum NSKeyValueObservingOptions {
  New = 1,
  Old = 2,
  Initial = 4,
  Prior = 8
}

global['NSKeyValueObservingOptions'] = NSKeyValueObservingOptions;

export enum NSKeyValueSetMutationKind {
  UnionSetMutation = 1,
  MinusSetMutation = 2,
  IntersectSetMutation = 3,
  SetSetMutation = 4
}

global['NSKeyValueSetMutationKind'] = NSKeyValueSetMutationKind;

export enum NSLinguisticTaggerUnit {
  Word = 0,
  Sentence = 1,
  Paragraph = 2,
  Document = 3
}

global['NSLinguisticTaggerUnit'] = NSLinguisticTaggerUnit;

export enum NSOrderedCollectionDifferenceCalculationOptions {
  OmitInsertedObjects = 1,
  OmitRemovedObjects = 2,
  InferMoves = 4
}

global['NSOrderedCollectionDifferenceCalculationOptions'] = NSOrderedCollectionDifferenceCalculationOptions;

export enum QualityOfService {
  UserInteractive = 33,
  UserInitiated = 25,
  Utility = 17,
  Background = 9,
  Default = -1
}

global['QualityOfService'] = QualityOfService;

export enum NSRectEdge {
  RectEdgeMinX = 0,
  RectEdgeMinY = 1,
  RectEdgeMaxX = 2,
  RectEdgeMaxY = 3,
  MinXEdge = 0,
  MinYEdge = 1,
  MaxXEdge = 2,
  MaxYEdge = 3
}

global['NSRectEdge'] = NSRectEdge;

export enum NSSaveOptions {
  Yes = 0,
  No = 1,
  Ask = 2
}

global['NSSaveOptions'] = NSSaveOptions;

export enum NSSortOptions {
  Concurrent = 1,
  Stable = 16
}

global['NSSortOptions'] = NSSortOptions;

export enum NSURLErrorNetworkUnavailableReason {
  Cellular = 0,
  Expensive = 1,
  Constrained = 2
}

global['NSURLErrorNetworkUnavailableReason'] = NSURLErrorNetworkUnavailableReason;

export enum NSURLSessionDelayedRequestDisposition {
  ContinueLoading = 0,
  UseNewRequest = 1,
  Cancel = 2
}

global['NSURLSessionDelayedRequestDisposition'] = NSURLSessionDelayedRequestDisposition;

export enum NSURLSessionWebSocketMessageType {
  Data = 0,
  String = 1
}

global['NSURLSessionWebSocketMessageType'] = NSURLSessionWebSocketMessageType;

export enum IKCameraDeviceViewDisplayMode {
  None = -1,
  Table = 0,
  Icon = 1
}

global['IKCameraDeviceViewDisplayMode'] = IKCameraDeviceViewDisplayMode;

export enum IKCameraDeviceViewTransferMode {
  FileBased = 0,
  MemoryBased = 1
}

global['IKCameraDeviceViewTransferMode'] = IKCameraDeviceViewTransferMode;

export enum IKDeviceBrowserViewDisplayMode {
  Table = 0,
  Outline = 1,
  Icon = 2
}

global['IKDeviceBrowserViewDisplayMode'] = IKDeviceBrowserViewDisplayMode;

export enum IKImageBrowserCellState {
  StateNoImage = 0,
  StateInvalid = 1,
  StateReady = 2
}

global['IKImageBrowserCellState'] = IKImageBrowserCellState;

export enum IKImageBrowserDropOperation {
  On = 0,
  Before = 1
}

global['IKImageBrowserDropOperation'] = IKImageBrowserDropOperation;

export enum IKScannerDeviceViewDisplayMode {
  None = -1,
  Simple = 0,
  Advanced = 1
}

global['IKScannerDeviceViewDisplayMode'] = IKScannerDeviceViewDisplayMode;

export enum IKScannerDeviceViewTransferMode {
  FileBased = 0,
  MemoryBased = 1
}

global['IKScannerDeviceViewTransferMode'] = IKScannerDeviceViewTransferMode;

export enum QCPlugInExecutionMode {
  kQCPlugInExecutionModeProvider = 1,
  kQCPlugInExecutionModeProcessor = 2,
  kQCPlugInExecutionModeConsumer = 3
}

global['QCPlugInExecutionMode'] = QCPlugInExecutionMode;

export enum QCPlugInTimeMode {
  kQCPlugInTimeModeNone = 0,
  kQCPlugInTimeModeIdle = 1,
  kQCPlugInTimeModeTimeBase = 2
}

global['QCPlugInTimeMode'] = QCPlugInTimeMode;

export enum QLPreviewViewStyle {
  Normal = 0,
  Compact = 1
}

global['QLPreviewViewStyle'] = QLPreviewViewStyle;

export enum CAAutoresizingMask {
  kCALayerNotSizable = 0,
  kCALayerMinXMargin = 1,
  kCALayerWidthSizable = 2,
  kCALayerMaxXMargin = 4,
  kCALayerMinYMargin = 8,
  kCALayerHeightSizable = 16,
  kCALayerMaxYMargin = 32
}

global['CAAutoresizingMask'] = CAAutoresizingMask;

export enum CAConstraintAttribute {
  kCAConstraintMinX = 0,
  kCAConstraintMidX = 1,
  kCAConstraintMaxX = 2,
  kCAConstraintWidth = 3,
  kCAConstraintMinY = 4,
  kCAConstraintMidY = 5,
  kCAConstraintMaxY = 6,
  kCAConstraintHeight = 7
}

global['CAConstraintAttribute'] = CAConstraintAttribute;

export enum CACornerMask {
  kCALayerMinXMinYCorner = 1,
  kCALayerMaxXMinYCorner = 2,
  kCALayerMinXMaxYCorner = 4,
  kCALayerMaxXMaxYCorner = 8
}

global['CACornerMask'] = CACornerMask;

export enum CAEdgeAntialiasingMask {
  kCALayerLeftEdge = 1,
  kCALayerRightEdge = 2,
  kCALayerBottomEdge = 4,
  kCALayerTopEdge = 8
}

global['CAEdgeAntialiasingMask'] = CAEdgeAntialiasingMask;

// export let AVAssetExportPreset1280x720: string;
// global['AVAssetExportPreset1280x720'] = AVAssetExportPreset1280x720;

// export let AVAssetExportPreset1920x1080: string;
// global['AVAssetExportPreset1920x1080'] = AVAssetExportPreset1920x1080;

// export let AVAssetExportPreset3840x2160: string;
// global['AVAssetExportPreset3840x2160'] = AVAssetExportPreset3840x2160;

// export let AVAssetExportPreset640x480: string;
// global['AVAssetExportPreset640x480'] = AVAssetExportPreset640x480;

// export let AVAssetExportPreset960x540: string;
// global['AVAssetExportPreset960x540'] = AVAssetExportPreset960x540;

// export let AVAssetExportPresetAppleM4A: string;
// global['AVAssetExportPresetAppleM4A'] = AVAssetExportPresetAppleM4A;

// export let AVAssetExportPresetAppleM4V1080pHD: string;
// global['AVAssetExportPresetAppleM4V1080pHD'] = AVAssetExportPresetAppleM4V1080pHD;

// export let AVAssetExportPresetAppleM4V480pSD: string;
// global['AVAssetExportPresetAppleM4V480pSD'] = AVAssetExportPresetAppleM4V480pSD;

// export let AVAssetExportPresetAppleM4V720pHD: string;
// global['AVAssetExportPresetAppleM4V720pHD'] = AVAssetExportPresetAppleM4V720pHD;

// export let AVAssetExportPresetAppleM4VAppleTV: string;
// global['AVAssetExportPresetAppleM4VAppleTV'] = AVAssetExportPresetAppleM4VAppleTV;

// export let AVAssetExportPresetAppleM4VCellular: string;
// global['AVAssetExportPresetAppleM4VCellular'] = AVAssetExportPresetAppleM4VCellular;

// export let AVAssetExportPresetAppleM4VWiFi: string;
// global['AVAssetExportPresetAppleM4VWiFi'] = AVAssetExportPresetAppleM4VWiFi;

// export let AVAssetExportPresetAppleM4ViPod: string;
// global['AVAssetExportPresetAppleM4ViPod'] = AVAssetExportPresetAppleM4ViPod;

// export let AVAssetExportPresetAppleProRes422LPCM: string;
// global['AVAssetExportPresetAppleProRes422LPCM'] = AVAssetExportPresetAppleProRes422LPCM;

// export let AVAssetExportPresetAppleProRes4444LPCM: string;
// global['AVAssetExportPresetAppleProRes4444LPCM'] = AVAssetExportPresetAppleProRes4444LPCM;

// export let AVAssetExportPresetHEVC1920x1080: string;
// global['AVAssetExportPresetHEVC1920x1080'] = AVAssetExportPresetHEVC1920x1080;

// export let AVAssetExportPresetHEVC1920x1080WithAlpha: string;
// global['AVAssetExportPresetHEVC1920x1080WithAlpha'] = AVAssetExportPresetHEVC1920x1080WithAlpha;

// export let AVAssetExportPresetHEVC3840x2160: string;
// global['AVAssetExportPresetHEVC3840x2160'] = AVAssetExportPresetHEVC3840x2160;

// export let AVAssetExportPresetHEVC3840x2160WithAlpha: string;
// global['AVAssetExportPresetHEVC3840x2160WithAlpha'] = AVAssetExportPresetHEVC3840x2160WithAlpha;

// export let AVAssetExportPresetHEVCHighestQuality: string;
// global['AVAssetExportPresetHEVCHighestQuality'] = AVAssetExportPresetHEVCHighestQuality;

// export let AVAssetExportPresetHEVCHighestQualityWithAlpha: string;
// global['AVAssetExportPresetHEVCHighestQualityWithAlpha'] = AVAssetExportPresetHEVCHighestQualityWithAlpha;

// export let AVAssetExportPresetHighestQuality: string;
// global['AVAssetExportPresetHighestQuality'] = AVAssetExportPresetHighestQuality;

// export let AVAssetExportPresetLowQuality: string;
// global['AVAssetExportPresetLowQuality'] = AVAssetExportPresetLowQuality;

// export let AVAssetExportPresetMediumQuality: string;
// global['AVAssetExportPresetMediumQuality'] = AVAssetExportPresetMediumQuality;

// export let AVAssetExportPresetPassthrough: string;
// global['AVAssetExportPresetPassthrough'] = AVAssetExportPresetPassthrough;

// export let AVAssetResourceLoadingRequestStreamingContentKeyRequestRequiresPersistentKey: string;
// global['AVAssetResourceLoadingRequestStreamingContentKeyRequestRequiresPersistentKey'] = AVAssetResourceLoadingRequestStreamingContentKeyRequestRequiresPersistentKey;

// export let AVAudioBitRateStrategy_Constant: string;
// global['AVAudioBitRateStrategy_Constant'] = AVAudioBitRateStrategy_Constant;

// export let AVAudioBitRateStrategy_LongTermAverage: string;
// global['AVAudioBitRateStrategy_LongTermAverage'] = AVAudioBitRateStrategy_LongTermAverage;

// export let AVAudioBitRateStrategy_Variable: string;
// global['AVAudioBitRateStrategy_Variable'] = AVAudioBitRateStrategy_Variable;

// export let AVAudioBitRateStrategy_VariableConstrained: string;
// global['AVAudioBitRateStrategy_VariableConstrained'] = AVAudioBitRateStrategy_VariableConstrained;

// export let AVAudioFileTypeKey: string;
// global['AVAudioFileTypeKey'] = AVAudioFileTypeKey;

// export let AVAudioUnitManufacturerNameApple: string;
// global['AVAudioUnitManufacturerNameApple'] = AVAudioUnitManufacturerNameApple;

// export let AVAudioUnitTypeEffect: string;
// global['AVAudioUnitTypeEffect'] = AVAudioUnitTypeEffect;

// export let AVAudioUnitTypeFormatConverter: string;
// global['AVAudioUnitTypeFormatConverter'] = AVAudioUnitTypeFormatConverter;

// export let AVAudioUnitTypeGenerator: string;
// global['AVAudioUnitTypeGenerator'] = AVAudioUnitTypeGenerator;

// export let AVAudioUnitTypeMIDIProcessor: string;
// global['AVAudioUnitTypeMIDIProcessor'] = AVAudioUnitTypeMIDIProcessor;

// export let AVAudioUnitTypeMixer: string;
// global['AVAudioUnitTypeMixer'] = AVAudioUnitTypeMixer;

// export let AVAudioUnitTypeMusicDevice: string;
// global['AVAudioUnitTypeMusicDevice'] = AVAudioUnitTypeMusicDevice;

// export let AVAudioUnitTypeMusicEffect: string;
// global['AVAudioUnitTypeMusicEffect'] = AVAudioUnitTypeMusicEffect;

// export let AVAudioUnitTypeOfflineEffect: string;
// global['AVAudioUnitTypeOfflineEffect'] = AVAudioUnitTypeOfflineEffect;

// export let AVAudioUnitTypeOutput: string;
// global['AVAudioUnitTypeOutput'] = AVAudioUnitTypeOutput;

// export let AVAudioUnitTypePanner: string;
// global['AVAudioUnitTypePanner'] = AVAudioUnitTypePanner;

// export let AVCaptureSessionErrorKey: string;
// global['AVCaptureSessionErrorKey'] = AVCaptureSessionErrorKey;

// export let AVChannelLayoutKey: string;
// global['AVChannelLayoutKey'] = AVChannelLayoutKey;

// export let AVContentKeyRequestProtocolVersionsKey: string;
// global['AVContentKeyRequestProtocolVersionsKey'] = AVContentKeyRequestProtocolVersionsKey;

// export let AVContentKeyRequestRequiresValidationDataInSecureTokenKey: string;
// global['AVContentKeyRequestRequiresValidationDataInSecureTokenKey'] = AVContentKeyRequestRequiresValidationDataInSecureTokenKey;

// export let AVCoreAnimationBeginTimeAtZero: number;
// global['AVCoreAnimationBeginTimeAtZero'] = AVCoreAnimationBeginTimeAtZero;

// export let AVEncoderAudioQualityForVBRKey: string;
// global['AVEncoderAudioQualityForVBRKey'] = AVEncoderAudioQualityForVBRKey;

// export let AVEncoderAudioQualityKey: string;
// global['AVEncoderAudioQualityKey'] = AVEncoderAudioQualityKey;

// export let AVEncoderBitDepthHintKey: string;
// global['AVEncoderBitDepthHintKey'] = AVEncoderBitDepthHintKey;

// export let AVEncoderBitRateKey: string;
// global['AVEncoderBitRateKey'] = AVEncoderBitRateKey;

// export let AVEncoderBitRatePerChannelKey: string;
// global['AVEncoderBitRatePerChannelKey'] = AVEncoderBitRatePerChannelKey;

// export let AVEncoderBitRateStrategyKey: string;
// global['AVEncoderBitRateStrategyKey'] = AVEncoderBitRateStrategyKey;

// export let AVErrorDeviceKey: string;
// global['AVErrorDeviceKey'] = AVErrorDeviceKey;

// export let AVErrorDiscontinuityFlagsKey: string;
// global['AVErrorDiscontinuityFlagsKey'] = AVErrorDiscontinuityFlagsKey;

// export let AVErrorFileSizeKey: string;
// global['AVErrorFileSizeKey'] = AVErrorFileSizeKey;

// export let AVErrorFileTypeKey: string;
// global['AVErrorFileTypeKey'] = AVErrorFileTypeKey;

// export let AVErrorMediaSubTypeKey: string;
// global['AVErrorMediaSubTypeKey'] = AVErrorMediaSubTypeKey;

// export let AVErrorMediaTypeKey: string;
// global['AVErrorMediaTypeKey'] = AVErrorMediaTypeKey;

// export let AVErrorPIDKey: string;
// global['AVErrorPIDKey'] = AVErrorPIDKey;

// export let AVErrorPersistentTrackIDKey: string;
// global['AVErrorPersistentTrackIDKey'] = AVErrorPersistentTrackIDKey;

// export let AVErrorPresentationTimeStampKey: string;
// global['AVErrorPresentationTimeStampKey'] = AVErrorPresentationTimeStampKey;

// export let AVErrorRecordingSuccessfullyFinishedKey: string;
// global['AVErrorRecordingSuccessfullyFinishedKey'] = AVErrorRecordingSuccessfullyFinishedKey;

// export let AVErrorTimeKey: string;
// global['AVErrorTimeKey'] = AVErrorTimeKey;

// export let AVFormatIDKey: string;
// global['AVFormatIDKey'] = AVFormatIDKey;

// export let AVFoundationErrorDomain: string;
// global['AVFoundationErrorDomain'] = AVFoundationErrorDomain;

// export let AVLinearPCMBitDepthKey: string;
// global['AVLinearPCMBitDepthKey'] = AVLinearPCMBitDepthKey;

// export let AVLinearPCMIsBigEndianKey: string;
// global['AVLinearPCMIsBigEndianKey'] = AVLinearPCMIsBigEndianKey;

// export let AVLinearPCMIsFloatKey: string;
// global['AVLinearPCMIsFloatKey'] = AVLinearPCMIsFloatKey;

// export let AVLinearPCMIsNonInterleaved: string;
// global['AVLinearPCMIsNonInterleaved'] = AVLinearPCMIsNonInterleaved;

// export let AVMovieReferenceRestrictionsKey: string;
// global['AVMovieReferenceRestrictionsKey'] = AVMovieReferenceRestrictionsKey;

// export let AVNumberOfChannelsKey: string;
// global['AVNumberOfChannelsKey'] = AVNumberOfChannelsKey;

// export let AVPlayerItemFailedToPlayToEndTimeErrorKey: string;
// global['AVPlayerItemFailedToPlayToEndTimeErrorKey'] = AVPlayerItemFailedToPlayToEndTimeErrorKey;

// export let AVPlayerItemTrackVideoFieldModeDeinterlaceFields: string;
// global['AVPlayerItemTrackVideoFieldModeDeinterlaceFields'] = AVPlayerItemTrackVideoFieldModeDeinterlaceFields;

// export let AVSampleBufferAudioRendererFlushTimeKey: string;
// global['AVSampleBufferAudioRendererFlushTimeKey'] = AVSampleBufferAudioRendererFlushTimeKey;

// export let AVSampleBufferDisplayLayerFailedToDecodeNotificationErrorKey: string;
// global['AVSampleBufferDisplayLayerFailedToDecodeNotificationErrorKey'] = AVSampleBufferDisplayLayerFailedToDecodeNotificationErrorKey;

// export let AVSampleRateConverterAlgorithmKey: string;
// global['AVSampleRateConverterAlgorithmKey'] = AVSampleRateConverterAlgorithmKey;

// export let AVSampleRateConverterAlgorithm_Mastering: string;
// global['AVSampleRateConverterAlgorithm_Mastering'] = AVSampleRateConverterAlgorithm_Mastering;

// export let AVSampleRateConverterAlgorithm_MinimumPhase: string;
// global['AVSampleRateConverterAlgorithm_MinimumPhase'] = AVSampleRateConverterAlgorithm_MinimumPhase;

// export let AVSampleRateConverterAlgorithm_Normal: string;
// global['AVSampleRateConverterAlgorithm_Normal'] = AVSampleRateConverterAlgorithm_Normal;

// export let AVSampleRateConverterAudioQualityKey: string;
// global['AVSampleRateConverterAudioQualityKey'] = AVSampleRateConverterAudioQualityKey;

// export let AVSampleRateKey: string;
// global['AVSampleRateKey'] = AVSampleRateKey;

// export let AVSpeechSynthesisIPANotationAttribute: string;
// global['AVSpeechSynthesisIPANotationAttribute'] = AVSpeechSynthesisIPANotationAttribute;

// export let AVSpeechSynthesisVoiceIdentifierAlex: string;
// global['AVSpeechSynthesisVoiceIdentifierAlex'] = AVSpeechSynthesisVoiceIdentifierAlex;

// export let AVSpeechUtteranceDefaultSpeechRate: number;
// global['AVSpeechUtteranceDefaultSpeechRate'] = AVSpeechUtteranceDefaultSpeechRate;

// export let AVSpeechUtteranceMaximumSpeechRate: number;
// global['AVSpeechUtteranceMaximumSpeechRate'] = AVSpeechUtteranceMaximumSpeechRate;

// export let AVSpeechUtteranceMinimumSpeechRate: number;
// global['AVSpeechUtteranceMinimumSpeechRate'] = AVSpeechUtteranceMinimumSpeechRate;

// export let AVStreamingKeyDeliveryContentKeyType: string;
// global['AVStreamingKeyDeliveryContentKeyType'] = AVStreamingKeyDeliveryContentKeyType;

// export let AVStreamingKeyDeliveryPersistentContentKeyType: string;
// global['AVStreamingKeyDeliveryPersistentContentKeyType'] = AVStreamingKeyDeliveryPersistentContentKeyType;

// export let AVURLAssetAllowsCellularAccessKey: string;
// global['AVURLAssetAllowsCellularAccessKey'] = AVURLAssetAllowsCellularAccessKey;

// export let AVURLAssetAllowsConstrainedNetworkAccessKey: string;
// global['AVURLAssetAllowsConstrainedNetworkAccessKey'] = AVURLAssetAllowsConstrainedNetworkAccessKey;

// export let AVURLAssetAllowsExpensiveNetworkAccessKey: string;
// global['AVURLAssetAllowsExpensiveNetworkAccessKey'] = AVURLAssetAllowsExpensiveNetworkAccessKey;

// export let AVURLAssetHTTPCookiesKey: string;
// global['AVURLAssetHTTPCookiesKey'] = AVURLAssetHTTPCookiesKey;

// export let AVURLAssetPreferPreciseDurationAndTimingKey: string;
// global['AVURLAssetPreferPreciseDurationAndTimingKey'] = AVURLAssetPreferPreciseDurationAndTimingKey;

// export let AVURLAssetReferenceRestrictionsKey: string;
// global['AVURLAssetReferenceRestrictionsKey'] = AVURLAssetReferenceRestrictionsKey;

// export let AVVideoAllowFrameReorderingKey: string;
// global['AVVideoAllowFrameReorderingKey'] = AVVideoAllowFrameReorderingKey;

// export let AVVideoAllowWideColorKey: string;
// global['AVVideoAllowWideColorKey'] = AVVideoAllowWideColorKey;

// export let AVVideoAverageBitRateKey: string;
// global['AVVideoAverageBitRateKey'] = AVVideoAverageBitRateKey;

// export let AVVideoAverageNonDroppableFrameRateKey: string;
// global['AVVideoAverageNonDroppableFrameRateKey'] = AVVideoAverageNonDroppableFrameRateKey;

// export let AVVideoCleanApertureHeightKey: string;
// global['AVVideoCleanApertureHeightKey'] = AVVideoCleanApertureHeightKey;

// export let AVVideoCleanApertureHorizontalOffsetKey: string;
// global['AVVideoCleanApertureHorizontalOffsetKey'] = AVVideoCleanApertureHorizontalOffsetKey;

// export let AVVideoCleanApertureKey: string;
// global['AVVideoCleanApertureKey'] = AVVideoCleanApertureKey;

// export let AVVideoCleanApertureVerticalOffsetKey: string;
// global['AVVideoCleanApertureVerticalOffsetKey'] = AVVideoCleanApertureVerticalOffsetKey;

// export let AVVideoCleanApertureWidthKey: string;
// global['AVVideoCleanApertureWidthKey'] = AVVideoCleanApertureWidthKey;

// export let AVVideoCodecKey: string;
// global['AVVideoCodecKey'] = AVVideoCodecKey;

// export let AVVideoColorPrimariesKey: string;
// global['AVVideoColorPrimariesKey'] = AVVideoColorPrimariesKey;

// export let AVVideoColorPrimaries_EBU_3213: string;
// global['AVVideoColorPrimaries_EBU_3213'] = AVVideoColorPrimaries_EBU_3213;

// export let AVVideoColorPrimaries_ITU_R_2020: string;
// global['AVVideoColorPrimaries_ITU_R_2020'] = AVVideoColorPrimaries_ITU_R_2020;

// export let AVVideoColorPrimaries_ITU_R_709_2: string;
// global['AVVideoColorPrimaries_ITU_R_709_2'] = AVVideoColorPrimaries_ITU_R_709_2;

// export let AVVideoColorPrimaries_P3_D65: string;
// global['AVVideoColorPrimaries_P3_D65'] = AVVideoColorPrimaries_P3_D65;

// export let AVVideoColorPrimaries_SMPTE_C: string;
// global['AVVideoColorPrimaries_SMPTE_C'] = AVVideoColorPrimaries_SMPTE_C;

// export let AVVideoColorPropertiesKey: string;
// global['AVVideoColorPropertiesKey'] = AVVideoColorPropertiesKey;

// export let AVVideoCompressionPropertiesKey: string;
// global['AVVideoCompressionPropertiesKey'] = AVVideoCompressionPropertiesKey;

// export let AVVideoDecompressionPropertiesKey: string;
// global['AVVideoDecompressionPropertiesKey'] = AVVideoDecompressionPropertiesKey;

// export let AVVideoEncoderSpecificationKey: string;
// global['AVVideoEncoderSpecificationKey'] = AVVideoEncoderSpecificationKey;

// export let AVVideoExpectedSourceFrameRateKey: string;
// global['AVVideoExpectedSourceFrameRateKey'] = AVVideoExpectedSourceFrameRateKey;

// export let AVVideoH264EntropyModeCABAC: string;
// global['AVVideoH264EntropyModeCABAC'] = AVVideoH264EntropyModeCABAC;

// export let AVVideoH264EntropyModeCAVLC: string;
// global['AVVideoH264EntropyModeCAVLC'] = AVVideoH264EntropyModeCAVLC;

// export let AVVideoH264EntropyModeKey: string;
// global['AVVideoH264EntropyModeKey'] = AVVideoH264EntropyModeKey;

// export let AVVideoHeightKey: string;
// global['AVVideoHeightKey'] = AVVideoHeightKey;

// export let AVVideoMaxKeyFrameIntervalDurationKey: string;
// global['AVVideoMaxKeyFrameIntervalDurationKey'] = AVVideoMaxKeyFrameIntervalDurationKey;

// export let AVVideoMaxKeyFrameIntervalKey: string;
// global['AVVideoMaxKeyFrameIntervalKey'] = AVVideoMaxKeyFrameIntervalKey;

// export let AVVideoPixelAspectRatioHorizontalSpacingKey: string;
// global['AVVideoPixelAspectRatioHorizontalSpacingKey'] = AVVideoPixelAspectRatioHorizontalSpacingKey;

// export let AVVideoPixelAspectRatioKey: string;
// global['AVVideoPixelAspectRatioKey'] = AVVideoPixelAspectRatioKey;

// export let AVVideoPixelAspectRatioVerticalSpacingKey: string;
// global['AVVideoPixelAspectRatioVerticalSpacingKey'] = AVVideoPixelAspectRatioVerticalSpacingKey;

// export let AVVideoProfileLevelH264Baseline30: string;
// global['AVVideoProfileLevelH264Baseline30'] = AVVideoProfileLevelH264Baseline30;

// export let AVVideoProfileLevelH264Baseline31: string;
// global['AVVideoProfileLevelH264Baseline31'] = AVVideoProfileLevelH264Baseline31;

// export let AVVideoProfileLevelH264Baseline41: string;
// global['AVVideoProfileLevelH264Baseline41'] = AVVideoProfileLevelH264Baseline41;

// export let AVVideoProfileLevelH264BaselineAutoLevel: string;
// global['AVVideoProfileLevelH264BaselineAutoLevel'] = AVVideoProfileLevelH264BaselineAutoLevel;

// export let AVVideoProfileLevelH264High40: string;
// global['AVVideoProfileLevelH264High40'] = AVVideoProfileLevelH264High40;

// export let AVVideoProfileLevelH264High41: string;
// global['AVVideoProfileLevelH264High41'] = AVVideoProfileLevelH264High41;

// export let AVVideoProfileLevelH264HighAutoLevel: string;
// global['AVVideoProfileLevelH264HighAutoLevel'] = AVVideoProfileLevelH264HighAutoLevel;

// export let AVVideoProfileLevelH264Main30: string;
// global['AVVideoProfileLevelH264Main30'] = AVVideoProfileLevelH264Main30;

// export let AVVideoProfileLevelH264Main31: string;
// global['AVVideoProfileLevelH264Main31'] = AVVideoProfileLevelH264Main31;

// export let AVVideoProfileLevelH264Main32: string;
// global['AVVideoProfileLevelH264Main32'] = AVVideoProfileLevelH264Main32;

// export let AVVideoProfileLevelH264Main41: string;
// global['AVVideoProfileLevelH264Main41'] = AVVideoProfileLevelH264Main41;

// export let AVVideoProfileLevelH264MainAutoLevel: string;
// global['AVVideoProfileLevelH264MainAutoLevel'] = AVVideoProfileLevelH264MainAutoLevel;

// export let AVVideoProfileLevelKey: string;
// global['AVVideoProfileLevelKey'] = AVVideoProfileLevelKey;

// export let AVVideoQualityKey: string;
// global['AVVideoQualityKey'] = AVVideoQualityKey;

// export let AVVideoScalingModeFit: string;
// global['AVVideoScalingModeFit'] = AVVideoScalingModeFit;

// export let AVVideoScalingModeKey: string;
// global['AVVideoScalingModeKey'] = AVVideoScalingModeKey;

// export let AVVideoScalingModeResize: string;
// global['AVVideoScalingModeResize'] = AVVideoScalingModeResize;

// export let AVVideoScalingModeResizeAspect: string;
// global['AVVideoScalingModeResizeAspect'] = AVVideoScalingModeResizeAspect;

// export let AVVideoScalingModeResizeAspectFill: string;
// global['AVVideoScalingModeResizeAspectFill'] = AVVideoScalingModeResizeAspectFill;

// export let AVVideoTransferFunctionKey: string;
// global['AVVideoTransferFunctionKey'] = AVVideoTransferFunctionKey;

// export let AVVideoTransferFunction_ITU_R_2100_HLG: string;
// global['AVVideoTransferFunction_ITU_R_2100_HLG'] = AVVideoTransferFunction_ITU_R_2100_HLG;

// export let AVVideoTransferFunction_ITU_R_709_2: string;
// global['AVVideoTransferFunction_ITU_R_709_2'] = AVVideoTransferFunction_ITU_R_709_2;

// export let AVVideoTransferFunction_SMPTE_240M_1995: string;
// global['AVVideoTransferFunction_SMPTE_240M_1995'] = AVVideoTransferFunction_SMPTE_240M_1995;

// export let AVVideoTransferFunction_SMPTE_ST_2084_PQ: string;
// global['AVVideoTransferFunction_SMPTE_ST_2084_PQ'] = AVVideoTransferFunction_SMPTE_ST_2084_PQ;

// export let AVVideoWidthKey: string;
// global['AVVideoWidthKey'] = AVVideoWidthKey;

// export let AVVideoYCbCrMatrixKey: string;
// global['AVVideoYCbCrMatrixKey'] = AVVideoYCbCrMatrixKey;

// export let AVVideoYCbCrMatrix_ITU_R_2020: string;
// global['AVVideoYCbCrMatrix_ITU_R_2020'] = AVVideoYCbCrMatrix_ITU_R_2020;

// export let AVVideoYCbCrMatrix_ITU_R_601_4: string;
// global['AVVideoYCbCrMatrix_ITU_R_601_4'] = AVVideoYCbCrMatrix_ITU_R_601_4;

// export let AVVideoYCbCrMatrix_ITU_R_709_2: string;
// global['AVVideoYCbCrMatrix_ITU_R_709_2'] = AVVideoYCbCrMatrix_ITU_R_709_2;

// export let AVVideoYCbCrMatrix_SMPTE_240M_1995: string;
// global['AVVideoYCbCrMatrix_SMPTE_240M_1995'] = AVVideoYCbCrMatrix_SMPTE_240M_1995;

// export let NSAllRomanInputSourcesLocaleIdentifier: string;
// global['NSAllRomanInputSourcesLocaleIdentifier'] = NSAllRomanInputSourcesLocaleIdentifier;

// export let NSAnimationTriggerOrderIn: string;
// global['NSAnimationTriggerOrderIn'] = NSAnimationTriggerOrderIn;

// export let NSAnimationTriggerOrderOut: string;
// global['NSAnimationTriggerOrderOut'] = NSAnimationTriggerOrderOut;

// export let NSApp: NSApplication;
// global['NSApp'] = NSApp;

// export let NSBlack: number;
// global['NSBlack'] = NSBlack;

// export let NSDarkGray: number;
// global['NSDarkGray'] = NSDarkGray;

// export let NSDirectionalEdgeInsetsZero: NSDirectionalEdgeInsets;
// global['NSDirectionalEdgeInsetsZero'] = NSDirectionalEdgeInsetsZero;

// export let NSLightGray: number;
// global['NSLightGray'] = NSLightGray;

// export let NSMultipleValuesMarker: any;
// global['NSMultipleValuesMarker'] = NSMultipleValuesMarker;

// export let NSNoSelectionMarker: any;
// global['NSNoSelectionMarker'] = NSNoSelectionMarker;

// export let NSNotApplicableMarker: any;
// global['NSNotApplicableMarker'] = NSNotApplicableMarker;

// export let NSTypeIdentifierAddressText: string;
// global['NSTypeIdentifierAddressText'] = NSTypeIdentifierAddressText;

// export let NSTypeIdentifierDateText: string;
// global['NSTypeIdentifierDateText'] = NSTypeIdentifierDateText;

// export let NSTypeIdentifierPhoneNumberText: string;
// global['NSTypeIdentifierPhoneNumberText'] = NSTypeIdentifierPhoneNumberText;

// export let NSTypeIdentifierTransitInformationText: string;
// global['NSTypeIdentifierTransitInformationText'] = NSTypeIdentifierTransitInformationText;

// export let NSUnderlineByWord: NSUnderlineStyle;
// global['NSUnderlineByWord'] = NSUnderlineByWord;

// export let NSUnderlinePatternDash: NSUnderlineStyle;
// global['NSUnderlinePatternDash'] = NSUnderlinePatternDash;

// export let NSUnderlinePatternDashDot: NSUnderlineStyle;
// global['NSUnderlinePatternDashDot'] = NSUnderlinePatternDashDot;

// export let NSUnderlinePatternDashDotDot: NSUnderlineStyle;
// global['NSUnderlinePatternDashDotDot'] = NSUnderlinePatternDashDotDot;

// export let NSUnderlinePatternDot: NSUnderlineStyle;
// global['NSUnderlinePatternDot'] = NSUnderlinePatternDot;

// export let NSUnderlinePatternSolid: NSUnderlineStyle;
// global['NSUnderlinePatternSolid'] = NSUnderlinePatternSolid;

// export let NSUserActivityDocumentURLKey: string;
// global['NSUserActivityDocumentURLKey'] = NSUserActivityDocumentURLKey;

// export let NSWhite: number;
// global['NSWhite'] = NSWhite;

// export let NSAddedPersistentStoresKey: string;
// global['NSAddedPersistentStoresKey'] = NSAddedPersistentStoresKey;

// export let NSAffectedObjectsErrorKey: string;
// global['NSAffectedObjectsErrorKey'] = NSAffectedObjectsErrorKey;

// export let NSAffectedStoresErrorKey: string;
// global['NSAffectedStoresErrorKey'] = NSAffectedStoresErrorKey;

// export let NSBinaryStoreInsecureDecodingCompatibilityOption: string;
// global['NSBinaryStoreInsecureDecodingCompatibilityOption'] = NSBinaryStoreInsecureDecodingCompatibilityOption;

// export let NSBinaryStoreSecureDecodingClasses: string;
// global['NSBinaryStoreSecureDecodingClasses'] = NSBinaryStoreSecureDecodingClasses;

// export let NSBinaryStoreType: string;
// global['NSBinaryStoreType'] = NSBinaryStoreType;

// export let NSCoreDataCoreSpotlightExporter: string;
// global['NSCoreDataCoreSpotlightExporter'] = NSCoreDataCoreSpotlightExporter;

// export let NSCoreDataVersionNumber: number;
// global['NSCoreDataVersionNumber'] = NSCoreDataVersionNumber;

// export let NSDeletedObjectsKey: string;
// global['NSDeletedObjectsKey'] = NSDeletedObjectsKey;

// export let NSDetailedErrorsKey: string;
// global['NSDetailedErrorsKey'] = NSDetailedErrorsKey;

// export let NSErrorMergePolicy: any;
// global['NSErrorMergePolicy'] = NSErrorMergePolicy;

// export let NSErrorMergePolicy: any;
// global['NSErrorMergePolicy'] = NSErrorMergePolicy;

// export let NSFetchRequestExpressionType: NSExpression.ExpressionType;
// global['NSFetchRequestExpressionType'] = NSFetchRequestExpressionType;

// export let NSIgnorePersistentStoreVersioningOption: string;
// global['NSIgnorePersistentStoreVersioningOption'] = NSIgnorePersistentStoreVersioningOption;

// export let NSInMemoryStoreType: string;
// global['NSInMemoryStoreType'] = NSInMemoryStoreType;

// export let NSInferMappingModelAutomaticallyOption: string;
// global['NSInferMappingModelAutomaticallyOption'] = NSInferMappingModelAutomaticallyOption;

// export let NSInsertedObjectsKey: string;
// global['NSInsertedObjectsKey'] = NSInsertedObjectsKey;

// export let NSInvalidatedAllObjectsKey: string;
// global['NSInvalidatedAllObjectsKey'] = NSInvalidatedAllObjectsKey;

// export let NSInvalidatedObjectsKey: string;
// global['NSInvalidatedObjectsKey'] = NSInvalidatedObjectsKey;

// export let NSManagedObjectContextDidSaveNotification: string;
// global['NSManagedObjectContextDidSaveNotification'] = NSManagedObjectContextDidSaveNotification;

// export let NSManagedObjectContextObjectsDidChangeNotification: string;
// global['NSManagedObjectContextObjectsDidChangeNotification'] = NSManagedObjectContextObjectsDidChangeNotification;

// export let NSManagedObjectContextQueryGenerationKey: string;
// global['NSManagedObjectContextQueryGenerationKey'] = NSManagedObjectContextQueryGenerationKey;

// export let NSManagedObjectContextWillSaveNotification: string;
// global['NSManagedObjectContextWillSaveNotification'] = NSManagedObjectContextWillSaveNotification;

// export let NSMergeByPropertyObjectTrumpMergePolicy: any;
// global['NSMergeByPropertyObjectTrumpMergePolicy'] = NSMergeByPropertyObjectTrumpMergePolicy;

// export let NSMergeByPropertyObjectTrumpMergePolicy: any;
// global['NSMergeByPropertyObjectTrumpMergePolicy'] = NSMergeByPropertyObjectTrumpMergePolicy;

// export let NSMergeByPropertyStoreTrumpMergePolicy: any;
// global['NSMergeByPropertyStoreTrumpMergePolicy'] = NSMergeByPropertyStoreTrumpMergePolicy;

// export let NSMergeByPropertyStoreTrumpMergePolicy: any;
// global['NSMergeByPropertyStoreTrumpMergePolicy'] = NSMergeByPropertyStoreTrumpMergePolicy;

// export let NSMigratePersistentStoresAutomaticallyOption: string;
// global['NSMigratePersistentStoresAutomaticallyOption'] = NSMigratePersistentStoresAutomaticallyOption;

// export let NSMigrationDestinationObjectKey: string;
// global['NSMigrationDestinationObjectKey'] = NSMigrationDestinationObjectKey;

// export let NSMigrationEntityMappingKey: string;
// global['NSMigrationEntityMappingKey'] = NSMigrationEntityMappingKey;

// export let NSMigrationEntityPolicyKey: string;
// global['NSMigrationEntityPolicyKey'] = NSMigrationEntityPolicyKey;

// export let NSMigrationManagerKey: string;
// global['NSMigrationManagerKey'] = NSMigrationManagerKey;

// export let NSMigrationPropertyMappingKey: string;
// global['NSMigrationPropertyMappingKey'] = NSMigrationPropertyMappingKey;

// export let NSMigrationSourceObjectKey: string;
// global['NSMigrationSourceObjectKey'] = NSMigrationSourceObjectKey;

// export let NSOverwriteMergePolicy: any;
// global['NSOverwriteMergePolicy'] = NSOverwriteMergePolicy;

// export let NSOverwriteMergePolicy: any;
// global['NSOverwriteMergePolicy'] = NSOverwriteMergePolicy;

// export let NSPersistentHistoryTokenKey: string;
// global['NSPersistentHistoryTokenKey'] = NSPersistentHistoryTokenKey;

// export let NSPersistentHistoryTrackingKey: string;
// global['NSPersistentHistoryTrackingKey'] = NSPersistentHistoryTrackingKey;

// export let NSPersistentStoreConnectionPoolMaxSizeKey: string;
// global['NSPersistentStoreConnectionPoolMaxSizeKey'] = NSPersistentStoreConnectionPoolMaxSizeKey;

// export let NSPersistentStoreCoordinatorStoresDidChangeNotification: string;
// global['NSPersistentStoreCoordinatorStoresDidChangeNotification'] = NSPersistentStoreCoordinatorStoresDidChangeNotification;

// export let NSPersistentStoreCoordinatorStoresWillChangeNotification: string;
// global['NSPersistentStoreCoordinatorStoresWillChangeNotification'] = NSPersistentStoreCoordinatorStoresWillChangeNotification;

// export let NSPersistentStoreCoordinatorWillRemoveStoreNotification: string;
// global['NSPersistentStoreCoordinatorWillRemoveStoreNotification'] = NSPersistentStoreCoordinatorWillRemoveStoreNotification;

// export let NSPersistentStoreForceDestroyOption: string;
// global['NSPersistentStoreForceDestroyOption'] = NSPersistentStoreForceDestroyOption;

// export let NSPersistentStoreOSCompatibility: string;
// global['NSPersistentStoreOSCompatibility'] = NSPersistentStoreOSCompatibility;

// export let NSPersistentStoreRemoteChangeNotification: string;
// global['NSPersistentStoreRemoteChangeNotification'] = NSPersistentStoreRemoteChangeNotification;

// export let NSPersistentStoreRemoteChangeNotificationPostOptionKey: string;
// global['NSPersistentStoreRemoteChangeNotificationPostOptionKey'] = NSPersistentStoreRemoteChangeNotificationPostOptionKey;

// export let NSPersistentStoreSaveConflictsErrorKey: string;
// global['NSPersistentStoreSaveConflictsErrorKey'] = NSPersistentStoreSaveConflictsErrorKey;

// export let NSPersistentStoreTimeoutOption: string;
// global['NSPersistentStoreTimeoutOption'] = NSPersistentStoreTimeoutOption;

// export let NSPersistentStoreURLKey: string;
// global['NSPersistentStoreURLKey'] = NSPersistentStoreURLKey;

// export let NSReadOnlyPersistentStoreOption: string;
// global['NSReadOnlyPersistentStoreOption'] = NSReadOnlyPersistentStoreOption;

// export let NSRefreshedObjectsKey: string;
// global['NSRefreshedObjectsKey'] = NSRefreshedObjectsKey;

// export let NSRemovedPersistentStoresKey: string;
// global['NSRemovedPersistentStoresKey'] = NSRemovedPersistentStoresKey;

// export let NSRollbackMergePolicy: any;
// global['NSRollbackMergePolicy'] = NSRollbackMergePolicy;

// export let NSRollbackMergePolicy: any;
// global['NSRollbackMergePolicy'] = NSRollbackMergePolicy;

// export let NSSQLiteAnalyzeOption: string;
// global['NSSQLiteAnalyzeOption'] = NSSQLiteAnalyzeOption;

// export let NSSQLiteErrorDomain: string;
// global['NSSQLiteErrorDomain'] = NSSQLiteErrorDomain;

// export let NSSQLiteManualVacuumOption: string;
// global['NSSQLiteManualVacuumOption'] = NSSQLiteManualVacuumOption;

// export let NSSQLitePragmasOption: string;
// global['NSSQLitePragmasOption'] = NSSQLitePragmasOption;

// export let NSSQLiteStoreType: string;
// global['NSSQLiteStoreType'] = NSSQLiteStoreType;

// export let NSStoreModelVersionHashesKey: string;
// global['NSStoreModelVersionHashesKey'] = NSStoreModelVersionHashesKey;

// export let NSStoreModelVersionIdentifiersKey: string;
// global['NSStoreModelVersionIdentifiersKey'] = NSStoreModelVersionIdentifiersKey;

// export let NSStoreTypeKey: string;
// global['NSStoreTypeKey'] = NSStoreTypeKey;

// export let NSStoreUUIDKey: string;
// global['NSStoreUUIDKey'] = NSStoreUUIDKey;

// export let NSUUIDChangedPersistentStoresKey: string;
// global['NSUUIDChangedPersistentStoresKey'] = NSUUIDChangedPersistentStoresKey;

// export let NSUpdatedObjectsKey: string;
// global['NSUpdatedObjectsKey'] = NSUpdatedObjectsKey;

// export let NSValidateXMLStoreOption: string;
// global['NSValidateXMLStoreOption'] = NSValidateXMLStoreOption;

// export let NSValidationKeyErrorKey: string;
// global['NSValidationKeyErrorKey'] = NSValidationKeyErrorKey;

// export let NSValidationObjectErrorKey: string;
// global['NSValidationObjectErrorKey'] = NSValidationObjectErrorKey;

// export let NSValidationPredicateErrorKey: string;
// global['NSValidationPredicateErrorKey'] = NSValidationPredicateErrorKey;

// export let NSValidationValueErrorKey: string;
// global['NSValidationValueErrorKey'] = NSValidationValueErrorKey;

// export let NSXMLStoreType: string;
// global['NSXMLStoreType'] = NSXMLStoreType;

// export let kCFAbsoluteTimeIntervalSince1904: number;
// global['kCFAbsoluteTimeIntervalSince1904'] = kCFAbsoluteTimeIntervalSince1904;

// export let kCFAbsoluteTimeIntervalSince1970: number;
// global['kCFAbsoluteTimeIntervalSince1970'] = kCFAbsoluteTimeIntervalSince1970;

// export let kCFAllocatorDefault: any;
// global['kCFAllocatorDefault'] = kCFAllocatorDefault;

// export let kCFAllocatorMalloc: any;
// global['kCFAllocatorMalloc'] = kCFAllocatorMalloc;

// export let kCFAllocatorMallocZone: any;
// global['kCFAllocatorMallocZone'] = kCFAllocatorMallocZone;

// export let kCFAllocatorNull: any;
// global['kCFAllocatorNull'] = kCFAllocatorNull;

// export let kCFAllocatorSystemDefault: any;
// global['kCFAllocatorSystemDefault'] = kCFAllocatorSystemDefault;

// export let kCFAllocatorUseContext: any;
// global['kCFAllocatorUseContext'] = kCFAllocatorUseContext;

// export let kCFBooleanFalse: number;
// global['kCFBooleanFalse'] = kCFBooleanFalse;

// export let kCFBooleanTrue: number;
// global['kCFBooleanTrue'] = kCFBooleanTrue;

// export let kCFBundleDevelopmentRegionKey: string;
// global['kCFBundleDevelopmentRegionKey'] = kCFBundleDevelopmentRegionKey;

// export let kCFBundleExecutableKey: string;
// global['kCFBundleExecutableKey'] = kCFBundleExecutableKey;

// export let kCFBundleIdentifierKey: string;
// global['kCFBundleIdentifierKey'] = kCFBundleIdentifierKey;

// export let kCFBundleInfoDictionaryVersionKey: string;
// global['kCFBundleInfoDictionaryVersionKey'] = kCFBundleInfoDictionaryVersionKey;

// export let kCFBundleLocalizationsKey: string;
// global['kCFBundleLocalizationsKey'] = kCFBundleLocalizationsKey;

// export let kCFBundleNameKey: string;
// global['kCFBundleNameKey'] = kCFBundleNameKey;

// export let kCFBundleVersionKey: string;
// global['kCFBundleVersionKey'] = kCFBundleVersionKey;

// export let kCFCopyStringBagCallBacks: CFBagCallBacks;
// global['kCFCopyStringBagCallBacks'] = kCFCopyStringBagCallBacks;

// export let kCFCopyStringDictionaryKeyCallBacks: CFDictionaryKeyCallBacks;
// global['kCFCopyStringDictionaryKeyCallBacks'] = kCFCopyStringDictionaryKeyCallBacks;

// export let kCFCopyStringSetCallBacks: CFSetCallBacks;
// global['kCFCopyStringSetCallBacks'] = kCFCopyStringSetCallBacks;

// export let kCFCoreFoundationVersionNumber: number;
// global['kCFCoreFoundationVersionNumber'] = kCFCoreFoundationVersionNumber;

// export let kCFErrorDescriptionKey: string;
// global['kCFErrorDescriptionKey'] = kCFErrorDescriptionKey;

// export let kCFErrorDomainCocoa: any;
// global['kCFErrorDomainCocoa'] = kCFErrorDomainCocoa;

// export let kCFErrorDomainMach: any;
// global['kCFErrorDomainMach'] = kCFErrorDomainMach;

// export let kCFErrorDomainOSStatus: any;
// global['kCFErrorDomainOSStatus'] = kCFErrorDomainOSStatus;

// export let kCFErrorDomainPOSIX: any;
// global['kCFErrorDomainPOSIX'] = kCFErrorDomainPOSIX;

// export let kCFErrorFilePathKey: string;
// global['kCFErrorFilePathKey'] = kCFErrorFilePathKey;

// export let kCFErrorLocalizedDescriptionKey: string;
// global['kCFErrorLocalizedDescriptionKey'] = kCFErrorLocalizedDescriptionKey;

// export let kCFErrorLocalizedFailureKey: string;
// global['kCFErrorLocalizedFailureKey'] = kCFErrorLocalizedFailureKey;

// export let kCFErrorLocalizedFailureReasonKey: string;
// global['kCFErrorLocalizedFailureReasonKey'] = kCFErrorLocalizedFailureReasonKey;

// export let kCFErrorLocalizedRecoverySuggestionKey: string;
// global['kCFErrorLocalizedRecoverySuggestionKey'] = kCFErrorLocalizedRecoverySuggestionKey;

// export let kCFErrorURLKey: string;
// global['kCFErrorURLKey'] = kCFErrorURLKey;

// export let kCFErrorUnderlyingErrorKey: string;
// global['kCFErrorUnderlyingErrorKey'] = kCFErrorUnderlyingErrorKey;

// export let kCFNotFound: number;
// global['kCFNotFound'] = kCFNotFound;

// export let kCFNull: NSNull;
// global['kCFNull'] = kCFNull;

// export let kCFNumberNaN: number;
// global['kCFNumberNaN'] = kCFNumberNaN;

// export let kCFNumberNegativeInfinity: number;
// global['kCFNumberNegativeInfinity'] = kCFNumberNegativeInfinity;

// export let kCFNumberPositiveInfinity: number;
// global['kCFNumberPositiveInfinity'] = kCFNumberPositiveInfinity;

// export let kCFPlugInDynamicRegisterFunctionKey: string;
// global['kCFPlugInDynamicRegisterFunctionKey'] = kCFPlugInDynamicRegisterFunctionKey;

// export let kCFPlugInDynamicRegistrationKey: string;
// global['kCFPlugInDynamicRegistrationKey'] = kCFPlugInDynamicRegistrationKey;

// export let kCFPlugInFactoriesKey: string;
// global['kCFPlugInFactoriesKey'] = kCFPlugInFactoriesKey;

// export let kCFPlugInTypesKey: string;
// global['kCFPlugInTypesKey'] = kCFPlugInTypesKey;

// export let kCFPlugInUnloadFunctionKey: string;
// global['kCFPlugInUnloadFunctionKey'] = kCFPlugInUnloadFunctionKey;

// export let kCFPreferencesAnyApplication: string;
// global['kCFPreferencesAnyApplication'] = kCFPreferencesAnyApplication;

// export let kCFPreferencesAnyHost: string;
// global['kCFPreferencesAnyHost'] = kCFPreferencesAnyHost;

// export let kCFPreferencesAnyUser: string;
// global['kCFPreferencesAnyUser'] = kCFPreferencesAnyUser;

// export let kCFPreferencesCurrentApplication: string;
// global['kCFPreferencesCurrentApplication'] = kCFPreferencesCurrentApplication;

// export let kCFPreferencesCurrentHost: string;
// global['kCFPreferencesCurrentHost'] = kCFPreferencesCurrentHost;

// export let kCFPreferencesCurrentUser: string;
// global['kCFPreferencesCurrentUser'] = kCFPreferencesCurrentUser;

// export let kCFSocketCommandKey: string;
// global['kCFSocketCommandKey'] = kCFSocketCommandKey;

// export let kCFSocketErrorKey: string;
// global['kCFSocketErrorKey'] = kCFSocketErrorKey;

// export let kCFSocketNameKey: string;
// global['kCFSocketNameKey'] = kCFSocketNameKey;

// export let kCFSocketRegisterCommand: string;
// global['kCFSocketRegisterCommand'] = kCFSocketRegisterCommand;

// export let kCFSocketResultKey: string;
// global['kCFSocketResultKey'] = kCFSocketResultKey;

// export let kCFSocketRetrieveCommand: string;
// global['kCFSocketRetrieveCommand'] = kCFSocketRetrieveCommand;

// export let kCFSocketValueKey: string;
// global['kCFSocketValueKey'] = kCFSocketValueKey;

// export let kCFStreamErrorDomainSOCKS: number;
// global['kCFStreamErrorDomainSOCKS'] = kCFStreamErrorDomainSOCKS;

// export let kCFStreamErrorDomainSSL: number;
// global['kCFStreamErrorDomainSSL'] = kCFStreamErrorDomainSSL;

// export let kCFStreamPropertySOCKSPassword: string;
// global['kCFStreamPropertySOCKSPassword'] = kCFStreamPropertySOCKSPassword;

// export let kCFStreamPropertySOCKSProxy: string;
// global['kCFStreamPropertySOCKSProxy'] = kCFStreamPropertySOCKSProxy;

// export let kCFStreamPropertySOCKSProxyHost: string;
// global['kCFStreamPropertySOCKSProxyHost'] = kCFStreamPropertySOCKSProxyHost;

// export let kCFStreamPropertySOCKSProxyPort: string;
// global['kCFStreamPropertySOCKSProxyPort'] = kCFStreamPropertySOCKSProxyPort;

// export let kCFStreamPropertySOCKSUser: string;
// global['kCFStreamPropertySOCKSUser'] = kCFStreamPropertySOCKSUser;

// export let kCFStreamPropertySOCKSVersion: string;
// global['kCFStreamPropertySOCKSVersion'] = kCFStreamPropertySOCKSVersion;

// export let kCFStreamPropertyShouldCloseNativeSocket: string;
// global['kCFStreamPropertyShouldCloseNativeSocket'] = kCFStreamPropertyShouldCloseNativeSocket;

// export let kCFStreamPropertySocketSecurityLevel: string;
// global['kCFStreamPropertySocketSecurityLevel'] = kCFStreamPropertySocketSecurityLevel;

// export let kCFStreamSocketSOCKSVersion4: string;
// global['kCFStreamSocketSOCKSVersion4'] = kCFStreamSocketSOCKSVersion4;

// export let kCFStreamSocketSOCKSVersion5: string;
// global['kCFStreamSocketSOCKSVersion5'] = kCFStreamSocketSOCKSVersion5;

// export let kCFStreamSocketSecurityLevelNegotiatedSSL: string;
// global['kCFStreamSocketSecurityLevelNegotiatedSSL'] = kCFStreamSocketSecurityLevelNegotiatedSSL;

// export let kCFStreamSocketSecurityLevelNone: string;
// global['kCFStreamSocketSecurityLevelNone'] = kCFStreamSocketSecurityLevelNone;

// export let kCFStreamSocketSecurityLevelTLSv1: string;
// global['kCFStreamSocketSecurityLevelTLSv1'] = kCFStreamSocketSecurityLevelTLSv1;

// export let kCFStringBinaryHeapCallBacks: CFBinaryHeapCallBacks;
// global['kCFStringBinaryHeapCallBacks'] = kCFStringBinaryHeapCallBacks;

// export let kCFStringTransformFullwidthHalfwidth: string;
// global['kCFStringTransformFullwidthHalfwidth'] = kCFStringTransformFullwidthHalfwidth;

// export let kCFStringTransformHiraganaKatakana: string;
// global['kCFStringTransformHiraganaKatakana'] = kCFStringTransformHiraganaKatakana;

// export let kCFStringTransformLatinArabic: string;
// global['kCFStringTransformLatinArabic'] = kCFStringTransformLatinArabic;

// export let kCFStringTransformLatinCyrillic: string;
// global['kCFStringTransformLatinCyrillic'] = kCFStringTransformLatinCyrillic;

// export let kCFStringTransformLatinGreek: string;
// global['kCFStringTransformLatinGreek'] = kCFStringTransformLatinGreek;

// export let kCFStringTransformLatinHangul: string;
// global['kCFStringTransformLatinHangul'] = kCFStringTransformLatinHangul;

// export let kCFStringTransformLatinHebrew: string;
// global['kCFStringTransformLatinHebrew'] = kCFStringTransformLatinHebrew;

// export let kCFStringTransformLatinHiragana: string;
// global['kCFStringTransformLatinHiragana'] = kCFStringTransformLatinHiragana;

// export let kCFStringTransformLatinKatakana: string;
// global['kCFStringTransformLatinKatakana'] = kCFStringTransformLatinKatakana;

// export let kCFStringTransformLatinThai: string;
// global['kCFStringTransformLatinThai'] = kCFStringTransformLatinThai;

// export let kCFStringTransformMandarinLatin: string;
// global['kCFStringTransformMandarinLatin'] = kCFStringTransformMandarinLatin;

// export let kCFStringTransformStripCombiningMarks: string;
// global['kCFStringTransformStripCombiningMarks'] = kCFStringTransformStripCombiningMarks;

// export let kCFStringTransformStripDiacritics: string;
// global['kCFStringTransformStripDiacritics'] = kCFStringTransformStripDiacritics;

// export let kCFStringTransformToLatin: string;
// global['kCFStringTransformToLatin'] = kCFStringTransformToLatin;

// export let kCFStringTransformToUnicodeName: string;
// global['kCFStringTransformToUnicodeName'] = kCFStringTransformToUnicodeName;

// export let kCFStringTransformToXMLHex: string;
// global['kCFStringTransformToXMLHex'] = kCFStringTransformToXMLHex;

// export let kCFTypeArrayCallBacks: CFArrayCallBacks;
// global['kCFTypeArrayCallBacks'] = kCFTypeArrayCallBacks;

// export let kCFTypeBagCallBacks: CFBagCallBacks;
// global['kCFTypeBagCallBacks'] = kCFTypeBagCallBacks;

// export let kCFTypeDictionaryKeyCallBacks: CFDictionaryKeyCallBacks;
// global['kCFTypeDictionaryKeyCallBacks'] = kCFTypeDictionaryKeyCallBacks;

// export let kCFTypeDictionaryValueCallBacks: CFDictionaryValueCallBacks;
// global['kCFTypeDictionaryValueCallBacks'] = kCFTypeDictionaryValueCallBacks;

// export let kCFTypeSetCallBacks: CFSetCallBacks;
// global['kCFTypeSetCallBacks'] = kCFTypeSetCallBacks;

// export let kCFURLAddedToDirectoryDateKey: string;
// global['kCFURLAddedToDirectoryDateKey'] = kCFURLAddedToDirectoryDateKey;

// export let kCFURLApplicationIsScriptableKey: string;
// global['kCFURLApplicationIsScriptableKey'] = kCFURLApplicationIsScriptableKey;

// export let kCFURLAttributeModificationDateKey: string;
// global['kCFURLAttributeModificationDateKey'] = kCFURLAttributeModificationDateKey;

// export let kCFURLCanonicalPathKey: string;
// global['kCFURLCanonicalPathKey'] = kCFURLCanonicalPathKey;

// export let kCFURLContentAccessDateKey: string;
// global['kCFURLContentAccessDateKey'] = kCFURLContentAccessDateKey;

// export let kCFURLContentModificationDateKey: string;
// global['kCFURLContentModificationDateKey'] = kCFURLContentModificationDateKey;

// export let kCFURLCreationDateKey: string;
// global['kCFURLCreationDateKey'] = kCFURLCreationDateKey;

// export let kCFURLDocumentIdentifierKey: string;
// global['kCFURLDocumentIdentifierKey'] = kCFURLDocumentIdentifierKey;

// export let kCFURLFileAllocatedSizeKey: string;
// global['kCFURLFileAllocatedSizeKey'] = kCFURLFileAllocatedSizeKey;

// export let kCFURLFileResourceIdentifierKey: string;
// global['kCFURLFileResourceIdentifierKey'] = kCFURLFileResourceIdentifierKey;

// export let kCFURLFileResourceTypeBlockSpecial: string;
// global['kCFURLFileResourceTypeBlockSpecial'] = kCFURLFileResourceTypeBlockSpecial;

// export let kCFURLFileResourceTypeCharacterSpecial: string;
// global['kCFURLFileResourceTypeCharacterSpecial'] = kCFURLFileResourceTypeCharacterSpecial;

// export let kCFURLFileResourceTypeDirectory: string;
// global['kCFURLFileResourceTypeDirectory'] = kCFURLFileResourceTypeDirectory;

// export let kCFURLFileResourceTypeKey: string;
// global['kCFURLFileResourceTypeKey'] = kCFURLFileResourceTypeKey;

// export let kCFURLFileResourceTypeNamedPipe: string;
// global['kCFURLFileResourceTypeNamedPipe'] = kCFURLFileResourceTypeNamedPipe;

// export let kCFURLFileResourceTypeRegular: string;
// global['kCFURLFileResourceTypeRegular'] = kCFURLFileResourceTypeRegular;

// export let kCFURLFileResourceTypeSocket: string;
// global['kCFURLFileResourceTypeSocket'] = kCFURLFileResourceTypeSocket;

// export let kCFURLFileResourceTypeSymbolicLink: string;
// global['kCFURLFileResourceTypeSymbolicLink'] = kCFURLFileResourceTypeSymbolicLink;

// export let kCFURLFileResourceTypeUnknown: string;
// global['kCFURLFileResourceTypeUnknown'] = kCFURLFileResourceTypeUnknown;

// export let kCFURLFileSecurityKey: string;
// global['kCFURLFileSecurityKey'] = kCFURLFileSecurityKey;

// export let kCFURLFileSizeKey: string;
// global['kCFURLFileSizeKey'] = kCFURLFileSizeKey;

// export let kCFURLGenerationIdentifierKey: string;
// global['kCFURLGenerationIdentifierKey'] = kCFURLGenerationIdentifierKey;

// export let kCFURLHasHiddenExtensionKey: string;
// global['kCFURLHasHiddenExtensionKey'] = kCFURLHasHiddenExtensionKey;

// export let kCFURLIsAliasFileKey: string;
// global['kCFURLIsAliasFileKey'] = kCFURLIsAliasFileKey;

// export let kCFURLIsApplicationKey: string;
// global['kCFURLIsApplicationKey'] = kCFURLIsApplicationKey;

// export let kCFURLIsDirectoryKey: string;
// global['kCFURLIsDirectoryKey'] = kCFURLIsDirectoryKey;

// export let kCFURLIsExcludedFromBackupKey: string;
// global['kCFURLIsExcludedFromBackupKey'] = kCFURLIsExcludedFromBackupKey;

// export let kCFURLIsExecutableKey: string;
// global['kCFURLIsExecutableKey'] = kCFURLIsExecutableKey;

// export let kCFURLIsHiddenKey: string;
// global['kCFURLIsHiddenKey'] = kCFURLIsHiddenKey;

// export let kCFURLIsMountTriggerKey: string;
// global['kCFURLIsMountTriggerKey'] = kCFURLIsMountTriggerKey;

// export let kCFURLIsPackageKey: string;
// global['kCFURLIsPackageKey'] = kCFURLIsPackageKey;

// export let kCFURLIsReadableKey: string;
// global['kCFURLIsReadableKey'] = kCFURLIsReadableKey;

// export let kCFURLIsRegularFileKey: string;
// global['kCFURLIsRegularFileKey'] = kCFURLIsRegularFileKey;

// export let kCFURLIsSymbolicLinkKey: string;
// global['kCFURLIsSymbolicLinkKey'] = kCFURLIsSymbolicLinkKey;

// export let kCFURLIsSystemImmutableKey: string;
// global['kCFURLIsSystemImmutableKey'] = kCFURLIsSystemImmutableKey;

// export let kCFURLIsUbiquitousItemKey: string;
// global['kCFURLIsUbiquitousItemKey'] = kCFURLIsUbiquitousItemKey;

// export let kCFURLIsUserImmutableKey: string;
// global['kCFURLIsUserImmutableKey'] = kCFURLIsUserImmutableKey;

// export let kCFURLIsVolumeKey: string;
// global['kCFURLIsVolumeKey'] = kCFURLIsVolumeKey;

// export let kCFURLIsWritableKey: string;
// global['kCFURLIsWritableKey'] = kCFURLIsWritableKey;

// export let kCFURLKeysOfUnsetValuesKey: string;
// global['kCFURLKeysOfUnsetValuesKey'] = kCFURLKeysOfUnsetValuesKey;

// export let kCFURLLabelNumberKey: string;
// global['kCFURLLabelNumberKey'] = kCFURLLabelNumberKey;

// export let kCFURLLinkCountKey: string;
// global['kCFURLLinkCountKey'] = kCFURLLinkCountKey;

// export let kCFURLLocalizedLabelKey: string;
// global['kCFURLLocalizedLabelKey'] = kCFURLLocalizedLabelKey;

// export let kCFURLLocalizedNameKey: string;
// global['kCFURLLocalizedNameKey'] = kCFURLLocalizedNameKey;

// export let kCFURLLocalizedTypeDescriptionKey: string;
// global['kCFURLLocalizedTypeDescriptionKey'] = kCFURLLocalizedTypeDescriptionKey;

// export let kCFURLNameKey: string;
// global['kCFURLNameKey'] = kCFURLNameKey;

// export let kCFURLParentDirectoryURLKey: string;
// global['kCFURLParentDirectoryURLKey'] = kCFURLParentDirectoryURLKey;

// export let kCFURLPathKey: string;
// global['kCFURLPathKey'] = kCFURLPathKey;

// export let kCFURLPreferredIOBlockSizeKey: string;
// global['kCFURLPreferredIOBlockSizeKey'] = kCFURLPreferredIOBlockSizeKey;

// export let kCFURLQuarantinePropertiesKey: string;
// global['kCFURLQuarantinePropertiesKey'] = kCFURLQuarantinePropertiesKey;

// export let kCFURLTagNamesKey: string;
// global['kCFURLTagNamesKey'] = kCFURLTagNamesKey;

// export let kCFURLTotalFileAllocatedSizeKey: string;
// global['kCFURLTotalFileAllocatedSizeKey'] = kCFURLTotalFileAllocatedSizeKey;

// export let kCFURLTotalFileSizeKey: string;
// global['kCFURLTotalFileSizeKey'] = kCFURLTotalFileSizeKey;

// export let kCFURLTypeIdentifierKey: string;
// global['kCFURLTypeIdentifierKey'] = kCFURLTypeIdentifierKey;

// export let kCFURLUbiquitousItemDownloadingErrorKey: string;
// global['kCFURLUbiquitousItemDownloadingErrorKey'] = kCFURLUbiquitousItemDownloadingErrorKey;

// export let kCFURLUbiquitousItemDownloadingStatusCurrent: string;
// global['kCFURLUbiquitousItemDownloadingStatusCurrent'] = kCFURLUbiquitousItemDownloadingStatusCurrent;

// export let kCFURLUbiquitousItemDownloadingStatusDownloaded: string;
// global['kCFURLUbiquitousItemDownloadingStatusDownloaded'] = kCFURLUbiquitousItemDownloadingStatusDownloaded;

// export let kCFURLUbiquitousItemDownloadingStatusKey: string;
// global['kCFURLUbiquitousItemDownloadingStatusKey'] = kCFURLUbiquitousItemDownloadingStatusKey;

// export let kCFURLUbiquitousItemDownloadingStatusNotDownloaded: string;
// global['kCFURLUbiquitousItemDownloadingStatusNotDownloaded'] = kCFURLUbiquitousItemDownloadingStatusNotDownloaded;

// export let kCFURLUbiquitousItemHasUnresolvedConflictsKey: string;
// global['kCFURLUbiquitousItemHasUnresolvedConflictsKey'] = kCFURLUbiquitousItemHasUnresolvedConflictsKey;

// export let kCFURLUbiquitousItemIsDownloadingKey: string;
// global['kCFURLUbiquitousItemIsDownloadingKey'] = kCFURLUbiquitousItemIsDownloadingKey;

// export let kCFURLUbiquitousItemIsUploadedKey: string;
// global['kCFURLUbiquitousItemIsUploadedKey'] = kCFURLUbiquitousItemIsUploadedKey;

// export let kCFURLUbiquitousItemIsUploadingKey: string;
// global['kCFURLUbiquitousItemIsUploadingKey'] = kCFURLUbiquitousItemIsUploadingKey;

// export let kCFURLUbiquitousItemUploadingErrorKey: string;
// global['kCFURLUbiquitousItemUploadingErrorKey'] = kCFURLUbiquitousItemUploadingErrorKey;

// export let kCFURLVolumeAvailableCapacityForImportantUsageKey: string;
// global['kCFURLVolumeAvailableCapacityForImportantUsageKey'] = kCFURLVolumeAvailableCapacityForImportantUsageKey;

// export let kCFURLVolumeAvailableCapacityForOpportunisticUsageKey: string;
// global['kCFURLVolumeAvailableCapacityForOpportunisticUsageKey'] = kCFURLVolumeAvailableCapacityForOpportunisticUsageKey;

// export let kCFURLVolumeAvailableCapacityKey: string;
// global['kCFURLVolumeAvailableCapacityKey'] = kCFURLVolumeAvailableCapacityKey;

// export let kCFURLVolumeCreationDateKey: string;
// global['kCFURLVolumeCreationDateKey'] = kCFURLVolumeCreationDateKey;

// export let kCFURLVolumeIdentifierKey: string;
// global['kCFURLVolumeIdentifierKey'] = kCFURLVolumeIdentifierKey;

// export let kCFURLVolumeIsAutomountedKey: string;
// global['kCFURLVolumeIsAutomountedKey'] = kCFURLVolumeIsAutomountedKey;

// export let kCFURLVolumeIsBrowsableKey: string;
// global['kCFURLVolumeIsBrowsableKey'] = kCFURLVolumeIsBrowsableKey;

// export let kCFURLVolumeIsEjectableKey: string;
// global['kCFURLVolumeIsEjectableKey'] = kCFURLVolumeIsEjectableKey;

// export let kCFURLVolumeIsEncryptedKey: string;
// global['kCFURLVolumeIsEncryptedKey'] = kCFURLVolumeIsEncryptedKey;

// export let kCFURLVolumeIsInternalKey: string;
// global['kCFURLVolumeIsInternalKey'] = kCFURLVolumeIsInternalKey;

// export let kCFURLVolumeIsJournalingKey: string;
// global['kCFURLVolumeIsJournalingKey'] = kCFURLVolumeIsJournalingKey;

// export let kCFURLVolumeIsLocalKey: string;
// global['kCFURLVolumeIsLocalKey'] = kCFURLVolumeIsLocalKey;

// export let kCFURLVolumeIsReadOnlyKey: string;
// global['kCFURLVolumeIsReadOnlyKey'] = kCFURLVolumeIsReadOnlyKey;

// export let kCFURLVolumeIsRemovableKey: string;
// global['kCFURLVolumeIsRemovableKey'] = kCFURLVolumeIsRemovableKey;

// export let kCFURLVolumeIsRootFileSystemKey: string;
// global['kCFURLVolumeIsRootFileSystemKey'] = kCFURLVolumeIsRootFileSystemKey;

// export let kCFURLVolumeLocalizedFormatDescriptionKey: string;
// global['kCFURLVolumeLocalizedFormatDescriptionKey'] = kCFURLVolumeLocalizedFormatDescriptionKey;

// export let kCFURLVolumeLocalizedNameKey: string;
// global['kCFURLVolumeLocalizedNameKey'] = kCFURLVolumeLocalizedNameKey;

// export let kCFURLVolumeMaximumFileSizeKey: string;
// global['kCFURLVolumeMaximumFileSizeKey'] = kCFURLVolumeMaximumFileSizeKey;

// export let kCFURLVolumeNameKey: string;
// global['kCFURLVolumeNameKey'] = kCFURLVolumeNameKey;

// export let kCFURLVolumeResourceCountKey: string;
// global['kCFURLVolumeResourceCountKey'] = kCFURLVolumeResourceCountKey;

// export let kCFURLVolumeSupportsAccessPermissionsKey: string;
// global['kCFURLVolumeSupportsAccessPermissionsKey'] = kCFURLVolumeSupportsAccessPermissionsKey;

// export let kCFURLVolumeSupportsAdvisoryFileLockingKey: string;
// global['kCFURLVolumeSupportsAdvisoryFileLockingKey'] = kCFURLVolumeSupportsAdvisoryFileLockingKey;

// export let kCFURLVolumeSupportsCasePreservedNamesKey: string;
// global['kCFURLVolumeSupportsCasePreservedNamesKey'] = kCFURLVolumeSupportsCasePreservedNamesKey;

// export let kCFURLVolumeSupportsCaseSensitiveNamesKey: string;
// global['kCFURLVolumeSupportsCaseSensitiveNamesKey'] = kCFURLVolumeSupportsCaseSensitiveNamesKey;

// export let kCFURLVolumeSupportsCompressionKey: string;
// global['kCFURLVolumeSupportsCompressionKey'] = kCFURLVolumeSupportsCompressionKey;

// export let kCFURLVolumeSupportsExclusiveRenamingKey: string;
// global['kCFURLVolumeSupportsExclusiveRenamingKey'] = kCFURLVolumeSupportsExclusiveRenamingKey;

// export let kCFURLVolumeSupportsExtendedSecurityKey: string;
// global['kCFURLVolumeSupportsExtendedSecurityKey'] = kCFURLVolumeSupportsExtendedSecurityKey;

// export let kCFURLVolumeSupportsFileCloningKey: string;
// global['kCFURLVolumeSupportsFileCloningKey'] = kCFURLVolumeSupportsFileCloningKey;

// export let kCFURLVolumeSupportsHardLinksKey: string;
// global['kCFURLVolumeSupportsHardLinksKey'] = kCFURLVolumeSupportsHardLinksKey;

// export let kCFURLVolumeSupportsImmutableFilesKey: string;
// global['kCFURLVolumeSupportsImmutableFilesKey'] = kCFURLVolumeSupportsImmutableFilesKey;

// export let kCFURLVolumeSupportsJournalingKey: string;
// global['kCFURLVolumeSupportsJournalingKey'] = kCFURLVolumeSupportsJournalingKey;

// export let kCFURLVolumeSupportsPersistentIDsKey: string;
// global['kCFURLVolumeSupportsPersistentIDsKey'] = kCFURLVolumeSupportsPersistentIDsKey;

// export let kCFURLVolumeSupportsRenamingKey: string;
// global['kCFURLVolumeSupportsRenamingKey'] = kCFURLVolumeSupportsRenamingKey;

// export let kCFURLVolumeSupportsRootDirectoryDatesKey: string;
// global['kCFURLVolumeSupportsRootDirectoryDatesKey'] = kCFURLVolumeSupportsRootDirectoryDatesKey;

// export let kCFURLVolumeSupportsSparseFilesKey: string;
// global['kCFURLVolumeSupportsSparseFilesKey'] = kCFURLVolumeSupportsSparseFilesKey;

// export let kCFURLVolumeSupportsSwapRenamingKey: string;
// global['kCFURLVolumeSupportsSwapRenamingKey'] = kCFURLVolumeSupportsSwapRenamingKey;

// export let kCFURLVolumeSupportsSymbolicLinksKey: string;
// global['kCFURLVolumeSupportsSymbolicLinksKey'] = kCFURLVolumeSupportsSymbolicLinksKey;

// export let kCFURLVolumeSupportsVolumeSizesKey: string;
// global['kCFURLVolumeSupportsVolumeSizesKey'] = kCFURLVolumeSupportsVolumeSizesKey;

// export let kCFURLVolumeSupportsZeroRunsKey: string;
// global['kCFURLVolumeSupportsZeroRunsKey'] = kCFURLVolumeSupportsZeroRunsKey;

// export let kCFURLVolumeTotalCapacityKey: string;
// global['kCFURLVolumeTotalCapacityKey'] = kCFURLVolumeTotalCapacityKey;

// export let kCFURLVolumeURLForRemountingKey: string;
// global['kCFURLVolumeURLForRemountingKey'] = kCFURLVolumeURLForRemountingKey;

// export let kCFURLVolumeURLKey: string;
// global['kCFURLVolumeURLKey'] = kCFURLVolumeURLKey;

// export let kCFURLVolumeUUIDStringKey: string;
// global['kCFURLVolumeUUIDStringKey'] = kCFURLVolumeUUIDStringKey;

// export let kCFUserNotificationAlertHeaderKey: string;
// global['kCFUserNotificationAlertHeaderKey'] = kCFUserNotificationAlertHeaderKey;

// export let kCFUserNotificationAlertMessageKey: string;
// global['kCFUserNotificationAlertMessageKey'] = kCFUserNotificationAlertMessageKey;

// export let kCFUserNotificationAlertTopMostKey: string;
// global['kCFUserNotificationAlertTopMostKey'] = kCFUserNotificationAlertTopMostKey;

// export let kCFUserNotificationAlternateButtonTitleKey: string;
// global['kCFUserNotificationAlternateButtonTitleKey'] = kCFUserNotificationAlternateButtonTitleKey;

// export let kCFUserNotificationCheckBoxTitlesKey: string;
// global['kCFUserNotificationCheckBoxTitlesKey'] = kCFUserNotificationCheckBoxTitlesKey;

// export let kCFUserNotificationDefaultButtonTitleKey: string;
// global['kCFUserNotificationDefaultButtonTitleKey'] = kCFUserNotificationDefaultButtonTitleKey;

// export let kCFUserNotificationIconURLKey: string;
// global['kCFUserNotificationIconURLKey'] = kCFUserNotificationIconURLKey;

// export let kCFUserNotificationKeyboardTypesKey: string;
// global['kCFUserNotificationKeyboardTypesKey'] = kCFUserNotificationKeyboardTypesKey;

// export let kCFUserNotificationLocalizationURLKey: string;
// global['kCFUserNotificationLocalizationURLKey'] = kCFUserNotificationLocalizationURLKey;

// export let kCFUserNotificationOtherButtonTitleKey: string;
// global['kCFUserNotificationOtherButtonTitleKey'] = kCFUserNotificationOtherButtonTitleKey;

// export let kCFUserNotificationPopUpSelectionKey: string;
// global['kCFUserNotificationPopUpSelectionKey'] = kCFUserNotificationPopUpSelectionKey;

// export let kCFUserNotificationPopUpTitlesKey: string;
// global['kCFUserNotificationPopUpTitlesKey'] = kCFUserNotificationPopUpTitlesKey;

// export let kCFUserNotificationProgressIndicatorValueKey: string;
// global['kCFUserNotificationProgressIndicatorValueKey'] = kCFUserNotificationProgressIndicatorValueKey;

// export let kCFUserNotificationSoundURLKey: string;
// global['kCFUserNotificationSoundURLKey'] = kCFUserNotificationSoundURLKey;

// export let kCFUserNotificationTextFieldTitlesKey: string;
// global['kCFUserNotificationTextFieldTitlesKey'] = kCFUserNotificationTextFieldTitlesKey;

// export let kCFUserNotificationTextFieldValuesKey: string;
// global['kCFUserNotificationTextFieldValuesKey'] = kCFUserNotificationTextFieldValuesKey;

// export let kCFXMLTreeErrorDescription: string;
// global['kCFXMLTreeErrorDescription'] = kCFXMLTreeErrorDescription;

// export let kCFXMLTreeErrorLineNumber: string;
// global['kCFXMLTreeErrorLineNumber'] = kCFXMLTreeErrorLineNumber;

// export let kCFXMLTreeErrorLocation: string;
// global['kCFXMLTreeErrorLocation'] = kCFXMLTreeErrorLocation;

// export let kCFXMLTreeErrorStatusCode: string;
// global['kCFXMLTreeErrorStatusCode'] = kCFXMLTreeErrorStatusCode;

// export let kCGDisplayShowDuplicateLowResolutionModes: string;
// global['kCGDisplayShowDuplicateLowResolutionModes'] = kCGDisplayShowDuplicateLowResolutionModes;

// export let kCGFontIndexInvalid: number;
// global['kCGFontIndexInvalid'] = kCGFontIndexInvalid;

// export let kCGFontIndexMax: number;
// global['kCGFontIndexMax'] = kCGFontIndexMax;

// export let kCGGlyphMax: number;
// global['kCGGlyphMax'] = kCGGlyphMax;

// export let kCGPDFContextAccessPermissions: string;
// global['kCGPDFContextAccessPermissions'] = kCGPDFContextAccessPermissions;

// export let kCGPDFContextAllowsCopying: string;
// global['kCGPDFContextAllowsCopying'] = kCGPDFContextAllowsCopying;

// export let kCGPDFContextAllowsPrinting: string;
// global['kCGPDFContextAllowsPrinting'] = kCGPDFContextAllowsPrinting;

// export let kCGPDFContextArtBox: string;
// global['kCGPDFContextArtBox'] = kCGPDFContextArtBox;

// export let kCGPDFContextAuthor: string;
// global['kCGPDFContextAuthor'] = kCGPDFContextAuthor;

// export let kCGPDFContextBleedBox: string;
// global['kCGPDFContextBleedBox'] = kCGPDFContextBleedBox;

// export let kCGPDFContextCreator: string;
// global['kCGPDFContextCreator'] = kCGPDFContextCreator;

// export let kCGPDFContextCropBox: string;
// global['kCGPDFContextCropBox'] = kCGPDFContextCropBox;

// export let kCGPDFContextEncryptionKeyLength: string;
// global['kCGPDFContextEncryptionKeyLength'] = kCGPDFContextEncryptionKeyLength;

// export let kCGPDFContextKeywords: string;
// global['kCGPDFContextKeywords'] = kCGPDFContextKeywords;

// export let kCGPDFContextMediaBox: string;
// global['kCGPDFContextMediaBox'] = kCGPDFContextMediaBox;

// export let kCGPDFContextOutputIntent: string;
// global['kCGPDFContextOutputIntent'] = kCGPDFContextOutputIntent;

// export let kCGPDFContextOutputIntents: string;
// global['kCGPDFContextOutputIntents'] = kCGPDFContextOutputIntents;

// export let kCGPDFContextOwnerPassword: string;
// global['kCGPDFContextOwnerPassword'] = kCGPDFContextOwnerPassword;

// export let kCGPDFContextSubject: string;
// global['kCGPDFContextSubject'] = kCGPDFContextSubject;

// export let kCGPDFContextTitle: string;
// global['kCGPDFContextTitle'] = kCGPDFContextTitle;

// export let kCGPDFContextTrimBox: string;
// global['kCGPDFContextTrimBox'] = kCGPDFContextTrimBox;

// export let kCGPDFContextUserPassword: string;
// global['kCGPDFContextUserPassword'] = kCGPDFContextUserPassword;

// export let kCGPDFOutlineChildren: string;
// global['kCGPDFOutlineChildren'] = kCGPDFOutlineChildren;

// export let kCGPDFOutlineDestination: string;
// global['kCGPDFOutlineDestination'] = kCGPDFOutlineDestination;

// export let kCGPDFOutlineDestinationRect: string;
// global['kCGPDFOutlineDestinationRect'] = kCGPDFOutlineDestinationRect;

// export let kCGPDFOutlineTitle: string;
// global['kCGPDFOutlineTitle'] = kCGPDFOutlineTitle;

// export let kCGPDFXDestinationOutputProfile: string;
// global['kCGPDFXDestinationOutputProfile'] = kCGPDFXDestinationOutputProfile;

// export let kCGPDFXInfo: string;
// global['kCGPDFXInfo'] = kCGPDFXInfo;

// export let kCGPDFXOutputCondition: string;
// global['kCGPDFXOutputCondition'] = kCGPDFXOutputCondition;

// export let kCGPDFXOutputConditionIdentifier: string;
// global['kCGPDFXOutputConditionIdentifier'] = kCGPDFXOutputConditionIdentifier;

// export let kCGPDFXOutputIntentSubtype: string;
// global['kCGPDFXOutputIntentSubtype'] = kCGPDFXOutputIntentSubtype;

// export let kCGPDFXRegistryName: string;
// global['kCGPDFXRegistryName'] = kCGPDFXRegistryName;

// export let kCGWindowAlpha: string;
// global['kCGWindowAlpha'] = kCGWindowAlpha;

// export let kCGWindowBackingLocationVideoMemory: string;
// global['kCGWindowBackingLocationVideoMemory'] = kCGWindowBackingLocationVideoMemory;

// export let kCGWindowBounds: string;
// global['kCGWindowBounds'] = kCGWindowBounds;

// export let kCGWindowIsOnscreen: string;
// global['kCGWindowIsOnscreen'] = kCGWindowIsOnscreen;

// export let kCGWindowLayer: string;
// global['kCGWindowLayer'] = kCGWindowLayer;

// export let kCGWindowMemoryUsage: string;
// global['kCGWindowMemoryUsage'] = kCGWindowMemoryUsage;

// export let kCGWindowName: string;
// global['kCGWindowName'] = kCGWindowName;

// export let kCGWindowNumber: string;
// global['kCGWindowNumber'] = kCGWindowNumber;

// export let kCGWindowOwnerName: string;
// global['kCGWindowOwnerName'] = kCGWindowOwnerName;

// export let kCGWindowOwnerPID: string;
// global['kCGWindowOwnerPID'] = kCGWindowOwnerPID;

// export let kCGWindowSharingState: string;
// global['kCGWindowSharingState'] = kCGWindowSharingState;

// export let kCGWindowStoreType: string;
// global['kCGWindowStoreType'] = kCGWindowStoreType;

// export let CIDetectorAccuracy: string;
// global['CIDetectorAccuracy'] = CIDetectorAccuracy;

// export let CIDetectorAccuracyHigh: string;
// global['CIDetectorAccuracyHigh'] = CIDetectorAccuracyHigh;

// export let CIDetectorAccuracyLow: string;
// global['CIDetectorAccuracyLow'] = CIDetectorAccuracyLow;

// export let CIDetectorAspectRatio: string;
// global['CIDetectorAspectRatio'] = CIDetectorAspectRatio;

// export let CIDetectorEyeBlink: string;
// global['CIDetectorEyeBlink'] = CIDetectorEyeBlink;

// export let CIDetectorFocalLength: string;
// global['CIDetectorFocalLength'] = CIDetectorFocalLength;

// export let CIDetectorImageOrientation: string;
// global['CIDetectorImageOrientation'] = CIDetectorImageOrientation;

// export let CIDetectorMaxFeatureCount: string;
// global['CIDetectorMaxFeatureCount'] = CIDetectorMaxFeatureCount;

// export let CIDetectorMinFeatureSize: string;
// global['CIDetectorMinFeatureSize'] = CIDetectorMinFeatureSize;

// export let CIDetectorNumberOfAngles: string;
// global['CIDetectorNumberOfAngles'] = CIDetectorNumberOfAngles;

// export let CIDetectorReturnSubFeatures: string;
// global['CIDetectorReturnSubFeatures'] = CIDetectorReturnSubFeatures;

// export let CIDetectorSmile: string;
// global['CIDetectorSmile'] = CIDetectorSmile;

// export let CIDetectorTracking: string;
// global['CIDetectorTracking'] = CIDetectorTracking;

// export let CIDetectorTypeFace: string;
// global['CIDetectorTypeFace'] = CIDetectorTypeFace;

// export let CIDetectorTypeQRCode: string;
// global['CIDetectorTypeQRCode'] = CIDetectorTypeQRCode;

// export let CIDetectorTypeRectangle: string;
// global['CIDetectorTypeRectangle'] = CIDetectorTypeRectangle;

// export let CIDetectorTypeText: string;
// global['CIDetectorTypeText'] = CIDetectorTypeText;

// export let CIFeatureTypeFace: string;
// global['CIFeatureTypeFace'] = CIFeatureTypeFace;

// export let CIFeatureTypeQRCode: string;
// global['CIFeatureTypeQRCode'] = CIFeatureTypeQRCode;

// export let CIFeatureTypeRectangle: string;
// global['CIFeatureTypeRectangle'] = CIFeatureTypeRectangle;

// export let CIFeatureTypeText: string;
// global['CIFeatureTypeText'] = CIFeatureTypeText;

// export let kCIApplyOptionColorSpace: string;
// global['kCIApplyOptionColorSpace'] = kCIApplyOptionColorSpace;

// export let kCIApplyOptionDefinition: string;
// global['kCIApplyOptionDefinition'] = kCIApplyOptionDefinition;

// export let kCIApplyOptionExtent: string;
// global['kCIApplyOptionExtent'] = kCIApplyOptionExtent;

// export let kCIApplyOptionUserInfo: string;
// global['kCIApplyOptionUserInfo'] = kCIApplyOptionUserInfo;

// export let kCIAttributeClass: string;
// global['kCIAttributeClass'] = kCIAttributeClass;

// export let kCIAttributeDefault: string;
// global['kCIAttributeDefault'] = kCIAttributeDefault;

// export let kCIAttributeDescription: string;
// global['kCIAttributeDescription'] = kCIAttributeDescription;

// export let kCIAttributeDisplayName: string;
// global['kCIAttributeDisplayName'] = kCIAttributeDisplayName;

// export let kCIAttributeFilterAvailable_Mac: string;
// global['kCIAttributeFilterAvailable_Mac'] = kCIAttributeFilterAvailable_Mac;

// export let kCIAttributeFilterAvailable_iOS: string;
// global['kCIAttributeFilterAvailable_iOS'] = kCIAttributeFilterAvailable_iOS;

// export let kCIAttributeFilterCategories: string;
// global['kCIAttributeFilterCategories'] = kCIAttributeFilterCategories;

// export let kCIAttributeFilterDisplayName: string;
// global['kCIAttributeFilterDisplayName'] = kCIAttributeFilterDisplayName;

// export let kCIAttributeFilterName: string;
// global['kCIAttributeFilterName'] = kCIAttributeFilterName;

// export let kCIAttributeIdentity: string;
// global['kCIAttributeIdentity'] = kCIAttributeIdentity;

// export let kCIAttributeMax: string;
// global['kCIAttributeMax'] = kCIAttributeMax;

// export let kCIAttributeMin: string;
// global['kCIAttributeMin'] = kCIAttributeMin;

// export let kCIAttributeName: string;
// global['kCIAttributeName'] = kCIAttributeName;

// export let kCIAttributeReferenceDocumentation: string;
// global['kCIAttributeReferenceDocumentation'] = kCIAttributeReferenceDocumentation;

// export let kCIAttributeSliderMax: string;
// global['kCIAttributeSliderMax'] = kCIAttributeSliderMax;

// export let kCIAttributeSliderMin: string;
// global['kCIAttributeSliderMin'] = kCIAttributeSliderMin;

// export let kCIAttributeType: string;
// global['kCIAttributeType'] = kCIAttributeType;

// export let kCIAttributeTypeAngle: string;
// global['kCIAttributeTypeAngle'] = kCIAttributeTypeAngle;

// export let kCIAttributeTypeBoolean: string;
// global['kCIAttributeTypeBoolean'] = kCIAttributeTypeBoolean;

// export let kCIAttributeTypeColor: string;
// global['kCIAttributeTypeColor'] = kCIAttributeTypeColor;

// export let kCIAttributeTypeCount: string;
// global['kCIAttributeTypeCount'] = kCIAttributeTypeCount;

// export let kCIAttributeTypeDistance: string;
// global['kCIAttributeTypeDistance'] = kCIAttributeTypeDistance;

// export let kCIAttributeTypeGradient: string;
// global['kCIAttributeTypeGradient'] = kCIAttributeTypeGradient;

// export let kCIAttributeTypeImage: string;
// global['kCIAttributeTypeImage'] = kCIAttributeTypeImage;

// export let kCIAttributeTypeInteger: string;
// global['kCIAttributeTypeInteger'] = kCIAttributeTypeInteger;

// export let kCIAttributeTypeOffset: string;
// global['kCIAttributeTypeOffset'] = kCIAttributeTypeOffset;

// export let kCIAttributeTypeOpaqueColor: string;
// global['kCIAttributeTypeOpaqueColor'] = kCIAttributeTypeOpaqueColor;

// export let kCIAttributeTypePosition: string;
// global['kCIAttributeTypePosition'] = kCIAttributeTypePosition;

// export let kCIAttributeTypePosition3: string;
// global['kCIAttributeTypePosition3'] = kCIAttributeTypePosition3;

// export let kCIAttributeTypeRectangle: string;
// global['kCIAttributeTypeRectangle'] = kCIAttributeTypeRectangle;

// export let kCIAttributeTypeScalar: string;
// global['kCIAttributeTypeScalar'] = kCIAttributeTypeScalar;

// export let kCIAttributeTypeTime: string;
// global['kCIAttributeTypeTime'] = kCIAttributeTypeTime;

// export let kCIAttributeTypeTransform: string;
// global['kCIAttributeTypeTransform'] = kCIAttributeTypeTransform;

// export let kCICategoryBlur: string;
// global['kCICategoryBlur'] = kCICategoryBlur;

// export let kCICategoryBuiltIn: string;
// global['kCICategoryBuiltIn'] = kCICategoryBuiltIn;

// export let kCICategoryColorAdjustment: string;
// global['kCICategoryColorAdjustment'] = kCICategoryColorAdjustment;

// export let kCICategoryColorEffect: string;
// global['kCICategoryColorEffect'] = kCICategoryColorEffect;

// export let kCICategoryCompositeOperation: string;
// global['kCICategoryCompositeOperation'] = kCICategoryCompositeOperation;

// export let kCICategoryDistortionEffect: string;
// global['kCICategoryDistortionEffect'] = kCICategoryDistortionEffect;

// export let kCICategoryFilterGenerator: string;
// global['kCICategoryFilterGenerator'] = kCICategoryFilterGenerator;

// export let kCICategoryGenerator: string;
// global['kCICategoryGenerator'] = kCICategoryGenerator;

// export let kCICategoryGeometryAdjustment: string;
// global['kCICategoryGeometryAdjustment'] = kCICategoryGeometryAdjustment;

// export let kCICategoryGradient: string;
// global['kCICategoryGradient'] = kCICategoryGradient;

// export let kCICategoryHalftoneEffect: string;
// global['kCICategoryHalftoneEffect'] = kCICategoryHalftoneEffect;

// export let kCICategoryHighDynamicRange: string;
// global['kCICategoryHighDynamicRange'] = kCICategoryHighDynamicRange;

// export let kCICategoryInterlaced: string;
// global['kCICategoryInterlaced'] = kCICategoryInterlaced;

// export let kCICategoryNonSquarePixels: string;
// global['kCICategoryNonSquarePixels'] = kCICategoryNonSquarePixels;

// export let kCICategoryReduction: string;
// global['kCICategoryReduction'] = kCICategoryReduction;

// export let kCICategorySharpen: string;
// global['kCICategorySharpen'] = kCICategorySharpen;

// export let kCICategoryStillImage: string;
// global['kCICategoryStillImage'] = kCICategoryStillImage;

// export let kCICategoryStylize: string;
// global['kCICategoryStylize'] = kCICategoryStylize;

// export let kCICategoryTileEffect: string;
// global['kCICategoryTileEffect'] = kCICategoryTileEffect;

// export let kCICategoryTransition: string;
// global['kCICategoryTransition'] = kCICategoryTransition;

// export let kCICategoryVideo: string;
// global['kCICategoryVideo'] = kCICategoryVideo;

// export let kCIFilterGeneratorExportedKey: string;
// global['kCIFilterGeneratorExportedKey'] = kCIFilterGeneratorExportedKey;

// export let kCIFilterGeneratorExportedKeyName: string;
// global['kCIFilterGeneratorExportedKeyName'] = kCIFilterGeneratorExportedKeyName;

// export let kCIFilterGeneratorExportedKeyTargetObject: string;
// global['kCIFilterGeneratorExportedKeyTargetObject'] = kCIFilterGeneratorExportedKeyTargetObject;

// export let kCIInputAmountKey: string;
// global['kCIInputAmountKey'] = kCIInputAmountKey;

// export let kCIInputAngleKey: string;
// global['kCIInputAngleKey'] = kCIInputAngleKey;

// export let kCIInputAspectRatioKey: string;
// global['kCIInputAspectRatioKey'] = kCIInputAspectRatioKey;

// export let kCIInputBackgroundImageKey: string;
// global['kCIInputBackgroundImageKey'] = kCIInputBackgroundImageKey;

// export let kCIInputBiasKey: string;
// global['kCIInputBiasKey'] = kCIInputBiasKey;

// export let kCIInputBrightnessKey: string;
// global['kCIInputBrightnessKey'] = kCIInputBrightnessKey;

// export let kCIInputCenterKey: string;
// global['kCIInputCenterKey'] = kCIInputCenterKey;

// export let kCIInputColorKey: string;
// global['kCIInputColorKey'] = kCIInputColorKey;

// export let kCIInputContrastKey: string;
// global['kCIInputContrastKey'] = kCIInputContrastKey;

// export let kCIInputDepthImageKey: string;
// global['kCIInputDepthImageKey'] = kCIInputDepthImageKey;

// export let kCIInputDisparityImageKey: string;
// global['kCIInputDisparityImageKey'] = kCIInputDisparityImageKey;

// export let kCIInputEVKey: string;
// global['kCIInputEVKey'] = kCIInputEVKey;

// export let kCIInputEnableEDRModeKey: string;
// global['kCIInputEnableEDRModeKey'] = kCIInputEnableEDRModeKey;

// export let kCIInputExtentKey: string;
// global['kCIInputExtentKey'] = kCIInputExtentKey;

// export let kCIInputGradientImageKey: string;
// global['kCIInputGradientImageKey'] = kCIInputGradientImageKey;

// export let kCIInputImageKey: string;
// global['kCIInputImageKey'] = kCIInputImageKey;

// export let kCIInputIntensityKey: string;
// global['kCIInputIntensityKey'] = kCIInputIntensityKey;

// export let kCIInputMaskImageKey: string;
// global['kCIInputMaskImageKey'] = kCIInputMaskImageKey;

// export let kCIInputMatteImageKey: string;
// global['kCIInputMatteImageKey'] = kCIInputMatteImageKey;

// export let kCIInputRadiusKey: string;
// global['kCIInputRadiusKey'] = kCIInputRadiusKey;

// export let kCIInputRefractionKey: string;
// global['kCIInputRefractionKey'] = kCIInputRefractionKey;

// export let kCIInputSaturationKey: string;
// global['kCIInputSaturationKey'] = kCIInputSaturationKey;

// export let kCIInputScaleKey: string;
// global['kCIInputScaleKey'] = kCIInputScaleKey;

// export let kCIInputShadingImageKey: string;
// global['kCIInputShadingImageKey'] = kCIInputShadingImageKey;

// export let kCIInputSharpnessKey: string;
// global['kCIInputSharpnessKey'] = kCIInputSharpnessKey;

// export let kCIInputTargetImageKey: string;
// global['kCIInputTargetImageKey'] = kCIInputTargetImageKey;

// export let kCIInputTimeKey: string;
// global['kCIInputTimeKey'] = kCIInputTimeKey;

// export let kCIInputTransformKey: string;
// global['kCIInputTransformKey'] = kCIInputTransformKey;

// export let kCIInputVersionKey: string;
// global['kCIInputVersionKey'] = kCIInputVersionKey;

// export let kCIInputWeightsKey: string;
// global['kCIInputWeightsKey'] = kCIInputWeightsKey;

// export let kCIInputWidthKey: string;
// global['kCIInputWidthKey'] = kCIInputWidthKey;

// export let kCIOutputImageKey: string;
// global['kCIOutputImageKey'] = kCIOutputImageKey;

// export let kCISamplerAffineMatrix: string;
// global['kCISamplerAffineMatrix'] = kCISamplerAffineMatrix;

// export let kCISamplerColorSpace: string;
// global['kCISamplerColorSpace'] = kCISamplerColorSpace;

// export let kCISamplerFilterLinear: string;
// global['kCISamplerFilterLinear'] = kCISamplerFilterLinear;

// export let kCISamplerFilterMode: string;
// global['kCISamplerFilterMode'] = kCISamplerFilterMode;

// export let kCISamplerFilterNearest: string;
// global['kCISamplerFilterNearest'] = kCISamplerFilterNearest;

// export let kCISamplerWrapBlack: string;
// global['kCISamplerWrapBlack'] = kCISamplerWrapBlack;

// export let kCISamplerWrapClamp: string;
// global['kCISamplerWrapClamp'] = kCISamplerWrapClamp;

// export let kCISamplerWrapMode: string;
// global['kCISamplerWrapMode'] = kCISamplerWrapMode;

// export let kCIUIParameterSet: string;
// global['kCIUIParameterSet'] = kCIUIParameterSet;

// export let kCIUISetAdvanced: string;
// global['kCIUISetAdvanced'] = kCIUISetAdvanced;

// export let kCIUISetBasic: string;
// global['kCIUISetBasic'] = kCIUISetBasic;

// export let kCIUISetDevelopment: string;
// global['kCIUISetDevelopment'] = kCIUISetDevelopment;

// export let kCIUISetIntermediate: string;
// global['kCIUISetIntermediate'] = kCIUISetIntermediate;

// export let kCMFormatDescriptionAlphaChannelMode_PremultipliedAlpha: string;
// global['kCMFormatDescriptionAlphaChannelMode_PremultipliedAlpha'] = kCMFormatDescriptionAlphaChannelMode_PremultipliedAlpha;

// export let kCMFormatDescriptionAlphaChannelMode_StraightAlpha: string;
// global['kCMFormatDescriptionAlphaChannelMode_StraightAlpha'] = kCMFormatDescriptionAlphaChannelMode_StraightAlpha;

// export let kCMFormatDescriptionChromaLocation_Bottom: string;
// global['kCMFormatDescriptionChromaLocation_Bottom'] = kCMFormatDescriptionChromaLocation_Bottom;

// export let kCMFormatDescriptionChromaLocation_BottomLeft: string;
// global['kCMFormatDescriptionChromaLocation_BottomLeft'] = kCMFormatDescriptionChromaLocation_BottomLeft;

// export let kCMFormatDescriptionChromaLocation_Center: string;
// global['kCMFormatDescriptionChromaLocation_Center'] = kCMFormatDescriptionChromaLocation_Center;

// export let kCMFormatDescriptionChromaLocation_DV420: string;
// global['kCMFormatDescriptionChromaLocation_DV420'] = kCMFormatDescriptionChromaLocation_DV420;

// export let kCMFormatDescriptionChromaLocation_Left: string;
// global['kCMFormatDescriptionChromaLocation_Left'] = kCMFormatDescriptionChromaLocation_Left;

// export let kCMFormatDescriptionChromaLocation_Top: string;
// global['kCMFormatDescriptionChromaLocation_Top'] = kCMFormatDescriptionChromaLocation_Top;

// export let kCMFormatDescriptionChromaLocation_TopLeft: string;
// global['kCMFormatDescriptionChromaLocation_TopLeft'] = kCMFormatDescriptionChromaLocation_TopLeft;

// export let kCMFormatDescriptionColorPrimaries_DCI_P3: string;
// global['kCMFormatDescriptionColorPrimaries_DCI_P3'] = kCMFormatDescriptionColorPrimaries_DCI_P3;

// export let kCMFormatDescriptionColorPrimaries_EBU_3213: string;
// global['kCMFormatDescriptionColorPrimaries_EBU_3213'] = kCMFormatDescriptionColorPrimaries_EBU_3213;

// export let kCMFormatDescriptionColorPrimaries_ITU_R_2020: string;
// global['kCMFormatDescriptionColorPrimaries_ITU_R_2020'] = kCMFormatDescriptionColorPrimaries_ITU_R_2020;

// export let kCMFormatDescriptionColorPrimaries_ITU_R_709_2: string;
// global['kCMFormatDescriptionColorPrimaries_ITU_R_709_2'] = kCMFormatDescriptionColorPrimaries_ITU_R_709_2;

// export let kCMFormatDescriptionColorPrimaries_P22: string;
// global['kCMFormatDescriptionColorPrimaries_P22'] = kCMFormatDescriptionColorPrimaries_P22;

// export let kCMFormatDescriptionColorPrimaries_P3_D65: string;
// global['kCMFormatDescriptionColorPrimaries_P3_D65'] = kCMFormatDescriptionColorPrimaries_P3_D65;

// export let kCMFormatDescriptionColorPrimaries_SMPTE_C: string;
// global['kCMFormatDescriptionColorPrimaries_SMPTE_C'] = kCMFormatDescriptionColorPrimaries_SMPTE_C;

// export let kCMFormatDescriptionConformsToMPEG2VideoProfile: string;
// global['kCMFormatDescriptionConformsToMPEG2VideoProfile'] = kCMFormatDescriptionConformsToMPEG2VideoProfile;

// export let kCMFormatDescriptionExtensionKey_MetadataKeyTable: string;
// global['kCMFormatDescriptionExtensionKey_MetadataKeyTable'] = kCMFormatDescriptionExtensionKey_MetadataKeyTable;

// export let kCMFormatDescriptionExtension_AlphaChannelMode: string;
// global['kCMFormatDescriptionExtension_AlphaChannelMode'] = kCMFormatDescriptionExtension_AlphaChannelMode;

// export let kCMFormatDescriptionExtension_AlternativeTransferCharacteristics: string;
// global['kCMFormatDescriptionExtension_AlternativeTransferCharacteristics'] = kCMFormatDescriptionExtension_AlternativeTransferCharacteristics;

// export let kCMFormatDescriptionExtension_AuxiliaryTypeInfo: string;
// global['kCMFormatDescriptionExtension_AuxiliaryTypeInfo'] = kCMFormatDescriptionExtension_AuxiliaryTypeInfo;

// export let kCMFormatDescriptionExtension_BytesPerRow: string;
// global['kCMFormatDescriptionExtension_BytesPerRow'] = kCMFormatDescriptionExtension_BytesPerRow;

// export let kCMFormatDescriptionExtension_ChromaLocationBottomField: string;
// global['kCMFormatDescriptionExtension_ChromaLocationBottomField'] = kCMFormatDescriptionExtension_ChromaLocationBottomField;

// export let kCMFormatDescriptionExtension_ChromaLocationTopField: string;
// global['kCMFormatDescriptionExtension_ChromaLocationTopField'] = kCMFormatDescriptionExtension_ChromaLocationTopField;

// export let kCMFormatDescriptionExtension_CleanAperture: string;
// global['kCMFormatDescriptionExtension_CleanAperture'] = kCMFormatDescriptionExtension_CleanAperture;

// export let kCMFormatDescriptionExtension_ColorPrimaries: string;
// global['kCMFormatDescriptionExtension_ColorPrimaries'] = kCMFormatDescriptionExtension_ColorPrimaries;

// export let kCMFormatDescriptionExtension_ContainsAlphaChannel: string;
// global['kCMFormatDescriptionExtension_ContainsAlphaChannel'] = kCMFormatDescriptionExtension_ContainsAlphaChannel;

// export let kCMFormatDescriptionExtension_ContentLightLevelInfo: string;
// global['kCMFormatDescriptionExtension_ContentLightLevelInfo'] = kCMFormatDescriptionExtension_ContentLightLevelInfo;

// export let kCMFormatDescriptionExtension_Depth: string;
// global['kCMFormatDescriptionExtension_Depth'] = kCMFormatDescriptionExtension_Depth;

// export let kCMFormatDescriptionExtension_FieldCount: string;
// global['kCMFormatDescriptionExtension_FieldCount'] = kCMFormatDescriptionExtension_FieldCount;

// export let kCMFormatDescriptionExtension_FieldDetail: string;
// global['kCMFormatDescriptionExtension_FieldDetail'] = kCMFormatDescriptionExtension_FieldDetail;

// export let kCMFormatDescriptionExtension_FormatName: string;
// global['kCMFormatDescriptionExtension_FormatName'] = kCMFormatDescriptionExtension_FormatName;

// export let kCMFormatDescriptionExtension_FullRangeVideo: string;
// global['kCMFormatDescriptionExtension_FullRangeVideo'] = kCMFormatDescriptionExtension_FullRangeVideo;

// export let kCMFormatDescriptionExtension_GammaLevel: string;
// global['kCMFormatDescriptionExtension_GammaLevel'] = kCMFormatDescriptionExtension_GammaLevel;

// export let kCMFormatDescriptionExtension_ICCProfile: string;
// global['kCMFormatDescriptionExtension_ICCProfile'] = kCMFormatDescriptionExtension_ICCProfile;

// export let kCMFormatDescriptionExtension_MasteringDisplayColorVolume: string;
// global['kCMFormatDescriptionExtension_MasteringDisplayColorVolume'] = kCMFormatDescriptionExtension_MasteringDisplayColorVolume;

// export let kCMFormatDescriptionExtension_OriginalCompressionSettings: string;
// global['kCMFormatDescriptionExtension_OriginalCompressionSettings'] = kCMFormatDescriptionExtension_OriginalCompressionSettings;

// export let kCMFormatDescriptionExtension_PixelAspectRatio: string;
// global['kCMFormatDescriptionExtension_PixelAspectRatio'] = kCMFormatDescriptionExtension_PixelAspectRatio;

// export let kCMFormatDescriptionExtension_RevisionLevel: string;
// global['kCMFormatDescriptionExtension_RevisionLevel'] = kCMFormatDescriptionExtension_RevisionLevel;

// export let kCMFormatDescriptionExtension_SampleDescriptionExtensionAtoms: string;
// global['kCMFormatDescriptionExtension_SampleDescriptionExtensionAtoms'] = kCMFormatDescriptionExtension_SampleDescriptionExtensionAtoms;

// export let kCMFormatDescriptionExtension_SpatialQuality: string;
// global['kCMFormatDescriptionExtension_SpatialQuality'] = kCMFormatDescriptionExtension_SpatialQuality;

// export let kCMFormatDescriptionExtension_TemporalQuality: string;
// global['kCMFormatDescriptionExtension_TemporalQuality'] = kCMFormatDescriptionExtension_TemporalQuality;

// export let kCMFormatDescriptionExtension_TransferFunction: string;
// global['kCMFormatDescriptionExtension_TransferFunction'] = kCMFormatDescriptionExtension_TransferFunction;

// export let kCMFormatDescriptionExtension_Vendor: string;
// global['kCMFormatDescriptionExtension_Vendor'] = kCMFormatDescriptionExtension_Vendor;

// export let kCMFormatDescriptionExtension_VerbatimISOSampleEntry: string;
// global['kCMFormatDescriptionExtension_VerbatimISOSampleEntry'] = kCMFormatDescriptionExtension_VerbatimISOSampleEntry;

// export let kCMFormatDescriptionExtension_VerbatimImageDescription: string;
// global['kCMFormatDescriptionExtension_VerbatimImageDescription'] = kCMFormatDescriptionExtension_VerbatimImageDescription;

// export let kCMFormatDescriptionExtension_VerbatimSampleDescription: string;
// global['kCMFormatDescriptionExtension_VerbatimSampleDescription'] = kCMFormatDescriptionExtension_VerbatimSampleDescription;

// export let kCMFormatDescriptionExtension_Version: string;
// global['kCMFormatDescriptionExtension_Version'] = kCMFormatDescriptionExtension_Version;

// export let kCMFormatDescriptionExtension_YCbCrMatrix: string;
// global['kCMFormatDescriptionExtension_YCbCrMatrix'] = kCMFormatDescriptionExtension_YCbCrMatrix;

// export let kCMFormatDescriptionFieldDetail_SpatialFirstLineEarly: string;
// global['kCMFormatDescriptionFieldDetail_SpatialFirstLineEarly'] = kCMFormatDescriptionFieldDetail_SpatialFirstLineEarly;

// export let kCMFormatDescriptionFieldDetail_SpatialFirstLineLate: string;
// global['kCMFormatDescriptionFieldDetail_SpatialFirstLineLate'] = kCMFormatDescriptionFieldDetail_SpatialFirstLineLate;

// export let kCMFormatDescriptionFieldDetail_TemporalBottomFirst: string;
// global['kCMFormatDescriptionFieldDetail_TemporalBottomFirst'] = kCMFormatDescriptionFieldDetail_TemporalBottomFirst;

// export let kCMFormatDescriptionFieldDetail_TemporalTopFirst: string;
// global['kCMFormatDescriptionFieldDetail_TemporalTopFirst'] = kCMFormatDescriptionFieldDetail_TemporalTopFirst;

// export let kCMFormatDescriptionKey_CleanApertureHeight: string;
// global['kCMFormatDescriptionKey_CleanApertureHeight'] = kCMFormatDescriptionKey_CleanApertureHeight;

// export let kCMFormatDescriptionKey_CleanApertureHeightRational: string;
// global['kCMFormatDescriptionKey_CleanApertureHeightRational'] = kCMFormatDescriptionKey_CleanApertureHeightRational;

// export let kCMFormatDescriptionKey_CleanApertureHorizontalOffset: string;
// global['kCMFormatDescriptionKey_CleanApertureHorizontalOffset'] = kCMFormatDescriptionKey_CleanApertureHorizontalOffset;

// export let kCMFormatDescriptionKey_CleanApertureHorizontalOffsetRational: string;
// global['kCMFormatDescriptionKey_CleanApertureHorizontalOffsetRational'] = kCMFormatDescriptionKey_CleanApertureHorizontalOffsetRational;

// export let kCMFormatDescriptionKey_CleanApertureVerticalOffset: string;
// global['kCMFormatDescriptionKey_CleanApertureVerticalOffset'] = kCMFormatDescriptionKey_CleanApertureVerticalOffset;

// export let kCMFormatDescriptionKey_CleanApertureVerticalOffsetRational: string;
// global['kCMFormatDescriptionKey_CleanApertureVerticalOffsetRational'] = kCMFormatDescriptionKey_CleanApertureVerticalOffsetRational;

// export let kCMFormatDescriptionKey_CleanApertureWidth: string;
// global['kCMFormatDescriptionKey_CleanApertureWidth'] = kCMFormatDescriptionKey_CleanApertureWidth;

// export let kCMFormatDescriptionKey_CleanApertureWidthRational: string;
// global['kCMFormatDescriptionKey_CleanApertureWidthRational'] = kCMFormatDescriptionKey_CleanApertureWidthRational;

// export let kCMFormatDescriptionKey_PixelAspectRatioHorizontalSpacing: string;
// global['kCMFormatDescriptionKey_PixelAspectRatioHorizontalSpacing'] = kCMFormatDescriptionKey_PixelAspectRatioHorizontalSpacing;

// export let kCMFormatDescriptionKey_PixelAspectRatioVerticalSpacing: string;
// global['kCMFormatDescriptionKey_PixelAspectRatioVerticalSpacing'] = kCMFormatDescriptionKey_PixelAspectRatioVerticalSpacing;

// export let kCMFormatDescriptionTransferFunction_ITU_R_2020: string;
// global['kCMFormatDescriptionTransferFunction_ITU_R_2020'] = kCMFormatDescriptionTransferFunction_ITU_R_2020;

// export let kCMFormatDescriptionTransferFunction_ITU_R_2100_HLG: string;
// global['kCMFormatDescriptionTransferFunction_ITU_R_2100_HLG'] = kCMFormatDescriptionTransferFunction_ITU_R_2100_HLG;

// export let kCMFormatDescriptionTransferFunction_ITU_R_709_2: string;
// global['kCMFormatDescriptionTransferFunction_ITU_R_709_2'] = kCMFormatDescriptionTransferFunction_ITU_R_709_2;

// export let kCMFormatDescriptionTransferFunction_Linear: string;
// global['kCMFormatDescriptionTransferFunction_Linear'] = kCMFormatDescriptionTransferFunction_Linear;

// export let kCMFormatDescriptionTransferFunction_SMPTE_240M_1995: string;
// global['kCMFormatDescriptionTransferFunction_SMPTE_240M_1995'] = kCMFormatDescriptionTransferFunction_SMPTE_240M_1995;

// export let kCMFormatDescriptionTransferFunction_SMPTE_ST_2084_PQ: string;
// global['kCMFormatDescriptionTransferFunction_SMPTE_ST_2084_PQ'] = kCMFormatDescriptionTransferFunction_SMPTE_ST_2084_PQ;

// export let kCMFormatDescriptionTransferFunction_SMPTE_ST_428_1: string;
// global['kCMFormatDescriptionTransferFunction_SMPTE_ST_428_1'] = kCMFormatDescriptionTransferFunction_SMPTE_ST_428_1;

// export let kCMFormatDescriptionTransferFunction_UseGamma: string;
// global['kCMFormatDescriptionTransferFunction_UseGamma'] = kCMFormatDescriptionTransferFunction_UseGamma;

// export let kCMFormatDescriptionTransferFunction_sRGB: string;
// global['kCMFormatDescriptionTransferFunction_sRGB'] = kCMFormatDescriptionTransferFunction_sRGB;

// export let kCMFormatDescriptionVendor_Apple: string;
// global['kCMFormatDescriptionVendor_Apple'] = kCMFormatDescriptionVendor_Apple;

// export let kCMFormatDescriptionYCbCrMatrix_ITU_R_2020: string;
// global['kCMFormatDescriptionYCbCrMatrix_ITU_R_2020'] = kCMFormatDescriptionYCbCrMatrix_ITU_R_2020;

// export let kCMFormatDescriptionYCbCrMatrix_ITU_R_601_4: string;
// global['kCMFormatDescriptionYCbCrMatrix_ITU_R_601_4'] = kCMFormatDescriptionYCbCrMatrix_ITU_R_601_4;

// export let kCMFormatDescriptionYCbCrMatrix_ITU_R_709_2: string;
// global['kCMFormatDescriptionYCbCrMatrix_ITU_R_709_2'] = kCMFormatDescriptionYCbCrMatrix_ITU_R_709_2;

// export let kCMFormatDescriptionYCbCrMatrix_SMPTE_240M_1995: string;
// global['kCMFormatDescriptionYCbCrMatrix_SMPTE_240M_1995'] = kCMFormatDescriptionYCbCrMatrix_SMPTE_240M_1995;

// export let kCMHEVCTemporalLevelInfoKey_ConstraintIndicatorFlags: string;
// global['kCMHEVCTemporalLevelInfoKey_ConstraintIndicatorFlags'] = kCMHEVCTemporalLevelInfoKey_ConstraintIndicatorFlags;

// export let kCMHEVCTemporalLevelInfoKey_LevelIndex: string;
// global['kCMHEVCTemporalLevelInfoKey_LevelIndex'] = kCMHEVCTemporalLevelInfoKey_LevelIndex;

// export let kCMHEVCTemporalLevelInfoKey_ProfileCompatibilityFlags: string;
// global['kCMHEVCTemporalLevelInfoKey_ProfileCompatibilityFlags'] = kCMHEVCTemporalLevelInfoKey_ProfileCompatibilityFlags;

// export let kCMHEVCTemporalLevelInfoKey_ProfileIndex: string;
// global['kCMHEVCTemporalLevelInfoKey_ProfileIndex'] = kCMHEVCTemporalLevelInfoKey_ProfileIndex;

// export let kCMHEVCTemporalLevelInfoKey_ProfileSpace: string;
// global['kCMHEVCTemporalLevelInfoKey_ProfileSpace'] = kCMHEVCTemporalLevelInfoKey_ProfileSpace;

// export let kCMHEVCTemporalLevelInfoKey_TemporalLevel: string;
// global['kCMHEVCTemporalLevelInfoKey_TemporalLevel'] = kCMHEVCTemporalLevelInfoKey_TemporalLevel;

// export let kCMHEVCTemporalLevelInfoKey_TierFlag: string;
// global['kCMHEVCTemporalLevelInfoKey_TierFlag'] = kCMHEVCTemporalLevelInfoKey_TierFlag;

// export let kCMMemoryPoolOption_AgeOutPeriod: string;
// global['kCMMemoryPoolOption_AgeOutPeriod'] = kCMMemoryPoolOption_AgeOutPeriod;

// export let kCMMetadataBaseDataType_AffineTransformF64: string;
// global['kCMMetadataBaseDataType_AffineTransformF64'] = kCMMetadataBaseDataType_AffineTransformF64;

// export let kCMMetadataBaseDataType_BMP: string;
// global['kCMMetadataBaseDataType_BMP'] = kCMMetadataBaseDataType_BMP;

// export let kCMMetadataBaseDataType_DimensionsF32: string;
// global['kCMMetadataBaseDataType_DimensionsF32'] = kCMMetadataBaseDataType_DimensionsF32;

// export let kCMMetadataBaseDataType_Float32: string;
// global['kCMMetadataBaseDataType_Float32'] = kCMMetadataBaseDataType_Float32;

// export let kCMMetadataBaseDataType_Float64: string;
// global['kCMMetadataBaseDataType_Float64'] = kCMMetadataBaseDataType_Float64;

// export let kCMMetadataBaseDataType_GIF: string;
// global['kCMMetadataBaseDataType_GIF'] = kCMMetadataBaseDataType_GIF;

// export let kCMMetadataBaseDataType_JPEG: string;
// global['kCMMetadataBaseDataType_JPEG'] = kCMMetadataBaseDataType_JPEG;

// export let kCMMetadataBaseDataType_JSON: string;
// global['kCMMetadataBaseDataType_JSON'] = kCMMetadataBaseDataType_JSON;

// export let kCMMetadataBaseDataType_PNG: string;
// global['kCMMetadataBaseDataType_PNG'] = kCMMetadataBaseDataType_PNG;

// export let kCMMetadataBaseDataType_PerspectiveTransformF64: string;
// global['kCMMetadataBaseDataType_PerspectiveTransformF64'] = kCMMetadataBaseDataType_PerspectiveTransformF64;

// export let kCMMetadataBaseDataType_PointF32: string;
// global['kCMMetadataBaseDataType_PointF32'] = kCMMetadataBaseDataType_PointF32;

// export let kCMMetadataBaseDataType_PolygonF32: string;
// global['kCMMetadataBaseDataType_PolygonF32'] = kCMMetadataBaseDataType_PolygonF32;

// export let kCMMetadataBaseDataType_PolylineF32: string;
// global['kCMMetadataBaseDataType_PolylineF32'] = kCMMetadataBaseDataType_PolylineF32;

// export let kCMMetadataBaseDataType_RawData: string;
// global['kCMMetadataBaseDataType_RawData'] = kCMMetadataBaseDataType_RawData;

// export let kCMMetadataBaseDataType_RectF32: string;
// global['kCMMetadataBaseDataType_RectF32'] = kCMMetadataBaseDataType_RectF32;

// export let kCMMetadataBaseDataType_SInt16: string;
// global['kCMMetadataBaseDataType_SInt16'] = kCMMetadataBaseDataType_SInt16;

// export let kCMMetadataBaseDataType_SInt32: string;
// global['kCMMetadataBaseDataType_SInt32'] = kCMMetadataBaseDataType_SInt32;

// export let kCMMetadataBaseDataType_SInt64: string;
// global['kCMMetadataBaseDataType_SInt64'] = kCMMetadataBaseDataType_SInt64;

// export let kCMMetadataBaseDataType_SInt8: string;
// global['kCMMetadataBaseDataType_SInt8'] = kCMMetadataBaseDataType_SInt8;

// export let kCMMetadataBaseDataType_UInt16: string;
// global['kCMMetadataBaseDataType_UInt16'] = kCMMetadataBaseDataType_UInt16;

// export let kCMMetadataBaseDataType_UInt32: string;
// global['kCMMetadataBaseDataType_UInt32'] = kCMMetadataBaseDataType_UInt32;

// export let kCMMetadataBaseDataType_UInt64: string;
// global['kCMMetadataBaseDataType_UInt64'] = kCMMetadataBaseDataType_UInt64;

// export let kCMMetadataBaseDataType_UInt8: string;
// global['kCMMetadataBaseDataType_UInt8'] = kCMMetadataBaseDataType_UInt8;

// export let kCMMetadataBaseDataType_UTF16: string;
// global['kCMMetadataBaseDataType_UTF16'] = kCMMetadataBaseDataType_UTF16;

// export let kCMMetadataBaseDataType_UTF8: string;
// global['kCMMetadataBaseDataType_UTF8'] = kCMMetadataBaseDataType_UTF8;

// export let kCMMetadataDataType_QuickTimeMetadataDirection: string;
// global['kCMMetadataDataType_QuickTimeMetadataDirection'] = kCMMetadataDataType_QuickTimeMetadataDirection;

// export let kCMMetadataDataType_QuickTimeMetadataLocation_ISO6709: string;
// global['kCMMetadataDataType_QuickTimeMetadataLocation_ISO6709'] = kCMMetadataDataType_QuickTimeMetadataLocation_ISO6709;

// export let kCMMetadataFormatDescriptionKey_ConformingDataTypes: string;
// global['kCMMetadataFormatDescriptionKey_ConformingDataTypes'] = kCMMetadataFormatDescriptionKey_ConformingDataTypes;

// export let kCMMetadataFormatDescriptionKey_DataType: string;
// global['kCMMetadataFormatDescriptionKey_DataType'] = kCMMetadataFormatDescriptionKey_DataType;

// export let kCMMetadataFormatDescriptionKey_DataTypeNamespace: string;
// global['kCMMetadataFormatDescriptionKey_DataTypeNamespace'] = kCMMetadataFormatDescriptionKey_DataTypeNamespace;

// export let kCMMetadataFormatDescriptionKey_LanguageTag: string;
// global['kCMMetadataFormatDescriptionKey_LanguageTag'] = kCMMetadataFormatDescriptionKey_LanguageTag;

// export let kCMMetadataFormatDescriptionKey_LocalID: string;
// global['kCMMetadataFormatDescriptionKey_LocalID'] = kCMMetadataFormatDescriptionKey_LocalID;

// export let kCMMetadataFormatDescriptionKey_Namespace: string;
// global['kCMMetadataFormatDescriptionKey_Namespace'] = kCMMetadataFormatDescriptionKey_Namespace;

// export let kCMMetadataFormatDescriptionKey_SetupData: string;
// global['kCMMetadataFormatDescriptionKey_SetupData'] = kCMMetadataFormatDescriptionKey_SetupData;

// export let kCMMetadataFormatDescriptionKey_StructuralDependency: string;
// global['kCMMetadataFormatDescriptionKey_StructuralDependency'] = kCMMetadataFormatDescriptionKey_StructuralDependency;

// export let kCMMetadataFormatDescriptionKey_Value: string;
// global['kCMMetadataFormatDescriptionKey_Value'] = kCMMetadataFormatDescriptionKey_Value;

// export let kCMMetadataFormatDescriptionMetadataSpecificationKey_DataType: string;
// global['kCMMetadataFormatDescriptionMetadataSpecificationKey_DataType'] = kCMMetadataFormatDescriptionMetadataSpecificationKey_DataType;

// export let kCMMetadataFormatDescriptionMetadataSpecificationKey_ExtendedLanguageTag: string;
// global['kCMMetadataFormatDescriptionMetadataSpecificationKey_ExtendedLanguageTag'] = kCMMetadataFormatDescriptionMetadataSpecificationKey_ExtendedLanguageTag;

// export let kCMMetadataFormatDescriptionMetadataSpecificationKey_Identifier: string;
// global['kCMMetadataFormatDescriptionMetadataSpecificationKey_Identifier'] = kCMMetadataFormatDescriptionMetadataSpecificationKey_Identifier;

// export let kCMMetadataFormatDescriptionMetadataSpecificationKey_SetupData: string;
// global['kCMMetadataFormatDescriptionMetadataSpecificationKey_SetupData'] = kCMMetadataFormatDescriptionMetadataSpecificationKey_SetupData;

// export let kCMMetadataFormatDescriptionMetadataSpecificationKey_StructuralDependency: string;
// global['kCMMetadataFormatDescriptionMetadataSpecificationKey_StructuralDependency'] = kCMMetadataFormatDescriptionMetadataSpecificationKey_StructuralDependency;

// export let kCMMetadataFormatDescription_StructuralDependencyKey_DependencyIsInvalidFlag: string;
// global['kCMMetadataFormatDescription_StructuralDependencyKey_DependencyIsInvalidFlag'] = kCMMetadataFormatDescription_StructuralDependencyKey_DependencyIsInvalidFlag;

// export let kCMMetadataIdentifier_QuickTimeMetadataDirection_Facing: string;
// global['kCMMetadataIdentifier_QuickTimeMetadataDirection_Facing'] = kCMMetadataIdentifier_QuickTimeMetadataDirection_Facing;

// export let kCMMetadataIdentifier_QuickTimeMetadataLivePhotoStillImageTransform: string;
// global['kCMMetadataIdentifier_QuickTimeMetadataLivePhotoStillImageTransform'] = kCMMetadataIdentifier_QuickTimeMetadataLivePhotoStillImageTransform;

// export let kCMMetadataIdentifier_QuickTimeMetadataLivePhotoStillImageTransformReferenceDimensions: string;
// global['kCMMetadataIdentifier_QuickTimeMetadataLivePhotoStillImageTransformReferenceDimensions'] = kCMMetadataIdentifier_QuickTimeMetadataLivePhotoStillImageTransformReferenceDimensions;

// export let kCMMetadataIdentifier_QuickTimeMetadataLocation_ISO6709: string;
// global['kCMMetadataIdentifier_QuickTimeMetadataLocation_ISO6709'] = kCMMetadataIdentifier_QuickTimeMetadataLocation_ISO6709;

// export let kCMMetadataIdentifier_QuickTimeMetadataPreferredAffineTransform: string;
// global['kCMMetadataIdentifier_QuickTimeMetadataPreferredAffineTransform'] = kCMMetadataIdentifier_QuickTimeMetadataPreferredAffineTransform;

// export let kCMMetadataIdentifier_QuickTimeMetadataVideoOrientation: string;
// global['kCMMetadataIdentifier_QuickTimeMetadataVideoOrientation'] = kCMMetadataIdentifier_QuickTimeMetadataVideoOrientation;

// export let kCMMetadataKeySpace_HLSDateRange: string;
// global['kCMMetadataKeySpace_HLSDateRange'] = kCMMetadataKeySpace_HLSDateRange;

// export let kCMMetadataKeySpace_ID3: string;
// global['kCMMetadataKeySpace_ID3'] = kCMMetadataKeySpace_ID3;

// export let kCMMetadataKeySpace_ISOUserData: string;
// global['kCMMetadataKeySpace_ISOUserData'] = kCMMetadataKeySpace_ISOUserData;

// export let kCMMetadataKeySpace_Icy: string;
// global['kCMMetadataKeySpace_Icy'] = kCMMetadataKeySpace_Icy;

// export let kCMMetadataKeySpace_QuickTimeMetadata: string;
// global['kCMMetadataKeySpace_QuickTimeMetadata'] = kCMMetadataKeySpace_QuickTimeMetadata;

// export let kCMMetadataKeySpace_QuickTimeUserData: string;
// global['kCMMetadataKeySpace_QuickTimeUserData'] = kCMMetadataKeySpace_QuickTimeUserData;

// export let kCMMetadataKeySpace_iTunes: string;
// global['kCMMetadataKeySpace_iTunes'] = kCMMetadataKeySpace_iTunes;

// export let kCMSampleAttachmentKey_AudioIndependentSampleDecoderRefreshCount: string;
// global['kCMSampleAttachmentKey_AudioIndependentSampleDecoderRefreshCount'] = kCMSampleAttachmentKey_AudioIndependentSampleDecoderRefreshCount;

// export let kCMSampleAttachmentKey_DependsOnOthers: string;
// global['kCMSampleAttachmentKey_DependsOnOthers'] = kCMSampleAttachmentKey_DependsOnOthers;

// export let kCMSampleAttachmentKey_DisplayImmediately: string;
// global['kCMSampleAttachmentKey_DisplayImmediately'] = kCMSampleAttachmentKey_DisplayImmediately;

// export let kCMSampleAttachmentKey_DoNotDisplay: string;
// global['kCMSampleAttachmentKey_DoNotDisplay'] = kCMSampleAttachmentKey_DoNotDisplay;

// export let kCMSampleAttachmentKey_EarlierDisplayTimesAllowed: string;
// global['kCMSampleAttachmentKey_EarlierDisplayTimesAllowed'] = kCMSampleAttachmentKey_EarlierDisplayTimesAllowed;

// export let kCMSampleAttachmentKey_HEVCStepwiseTemporalSubLayerAccess: string;
// global['kCMSampleAttachmentKey_HEVCStepwiseTemporalSubLayerAccess'] = kCMSampleAttachmentKey_HEVCStepwiseTemporalSubLayerAccess;

// export let kCMSampleAttachmentKey_HEVCSyncSampleNALUnitType: string;
// global['kCMSampleAttachmentKey_HEVCSyncSampleNALUnitType'] = kCMSampleAttachmentKey_HEVCSyncSampleNALUnitType;

// export let kCMSampleAttachmentKey_HEVCTemporalLevelInfo: string;
// global['kCMSampleAttachmentKey_HEVCTemporalLevelInfo'] = kCMSampleAttachmentKey_HEVCTemporalLevelInfo;

// export let kCMSampleAttachmentKey_HEVCTemporalSubLayerAccess: string;
// global['kCMSampleAttachmentKey_HEVCTemporalSubLayerAccess'] = kCMSampleAttachmentKey_HEVCTemporalSubLayerAccess;

// export let kCMSampleAttachmentKey_HasRedundantCoding: string;
// global['kCMSampleAttachmentKey_HasRedundantCoding'] = kCMSampleAttachmentKey_HasRedundantCoding;

// export let kCMSampleAttachmentKey_IsDependedOnByOthers: string;
// global['kCMSampleAttachmentKey_IsDependedOnByOthers'] = kCMSampleAttachmentKey_IsDependedOnByOthers;

// export let kCMSampleAttachmentKey_NotSync: string;
// global['kCMSampleAttachmentKey_NotSync'] = kCMSampleAttachmentKey_NotSync;

// export let kCMSampleAttachmentKey_PartialSync: string;
// global['kCMSampleAttachmentKey_PartialSync'] = kCMSampleAttachmentKey_PartialSync;

// export let kCMSampleBufferAttachmentKey_CameraIntrinsicMatrix: string;
// global['kCMSampleBufferAttachmentKey_CameraIntrinsicMatrix'] = kCMSampleBufferAttachmentKey_CameraIntrinsicMatrix;

// export let kCMSampleBufferAttachmentKey_DisplayEmptyMediaImmediately: string;
// global['kCMSampleBufferAttachmentKey_DisplayEmptyMediaImmediately'] = kCMSampleBufferAttachmentKey_DisplayEmptyMediaImmediately;

// export let kCMSampleBufferAttachmentKey_DrainAfterDecoding: string;
// global['kCMSampleBufferAttachmentKey_DrainAfterDecoding'] = kCMSampleBufferAttachmentKey_DrainAfterDecoding;

// export let kCMSampleBufferAttachmentKey_DroppedFrameReason: string;
// global['kCMSampleBufferAttachmentKey_DroppedFrameReason'] = kCMSampleBufferAttachmentKey_DroppedFrameReason;

// export let kCMSampleBufferAttachmentKey_DroppedFrameReasonInfo: string;
// global['kCMSampleBufferAttachmentKey_DroppedFrameReasonInfo'] = kCMSampleBufferAttachmentKey_DroppedFrameReasonInfo;

// export let kCMSampleBufferAttachmentKey_EmptyMedia: string;
// global['kCMSampleBufferAttachmentKey_EmptyMedia'] = kCMSampleBufferAttachmentKey_EmptyMedia;

// export let kCMSampleBufferAttachmentKey_EndsPreviousSampleDuration: string;
// global['kCMSampleBufferAttachmentKey_EndsPreviousSampleDuration'] = kCMSampleBufferAttachmentKey_EndsPreviousSampleDuration;

// export let kCMSampleBufferAttachmentKey_FillDiscontinuitiesWithSilence: string;
// global['kCMSampleBufferAttachmentKey_FillDiscontinuitiesWithSilence'] = kCMSampleBufferAttachmentKey_FillDiscontinuitiesWithSilence;

// export let kCMSampleBufferAttachmentKey_ForceKeyFrame: string;
// global['kCMSampleBufferAttachmentKey_ForceKeyFrame'] = kCMSampleBufferAttachmentKey_ForceKeyFrame;

// export let kCMSampleBufferAttachmentKey_GradualDecoderRefresh: string;
// global['kCMSampleBufferAttachmentKey_GradualDecoderRefresh'] = kCMSampleBufferAttachmentKey_GradualDecoderRefresh;

// export let kCMSampleBufferAttachmentKey_PermanentEmptyMedia: string;
// global['kCMSampleBufferAttachmentKey_PermanentEmptyMedia'] = kCMSampleBufferAttachmentKey_PermanentEmptyMedia;

// export let kCMSampleBufferAttachmentKey_PostNotificationWhenConsumed: string;
// global['kCMSampleBufferAttachmentKey_PostNotificationWhenConsumed'] = kCMSampleBufferAttachmentKey_PostNotificationWhenConsumed;

// export let kCMSampleBufferAttachmentKey_ResetDecoderBeforeDecoding: string;
// global['kCMSampleBufferAttachmentKey_ResetDecoderBeforeDecoding'] = kCMSampleBufferAttachmentKey_ResetDecoderBeforeDecoding;

// export let kCMSampleBufferAttachmentKey_ResumeOutput: string;
// global['kCMSampleBufferAttachmentKey_ResumeOutput'] = kCMSampleBufferAttachmentKey_ResumeOutput;

// export let kCMSampleBufferAttachmentKey_Reverse: string;
// global['kCMSampleBufferAttachmentKey_Reverse'] = kCMSampleBufferAttachmentKey_Reverse;

// export let kCMSampleBufferAttachmentKey_SampleReferenceByteOffset: string;
// global['kCMSampleBufferAttachmentKey_SampleReferenceByteOffset'] = kCMSampleBufferAttachmentKey_SampleReferenceByteOffset;

// export let kCMSampleBufferAttachmentKey_SampleReferenceURL: string;
// global['kCMSampleBufferAttachmentKey_SampleReferenceURL'] = kCMSampleBufferAttachmentKey_SampleReferenceURL;

// export let kCMSampleBufferAttachmentKey_SpeedMultiplier: string;
// global['kCMSampleBufferAttachmentKey_SpeedMultiplier'] = kCMSampleBufferAttachmentKey_SpeedMultiplier;

// export let kCMSampleBufferAttachmentKey_StillImageLensStabilizationInfo: string;
// global['kCMSampleBufferAttachmentKey_StillImageLensStabilizationInfo'] = kCMSampleBufferAttachmentKey_StillImageLensStabilizationInfo;

// export let kCMSampleBufferAttachmentKey_TransitionID: string;
// global['kCMSampleBufferAttachmentKey_TransitionID'] = kCMSampleBufferAttachmentKey_TransitionID;

// export let kCMSampleBufferAttachmentKey_TrimDurationAtEnd: string;
// global['kCMSampleBufferAttachmentKey_TrimDurationAtEnd'] = kCMSampleBufferAttachmentKey_TrimDurationAtEnd;

// export let kCMSampleBufferAttachmentKey_TrimDurationAtStart: string;
// global['kCMSampleBufferAttachmentKey_TrimDurationAtStart'] = kCMSampleBufferAttachmentKey_TrimDurationAtStart;

// export let kCMSampleBufferConduitNotificationParameter_MaxUpcomingOutputPTS: string;
// global['kCMSampleBufferConduitNotificationParameter_MaxUpcomingOutputPTS'] = kCMSampleBufferConduitNotificationParameter_MaxUpcomingOutputPTS;

// export let kCMSampleBufferConduitNotificationParameter_MinUpcomingOutputPTS: string;
// global['kCMSampleBufferConduitNotificationParameter_MinUpcomingOutputPTS'] = kCMSampleBufferConduitNotificationParameter_MinUpcomingOutputPTS;

// export let kCMSampleBufferConduitNotificationParameter_ResumeTag: string;
// global['kCMSampleBufferConduitNotificationParameter_ResumeTag'] = kCMSampleBufferConduitNotificationParameter_ResumeTag;

// export let kCMSampleBufferConduitNotificationParameter_UpcomingOutputPTSRangeMayOverlapQueuedOutputPTSRange: string;
// global['kCMSampleBufferConduitNotificationParameter_UpcomingOutputPTSRangeMayOverlapQueuedOutputPTSRange'] = kCMSampleBufferConduitNotificationParameter_UpcomingOutputPTSRangeMayOverlapQueuedOutputPTSRange;

// export let kCMSampleBufferConduitNotification_InhibitOutputUntil: string;
// global['kCMSampleBufferConduitNotification_InhibitOutputUntil'] = kCMSampleBufferConduitNotification_InhibitOutputUntil;

// export let kCMSampleBufferConduitNotification_ResetOutput: string;
// global['kCMSampleBufferConduitNotification_ResetOutput'] = kCMSampleBufferConduitNotification_ResetOutput;

// export let kCMSampleBufferConduitNotification_UpcomingOutputPTSRangeChanged: string;
// global['kCMSampleBufferConduitNotification_UpcomingOutputPTSRangeChanged'] = kCMSampleBufferConduitNotification_UpcomingOutputPTSRangeChanged;

// export let kCMSampleBufferConsumerNotification_BufferConsumed: string;
// global['kCMSampleBufferConsumerNotification_BufferConsumed'] = kCMSampleBufferConsumerNotification_BufferConsumed;

// export let kCMSampleBufferDroppedFrameReasonInfo_CameraModeSwitch: string;
// global['kCMSampleBufferDroppedFrameReasonInfo_CameraModeSwitch'] = kCMSampleBufferDroppedFrameReasonInfo_CameraModeSwitch;

// export let kCMSampleBufferDroppedFrameReason_Discontinuity: string;
// global['kCMSampleBufferDroppedFrameReason_Discontinuity'] = kCMSampleBufferDroppedFrameReason_Discontinuity;

// export let kCMSampleBufferDroppedFrameReason_FrameWasLate: string;
// global['kCMSampleBufferDroppedFrameReason_FrameWasLate'] = kCMSampleBufferDroppedFrameReason_FrameWasLate;

// export let kCMSampleBufferDroppedFrameReason_OutOfBuffers: string;
// global['kCMSampleBufferDroppedFrameReason_OutOfBuffers'] = kCMSampleBufferDroppedFrameReason_OutOfBuffers;

// export let kCMSampleBufferLensStabilizationInfo_Active: string;
// global['kCMSampleBufferLensStabilizationInfo_Active'] = kCMSampleBufferLensStabilizationInfo_Active;

// export let kCMSampleBufferLensStabilizationInfo_Off: string;
// global['kCMSampleBufferLensStabilizationInfo_Off'] = kCMSampleBufferLensStabilizationInfo_Off;

// export let kCMSampleBufferLensStabilizationInfo_OutOfRange: string;
// global['kCMSampleBufferLensStabilizationInfo_OutOfRange'] = kCMSampleBufferLensStabilizationInfo_OutOfRange;

// export let kCMSampleBufferLensStabilizationInfo_Unavailable: string;
// global['kCMSampleBufferLensStabilizationInfo_Unavailable'] = kCMSampleBufferLensStabilizationInfo_Unavailable;

// export let kCMSampleBufferNotificationParameter_OSStatus: string;
// global['kCMSampleBufferNotificationParameter_OSStatus'] = kCMSampleBufferNotificationParameter_OSStatus;

// export let kCMSampleBufferNotification_DataBecameReady: string;
// global['kCMSampleBufferNotification_DataBecameReady'] = kCMSampleBufferNotification_DataBecameReady;

// export let kCMSampleBufferNotification_DataFailed: string;
// global['kCMSampleBufferNotification_DataFailed'] = kCMSampleBufferNotification_DataFailed;

// export let kCMTextFormatDescriptionColor_Alpha: string;
// global['kCMTextFormatDescriptionColor_Alpha'] = kCMTextFormatDescriptionColor_Alpha;

// export let kCMTextFormatDescriptionColor_Blue: string;
// global['kCMTextFormatDescriptionColor_Blue'] = kCMTextFormatDescriptionColor_Blue;

// export let kCMTextFormatDescriptionColor_Green: string;
// global['kCMTextFormatDescriptionColor_Green'] = kCMTextFormatDescriptionColor_Green;

// export let kCMTextFormatDescriptionColor_Red: string;
// global['kCMTextFormatDescriptionColor_Red'] = kCMTextFormatDescriptionColor_Red;

// export let kCMTextFormatDescriptionExtension_BackgroundColor: string;
// global['kCMTextFormatDescriptionExtension_BackgroundColor'] = kCMTextFormatDescriptionExtension_BackgroundColor;

// export let kCMTextFormatDescriptionExtension_DefaultFontName: string;
// global['kCMTextFormatDescriptionExtension_DefaultFontName'] = kCMTextFormatDescriptionExtension_DefaultFontName;

// export let kCMTextFormatDescriptionExtension_DefaultStyle: string;
// global['kCMTextFormatDescriptionExtension_DefaultStyle'] = kCMTextFormatDescriptionExtension_DefaultStyle;

// export let kCMTextFormatDescriptionExtension_DefaultTextBox: string;
// global['kCMTextFormatDescriptionExtension_DefaultTextBox'] = kCMTextFormatDescriptionExtension_DefaultTextBox;

// export let kCMTextFormatDescriptionExtension_DisplayFlags: string;
// global['kCMTextFormatDescriptionExtension_DisplayFlags'] = kCMTextFormatDescriptionExtension_DisplayFlags;

// export let kCMTextFormatDescriptionExtension_FontTable: string;
// global['kCMTextFormatDescriptionExtension_FontTable'] = kCMTextFormatDescriptionExtension_FontTable;

// export let kCMTextFormatDescriptionExtension_HorizontalJustification: string;
// global['kCMTextFormatDescriptionExtension_HorizontalJustification'] = kCMTextFormatDescriptionExtension_HorizontalJustification;

// export let kCMTextFormatDescriptionExtension_TextJustification: string;
// global['kCMTextFormatDescriptionExtension_TextJustification'] = kCMTextFormatDescriptionExtension_TextJustification;

// export let kCMTextFormatDescriptionExtension_VerticalJustification: string;
// global['kCMTextFormatDescriptionExtension_VerticalJustification'] = kCMTextFormatDescriptionExtension_VerticalJustification;

// export let kCMTextFormatDescriptionRect_Bottom: string;
// global['kCMTextFormatDescriptionRect_Bottom'] = kCMTextFormatDescriptionRect_Bottom;

// export let kCMTextFormatDescriptionRect_Left: string;
// global['kCMTextFormatDescriptionRect_Left'] = kCMTextFormatDescriptionRect_Left;

// export let kCMTextFormatDescriptionRect_Right: string;
// global['kCMTextFormatDescriptionRect_Right'] = kCMTextFormatDescriptionRect_Right;

// export let kCMTextFormatDescriptionRect_Top: string;
// global['kCMTextFormatDescriptionRect_Top'] = kCMTextFormatDescriptionRect_Top;

// export let kCMTextFormatDescriptionStyle_Ascent: string;
// global['kCMTextFormatDescriptionStyle_Ascent'] = kCMTextFormatDescriptionStyle_Ascent;

// export let kCMTextFormatDescriptionStyle_EndChar: string;
// global['kCMTextFormatDescriptionStyle_EndChar'] = kCMTextFormatDescriptionStyle_EndChar;

// export let kCMTextFormatDescriptionStyle_Font: string;
// global['kCMTextFormatDescriptionStyle_Font'] = kCMTextFormatDescriptionStyle_Font;

// export let kCMTextFormatDescriptionStyle_FontFace: string;
// global['kCMTextFormatDescriptionStyle_FontFace'] = kCMTextFormatDescriptionStyle_FontFace;

// export let kCMTextFormatDescriptionStyle_FontSize: string;
// global['kCMTextFormatDescriptionStyle_FontSize'] = kCMTextFormatDescriptionStyle_FontSize;

// export let kCMTextFormatDescriptionStyle_ForegroundColor: string;
// global['kCMTextFormatDescriptionStyle_ForegroundColor'] = kCMTextFormatDescriptionStyle_ForegroundColor;

// export let kCMTextFormatDescriptionStyle_Height: string;
// global['kCMTextFormatDescriptionStyle_Height'] = kCMTextFormatDescriptionStyle_Height;

// export let kCMTextFormatDescriptionStyle_StartChar: string;
// global['kCMTextFormatDescriptionStyle_StartChar'] = kCMTextFormatDescriptionStyle_StartChar;

// export let kCMTextMarkupAlignmentType_End: string;
// global['kCMTextMarkupAlignmentType_End'] = kCMTextMarkupAlignmentType_End;

// export let kCMTextMarkupAlignmentType_Left: string;
// global['kCMTextMarkupAlignmentType_Left'] = kCMTextMarkupAlignmentType_Left;

// export let kCMTextMarkupAlignmentType_Middle: string;
// global['kCMTextMarkupAlignmentType_Middle'] = kCMTextMarkupAlignmentType_Middle;

// export let kCMTextMarkupAlignmentType_Right: string;
// global['kCMTextMarkupAlignmentType_Right'] = kCMTextMarkupAlignmentType_Right;

// export let kCMTextMarkupAlignmentType_Start: string;
// global['kCMTextMarkupAlignmentType_Start'] = kCMTextMarkupAlignmentType_Start;

// export let kCMTextMarkupAttribute_Alignment: string;
// global['kCMTextMarkupAttribute_Alignment'] = kCMTextMarkupAttribute_Alignment;

// export let kCMTextMarkupAttribute_BackgroundColorARGB: string;
// global['kCMTextMarkupAttribute_BackgroundColorARGB'] = kCMTextMarkupAttribute_BackgroundColorARGB;

// export let kCMTextMarkupAttribute_BaseFontSizePercentageRelativeToVideoHeight: string;
// global['kCMTextMarkupAttribute_BaseFontSizePercentageRelativeToVideoHeight'] = kCMTextMarkupAttribute_BaseFontSizePercentageRelativeToVideoHeight;

// export let kCMTextMarkupAttribute_BoldStyle: string;
// global['kCMTextMarkupAttribute_BoldStyle'] = kCMTextMarkupAttribute_BoldStyle;

// export let kCMTextMarkupAttribute_CharacterBackgroundColorARGB: string;
// global['kCMTextMarkupAttribute_CharacterBackgroundColorARGB'] = kCMTextMarkupAttribute_CharacterBackgroundColorARGB;

// export let kCMTextMarkupAttribute_CharacterEdgeStyle: string;
// global['kCMTextMarkupAttribute_CharacterEdgeStyle'] = kCMTextMarkupAttribute_CharacterEdgeStyle;

// export let kCMTextMarkupAttribute_FontFamilyName: string;
// global['kCMTextMarkupAttribute_FontFamilyName'] = kCMTextMarkupAttribute_FontFamilyName;

// export let kCMTextMarkupAttribute_ForegroundColorARGB: string;
// global['kCMTextMarkupAttribute_ForegroundColorARGB'] = kCMTextMarkupAttribute_ForegroundColorARGB;

// export let kCMTextMarkupAttribute_GenericFontFamilyName: string;
// global['kCMTextMarkupAttribute_GenericFontFamilyName'] = kCMTextMarkupAttribute_GenericFontFamilyName;

// export let kCMTextMarkupAttribute_ItalicStyle: string;
// global['kCMTextMarkupAttribute_ItalicStyle'] = kCMTextMarkupAttribute_ItalicStyle;

// export let kCMTextMarkupAttribute_OrthogonalLinePositionPercentageRelativeToWritingDirection: string;
// global['kCMTextMarkupAttribute_OrthogonalLinePositionPercentageRelativeToWritingDirection'] = kCMTextMarkupAttribute_OrthogonalLinePositionPercentageRelativeToWritingDirection;

// export let kCMTextMarkupAttribute_RelativeFontSize: string;
// global['kCMTextMarkupAttribute_RelativeFontSize'] = kCMTextMarkupAttribute_RelativeFontSize;

// export let kCMTextMarkupAttribute_TextPositionPercentageRelativeToWritingDirection: string;
// global['kCMTextMarkupAttribute_TextPositionPercentageRelativeToWritingDirection'] = kCMTextMarkupAttribute_TextPositionPercentageRelativeToWritingDirection;

// export let kCMTextMarkupAttribute_UnderlineStyle: string;
// global['kCMTextMarkupAttribute_UnderlineStyle'] = kCMTextMarkupAttribute_UnderlineStyle;

// export let kCMTextMarkupAttribute_VerticalLayout: string;
// global['kCMTextMarkupAttribute_VerticalLayout'] = kCMTextMarkupAttribute_VerticalLayout;

// export let kCMTextMarkupAttribute_WritingDirectionSizePercentage: string;
// global['kCMTextMarkupAttribute_WritingDirectionSizePercentage'] = kCMTextMarkupAttribute_WritingDirectionSizePercentage;

// export let kCMTextMarkupCharacterEdgeStyle_Depressed: string;
// global['kCMTextMarkupCharacterEdgeStyle_Depressed'] = kCMTextMarkupCharacterEdgeStyle_Depressed;

// export let kCMTextMarkupCharacterEdgeStyle_DropShadow: string;
// global['kCMTextMarkupCharacterEdgeStyle_DropShadow'] = kCMTextMarkupCharacterEdgeStyle_DropShadow;

// export let kCMTextMarkupCharacterEdgeStyle_None: string;
// global['kCMTextMarkupCharacterEdgeStyle_None'] = kCMTextMarkupCharacterEdgeStyle_None;

// export let kCMTextMarkupCharacterEdgeStyle_Raised: string;
// global['kCMTextMarkupCharacterEdgeStyle_Raised'] = kCMTextMarkupCharacterEdgeStyle_Raised;

// export let kCMTextMarkupCharacterEdgeStyle_Uniform: string;
// global['kCMTextMarkupCharacterEdgeStyle_Uniform'] = kCMTextMarkupCharacterEdgeStyle_Uniform;

// export let kCMTextMarkupGenericFontName_Casual: string;
// global['kCMTextMarkupGenericFontName_Casual'] = kCMTextMarkupGenericFontName_Casual;

// export let kCMTextMarkupGenericFontName_Cursive: string;
// global['kCMTextMarkupGenericFontName_Cursive'] = kCMTextMarkupGenericFontName_Cursive;

// export let kCMTextMarkupGenericFontName_Default: string;
// global['kCMTextMarkupGenericFontName_Default'] = kCMTextMarkupGenericFontName_Default;

// export let kCMTextMarkupGenericFontName_Fantasy: string;
// global['kCMTextMarkupGenericFontName_Fantasy'] = kCMTextMarkupGenericFontName_Fantasy;

// export let kCMTextMarkupGenericFontName_Monospace: string;
// global['kCMTextMarkupGenericFontName_Monospace'] = kCMTextMarkupGenericFontName_Monospace;

// export let kCMTextMarkupGenericFontName_MonospaceSansSerif: string;
// global['kCMTextMarkupGenericFontName_MonospaceSansSerif'] = kCMTextMarkupGenericFontName_MonospaceSansSerif;

// export let kCMTextMarkupGenericFontName_MonospaceSerif: string;
// global['kCMTextMarkupGenericFontName_MonospaceSerif'] = kCMTextMarkupGenericFontName_MonospaceSerif;

// export let kCMTextMarkupGenericFontName_ProportionalSansSerif: string;
// global['kCMTextMarkupGenericFontName_ProportionalSansSerif'] = kCMTextMarkupGenericFontName_ProportionalSansSerif;

// export let kCMTextMarkupGenericFontName_ProportionalSerif: string;
// global['kCMTextMarkupGenericFontName_ProportionalSerif'] = kCMTextMarkupGenericFontName_ProportionalSerif;

// export let kCMTextMarkupGenericFontName_SansSerif: string;
// global['kCMTextMarkupGenericFontName_SansSerif'] = kCMTextMarkupGenericFontName_SansSerif;

// export let kCMTextMarkupGenericFontName_Serif: string;
// global['kCMTextMarkupGenericFontName_Serif'] = kCMTextMarkupGenericFontName_Serif;

// export let kCMTextMarkupGenericFontName_SmallCapital: string;
// global['kCMTextMarkupGenericFontName_SmallCapital'] = kCMTextMarkupGenericFontName_SmallCapital;

// export let kCMTextVerticalLayout_LeftToRight: string;
// global['kCMTextVerticalLayout_LeftToRight'] = kCMTextVerticalLayout_LeftToRight;

// export let kCMTextVerticalLayout_RightToLeft: string;
// global['kCMTextVerticalLayout_RightToLeft'] = kCMTextVerticalLayout_RightToLeft;

// export let kCMTimeCodeFormatDescriptionExtension_SourceReferenceName: string;
// global['kCMTimeCodeFormatDescriptionExtension_SourceReferenceName'] = kCMTimeCodeFormatDescriptionExtension_SourceReferenceName;

// export let kCMTimeCodeFormatDescriptionKey_LangCode: string;
// global['kCMTimeCodeFormatDescriptionKey_LangCode'] = kCMTimeCodeFormatDescriptionKey_LangCode;

// export let kCMTimeCodeFormatDescriptionKey_Value: string;
// global['kCMTimeCodeFormatDescriptionKey_Value'] = kCMTimeCodeFormatDescriptionKey_Value;

// export let kCMTimeEpochKey: string;
// global['kCMTimeEpochKey'] = kCMTimeEpochKey;

// export let kCMTimeFlagsKey: string;
// global['kCMTimeFlagsKey'] = kCMTimeFlagsKey;

// export let kCMTimeMappingSourceKey: string;
// global['kCMTimeMappingSourceKey'] = kCMTimeMappingSourceKey;

// export let kCMTimeMappingTargetKey: string;
// global['kCMTimeMappingTargetKey'] = kCMTimeMappingTargetKey;

// export let kCMTimeRangeDurationKey: string;
// global['kCMTimeRangeDurationKey'] = kCMTimeRangeDurationKey;

// export let kCMTimeRangeStartKey: string;
// global['kCMTimeRangeStartKey'] = kCMTimeRangeStartKey;

// export let kCMTimeScaleKey: string;
// global['kCMTimeScaleKey'] = kCMTimeScaleKey;

// export let kCMTimeValueKey: string;
// global['kCMTimeValueKey'] = kCMTimeValueKey;

// export let kCMTimebaseNotificationKey_EventTime: string;
// global['kCMTimebaseNotificationKey_EventTime'] = kCMTimebaseNotificationKey_EventTime;

// export let kCMTimebaseNotification_EffectiveRateChanged: string;
// global['kCMTimebaseNotification_EffectiveRateChanged'] = kCMTimebaseNotification_EffectiveRateChanged;

// export let kCMTimebaseNotification_TimeJumped: string;
// global['kCMTimebaseNotification_TimeJumped'] = kCMTimebaseNotification_TimeJumped;

// export let kCMIOBlockBufferAttachmentKey_CVPixelBufferReference: string;
// global['kCMIOBlockBufferAttachmentKey_CVPixelBufferReference'] = kCMIOBlockBufferAttachmentKey_CVPixelBufferReference;

// export let kCMIOSampleBufferAttachmentKey_CAAudioTimeStamp: string;
// global['kCMIOSampleBufferAttachmentKey_CAAudioTimeStamp'] = kCMIOSampleBufferAttachmentKey_CAAudioTimeStamp;

// export let kCMIOSampleBufferAttachmentKey_ClientSequenceID: string;
// global['kCMIOSampleBufferAttachmentKey_ClientSequenceID'] = kCMIOSampleBufferAttachmentKey_ClientSequenceID;

// export let kCMIOSampleBufferAttachmentKey_ClosedCaptionSampleBuffer: string;
// global['kCMIOSampleBufferAttachmentKey_ClosedCaptionSampleBuffer'] = kCMIOSampleBufferAttachmentKey_ClosedCaptionSampleBuffer;

// export let kCMIOSampleBufferAttachmentKey_DiscontinuityFlags: string;
// global['kCMIOSampleBufferAttachmentKey_DiscontinuityFlags'] = kCMIOSampleBufferAttachmentKey_DiscontinuityFlags;

// export let kCMIOSampleBufferAttachmentKey_HDV1_PackData: string;
// global['kCMIOSampleBufferAttachmentKey_HDV1_PackData'] = kCMIOSampleBufferAttachmentKey_HDV1_PackData;

// export let kCMIOSampleBufferAttachmentKey_HDV2_VAUX: string;
// global['kCMIOSampleBufferAttachmentKey_HDV2_VAUX'] = kCMIOSampleBufferAttachmentKey_HDV2_VAUX;

// export let kCMIOSampleBufferAttachmentKey_HostTime: string;
// global['kCMIOSampleBufferAttachmentKey_HostTime'] = kCMIOSampleBufferAttachmentKey_HostTime;

// export let kCMIOSampleBufferAttachmentKey_MouseAndKeyboardModifiers: string;
// global['kCMIOSampleBufferAttachmentKey_MouseAndKeyboardModifiers'] = kCMIOSampleBufferAttachmentKey_MouseAndKeyboardModifiers;

// export let kCMIOSampleBufferAttachmentKey_MuxedSourcePresentationTimeStamp: string;
// global['kCMIOSampleBufferAttachmentKey_MuxedSourcePresentationTimeStamp'] = kCMIOSampleBufferAttachmentKey_MuxedSourcePresentationTimeStamp;

// export let kCMIOSampleBufferAttachmentKey_NativeSMPTEFrameCount: string;
// global['kCMIOSampleBufferAttachmentKey_NativeSMPTEFrameCount'] = kCMIOSampleBufferAttachmentKey_NativeSMPTEFrameCount;

// export let kCMIOSampleBufferAttachmentKey_NoDataMarker: string;
// global['kCMIOSampleBufferAttachmentKey_NoDataMarker'] = kCMIOSampleBufferAttachmentKey_NoDataMarker;

// export let kCMIOSampleBufferAttachmentKey_NumberOfVideoFramesInBuffer: string;
// global['kCMIOSampleBufferAttachmentKey_NumberOfVideoFramesInBuffer'] = kCMIOSampleBufferAttachmentKey_NumberOfVideoFramesInBuffer;

// export let kCMIOSampleBufferAttachmentKey_NumberOfVideoFramesInGOP: string;
// global['kCMIOSampleBufferAttachmentKey_NumberOfVideoFramesInGOP'] = kCMIOSampleBufferAttachmentKey_NumberOfVideoFramesInGOP;

// export let kCMIOSampleBufferAttachmentKey_PulldownCadenceInfo: string;
// global['kCMIOSampleBufferAttachmentKey_PulldownCadenceInfo'] = kCMIOSampleBufferAttachmentKey_PulldownCadenceInfo;

// export let kCMIOSampleBufferAttachmentKey_RepeatedBufferContents: string;
// global['kCMIOSampleBufferAttachmentKey_RepeatedBufferContents'] = kCMIOSampleBufferAttachmentKey_RepeatedBufferContents;

// export let kCMIOSampleBufferAttachmentKey_SMPTETime: string;
// global['kCMIOSampleBufferAttachmentKey_SMPTETime'] = kCMIOSampleBufferAttachmentKey_SMPTETime;

// export let kCMIOSampleBufferAttachmentKey_SequenceNumber: string;
// global['kCMIOSampleBufferAttachmentKey_SequenceNumber'] = kCMIOSampleBufferAttachmentKey_SequenceNumber;

// export let kCMIOSampleBufferAttachmentKey_SourceAudioFormatDescription: string;
// global['kCMIOSampleBufferAttachmentKey_SourceAudioFormatDescription'] = kCMIOSampleBufferAttachmentKey_SourceAudioFormatDescription;

// export let kCMIOSampleBufferAttachment_MouseAndKeyboardModifiersKey_CursorFrameRect: string;
// global['kCMIOSampleBufferAttachment_MouseAndKeyboardModifiersKey_CursorFrameRect'] = kCMIOSampleBufferAttachment_MouseAndKeyboardModifiersKey_CursorFrameRect;

// export let kCMIOSampleBufferAttachment_MouseAndKeyboardModifiersKey_CursorIsDrawnInFramebuffer: string;
// global['kCMIOSampleBufferAttachment_MouseAndKeyboardModifiersKey_CursorIsDrawnInFramebuffer'] = kCMIOSampleBufferAttachment_MouseAndKeyboardModifiersKey_CursorIsDrawnInFramebuffer;

// export let kCMIOSampleBufferAttachment_MouseAndKeyboardModifiersKey_CursorIsVisible: string;
// global['kCMIOSampleBufferAttachment_MouseAndKeyboardModifiersKey_CursorIsVisible'] = kCMIOSampleBufferAttachment_MouseAndKeyboardModifiersKey_CursorIsVisible;

// export let kCMIOSampleBufferAttachment_MouseAndKeyboardModifiersKey_CursorPositionX: string;
// global['kCMIOSampleBufferAttachment_MouseAndKeyboardModifiersKey_CursorPositionX'] = kCMIOSampleBufferAttachment_MouseAndKeyboardModifiersKey_CursorPositionX;

// export let kCMIOSampleBufferAttachment_MouseAndKeyboardModifiersKey_CursorPositionY: string;
// global['kCMIOSampleBufferAttachment_MouseAndKeyboardModifiersKey_CursorPositionY'] = kCMIOSampleBufferAttachment_MouseAndKeyboardModifiersKey_CursorPositionY;

// export let kCMIOSampleBufferAttachment_MouseAndKeyboardModifiersKey_CursorReference: string;
// global['kCMIOSampleBufferAttachment_MouseAndKeyboardModifiersKey_CursorReference'] = kCMIOSampleBufferAttachment_MouseAndKeyboardModifiersKey_CursorReference;

// export let kCMIOSampleBufferAttachment_MouseAndKeyboardModifiersKey_CursorScale: string;
// global['kCMIOSampleBufferAttachment_MouseAndKeyboardModifiersKey_CursorScale'] = kCMIOSampleBufferAttachment_MouseAndKeyboardModifiersKey_CursorScale;

// export let kCMIOSampleBufferAttachment_MouseAndKeyboardModifiersKey_CursorSeed: string;
// global['kCMIOSampleBufferAttachment_MouseAndKeyboardModifiersKey_CursorSeed'] = kCMIOSampleBufferAttachment_MouseAndKeyboardModifiersKey_CursorSeed;

// export let kCMIOSampleBufferAttachment_MouseAndKeyboardModifiersKey_KeyboardModifiers: string;
// global['kCMIOSampleBufferAttachment_MouseAndKeyboardModifiersKey_KeyboardModifiers'] = kCMIOSampleBufferAttachment_MouseAndKeyboardModifiersKey_KeyboardModifiers;

// export let kCMIOSampleBufferAttachment_MouseAndKeyboardModifiersKey_KeyboardModifiersEvent: string;
// global['kCMIOSampleBufferAttachment_MouseAndKeyboardModifiersKey_KeyboardModifiersEvent'] = kCMIOSampleBufferAttachment_MouseAndKeyboardModifiersKey_KeyboardModifiersEvent;

// export let kCMIOSampleBufferAttachment_MouseAndKeyboardModifiersKey_MouseButtonState: string;
// global['kCMIOSampleBufferAttachment_MouseAndKeyboardModifiersKey_MouseButtonState'] = kCMIOSampleBufferAttachment_MouseAndKeyboardModifiersKey_MouseButtonState;

// export let NSAppleEventTimeOutDefault: number;
// global['NSAppleEventTimeOutDefault'] = NSAppleEventTimeOutDefault;

// export let NSAppleEventTimeOutNone: number;
// global['NSAppleEventTimeOutNone'] = NSAppleEventTimeOutNone;

// export let NSAssertionHandlerKey: string;
// global['NSAssertionHandlerKey'] = NSAssertionHandlerKey;

// export let NSCocoaErrorDomain: string;
// global['NSCocoaErrorDomain'] = NSCocoaErrorDomain;

// export let NSDeallocateZombies: boolean;
// global['NSDeallocateZombies'] = NSDeallocateZombies;

// export let NSDebugDescriptionErrorKey: string;
// global['NSDebugDescriptionErrorKey'] = NSDebugDescriptionErrorKey;

// export let NSDebugEnabled: boolean;
// global['NSDebugEnabled'] = NSDebugEnabled;

// export let NSEdgeInsetsZero: NSEdgeInsets;
// global['NSEdgeInsetsZero'] = NSEdgeInsetsZero;

// export let NSExtensionItemAttachmentsKey: string;
// global['NSExtensionItemAttachmentsKey'] = NSExtensionItemAttachmentsKey;

// export let NSExtensionItemAttributedContentTextKey: string;
// global['NSExtensionItemAttributedContentTextKey'] = NSExtensionItemAttributedContentTextKey;

// export let NSExtensionItemAttributedTitleKey: string;
// global['NSExtensionItemAttributedTitleKey'] = NSExtensionItemAttributedTitleKey;

// export let NSExtensionItemsAndErrorsKey: string;
// global['NSExtensionItemsAndErrorsKey'] = NSExtensionItemsAndErrorsKey;

// export let NSExtensionJavaScriptPreprocessingResultsKey: string;
// global['NSExtensionJavaScriptPreprocessingResultsKey'] = NSExtensionJavaScriptPreprocessingResultsKey;

// export let NSFileHandleNotificationDataItem: string;
// global['NSFileHandleNotificationDataItem'] = NSFileHandleNotificationDataItem;

// export let NSFileHandleNotificationFileHandleItem: string;
// global['NSFileHandleNotificationFileHandleItem'] = NSFileHandleNotificationFileHandleItem;

// export let NSFileManagerUnmountDissentingProcessIdentifierErrorKey: string;
// global['NSFileManagerUnmountDissentingProcessIdentifierErrorKey'] = NSFileManagerUnmountDissentingProcessIdentifierErrorKey;

// export let NSFilePathErrorKey: string;
// global['NSFilePathErrorKey'] = NSFilePathErrorKey;

// export let NSFoundationVersionNumber: number;
// global['NSFoundationVersionNumber'] = NSFoundationVersionNumber;

// export let NSGrammarCorrections: string;
// global['NSGrammarCorrections'] = NSGrammarCorrections;

// export let NSGrammarRange: string;
// global['NSGrammarRange'] = NSGrammarRange;

// export let NSGrammarUserDescription: string;
// global['NSGrammarUserDescription'] = NSGrammarUserDescription;

// export let NSHashTableCopyIn: NSPointerFunctions.Options;
// global['NSHashTableCopyIn'] = NSHashTableCopyIn;

// export let NSHashTableObjectPointerPersonality: NSPointerFunctions.Options;
// global['NSHashTableObjectPointerPersonality'] = NSHashTableObjectPointerPersonality;

// export let NSHashTableStrongMemory: NSPointerFunctions.Options;
// global['NSHashTableStrongMemory'] = NSHashTableStrongMemory;

// export let NSHashTableWeakMemory: NSPointerFunctions.Options;
// global['NSHashTableWeakMemory'] = NSHashTableWeakMemory;

// export let NSHelpAnchorErrorKey: string;
// global['NSHelpAnchorErrorKey'] = NSHelpAnchorErrorKey;

// export let NSIntegerHashCallBacks: NSHashTableCallBacks;
// global['NSIntegerHashCallBacks'] = NSIntegerHashCallBacks;

// export let NSIntegerMapKeyCallBacks: NSMapTableKeyCallBacks;
// global['NSIntegerMapKeyCallBacks'] = NSIntegerMapKeyCallBacks;

// export let NSIntegerMapValueCallBacks: NSMapTableValueCallBacks;
// global['NSIntegerMapValueCallBacks'] = NSIntegerMapValueCallBacks;

// export let NSItemProviderPreferredImageSizeKey: string;
// global['NSItemProviderPreferredImageSizeKey'] = NSItemProviderPreferredImageSizeKey;

// export let NSKeepAllocationStatistics: boolean;
// global['NSKeepAllocationStatistics'] = NSKeepAllocationStatistics;

// export let NSKeyedArchiveRootObjectKey: string;
// global['NSKeyedArchiveRootObjectKey'] = NSKeyedArchiveRootObjectKey;

// export let NSLoadedClasses: string;
// global['NSLoadedClasses'] = NSLoadedClasses;

// export let NSLocalizedDescriptionKey: string;
// global['NSLocalizedDescriptionKey'] = NSLocalizedDescriptionKey;

// export let NSLocalizedFailureErrorKey: string;
// global['NSLocalizedFailureErrorKey'] = NSLocalizedFailureErrorKey;

// export let NSLocalizedFailureReasonErrorKey: string;
// global['NSLocalizedFailureReasonErrorKey'] = NSLocalizedFailureReasonErrorKey;

// export let NSLocalizedRecoveryOptionsErrorKey: string;
// global['NSLocalizedRecoveryOptionsErrorKey'] = NSLocalizedRecoveryOptionsErrorKey;

// export let NSLocalizedRecoverySuggestionErrorKey: string;
// global['NSLocalizedRecoverySuggestionErrorKey'] = NSLocalizedRecoverySuggestionErrorKey;

// export let NSMachErrorDomain: string;
// global['NSMachErrorDomain'] = NSMachErrorDomain;

// export let NSMapTableCopyIn: NSPointerFunctions.Options;
// global['NSMapTableCopyIn'] = NSMapTableCopyIn;

// export let NSMapTableObjectPointerPersonality: NSPointerFunctions.Options;
// global['NSMapTableObjectPointerPersonality'] = NSMapTableObjectPointerPersonality;

// export let NSMapTableStrongMemory: NSPointerFunctions.Options;
// global['NSMapTableStrongMemory'] = NSMapTableStrongMemory;

// export let NSMapTableWeakMemory: NSPointerFunctions.Options;
// global['NSMapTableWeakMemory'] = NSMapTableWeakMemory;

// export let NSMetadataItemAcquisitionMakeKey: string;
// global['NSMetadataItemAcquisitionMakeKey'] = NSMetadataItemAcquisitionMakeKey;

// export let NSMetadataItemAcquisitionModelKey: string;
// global['NSMetadataItemAcquisitionModelKey'] = NSMetadataItemAcquisitionModelKey;

// export let NSMetadataItemAlbumKey: string;
// global['NSMetadataItemAlbumKey'] = NSMetadataItemAlbumKey;

// export let NSMetadataItemAltitudeKey: string;
// global['NSMetadataItemAltitudeKey'] = NSMetadataItemAltitudeKey;

// export let NSMetadataItemApertureKey: string;
// global['NSMetadataItemApertureKey'] = NSMetadataItemApertureKey;

// export let NSMetadataItemAppleLoopDescriptorsKey: string;
// global['NSMetadataItemAppleLoopDescriptorsKey'] = NSMetadataItemAppleLoopDescriptorsKey;

// export let NSMetadataItemAppleLoopsKeyFilterTypeKey: string;
// global['NSMetadataItemAppleLoopsKeyFilterTypeKey'] = NSMetadataItemAppleLoopsKeyFilterTypeKey;

// export let NSMetadataItemAppleLoopsLoopModeKey: string;
// global['NSMetadataItemAppleLoopsLoopModeKey'] = NSMetadataItemAppleLoopsLoopModeKey;

// export let NSMetadataItemAppleLoopsRootKeyKey: string;
// global['NSMetadataItemAppleLoopsRootKeyKey'] = NSMetadataItemAppleLoopsRootKeyKey;

// export let NSMetadataItemApplicationCategoriesKey: string;
// global['NSMetadataItemApplicationCategoriesKey'] = NSMetadataItemApplicationCategoriesKey;

// export let NSMetadataItemAttributeChangeDateKey: string;
// global['NSMetadataItemAttributeChangeDateKey'] = NSMetadataItemAttributeChangeDateKey;

// export let NSMetadataItemAudiencesKey: string;
// global['NSMetadataItemAudiencesKey'] = NSMetadataItemAudiencesKey;

// export let NSMetadataItemAudioBitRateKey: string;
// global['NSMetadataItemAudioBitRateKey'] = NSMetadataItemAudioBitRateKey;

// export let NSMetadataItemAudioChannelCountKey: string;
// global['NSMetadataItemAudioChannelCountKey'] = NSMetadataItemAudioChannelCountKey;

// export let NSMetadataItemAudioEncodingApplicationKey: string;
// global['NSMetadataItemAudioEncodingApplicationKey'] = NSMetadataItemAudioEncodingApplicationKey;

// export let NSMetadataItemAudioSampleRateKey: string;
// global['NSMetadataItemAudioSampleRateKey'] = NSMetadataItemAudioSampleRateKey;

// export let NSMetadataItemAudioTrackNumberKey: string;
// global['NSMetadataItemAudioTrackNumberKey'] = NSMetadataItemAudioTrackNumberKey;

// export let NSMetadataItemAuthorAddressesKey: string;
// global['NSMetadataItemAuthorAddressesKey'] = NSMetadataItemAuthorAddressesKey;

// export let NSMetadataItemAuthorEmailAddressesKey: string;
// global['NSMetadataItemAuthorEmailAddressesKey'] = NSMetadataItemAuthorEmailAddressesKey;

// export let NSMetadataItemAuthorsKey: string;
// global['NSMetadataItemAuthorsKey'] = NSMetadataItemAuthorsKey;

// export let NSMetadataItemBitsPerSampleKey: string;
// global['NSMetadataItemBitsPerSampleKey'] = NSMetadataItemBitsPerSampleKey;

// export let NSMetadataItemCFBundleIdentifierKey: string;
// global['NSMetadataItemCFBundleIdentifierKey'] = NSMetadataItemCFBundleIdentifierKey;

// export let NSMetadataItemCameraOwnerKey: string;
// global['NSMetadataItemCameraOwnerKey'] = NSMetadataItemCameraOwnerKey;

// export let NSMetadataItemCityKey: string;
// global['NSMetadataItemCityKey'] = NSMetadataItemCityKey;

// export let NSMetadataItemCodecsKey: string;
// global['NSMetadataItemCodecsKey'] = NSMetadataItemCodecsKey;

// export let NSMetadataItemColorSpaceKey: string;
// global['NSMetadataItemColorSpaceKey'] = NSMetadataItemColorSpaceKey;

// export let NSMetadataItemCommentKey: string;
// global['NSMetadataItemCommentKey'] = NSMetadataItemCommentKey;

// export let NSMetadataItemComposerKey: string;
// global['NSMetadataItemComposerKey'] = NSMetadataItemComposerKey;

// export let NSMetadataItemContactKeywordsKey: string;
// global['NSMetadataItemContactKeywordsKey'] = NSMetadataItemContactKeywordsKey;

// export let NSMetadataItemContentCreationDateKey: string;
// global['NSMetadataItemContentCreationDateKey'] = NSMetadataItemContentCreationDateKey;

// export let NSMetadataItemContentModificationDateKey: string;
// global['NSMetadataItemContentModificationDateKey'] = NSMetadataItemContentModificationDateKey;

// export let NSMetadataItemContentTypeKey: string;
// global['NSMetadataItemContentTypeKey'] = NSMetadataItemContentTypeKey;

// export let NSMetadataItemContentTypeTreeKey: string;
// global['NSMetadataItemContentTypeTreeKey'] = NSMetadataItemContentTypeTreeKey;

// export let NSMetadataItemContributorsKey: string;
// global['NSMetadataItemContributorsKey'] = NSMetadataItemContributorsKey;

// export let NSMetadataItemCopyrightKey: string;
// global['NSMetadataItemCopyrightKey'] = NSMetadataItemCopyrightKey;

// export let NSMetadataItemCountryKey: string;
// global['NSMetadataItemCountryKey'] = NSMetadataItemCountryKey;

// export let NSMetadataItemCoverageKey: string;
// global['NSMetadataItemCoverageKey'] = NSMetadataItemCoverageKey;

// export let NSMetadataItemCreatorKey: string;
// global['NSMetadataItemCreatorKey'] = NSMetadataItemCreatorKey;

// export let NSMetadataItemDateAddedKey: string;
// global['NSMetadataItemDateAddedKey'] = NSMetadataItemDateAddedKey;

// export let NSMetadataItemDeliveryTypeKey: string;
// global['NSMetadataItemDeliveryTypeKey'] = NSMetadataItemDeliveryTypeKey;

// export let NSMetadataItemDescriptionKey: string;
// global['NSMetadataItemDescriptionKey'] = NSMetadataItemDescriptionKey;

// export let NSMetadataItemDirectorKey: string;
// global['NSMetadataItemDirectorKey'] = NSMetadataItemDirectorKey;

// export let NSMetadataItemDisplayNameKey: string;
// global['NSMetadataItemDisplayNameKey'] = NSMetadataItemDisplayNameKey;

// export let NSMetadataItemDownloadedDateKey: string;
// global['NSMetadataItemDownloadedDateKey'] = NSMetadataItemDownloadedDateKey;

// export let NSMetadataItemDueDateKey: string;
// global['NSMetadataItemDueDateKey'] = NSMetadataItemDueDateKey;

// export let NSMetadataItemDurationSecondsKey: string;
// global['NSMetadataItemDurationSecondsKey'] = NSMetadataItemDurationSecondsKey;

// export let NSMetadataItemEXIFGPSVersionKey: string;
// global['NSMetadataItemEXIFGPSVersionKey'] = NSMetadataItemEXIFGPSVersionKey;

// export let NSMetadataItemEXIFVersionKey: string;
// global['NSMetadataItemEXIFVersionKey'] = NSMetadataItemEXIFVersionKey;

// export let NSMetadataItemEditorsKey: string;
// global['NSMetadataItemEditorsKey'] = NSMetadataItemEditorsKey;

// export let NSMetadataItemEmailAddressesKey: string;
// global['NSMetadataItemEmailAddressesKey'] = NSMetadataItemEmailAddressesKey;

// export let NSMetadataItemEncodingApplicationsKey: string;
// global['NSMetadataItemEncodingApplicationsKey'] = NSMetadataItemEncodingApplicationsKey;

// export let NSMetadataItemExecutableArchitecturesKey: string;
// global['NSMetadataItemExecutableArchitecturesKey'] = NSMetadataItemExecutableArchitecturesKey;

// export let NSMetadataItemExecutablePlatformKey: string;
// global['NSMetadataItemExecutablePlatformKey'] = NSMetadataItemExecutablePlatformKey;

// export let NSMetadataItemExposureModeKey: string;
// global['NSMetadataItemExposureModeKey'] = NSMetadataItemExposureModeKey;

// export let NSMetadataItemExposureProgramKey: string;
// global['NSMetadataItemExposureProgramKey'] = NSMetadataItemExposureProgramKey;

// export let NSMetadataItemExposureTimeSecondsKey: string;
// global['NSMetadataItemExposureTimeSecondsKey'] = NSMetadataItemExposureTimeSecondsKey;

// export let NSMetadataItemExposureTimeStringKey: string;
// global['NSMetadataItemExposureTimeStringKey'] = NSMetadataItemExposureTimeStringKey;

// export let NSMetadataItemFNumberKey: string;
// global['NSMetadataItemFNumberKey'] = NSMetadataItemFNumberKey;

// export let NSMetadataItemFSContentChangeDateKey: string;
// global['NSMetadataItemFSContentChangeDateKey'] = NSMetadataItemFSContentChangeDateKey;

// export let NSMetadataItemFSCreationDateKey: string;
// global['NSMetadataItemFSCreationDateKey'] = NSMetadataItemFSCreationDateKey;

// export let NSMetadataItemFSNameKey: string;
// global['NSMetadataItemFSNameKey'] = NSMetadataItemFSNameKey;

// export let NSMetadataItemFSSizeKey: string;
// global['NSMetadataItemFSSizeKey'] = NSMetadataItemFSSizeKey;

// export let NSMetadataItemFinderCommentKey: string;
// global['NSMetadataItemFinderCommentKey'] = NSMetadataItemFinderCommentKey;

// export let NSMetadataItemFlashOnOffKey: string;
// global['NSMetadataItemFlashOnOffKey'] = NSMetadataItemFlashOnOffKey;

// export let NSMetadataItemFocalLength35mmKey: string;
// global['NSMetadataItemFocalLength35mmKey'] = NSMetadataItemFocalLength35mmKey;

// export let NSMetadataItemFocalLengthKey: string;
// global['NSMetadataItemFocalLengthKey'] = NSMetadataItemFocalLengthKey;

// export let NSMetadataItemFontsKey: string;
// global['NSMetadataItemFontsKey'] = NSMetadataItemFontsKey;

// export let NSMetadataItemGPSAreaInformationKey: string;
// global['NSMetadataItemGPSAreaInformationKey'] = NSMetadataItemGPSAreaInformationKey;

// export let NSMetadataItemGPSDOPKey: string;
// global['NSMetadataItemGPSDOPKey'] = NSMetadataItemGPSDOPKey;

// export let NSMetadataItemGPSDateStampKey: string;
// global['NSMetadataItemGPSDateStampKey'] = NSMetadataItemGPSDateStampKey;

// export let NSMetadataItemGPSDestBearingKey: string;
// global['NSMetadataItemGPSDestBearingKey'] = NSMetadataItemGPSDestBearingKey;

// export let NSMetadataItemGPSDestDistanceKey: string;
// global['NSMetadataItemGPSDestDistanceKey'] = NSMetadataItemGPSDestDistanceKey;

// export let NSMetadataItemGPSDestLatitudeKey: string;
// global['NSMetadataItemGPSDestLatitudeKey'] = NSMetadataItemGPSDestLatitudeKey;

// export let NSMetadataItemGPSDestLongitudeKey: string;
// global['NSMetadataItemGPSDestLongitudeKey'] = NSMetadataItemGPSDestLongitudeKey;

// export let NSMetadataItemGPSDifferentalKey: string;
// global['NSMetadataItemGPSDifferentalKey'] = NSMetadataItemGPSDifferentalKey;

// export let NSMetadataItemGPSMapDatumKey: string;
// global['NSMetadataItemGPSMapDatumKey'] = NSMetadataItemGPSMapDatumKey;

// export let NSMetadataItemGPSMeasureModeKey: string;
// global['NSMetadataItemGPSMeasureModeKey'] = NSMetadataItemGPSMeasureModeKey;

// export let NSMetadataItemGPSProcessingMethodKey: string;
// global['NSMetadataItemGPSProcessingMethodKey'] = NSMetadataItemGPSProcessingMethodKey;

// export let NSMetadataItemGPSStatusKey: string;
// global['NSMetadataItemGPSStatusKey'] = NSMetadataItemGPSStatusKey;

// export let NSMetadataItemGPSTrackKey: string;
// global['NSMetadataItemGPSTrackKey'] = NSMetadataItemGPSTrackKey;

// export let NSMetadataItemGenreKey: string;
// global['NSMetadataItemGenreKey'] = NSMetadataItemGenreKey;

// export let NSMetadataItemHasAlphaChannelKey: string;
// global['NSMetadataItemHasAlphaChannelKey'] = NSMetadataItemHasAlphaChannelKey;

// export let NSMetadataItemHeadlineKey: string;
// global['NSMetadataItemHeadlineKey'] = NSMetadataItemHeadlineKey;

// export let NSMetadataItemISOSpeedKey: string;
// global['NSMetadataItemISOSpeedKey'] = NSMetadataItemISOSpeedKey;

// export let NSMetadataItemIdentifierKey: string;
// global['NSMetadataItemIdentifierKey'] = NSMetadataItemIdentifierKey;

// export let NSMetadataItemImageDirectionKey: string;
// global['NSMetadataItemImageDirectionKey'] = NSMetadataItemImageDirectionKey;

// export let NSMetadataItemInformationKey: string;
// global['NSMetadataItemInformationKey'] = NSMetadataItemInformationKey;

// export let NSMetadataItemInstantMessageAddressesKey: string;
// global['NSMetadataItemInstantMessageAddressesKey'] = NSMetadataItemInstantMessageAddressesKey;

// export let NSMetadataItemInstructionsKey: string;
// global['NSMetadataItemInstructionsKey'] = NSMetadataItemInstructionsKey;

// export let NSMetadataItemIsApplicationManagedKey: string;
// global['NSMetadataItemIsApplicationManagedKey'] = NSMetadataItemIsApplicationManagedKey;

// export let NSMetadataItemIsGeneralMIDISequenceKey: string;
// global['NSMetadataItemIsGeneralMIDISequenceKey'] = NSMetadataItemIsGeneralMIDISequenceKey;

// export let NSMetadataItemIsLikelyJunkKey: string;
// global['NSMetadataItemIsLikelyJunkKey'] = NSMetadataItemIsLikelyJunkKey;

// export let NSMetadataItemIsUbiquitousKey: string;
// global['NSMetadataItemIsUbiquitousKey'] = NSMetadataItemIsUbiquitousKey;

// export let NSMetadataItemKeySignatureKey: string;
// global['NSMetadataItemKeySignatureKey'] = NSMetadataItemKeySignatureKey;

// export let NSMetadataItemKeywordsKey: string;
// global['NSMetadataItemKeywordsKey'] = NSMetadataItemKeywordsKey;

// export let NSMetadataItemKindKey: string;
// global['NSMetadataItemKindKey'] = NSMetadataItemKindKey;

// export let NSMetadataItemLanguagesKey: string;
// global['NSMetadataItemLanguagesKey'] = NSMetadataItemLanguagesKey;

// export let NSMetadataItemLastUsedDateKey: string;
// global['NSMetadataItemLastUsedDateKey'] = NSMetadataItemLastUsedDateKey;

// export let NSMetadataItemLatitudeKey: string;
// global['NSMetadataItemLatitudeKey'] = NSMetadataItemLatitudeKey;

// export let NSMetadataItemLayerNamesKey: string;
// global['NSMetadataItemLayerNamesKey'] = NSMetadataItemLayerNamesKey;

// export let NSMetadataItemLensModelKey: string;
// global['NSMetadataItemLensModelKey'] = NSMetadataItemLensModelKey;

// export let NSMetadataItemLongitudeKey: string;
// global['NSMetadataItemLongitudeKey'] = NSMetadataItemLongitudeKey;

// export let NSMetadataItemLyricistKey: string;
// global['NSMetadataItemLyricistKey'] = NSMetadataItemLyricistKey;

// export let NSMetadataItemMaxApertureKey: string;
// global['NSMetadataItemMaxApertureKey'] = NSMetadataItemMaxApertureKey;

// export let NSMetadataItemMediaTypesKey: string;
// global['NSMetadataItemMediaTypesKey'] = NSMetadataItemMediaTypesKey;

// export let NSMetadataItemMeteringModeKey: string;
// global['NSMetadataItemMeteringModeKey'] = NSMetadataItemMeteringModeKey;

// export let NSMetadataItemMusicalGenreKey: string;
// global['NSMetadataItemMusicalGenreKey'] = NSMetadataItemMusicalGenreKey;

// export let NSMetadataItemMusicalInstrumentCategoryKey: string;
// global['NSMetadataItemMusicalInstrumentCategoryKey'] = NSMetadataItemMusicalInstrumentCategoryKey;

// export let NSMetadataItemMusicalInstrumentNameKey: string;
// global['NSMetadataItemMusicalInstrumentNameKey'] = NSMetadataItemMusicalInstrumentNameKey;

// export let NSMetadataItemNamedLocationKey: string;
// global['NSMetadataItemNamedLocationKey'] = NSMetadataItemNamedLocationKey;

// export let NSMetadataItemNumberOfPagesKey: string;
// global['NSMetadataItemNumberOfPagesKey'] = NSMetadataItemNumberOfPagesKey;

// export let NSMetadataItemOrganizationsKey: string;
// global['NSMetadataItemOrganizationsKey'] = NSMetadataItemOrganizationsKey;

// export let NSMetadataItemOrientationKey: string;
// global['NSMetadataItemOrientationKey'] = NSMetadataItemOrientationKey;

// export let NSMetadataItemOriginalFormatKey: string;
// global['NSMetadataItemOriginalFormatKey'] = NSMetadataItemOriginalFormatKey;

// export let NSMetadataItemOriginalSourceKey: string;
// global['NSMetadataItemOriginalSourceKey'] = NSMetadataItemOriginalSourceKey;

// export let NSMetadataItemPageHeightKey: string;
// global['NSMetadataItemPageHeightKey'] = NSMetadataItemPageHeightKey;

// export let NSMetadataItemPageWidthKey: string;
// global['NSMetadataItemPageWidthKey'] = NSMetadataItemPageWidthKey;

// export let NSMetadataItemParticipantsKey: string;
// global['NSMetadataItemParticipantsKey'] = NSMetadataItemParticipantsKey;

// export let NSMetadataItemPathKey: string;
// global['NSMetadataItemPathKey'] = NSMetadataItemPathKey;

// export let NSMetadataItemPerformersKey: string;
// global['NSMetadataItemPerformersKey'] = NSMetadataItemPerformersKey;

// export let NSMetadataItemPhoneNumbersKey: string;
// global['NSMetadataItemPhoneNumbersKey'] = NSMetadataItemPhoneNumbersKey;

// export let NSMetadataItemPixelCountKey: string;
// global['NSMetadataItemPixelCountKey'] = NSMetadataItemPixelCountKey;

// export let NSMetadataItemPixelHeightKey: string;
// global['NSMetadataItemPixelHeightKey'] = NSMetadataItemPixelHeightKey;

// export let NSMetadataItemPixelWidthKey: string;
// global['NSMetadataItemPixelWidthKey'] = NSMetadataItemPixelWidthKey;

// export let NSMetadataItemProducerKey: string;
// global['NSMetadataItemProducerKey'] = NSMetadataItemProducerKey;

// export let NSMetadataItemProfileNameKey: string;
// global['NSMetadataItemProfileNameKey'] = NSMetadataItemProfileNameKey;

// export let NSMetadataItemProjectsKey: string;
// global['NSMetadataItemProjectsKey'] = NSMetadataItemProjectsKey;

// export let NSMetadataItemPublishersKey: string;
// global['NSMetadataItemPublishersKey'] = NSMetadataItemPublishersKey;

// export let NSMetadataItemRecipientAddressesKey: string;
// global['NSMetadataItemRecipientAddressesKey'] = NSMetadataItemRecipientAddressesKey;

// export let NSMetadataItemRecipientEmailAddressesKey: string;
// global['NSMetadataItemRecipientEmailAddressesKey'] = NSMetadataItemRecipientEmailAddressesKey;

// export let NSMetadataItemRecipientsKey: string;
// global['NSMetadataItemRecipientsKey'] = NSMetadataItemRecipientsKey;

// export let NSMetadataItemRecordingDateKey: string;
// global['NSMetadataItemRecordingDateKey'] = NSMetadataItemRecordingDateKey;

// export let NSMetadataItemRecordingYearKey: string;
// global['NSMetadataItemRecordingYearKey'] = NSMetadataItemRecordingYearKey;

// export let NSMetadataItemRedEyeOnOffKey: string;
// global['NSMetadataItemRedEyeOnOffKey'] = NSMetadataItemRedEyeOnOffKey;

// export let NSMetadataItemResolutionHeightDPIKey: string;
// global['NSMetadataItemResolutionHeightDPIKey'] = NSMetadataItemResolutionHeightDPIKey;

// export let NSMetadataItemResolutionWidthDPIKey: string;
// global['NSMetadataItemResolutionWidthDPIKey'] = NSMetadataItemResolutionWidthDPIKey;

// export let NSMetadataItemRightsKey: string;
// global['NSMetadataItemRightsKey'] = NSMetadataItemRightsKey;

// export let NSMetadataItemSecurityMethodKey: string;
// global['NSMetadataItemSecurityMethodKey'] = NSMetadataItemSecurityMethodKey;

// export let NSMetadataItemSpeedKey: string;
// global['NSMetadataItemSpeedKey'] = NSMetadataItemSpeedKey;

// export let NSMetadataItemStarRatingKey: string;
// global['NSMetadataItemStarRatingKey'] = NSMetadataItemStarRatingKey;

// export let NSMetadataItemStateOrProvinceKey: string;
// global['NSMetadataItemStateOrProvinceKey'] = NSMetadataItemStateOrProvinceKey;

// export let NSMetadataItemStreamableKey: string;
// global['NSMetadataItemStreamableKey'] = NSMetadataItemStreamableKey;

// export let NSMetadataItemSubjectKey: string;
// global['NSMetadataItemSubjectKey'] = NSMetadataItemSubjectKey;

// export let NSMetadataItemTempoKey: string;
// global['NSMetadataItemTempoKey'] = NSMetadataItemTempoKey;

// export let NSMetadataItemTextContentKey: string;
// global['NSMetadataItemTextContentKey'] = NSMetadataItemTextContentKey;

// export let NSMetadataItemThemeKey: string;
// global['NSMetadataItemThemeKey'] = NSMetadataItemThemeKey;

// export let NSMetadataItemTimeSignatureKey: string;
// global['NSMetadataItemTimeSignatureKey'] = NSMetadataItemTimeSignatureKey;

// export let NSMetadataItemTimestampKey: string;
// global['NSMetadataItemTimestampKey'] = NSMetadataItemTimestampKey;

// export let NSMetadataItemTitleKey: string;
// global['NSMetadataItemTitleKey'] = NSMetadataItemTitleKey;

// export let NSMetadataItemTotalBitRateKey: string;
// global['NSMetadataItemTotalBitRateKey'] = NSMetadataItemTotalBitRateKey;

// export let NSMetadataItemURLKey: string;
// global['NSMetadataItemURLKey'] = NSMetadataItemURLKey;

// export let NSMetadataItemVersionKey: string;
// global['NSMetadataItemVersionKey'] = NSMetadataItemVersionKey;

// export let NSMetadataItemVideoBitRateKey: string;
// global['NSMetadataItemVideoBitRateKey'] = NSMetadataItemVideoBitRateKey;

// export let NSMetadataItemWhereFromsKey: string;
// global['NSMetadataItemWhereFromsKey'] = NSMetadataItemWhereFromsKey;

// export let NSMetadataItemWhiteBalanceKey: string;
// global['NSMetadataItemWhiteBalanceKey'] = NSMetadataItemWhiteBalanceKey;

// export let NSMetadataQueryAccessibleUbiquitousExternalDocumentsScope: string;
// global['NSMetadataQueryAccessibleUbiquitousExternalDocumentsScope'] = NSMetadataQueryAccessibleUbiquitousExternalDocumentsScope;

// export let NSMetadataQueryIndexedLocalComputerScope: string;
// global['NSMetadataQueryIndexedLocalComputerScope'] = NSMetadataQueryIndexedLocalComputerScope;

// export let NSMetadataQueryIndexedNetworkScope: string;
// global['NSMetadataQueryIndexedNetworkScope'] = NSMetadataQueryIndexedNetworkScope;

// export let NSMetadataQueryLocalComputerScope: string;
// global['NSMetadataQueryLocalComputerScope'] = NSMetadataQueryLocalComputerScope;

// export let NSMetadataQueryNetworkScope: string;
// global['NSMetadataQueryNetworkScope'] = NSMetadataQueryNetworkScope;

// export let NSMetadataQueryResultContentRelevanceAttribute: string;
// global['NSMetadataQueryResultContentRelevanceAttribute'] = NSMetadataQueryResultContentRelevanceAttribute;

// export let NSMetadataQueryUbiquitousDataScope: string;
// global['NSMetadataQueryUbiquitousDataScope'] = NSMetadataQueryUbiquitousDataScope;

// export let NSMetadataQueryUbiquitousDocumentsScope: string;
// global['NSMetadataQueryUbiquitousDocumentsScope'] = NSMetadataQueryUbiquitousDocumentsScope;

// export let NSMetadataQueryUpdateAddedItemsKey: string;
// global['NSMetadataQueryUpdateAddedItemsKey'] = NSMetadataQueryUpdateAddedItemsKey;

// export let NSMetadataQueryUpdateChangedItemsKey: string;
// global['NSMetadataQueryUpdateChangedItemsKey'] = NSMetadataQueryUpdateChangedItemsKey;

// export let NSMetadataQueryUpdateRemovedItemsKey: string;
// global['NSMetadataQueryUpdateRemovedItemsKey'] = NSMetadataQueryUpdateRemovedItemsKey;

// export let NSMetadataQueryUserHomeScope: string;
// global['NSMetadataQueryUserHomeScope'] = NSMetadataQueryUserHomeScope;

// export let NSMetadataUbiquitousItemContainerDisplayNameKey: string;
// global['NSMetadataUbiquitousItemContainerDisplayNameKey'] = NSMetadataUbiquitousItemContainerDisplayNameKey;

// export let NSMetadataUbiquitousItemDownloadRequestedKey: string;
// global['NSMetadataUbiquitousItemDownloadRequestedKey'] = NSMetadataUbiquitousItemDownloadRequestedKey;

// export let NSMetadataUbiquitousItemDownloadingErrorKey: string;
// global['NSMetadataUbiquitousItemDownloadingErrorKey'] = NSMetadataUbiquitousItemDownloadingErrorKey;

// export let NSMetadataUbiquitousItemDownloadingStatusCurrent: string;
// global['NSMetadataUbiquitousItemDownloadingStatusCurrent'] = NSMetadataUbiquitousItemDownloadingStatusCurrent;

// export let NSMetadataUbiquitousItemDownloadingStatusDownloaded: string;
// global['NSMetadataUbiquitousItemDownloadingStatusDownloaded'] = NSMetadataUbiquitousItemDownloadingStatusDownloaded;

// export let NSMetadataUbiquitousItemDownloadingStatusKey: string;
// global['NSMetadataUbiquitousItemDownloadingStatusKey'] = NSMetadataUbiquitousItemDownloadingStatusKey;

// export let NSMetadataUbiquitousItemDownloadingStatusNotDownloaded: string;
// global['NSMetadataUbiquitousItemDownloadingStatusNotDownloaded'] = NSMetadataUbiquitousItemDownloadingStatusNotDownloaded;

// export let NSMetadataUbiquitousItemHasUnresolvedConflictsKey: string;
// global['NSMetadataUbiquitousItemHasUnresolvedConflictsKey'] = NSMetadataUbiquitousItemHasUnresolvedConflictsKey;

// export let NSMetadataUbiquitousItemIsDownloadingKey: string;
// global['NSMetadataUbiquitousItemIsDownloadingKey'] = NSMetadataUbiquitousItemIsDownloadingKey;

// export let NSMetadataUbiquitousItemIsExternalDocumentKey: string;
// global['NSMetadataUbiquitousItemIsExternalDocumentKey'] = NSMetadataUbiquitousItemIsExternalDocumentKey;

// export let NSMetadataUbiquitousItemIsSharedKey: string;
// global['NSMetadataUbiquitousItemIsSharedKey'] = NSMetadataUbiquitousItemIsSharedKey;

// export let NSMetadataUbiquitousItemIsUploadedKey: string;
// global['NSMetadataUbiquitousItemIsUploadedKey'] = NSMetadataUbiquitousItemIsUploadedKey;

// export let NSMetadataUbiquitousItemIsUploadingKey: string;
// global['NSMetadataUbiquitousItemIsUploadingKey'] = NSMetadataUbiquitousItemIsUploadingKey;

// export let NSMetadataUbiquitousItemPercentDownloadedKey: string;
// global['NSMetadataUbiquitousItemPercentDownloadedKey'] = NSMetadataUbiquitousItemPercentDownloadedKey;

// export let NSMetadataUbiquitousItemPercentUploadedKey: string;
// global['NSMetadataUbiquitousItemPercentUploadedKey'] = NSMetadataUbiquitousItemPercentUploadedKey;

// export let NSMetadataUbiquitousItemURLInLocalContainerKey: string;
// global['NSMetadataUbiquitousItemURLInLocalContainerKey'] = NSMetadataUbiquitousItemURLInLocalContainerKey;

// export let NSMetadataUbiquitousItemUploadingErrorKey: string;
// global['NSMetadataUbiquitousItemUploadingErrorKey'] = NSMetadataUbiquitousItemUploadingErrorKey;

// export let NSMetadataUbiquitousSharedItemCurrentUserPermissionsKey: string;
// global['NSMetadataUbiquitousSharedItemCurrentUserPermissionsKey'] = NSMetadataUbiquitousSharedItemCurrentUserPermissionsKey;

// export let NSMetadataUbiquitousSharedItemCurrentUserRoleKey: string;
// global['NSMetadataUbiquitousSharedItemCurrentUserRoleKey'] = NSMetadataUbiquitousSharedItemCurrentUserRoleKey;

// export let NSMetadataUbiquitousSharedItemMostRecentEditorNameComponentsKey: string;
// global['NSMetadataUbiquitousSharedItemMostRecentEditorNameComponentsKey'] = NSMetadataUbiquitousSharedItemMostRecentEditorNameComponentsKey;

// export let NSMetadataUbiquitousSharedItemOwnerNameComponentsKey: string;
// global['NSMetadataUbiquitousSharedItemOwnerNameComponentsKey'] = NSMetadataUbiquitousSharedItemOwnerNameComponentsKey;

// export let NSMetadataUbiquitousSharedItemPermissionsReadOnly: string;
// global['NSMetadataUbiquitousSharedItemPermissionsReadOnly'] = NSMetadataUbiquitousSharedItemPermissionsReadOnly;

// export let NSMetadataUbiquitousSharedItemPermissionsReadWrite: string;
// global['NSMetadataUbiquitousSharedItemPermissionsReadWrite'] = NSMetadataUbiquitousSharedItemPermissionsReadWrite;

// export let NSMetadataUbiquitousSharedItemRoleOwner: string;
// global['NSMetadataUbiquitousSharedItemRoleOwner'] = NSMetadataUbiquitousSharedItemRoleOwner;

// export let NSMetadataUbiquitousSharedItemRoleParticipant: string;
// global['NSMetadataUbiquitousSharedItemRoleParticipant'] = NSMetadataUbiquitousSharedItemRoleParticipant;

// export let NSNonOwnedPointerHashCallBacks: NSHashTableCallBacks;
// global['NSNonOwnedPointerHashCallBacks'] = NSNonOwnedPointerHashCallBacks;

// export let NSNonOwnedPointerMapKeyCallBacks: NSMapTableKeyCallBacks;
// global['NSNonOwnedPointerMapKeyCallBacks'] = NSNonOwnedPointerMapKeyCallBacks;

// export let NSNonOwnedPointerMapValueCallBacks: NSMapTableValueCallBacks;
// global['NSNonOwnedPointerMapValueCallBacks'] = NSNonOwnedPointerMapValueCallBacks;

// export let NSNonOwnedPointerOrNullMapKeyCallBacks: NSMapTableKeyCallBacks;
// global['NSNonOwnedPointerOrNullMapKeyCallBacks'] = NSNonOwnedPointerOrNullMapKeyCallBacks;

// export let NSNonRetainedObjectHashCallBacks: NSHashTableCallBacks;
// global['NSNonRetainedObjectHashCallBacks'] = NSNonRetainedObjectHashCallBacks;

// export let NSNonRetainedObjectMapKeyCallBacks: NSMapTableKeyCallBacks;
// global['NSNonRetainedObjectMapKeyCallBacks'] = NSNonRetainedObjectMapKeyCallBacks;

// export let NSNonRetainedObjectMapValueCallBacks: NSMapTableValueCallBacks;
// global['NSNonRetainedObjectMapValueCallBacks'] = NSNonRetainedObjectMapValueCallBacks;

// export let NSNotFound: number;
// global['NSNotFound'] = NSNotFound;

// export let NSNotificationDeliverImmediately: DistributedNotificationCenter.Options;
// global['NSNotificationDeliverImmediately'] = NSNotificationDeliverImmediately;

// export let NSNotificationPostToAllSessions: DistributedNotificationCenter.Options;
// global['NSNotificationPostToAllSessions'] = NSNotificationPostToAllSessions;

// export let NSOSStatusErrorDomain: string;
// global['NSOSStatusErrorDomain'] = NSOSStatusErrorDomain;

// export let NSObjectHashCallBacks: NSHashTableCallBacks;
// global['NSObjectHashCallBacks'] = NSObjectHashCallBacks;

// export let NSObjectMapKeyCallBacks: NSMapTableKeyCallBacks;
// global['NSObjectMapKeyCallBacks'] = NSObjectMapKeyCallBacks;

// export let NSObjectMapValueCallBacks: NSMapTableValueCallBacks;
// global['NSObjectMapValueCallBacks'] = NSObjectMapValueCallBacks;

// export let NSOperationNotSupportedForKeyException: string;
// global['NSOperationNotSupportedForKeyException'] = NSOperationNotSupportedForKeyException;

// export let NSOwnedObjectIdentityHashCallBacks: NSHashTableCallBacks;
// global['NSOwnedObjectIdentityHashCallBacks'] = NSOwnedObjectIdentityHashCallBacks;

// export let NSOwnedPointerHashCallBacks: NSHashTableCallBacks;
// global['NSOwnedPointerHashCallBacks'] = NSOwnedPointerHashCallBacks;

// export let NSOwnedPointerMapKeyCallBacks: NSMapTableKeyCallBacks;
// global['NSOwnedPointerMapKeyCallBacks'] = NSOwnedPointerMapKeyCallBacks;

// export let NSOwnedPointerMapValueCallBacks: NSMapTableValueCallBacks;
// global['NSOwnedPointerMapValueCallBacks'] = NSOwnedPointerMapValueCallBacks;

// export let NSPOSIXErrorDomain: string;
// global['NSPOSIXErrorDomain'] = NSPOSIXErrorDomain;

// export let NSPersonNameComponentDelimiter: string;
// global['NSPersonNameComponentDelimiter'] = NSPersonNameComponentDelimiter;

// export let NSPersonNameComponentFamilyName: string;
// global['NSPersonNameComponentFamilyName'] = NSPersonNameComponentFamilyName;

// export let NSPersonNameComponentGivenName: string;
// global['NSPersonNameComponentGivenName'] = NSPersonNameComponentGivenName;

// export let NSPersonNameComponentKey: string;
// global['NSPersonNameComponentKey'] = NSPersonNameComponentKey;

// export let NSPersonNameComponentMiddleName: string;
// global['NSPersonNameComponentMiddleName'] = NSPersonNameComponentMiddleName;

// export let NSPersonNameComponentNickname: string;
// global['NSPersonNameComponentNickname'] = NSPersonNameComponentNickname;

// export let NSPersonNameComponentPrefix: string;
// global['NSPersonNameComponentPrefix'] = NSPersonNameComponentPrefix;

// export let NSPersonNameComponentSuffix: string;
// global['NSPersonNameComponentSuffix'] = NSPersonNameComponentSuffix;

// export let NSPointerToStructHashCallBacks: NSHashTableCallBacks;
// global['NSPointerToStructHashCallBacks'] = NSPointerToStructHashCallBacks;

// export let NSRecoveryAttempterErrorKey: string;
// global['NSRecoveryAttempterErrorKey'] = NSRecoveryAttempterErrorKey;

// export let NSStreamSOCKSErrorDomain: string;
// global['NSStreamSOCKSErrorDomain'] = NSStreamSOCKSErrorDomain;

// export let NSStreamSocketSSLErrorDomain: string;
// global['NSStreamSocketSSLErrorDomain'] = NSStreamSocketSSLErrorDomain;

// export let NSStringEncodingErrorKey: string;
// global['NSStringEncodingErrorKey'] = NSStringEncodingErrorKey;

// export let NSURLAuthenticationMethodClientCertificate: string;
// global['NSURLAuthenticationMethodClientCertificate'] = NSURLAuthenticationMethodClientCertificate;

// export let NSURLAuthenticationMethodDefault: string;
// global['NSURLAuthenticationMethodDefault'] = NSURLAuthenticationMethodDefault;

// export let NSURLAuthenticationMethodHTMLForm: string;
// global['NSURLAuthenticationMethodHTMLForm'] = NSURLAuthenticationMethodHTMLForm;

// export let NSURLAuthenticationMethodHTTPBasic: string;
// global['NSURLAuthenticationMethodHTTPBasic'] = NSURLAuthenticationMethodHTTPBasic;

// export let NSURLAuthenticationMethodHTTPDigest: string;
// global['NSURLAuthenticationMethodHTTPDigest'] = NSURLAuthenticationMethodHTTPDigest;

// export let NSURLAuthenticationMethodNTLM: string;
// global['NSURLAuthenticationMethodNTLM'] = NSURLAuthenticationMethodNTLM;

// export let NSURLAuthenticationMethodNegotiate: string;
// global['NSURLAuthenticationMethodNegotiate'] = NSURLAuthenticationMethodNegotiate;

// export let NSURLAuthenticationMethodServerTrust: string;
// global['NSURLAuthenticationMethodServerTrust'] = NSURLAuthenticationMethodServerTrust;

// export let NSURLCredentialStorageRemoveSynchronizableCredentials: string;
// global['NSURLCredentialStorageRemoveSynchronizableCredentials'] = NSURLCredentialStorageRemoveSynchronizableCredentials;

// export let NSURLErrorBackgroundTaskCancelledReasonKey: string;
// global['NSURLErrorBackgroundTaskCancelledReasonKey'] = NSURLErrorBackgroundTaskCancelledReasonKey;

// export let NSURLErrorDomain: string;
// global['NSURLErrorDomain'] = NSURLErrorDomain;

// export let NSURLErrorFailingURLErrorKey: string;
// global['NSURLErrorFailingURLErrorKey'] = NSURLErrorFailingURLErrorKey;

// export let NSURLErrorFailingURLPeerTrustErrorKey: string;
// global['NSURLErrorFailingURLPeerTrustErrorKey'] = NSURLErrorFailingURLPeerTrustErrorKey;

// export let NSURLErrorFailingURLStringErrorKey: string;
// global['NSURLErrorFailingURLStringErrorKey'] = NSURLErrorFailingURLStringErrorKey;

// export let NSURLErrorKey: string;
// global['NSURLErrorKey'] = NSURLErrorKey;

// export let NSURLErrorNetworkUnavailableReasonKey: string;
// global['NSURLErrorNetworkUnavailableReasonKey'] = NSURLErrorNetworkUnavailableReasonKey;

// export let NSURLFileScheme: string;
// global['NSURLFileScheme'] = NSURLFileScheme;

// export let NSURLProtectionSpaceFTP: string;
// global['NSURLProtectionSpaceFTP'] = NSURLProtectionSpaceFTP;

// export let NSURLProtectionSpaceFTPProxy: string;
// global['NSURLProtectionSpaceFTPProxy'] = NSURLProtectionSpaceFTPProxy;

// export let NSURLProtectionSpaceHTTP: string;
// global['NSURLProtectionSpaceHTTP'] = NSURLProtectionSpaceHTTP;

// export let NSURLProtectionSpaceHTTPProxy: string;
// global['NSURLProtectionSpaceHTTPProxy'] = NSURLProtectionSpaceHTTPProxy;

// export let NSURLProtectionSpaceHTTPS: string;
// global['NSURLProtectionSpaceHTTPS'] = NSURLProtectionSpaceHTTPS;

// export let NSURLProtectionSpaceHTTPSProxy: string;
// global['NSURLProtectionSpaceHTTPSProxy'] = NSURLProtectionSpaceHTTPSProxy;

// export let NSURLProtectionSpaceSOCKSProxy: string;
// global['NSURLProtectionSpaceSOCKSProxy'] = NSURLProtectionSpaceSOCKSProxy;

// export let NSURLSessionDownloadTaskResumeData: string;
// global['NSURLSessionDownloadTaskResumeData'] = NSURLSessionDownloadTaskResumeData;

// export let NSURLSessionTransferSizeUnknown: number;
// global['NSURLSessionTransferSizeUnknown'] = NSURLSessionTransferSizeUnknown;

// export let NSUbiquitousKeyValueStoreChangeReasonKey: string;
// global['NSUbiquitousKeyValueStoreChangeReasonKey'] = NSUbiquitousKeyValueStoreChangeReasonKey;

// export let NSUbiquitousKeyValueStoreChangedKeysKey: string;
// global['NSUbiquitousKeyValueStoreChangedKeysKey'] = NSUbiquitousKeyValueStoreChangedKeysKey;

// export let NSUnderlyingErrorKey: string;
// global['NSUnderlyingErrorKey'] = NSUnderlyingErrorKey;

// export let NSUndoCloseGroupingRunLoopOrdering: number;
// global['NSUndoCloseGroupingRunLoopOrdering'] = NSUndoCloseGroupingRunLoopOrdering;

// export let NSUndoManagerGroupIsDiscardableKey: string;
// global['NSUndoManagerGroupIsDiscardableKey'] = NSUndoManagerGroupIsDiscardableKey;

// export let NSUserActivityTypeBrowsingWeb: string;
// global['NSUserActivityTypeBrowsingWeb'] = NSUserActivityTypeBrowsingWeb;

// export let NSUserNotificationDefaultSoundName: string;
// global['NSUserNotificationDefaultSoundName'] = NSUserNotificationDefaultSoundName;

// export let NSZeroPoint: CGPoint;
// global['NSZeroPoint'] = NSZeroPoint;

// export let NSZeroRect: CGRect;
// global['NSZeroRect'] = NSZeroRect;

// export let NSZeroSize: CGSize;
// global['NSZeroSize'] = NSZeroSize;

// export let NSZombieEnabled: boolean;
// global['NSZombieEnabled'] = NSZombieEnabled;

// export let IKFilterBrowserDefaultInputImage: string;
// global['IKFilterBrowserDefaultInputImage'] = IKFilterBrowserDefaultInputImage;

// export let IKFilterBrowserExcludeCategories: string;
// global['IKFilterBrowserExcludeCategories'] = IKFilterBrowserExcludeCategories;

// export let IKFilterBrowserExcludeFilters: string;
// global['IKFilterBrowserExcludeFilters'] = IKFilterBrowserExcludeFilters;

// export let IKFilterBrowserShowCategories: string;
// global['IKFilterBrowserShowCategories'] = IKFilterBrowserShowCategories;

// export let IKFilterBrowserShowPreview: string;
// global['IKFilterBrowserShowPreview'] = IKFilterBrowserShowPreview;

// export let IKImageBrowserBackgroundColorKey: string;
// global['IKImageBrowserBackgroundColorKey'] = IKImageBrowserBackgroundColorKey;

// export let IKImageBrowserCGImageRepresentationType: string;
// global['IKImageBrowserCGImageRepresentationType'] = IKImageBrowserCGImageRepresentationType;

// export let IKImageBrowserCGImageSourceRepresentationType: string;
// global['IKImageBrowserCGImageSourceRepresentationType'] = IKImageBrowserCGImageSourceRepresentationType;

// export let IKImageBrowserCellBackgroundLayer: string;
// global['IKImageBrowserCellBackgroundLayer'] = IKImageBrowserCellBackgroundLayer;

// export let IKImageBrowserCellForegroundLayer: string;
// global['IKImageBrowserCellForegroundLayer'] = IKImageBrowserCellForegroundLayer;

// export let IKImageBrowserCellPlaceHolderLayer: string;
// global['IKImageBrowserCellPlaceHolderLayer'] = IKImageBrowserCellPlaceHolderLayer;

// export let IKImageBrowserCellSelectionLayer: string;
// global['IKImageBrowserCellSelectionLayer'] = IKImageBrowserCellSelectionLayer;

// export let IKImageBrowserCellsHighlightedTitleAttributesKey: string;
// global['IKImageBrowserCellsHighlightedTitleAttributesKey'] = IKImageBrowserCellsHighlightedTitleAttributesKey;

// export let IKImageBrowserCellsOutlineColorKey: string;
// global['IKImageBrowserCellsOutlineColorKey'] = IKImageBrowserCellsOutlineColorKey;

// export let IKImageBrowserCellsSubtitleAttributesKey: string;
// global['IKImageBrowserCellsSubtitleAttributesKey'] = IKImageBrowserCellsSubtitleAttributesKey;

// export let IKImageBrowserCellsTitleAttributesKey: string;
// global['IKImageBrowserCellsTitleAttributesKey'] = IKImageBrowserCellsTitleAttributesKey;

// export let IKImageBrowserGroupBackgroundColorKey: string;
// global['IKImageBrowserGroupBackgroundColorKey'] = IKImageBrowserGroupBackgroundColorKey;

// export let IKImageBrowserGroupFooterLayer: string;
// global['IKImageBrowserGroupFooterLayer'] = IKImageBrowserGroupFooterLayer;

// export let IKImageBrowserGroupHeaderLayer: string;
// global['IKImageBrowserGroupHeaderLayer'] = IKImageBrowserGroupHeaderLayer;

// export let IKImageBrowserGroupRangeKey: string;
// global['IKImageBrowserGroupRangeKey'] = IKImageBrowserGroupRangeKey;

// export let IKImageBrowserGroupStyleKey: string;
// global['IKImageBrowserGroupStyleKey'] = IKImageBrowserGroupStyleKey;

// export let IKImageBrowserGroupTitleKey: string;
// global['IKImageBrowserGroupTitleKey'] = IKImageBrowserGroupTitleKey;

// export let IKImageBrowserIconRefPathRepresentationType: string;
// global['IKImageBrowserIconRefPathRepresentationType'] = IKImageBrowserIconRefPathRepresentationType;

// export let IKImageBrowserIconRefRepresentationType: string;
// global['IKImageBrowserIconRefRepresentationType'] = IKImageBrowserIconRefRepresentationType;

// export let IKImageBrowserNSBitmapImageRepresentationType: string;
// global['IKImageBrowserNSBitmapImageRepresentationType'] = IKImageBrowserNSBitmapImageRepresentationType;

// export let IKImageBrowserNSDataRepresentationType: string;
// global['IKImageBrowserNSDataRepresentationType'] = IKImageBrowserNSDataRepresentationType;

// export let IKImageBrowserNSImageRepresentationType: string;
// global['IKImageBrowserNSImageRepresentationType'] = IKImageBrowserNSImageRepresentationType;

// export let IKImageBrowserNSURLRepresentationType: string;
// global['IKImageBrowserNSURLRepresentationType'] = IKImageBrowserNSURLRepresentationType;

// export let IKImageBrowserPDFPageRepresentationType: string;
// global['IKImageBrowserPDFPageRepresentationType'] = IKImageBrowserPDFPageRepresentationType;

// export let IKImageBrowserPathRepresentationType: string;
// global['IKImageBrowserPathRepresentationType'] = IKImageBrowserPathRepresentationType;

// export let IKImageBrowserQCCompositionPathRepresentationType: string;
// global['IKImageBrowserQCCompositionPathRepresentationType'] = IKImageBrowserQCCompositionPathRepresentationType;

// export let IKImageBrowserQCCompositionRepresentationType: string;
// global['IKImageBrowserQCCompositionRepresentationType'] = IKImageBrowserQCCompositionRepresentationType;

// export let IKImageBrowserQTMoviePathRepresentationType: string;
// global['IKImageBrowserQTMoviePathRepresentationType'] = IKImageBrowserQTMoviePathRepresentationType;

// export let IKImageBrowserQTMovieRepresentationType: string;
// global['IKImageBrowserQTMovieRepresentationType'] = IKImageBrowserQTMovieRepresentationType;

// export let IKImageBrowserQuickLookPathRepresentationType: string;
// global['IKImageBrowserQuickLookPathRepresentationType'] = IKImageBrowserQuickLookPathRepresentationType;

// export let IKImageBrowserSelectionColorKey: string;
// global['IKImageBrowserSelectionColorKey'] = IKImageBrowserSelectionColorKey;

// export let IKOverlayTypeBackground: string;
// global['IKOverlayTypeBackground'] = IKOverlayTypeBackground;

// export let IKOverlayTypeImage: string;
// global['IKOverlayTypeImage'] = IKOverlayTypeImage;

// export let IKPictureTakerAllowsEditingKey: string;
// global['IKPictureTakerAllowsEditingKey'] = IKPictureTakerAllowsEditingKey;

// export let IKPictureTakerAllowsFileChoosingKey: string;
// global['IKPictureTakerAllowsFileChoosingKey'] = IKPictureTakerAllowsFileChoosingKey;

// export let IKPictureTakerAllowsVideoCaptureKey: string;
// global['IKPictureTakerAllowsVideoCaptureKey'] = IKPictureTakerAllowsVideoCaptureKey;

// export let IKPictureTakerCropAreaSizeKey: string;
// global['IKPictureTakerCropAreaSizeKey'] = IKPictureTakerCropAreaSizeKey;

// export let IKPictureTakerImageTransformsKey: string;
// global['IKPictureTakerImageTransformsKey'] = IKPictureTakerImageTransformsKey;

// export let IKPictureTakerInformationalTextKey: string;
// global['IKPictureTakerInformationalTextKey'] = IKPictureTakerInformationalTextKey;

// export let IKPictureTakerOutputImageMaxSizeKey: string;
// global['IKPictureTakerOutputImageMaxSizeKey'] = IKPictureTakerOutputImageMaxSizeKey;

// export let IKPictureTakerRemainOpenAfterValidateKey: string;
// global['IKPictureTakerRemainOpenAfterValidateKey'] = IKPictureTakerRemainOpenAfterValidateKey;

// export let IKPictureTakerShowAddressBookPicture: string;
// global['IKPictureTakerShowAddressBookPicture'] = IKPictureTakerShowAddressBookPicture;

// export let IKPictureTakerShowAddressBookPictureKey: string;
// global['IKPictureTakerShowAddressBookPictureKey'] = IKPictureTakerShowAddressBookPictureKey;

// export let IKPictureTakerShowEffectsKey: string;
// global['IKPictureTakerShowEffectsKey'] = IKPictureTakerShowEffectsKey;

// export let IKPictureTakerShowEmptyPicture: string;
// global['IKPictureTakerShowEmptyPicture'] = IKPictureTakerShowEmptyPicture;

// export let IKPictureTakerShowEmptyPictureKey: string;
// global['IKPictureTakerShowEmptyPictureKey'] = IKPictureTakerShowEmptyPictureKey;

// export let IKPictureTakerShowRecentPictureKey: string;
// global['IKPictureTakerShowRecentPictureKey'] = IKPictureTakerShowRecentPictureKey;

// export let IKPictureTakerUpdateRecentPictureKey: string;
// global['IKPictureTakerUpdateRecentPictureKey'] = IKPictureTakerUpdateRecentPictureKey;

// export let IKSlideshowAudioFile: string;
// global['IKSlideshowAudioFile'] = IKSlideshowAudioFile;

// export let IKSlideshowModeImages: string;
// global['IKSlideshowModeImages'] = IKSlideshowModeImages;

// export let IKSlideshowModeOther: string;
// global['IKSlideshowModeOther'] = IKSlideshowModeOther;

// export let IKSlideshowModePDF: string;
// global['IKSlideshowModePDF'] = IKSlideshowModePDF;

// export let IKSlideshowPDFDisplayBox: string;
// global['IKSlideshowPDFDisplayBox'] = IKSlideshowPDFDisplayBox;

// export let IKSlideshowPDFDisplayMode: string;
// global['IKSlideshowPDFDisplayMode'] = IKSlideshowPDFDisplayMode;

// export let IKSlideshowPDFDisplaysAsBook: string;
// global['IKSlideshowPDFDisplaysAsBook'] = IKSlideshowPDFDisplaysAsBook;

// export let IKSlideshowScreen: string;
// global['IKSlideshowScreen'] = IKSlideshowScreen;

// export let IKSlideshowStartIndex: string;
// global['IKSlideshowStartIndex'] = IKSlideshowStartIndex;

// export let IKSlideshowStartPaused: string;
// global['IKSlideshowStartPaused'] = IKSlideshowStartPaused;

// export let IKSlideshowWrapAround: string;
// global['IKSlideshowWrapAround'] = IKSlideshowWrapAround;

// export let IKToolModeAnnotate: string;
// global['IKToolModeAnnotate'] = IKToolModeAnnotate;

// export let IKToolModeCrop: string;
// global['IKToolModeCrop'] = IKToolModeCrop;

// export let IKToolModeMove: string;
// global['IKToolModeMove'] = IKToolModeMove;

// export let IKToolModeNone: string;
// global['IKToolModeNone'] = IKToolModeNone;

// export let IKToolModeRotate: string;
// global['IKToolModeRotate'] = IKToolModeRotate;

// export let IKToolModeSelect: string;
// global['IKToolModeSelect'] = IKToolModeSelect;

// export let IKToolModeSelectEllipse: string;
// global['IKToolModeSelectEllipse'] = IKToolModeSelectEllipse;

// export let IKToolModeSelectLasso: string;
// global['IKToolModeSelectLasso'] = IKToolModeSelectLasso;

// export let IKToolModeSelectRect: string;
// global['IKToolModeSelectRect'] = IKToolModeSelectRect;

// export let IKUIFlavorAllowFallback: string;
// global['IKUIFlavorAllowFallback'] = IKUIFlavorAllowFallback;

// export let IKUISizeFlavor: string;
// global['IKUISizeFlavor'] = IKUISizeFlavor;

// export let IKUISizeMini: string;
// global['IKUISizeMini'] = IKUISizeMini;

// export let IKUISizeRegular: string;
// global['IKUISizeRegular'] = IKUISizeRegular;

// export let IKUISizeSmall: string;
// global['IKUISizeSmall'] = IKUISizeSmall;

// export let IKUImaxSize: string;
// global['IKUImaxSize'] = IKUImaxSize;

// export let IK_ApertureBundleIdentifier: string;
// global['IK_ApertureBundleIdentifier'] = IK_ApertureBundleIdentifier;

// export let IK_MailBundleIdentifier: string;
// global['IK_MailBundleIdentifier'] = IK_MailBundleIdentifier;

// export let IK_PhotosBundleIdentifier: string;
// global['IK_PhotosBundleIdentifier'] = IK_PhotosBundleIdentifier;

// export let IK_iPhotoBundleIdentifier: string;
// global['IK_iPhotoBundleIdentifier'] = IK_iPhotoBundleIdentifier;

// export let QCCompositionInputPaceKey: string;
// global['QCCompositionInputPaceKey'] = QCCompositionInputPaceKey;

// export let globalUpdateOK: boolean;
// global['globalUpdateOK'] = globalUpdateOK;

// export let kQuartzFilterApplicationDomain: string;
// global['kQuartzFilterApplicationDomain'] = kQuartzFilterApplicationDomain;

// export let kQuartzFilterPDFWorkflowDomain: string;
// global['kQuartzFilterPDFWorkflowDomain'] = kQuartzFilterPDFWorkflowDomain;

// export let kQuartzFilterPrintingDomain: string;
// global['kQuartzFilterPrintingDomain'] = kQuartzFilterPrintingDomain;

// export let CATransform3DIdentity: CATransform3D;
// global['CATransform3DIdentity'] = CATransform3DIdentity;

// export let kCAOnOrderIn: string;
// global['kCAOnOrderIn'] = kCAOnOrderIn;

// export let kCAOnOrderOut: string;
// global['kCAOnOrderOut'] = kCAOnOrderOut;

// export let kCARendererColorSpace: string;
// global['kCARendererColorSpace'] = kCARendererColorSpace;

// export let kCARendererMetalCommandQueue: string;
// global['kCARendererMetalCommandQueue'] = kCARendererMetalCommandQueue;

// export let kCATransactionAnimationDuration: string;
// global['kCATransactionAnimationDuration'] = kCATransactionAnimationDuration;

// export let kCATransactionAnimationTimingFunction: string;
// global['kCATransactionAnimationTimingFunction'] = kCATransactionAnimationTimingFunction;

// export let kCATransactionCompletionBlock: string;
// global['kCATransactionCompletionBlock'] = kCATransactionCompletionBlock;

// export let kCATransactionDisableActions: string;
// global['kCATransactionDisableActions'] = kCATransactionDisableActions;

// export let kCATransition: string;
// global['kCATransition'] = kCATransition;

export {
  AVAsset,
  AVAssetCache,
  AVAssetExportSession,
  AVAssetImageGenerator,
  AVAssetReader,
  AVAssetReaderAudioMixOutput,
  AVAssetReaderOutput,
  AVAssetReaderOutputMetadataAdaptor,
  AVAssetReaderSampleReferenceOutput,
  AVAssetReaderTrackOutput,
  AVAssetReaderVideoCompositionOutput,
  AVAssetResourceLoader,
  AVAssetResourceLoaderDelegate,
  AVAssetResourceLoadingContentInformationRequest,
  AVAssetResourceLoadingDataRequest,
  AVAssetResourceLoadingRequest,
  AVAssetResourceLoadingRequestor,
  AVAssetResourceRenewalRequest,
  AVAssetTrack,
  AVAssetTrackGroup,
  AVAssetTrackSegment,
  AVAssetWriter,
  AVAssetWriterInput,
  AVAssetWriterInputGroup,
  AVAssetWriterInputMetadataAdaptor,
  AVAssetWriterInputPassDescription,
  AVAssetWriterInputPixelBufferAdaptor,
  AVAsynchronousCIImageFilteringRequest,
  AVAsynchronousKeyValueLoading,
  AVAsynchronousVideoCompositionRequest,
  AVAudio3DMixing,
  AVAudioBuffer,
  AVAudioChannelLayout,
  AVAudioCompressedBuffer,
  AVAudioConnectionPoint,
  AVAudioConverter,
  AVAudioEngine,
  AVAudioEnvironmentDistanceAttenuationParameters,
  AVAudioEnvironmentNode,
  AVAudioEnvironmentReverbParameters,
  AVAudioFile,
  AVAudioFormat,
  AVAudioIONode,
  AVAudioInputNode,
  AVAudioMix,
  AVAudioMixInputParameters,
  AVAudioMixerNode,
  AVAudioMixing,
  AVAudioMixingDestination,
  AVAudioNode,
  AVAudioOutputNode,
  AVAudioPCMBuffer,
  AVAudioPlayer,
  AVAudioPlayerDelegate,
  AVAudioPlayerNode,
  AVAudioRecorder,
  AVAudioRecorderDelegate,
  AVAudioSequencer,
  AVAudioSession,
  AVAudioSinkNode,
  AVAudioSourceNode,
  AVAudioStereoMixing,
  AVAudioTime,
  AVAudioTimePitchAlgorithm,
  AVAudioUnit,
  AVAudioUnitComponent,
  AVAudioUnitComponentManager,
  AVAudioUnitDelay,
  AVAudioUnitDistortion,
  AVAudioUnitEQ,
  AVAudioUnitEQFilterParameters,
  AVAudioUnitEffect,
  AVAudioUnitGenerator,
  AVAudioUnitMIDIInstrument,
  AVAudioUnitReverb,
  AVAudioUnitSampler,
  AVAudioUnitTimeEffect,
  AVAudioUnitTimePitch,
  AVAudioUnitVarispeed,
  AVCameraCalibrationData,
  AVCaptureAudioChannel,
  AVCaptureAudioDataOutput,
  AVCaptureAudioDataOutputSampleBufferDelegate,
  AVCaptureAudioFileOutput,
  AVCaptureAudioPreviewOutput,
  AVCaptureConnection,
  AVCaptureDevice,
  AVCaptureDeviceInput,
  AVCaptureFileOutput,
  AVCaptureFileOutputDelegate,
  AVCaptureFileOutputRecordingDelegate,
  AVCaptureInput,
  AVCaptureMovieFileOutput,
  AVCaptureOutput,
  AVCapturePhoto,
  AVCapturePhotoCaptureDelegate,
  AVCapturePhotoOutput,
  AVCapturePhotoSettings,
  AVCaptureResolvedPhotoSettings,
  AVCaptureScreenInput,
  AVCaptureSession,
  AVCaptureVideoDataOutput,
  AVCaptureVideoDataOutputSampleBufferDelegate,
  AVCaptureVideoPreviewLayer,
  AVCaptureView,
  AVCaptureViewDelegate,
  AVComposition,
  AVCompositionTrack,
  AVCompositionTrackFormatDescriptionReplacement,
  AVCompositionTrackSegment,
  AVContentKeyRecipient,
  AVContentKeyRequest,
  AVContentKeyResponse,
  AVContentKeySession,
  AVContentKeySessionDelegate,
  AVContentKeySessionServerPlaybackContextOption,
  AVContentKeySystem,
  AVDateRangeMetadataGroup,
  AVDepthData,
  AVFileType,
  AVFragmentMinding,
  AVFragmentedAsset,
  AVFragmentedAssetMinder,
  AVFragmentedAssetTrack,
  AVFragmentedMovie,
  AVFragmentedMovieMinder,
  AVFragmentedMovieTrack,
  AVFrameRateRange,
  AVLayerVideoGravity,
  AVMIDIPlayer,
  AVMediaCharacteristic,
  AVMediaDataStorage,
  AVMediaSelection,
  AVMediaSelectionGroup,
  AVMediaSelectionOption,
  AVMediaType,
  AVMetadataBodyObject,
  AVMetadataCatBodyObject,
  AVMetadataDogBodyObject,
  AVMetadataExtraAttributeKey,
  AVMetadataFaceObject,
  AVMetadataFormat,
  AVMetadataGroup,
  AVMetadataHumanBodyObject,
  AVMetadataIdentifier,
  AVMetadataItem,
  AVMetadataItemFilter,
  AVMetadataItemValueRequest,
  AVMetadataKey,
  AVMetadataKeySpace,
  AVMetadataMachineReadableCodeObject,
  AVMetadataObject,
  AVMetadataSalientObject,
  AVMovie,
  AVMovieTrack,
  AVMusicTrack,
  AVMutableAudioMix,
  AVMutableAudioMixInputParameters,
  AVMutableComposition,
  AVMutableCompositionTrack,
  AVMutableDateRangeMetadataGroup,
  AVMutableMediaSelection,
  AVMutableMetadataItem,
  AVMutableMovie,
  AVMutableMovieTrack,
  AVMutableTimedMetadataGroup,
  AVMutableVideoComposition,
  AVMutableVideoCompositionInstruction,
  AVMutableVideoCompositionLayerInstruction,
  AVOutputSettingsAssistant,
  AVOutputSettingsPreset,
  AVPersistableContentKeyRequest,
  AVPictureInPictureController,
  AVPictureInPictureControllerDelegate,
  AVPlayer,
  AVPlayerItem,
  AVPlayerItemAccessLog,
  AVPlayerItemAccessLogEvent,
  AVPlayerItemErrorLog,
  AVPlayerItemErrorLogEvent,
  AVPlayerItemLegibleOutput,
  AVPlayerItemLegibleOutputPushDelegate,
  AVPlayerItemMediaDataCollector,
  AVPlayerItemMetadataCollector,
  AVPlayerItemMetadataCollectorPushDelegate,
  AVPlayerItemMetadataOutput,
  AVPlayerItemMetadataOutputPushDelegate,
  AVPlayerItemOutput,
  AVPlayerItemOutputPullDelegate,
  AVPlayerItemOutputPushDelegate,
  AVPlayerItemTrack,
  AVPlayerItemVideoOutput,
  AVPlayerLayer,
  AVPlayerLooper,
  AVPlayerMediaSelectionCriteria,
  AVPlayerView,
  AVPlayerViewPictureInPictureDelegate,
  AVPortraitEffectsMatte,
  AVQueuePlayer,
  AVQueuedSampleBufferRendering,
  AVRouteDetector,
  AVRoutePickerView,
  AVRoutePickerViewDelegate,
  AVSampleBufferAudioRenderer,
  AVSampleBufferDisplayLayer,
  AVSampleBufferGenerator,
  AVSampleBufferRenderSynchronizer,
  AVSampleBufferRequest,
  AVSampleCursor,
  AVSemanticSegmentationMatte,
  AVSpeechSynthesisVoice,
  AVSpeechSynthesizer,
  AVSpeechSynthesizerDelegate,
  AVSpeechUtterance,
  AVSynchronizedLayer,
  AVTextStyleRule,
  AVTimedMetadataGroup,
  AVURLAsset,
  AVVideoApertureMode,
  AVVideoCodecType,
  AVVideoCompositing,
  AVVideoComposition,
  AVVideoCompositionCoreAnimationTool,
  AVVideoCompositionInstruction,
  AVVideoCompositionLayerInstruction,
  AVVideoCompositionRenderContext,
  AVVideoCompositionRenderHint,
  AVVideoCompositionValidationHandling,
  Authorization,
  BlockOperation,
  Bundle,
  ByteCountFormatter,
  CAAction,
  CAAnimation,
  CAAnimationCalculationMode,
  CAAnimationDelegate,
  CAAnimationGroup,
  CAAnimationRotationMode,
  CABasicAnimation,
  CAConstraint,
  CAConstraintLayoutManager,
  CAEDRMetadata,
  CAEmitterCell,
  CAEmitterLayer,
  CAEmitterLayerEmitterMode,
  CAEmitterLayerEmitterShape,
  CAEmitterLayerRenderMode,
  CAGradientLayer,
  CAGradientLayerType,
  CAKeyframeAnimation,
  CALayer,
  CALayerContentsFilter,
  CALayerContentsFormat,
  CALayerContentsGravity,
  CALayerCornerCurve,
  CALayerDelegate,
  CALayoutManager,
  CAMediaTiming,
  CAMediaTimingFillMode,
  CAMediaTimingFunction,
  CAMediaTimingFunctionName,
  CAMetalDrawable,
  CAMetalLayer,
  CAPropertyAnimation,
  CARemoteLayerClient,
  CARemoteLayerServer,
  CARenderer,
  CAReplicatorLayer,
  CAScrollLayer,
  CAScrollLayerScrollMode,
  CAShapeLayer,
  CAShapeLayerFillRule,
  CAShapeLayerLineCap,
  CAShapeLayerLineJoin,
  CASpringAnimation,
  CATextLayer,
  CATextLayerAlignmentMode,
  CATextLayerTruncationMode,
  CATiledLayer,
  CATransaction,
  CATransformLayer,
  CATransition,
  CATransitionSubtype,
  CATransitionType,
  CAValueFunction,
  CAValueFunctionName,
  CFCalendarIdentifier,
  CFDateFormatterKey,
  CFLocaleKey,
  CFNotificationName,
  CFNumberFormatterKey,
  CFRunLoopMode,
  CFStreamPropertyKey,
  CGAffineTransform,
  CGColor,
  CGColorSpace,
  CGDisplayStream,
  CGFont,
  CGPDFTagProperty,
  CGPoint,
  CGRect,
  CGSize,
  CIAccordionFoldTransition,
  CIAffineClamp,
  CIAffineTile,
  CIAttributedTextImageGenerator,
  CIAztecCodeDescriptor,
  CIAztecCodeGenerator,
  CIBarcodeDescriptor,
  CIBarcodeGenerator,
  CIBarsSwipeTransition,
  CIBicubicScaleTransform,
  CIBlendKernel,
  CIBlendWithMask,
  CIBloom,
  CIBokehBlur,
  CIBoxBlur,
  CICMYKHalftone,
  CICheckerboardGenerator,
  CICircularScreen,
  CICode128BarcodeGenerator,
  CIColor,
  CIColorClamp,
  CIColorControls,
  CIColorCrossPolynomial,
  CIColorCube,
  CIColorCubeWithColorSpace,
  CIColorCubesMixedWithMask,
  CIColorCurves,
  CIColorInvert,
  CIColorKernel,
  CIColorMap,
  CIColorMatrix,
  CIColorMonochrome,
  CIColorPolynomial,
  CIColorPosterize,
  CIComicEffect,
  CICompositeOperation,
  CIContext,
  CIContextOption,
  CIConvolution,
  CICopyMachineTransition,
  CICoreMLModel,
  CICrystallize,
  CIDataMatrixCodeDescriptor,
  CIDepthOfField,
  CIDepthToDisparity,
  CIDetector,
  CIDiscBlur,
  CIDisintegrateWithMaskTransition,
  CIDisparityToDepth,
  CIDissolveTransition,
  CIDither,
  CIDocumentEnhancer,
  CIDotScreen,
  CIEdgePreserveUpsample,
  CIEdgeWork,
  CIEdges,
  CIEightfoldReflectedTile,
  CIExposureAdjust,
  CIFaceFeature,
  CIFalseColor,
  CIFeature,
  CIFilter,
  CIFilterConstructor,
  CIFilterGenerator,
  CIFilterShape,
  CIFlashTransition,
  CIFormat,
  CIFourCoordinateGeometryFilter,
  CIFourfoldReflectedTile,
  CIFourfoldRotatedTile,
  CIFourfoldTranslatedTile,
  CIGaborGradients,
  CIGammaAdjust,
  CIGaussianBlur,
  CIGaussianGradient,
  CIGlideReflectedTile,
  CIGloom,
  CIHatchedScreen,
  CIHeightFieldFromMask,
  CIHexagonalPixellate,
  CIHighlightShadowAdjust,
  CIHueAdjust,
  CIHueSaturationValueGradient,
  CIImage,
  CIImageAccumulator,
  CIImageAutoAdjustmentOption,
  CIImageOption,
  CIImageProcessorInput,
  CIImageProcessorKernel,
  CIImageProcessorOutput,
  CIImageRepresentationOption,
  CIKaleidoscope,
  CIKernel,
  CIKeystoneCorrectionCombined,
  CIKeystoneCorrectionHorizontal,
  CIKeystoneCorrectionVertical,
  CILabDeltaE,
  CILanczosScaleTransform,
  CILenticularHaloGenerator,
  CILineOverlay,
  CILineScreen,
  CILinearGradient,
  CILinearToSRGBToneCurve,
  CIMaskToAlpha,
  CIMaskedVariableBlur,
  CIMaximumComponent,
  CIMedian,
  CIMeshGenerator,
  CIMinimumComponent,
  CIMix,
  CIModTransition,
  CIMorphologyGradient,
  CIMorphologyMaximum,
  CIMorphologyMinimum,
  CIMorphologyRectangleMaximum,
  CIMorphologyRectangleMinimum,
  CIMotionBlur,
  CINoiseReduction,
  CIOpTile,
  CIPDF417BarcodeGenerator,
  CIPDF417CodeDescriptor,
  CIPageCurlTransition,
  CIPageCurlWithShadowTransition,
  CIPaletteCentroid,
  CIPalettize,
  CIParallelogramTile,
  CIPerspectiveCorrection,
  CIPerspectiveRotate,
  CIPerspectiveTile,
  CIPerspectiveTransform,
  CIPerspectiveTransformWithExtent,
  CIPhotoEffect,
  CIPixellate,
  CIPlugIn,
  CIPlugInRegistration,
  CIPointillize,
  CIQRCodeDescriptor,
  CIQRCodeFeature,
  CIQRCodeGenerator,
  CIRAWFilterOption,
  CIRadialGradient,
  CIRandomGenerator,
  CIRectangleFeature,
  CIRenderDestination,
  CIRenderInfo,
  CIRenderTask,
  CIRippleTransition,
  CIRoundedRectangleGenerator,
  CISRGBToneCurveToLinear,
  CISaliencyMap,
  CISampler,
  CISepiaTone,
  CIShadedMaterial,
  CISharpenLuminance,
  CISixfoldReflectedTile,
  CISixfoldRotatedTile,
  CISmoothLinearGradient,
  CISpotColor,
  CISpotLight,
  CIStarShineGenerator,
  CIStraighten,
  CIStripesGenerator,
  CISunbeamsGenerator,
  CISwipeTransition,
  CITemperatureAndTint,
  CITextFeature,
  CITextImageGenerator,
  CIThermal,
  CIToneCurve,
  CITransitionFilter,
  CITriangleKaleidoscope,
  CITriangleTile,
  CITwelvefoldReflectedTile,
  CIUnsharpMask,
  CIVector,
  CIVibrance,
  CIVignette,
  CIVignetteEffect,
  CIWarpKernel,
  CIWhitePointAdjust,
  CIXRay,
  CIZoomBlur,
  CMImageDescriptionFlavor,
  CMSampleTimingInfo,
  CMSoundDescriptionFlavor,
  CMTime,
  CMTimeMapping,
  CMTimeRange,
  CachedURLResponse,
  DateComponentsFormatter,
  DateFormatter,
  DateIntervalFormatter,
  Decimal,
  Dimension,
  DirectoryEnumerator,
  DiscoverySession,
  DistributedNotificationCenter,
  EnergyFormatter,
  FileAttributeKey,
  FileAttributeType,
  FileHandle,
  FileManager,
  FileManagerDelegate,
  FileProtectionType,
  FileWrapper,
  Format,
  Formatter,
  HTTPCookie,
  HTTPCookiePropertyKey,
  HTTPCookieStorage,
  HTTPCookieStringPolicy,
  HTTPURLResponse,
  Host,
  IKCameraDeviceView,
  IKCameraDeviceViewDelegate,
  IKDeviceBrowserView,
  IKDeviceBrowserViewDelegate,
  IKFilterBrowserPanel,
  IKFilterBrowserView,
  IKFilterCustomUIProvider,
  IKFilterUIView,
  IKImageBrowserCell,
  IKImageEditPanel,
  IKImageEditPanelDataSource,
  IKImageView,
  IKPictureTaker,
  IKSaveOptions,
  IKScannerDeviceView,
  IKScannerDeviceViewDelegate,
  IKSlideshow,
  IKSlideshowDataSource,
  ISO8601DateFormatter,
  InputSource,
  InputStream,
  ItemResult,
  JSONSerialization,
  LengthFormatter,
  ListFormatter,
  MassFormatter,
  MeasurementFormatter,
  MessagePort,
  NSATSTypesetter,
  NSAccessibility,
  NSAccessibilityButton,
  NSAccessibilityCheckBox,
  NSAccessibilityContainsTransientUI,
  NSAccessibilityCustomAction,
  NSAccessibilityCustomRotor,
  NSAccessibilityCustomRotorItemSearchDelegate,
  NSAccessibilityElement,
  NSAccessibilityElementLoading,
  NSAccessibilityGroup,
  NSAccessibilityImage,
  NSAccessibilityLayoutArea,
  NSAccessibilityLayoutItem,
  NSAccessibilityList,
  NSAccessibilityNavigableStaticText,
  NSAccessibilityOutline,
  NSAccessibilityProgressIndicator,
  NSAccessibilityRadioButton,
  NSAccessibilityRow,
  NSAccessibilitySlider,
  NSAccessibilityStaticText,
  NSAccessibilityStepper,
  NSAccessibilitySwitch,
  NSAccessibilityTable,
  NSActionCell,
  NSAffineTransform,
  NSAlert,
  NSAlertDelegate,
  NSAlignmentFeedbackFilter,
  NSAlignmentFeedbackToken,
  NSAnimatablePropertyContainer,
  NSAnimation,
  NSAnimationContext,
  NSAnimationDelegate,
  NSAppKitVersion,
  NSAppearance,
  NSAppearanceCustomization,
  NSAppleEventDescriptor,
  NSAppleEventManager,
  NSAppleScript,
  NSApplication,
  NSApplicationDelegate,
  NSArray,
  NSArrayController,
  NSAssertionHandler,
  NSAsynchronousFetchRequest,
  NSAsynchronousFetchResult,
  NSAtomicStore,
  NSAtomicStoreCacheNode,
  NSAttributeDescription,
  NSAttributedString,
  NSAutoreleasePool,
  NSBackgroundActivityScheduler,
  NSBatchDeleteRequest,
  NSBatchDeleteResult,
  NSBatchInsertRequest,
  NSBatchInsertResult,
  NSBatchUpdateRequest,
  NSBatchUpdateResult,
  NSBezierPath,
  NSBindingInfoKey,
  NSBindingName,
  NSBindingOption,
  NSBindingSelectionMarker,
  NSBitmapImageRep,
  NSBox,
  NSBrowser,
  NSBrowserCell,
  NSBrowserDelegate,
  NSButton,
  NSButtonCell,
  NSButtonTouchBarItem,
  NSCIImageRep,
  NSCache,
  NSCacheDelegate,
  NSCalendar,
  NSCandidateListTouchBarItem,
  NSCandidateListTouchBarItemDelegate,
  NSCell,
  NSChangeSpelling,
  NSCharacterSet,
  NSClassDescription,
  NSClickGestureRecognizer,
  NSClipView,
  NSCloneCommand,
  NSCloseCommand,
  NSCloudSharingServiceDelegate,
  NSCloudSharingValidation,
  NSCoder,
  NSCoding,
  NSCollectionLayoutAnchor,
  NSCollectionLayoutBoundarySupplementaryItem,
  NSCollectionLayoutContainer,
  NSCollectionLayoutDecorationItem,
  NSCollectionLayoutDimension,
  NSCollectionLayoutEdgeSpacing,
  NSCollectionLayoutEnvironment,
  NSCollectionLayoutGroup,
  NSCollectionLayoutGroupCustomItem,
  NSCollectionLayoutItem,
  NSCollectionLayoutSection,
  NSCollectionLayoutSize,
  NSCollectionLayoutSpacing,
  NSCollectionLayoutSupplementaryItem,
  NSCollectionLayoutVisibleItem,
  NSCollectionView,
  NSCollectionViewCompositionalLayout,
  NSCollectionViewCompositionalLayoutConfiguration,
  NSCollectionViewDataSource,
  NSCollectionViewDelegate,
  NSCollectionViewDelegateFlowLayout,
  NSCollectionViewDiffableDataSourceReference,
  NSCollectionViewElement,
  NSCollectionViewFlowLayout,
  NSCollectionViewFlowLayoutInvalidationContext,
  NSCollectionViewGridLayout,
  NSCollectionViewItem,
  NSCollectionViewLayout,
  NSCollectionViewLayoutAttributes,
  NSCollectionViewLayoutInvalidationContext,
  NSCollectionViewPrefetching,
  NSCollectionViewSectionHeaderView,
  NSCollectionViewTransitionLayout,
  NSCollectionViewUpdateItem,
  NSColor,
  NSColorChanging,
  NSColorList,
  NSColorPanel,
  NSColorPicker,
  NSColorPickerTouchBarItem,
  NSColorPickingCustom,
  NSColorPickingDefault,
  NSColorSampler,
  NSColorSpace,
  NSColorSpaceName,
  NSColorWell,
  NSComboBox,
  NSComboBoxCell,
  NSComboBoxCellDataSource,
  NSComboBoxDataSource,
  NSComboBoxDelegate,
  NSComparisonPredicate,
  NSCompoundPredicate,
  NSCondition,
  NSConditionLock,
  NSConstraintConflict,
  NSControl,
  NSControlTextEditingDelegate,
  NSController,
  NSCopying,
  NSCoreDataCoreSpotlightDelegate,
  NSCountCommand,
  NSCountedSet,
  NSCreateCommand,
  NSCursor,
  NSCustomImageRep,
  NSCustomTouchBarItem,
  NSData,
  NSDataAsset,
  NSDataDetector,
  NSDate,
  NSDateComponents,
  NSDateInterval,
  NSDatePicker,
  NSDatePickerCell,
  NSDatePickerCellDelegate,
  NSDecimalNumber,
  NSDecimalNumberBehaviors,
  NSDecimalNumberHandler,
  NSDeleteCommand,
  NSDerivedAttributeDescription,
  NSDeviceDescriptionKey,
  NSDictionary,
  NSDictionaryController,
  NSDictionaryControllerKeyValuePair,
  NSDiffableDataSourceSnapshotReference,
  NSDiscardableContent,
  NSDistributedLock,
  NSDockTile,
  NSDockTilePlugIn,
  NSDocument,
  NSDocumentController,
  NSDraggingDestination,
  NSDraggingImageComponent,
  NSDraggingInfo,
  NSDraggingItem,
  NSDraggingSession,
  NSDraggingSource,
  NSDrawer,
  NSDrawerDelegate,
  NSEPSImageRep,
  NSEditor,
  NSEditorRegistration,
  NSEntityDescription,
  NSEntityMapping,
  NSEntityMigrationPolicy,
  NSEnumerator,
  NSError,
  NSEvent,
  NSException,
  NSExceptionName,
  NSExistsCommand,
  NSExpression,
  NSExpressionDescription,
  NSExtensionContext,
  NSExtensionItem,
  NSExtensionRequestHandling,
  NSFastEnumeration,
  NSFetchIndexDescription,
  NSFetchIndexElementDescription,
  NSFetchRequest,
  NSFetchRequestExpression,
  NSFetchRequestResult,
  NSFetchedPropertyDescription,
  NSFetchedResultsController,
  NSFetchedResultsControllerDelegate,
  NSFetchedResultsSectionInfo,
  NSFileAccessIntent,
  NSFileCoordinator,
  NSFilePresenter,
  NSFilePromiseProvider,
  NSFilePromiseProviderDelegate,
  NSFilePromiseReceiver,
  NSFileProviderService,
  NSFileSecurity,
  NSFileVersion,
  NSFont,
  NSFontAssetRequest,
  NSFontChanging,
  NSFontCollection,
  NSFontDescriptor,
  NSFontManager,
  NSFontPanel,
  NSFormCell,
  NSGestureRecognizer,
  NSGestureRecognizerDelegate,
  NSGetCommand,
  NSGlyphGenerator,
  NSGlyphInfo,
  NSGlyphStorage,
  NSGradient,
  NSGraphicsContext,
  NSGridCell,
  NSGridColumn,
  NSGridRow,
  NSGridView,
  NSGroupTouchBarItem,
  NSHapticFeedbackManager,
  NSHapticFeedbackPerformer,
  NSHashTable,
  NSHelpManager,
  NSIgnoreMisspelledWords,
  NSImage,
  NSImageCell,
  NSImageDelegate,
  NSImageRep,
  NSImageView,
  NSIncrementalStore,
  NSIncrementalStoreNode,
  NSIndexPath,
  NSIndexSet,
  NSIndexSpecifier,
  NSInputServerMouseTracker,
  NSInputServiceProvider,
  NSItemProvider,
  NSItemProviderReading,
  NSItemProviderWriting,
  NSKeyValueChangeKey,
  NSKeyValueOperator,
  NSKeyedArchiver,
  NSKeyedArchiverDelegate,
  NSKeyedUnarchiver,
  NSKeyedUnarchiverDelegate,
  NSLayoutAnchor,
  NSLayoutConstraint,
  NSLayoutDimension,
  NSLayoutGuide,
  NSLayoutManager,
  NSLayoutManagerDelegate,
  NSLayoutXAxisAnchor,
  NSLayoutYAxisAnchor,
  NSLevelIndicator,
  NSLevelIndicatorCell,
  NSLinguisticTag,
  NSLinguisticTagScheme,
  NSLinguisticTagger,
  NSLocale,
  NSLock,
  NSLocking,
  NSLogicalTest,
  NSMachPort,
  NSMachPortDelegate,
  NSMagnificationGestureRecognizer,
  NSManagedObject,
  NSManagedObjectContext,
  NSManagedObjectID,
  NSManagedObjectModel,
  NSMapTable,
  NSMappingModel,
  NSMatrix,
  NSMatrixDelegate,
  NSMeasurement,
  NSMediaLibraryBrowserController,
  NSMenu,
  NSMenuDelegate,
  NSMenuItem,
  NSMenuItemCell,
  NSMenuItemValidation,
  NSMenuToolbarItem,
  NSMergeConflict,
  NSMergePolicy,
  NSMetadataItem,
  NSMetadataQuery,
  NSMetadataQueryAttributeValueTuple,
  NSMetadataQueryDelegate,
  NSMetadataQueryResultGroup,
  NSMiddleSpecifier,
  NSMigrationManager,
  NSMoveCommand,
  NSMutableArray,
  NSMutableAttributedString,
  NSMutableCharacterSet,
  NSMutableCopying,
  NSMutableData,
  NSMutableDictionary,
  NSMutableFontCollection,
  NSMutableIndexSet,
  NSMutableOrderedSet,
  NSMutableParagraphStyle,
  NSMutableSet,
  NSMutableString,
  NSMutableURLRequest,
  NSNameSpecifier,
  NSNib,
  NSNotification,
  NSNull,
  NSNumber,
  NSObjectController,
  NSOpenPanel,
  NSOpenSavePanelDelegate,
  NSOrderedCollectionChange,
  NSOrderedCollectionDifference,
  NSOrderedSet,
  NSOrthography,
  NSOutlineView,
  NSOutlineViewDataSource,
  NSOutlineViewDelegate,
  NSPDFImageRep,
  NSPDFInfo,
  NSPDFPanel,
  NSPICTImageRep,
  NSPageController,
  NSPageControllerDelegate,
  NSPageLayout,
  NSPanGestureRecognizer,
  NSPanel,
  NSParagraphStyle,
  NSPasteboard,
  NSPasteboardItem,
  NSPasteboardItemDataProvider,
  NSPasteboardReading,
  NSPasteboardTypeOwner,
  NSPasteboardWriting,
  NSPathCell,
  NSPathCellDelegate,
  NSPathComponentCell,
  NSPathControl,
  NSPathControlDelegate,
  NSPathControlItem,
  NSPersistentCloudKitContainer,
  NSPersistentCloudKitContainerOptions,
  NSPersistentContainer,
  NSPersistentDocument,
  NSPersistentHistoryChange,
  NSPersistentHistoryChangeRequest,
  NSPersistentHistoryResult,
  NSPersistentHistoryToken,
  NSPersistentHistoryTransaction,
  NSPersistentStore,
  NSPersistentStoreAsynchronousResult,
  NSPersistentStoreCoordinator,
  NSPersistentStoreDescription,
  NSPersistentStoreRequest,
  NSPersistentStoreResult,
  NSPersonNameComponents,
  NSPickerTouchBarItem,
  NSPointerArray,
  NSPointerFunctions,
  NSPopUpButton,
  NSPopUpButtonCell,
  NSPopover,
  NSPopoverDelegate,
  NSPopoverTouchBarItem,
  NSPositionalSpecifier,
  NSPredicate,
  NSPredicateEditor,
  NSPredicateEditorRowTemplate,
  NSPressGestureRecognizer,
  NSPressureConfiguration,
  NSPrintInfo,
  NSPrintOperation,
  NSPrintPanel,
  NSPrintPanelAccessorizing,
  NSPrinter,
  NSProgressIndicator,
  NSPropertyDescription,
  NSPropertyMapping,
  NSPropertySpecifier,
  NSProtocolChecker,
  NSProxy,
  NSPurgeableData,
  NSQueryGenerationToken,
  NSQuitCommand,
  NSRandomSpecifier,
  NSRangeSpecifier,
  NSRecursiveLock,
  NSRegularExpression,
  NSRelationshipDescription,
  NSRelativeSpecifier,
  NSResponder,
  NSRotationGestureRecognizer,
  NSRuleEditor,
  NSRuleEditorDelegate,
  NSRulerMarker,
  NSRulerView,
  NSRunningApplication,
  NSSaveChangesRequest,
  NSSavePanel,
  NSScreen,
  NSScriptClassDescription,
  NSScriptCoercionHandler,
  NSScriptCommand,
  NSScriptCommandDescription,
  NSScriptExecutionContext,
  NSScriptObjectSpecifier,
  NSScriptSuiteRegistry,
  NSScriptWhoseTest,
  NSScrollView,
  NSScroller,
  NSScrubber,
  NSScrubberArrangedView,
  NSScrubberDataSource,
  NSScrubberDelegate,
  NSScrubberFlowLayout,
  NSScrubberFlowLayoutDelegate,
  NSScrubberImageItemView,
  NSScrubberItemView,
  NSScrubberLayout,
  NSScrubberLayoutAttributes,
  NSScrubberProportionalLayout,
  NSScrubberSelectionStyle,
  NSScrubberSelectionView,
  NSScrubberTextItemView,
  NSSearchField,
  NSSearchFieldCell,
  NSSearchFieldDelegate,
  NSSecureCoding,
  NSSecureTextField,
  NSSecureTextFieldCell,
  NSSecureUnarchiveFromDataTransformer,
  NSSegmentedCell,
  NSSegmentedControl,
  NSSeguePerforming,
  NSServicesMenuRequestor,
  NSSet,
  NSSetCommand,
  NSShadow,
  NSSharingService,
  NSSharingServiceDelegate,
  NSSharingServicePicker,
  NSSharingServicePickerDelegate,
  NSSharingServicePickerToolbarItem,
  NSSharingServicePickerToolbarItemDelegate,
  NSSharingServicePickerTouchBarItem,
  NSSharingServicePickerTouchBarItemDelegate,
  NSSlider,
  NSSliderAccessory,
  NSSliderAccessoryBehavior,
  NSSliderCell,
  NSSliderTouchBarItem,
  NSSortDescriptor,
  NSSound,
  NSSoundDelegate,
  NSSpecifierTest,
  NSSpeechRecognizer,
  NSSpeechRecognizerDelegate,
  NSSpeechSynthesizer,
  NSSpeechSynthesizerDelegate,
  NSSpellChecker,
  NSSpellServer,
  NSSpellServerDelegate,
  NSSplitView,
  NSSplitViewController,
  NSSplitViewDelegate,
  NSSplitViewItem,
  NSSpringLoadingDestination,
  NSStackView,
  NSStackViewDelegate,
  NSStandardKeyBindingResponding,
  NSStatusBar,
  NSStatusBarButton,
  NSStatusItem,
  NSStepper,
  NSStepperCell,
  NSStepperTouchBarItem,
  NSStoryboard,
  NSStoryboardSegue,
  NSString,
  NSStringDrawingContext,
  NSSwitch,
  NSTabView,
  NSTabViewController,
  NSTabViewDelegate,
  NSTabViewItem,
  NSTableCellView,
  NSTableColumn,
  NSTableHeaderCell,
  NSTableHeaderView,
  NSTableRowView,
  NSTableView,
  NSTableViewDataSource,
  NSTableViewDelegate,
  NSTableViewRowAction,
  NSText,
  NSTextAlternatives,
  NSTextAttachment,
  NSTextAttachmentCell,
  NSTextAttachmentContainer,
  NSTextBlock,
  NSTextCheckingClient,
  NSTextCheckingController,
  NSTextCheckingKey,
  NSTextCheckingResult,
  NSTextContainer,
  NSTextDelegate,
  NSTextField,
  NSTextFieldCell,
  NSTextFieldDelegate,
  NSTextFinder,
  NSTextFinderBarContainer,
  NSTextFinderClient,
  NSTextInput,
  NSTextInputClient,
  NSTextInputContext,
  NSTextInputTraits,
  NSTextLayoutOrientationProvider,
  NSTextList,
  NSTextStorage,
  NSTextStorageDelegate,
  NSTextTab,
  NSTextTable,
  NSTextTableBlock,
  NSTextView,
  NSTextViewDelegate,
  NSTimeZone,
  NSTitlebarAccessoryViewController,
  NSTokenField,
  NSTokenFieldCell,
  NSTokenFieldCellDelegate,
  NSTokenFieldDelegate,
  NSToolbar,
  NSToolbarDelegate,
  NSToolbarItem,
  NSToolbarItemGroup,
  NSToolbarItemValidation,
  NSTouch,
  NSTouchBar,
  NSTouchBarDelegate,
  NSTouchBarItem,
  NSTouchBarProvider,
  NSTrackingArea,
  NSTreeController,
  NSTreeNode,
  NSTypesetter,
  NSURL,
  NSURLComponents,
  NSURLConnection,
  NSURLConnectionDataDelegate,
  NSURLConnectionDelegate,
  NSURLConnectionDownloadDelegate,
  NSURLDownload,
  NSURLDownloadDelegate,
  NSURLHandle,
  NSURLQueryItem,
  NSURLRequest,
  NSURLSessionWebSocketMessage,
  NSUUID,
  NSUbiquitousKeyValueStore,
  NSUniqueIDSpecifier,
  NSUnitInformationStorage,
  NSUserActivity,
  NSUserActivityDelegate,
  NSUserActivityRestoring,
  NSUserAppleScriptTask,
  NSUserAutomatorTask,
  NSUserDefaultsController,
  NSUserInterfaceCompression,
  NSUserInterfaceCompressionOptions,
  NSUserInterfaceItemIdentification,
  NSUserInterfaceItemSearching,
  NSUserInterfaceValidations,
  NSUserNotification,
  NSUserNotificationAction,
  NSUserNotificationCenter,
  NSUserNotificationCenterDelegate,
  NSUserScriptTask,
  NSUserUnixTask,
  NSValidatedUserInterfaceItem,
  NSValue,
  NSValueTransformerName,
  NSView,
  NSViewAnimation,
  NSViewController,
  NSViewControllerPresentationAnimator,
  NSViewLayerContentScaleDelegate,
  NSViewToolTipOwner,
  NSVisualEffectView,
  NSWhoseSpecifier,
  NSWindow,
  NSWindowController,
  NSWindowDelegate,
  NSWindowRestoration,
  NSWindowTab,
  NSWindowTabGroup,
  NSWorkspace,
  NSXPCCoder,
  NSXPCConnection,
  NSXPCInterface,
  NSXPCListener,
  NSXPCListenerDelegate,
  NSXPCListenerEndpoint,
  NSXPCProxyCreating,
  NetService,
  NetServiceBrowser,
  NetServiceBrowserDelegate,
  NetServiceDelegate,
  NotificationCenter,
  NotificationQueue,
  NumberFormatter,
  OpenConfiguration,
  Operation,
  OperationQueue,
  OutputStream,
  PersonNameComponentsFormatter,
  Pipe,
  Port,
  PortDelegate,
  PortMessage,
  Process,
  ProcessInfo,
  Progress,
  ProgressKind,
  ProgressReporting,
  ProgressUserInfoKey,
  PropertyListSerialization,
  QLPreviewItem,
  QLPreviewPanel,
  QLPreviewPanelDataSource,
  QLPreviewPanelDelegate,
  QLPreviewView,
  QLPreviewingController,
  QuartzFilter,
  QuartzFilterManager,
  QuartzFilterView,
  RelativeDateTimeFormatter,
  RunLoop,
  Scanner,
  SearchParameters,
  SocketPort,
  Stream,
  StreamDelegate,
  StreamNetworkServiceTypeValue,
  StreamSOCKSProxyConfiguration,
  StreamSOCKSProxyVersion,
  StreamSocketSecurityLevel,
  StringEncodingDetectionOptionsKey,
  StringTransform,
  SystemPressureState,
  Thread,
  Timer,
  URLAuthenticationChallenge,
  URLAuthenticationChallengeSender,
  URLCache,
  URLCredential,
  URLCredentialStorage,
  URLFileProtection,
  URLFileResourceType,
  URLProtectionSpace,
  URLProtocol,
  URLProtocolClient,
  URLResourceKey,
  URLResponse,
  URLSession,
  URLSessionConfiguration,
  URLSessionDataDelegate,
  URLSessionDataTask,
  URLSessionDelegate,
  URLSessionDownloadDelegate,
  URLSessionDownloadTask,
  URLSessionStreamDelegate,
  URLSessionStreamTask,
  URLSessionTask,
  URLSessionTaskDelegate,
  URLSessionTaskMetrics,
  URLSessionTaskTransactionMetrics,
  URLSessionUploadTask,
  URLSessionWebSocketDelegate,
  URLSessionWebSocketTask,
  URLThumbnailDictionaryItem,
  URLUbiquitousItemDownloadingStatus,
  URLUbiquitousSharedItemPermissions,
  URLUbiquitousSharedItemRole,
  UndoManager,
  Unit,
  UnitAcceleration,
  UnitAngle,
  UnitArea,
  UnitConcentrationMass,
  UnitConverter,
  UnitConverterLinear,
  UnitDispersion,
  UnitDuration,
  UnitElectricCharge,
  UnitElectricCurrent,
  UnitElectricPotentialDifference,
  UnitElectricResistance,
  UnitEnergy,
  UnitFrequency,
  UnitFuelEfficiency,
  UnitIlluminance,
  UnitLength,
  UnitMass,
  UnitPower,
  UnitPressure,
  UnitSpeed,
  UnitTemperature,
  UnitVolume,
  UserDefaults,
  ValueTransformer,
  XMLDTD,
  XMLDTDNode,
  XMLDocument,
  XMLElement,
  XMLNode,
  XMLParser,
  XMLParserDelegate
};
